<html><head></head><body><section data-pdf-bookmark="Chapter 2. TypeScript&#x2019;s Type System" data-type="chapter" epub:type="chapter" class="praise"><div class="praise" id="ch-types">
<h1 class="calibre14"><span class="calibre">Chapter 2. </span>TypeScript’s Type System</h1>


<p class="author1">TypeScript generates code (<a href="ch01.html#independent" class="calibre9">Item 3</a>), but the type system is the main event. This is why you’re using the language!</p>

<p class="author1">This chapter walks you through the nuts and bolts of TypeScript’s type system: how to think about it, how to use it, choices you’ll need to make, and features you should avoid. TypeScript’s type system is surprisingly powerful and able to express things you might not expect a type system to be able to. The items in this chapter will give you a solid foundation to build upon as you write TypeScript and read the rest of this book.</p>






<section data-pdf-bookmark="Item 6: Use Your Editor to Interrogate and Explore the Type System" data-type="sect1" class="praise"><div class="praise" id="editor">
<h1 class="calibre16">Item 6: Use Your Editor to Interrogate and Explore the Type System</h1>

<p class="author1">When<a data-primary="type system" data-secondary="using editors to interrogate and explore" data-type="indexterm" id="TSeditor02" class="calibre9"/><a data-primary="editors, using to interrogate and explore type system" data-type="indexterm" id="Einterr02" class="calibre9"/> you install TypeScript, you get two executables:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1"><code class="calibre18">tsc</code>, the TypeScript compiler</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">tsserver</code>, the TypeScript standalone server</p>
</li>
</ul>

<p class="author1">You’re<a data-primary="language services" data-secondary="components of" data-type="indexterm" id="idm45331677447448" class="calibre9"/> much more likely to run the TypeScript compiler directly, but the server is every bit as important because it provides <em class="calibre3">language services</em>. These include autocomplete, inspection, navigation, and refactoring. You typically use these services through your editor. If yours isn’t configured to provide them, then you’re missing out! Services like autocomplete are one of the things that make TypeScript such a joy to use. But beyond convenience, your editor is the best place to build and test your knowledge of the type system. This will help you build an intuition for when TypeScript is able to infer types, which is key to writing compact, idiomatic code (see <a href="ch03.html#avoid-inferable" class="calibre9">Item 19</a>).</p>

<p class="author1">The details will vary from editor to editor, but you can generally mouse over a symbol to see what TypeScript considers its type (see <a data-type="xref" href="ch02_split_000.html#efts-02in01" class="calibre9">Figure 2-1</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-02in01">
<img alt="efts 02in01" src="assets/efts_02in01.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-1. </span>An editor (vscode) showing that the inferred type of the num symbol is <span class="calibre">number</span></h6>
</div></figure>

<p class="author1">You didn’t write <code class="calibre18">number</code> here, but TypeScript was able to figure it out based on the value 10.</p>

<p class="author1">You<a data-primary="functions" data-secondary="inspecting with editors" data-type="indexterm" id="idm45331677439320" class="calibre9"/> can also inspect functions, as shown in <a data-type="xref" href="ch02_split_000.html#hover1" class="calibre9">Figure 2-2</a>.</p>

<figure class="calibre28"><div class="figure" id="hover1">
<img alt="efts 0201" src="assets/efts_0201.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-2. </span>Using an editor to reveal the inferred type for a function</h6>
</div></figure>

<p class="author1">The noteworthy bit of information is the inferred value for the return type, <code class="calibre18">number</code>. If this does not match your expectation, you should add a type declaration and track down the discrepancy (see <a href="ch02_split_000.html#prefer-declarations-to-assertions" class="calibre9">Item 9</a>).</p>

<p class="author1">Seeing TypeScript’s understanding of a variable’s type at any given point is essential for building an intuition around widening (<a href="ch03.html#widening" class="calibre9">Item 21</a>) and narrowing (<a href="ch03.html#narrowing" class="calibre9">Item 22</a>). Seeing the type of a variable change in the branch of a conditional is a tremendous way to build confidence in the type system (see <a data-type="xref" href="ch02_split_000.html#editor-narrowing" class="calibre9">Figure 2-3</a>).</p>

<figure class="calibre28"><div class="figure" id="editor-narrowing">
<img alt="efts 0202" src="assets/efts_0202.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-3. </span>The type of message is string | null outside the branch but string inside.</h6>
</div></figure>

<p class="author1">You can inspect individual properties in a larger object to see what TypeScript has inferred about them (see <a data-type="xref" href="ch02_split_000.html#inferred-in-property" class="calibre9">Figure 2-4</a>).</p>

<figure class="calibre28"><div class="figure" id="inferred-in-property">
<img alt="efts 0203" src="assets/efts_0203.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-4. </span>Inspecting how TypeScript has inferred types in an object</h6>
</div></figure>

<p class="author1">If your intention was for <code class="calibre18">x</code> to be a tuple type (<code class="calibre18">[number, number, number]</code>), then a type annotation will be required.</p>

<p class="author1">To see inferred generic types in the middle of a chain of operations, inspect the method name (as shown in <a data-type="xref" href="ch02_split_000.html#infer-generics" class="calibre9">Figure 2-5</a>).</p>

<figure class="calibre28"><div class="figure" id="infer-generics">
<img alt="efts 0204" src="assets/efts_0204.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-5. </span>Revealing inferred generic types in a chain of method calls</h6>
</div></figure>

<p class="author1">The <code class="calibre18">Array&lt;string&gt;</code> indicates that TypeScript understands that <code class="calibre18">split</code> produced an array of strings. While there was little ambiguity in this case, this information can prove essential in writing and debugging long chains of function calls.</p>

<p class="author1">Seeing type errors in your editor can also be a great way to learn the nuances of the type system. For example, this function tries to get an <code class="calibre18">HTMLElement</code> by its ID, or return a default one. TypeScript flags two errors:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getElement</code><code class="p">(</code><code class="nx">elOrId</code>: <code class="kd">string</code><code class="o">|</code><code class="nx">HTMLElement</code><code class="o">|</code><code class="nx">null</code><code class="p">)</code><code class="o">:</code> <code class="nx">HTMLElement</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="kd">typeof</code> <code class="nx">elOrId</code> <code class="o">===</code> <code class="s">'object'</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">elOrId</code><code class="p">;</code>
 <code class="c">// ~~~~~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">elOrId</code> <code class="o">===</code> <code class="kd">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="nx">elOrId</code><code class="p">);</code>
    <code class="kd">return</code> <code class="nx">el</code><code class="p">;</code>
 <code class="c">// ~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">The intent in the first branch of the <code class="calibre18">if</code> statement was to filter down to just the objects, namely, the <code class="calibre18">HTMLElement</code>s. But oddly enough, in JavaScript <code class="calibre18">typeof null</code> is <code class="calibre18">"object"</code>, so <code class="calibre18">elOrId</code> could still be <code class="calibre18">null</code> in that branch. You can fix this by putting the <code class="calibre18">null</code> check first. The second error is because <code class="calibre18">document.getElementById</code> can return <code class="calibre18">null</code>, so you need to handle that case as well, perhaps by throwing an exception.</p>

<p class="author1">Language services<a data-primary="libraries" data-secondary="navigating libraries and type declarations" data-type="indexterm" id="idm45331677364328" class="calibre9"/><a data-primary="language services" data-secondary="navigating libraries and type declarations" data-type="indexterm" id="idm45331677363224" class="calibre9"/><a data-primary="type declaration" data-secondary="navigating with language services" data-type="indexterm" id="idm45331677362248" class="calibre9"/> can also help you navigate through libraries and type declarations. Suppose you see a call to the <code class="calibre18">fetch</code> function in code and want to learn more about it. Your editor should provide a “Go to Definition” option. In mine it looks like it does in <a data-type="xref" href="ch02_split_000.html#efts-02in02" class="calibre9">Figure 2-6</a>.</p>

<figure class="calibre28"><div class="figure" id="efts-02in02">
<img alt="efts 02in02" src="assets/efts_02in02.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-6. </span>The TypeScript language service provides a “Go to Definition” feature that should be surfaced in your editor.</h6>
</div></figure>

<p class="author1">Selecting this option takes you into <code class="calibre18">lib.dom.d.ts</code>, the type declarations which TypeScript includes for the DOM:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">fetch</code><code class="p">(</code>
  <code class="nx">input</code>: <code class="nx">RequestInfo</code><code class="p">,</code> <code class="nx">init?</code>: <code class="nx">RequestInit</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code><code class="p">;</code></pre>

<p class="author1">You can see that <code class="calibre18">fetch</code> returns a <code class="calibre18">Promise</code> and takes two arguments. Clicking through on <code class="calibre18">RequestInfo</code> brings you here:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">RequestInfo</code> <code class="o">=</code> <code class="nx">Request</code> <code class="o">|</code> <code class="kt">string</code><code class="p">;</code></pre>

<p class="author1">from which you can go to <code class="calibre18">Request</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">var</code> <code class="nx">Request</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">prototype</code>: <code class="nx">Request</code><code class="p">;</code>
    <code class="kd">new</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">RequestInfo</code><code class="p">,</code> <code class="nx">init?</code>: <code class="nx">RequestInit</code><code class="p">)</code><code class="o">:</code> <code class="nx">Request</code><code class="p">;</code>
<code class="p">};</code></pre>

<p class="author1">Here you can see that the <code class="calibre18">Request</code> type and value are being modeled separately (see <a href="ch02_split_000.html#type-value-space" class="calibre9">Item 8</a>). You’ve seen <code class="calibre18">RequestInfo</code> already. Clicking through on <code class="calibre18">RequestInit</code> shows everything you can use to construct a <code class="calibre18">Request</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">RequestInit</code> <code class="p">{</code>
    <code class="nx">body?</code>: <code class="nx">BodyInit</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
    <code class="nx">cache?</code>: <code class="nx">RequestCache</code><code class="p">;</code>
    <code class="nx">credentials?</code>: <code class="nx">RequestCredentials</code><code class="p">;</code>
    <code class="nx">headers?</code>: <code class="nx">HeadersInit</code><code class="p">;</code>
    <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">There are many more types you could follow here, but you get the idea. Type declarations can be challenging to read at first, but they’re an excellent way to see what can be done with TypeScript, how the library you’re using is modeled, and how you might debug errors. For much more on type declarations, see <a data-type="xref" href="ch06.html#ch-declarations" class="calibre9">Chapter 6</a>.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331677194136">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Take advantage of the TypeScript language services by using an editor that can use them.</p>
</li>
<li class="calibre12">
<p class="author1">Use your editor to build an intuition for how the type system works and how TypeScript infers types.</p>
</li>
<li class="calibre12">
<p class="author1">Know how to jump into type declaration files to see how they model behavior.<a data-primary="" data-startref="TSeditor02" data-type="indexterm" id="idm45331677167176" class="calibre9"/><a data-primary="" data-startref="Einterr02" data-type="indexterm" id="idm45331677166104" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 7: Think of Types as Sets of Values" data-type="sect1" class="praise"><div class="praise" id="types-as-sets">
<h1 class="calibre16">Item 7: Think of Types as Sets of Values</h1>

<p class="author1">At<a data-primary="type system" data-secondary="types as set values" data-type="indexterm" id="TSset02" class="calibre9"/><a data-primary="values" data-secondary="types as set values" data-type="indexterm" id="Vtypes02" class="calibre9"/><a data-primary="domain of a type" data-type="indexterm" id="dom02" class="calibre9"/><a data-primary="type domains" data-type="indexterm" id="tydom02" class="calibre9"/> runtime, every variable has a single value chosen from JavaScript’s universe of values. There are many possible values, including:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1"><code class="calibre18">42</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">null</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">undefined</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">'Canada'</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">{animal: 'Whale', weight_lbs: 40_000}</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">/regex/</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">new HTMLButtonElement</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">(x, y) =&gt; x + y</code></p>
</li>
</ul>

<p class="author1">But before your code runs, when TypeScript is checking it for errors, it just has a <em class="calibre3">type</em>. This is best thought of as a <em class="calibre3">set of possible values</em>. This set is known as the <em class="calibre3">domain</em> of the type. For instance, you can think of the <code class="calibre18">number</code> type as the set of all number values. <code class="calibre18">42</code> and <code class="calibre18">-37.25</code> are in it, but <code class="calibre18">'Canada'</code> is not. Depending on <code class="calibre18">strictNullChecks</code>, <code class="calibre18">null</code> and <code class="calibre18">undefined</code> may or may not be part of the set.</p>

<p class="author1">The smallest set is the empty set, which contains no values. It corresponds to the <code class="calibre18">never</code> type in TypeScript. Because its domain is empty, no values are assignable to a variable with a <code class="calibre18">never</code> type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code>: <code class="nx">never</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
   <code class="c">// ~ Type '12' is not assignable to type 'never'</code></pre>

<p class="author1">The next smallest sets are those which contain single values. These correspond to literal types in TypeScript, also known as unit types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="s">'A'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="s">'B'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">Twelve</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code></pre>

<p class="author1">To form types with two or three values, you can union unit types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">AB</code> <code class="o">=</code> <code class="s">'A'</code> <code class="o">|</code> <code class="s">'B'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">AB12</code> <code class="o">=</code> <code class="s">'A'</code> <code class="o">|</code> <code class="s">'B'</code> <code class="o">|</code> <code class="mi">12</code><code class="p">;</code></pre>

<p class="author1">and so on. Union types correspond to unions of sets of values.</p>

<p class="author1">The<a data-primary="assignable to" data-type="indexterm" id="idm45331677052872" class="calibre9"/> word “assignable” appears in many TypeScript errors. In the context of sets of values, it means either “member of” (for a relationship between a value and a type) or “subset of” (for a relationship between two types):</p>

<pre data-code-language="ts" data-type="programlisting" id="ab-not-c" class="calibre17"><code class="kd">const</code> <code class="nx">a</code>: <code class="nx">AB</code> <code class="o">=</code> <code class="s">'A'</code><code class="p">;</code>  <code class="c">// OK, value 'A' is a member of the set {'A', 'B'}</code>
<code class="kd">const</code> <code class="nx">c</code>: <code class="nx">AB</code> <code class="o">=</code> <code class="s">'C'</code><code class="p">;</code>
   <code class="c">// ~ Type '"C"' is not assignable to type 'AB'</code></pre>

<p class="author1">The type <code class="calibre18">"C"</code> is a unit type. Its domain consists of the single value <code class="calibre18">"C"</code>. This is not a subset of the domain of <code class="calibre18">AB</code> (which consists of the values <code class="calibre18">"A"</code> and <code class="calibre18">"B"</code>), so this is an error. At the end of the day, almost all the type checker is doing is testing whether one set is a subset of another:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// OK, {"A", "B"} is a subset of {"A", "B"}:</code>
<code class="kd">const</code> <code class="nx">ab</code>: <code class="nx">AB</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code> <code class="o">?</code> <code class="s">'A'</code> <code class="o">:</code> <code class="s">'B'</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">ab12</code>: <code class="nx">AB12</code> <code class="o">=</code> <code class="nx">ab</code><code class="p">;</code>  <code class="c">// OK, {"A", "B"} is a subset of {"A", "B", 12}</code>

<code class="kd">declare</code> <code class="kd">let</code> <code class="nx">twelve</code>: <code class="nx">AB12</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">back</code>: <code class="nx">AB</code> <code class="o">=</code> <code class="nx">twelve</code><code class="p">;</code>
   <code class="c">// ~~~~ Type 'AB12' is not assignable to type 'AB'</code>
   <code class="c">//        Type '12' is not assignable to type 'AB'</code></pre>

<p class="author1">The sets for these types are easy to reason about because they are finite. But most types that you work with in practice have infinite domains. Reasoning about these can be harder. You can think of them as either being built constructively:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Int</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> <code class="o">|</code> <code class="mi">3</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code> <code class="c">// | ...</code></pre>

<p class="author1">or by describing their members:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Identified</code> <code class="p">{</code>
  <code class="nx">id</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Think of this interface as a description of the values in the domain of its type. Does the value have an <code class="calibre18">id</code> property whose value is assignable to (a member of) <code class="calibre18">string</code>? Then it’s an <code class="calibre18">Identifiable</code>.</p>

<p class="author1">That’s <em class="calibre3">all</em> it says. As <a href="ch01.html#structural" class="calibre9">Item 4</a> explained, TypeScript’s structural typing rules mean that the value could have other properties, too. It could even be callable! This fact can sometimes be obscured by excess property checking (see <a href="ch02_split_001.html#excess-property-checking" class="calibre9">Item 11</a>).</p>

<p class="author1">Thinking of types as sets of values helps you reason about operations on them. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Lifespan</code> <code class="p">{</code>
  <code class="nx">birth</code>: <code class="nx">Date</code><code class="p">;</code>
  <code class="nx">death?</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">PersonSpan</code> <code class="o">=</code> <code class="nx">Person</code> <code class="o">&amp;</code> <code class="nx">Lifespan</code><code class="p">;</code></pre>

<p class="author1">The<a data-primary="&amp; operator" data-type="indexterm" id="idm45331676803944" class="calibre9"/> <code class="calibre18">&amp;</code> operator computes the intersection of two types. What sorts of values belong to the <code class="calibre18">PersonSpan</code> type? On first glance the <code class="calibre18">Person</code> and <code class="calibre18">Lifespan</code> interfaces have no properties in common, so you might expect it to be the empty set (i.e., the <code class="calibre18">never</code> type). But type operations apply to the sets of values (the domain of the type), not to the properties in the interface. And remember that values with additional properties still belong to a type. So a value that has the properties of <em class="calibre3">both</em> <code class="calibre18">Person</code> <em class="calibre3">and</em> <code class="calibre18">Lifespan</code> will<a data-primary="Turing, Alan" data-type="indexterm" id="idm45331676785752" class="calibre9"/> belong to the intersection type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">ps</code>: <code class="kd">Person</code><code class="nx">Span</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Alan Turing'</code><code class="p">,</code>
  <code class="nx">birth</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s">'1912/06/23'</code><code class="p">),</code>
  <code class="nx">death</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s">'1954/06/07'</code><code class="p">),</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">Of course, a value could have more than those three properties and still belong to the type! The general rule is that values in an intersection type contain the union of properties in each of its constituents.</p>

<p class="author1">The intuition about intersecting properties is correct, but for the <em class="calibre3">union</em> of two interfaces, rather than their intersection:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">K</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="p">(</code><code class="nx">Person</code> <code class="o">|</code> <code class="nx">Lifespan</code><code class="p">);</code>  <code class="c">// Type is never</code></pre>

<p class="author1">There are no keys that TypeScript can guarantee belong to a value in the union type, so <code class="calibre18">keyof</code> for the union must be the empty set (<code class="calibre18">never</code>). Or, more formally:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">keyof</code> <code class="p">(</code><code class="nx">A</code><code class="o">&amp;</code><code class="nx">B</code><code class="p">)</code> <code class="o">=</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">A</code><code class="p">)</code> <code class="o">|</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">B</code><code class="p">)</code>
<code class="nx">keyof</code> <code class="p">(</code><code class="nx">A</code><code class="o">|</code><code class="nx">B</code><code class="p">)</code> <code class="o">=</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">A</code><code class="p">)</code> <code class="o">&amp;</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">B</code><code class="p">)</code></pre>

<p class="author1">If you can build an intuition for why these equations hold, you’ll have come a long way toward understanding TypeScript’s type system!</p>

<p class="author1">Another perhaps more common way to write the <code class="calibre18">PersonSpan</code> type would be with <code class="calibre18">extends</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">PersonSpan</code> <code class="kd">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">birth</code>: <code class="nx">Date</code><code class="p">;</code>
  <code class="nx">death?</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Thinking<a data-primary="extends" data-type="indexterm" id="idm45331676624696" class="calibre9"/> of types as sets of values, what does <code class="calibre18">extends</code> mean? Just like “assignable to,” you can read it as “subset of.” Every value in <code class="calibre18">PersonSpan</code> must have a <code class="calibre18">name</code> property which is a <code class="calibre18">string</code>. And every value must also have a <code class="calibre18">birth</code> property, so it’s a proper subset.</p>

<p class="author1">You<a data-primary="subtypes" data-type="indexterm" id="idm45331676621592" class="calibre9"/><a data-primary="subsets" data-type="indexterm" id="idm45331676620856" class="calibre9"/> might hear the term “subtype.” This is another way of saying that one set’s domain is a subset of the others. Thinking in terms of one-, two-, and three-dimensional vectors:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector1D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="kd">extends</code> <code class="nx">Vector1D</code> <code class="p">{</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Vector3D</code> <code class="kd">extends</code> <code class="nx">Vector2D</code> <code class="p">{</code> <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code></pre>

<p class="author1">You’d say that a <code class="calibre18">Vector3D</code> is a subtype of <code class="calibre18">Vector2D</code>, which is a subtype of <code class="calibre18">Vector1D</code> (in the context of classes you’d say “subclass”). This relationship is usually drawn as a hierarchy, but thinking in terms of sets of values, a Venn diagram is more appropriate (see <a data-type="xref" href="ch02_split_000.html#two-waysofthinking" class="calibre9">Figure 2-7</a>).</p>

<figure class="calibre28"><div class="figure" id="two-waysofthinking">
<img alt="efts 0205" src="assets/efts_0205.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-7. </span>Two ways of thinking of type relationships: as a hierarchy or as overlapping sets</h6>
</div></figure>

<p class="author1">With the Venn diagram, it’s clear that the subset/subtype/assignability relationships are unchanged if you rewrite the interfaces without <code class="calibre18">extends</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector1D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Vector3D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code></pre>

<p class="author1">The sets haven’t changed, so neither has the Venn diagram.</p>

<p class="author1">While both interpretations are workable for object types, the set interpretation becomes much more intuitive when you start thinking about literal types and union types. <code class="calibre18">extends</code> can also appear as a constraint in a generic type, and it also means “subset of” in this context (<a href="ch02_split_001.html#map-between-types" class="calibre9">Item 14</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getKey</code><code class="o">&lt;</code><code class="nx">K</code> <code class="kd">extends</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">any</code><code class="p">,</code> <code class="nx">key</code>: <code class="nx">K</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">What does it mean to extend <code class="calibre18">string</code>? If you’re used to thinking in terms of object inheritance, it’s hard to interpret. You could define a subclass of the object wrapper type <code class="calibre18">String</code> (<a href="ch02_split_000.html#avoid-object-wrapper-types" class="calibre9">Item 10</a>), but that seems inadvisable.</p>

<p class="author1">Thinking in terms of sets, on the other hand, it’s crystal clear: any type whose domain is a subset of <code class="calibre18">string</code> will do. This includes string literal types, unions of string literal types and <code class="calibre18">string</code> itself:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">getKey</code><code class="p">({},</code> <code class="s">'x'</code><code class="p">);</code>  <code class="c">// OK, 'x' extends string</code>
<code class="nx">getKey</code><code class="p">({},</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code> <code class="o">?</code> <code class="s">'a'</code> <code class="o">:</code> <code class="s">'b'</code><code class="p">);</code>  <code class="c">// OK, 'a'|'b' extends string</code>
<code class="nx">getKey</code><code class="p">({},</code> <code class="nb">document</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>  <code class="c">// OK, string extends string</code>
<code class="nx">getKey</code><code class="p">({},</code> <code class="mi">12</code><code class="p">);</code>
        <code class="c">// ~~ Type '12' is not assignable to parameter of type 'string'</code></pre>

<p class="author1">“extends” has turned into “assignable” in the last error, but this shouldn’t trip us up since we know to read both as “subset of.” This is also a helpful mindset with finite sets, such the ones you might get from <code class="calibre18">keyof T</code>, which returns type for just the keys of an object type:</p>

<pre data-code-language="ts" data-type="programlisting" id="sort-by" class="calibre17"><code class="kd">interface</code> <code class="nx">Point</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">PointKeys</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="nx">Point</code><code class="p">;</code>  <code class="c">// Type is "x" | "y"</code>

<code class="kd">function</code> <code class="nx">sortBy</code><code class="o">&lt;</code><code class="nx">K</code> <code class="kd">extends</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">vals</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="nx">K</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">[]</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">pts</code>: <code class="nx">Point</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[{</code><code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">1</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">2</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">0</code><code class="p">}];</code>
<code class="nx">sortBy</code><code class="p">(</code><code class="nx">pts</code><code class="p">,</code> <code class="s">'x'</code><code class="p">);</code>  <code class="c">// OK, 'x' extends 'x'|'y' (aka keyof T)</code>
<code class="nx">sortBy</code><code class="p">(</code><code class="nx">pts</code><code class="p">,</code> <code class="s">'y'</code><code class="p">);</code>  <code class="c">// OK, 'y' extends 'x'|'y'</code>
<code class="nx">sortBy</code><code class="p">(</code><code class="nx">pts</code><code class="p">,</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code> <code class="o">?</code> <code class="s">'x'</code> <code class="o">:</code> <code class="s">'y'</code><code class="p">);</code>  <code class="c">// OK, 'x'|'y' extends 'x'|'y'</code>
<code class="nx">sortBy</code><code class="p">(</code><code class="nx">pts</code><code class="p">,</code> <code class="s">'z'</code><code class="p">);</code>
         <code class="c">// ~~~ Type '"z"' is not assignable to parameter of type '"x" | "y"</code></pre>

<p class="author1">The set interpretation also makes more sense when you have types whose relationship isn’t strictly hierarchical. What’s the relationship between <code class="calibre18">string|number</code> and <code class="calibre18">string|Date</code>, for instance? Their intersection is non-empty (it’s <code class="calibre18">string</code>), but neither is a subset of the other. The relationship between their domains is clear, even though these types don’t fit into a strict hierarchy (see <a data-type="xref" href="ch02_split_000.html#union-types" class="calibre9">Figure 2-8</a>).</p>

<figure class="calibre28"><div class="figure" id="union-types">
<img alt="efts 0206" src="assets/efts_0206.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-8. </span>Union types may not fit into a hierarchy but can be thought of in terms of sets of values.</h6>
</div></figure>

<p class="author1">Thinking of types as sets can also clarify the relationships between arrays and tuples. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">list</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">];</code>  <code class="c">// Type is number[]</code>
<code class="kd">const</code> <code class="nx">tuple</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="nx">list</code><code class="p">;</code>
   <code class="c">// ~~~~~ Type 'number[]' is missing the following</code>
   <code class="c">//       properties from type '[number, number]': 0, 1</code></pre>

<p class="author1">Are there lists of numbers which are not pairs of numbers? Sure! The empty list and the list <code class="calibre18">[1]</code> are examples. It therefore makes sense that <code class="calibre18">number[]</code> is not assignable to <code class="calibre18">[number, number]</code> since it’s not a subset of it. (The reverse assignment does work.)</p>

<p class="author1">Is a triple assignable to a pair? Thinking in terms of structural typing, you might expect it to be. A pair has <code class="calibre18">0</code> and <code class="calibre18">1</code> keys, so mightn’t it have others, too, like <code class="calibre18">2</code>?</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">triple</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kd">const</code> <code class="kd">double</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="nx">triple</code><code class="p">;</code>
   <code class="c">// ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'</code>
   <code class="c">//          Types of property 'length' are incompatible</code>
   <code class="c">//          Type '3' is not assignable to type '2'</code></pre>

<p class="author1">The answer is “no,” and for an interesting reason. Rather than modeling a pair of numbers as <code class="calibre18">{0: number, 1: number}</code>, TypeScript models it as <code class="calibre18">{0: number, 1: number, length: 2}</code>. This makes sense—you can check the length of a tuple—and it precludes this assignment. And that’s probably for the best!</p>

<p class="author1">If types are best thought of as sets of values, that means that two types with the same sets of values are the same. And indeed this is true. Unless two types are semantically different and just happen to have the same domain, there’s no reason to define the same type twice.</p>

<p class="author1">Finally, it’s worth noting that not all sets of values correspond to TypeScript types. There is no TypeScript type for all the integers, or for all the objects that have <code class="calibre18">x</code> and <code class="calibre18">y</code> properties but no others. You can sometimes subtract types using <code class="calibre18">Exclude</code>, but only when it would result in a proper TypeScript type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">T</code> <code class="o">=</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">|</code><code class="nb">Date</code><code class="p">,</code> <code class="kt">string</code><code class="o">|</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// Type is Date</code>
<code class="kd">type</code> <code class="nx">NonZeroNums</code> <code class="o">=</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">,</code> <code class="mi">0</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// Type is still just number</code></pre>

<p class="author1"><a data-type="xref" href="ch02_split_000.html#terms-and-set-terms" class="calibre9">Table 2-1</a> summarizes<a data-primary="TypeScript" data-secondary="terms and set terms" data-type="indexterm" id="idm45331676065304" class="calibre9"/> the correspondence between TypeScript terms and terms from set theory.</p>
<table id="terms-and-set-terms" class="calibre34">
<caption class="calibre35"><span class="calibre">Table 2-1. </span>TypeScript terms and set terms</caption>
<thead class="calibre36">
<tr class="calibre37">
<th class="calibre38">TypeScript term</th>
<th class="calibre38">Set term</th>
</tr>
</thead>
<tbody class="calibre39">
<tr class="calibre37">
<td class="calibre40"><p class="author1"><code class="calibre41">never</code></p></td>
<td class="calibre40"><p class="author1">∅ (empty set)</p></td>
</tr>
<tr class="calibre42">
<td class="calibre40"><p class="author1">Literal type</p></td>
<td class="calibre40"><p class="author1">Single element set</p></td>
</tr>
<tr class="calibre37">
<td class="calibre40"><p class="author1">Value assignable to T</p></td>
<td class="calibre40"><p class="author1">Value ∈ T (member of)</p></td>
</tr>
<tr class="calibre42">
<td class="calibre40"><p class="author1">T1 assignable to T2</p></td>
<td class="calibre40"><p class="author1">T1 ⊆ T2 (subset of)</p></td>
</tr>
<tr class="calibre37">
<td class="calibre40"><p class="author1">T1 extends T2</p></td>
<td class="calibre40"><p class="author1">T1 ⊆ T2 (subset of)</p></td>
</tr>
<tr class="calibre42">
<td class="calibre40"><p class="author1">T1 | T2</p></td>
<td class="calibre40"><p class="author1">T1 ∪ T2 (union)</p></td>
</tr>
<tr class="calibre37">
<td class="calibre40"><p class="author1">T1 &amp; T2</p></td>
<td class="calibre40"><p class="author1">T1 ∩ T2 (intersection)</p></td>
</tr>
<tr class="calibre42">
<td class="calibre40"><p class="author1"><code class="calibre41">unknown</code></p></td>
<td class="calibre40"><p class="author1">Universal set</p></td>
</tr>
</tbody>
</table>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331676024152">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Think of types as sets of values (the type’s <em class="calibre3">domain</em>). These sets can either be finite (e.g., <code class="calibre18">boolean</code> or literal types) or infinite (e.g., <code class="calibre18">number</code> or <code class="calibre18">string</code>).</p>
</li>
<li class="calibre12">
<p class="author1">TypeScript types form intersecting sets (a Venn diagram) rather than a strict hierarchy. Two types can overlap without either being a subtype of the other.</p>
</li>
<li class="calibre12">
<p class="author1">Remember that an object can still belong to a type even if it has additional properties that were not mentioned in the type declaration.</p>
</li>
<li class="calibre12">
<p class="author1">Type operations apply to a set’s domain. The intersection of <code class="calibre18">A</code> and <code class="calibre18">B</code> is the intersection of <code class="calibre18">A</code>’s domain and <code class="calibre18">B</code>’s domain. For object types, this means that values in <code class="calibre18">A &amp; B</code> have the properties of both <code class="calibre18">A</code> and <code class="calibre18">B</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Think of “extends,” “assignable to,” and “subtype of” as synonyms for “subset of.”<a data-primary="" data-startref="TSset02" data-type="indexterm" id="idm45331675990376" class="calibre9"/><a data-primary="" data-startref="Vtypes02" data-type="indexterm" id="idm45331675989528" class="calibre9"/><a data-primary="" data-startref="dom02" data-type="indexterm" id="idm45331675988616" class="calibre9"/><a data-primary="" data-startref="tydom02" data-type="indexterm" id="idm45331675987672" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space" data-type="sect1" class="praise"><div class="praise" id="type-value-space">
<h1 class="calibre16">Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space</h1>

<p class="author1">A<a data-primary="classes" data-secondary="type versus value" data-type="indexterm" id="idm45331675985928" class="calibre9"/><a data-primary="type system" data-secondary="type space versus value space" data-type="indexterm" id="TStype02" class="calibre9"/><a data-primary="symbols" data-secondary="type space versus value space" data-type="indexterm" id="Stype02" class="calibre9"/><a data-primary="type space" data-type="indexterm" id="tysp02" class="calibre9"/><a data-primary="value space" data-type="indexterm" id="valsp02" class="calibre9"/> symbol in TypeScript exists in one of two spaces:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">Type space</p>
</li>
<li class="calibre12">
<p class="author1">Value space</p>
</li>
</ul>

<p class="author1">This can get confusing because the same name can refer to different things depending on which space it’s in:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Cylinder</code> <code class="p">{</code>
  <code class="nx">radius</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">Cylinder</code> <code class="o">=</code> <code class="p">(</code><code class="nx">radius</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">height</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">radius</code><code class="p">,</code> <code class="nx">height</code><code class="p">});</code></pre>

<p class="author1"><code class="calibre18">interface Cylinder</code> introduces a symbol in type space. <code class="calibre18">const Cylinder</code> introduces a symbol with the same name in value space. They have nothing to do with one another. Depending on the context, when you type <code class="calibre18">Cylinder</code>, you’ll either be referring to the type or the value. Sometimes this can lead to errors:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateVolume</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code> <code class="kd">instanceof</code> <code class="nx">Cylinder</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code>
       <code class="c">// ~~~~~~ Property 'radius' does not exist on type '{}'</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">What’s going on here? You probably intended the <code class="calibre18">instanceof</code> to check whether the shape was of the <code class="calibre18">Cylinder</code> type. But <code class="calibre18">instanceof</code> is JavaScript’s runtime operator, and it operates on values. So <code class="calibre18">instanceof Cylinder</code> refers to the function, not the type.</p>

<p class="author1">It’s not always obvious at first glance whether a symbol is in type space or value space. You have to tell from the context in which the symbol occurs. This can get especially confusing because many type-space constructs look exactly the same as value-space constructs.</p>

<p class="author1">Literals, for example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">T1</code> <code class="o">=</code> <code class="s">'string literal'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">T2</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">v1</code> <code class="o">=</code> <code class="s">'string literal'</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">v2</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code></pre>

<p class="author1">Generally the symbols after a <code class="calibre18">type</code> or <code class="calibre18">interface</code> are in type space while those introduced in a <code class="calibre18">const</code> or <code class="calibre18">let</code> declaration are values.</p>

<p class="author1">One<a data-primary="TypeScript Playground" data-type="indexterm" id="idm45331675879448" class="calibre9"/> of the best ways to build an intuition for the two spaces is through the <a href="https://www.typescriptlang.org/play/" class="calibre9">TypeScript Playground</a>, which shows you the generated JavaScript for your TypeScript source. Types are erased during compilation (<a href="ch01.html#independent" class="calibre9">Item 3</a>), so if a symbol disappears then it was probably in type space (see <a data-type="xref" href="ch02_split_000.html#TypeScript-playground" class="calibre9">Figure 2-9</a>).</p>

<figure class="calibre28"><div class="figure" id="TypeScript-playground">
<img alt="efts 0207" src="assets/efts_0207.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-9. </span>The TypeScript playground showing generated JavaScript. The symbols on the first two lines go away, so they were in type space.</h6>
</div></figure>

<p class="author1">Statements in TypeScript can alternate between type space and value space. The symbols after a type declaration (<code class="calibre18">:</code>) or an assertion (<code class="calibre18">as</code>) are in type space while everything after an <code class="calibre18">=</code> is in value space. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">p</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="s">'Jane'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Jacobs'</code> <code class="p">};</code>
<code class="c">//    -           --------------------------------- Values</code>
<code class="c">//       ------ Type</code></pre>

<p class="author1">Function statements in particular can alternate repeatedly between the spaces:</p>

<pre data-code-language="ts" data-type="programlisting" id="type-value-email" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">,</code> <code class="nx">subject</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">body</code>: <code class="kd">string</code><code class="p">)</code>: <code class="kd">Response</code> <code class="p">{</code>
  <code class="c">//     ----- -          -------          ----  Values</code>
  <code class="c">//              ------           ------        ------   -------- Types</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">The<a data-primary="class construct" data-type="indexterm" id="idm45331675759272" class="calibre9"/><a data-primary="enums (enumerations)" data-type="indexterm" id="idm45331675758664" class="calibre9"/> <code class="calibre18">class</code> and <code class="calibre18">enum</code> constructs introduce both a type and a value. In the first example, <code class="calibre18">Cylinder</code> should have been a <code class="calibre18">class</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Cylinder</code> <code class="p">{</code>
  <code class="nx">radius</code><code class="o">=</code><code class="mi">1</code><code class="p">;</code>
  <code class="nx">height</code><code class="o">=</code><code class="mi">1</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">calculateVolume</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code> <code class="kd">instanceof</code> <code class="nx">Cylinder</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code>  <code class="c">// OK, type is Cylinder</code>
    <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code>  <code class="c">// OK, type is number</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">The TypeScript type introduced by a class is based on its shape (its properties and methods) while the value is the constructor.</p>

<p class="author1">There<a data-primary="typeof operator" data-type="indexterm" id="idm45331675675000" class="calibre9"/> are many operators and keywords that mean different things in a type or value context. <code class="calibre18">typeof</code>, for instance:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">T1</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">p</code><code class="p">;</code>  <code class="c">// Type is Person</code>
<code class="kd">type</code> <code class="nx">T2</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">email</code><code class="p">;</code>
    <code class="c">// Type is (p: Person, subject: string, body: string) =&gt; Response</code>

<code class="kd">const</code> <code class="nx">v1</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">p</code><code class="p">;</code>  <code class="c">// Value is "object"</code>
<code class="kd">const</code> <code class="nx">v2</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">email</code><code class="p">;</code>  <code class="c">// Value is "function"</code></pre>

<p class="author1">In a type context, <code class="calibre18">typeof</code> takes a value and returns its TypeScript type. You can use these as part of a larger type expression, or use a <code class="calibre18">type</code> statement to give them a name.</p>

<p class="author1">In a value context, <code class="calibre18">typeof</code> is JavaScript’s runtime <code class="calibre18">typeof</code> operator. It returns a string containing the runtime type of the symbol. This is <em class="calibre3">not</em> the same as the TypeScript type! JavaScript’s runtime type system is much simpler than TypeScript’s static type system. In contrast to the infinite variety of TypeScript types, there have historically only been six runtime types in JavaScript: “string,” “number,” “boolean,” “undefined,” “object,” and “function.”</p>

<p class="author1"><code class="calibre18">typeof</code> always operates on values. You can’t apply it to types. The <code class="calibre18">class</code> keyword introduces both a value and a type, so what is the <code class="calibre18">typeof</code> a class? It depends on the context:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">Cylinder</code><code class="p">;</code>  <code class="c">// Value is "function"</code>
<code class="kd">type</code> <code class="nx">T</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">Cylinder</code><code class="p">;</code>  <code class="c">// Type is typeof Cylinder</code></pre>

<p class="author1">The value is <code class="calibre18">"function"</code> because of how classes are implemented in JavaScript. The type isn’t particularly illuminating. What’s important is that it’s <em class="calibre3">not</em> <code class="calibre18">Cylinder</code> (the type of an instance). It’s actually the constructor function, which you can see by using it with <code class="calibre18">new</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">let</code> <code class="nx">fn</code>: <code class="nx">T</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">fn</code><code class="p">();</code>  <code class="c">// Type is Cylinder</code></pre>

<p class="author1">You can go between the constructor type and the instance type using the <code class="calibre18">InstanceType</code> generic:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">C</code> <code class="o">=</code> <code class="nx">InstanceType</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="nx">Cylinder</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// Type is Cylinder</code></pre>

<p class="author1">The<a data-primary="[ ] property accessor" data-type="indexterm" id="idm45331675542504" class="calibre9"/> <code class="calibre18">[]</code> property accessor also has an identical-looking equivalent in type space. But be aware that while <code class="calibre18">obj['field']</code> and <code class="calibre18">obj.field</code> are equivalent in value space, they are not in type space. You must use the former to get the type of another type’s <span class="calibre">property:</span></p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">first</code>: <code class="kd">Person</code><code class="p">[</code><code class="s">'first'</code><code class="p">]</code> <code class="o">=</code> <code class="nx">p</code><code class="p">[</code><code class="s">'first'</code><code class="p">];</code>  <code class="c">// Or p.first</code>
   <code class="c">// -----                    ---------- Values</code>
   <code class="c">//        ------ ------- Types</code></pre>

<p class="author1"><code class="calibre18">Person['first']</code> is a <em class="calibre3">type</em> here since it appears in a type context (after a <code class="calibre18">:</code>). You can put any type in the index slot, including union types or primitive types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">PersonEl</code> <code class="o">=</code> <code class="nx">Person</code><code class="p">[</code><code class="s">'first'</code> <code class="o">|</code> <code class="s">'last'</code><code class="p">];</code>  <code class="c">// Type is string</code>
<code class="kd">type</code> <code class="nx">Tuple</code> <code class="o">=</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="nb">Date</code><code class="p">];</code>
<code class="kd">type</code> <code class="nx">TupleEl</code> <code class="o">=</code> <code class="nx">Tuple</code><code class="p">[</code><code class="kt">number</code><code class="p">];</code>  <code class="c">// Type is string | number | Date</code></pre>

<p class="author1">See <a href="ch02_split_001.html#map-between-types" class="calibre9">Item 14</a> for more on this.</p>

<p class="author1">There are many other constructs that have different meanings in the two spaces:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1"><code class="calibre18">this</code> in<a data-primary="this operator" data-type="indexterm" id="idm45331675400600" class="calibre9"/> value space is JavaScript’s <code class="calibre18">this</code> keyword (<a href="ch06.html#this-in-callbacks" class="calibre9">Item 49</a>). As a type, <code class="calibre18">this</code> is the TypeScript type of <code class="calibre18">this</code>, aka “polymorphic this.” It’s helpful for implementing method chains with subclasses.</p>
</li>
<li class="calibre12">
<p class="author1">In<a data-primary="&amp; operator" data-type="indexterm" id="idm45331675396920" class="calibre9"/><a data-primary="| operator" data-type="indexterm" id="idm45331675396184" class="calibre9"/> value space <code class="calibre18">&amp;</code> and <code class="calibre18">|</code> are bitwise AND and OR. In type space they are the intersection and union operators.</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">const</code> introduces<a data-primary="const" data-secondary="const versus as const" data-type="indexterm" id="idm45331675393368" class="calibre9"/> a new variable, but <code class="calibre18">as const</code> changes the inferred type of a literal or literal expression (<a href="ch03.html#widening" class="calibre9">Item 21</a>).</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">extends</code> can<a data-primary="extends" data-type="indexterm" id="idm45331675389944" class="calibre9"/> define a subclass (<code class="calibre18">class A extends B</code>) or a subtype (<code class="calibre18">interface A extends B</code>) or a constraint on a generic type (<code class="calibre18">Generic&lt;T extends number&gt;</code>).</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">in</code> can<a data-primary="in construct" data-secondary="value versus type space meanings" data-type="indexterm" id="idm45331675386648" class="calibre9"/> either be part of a loop (<code class="calibre18">for (key in object)</code>) or a mapped type (<a href="ch02_split_001.html#map-between-types" class="calibre9">Item 14</a>).</p>
</li>
</ul>

<p class="author1">If TypeScript doesn’t seem to understand your code at all, it may be because of confusion around type and value space. For example, say you change the <code class="calibre18">email</code> function from earlier to take its arguments in a single object parameter:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">(</code><code class="nx">options</code><code class="o">:</code> <code class="p">{</code><code class="nx">person</code>: <code class="kd">Person</code><code class="p">,</code> <code class="nx">subject</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">body</code>: <code class="kd">string</code><code class="p">})</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">In JavaScript you can use destructuring assignment to create local variables for each property in the object:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">({</code><code class="nx">person</code><code class="p">,</code> <code class="nx">subject</code><code class="p">,</code> <code class="nx">body</code><code class="p">})</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">If you try to do the same in TypeScript, you get some confusing errors:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">({</code>
  <code class="nx">person</code>: <code class="kd">Person</code><code class="p">,</code>
       <code class="c">// ~~~~~~ Binding element 'Person' implicitly has an 'any' type</code>
  <code class="nx">subject</code>: <code class="kd">string</code><code class="p">,</code>
        <code class="c">// ~~~~~~ Duplicate identifier 'string'</code>
        <code class="c">//        Binding element 'string' implicitly has an 'any' type</code>
  <code class="nx">body</code>: <code class="kd">string</code><code class="p">}</code>
     <code class="c">// ~~~~~~ Duplicate identifier 'string'</code>
     <code class="c">//        Binding element 'string' implicitly has an 'any' type</code>
<code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

<p class="author1">The problem is that <code class="calibre18">Person</code> and <code class="calibre18">string</code> are being interpreted in a value context. You’re trying to create a variable named <code class="calibre18">Person</code> and two variables named <code class="calibre18">string</code>. Instead, you should separate the types and values:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">(</code>
  <code class="p">{</code><code class="nx">person</code><code class="p">,</code> <code class="nx">subject</code><code class="p">,</code> <code class="nx">body</code><code class="p">}</code><code class="o">:</code> <code class="p">{</code><code class="nx">person</code>: <code class="kd">Person</code><code class="p">,</code> <code class="nx">subject</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">body</code>: <code class="kd">string</code><code class="p">}</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">This is significantly more verbose, but in practice you may have a named type for the parameters or be able to infer them from context (<a href="ch03.html#context-inference" class="calibre9">Item 26</a>).</p>

<p class="author1">While the similar constructs in type and value can be confusing at first, they’re eventually useful as a mnemonic once you get the hang of it.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331675196600">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Know how to tell whether you’re in type space or value space while reading a TypeScript expression. Use the TypeScript playground to build an intuition for this.</p>
</li>
<li class="calibre12">
<p class="author1">Every value has a type, but types do not have values. Constructs<a data-primary="interface construct" data-secondary="existence in type space" data-type="indexterm" id="idm45331675193096" class="calibre9"/> such as <code class="calibre18">type</code> and <code class="calibre18">interface</code> exist only in the type space.</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">"foo"</code> might be a string literal, or it might be a string literal type. Be aware of this distinction and understand how to tell which it is.</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">typeof</code>, <code class="calibre18">this</code>, and many other operators and keywords have different meanings in type space and value space.</p>
</li>
<li class="calibre12">
<p class="author1">Some constructs such as <code class="calibre18">class</code> or <code class="calibre18">enum</code> introduce both a type and a value.<a data-primary="" data-startref="TStype02" data-type="indexterm" id="idm45331675186392" class="calibre9"/><a data-primary="" data-startref="Stype02" data-type="indexterm" id="idm45331675185416" class="calibre9"/><a data-primary="" data-startref="tysp02" data-type="indexterm" id="idm45331675184472" class="calibre9"/><a data-primary="" data-startref="valsp02" data-type="indexterm" id="idm45331675183528" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 9: Prefer Type Declarations to Type Assertions" data-type="sect1" class="praise"><div class="praise" id="prefer-declarations-to-assertions">
<h1 class="calibre16">Item 9: Prefer Type Declarations to Type Assertions</h1>

<p class="author1">TypeScript<a data-primary="type system" data-secondary="type declarations versus type assertions" data-type="indexterm" id="TSdeclar02" class="calibre9"/><a data-primary="type assertion" data-secondary="versus type declarations" data-secondary-sortas="type declarations" data-type="indexterm" id="TAdecl02" class="calibre9"/><a data-primary="type declaration" data-secondary="versus type assertion" data-secondary-sortas="type assertion" data-type="indexterm" id="TDassert02" class="calibre9"/><a data-primary="variables" data-secondary="assigning values to" data-type="indexterm" id="VAvalues02" class="calibre9"/><a data-primary="values" data-secondary="assigning to variables" data-type="indexterm" id="Vassign02" class="calibre9"/> seems to have two ways of assigning a value to a variable and giving it a type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code> <code class="nx">name</code>: <code class="kd">string</code> <code class="p">};</code>

<code class="kd">const</code> <code class="nx">alice</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s">'Alice'</code> <code class="p">};</code>  <code class="c">// Type is Person</code>
<code class="kd">const</code> <code class="nx">bob</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s">'Bob'</code> <code class="p">}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>  <code class="c">// Type is Person</code></pre>

<p class="author1">While these achieve similar ends, they are actually quite different! The first (<code class="calibre18">alice: Person</code>) adds a <em class="calibre3">type declaration</em> to the variable and ensures that the value conforms to the type. The latter (<code class="calibre18">as Person</code>) performs a <em class="calibre3">type assertion</em>. This tells TypeScript that, despite the type it inferred, you know better and would like the type to be <code class="calibre18">Person</code>.</p>

<p class="author1">In general, you should prefer type declarations to type assertions. Here’s why:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">alice</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{};</code>
   <code class="c">// ~~~~~ Property 'name' is missing in type '{}'</code>
   <code class="c">//       but required in type 'Person'</code>
<code class="kd">const</code> <code class="nx">bob</code> <code class="o">=</code> <code class="p">{}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>  <code class="c">// No error</code></pre>

<p class="author1">The type declaration verifies that the value conforms to the interface. Since it does not, TypeScript flags an error. The type assertion silences this error by telling the type checker that, for whatever reason, you know better than it does.</p>

<p class="author1">The same thing happens if you specify an additional property:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">alice</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Alice'</code><code class="p">,</code>
  <code class="nx">occupation</code><code class="o">:</code> <code class="s">'TypeScript developer'</code>
<code class="c">// ~~~~~~~~~ Object literal may only specify known properties</code>
<code class="c">//           and 'occupation' does not exist in type 'Person'</code>
<code class="p">};</code>
<code class="kd">const</code> <code class="nx">bob</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Bob'</code><code class="p">,</code>
  <code class="nx">occupation</code><code class="o">:</code> <code class="s">'JavaScript developer'</code>
<code class="p">}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>  <code class="c">// No error</code></pre>

<p class="author1">This<a data-primary="excess property checking" data-secondary="type declaration and" data-type="indexterm" id="idm45331674973368" class="calibre9"/> is excess property checking at work (<a href="ch02_split_001.html#excess-property-checking" class="calibre9">Item 11</a>), but it doesn’t apply if you use an assertion.</p>

<p class="author1">Because they provide additional safety checks, you should use type declarations unless you have a specific reason to use a type assertion.</p>
<div data-type="note" epub:type="note" class="calibre24"><h6 class="calibre25">Note</h6>
<p class="author1">You<a data-primary="React library" data-secondary="Person in" data-type="indexterm" id="idm45331675010616" class="calibre9"/> may also see code that looks like <code class="calibre18">const bob = &lt;Person&gt;{}</code>. This was the original syntax for assertions and is equivalent to <code class="calibre18">{} as Person</code>. It is less common now because <code class="calibre18">&lt;Person&gt;</code> is interpreted as a start tag in <em class="calibre3">.tsx</em> files (TypeScript + React).</p>
</div>

<p class="author1">It’s<a data-primary="arrow functions" data-type="indexterm" id="idm45331675007432" class="calibre9"/><a data-primary="functions" data-secondary="arrow functions" data-type="indexterm" id="idm45331675006696" class="calibre9"/> not always clear how to use a declaration with arrow functions. For example, what if you wanted to use the named <code class="calibre18">Person</code> interface in this code?</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">name</code><code class="p">}));</code>
<code class="c">// { name: string; }[]... but we want Person[]</code></pre>

<p class="author1">It’s tempting to use a type assertion here, and it seems to solve the problem:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">name</code><code class="p">}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">)</code>
<code class="p">);</code> <code class="c">// Type is Person[]</code></pre>

<p class="author1">But this suffers from all the same issues as a more direct use of type assertions. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">({}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">));</code>
<code class="c">// No error</code></pre>

<p class="author1">So how do you use a type declaration in this context instead? The most straightforward way is to declare a variable in the arrow function:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">person</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="p">};</code>
  <code class="kd">return</code> <code class="nx">person</code>
<code class="p">});</code> <code class="c">// Type is Person[]</code></pre>

<p class="author1">But this introduces considerable noise compared to the original code. A more concise way is to declare the return type of the arrow function:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="p">(</code><code class="nx">name</code><code class="p">)</code><code class="o">:</code> <code class="nx">Person</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">name</code><code class="p">})</code>
<code class="p">);</code> <code class="c">// Type is Person[]</code></pre>

<p class="author1">This performs all the same checks on the value as the previous version. The parentheses are significant here! <code class="calibre18">(name): Person</code> infers the type of <code class="calibre18">name</code> and specifies that the returned type should be <code class="calibre18">Person</code>. But <code class="calibre18">(name: Person)</code> would specify the type of <code class="calibre18">name</code> as <code class="calibre18">Person</code> and allow the return type to be inferred, which would produce an error.</p>

<p class="author1">In this case you could have also written the final desired type and let TypeScript check the validity of the assignment:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code>: <code class="kd">Person</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="p">(</code><code class="nx">name</code><code class="p">)</code><code class="o">:</code> <code class="nx">Person</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">name</code><code class="p">})</code>
<code class="p">);</code></pre>

<p class="author1">But in the context of a longer chain of function calls it may be necessary or desirable to have the named type in place earlier. And it will help flag errors where they occur.</p>

<p class="author1">So when <em class="calibre3">should</em> you use a type assertion? Type assertions make the most sense when you truly do know more about a type than TypeScript does, typically from context that isn’t available to the type checker. For instance, you may know the type of a DOM element more precisely than TypeScript does:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s">'#myButton'</code><code class="p">).</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'click'</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">e</code><code class="p">.</code><code class="nx">currentTarget</code> <code class="c">// Type is EventTarget</code>
  <code class="kd">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nx">e</code><code class="p">.</code><code class="nx">currentTarget</code> <code class="kd">as</code> <code class="nx">HTMLButtonElement</code><code class="p">;</code>
  <code class="nx">button</code> <code class="c">// Type is HTMLButtonElement</code>
<code class="p">});</code></pre>

<p class="author1">Because TypeScript doesn’t have access to the DOM of your page, it has no way of knowing that <code class="calibre18">#myButton</code> is a button element. And it doesn’t know that the <code class="calibre18">currentTarget</code> of the event should be that same button. Since you have information that TypeScript does not, a type assertion makes sense here. For more on DOM types, see <a href="ch07.html#understand-the-dom" class="calibre9">Item 55</a>.</p>

<p class="author1">You may also run into the non-null assertion, which is so common that it gets a special syntax:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">elNull</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code>  <code class="c">// Type is HTMLElement | null</code>
<code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">)</code><code class="o">!</code><code class="p">;</code> <code class="c">// Type is HTMLElement</code></pre>

<p class="author1">Used<a data-primary="! operator" data-type="indexterm" id="idm45331674641448" class="calibre9"/><a data-primary="non-null assertions" data-type="indexterm" id="idm45331674640952" class="calibre9"/> as a prefix, <code class="calibre18">!</code> is boolean negation. But as a suffix, <code class="calibre18">!</code> is interpreted as an assertion that the value is non-null. You should treat <code class="calibre18">!</code> just like any other assertion: it is erased during compilation, so you should only use it if you have information that the type checker lacks and can ensure that the value is non-null. If you can’t, you should use a conditional to check for the <code class="calibre18">null</code> case.</p>

<p class="author1">Type assertions have their limits: they don’t let you convert between arbitrary types. The general idea is that you can use a type assertion to convert between A and B if either is a subset of the other. <code class="calibre18">HTMLElement</code> is a subtype of <code class="calibre18">HTMLElement | null</code>, so this type assertion is OK. <code class="calibre18">HTMLButtonElement</code> is a subtype of <code class="calibre18">EventTarget</code>, so that was OK, too. And <code class="calibre18">Person</code> is a subtype of <code class="calibre18">{}</code>, so that assertion is also fine.</p>

<p class="author1">But you can’t convert between a <code class="calibre18">Person</code> and an <code class="calibre18">HTMLElement</code> since neither is a subtype of the other:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">const</code> <code class="nx">body</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nx">body</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>
        <code class="c">// ~~~~~~~~~~~~~~ Conversion of type 'HTMLElement' to type 'Person'</code>
        <code class="c">//                may be a mistake because neither type sufficiently</code>
        <code class="c">//                overlaps with the other. If this was intentional,</code>
        <code class="c">//                convert the expression to 'unknown' first</code></pre>

<p class="author1">The error suggests an escape hatch, namely, using the <code class="calibre18">unknown</code> type (<a href="ch05.html#never-unknown" class="calibre9">Item 42</a>). Every type is a subtype of <code class="calibre18">unknown</code>, so assertions involving <code class="calibre18">unknown</code> are always OK. This lets you convert between arbitrary types, but at least you’re being explicit that you’re doing something suspicious!</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">body</code> <code class="kd">as</code> <code class="nx">unknown</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>  <code class="c">// OK</code></pre>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331674502440">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Prefer type declarations (<code class="calibre18">: Type</code>) to type assertions (<code class="calibre18">as Type</code>).</p>
</li>
<li class="calibre12">
<p class="author1">Know how to annotate the return type of an arrow function.</p>
</li>
<li class="calibre12">
<p class="author1">Use type assertions and non-null assertions when you know something about types that TypeScript does not.<a data-primary="" data-startref="TSdeclar02" data-type="indexterm" id="idm45331674518136" class="calibre9"/><a data-primary="" data-startref="TAdecl02" data-type="indexterm" id="idm45331674517160" class="calibre9"/><a data-primary="" data-startref="Vassign02" data-type="indexterm" id="idm45331674516216" class="calibre9"/><a data-primary="" data-startref="TDassert02" data-type="indexterm" id="idm45331674515272" class="calibre9"/><a data-primary="" data-startref="VAvalues02" data-type="indexterm" id="idm45331674483912" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 10: Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)" data-type="sect1" class="praise"><div class="praise" id="avoid-object-wrapper-types">
<h1 class="calibre16">Item 10: Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)</h1>

<p class="author1">In<a data-primary="type system" data-secondary="object wrapper types" data-type="indexterm" id="TSobject02" class="calibre9"/><a data-primary="object wrapper types" data-type="indexterm" id="object02" class="calibre9"/><a data-primary="string primitives" data-type="indexterm" id="string02" class="calibre9"/><a data-primary="number primitives" data-type="indexterm" id="number02" class="calibre9"/><a data-primary="boolean primitives" data-type="indexterm" id="boolean02" class="calibre9"/><a data-primary="null primitive" data-type="indexterm" id="nullp02" class="calibre9"/><a data-primary="undefined primitive" data-type="indexterm" id="undef02" class="calibre9"/><a data-primary="symbols" data-secondary="symbol primitives" data-type="indexterm" id="symb02" class="calibre9"/><a data-primary="bigint primitive" data-type="indexterm" id="bigint02" class="calibre9"/> addition to objects, JavaScript has seven types of primitive values: strings, numbers, booleans, <code class="calibre18">null</code>, <code class="calibre18">undefined</code>, symbol, and bigint. The first five have been around since the beginning. The<a data-primary="ES2015" data-secondary="symbol primitive" data-type="indexterm" id="idm45331674456312" class="calibre9"/> symbol primitive was added in ES2015, and bigint is in the process of being finalized.</p>

<p class="author1">Primitives are distinguished from objects by being immutable and not having methods. You might object that strings <em class="calibre3">do</em> have methods:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">'primitive'.charAt(3)</strong>
"m"</pre>

<p class="author1">But things are not quite as they seem. There’s actually something surprising and subtle going on here. While a string <em class="calibre3">primitive</em> does not have methods, JavaScript also defines a <code class="calibre18">String</code> <em class="calibre3">object</em> type that does. JavaScript freely converts between these types. When you access a method like <code class="calibre18">charAt</code> on a string primitive, JavaScript wraps it in a <code class="calibre18">String</code> object, calls the method, and then throws the object away.</p>

<p class="author1">You can observe this if you monkey-patch <code class="calibre18">String.prototype</code> (<a href="ch05.html#type-safe-monkey" class="calibre9">Item 43</a>):</p>

<pre data-code-language="js" data-type="programlisting" id="string-coerce-charat" class="calibre17"><code class="c">// Don't do this!</code>
<code class="kd">const</code> <code class="nx">originalCharAt</code> <code class="o">=</code> <code class="nb">String</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">charAt</code><code class="p">;</code>
<code class="nb">String</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">charAt</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">pos</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">,</code> <code class="kd">typeof</code> <code class="kd">this</code><code class="p">,</code> <code class="nx">pos</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">originalCharAt</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="kd">this</code><code class="p">,</code> <code class="nx">pos</code><code class="p">);</code>
<code class="p">};</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'primitive'</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><code class="mi">3</code><code class="p">));</code></pre>

<p class="author1">This produces the following output:</p>

<pre data-type="programlisting" id="string-coerce-charat-output" class="calibre17">[String: 'primitive'] 'object' 3
m</pre>

<p class="author1">The <code class="calibre18">this</code> value in the method is a <code class="calibre18">String</code> object wrapper, not a string primitive. You can instantiate a <code class="calibre18">String</code> object directly and it will sometimes behave like a string primitive. But not always. For example, a <code class="calibre18">String</code> object is only ever equal to itself:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">"hello" === new String("hello")</strong>
false
&gt; <strong class="calibre32">new String("hello") === new String("hello")</strong>
false</pre>

<p class="author1">The implicit conversion to object wrapper types explains an odd phenomenon in JavaScript—if you assign a property to a primitive, it disappears:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">x = "hello"</strong>
&gt; <strong class="calibre32">x.language = 'English'</strong>
'English'
&gt; <strong class="calibre32">x.language</strong>
undefined</pre>

<p class="author1">Now you know the explanation: <code class="calibre18">x</code> is converted to a <code class="calibre18">String</code> instance, the <code class="calibre18">language</code> property is set on that, and then the object (with its <code class="calibre18">language</code> property) is thrown away.</p>

<p class="author1">There are object wrapper types for the other primitives as well: <code class="calibre18">Number</code> for numbers, <code class="calibre18">Boolean</code> for booleans, <code class="calibre18">Symbol</code> for symbols, and <code class="calibre18">BigInt</code> for bigints (there are no object wrappers for <code class="calibre18">null</code> and <code class="calibre18">undefined</code>).</p>

<p class="author1">These wrapper types exist as a convenience to provide methods on the primitive values and to provide static methods (e.g., <code class="calibre18">String.fromCharCode</code>). But there’s usually no reason to instantiate them directly.</p>

<p class="author1">TypeScript models this distinction by having distinct types for the primitives and their object wrappers:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1"><code class="calibre18">string</code> and <code class="calibre18">String</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">number</code> and <code class="calibre18">Number</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">boolean</code> and <code class="calibre18">Boolean</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">symbol</code> and <code class="calibre18">Symbol</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">bigint</code> and <code class="calibre18">BigInt</code></p>
</li>
</ul>

<p class="author1">It’s<a data-primary="Java" data-secondary="String objects" data-type="indexterm" id="idm45331674376680" class="calibre9"/> easy to inadvertently type <code class="calibre18">String</code> (especially if you’re coming from Java or C#) and it even seems to work, at least initially:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStringLen</code><code class="p">(</code><code class="nx">foo</code>: <code class="nx">String</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">foo</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">getStringLen</code><code class="p">(</code><code class="s">"hello"</code><code class="p">);</code>  <code class="c">// OK</code>
<code class="nx">getStringLen</code><code class="p">(</code><code class="kd">new</code> <code class="nb">String</code><code class="p">(</code><code class="s">"hello"</code><code class="p">));</code>  <code class="c">// OK</code></pre>

<p class="author1">But things go awry when you try to pass a <code class="calibre18">String</code> object to a method that expects a <code class="calibre18">string</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isGreeting</code><code class="p">(</code><code class="nx">phrase</code>: <code class="nx">String</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">[</code>
    <code class="s">'hello'</code><code class="p">,</code>
    <code class="s">'good day'</code>
  <code class="p">].</code><code class="nx">includes</code><code class="p">(</code><code class="nx">phrase</code><code class="p">);</code>
          <code class="c">// ~~~~~~</code>
          <code class="c">// Argument of type 'String' is not assignable to parameter</code>
          <code class="c">// of type 'string'.</code>
          <code class="c">// 'string' is a primitive, but 'String' is a wrapper object;</code>
          <code class="c">// prefer using 'string' when possible</code>
<code class="p">}</code></pre>

<p class="author1">So <code class="calibre18">string</code> is assignable to <code class="calibre18">String</code>, but <code class="calibre18">String</code> is not assignable to <code class="calibre18">string</code>. Confusing? Follow the advice in the error message and stick with <code class="calibre18">string</code>. All the type declarations that ship with TypeScript use it, as do the typings for almost all other libraries.</p>

<p class="author1">Another way you can wind up with wrapper objects is if you provide an explicit type annotation with a capital letter:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">s</code>: <code class="nx">String</code> <code class="o">=</code> <code class="s">"primitive"</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">n</code>: <code class="nx">Number</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">b</code>: <code class="nx">Boolean</code> <code class="o">=</code> <code class="kd">true</code><code class="p">;</code></pre>

<p class="author1">Of course, the values at runtime are still primitives, not objects. But TypeScript permits these declarations because the primitive types are assignable to the object wrappers. These annotations are both misleading and redundant (<a href="ch03.html#avoid-inferable" class="calibre9">Item 19</a>). Better to stick with the primitive types.</p>

<p class="author1">As a final note, it’s OK to call <code class="calibre18">BigInt</code> and <code class="calibre18">Symbol</code> without <code class="calibre18">new</code>, since these create primitives:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">typeof BigInt(1234)</strong>
"bigint"
&gt; <strong class="calibre32">typeof Symbol('sym')</strong>
"symbol"</pre>

<p class="author1">These are the <code class="calibre18">BigInt</code> and <code class="calibre18">Symbol</code> <em class="calibre3">values</em>, not the TypeScript types (<a href="ch02_split_000.html#type-value-space" class="calibre9">Item 8</a>). Calling them results in values of type <code class="calibre18">bigint</code> and <code class="calibre18">symbol</code>.</p>








</div></section>













</div></section>

<section data-pdf-bookmark="Chapter 2. TypeScript&#x2019;s Type System" data-type="chapter" epub:type="chapter" class="praise">
<div class="praise" id="ch-types">
<section data-pdf-bookmark="Item 10: Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)" data-type="sect1" class="praise">
<div class="praise" id="avoid-object-wrapper-types">
<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331674201048">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Understand how object wrapper types are used to provide methods on primitive values. Avoid instantiating them or using them directly.</p>
</li>
<li class="calibre12">
<p class="author1">Avoid TypeScript object wrapper types. Use the primitive types instead: <code class="calibre18">string</code> instead of <code class="calibre18">String</code>, <code class="calibre18">number</code> instead of <code class="calibre18">Number</code>, <code class="calibre18">boolean</code> instead of <code class="calibre18">Boolean</code>, <code class="calibre18">symbol</code> instead of <code class="calibre18">Symbol</code>, and <code class="calibre18">bigint</code> instead of <code class="calibre18">BigInt</code>.<a data-primary="" data-startref="bigint02" data-type="indexterm" id="idm45331674192936" class="calibre9"/><a data-primary="" data-startref="object02" data-type="indexterm" id="idm45331674191928" class="calibre9"/><a data-primary="" data-startref="symb02" data-type="indexterm" id="idm45331674190984" class="calibre9"/><a data-primary="" data-startref="undef02" data-type="indexterm" id="idm45331674190040" class="calibre9"/><a data-primary="" data-startref="nullp02" data-type="indexterm" id="idm45331674189096" class="calibre9"/><a data-primary="" data-startref="boolean02" data-type="indexterm" id="idm45331674188152" class="calibre9"/><a data-primary="" data-startref="number02" data-type="indexterm" id="idm45331674187208" class="calibre9"/><a data-primary="" data-startref="string02" data-type="indexterm" id="idm45331674186264" class="calibre9"/><a data-primary="" data-startref="TSobject02" data-type="indexterm" id="idm45331674185320" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 11: Recognize the Limits of Excess Property Checking" data-type="sect1" class="praise"><div class="praise" id="excess-property-checking">
<h1 class="calibre16">Item 11: Recognize the Limits of Excess Property Checking</h1>

<p class="author1">When<a data-primary="type system" data-secondary="excess property checking limits" data-type="indexterm" id="TSexcess02" class="calibre9"/><a data-primary="excess property checking" data-secondary="limits of" data-type="indexterm" id="EPlimit02" class="calibre9"/> you assign an object literal to a variable with a declared type, TypeScript makes sure it has the properties of that type <em class="calibre3">and no others</em>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Room</code> <code class="p">{</code>
  <code class="nx">numDoors</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">ceilingHeightFt</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">r</code>: <code class="nx">Room</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">numDoors</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">ceilingHeightFt</code>: <code class="nx">10</code><code class="p">,</code>
  <code class="nx">elephant</code><code class="o">:</code> <code class="s">'present'</code><code class="p">,</code>
<code class="c">// ~~~~~~~~~~~~~~~~~~ Object literal may only specify known properties,</code>
<code class="c">//                    and 'elephant' does not exist in type 'Room'</code>
<code class="p">};</code></pre>

<p class="author1">While it is odd that there’s an <code class="calibre18">elephant</code> property, this error doesn’t make much sense from a structural typing point of view (<a href="ch01.html#structural" class="calibre9">Item 4</a>). That constant <em class="calibre3">is</em> assignable to the <code class="calibre18">Room</code> type, which you can see by introducing an intermediate variable:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">numDoors</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">ceilingHeightFt</code>: <code class="nx">10</code><code class="p">,</code>
  <code class="nx">elephant</code><code class="o">:</code> <code class="s">'present'</code><code class="p">,</code>
<code class="p">};</code>
<code class="kd">const</code> <code class="nx">r</code>: <code class="nx">Room</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">The type of <code class="calibre18">obj</code> is inferred as <code class="calibre18">{ numDoors: number; ceilingHeightFt: number; elephant: string }</code>. Because this type includes a subset of the values in the <code class="calibre18">Room</code> type, it is assignable to <code class="calibre18">Room</code>, and the code passes the type checker (see <a href="ch02_split_000.html#types-as-sets" class="calibre9">Item 7</a>).</p>

<p class="author1">So what is different about these two examples? In the first you’ve triggered a process known as “excess property checking,” which helps catch an important class of errors that the structural type system would otherwise miss. But this process has its limits, and conflating it with regular assignability checks can make it harder to build an intuition for structural typing. Recognizing excess property checking as a distinct process will help you build a clearer mental model of TypeScript’s type system.</p>

<p class="author1">As <a href="ch01.html#ts-vs-js" class="calibre9">Item 1</a> explained, TypeScript goes beyond trying to flag code that will throw exceptions at runtime. It also tries to find code that doesn’t do what you intend. Here’s an example of the latter:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Options</code> <code class="p">{</code>
  <code class="nx">title</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">darkMode?</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">createWindow</code><code class="p">(</code><code class="nx">options</code>: <code class="nx">Options</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">options</code><code class="p">.</code><code class="nx">darkMode</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">setDarkMode</code><code class="p">();</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="nx">createWindow</code><code class="p">({</code>
  <code class="nx">title</code><code class="o">:</code> <code class="s">'Spider Solitaire'</code><code class="p">,</code>
  <code class="nx">darkmode</code>: <code class="nx">true</code>
<code class="c">// ~~~~~~~~~~~~~ Object literal may only specify known properties, but</code>
<code class="c">//               'darkmode' does not exist in type 'Options'.</code>
<code class="c">//               Did you mean to write 'darkMode'?</code>
<code class="p">});</code></pre>

<p class="author1">This code doesn’t throw any sort of error at runtime. But it’s also unlikely to do what you intended for the exact reason that TypeScript says: it should be <code class="calibre18">darkMode</code> (capital M), not <code class="calibre18">darkmode</code>.</p>

<p class="author1">A<a data-primary="type checking, versus excess property checking" data-type="indexterm" id="idm45331673988408" class="calibre9"/> purely structural type checker wouldn’t be able to spot this sort of error because the domain of the <code class="calibre18">Options</code> type is incredibly broad: it includes all objects with a <code class="calibre18">title</code> property that’s a <code class="calibre18">string</code> and <em class="calibre3">any other properties</em>, so long as those don’t include a <code class="calibre18">darkMode</code> property set to something other than <code class="calibre18">true</code> or <code class="calibre18">false</code>.</p>

<p class="author1">It’s easy to forget how expansive TypeScript types can be. Here are a few more values that are assignable to <code class="calibre18">Options</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">o1</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="nb">document</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="kd">const</code> <code class="nx">o2</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">HTMLAnchorElement</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">Both <code class="calibre18">document</code> and instances of <code class="calibre18">HTMLAnchorElement</code> have <code class="calibre18">title</code> properties that are strings, so these assignments are OK. <code class="calibre18">Options</code> is a broad type indeed!</p>

<p class="author1">Excess property checking tries to rein this in without compromising the fundamentally structural nature of the type system. It does this by disallowing unknown properties specifically on object literals. (It’s sometimes called “strict object literal checking” for this reason.) Neither <code class="calibre18">document</code> nor <code class="calibre18">new HTMLAnchorElement</code> is an object literal, so they did not trigger the checks. But the <code class="calibre18">{title, darkmode}</code> object is, so it does:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">o</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">darkmode</code>: <code class="nx">true</code><code class="p">,</code> <code class="nx">title</code><code class="o">:</code> <code class="s">'Ski Free'</code> <code class="p">};</code>
                  <code class="c">// ~~~~~~~~ 'darkmode' does not exist in type 'Options'...</code></pre>

<p class="author1">This explains why using an intermediate variable without a type annotation makes the error go away:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">intermediate</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">darkmode</code>: <code class="nx">true</code><code class="p">,</code> <code class="nx">title</code><code class="o">:</code> <code class="s">'Ski Free'</code> <code class="p">};</code>
<code class="kd">const</code> <code class="nx">o</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="nx">intermediate</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">While the righthand side of the first line is an object literal, the righthand side of the second line (<code class="calibre18">intermediate</code>) is not, so excess property checking does not apply, and the error goes away.</p>

<p class="author1">Excess property checking does not happen when you use a type assertion:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">darkmode</code>: <code class="nx">true</code><code class="p">,</code> <code class="nx">title</code><code class="o">:</code> <code class="s">'Ski Free'</code> <code class="p">}</code> <code class="kd">as</code> <code class="nx">Options</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">This is a good reason to prefer declarations to assertions (<a href="ch02_split_000.html#prefer-declarations-to-assertions" class="calibre9">Item 9</a>).</p>

<p class="author1">If you don’t want this sort of check, you can tell TypeScript to expect additional properties using an index signature:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Options</code> <code class="p">{</code>
  <code class="nx">darkMode?</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="p">[</code><code class="nx">otherOptions</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">unknown</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">o</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">darkmode</code>: <code class="nx">true</code> <code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1"><a href="ch02_split_001.html#index-for-dynamic" class="calibre9">Item 15</a> discusses when this is and is not an appropriate way to model your data.</p>

<p class="author1">A related check happens for “weak” types, which have only optional properties:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">LineChartOptions</code> <code class="p">{</code>
  <code class="nx">logscale?</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="nx">invertedYAxis?</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="nx">areaChart?</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">opts</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">logScale</code>: <code class="nx">true</code> <code class="p">};</code>
<code class="kd">const</code> <code class="nx">o</code>: <code class="nx">LineChartOptions</code> <code class="o">=</code> <code class="nx">opts</code><code class="p">;</code>
   <code class="c">// ~ Type '{ logScale: boolean; }' has no properties in common</code>
   <code class="c">//   with type 'LineChartOptions'</code></pre>

<p class="author1">From a structural point of view, the <code class="calibre18">LineChartOptions</code> type should include almost all objects. For weak types like this, TypeScript adds another check to make sure that the value type and declared type have at least one property in common. Much like excess property checking, this is effective at catching typos and isn’t strictly structural. But unlike excess property checking, it happens during all assignability checks involving weak types. Factoring out an intermediate variable doesn’t bypass this check.</p>

<p class="author1">Excess property checking is an effective way of catching typos and other mistakes in property names that would otherwise be allowed by the structural typing system. It’s particularly useful with types like <code class="calibre18">Options</code> that contain optional fields. But it is also very limited in scope: it only applies to object literals. Recognize this limitation and distinguish between excess property checking and ordinary type checking. This will help you build a mental model of both.</p>

<p class="author1">Factoring out a constant made an error go away here, but it can also introduce an error in other contexts. See <a href="ch03.html#context-inference" class="calibre9">Item 26</a> for examples of this.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331673713848">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">When you assign an object literal to a variable or pass it as an argument to a function, it undergoes excess property checking.</p>
</li>
<li class="calibre12">
<p class="author1">Excess property checking is an effective way to find errors, but it is distinct from the usual structural assignability checks done by the TypeScript type checker. Conflating these processes will make it harder for you to build a mental model of assignability.</p>
</li>
<li class="calibre12">
<p class="author1">Be aware of the limits of excess property checking: introducing an intermediate variable will remove these checks.<a data-primary="" data-startref="TSexcess02" data-type="indexterm" id="idm45331673709304" class="calibre9"/><a data-primary="" data-startref="EPlimit02" data-type="indexterm" id="idm45331673708328" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 12: Apply Types to Entire Function Expressions When Possible" data-type="sect1" class="praise"><div class="praise" id="type-entire-functions">
<h1 class="calibre16">Item 12: Apply Types to Entire Function Expressions When Possible</h1>

<p class="author1">JavaScript<a data-primary="type system" data-secondary="applying type annotations to function expressions" data-type="indexterm" id="TSapply02" class="calibre9"/><a data-primary="typeof fn" data-type="indexterm" id="typeoffn02" class="calibre9"/><a data-primary="functions" data-secondary="applying type annotations to function expressions" data-type="indexterm" id="Fapply02" class="calibre9"/><a data-primary="JavaScript" data-secondary="function statements versus function expressions" data-type="indexterm" id="idm45331673701416" class="calibre9"/><a data-primary="TypeScript" data-secondary="function statements versus function expressions" data-type="indexterm" id="idm45331673700504" class="calibre9"/> (and TypeScript) distinguishes a function <em class="calibre3">statement</em> and a function <span class="calibre"><em class="calibre3">expression</em></span>:</p>

<pre data-code-language="ts" data-type="programlisting" id="roll-dice" class="calibre17"><code class="kd">function</code> <code class="nx">rollDice1</code><code class="p">(</code><code class="nx">sides</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>  <code class="c">// Statement</code>
<code class="kd">const</code> <code class="nx">rollDice2</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">sides</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>  <code class="c">// Expression</code>
<code class="kd">const</code> <code class="nx">rollDice3</code> <code class="o">=</code> <code class="p">(</code><code class="nx">sides</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>  <code class="c">// Also expression</code></pre>

<p class="author1">An advantage of function expressions in TypeScript is that you can apply a type declaration to the entire function at once, rather than specifying the types of the parameters and return type individually:</p>

<pre data-code-language="ts" data-type="programlisting" id="roll-dice-2" class="calibre17"><code class="kd">type</code> <code class="nx">DiceRollFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">sides</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">rollDice</code>: <code class="nx">DiceRollFn</code> <code class="o">=</code> <code class="nx">sides</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code></pre>

<p class="author1">If you mouse over <code class="calibre18">sides</code> in your editor, you’ll see that TypeScript knows its type is <code class="calibre18">number</code>. The function type doesn’t provide much value in such a simple example, but the technique does open up a number of possibilities.</p>

<p class="author1">One is reducing repetition. If you wanted to write several functions for doing arithmetic on numbers, for instance, you could write them like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">sub</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">-</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">mul</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">*</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">div</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">/</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code></pre>

<p class="author1">or consolidate the repeated function signatures with a single function type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">add</code>: <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">sub</code>: <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">-</code> <code class="nx">b</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">mul</code>: <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">*</code> <code class="nx">b</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">div</code>: <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">/</code> <code class="nx">b</code><code class="p">;</code></pre>

<p class="author1">This has fewer type annotations than before, and they’re separated away from the function implementations. This makes the logic more apparent. You’ve also gained a check that the return type of all the function expressions is <code class="calibre18">number</code>.</p>

<p class="author1">Libraries often provide types for common function signatures. For example, ReactJS provides a <code class="calibre18">MouseEventHandler</code> type that you can apply to an entire function rather than specifying <code class="calibre18">MouseEvent</code> as a type for the function’s parameter. If<a data-primary="callbacks" data-secondary="type declarations for" data-type="indexterm" id="idm45331673355512" class="calibre9"/> you’re a library author, consider providing type declarations for common callbacks.</p>

<p class="author1">Another<a data-primary="Twain, Mark" data-type="indexterm" id="idm45331673354056" class="calibre9"/> place you might want to apply a type to a function expression is to match the signature of some other function. In a web browser, for example, the <code class="calibre18">fetch</code> function issues an HTTP request for some resource:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">responseP</code> <code class="o">=</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">'/quote?by=Mark+Twain'</code><code class="p">);</code>  <code class="c">// Type is Promise&lt;Response&gt;</code></pre>

<p class="author1">You extract data from the response via <code class="calibre18">response.json()</code> or <code class="calibre18">response.text()</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">getQuote() {</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">'/quote?by=Mark+Twain'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">quote</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
  <code class="kd">return</code> <code class="nx">quote</code><code class="p">;</code>
<code class="p">}</code>
<code class="c">// {</code>
<code class="c">//   "quote": "If you tell the truth, you don't have to remember anything.",</code>
<code class="c">//   "source": "notebook",</code>
<code class="c">//   "date": "1894"</code>
<code class="c">// }</code></pre>

<p class="author1">(See <a href="ch03.html#use-async-await" class="calibre9">Item 25</a> for more on Promises and <code class="calibre18">async</code>/<code class="calibre18">await</code>.)</p>

<p class="author1">There’s a bug here: if the request for <code class="calibre18">/quote</code> fails, the response body is likely to contain an explanation like “404 Not Found.” This<a data-primary="JSON" data-type="indexterm" id="idm45331673324008" class="calibre9"/> isn’t JSON, so <code class="calibre18">response.json()</code> will return a rejected Promise with a message about invalid JSON. This obscures the real error, which was a 404.</p>

<p class="author1">It’s easy to forget that an error response with <code class="calibre18">fetch</code> does not result in a rejected Promise. Let’s write a <code class="calibre18">checkedFetch</code> function to do the status check for us. The type declarations for <code class="calibre18">fetch</code> in <code class="calibre18">lib.dom.d.ts</code> look like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">fetch</code><code class="p">(</code>
  <code class="nx">input</code>: <code class="nx">RequestInfo</code><code class="p">,</code> <code class="nx">init?</code>: <code class="nx">RequestInit</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code><code class="p">;</code></pre>

<p class="author1">So you can write <code class="calibre18">checkedFetch</code> like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">checkedFetch</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">RequestInfo</code><code class="p">,</code> <code class="nx">init?</code>: <code class="nx">RequestInit</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">);</code>
  <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// Converted to a rejected Promise in an async function</code>
    <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'Request failed: '</code> <code class="o">+</code> <code class="nx">response</code><code class="p">.</code><code class="nx">status</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">response</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This works, but it can be written more concisely:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">checkedFetch</code>: <code class="nx">typeof</code> <code class="nx">fetch</code> <code class="o">=</code> <code class="kd">async</code> <code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">);</code>
  <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'Request failed: '</code> <code class="o">+</code> <code class="nx">response</code><code class="p">.</code><code class="nx">status</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">response</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">We’ve changed from a function statement to a function expression and applied a type (<code class="calibre18">typeof fetch</code>) to the entire function. This allows TypeScript to infer the types of the <code class="calibre18">input</code> and <code class="calibre18">init</code> parameters.</p>

<p class="author1">The type annotation also guarantees that the return type of <code class="calibre18">checkedFetch</code> will be the same as that of <code class="calibre18">fetch</code>. Had you written <code class="calibre18">return</code> instead of <code class="calibre18">throw</code>, for example, TypeScript would have caught the mistake:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">checkedFetch</code>: <code class="nx">typeof</code> <code class="nx">fetch</code> <code class="o">=</code> <code class="kd">async</code> <code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c">//  ~~~~~~~~~~~~   Type 'Promise&lt;Response | HTTPError&gt;'</code>
  <code class="c">//                     is not assignable to type 'Promise&lt;Response&gt;'</code>
  <code class="c">//                   Type 'Response | HTTPError' is not assignable</code>
  <code class="c">//                       to type 'Response'</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">);</code>
  <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'Request failed: '</code> <code class="o">+</code> <code class="nx">response</code><code class="p">.</code><code class="nx">status</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">response</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The same mistake in the first example would likely have led to an error, but in the code that called <code class="calibre18">checkedFetch</code>, rather than in the implementation.</p>

<p class="author1">In addition to being more concise, typing this entire function expression instead of its parameters has given you better safety. When you’re writing a function that has the same type signature as another one, or writing many functions with the same type signature, consider whether you can apply a type declaration to entire functions, rather than repeating types of parameters and return values.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331672977704">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Consider applying type annotations to entire function expressions, rather than to their parameters and return type.</p>
</li>
<li class="calibre12">
<p class="author1">If you’re writing the same type signature repeatedly, factor out a function type or look for an existing one. If you’re a library author, provide types for common callbacks.</p>
</li>
<li class="calibre12">
<p class="author1">Use <code class="calibre18">typeof fn</code> to match the signature of another function.<a data-primary="" data-startref="Fapply02" data-type="indexterm" id="idm45331672972904" class="calibre9"/><a data-primary="" data-startref="typeoffn02" data-type="indexterm" id="idm45331672971928" class="calibre9"/><a data-primary="" data-startref="TSapply02" data-type="indexterm" id="idm45331672970984" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 13: Know the Differences Between type and interface" data-type="sect1" class="praise"><div class="praise" id="type-vs-interface">
<h1 class="calibre16">Item 13: Know the Differences Between type and interface</h1>

<p class="author1">If<a data-primary="type system" data-secondary="type versus interface" data-type="indexterm" id="TStypevs02" class="calibre9"/><a data-primary="type construct" data-type="indexterm" id="typeconst02" class="calibre9"/><a data-primary="interface construct" data-secondary="type versus interface" data-type="indexterm" id="intconst02" class="calibre9"/> you want to define a named type in TypeScript, you have two options. You can use a type, as shown here:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">or an interface:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">IState</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">(You could also use a <code class="calibre18">class</code>, but that is a JavaScript runtime concept that also introduces a value. See <a href="ch02_split_000.html#type-value-space" class="calibre9">Item 8</a>.)</p>

<p class="author1">Which should you use, <code class="calibre18">type</code> or <code class="calibre18">interface</code>? The line between these two options has become increasingly blurred over the years, to the point that in many situations you can use either. You should be aware of the distinctions that remain between <code class="calibre18">type</code> and <code class="calibre18">interface</code> and be consistent about which you use in which situation. But you should also know how to write the same types using both, so that you’ll be comfortable reading TypeScript that uses either.</p>
<div data-type="warning" epub:type="warning" class="calibre26"><h6 class="calibre27">Warning</h6>
<p class="author1">The examples in this item prefix type names with <code class="calibre18">I</code> or <code class="calibre18">T</code> solely to indicate how they were defined. You should not do this in your code! Prefixing interface types with <code class="calibre18">I</code> is common in C#, and this convention made some inroads in the early days of TypeScript. But it is considered bad style today because it’s unnecessary, adds little value, and is not consistently followed in the standard libraries.</p>
</div>

<p class="author1">First, the similarities: the State types are nearly indistinguishable from one another. If you define an <code class="calibre18">IState</code> or a <code class="calibre18">TState</code> value with an extra property, the errors you get are character-by-character identical:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">wyoming</code>: <code class="nx">TState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Wyoming'</code><code class="p">,</code>
  <code class="nx">capital</code><code class="o">:</code> <code class="s">'Cheyenne'</code><code class="p">,</code>
  <code class="nx">population</code>: <code class="nx">500_000</code>
<code class="c">// ~~~~~~~~~~~~~~~~~~ Type ... is not assignable to type 'TState'</code>
<code class="c">//                    Object literal may only specify known properties, and</code>
<code class="c">//                    'population' does not exist in type 'TState'</code>
<code class="p">};</code></pre>

<p class="author1">You can use an index signature with both <code class="calibre18">interface</code> and <code class="calibre18">type</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TDict</code> <code class="o">=</code> <code class="p">{</code> <code class="p">[</code><code class="nx">key</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">};</code>
<code class="kd">interface</code> <code class="nx">IDict</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">key</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">You can also define function types with either:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
<code class="kd">interface</code> <code class="nx">IFn</code> <code class="p">{</code>
  <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">toStrT</code>: <code class="nx">TFn</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="s">''</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="kd">const</code> <code class="nx">toStrI</code>: <code class="nx">IFn</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="s">''</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">The type alias looks more natural for this straightforward function type, but if the type has properties as well, then the declarations start to look more alike:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TFnWithProperties</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
  <code class="nx">prop</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">IFnWithProperties</code> <code class="p">{</code>
  <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
  <code class="nx">prop</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">You can remember this syntax by reminding yourself that in JavaScript, functions are callable objects.</p>

<p class="author1">Both type aliases and interfaces can be generic:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TPair</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="nx">T</code><code class="p">;</code>
  <code class="nx">second</code>: <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">IPair</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="nx">T</code><code class="p">;</code>
  <code class="nx">second</code>: <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">An <code class="calibre18">interface</code> can extend a <code class="calibre18">type</code> (with some caveats, explained momentarily), and a <code class="calibre18">type</code> can extend an <code class="calibre18">interface</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">IStateWithPop</code> <code class="kd">extends</code> <code class="nx">TState</code> <code class="p">{</code>
  <code class="nx">population</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">TStateWithPop</code> <code class="o">=</code> <code class="nx">IState</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">population</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">};</code></pre>

<p class="author1">Again, these types are identical. The caveat is that an <code class="calibre18">interface</code> cannot extend a complex type like a<a data-primary="union types" data-secondary="extending" data-type="indexterm" id="idm45331672576520" class="calibre9"/> union type. If you want to do that, you’ll need to use <code class="calibre18">type</code> and <code class="calibre18">&amp;</code>.</p>

<p class="author1">A<a data-primary="classes" data-secondary="implements" data-type="indexterm" id="idm45331672534072" class="calibre9"/> class can implement either an <code class="calibre18">interface</code> or a simple type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">StateT</code> <code class="kd">implements</code> <code class="nx">TState</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">class</code> <code class="nx">StateI</code> <code class="kd">implements</code> <code class="nx">IState</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Those are the similarities. What about the differences? You’ve seen one already—there are union <code class="calibre18">type</code>s but no union <code class="calibre18">interface</code>s:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">AorB</code> <code class="o">=</code> <code class="s">'a'</code> <code class="o">|</code> <code class="s">'b'</code><code class="p">;</code></pre>

<p class="author1">Extending union types can be useful. If you have separate types for <code class="calibre18">Input</code> and <code class="calibre18">Output</code> variables and a mapping from name to variable:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Input</code> <code class="o">=</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>
<code class="kd">type</code> <code class="nx">Output</code> <code class="o">=</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>
<code class="kd">interface</code> <code class="nx">VariableMap</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">Input</code> <code class="o">|</code> <code class="nx">Output</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">then you might want a type that attaches the name to the variable. This would be:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">NamedVariable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">Input</code> <code class="o">|</code> <code class="nx">Output</code><code class="p">)</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">name</code>: <code class="kd">string</code> <code class="p">};</code></pre>

<p class="author1">This type cannot be expressed with <code class="calibre18">interface</code>. A <code class="calibre18">type</code> is, in general, more capable than an <code class="calibre18">interface</code>. It can be a union, and it can also take advantage of more advanced features like mapped or conditional types.</p>

<p class="author1">It can also more easily express tuple and array types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Pair</code> <code class="o">=</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
<code class="kd">type</code> <code class="nx">StringList</code> <code class="o">=</code> <code class="kt">string</code><code class="p">[];</code>
<code class="kd">type</code> <code class="nx">NamedNums</code> <code class="o">=</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="p">...</code><code class="kt">number</code><code class="p">[]];</code></pre>

<p class="author1">You can express something <em class="calibre3">like</em> a tuple using <code class="calibre18">interface</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Tuple</code> <code class="p">{</code>
  <code class="nx">0</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">1</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">length</code>: <code class="nx">2</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">t</code>: <code class="nx">Tuple</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">];</code>  <code class="c">// OK</code></pre>

<p class="author1">But this is awkward and drops all the tuple methods like <code class="calibre18">concat</code>. Better to use a <code class="calibre18">type</code>. For more on the problems of numeric indices, see <a href="ch02_split_001.html#number-index" class="calibre9">Item 16</a>.</p>

<p class="author1">An<a data-primary="augmentation" data-type="indexterm" id="idm45331672248328" class="calibre9"/> <code class="calibre18">interface</code> does have some abilities that a <code class="calibre18">type</code> doesn’t, however. One of these is that an <code class="calibre18">interface</code> can be <em class="calibre3">augmented</em>. Going back to the <code class="calibre18">State</code> example, you could have added a <code class="calibre18">population</code> field in another way:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">IState</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">IState</code> <code class="p">{</code>
  <code class="nx">population</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">wyoming</code>: <code class="nx">IState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Wyoming'</code><code class="p">,</code>
  <code class="nx">capital</code><code class="o">:</code> <code class="s">'Cheyenne'</code><code class="p">,</code>
  <code class="nx">population</code>: <code class="nx">500_000</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">This<a data-primary="declaration merging" data-type="indexterm" id="idm45331673546312" class="calibre9"/> is known as “declaration merging,” and it’s quite surprising if you’ve never seen it before. This is primarily used with type declaration files (<a data-type="xref" href="ch06.html#ch-declarations" class="calibre9">Chapter 6</a>), and if you’re writing one, you should follow the norms and use <code class="calibre18">interface</code> to support it. The idea is that there may be gaps in your type declarations that users need to fill, and this is how they do it.</p>

<p class="author1">TypeScript<a data-primary="Array interface" data-type="indexterm" id="idm45331672169368" class="calibre9"/><a data-primary="tsconfig.json" data-secondary="merging and" data-type="indexterm" id="idm45331672168248" class="calibre9"/><a data-primary="ES2015" data-secondary="merging and" data-type="indexterm" id="idm45331672167304" class="calibre9"/><a data-primary="ES5" data-secondary="merging and" data-type="indexterm" id="idm45331672166360" class="calibre9"/> uses merging to get different types for the different versions of JavaScript’s standard library. The <code class="calibre18">Array</code> interface, for example, is defined in <em class="calibre3">lib.es5.d.ts</em>. By default this is all you get. But if you add <code class="calibre18">ES2015</code> to the <code class="calibre18">lib</code> entry of your <em class="calibre3">tsconfig.json</em>, TypeScript will also include <em class="calibre3">lib.es2015.d.ts</em>. This includes another <code class="calibre18">Array</code> interface with additional methods like <code class="calibre18">find</code> that were added in ES2015. They get added to the other <code class="calibre18">Array</code> interface via merging. The net effect is that you get a single <code class="calibre18">Array</code> type with exactly the right methods.</p>

<p class="author1">Merging is supported in regular code as well as declarations, and you should be aware of the possibility. If it’s essential that no one ever augment your type, then use <code class="calibre18">type</code>.</p>

<p class="author1">Returning to the question at the start of the item, should you use <code class="calibre18">type</code> or <code class="calibre18">interface</code>? For complex types, you have no choice: you need to use a type alias. But what about the simpler object types that can be represented either way? To answer this question, you should consider consistency and augmentation. Are you working in a codebase that consistently uses <code class="calibre18">interface</code>? Then stick with <code class="calibre18">interface</code>. Does it use <code class="calibre18">type</code>? Then use <code class="calibre18">type</code>.</p>

<p class="author1">For projects without an established style, you should think about augmentation. Are you publishing type declarations for an API? Then it might be helpful for your users to be able to be able to merge in new fields via an <code class="calibre18">interface</code> when the API changes. So use <code class="calibre18">interface</code>. But for a type that’s used internally in your project, declaration merging is likely to be a mistake. So prefer <code class="calibre18">type</code>.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331672154456">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Understand the differences and similarities between <code class="calibre18">type</code> and <code class="calibre18">interface</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Know how to write the same types using either syntax.</p>
</li>
<li class="calibre12">
<p class="author1">In deciding which to use in your project, consider the established style and whether augmentation might be beneficial.<a data-primary="" data-startref="intconst02" data-type="indexterm" id="idm45331672149304" class="calibre9"/><a data-primary="" data-startref="typeconst02" data-type="indexterm" id="idm45331672148328" class="calibre9"/><a data-primary="" data-startref="TStypevs02" data-type="indexterm" id="idm45331672147384" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 14: Use Type Operations and Generics to Avoid Repeating Yourself" data-type="sect1" class="praise"><div class="praise" id="map-between-types">
<h1 class="calibre16">Item 14: Use Type Operations and Generics to Avoid Repeating Yourself</h1>

<p class="author1">This<a data-primary="type system" data-secondary="avoiding repetition" data-type="indexterm" id="TSavoid02" class="calibre9"/><a data-primary="DRY (don’t repeat yourself) principle" data-type="indexterm" id="dry02" class="calibre9"/><a data-primary="repetition, avoiding" data-type="indexterm" id="repavoid02" class="calibre9"/> script prints the dimensions, surface areas, and volumes of a few cylinders:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Cylinder 1 x 1 '</code><code class="p">,</code>
  <code class="s">'Surface area:'</code><code class="p">,</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code><code class="p">,</code>
  <code class="s">'Volume:'</code><code class="p">,</code> <code class="mi">3.14159</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Cylinder 1 x 2 '</code><code class="p">,</code>
  <code class="s">'Surface area:'</code><code class="p">,</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code><code class="p">,</code>
  <code class="s">'Volume:'</code><code class="p">,</code> <code class="mi">3.14159</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Cylinder 2 x 1 '</code><code class="p">,</code>
  <code class="s">'Surface area:'</code><code class="p">,</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code><code class="p">,</code>
  <code class="s">'Volume:'</code><code class="p">,</code> <code class="mi">3.14159</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code><code class="p">);</code></pre>

<p class="author1">Is this code uncomfortable to look at? It should be. It’s extremely repetitive, as though the same line was copied and pasted, then modified. It repeats both values and constants. This has allowed an error to creep in (did you spot it?). Much better would be to factor out some functions, a constant, and a loop:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">surfaceArea</code> <code class="o">=</code> <code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">*</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">r</code> <code class="o">*</code> <code class="p">(</code><code class="nx">r</code> <code class="o">+</code> <code class="nx">h</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">volume</code> <code class="o">=</code> <code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">r</code> <code class="o">*</code> <code class="nx">r</code> <code class="o">*</code> <code class="nx">h</code><code class="p">;</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="p">[</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">]</code> <code class="kd">of</code> <code class="p">[[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">]])</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>
    <code class="s">`Cylinder </code><code class="si">${</code><code class="nx">r</code><code class="si">}</code><code class="s"> x </code><code class="si">${</code><code class="nx">h</code><code class="si">}</code><code class="s">`</code><code class="p">,</code>
    <code class="s">`Surface area: </code><code class="si">${</code><code class="nx">surfaceArea</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">)</code><code class="si">}</code><code class="s">`</code><code class="p">,</code>
    <code class="s">`Volume: </code><code class="si">${</code><code class="nx">volume</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">)</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">This is the DRY principle: don’t repeat yourself. It’s the closest thing to universal advice that you’ll find in software development. Yet developers who assiduously avoid repetition in code may not think twice about it in types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">lastName</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">PersonWithBirthDate</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">lastName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">birth</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Duplication in types has many of the same problems as duplication in code. What if you decide to add an optional <code class="calibre18">middleName</code> field to <code class="calibre18">Person</code>? Now <code class="calibre18">Person</code> and <code class="calibre18">PersonWithBirthDate</code> have diverged.</p>

<p class="author1">One reason that duplication is more common in types is that the mechanisms for factoring out shared patterns are less familiar than they are with code: what’s the type system equivalent of factoring out a helper function? By learning how to map between types, you can bring the benefits of DRY to your type definitions.</p>

<p class="author1">The simplest way to reduce repetition is by naming your types. Rather than writing a distance function this way:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">distance</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">},</code> <code class="nx">b</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">})</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">b</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">b</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>
<code class="p">}</code></pre>

<p class="author1">create a name for the type and use that:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Point2D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">distance</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">Point2D</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">Point2D</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

<p class="author1">This is the type system equivalent of factoring out a constant instead of writing it repeatedly. Duplicated types aren’t always so easy to spot. Sometimes they can be obscured by syntax. If several functions share the same type signature, for instance:</p>

<pre data-code-language="ts" data-type="programlisting" id="get-post-repetitive" class="calibre17"><code class="kd">function</code> <code class="nx">get</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">opts</code>: <code class="nx">Options</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">post</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">opts</code>: <code class="nx">Options</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

<p class="author1">Then you can factor out a named type for this signature:</p>

<pre data-code-language="ts" data-type="programlisting" id="get-post-dry" class="calibre17"><code class="kd">type</code> <code class="nx">HTTPFunction</code> <code class="o">=</code> <code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">opts</code>: <code class="nx">Options</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">get</code>: <code class="nx">HTTPFunction</code> <code class="o">=</code> <code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">opts</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>
<code class="kd">const</code> <code class="nx">post</code>: <code class="nx">HTTPFunction</code> <code class="o">=</code> <code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">opts</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code></pre>

<p class="author1">For more on this, see <a href="ch02_split_001.html#type-entire-functions" class="calibre9">Item 12</a>.</p>

<p class="author1">What<a data-primary="extends" data-type="indexterm" id="idm45331671521432" class="calibre9"/> about the <code class="calibre18">Person</code>/<code class="calibre18">PersonWithBirthDate</code> example? You can eliminate the repetition by making one interface extend the other:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">lastName</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">PersonWithBirthDate</code> <code class="kd">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">birth</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Now you only need to write the additional fields. If the two interfaces share a subset of their fields, then you can factor out a base class with just these common fields. Continuing the analogy with code duplication, this is akin to writing <code class="calibre18">PI</code> and <code class="calibre18">2*PI</code> instead of <code class="calibre18">3.141593</code> and <code class="calibre18">6.283185</code>.</p>

<p class="author1">You can also use the intersection operator (<code class="calibre18">&amp;</code>) to extend an existing type, though this is less common:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">PersonWithBirthDate</code> <code class="o">=</code> <code class="nx">Person</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">birth</code>: <code class="nx">Date</code> <code class="p">};</code></pre>

<p class="author1">This technique is most useful when you want to add some additional properties to a union type (which you cannot <code class="calibre18">extend</code>). For more on this, see <a href="ch02_split_001.html#type-vs-interface" class="calibre9">Item 13</a>.</p>

<p class="author1">You can also go the other direction. What if you have a type, <code class="calibre18">State</code>, which represents the state of an entire application, and another, <code class="calibre18">TopNavState</code>, which represents just a part?</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">userId</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">pageTitle</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">recentFiles</code>: <code class="kd">string</code><code class="p">[];</code>
  <code class="nx">pageContents</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">TopNavState</code> <code class="p">{</code>
  <code class="nx">userId</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">pageTitle</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">recentFiles</code>: <code class="kd">string</code><code class="p">[];</code>
<code class="p">}</code></pre>

<p class="author1">Rather than building up <code class="calibre18">State</code> by extending <code class="calibre18">TopNavState</code>, you’d like to define <code class="calibre18">TopNavState</code> as a subset of the fields in <code class="calibre18">State</code>. This way you can keep a single interface defining the state for the entire app.</p>

<p class="author1">You<a data-primary="indexing" data-type="indexterm" id="idm45331671365848" class="calibre9"/> can remove duplication in the types of the properties by indexing into <code class="calibre18">State</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TopNavState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">userId</code>: <code class="nx">State</code><code class="p">[</code><code class="s">'userId'</code><code class="p">];</code>
  <code class="nx">pageTitle</code>: <code class="nx">State</code><code class="p">[</code><code class="s">'pageTitle'</code><code class="p">];</code>
  <code class="nx">recentFiles</code>: <code class="nx">State</code><code class="p">[</code><code class="s">'recentFiles'</code><code class="p">];</code>
<code class="p">};</code></pre>

<p class="author1">While<a data-primary="in construct" data-secondary="in (mapped type)" data-type="indexterm" id="idm45331671353944" class="calibre9"/><a data-primary="mapped types" data-type="indexterm" id="idm45331671353208" class="calibre9"/> it’s longer, this <em class="calibre3">is</em> progress: a change in the type of <code class="calibre18">pageTitle</code> in <code class="calibre18">State</code> will get reflected in <code class="calibre18">TopNavState</code>. But it’s still repetitive. You can do better with a <em class="calibre3">mapped type</em>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TopNavState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">k</code> <code class="kd">in</code> <code class="s">'userId'</code> <code class="o">|</code> <code class="s">'pageTitle'</code> <code class="o">|</code> <code class="s">'recentFiles'</code><code class="p">]</code><code class="o">:</code> <code class="nx">State</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code>
<code class="p">};</code></pre>

<p class="author1">Mousing over <code class="calibre18">TopNavState</code> shows that this definition is, in fact, exactly the same as the previous one (see <a data-type="xref" href="ch02_split_001.html#efts-02in03" class="calibre9">Figure 2-10</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-02in03">
<img alt="efts 02in03" src="assets/efts_02in03.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 2-10. </span>Showing the expanded version of a mapped type in your text editor. This is the same as the initial definition, but with less duplication.</h6>
</div></figure>

<p class="author1">Mapped types are the type system equivalent of looping over the fields in an array. This particular pattern is so common that it’s part of the standard library, where it’s called <code class="calibre18">Pick</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code> <code class="p">[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="p">};</code></pre>

<p class="author1">(This definition isn’t <em class="calibre3">quite</em> complete, as you will see.) You use it like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TopNavState</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">State</code><code class="p">,</code> <code class="s">'userId'</code> <code class="o">|</code> <code class="s">'pageTitle'</code> <code class="o">|</code> <code class="s">'recentFiles'</code><code class="o">&gt;</code><code class="p">;</code></pre>

<p class="author1"><code class="calibre18">Pick</code> is<a data-primary="generic types" data-type="indexterm" id="idm45331671218120" class="calibre9"/><a data-primary="Pick type" data-type="indexterm" id="idm45331671217624" class="calibre9"/> an example of a <em class="calibre3">generic type</em>. Continuing the analogy to removing code duplication, using <code class="calibre18">Pick</code> is the equivalent of calling a function. <code class="calibre18">Pick</code> takes two types, <code class="calibre18">T</code> and <code class="calibre18">K</code>, and returns a third, much as a function might take two values and return a third.</p>

<p class="author1">Another form of duplication can arise with tagged unions. What if you want a type for just the tag?</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">SaveAction</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'save'</code><code class="p">;</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">LoadAction</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'load'</code><code class="p">;</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Action</code> <code class="o">=</code> <code class="nx">SaveAction</code> <code class="o">|</code> <code class="nx">LoadAction</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">ActionType</code> <code class="o">=</code> <code class="s">'save'</code> <code class="o">|</code> <code class="s">'load'</code><code class="p">;</code>  <code class="c">// Repeated types!</code></pre>

<p class="author1">You can define <code class="calibre18">ActionType</code> without repeating yourself by indexing into the <code class="calibre18">Action</code> union:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">ActionType</code> <code class="o">=</code> <code class="nx">Action</code><code class="p">[</code><code class="s">'type'</code><code class="p">];</code>  <code class="c">// Type is "save" | "load"</code></pre>

<p class="author1">As you add more types to the <code class="calibre18">Action</code> union, <code class="calibre18">ActionType</code> will incorporate them automatically. This type is distinct from what you’d get using <code class="calibre18">Pick</code>, which would give you an interface with a <code class="calibre18">type</code> property:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">ActionRec</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">Action</code><code class="p">,</code> <code class="s">'type'</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// {type: "save" | "load"}</code></pre>

<p class="author1">If you’re defining a class which can be initialized and later updated, the type for the parameter to the update method will optionally include most of the same parameters as the constructor:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Options</code> <code class="p">{</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">color</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">label</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">OptionsUpdate</code> <code class="p">{</code>
  <code class="nx">width?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">height?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">color?</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">label?</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">class</code> <code class="nx">UIWidget</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">init</code>: <code class="nx">Options</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
  <code class="nx">update</code><code class="p">(</code><code class="nx">options</code>: <code class="nx">OptionsUpdate</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">You<a data-primary="keyof" data-type="indexterm" id="idm45331671045224" class="calibre9"/> can construct <code class="calibre18">OptionsUpdate</code> from <code class="calibre18">Options</code> using a mapped type and <code class="calibre18">keyof</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">OptionsUpdate</code> <code class="o">=</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">keyof</code> <code class="nx">Options</code><code class="p">]</code><code class="o">?:</code> <code class="nx">Options</code><code class="p">[</code><code class="nx">k</code><code class="p">]};</code></pre>

<p class="author1"><code class="calibre18">keyof</code> takes a type and gives you a union of the types of its keys:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">OptionsKeys</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="nx">Options</code><code class="p">;</code>
<code class="c">// Type is "width" | "height" | "color" | "label"</code></pre>

<p class="author1">The mapped type (<code class="calibre18">[k in keyof Options]</code>) iterates over these and looks up the corresponding value type in <code class="calibre18">Options</code>. The <code class="calibre18">?</code> makes each property optional. This<a data-primary="Partial type" data-type="indexterm" id="idm45331670938776" class="calibre9"/> pattern is also extremely common and is enshrined in the standard library as <code class="calibre18">Partial</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">UIWidget</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">init</code>: <code class="nx">Options</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
  <code class="nx">update</code><code class="p">(</code><code class="nx">options</code>: <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Options</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">You may also find yourself wanting to define a type that matches the shape of a <em class="calibre3">value</em>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">INIT_OPTIONS</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">width</code>: <code class="nx">640</code><code class="p">,</code>
  <code class="nx">height</code>: <code class="nx">480</code><code class="p">,</code>
  <code class="nx">color</code><code class="o">:</code> <code class="s">'#00FF00'</code><code class="p">,</code>
  <code class="nx">label</code><code class="o">:</code> <code class="s">'VGA'</code><code class="p">,</code>
<code class="p">};</code>
<code class="kd">interface</code> <code class="nx">Options</code> <code class="p">{</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">color</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">label</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">You<a data-primary="typeof operator" data-type="indexterm" id="idm45331670843352" class="calibre9"/> can do so with <code class="calibre18">typeof</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Options</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">INIT_OPTIONS</code><code class="p">;</code></pre>

<p class="author1">This intentionally evokes JavaScript’s runtime <code class="calibre18">typeof</code> operator, but it operates at the level of TypeScript types and is much more precise. For more on <code class="calibre18">typeof</code>, see <a href="ch02_split_000.html#type-value-space" class="calibre9">Item 8</a>. Be careful about deriving types from values, however. It’s usually better to define types first and declare that values are assignable to them. This makes your types more explicit and less subject to the vagaries of widening (<a href="ch03.html#widening" class="calibre9">Item 21</a>).</p>

<p class="author1">Similarly, you may want to create a named type for the inferred return value of a function or method:</p>

<pre data-code-language="ts" data-type="programlisting" id="inferred-return-type" class="calibre17"><code class="kd">function</code> <code class="nx">getUserInfo</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
  <code class="kd">return</code> <code class="p">{</code>
    <code class="nx">userId</code><code class="p">,</code>
    <code class="nx">name</code><code class="p">,</code>
    <code class="nx">age</code><code class="p">,</code>
    <code class="nx">height</code><code class="p">,</code>
    <code class="nx">weight</code><code class="p">,</code>
    <code class="nx">favoriteColor</code><code class="p">,</code>
  <code class="p">};</code>
<code class="p">}</code>
<code class="c">// Return type inferred as { userId: string; name: string; age: number, ... }</code></pre>

<p class="author1">Doing this directly requires conditional types (see <a href="ch06.html#conditional-overload" class="calibre9">Item 50</a>). But, as we’ve seen before, the standard library defines generic types for common patterns like this one. In this<a data-primary="ReturnType" data-type="indexterm" id="idm45331670704392" class="calibre9"/> case the <code class="calibre18">ReturnType</code> generic does exactly what you want:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">UserInfo</code> <code class="o">=</code> <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="nx">getUserInfo</code><code class="o">&gt;</code><code class="p">;</code></pre>

<p class="author1">Note that <code class="calibre18">ReturnType</code> operates on <code class="calibre18">typeof getUserInfo</code>, the function’s <em class="calibre3">type</em>, rather than <code class="calibre18">getUserInfo</code>, the function’s <em class="calibre3">value</em>. As with <code class="calibre18">typeof</code>, use this technique judiciously. Don’t get mixed up about your source of truth.</p>

<p class="author1">Generic types are the equivalent of functions for types. And functions are the key to DRY for logic. So it should come as no surprise that generics are the key to DRY for types. But there’s a missing piece to this analogy. You use the type system to constrain the values you can map with a function: you add numbers, not objects; you find the area of shapes, not database records. How do you constrain the parameters in a generic type?</p>

<p class="author1">You<a data-primary="Astaire, Fred" data-type="indexterm" id="idm45331670679416" class="calibre9"/><a data-primary="Rogers, Ginger" data-type="indexterm" id="idm45331670643992" class="calibre9"/> do so with <code class="calibre18">extends</code>. You can declare that any generic parameter <code class="calibre18">extends</code> a type. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Name</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">DancingDuo</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">Name</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">[</code><code class="nx">T</code><code class="p">,</code> <code class="nx">T</code><code class="p">];</code>

<code class="kd">const</code> <code class="nx">couple1</code>: <code class="nx">DancingDuo</code><code class="o">&lt;</code><code class="nx">Name</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Fred'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Astaire'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Ginger'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Rogers'</code><code class="p">}</code>
<code class="p">];</code>  <code class="c">// OK</code>
<code class="kd">const</code> <code class="nx">couple2</code>: <code class="nx">DancingDuo</code><code class="o">&lt;</code><code class="p">{</code><code class="nx">first</code>: <code class="kd">string</code><code class="p">}</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">[</code>
                       <code class="c">// ~~~~~~~~~~~~~~~</code>
                       <code class="c">// Property 'last' is missing in type</code>
                       <code class="c">// '{ first: string; }' but required in type 'Name'</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Sonny'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Cher'</code><code class="p">}</code>
<code class="p">];</code></pre>

<p class="author1"><code class="calibre18">{first: string}</code> does not extend <code class="calibre18">Name</code>, hence the error.</p>
<div data-type="note" epub:type="note" class="calibre24"><h6 class="calibre25">Note</h6>
<p class="author1">At the moment, TypeScript always requires you to write out the generic parameter in a declaration. Writing <code class="calibre18">DancingDuo</code> instead of <code class="calibre18">DancingDuo&lt;Name&gt;</code> won’t cut it. If you want TypeScript to infer the type of the generic parameter, you can use a carefully typed identity function:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre43"><code class="kd">const</code> <code class="nx">dancingDuo</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">Name</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">DancingDuo</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">couple1</code> <code class="o">=</code> <code class="nx">dancingDuo</code><code class="p">([</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Fred'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Astaire'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Ginger'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Rogers'</code><code class="p">}</code>
<code class="p">]);</code>
<code class="kd">const</code> <code class="nx">couple2</code> <code class="o">=</code> <code class="nx">dancingDuo</code><code class="p">([</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Bono'</code><code class="p">},</code>
<code class="c">// ~~~~~~~~~~~~~~</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Prince'</code><code class="p">}</code>
<code class="c">// ~~~~~~~~~~~~~~~~</code>
<code class="c">//     Property 'last' is missing in type</code>
<code class="c">//     '{ first: string; }' but required in type 'Name'</code>
<code class="p">]);</code></pre>

<p class="author1">For<a data-primary="inferringPick" data-type="indexterm" id="idm45331670550328" class="calibre9"/> a particularly useful variation on this, see <code class="calibre18">inferringPick</code> in <a href="ch03.html#context-inference" class="calibre9">Item 26</a>.</p>
</div>

<p class="author1">You can use <code class="calibre18">extends</code> to complete the definition of <code class="calibre18">Pick</code> from earlier. If you run the original version through the type checker, you get an error:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code>
     <code class="c">// ~ Type 'K' is not assignable to type 'string | number | symbol'</code>
<code class="p">};</code></pre>

<p class="author1"><code class="calibre18">K</code> is unconstrained in this type and is clearly too broad: it needs to be something that can be used as an index, namely, <code class="calibre18">string | number | symbol</code>. But you can get narrower than that—<code class="calibre18">K</code> should really be some subset of the keys of T, namely, <code class="calibre18">keyof T</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kd">extends</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">Thinking of types as sets of values (<a href="ch02_split_000.html#types-as-sets" class="calibre9">Item 7</a>), it helps to read “extends” as “subset of” here.</p>

<p class="author1">As you work with increasingly abstract types, try not to lose sight of the goal: accepting valid programs and rejecting invalid ones. In this case, the upshot of the constraint is that passing <code class="calibre18">Pick</code> the wrong key will produce an error:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">FirstLast</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">Name</code><code class="p">,</code> <code class="s">'first'</code> <code class="o">|</code> <code class="s">'last'</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="kd">type</code> <code class="nx">FirstMiddle</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">Name</code><code class="p">,</code> <code class="s">'first'</code> <code class="o">|</code> <code class="s">'middle'</code><code class="o">&gt;</code><code class="p">;</code>
                           <code class="c">// ~~~~~~~~~~~~~~~~~~</code>
                           <code class="c">// Type '"middle"' is not assignable</code>
                           <code class="c">// to type '"first" | "last"'</code></pre>

<p class="author1">Repetition and copy/paste coding are just as bad in type space as they are in value space. The constructs you use to avoid repetition in type space may be less familiar than those used for program logic, but they are worth the effort to learn. Don’t repeat yourself!</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331670272920">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">The DRY (don’t repeat yourself) principle applies to types as much as it applies to logic.</p>
</li>
<li class="calibre12">
<p class="author1">Name types rather than repeating them. Use <code class="calibre18">extends</code> to avoid repeating fields in interfaces.</p>
</li>
<li class="calibre12">
<p class="author1">Build an understanding of the tools provided by TypeScript to map between types. These include <code class="calibre18">keyof</code>, <code class="calibre18">typeof</code>, indexing, and mapped types.</p>
</li>
<li class="calibre12">
<p class="author1">Generic types are the equivalent of functions for types. Use them to map between types instead of repeating types. Use <code class="calibre18">extends</code> to constrain generic types.</p>
</li>
<li class="calibre12">
<p class="author1">Familiarize yourself with generic types defined in the standard library such as <code class="calibre18">Pick</code>, <code class="calibre18">Partial</code>, and <code class="calibre18">ReturnType</code>.<a data-primary="" data-startref="TSavoid02" data-type="indexterm" id="idm45331670263800" class="calibre9"/><a data-primary="" data-startref="dry02" data-type="indexterm" id="idm45331670262792" class="calibre9"/><a data-primary="" data-startref="repavoid02" data-type="indexterm" id="idm45331670261848" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 15: Use Index Signatures for Dynamic Data" data-type="sect1" class="praise"><div class="praise" id="index-for-dynamic">
<h1 class="calibre16">Item 15: Use Index Signatures for Dynamic Data</h1>

<p class="author1">One<a data-primary="type system" data-secondary="index signatures for dynamic data" data-type="indexterm" id="TSinsig02" class="calibre9"/><a data-primary="index signatures" data-secondary="for dynamic data" data-type="indexterm" id="insig02" class="calibre9"/><a data-primary="dynamic data" data-type="indexterm" id="dyndat02" class="calibre9"/> of the best features of JavaScript is its convenient syntax for creating objects:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rocket</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Falcon 9'</code><code class="p">,</code>
  <code class="nx">variant</code><code class="o">:</code> <code class="s">'Block 5'</code><code class="p">,</code>
  <code class="nx">thrust</code><code class="o">:</code> <code class="s">'7,607 kN'</code><code class="p">,</code>
<code class="p">};</code></pre>

<p class="author1">Objects in JavaScript map string keys to values of any type. TypeScript lets you represent flexible mappings like this by specifying an <em class="calibre3">index signature</em> on the type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Rocket</code> <code class="o">=</code> <code class="p">{[</code><code class="nx">property</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">rocket</code>: <code class="nx">Rocket</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Falcon 9'</code><code class="p">,</code>
  <code class="nx">variant</code><code class="o">:</code> <code class="s">'v1.0'</code><code class="p">,</code>
  <code class="nx">thrust</code><code class="o">:</code> <code class="s">'4,940 kN'</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">The <code class="calibre18">[property: string]: string</code> is the index signature. It specifies three things:</p>
<dl class="praise">
<dt class="calibre19">A name for the keys</dt>
<dd class="calibre20">
<p class="author1">This is purely for documentation; it is not used by the type checker in any way.</p>
</dd>
<dt class="calibre19">A type for the key</dt>
<dd class="calibre20">
<p class="author1">This needs to be some combination of <code class="calibre18">string</code>, <code class="calibre18">number</code>, or <code class="calibre18">symbol</code>, but generally you just want to use <code class="calibre18">string</code> (see <a href="ch02_split_001.html#number-index" class="calibre9">Item 16</a>).</p>
</dd>
<dt class="calibre19">A type for the values</dt>
<dd class="calibre20">
<p class="author1">This can be anything.</p>
</dd>
</dl>

<p class="author1">While this does type check, it has a few downsides:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">It allows any keys, including incorrect ones. Had you written <code class="calibre18">Name</code> instead of <code class="calibre18">name</code>, it would have still been a valid <code class="calibre18">Rocket</code> type.</p>
</li>
<li class="calibre12">
<p class="author1">It doesn’t require any specific keys to be present. <code class="calibre18">{}</code> is also a valid <code class="calibre18">Rocket</code>.</p>
</li>
<li class="calibre12">
<p class="author1">It cannot have distinct types for different keys. For example, <code class="calibre18">thrust</code> should probably be a <code class="calibre18">number</code>, not a <code class="calibre18">string</code>.</p>
</li>
<li class="calibre12">
<p class="author1">TypeScript’s language services can’t help you with types like this. As you’re typing <code class="calibre18">name:</code>, there’s no autocomplete because the key could be anything.</p>
</li>
</ul>

<p class="author1">In<a data-primary="interface construct" data-secondary="as alternative to index signatures" data-type="indexterm" id="idm45331670146392" class="calibre9"/> short, index signatures are not very precise. There are almost always better alternatives to them. In this case, <code class="calibre18">Rocket</code> should clearly be an <code class="calibre18">interface</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Rocket</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">variant</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">thrust_kN</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">falconHeavy</code>: <code class="nx">Rocket</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Falcon Heavy'</code><code class="p">,</code>
  <code class="nx">variant</code><code class="o">:</code> <code class="s">'v1'</code><code class="p">,</code>
  <code class="nx">thrust_kN</code>: <code class="nx">15_200</code>
<code class="p">};</code></pre>

<p class="author1">Now <code class="calibre18">thrust_kN</code> is a <code class="calibre18">number</code> and TypeScript will check for the presence of all required fields. All the great language services that TypeScript provides are available: autocomplete, jump to definition, rename—and they all work.</p>

<p class="author1">What<a data-primary="CSV" data-type="indexterm" id="csv02" class="calibre9"/> should you use index signatures for? The canonical case is truly dynamic data. This might come from a CSV file, for instance, where you have a header row and want to represent data rows as objects mapping column names to values:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">input</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="p">{[</code><code class="nx">columnName</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}[]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">lines</code> <code class="o">=</code> <code class="nx">input</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">'\n'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="p">[</code><code class="nx">header</code><code class="p">,</code> <code class="p">...</code><code class="nx">rows</code><code class="p">]</code> <code class="o">=</code> <code class="nx">lines</code><code class="p">;</code>
  <code class="kd">return</code> <code class="nx">rows</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">row</code><code class="o">:</code> <code class="p">{[</code><code class="nx">columnName</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
    <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">cell</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">row</code><code class="p">[</code><code class="nx">header</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">cell</code><code class="p">;</code>
    <code class="p">});</code>
    <code class="kd">return</code> <code class="nx">row</code><code class="p">;</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

<p class="author1">There’s no way to know in advance what the column names are in such a general setting. So an index signature is appropriate. If the user of <code class="calibre18">parseCSV</code> knows more about what the columns are in a particular context, they may want to use an assertion to get a more specific type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ProductRow</code> <code class="p">{</code>
  <code class="nx">productId</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">price</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">declare</code> <code class="kd">let</code> <code class="nx">csvData</code>: <code class="kd">string</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">products</code> <code class="o">=</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">csvData</code><code class="p">)</code> <code class="kd">as</code> <code class="nx">unknown</code> <code class="kd">as</code> <code class="nx">ProductRow</code><code class="p">[];</code></pre>

<p class="author1">Of<a data-primary="undefined value type" data-type="indexterm" id="idm45331669946856" class="calibre9"/> course, there’s no guarantee that the columns at runtime will actually match your expectation. If this is something you’re concerned about, you can add <code class="calibre18">undefined</code> to the value type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">safeParseCSV</code><code class="p">(</code>
  <code class="nx">input</code>: <code class="kd">string</code>
<code class="p">)</code><code class="o">:</code> <code class="p">{[</code><code class="nx">columnName</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">undefined</code><code class="p">}[]</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">input</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">Now every access requires a check:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">csvData</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">prices</code><code class="o">:</code> <code class="p">{[</code><code class="nx">produt</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">row</code> <code class="nx">of</code> <code class="nx">rows</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">prices</code><code class="p">[</code><code class="nx">row</code><code class="p">.</code><code class="nx">productId</code><code class="p">]</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">row</code><code class="p">.</code><code class="nx">price</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">safeRows</code> <code class="o">=</code> <code class="nx">safeParseCSV</code><code class="p">(</code><code class="nx">csvData</code><code class="p">);</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">row</code> <code class="nx">of</code> <code class="nx">safeRows</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">prices</code><code class="p">[</code><code class="nx">row</code><code class="p">.</code><code class="nx">productId</code><code class="p">]</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">row</code><code class="p">.</code><code class="nx">price</code><code class="p">);</code>
      <code class="c">// ~~~~~~~~~~~~~ Type 'undefined' cannot be used as an index type</code>
<code class="p">}</code></pre>

<p class="author1">Of course, this may make the type less convenient to work with. Use your judgment.</p>

<p class="author1">If your type has a limited set of possible fields, don’t model this with an index signature. For instance, if you know your data will have keys like A, B, C, D, but you don’t know how many of them there will be, you could model the type either with optional fields or a union:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Row1</code> <code class="p">{</code> <code class="p">[</code><code class="nx">column</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code> <code class="p">}</code>  <code class="c">// Too broad</code>
<code class="kd">interface</code> <code class="nx">Row2</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">b?</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">c?</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">d?</code>: <code class="nx">number</code> <code class="p">}</code>  <code class="c">// Better</code>
<code class="kd">type</code> <code class="nx">Row3</code> <code class="o">=</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">c</code>: <code class="nx">number</code><code class="p">;</code>  <code class="p">}</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">c</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">d</code>: <code class="nx">number</code> <code class="p">};</code></pre>

<p class="author1">The last form is the most precise, but it may be less convenient to work with.</p>

<p class="author1">If the problem with using an index signature is that <code class="calibre18">string</code> is too broad, then there are a few alternatives.</p>

<p class="author1">One<a data-primary="Records" data-type="indexterm" id="idm45331669607640" class="calibre9"/> is using <code class="calibre18">Record</code>. This is a generic type that gives you more flexibility in the key type. In particular, you can pass in subsets of <code class="calibre18">string</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Vec3D</code> <code class="o">=</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="s">'x'</code> <code class="o">|</code> <code class="s">'y'</code> <code class="o">|</code> <code class="s">'z'</code><code class="p">,</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c">// Type Vec3D = {</code>
<code class="c">//   x: number;</code>
<code class="c">//   y: number;</code>
<code class="c">//   z: number;</code>
<code class="c">// }</code></pre>

<p class="author1">Another<a data-primary="in construct" data-secondary="in (mapped type)" data-type="indexterm" id="idm45331669582856" class="calibre9"/><a data-primary="mapped types" data-type="indexterm" id="idm45331669582008" class="calibre9"/> is using a mapped type. This gives you the possibility of using different types for different keys:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Vec3D</code> <code class="o">=</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="s">'x'</code> <code class="o">|</code> <code class="s">'y'</code> <code class="o">|</code> <code class="s">'z'</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">};</code>
<code class="c">// Same as above</code>
<code class="kd">type</code> <code class="nx">ABC</code> <code class="o">=</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="s">'a'</code> <code class="o">|</code> <code class="s">'b'</code> <code class="o">|</code> <code class="s">'c'</code><code class="p">]</code><code class="o">:</code> <code class="nx">k</code> <code class="kd">extends</code> <code class="s">'b'</code> <code class="o">?</code> <code class="kt">string</code> <code class="o">:</code> <code class="kt">number</code><code class="p">};</code>
<code class="c">// Type ABC = {</code>
<code class="c">//   a: number;</code>
<code class="c">//   b: string;</code>
<code class="c">//   c: number;</code>
<code class="c">// }</code></pre>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331669580024">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Use index signatures when the properties of an object cannot be known until runtime—for example, if you’re loading them from a CSV file.</p>
</li>
<li class="calibre12">
<p class="author1">Consider adding <code class="calibre18">undefined</code> to the value type of an index signature for safer access.</p>
</li>
<li class="calibre12">
<p class="author1">Prefer more precise types to index signatures when possible: <code class="calibre18">interface</code>s, <code class="calibre18">Record</code>s, or mapped types.<a data-primary="" data-startref="TSinsig02" data-type="indexterm" id="idm45331669477448" class="calibre9"/><a data-primary="" data-startref="insig02" data-type="indexterm" id="idm45331669476440" class="calibre9"/><a data-primary="" data-startref="dyndat02" data-type="indexterm" id="idm45331669475496" class="calibre9"/><a data-primary="" data-startref="csv02" data-type="indexterm" id="idm45331669474552" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures" data-type="sect1" class="praise"><div class="praise" id="number-index">
<h1 class="calibre16">Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures</h1>

<p class="author1">JavaScript<a data-primary="type system" data-secondary="arrays, tuples, and ArrayLike" data-type="indexterm" id="TSarray02" class="calibre9"/><a data-primary="index signatures" data-secondary="versus arrays, tuples, and ArrayLike" data-secondary-sortas="arrays, tuples, and ArrayLike" data-type="indexterm" id="ISarray02" class="calibre9"/><a data-primary="JavaScript" data-secondary="implicit type coercions in" data-type="indexterm" id="idm45331669468568" class="calibre9"/> is a famously quirky language. Some of the most notorious quirks involve implicit type coercions:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">"0" == 0</strong>
true</pre>

<p class="author1">but these can usually be avoided by using <code class="calibre18">===</code> and <code class="calibre18">!==</code> instead of their more coercive cousins.</p>

<p class="author1">JavaScript’s object model also has its quirks, and these are more important to understand because some of them are modeled by TypeScript’s type system. You’ve already seen one such quirk in <a href="ch02_split_000.html#avoid-object-wrapper-types" class="calibre9">Item 10</a>, which discussed object wrapper types. This item discusses another.</p>

<p class="author1">What<a data-primary="JavaScript" data-secondary="objects in" data-type="indexterm" id="idm45331669463304" class="calibre9"/><a data-primary="objects" data-secondary="in JavaScript" data-secondary-sortas="JavaScript" data-type="indexterm" id="idm45331669462296" class="calibre9"/> is an object? In JavaScript it’s a collection of key/value pairs. The<a data-primary="ES2015" data-secondary="keys in" data-type="indexterm" id="idm45331669460952" class="calibre9"/> keys are ususally strings (in ES2015 and later they can also be symbols). The values can be <span class="calibre">anything.</span></p>

<p class="author1">This<a data-primary="Java" data-secondary="hashable objects in" data-type="indexterm" id="idm45331669458824" class="calibre9"/> is more restrictive than what you find in many other languages. JavaScript does not have a notion of “hashable” objects like you find in Python or Java. If you try to use a more complex object as a key, it is converted into a string by calling its <code class="calibre18">toString</code> method:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">x = {}</strong>
{}
&gt; <strong class="calibre32">x[[1, 2, 3]] = 2</strong>
2
&gt; <strong class="calibre32">x</strong>
{ '1,2,3': 1 }
</pre>

<p class="author1">In particular, <em class="calibre3">numbers</em> cannot be used as keys. If you try to use a number as a property name, the JavaScript runtime will convert it to a string:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">{ 1: 2, 3: 4}</strong>
{ '1': 2, '3': 4 }</pre>

<p class="author1">So<a data-primary="arrays" data-type="indexterm" id="idm45331669452344" class="calibre9"/> what are arrays, then? They are certainly objects:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">typeof []</strong>
'object'</pre>

<p class="author1">And yet it’s quite normal to use numeric indices with them:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">x = [1, 2, 3]</strong>
[ 1, 2, 3 ]
&gt; <strong class="calibre32">x[0]</strong>
1</pre>

<p class="author1">Are these being converted into strings? In one of the oddest quirks of all, the answer is “yes.” You can also access the elements of an array using string keys:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">x['1']</strong>
2</pre>

<p class="author1">If<a data-primary="Object.keys" data-type="indexterm" id="idm45331669446136" class="calibre9"/> you use <code class="calibre18">Object.keys</code> to list the keys of an array, you get strings back:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">Object.keys(x)</strong>
[ '0', '1', '2' ]</pre>

<p class="author1">TypeScript<a data-primary="ES5" data-secondary="numeric keys and" data-type="indexterm" id="idm45331669443272" class="calibre9"/> attempts to bring some sanity to this by allowing numeric keys and distinguishing between these and strings. If you dig into the type declarations for <code class="calibre18">Array</code> (<a href="ch02_split_000.html#editor" class="calibre9">Item 6</a>), you’ll find this in <em class="calibre3">lib.es5.d.ts</em>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="c">// ...</code>
  <code class="p">[</code><code class="nx">n</code>: <code class="nx">number</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This is purely a fiction—string keys are accepted at runtime as the ECMAScript standard dictates that they must—but it is a helpful one that can catch mistakes:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">xs</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kd">const</code> <code class="nx">x0</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>  <code class="c">// OK</code>
<code class="kd">const</code> <code class="nx">x1</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="s">'1'</code><code class="p">];</code>
           <code class="c">// ~~~ Element implicitly has an 'any' type</code>
           <code class="c">//      because index expression is not of type 'number'</code>

<code class="kd">function</code> <code class="nx">get</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">k</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">array</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>
            <code class="c">// ~ Element implicitly has an 'any' type</code>
            <code class="c">//   because index expression is not of type 'number'</code>
<code class="p">}</code></pre>

<p class="author1">While this fiction is helpful, it’s important to remember that it is just a fiction. Like all aspects of TypeScript’s type system, it is erased at runtime (<a href="ch01.html#independent" class="calibre9">Item 3</a>). This means that constructs like <code class="calibre18">Object.keys</code> still return strings:</p>

<pre data-code-language="ts" data-type="programlisting" id="type-checks" class="calibre17"><code class="kd">const</code> <code class="nx">keys</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">xs</code><code class="p">);</code>  <code class="c">// Type is string[]</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">key</code> <code class="kd">in</code> <code class="nx">xs</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">key</code><code class="p">;</code>  <code class="c">// Type is string</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>  <code class="c">// Type is number</code>
<code class="p">}</code></pre>

<p class="author1">That this last access works is somewhat surprising since <code class="calibre18">string</code> is not assignable to <code class="calibre18">number</code>. It’s best thought of as a pragmatic concession to this style of iterating over arrays, which is common in JavaScript. That’s not to say that this is a good way to loop over an array. If you don’t care about the index, you can<a data-primary="for-of" data-type="indexterm" id="idm45331669236696" class="calibre9"/> use for-of:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">x</code> <code class="nx">of</code> <code class="nx">xs</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">x</code><code class="p">;</code>  <code class="c">// Type is number</code>
<code class="p">}</code></pre>

<p class="author1">If you do care about the index, you can use <code class="calibre18">Array.prototype.forEach</code>, which gives it to you as a <code class="calibre18">number</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">xs</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">x</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">i</code><code class="p">;</code>  <code class="c">// Type is number</code>
  <code class="nx">x</code><code class="p">;</code>  <code class="c">// Type is number</code>
<code class="p">});</code></pre>

<p class="author1">If<a data-primary="for(;;)" data-type="indexterm" id="idm45331669272152" class="calibre9"/> you need to break out of the loop early, you’re best off using a C-style <code class="calibre18">for(;;)</code> loop:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">xs</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="kd">break</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">If<a data-primary="in construct" data-secondary="in (for-in)" data-type="indexterm" id="idm45331669075464" class="calibre9"/><a data-primary="for-in loops" data-type="indexterm" id="idm45331669113224" class="calibre9"/> the types don’t convince you, perhaps the performance will: in most browsers and JavaScript engines, for-in loops over arrays are several orders of magnitude slower than for-of or a C-style for loop.</p>

<p class="author1">The general pattern here is that a <code class="calibre18">number</code> index signature means that what you put in has to be a <code class="calibre18">number</code> (with the notable exception of for-in loops), but what you get out is a <code class="calibre18">string</code>.</p>

<p class="author1">If<a data-primary="Array type" data-type="indexterm" id="idm45331669110152" class="calibre9"/><a data-primary="tuple type" data-type="indexterm" id="idm45331669109416" class="calibre9"/> this sounds confusing, it’s because it is! As a general rule, there’s not much reason to use <code class="calibre18">number</code> as the index signature of a type rather than <code class="calibre18">string</code>. If you want to specify something that will be indexed using numbers, you probably want to use an Array or tuple type instead. Using <code class="calibre18">number</code> as an index type can create the misconception that numeric properties are a thing in JavaScript, either for yourself or for readers of your code.</p>

<p class="author1">If you object to accepting an Array type because they have many other properties (from their prototype) that you might not use, such as <code class="calibre18">push</code> and <code class="calibre18">concat</code>, then that’s good—you’re thinking structurally! (If you need a refresher on this, refer to <a href="ch01.html#structural" class="calibre9">Item 4</a>.) If you truly want to accept tuples of any length or any array-like construct, TypeScript<a data-primary="ArrayLike type" data-type="indexterm" id="idm45331669104408" class="calibre9"/> has an <code class="calibre18">ArrayLike</code> type you can use:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">checkedAccess</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">xs</code>: <code class="nx">ArrayLike</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">i</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">xs</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">`Attempt to access </code><code class="si">${</code><code class="nx">i</code><code class="si">}</code><code class="s"> which is past end of array.`</code><code class="p">)</code>
<code class="p">}</code></pre>

<p class="author1">This has just a <code class="calibre18">length</code> and numeric index signature. In the rare cases that this is what you want, you should use it instead. But remember that the keys are still really strings!</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">tupleLike</code>: <code class="nx">ArrayLike</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
  <code class="s">'0'</code><code class="o">:</code> <code class="s">'A'</code><code class="p">,</code>
  <code class="s">'1'</code><code class="o">:</code> <code class="s">'B'</code><code class="p">,</code>
  <code class="nx">length</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331668954216">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Understand that arrays are objects, so their keys are strings, not numbers. <code class="calibre18">number</code> as an index signature is a purely TypeScript construct which is designed to help catch bugs.</p>
</li>
<li class="calibre12">
<p class="author1">Prefer <code class="calibre18">Array</code>, tuple, or <code class="calibre18">ArrayLike</code> types to using <code class="calibre18">number</code> in an index signature yourself.<a data-primary="" data-startref="TSarray02" data-type="indexterm" id="idm45331668945928" class="calibre9"/><a data-primary="" data-startref="ISarray02" data-type="indexterm" id="idm45331668944952" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 17: Use readonly to Avoid Errors Associated with Mutation" data-type="sect1" class="praise"><div class="praise" id="readonly">
<h1 class="calibre16">Item 17: Use readonly to Avoid Errors Associated with Mutation</h1>

<p class="author1">Here’s<a data-primary="type system" data-secondary="avoiding errors associated with mutation" data-type="indexterm" id="TSmut02" class="calibre9"/><a data-primary="mutations, avoiding errors associated with" data-type="indexterm" id="Merror2" class="calibre9"/><a data-primary="readonly" data-type="indexterm" id="reaon02" class="calibre9"/><a data-primary="const" data-secondary="avoiding errors associated with mutation" data-type="indexterm" id="const02" class="calibre9"/> some code to print the triangular numbers (1, 1+2, 1+2+3, etc.):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">printTriangles</code><code class="p">(</code><code class="nx">n</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">nums</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">n</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">nums</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">arraySum</code><code class="p">(</code><code class="nx">nums</code><code class="p">));</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">This code looks straightforward. But here’s what happens when you run it:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">printTriangles(5)</strong>
0
1
2
3
4</pre>

<p class="author1">The problem is that you’ve made an assumption about <code class="calibre18">arraySum</code>, namely, that it doesn’t modify <code class="calibre18">nums</code>. But here’s my implementation:</p>

<pre data-code-language="ts" data-type="programlisting" id="array-sum-mutation" class="calibre17"><code class="kd">function</code> <code class="nx">arraySum</code><code class="p">(</code><code class="nx">arr</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">num</code><code class="p">;</code>
  <code class="kd">while</code> <code class="p">((</code><code class="nx">num</code> <code class="o">=</code> <code class="nx">arr</code><code class="p">.</code><code class="nx">pop</code><code class="p">())</code> <code class="o">!==</code> <code class="kd">undefined</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">num</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">sum</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This function does calculate the sum of the numbers in the array. But it also has the side effect of emptying the array! TypeScript is fine with this, because JavaScript arrays are mutable.</p>

<p class="author1">It would be nice to have some assurances that <code class="calibre18">arraySum</code> does not modify the array. This is what the <code class="calibre18">readonly</code> type modifier does:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">arraySum</code><code class="p">(</code><code class="nx">arr</code>: <code class="nx">readonly</code> <code class="kt">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">num</code><code class="p">;</code>
  <code class="kd">while</code> <code class="p">((</code><code class="nx">num</code> <code class="o">=</code> <code class="nx">arr</code><code class="p">.</code><code class="nx">pop</code><code class="p">())</code> <code class="o">!==</code> <code class="kd">undefined</code><code class="p">)</code> <code class="p">{</code>
                 <code class="c">// ~~~ 'pop' does not exist on type 'readonly number[]'</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">num</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">sum</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This error message is worth digging into. <code class="calibre18">readonly number[]</code> is a <em class="calibre3">type</em>, and it is distinct from <code class="calibre18">number[]</code> in a few ways:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">You can read from its elements, but you can’t write to them.</p>
</li>
<li class="calibre12">
<p class="author1">You can read its <code class="calibre18">length</code>, but you can’t set it (which would mutate the array).</p>
</li>
<li class="calibre12">
<p class="author1">You can’t call <code class="calibre18">pop</code> or other methods that mutate the array.</p>
</li>
</ul>

<p class="author1">Because <code class="calibre18">number[]</code> is strictly more capable than <code class="calibre18">readonly number[]</code>, it follows that <code class="calibre18">number[]</code> is a subtype of <code class="calibre18">readonly number[]</code>. (It’s easy to get this backwards—remember <a href="ch02_split_000.html#types-as-sets" class="calibre9">Item 7</a>!) So you can assign a mutable array to a <code class="calibre18">readonly</code> array, but not vice versa:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kd">const</code> <code class="nx">b</code>: <code class="nx">readonly</code> <code class="kt">number</code><code class="p">[]</code> <code class="o">=</code> <code class="nx">a</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">c</code>: <code class="nx">number</code><code class="p">[]</code> <code class="o">=</code> <code class="nx">b</code><code class="p">;</code>
   <code class="c">// ~ Type 'readonly number[]' is 'readonly' and cannot be</code>
   <code class="c">//   assigned to the mutable type 'number[]'</code></pre>

<p class="author1">This makes sense: the <code class="calibre18">readonly</code> modifier wouldn’t be much use if you could get rid of it without even a type assertion.</p>

<p class="author1">When you declare a parameter <code class="calibre18">readonly</code>, a few things happen:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">TypeScript checks that the parameter isn’t mutated in the function body.</p>
</li>
<li class="calibre12">
<p class="author1">Callers are assured that your function doesn’t mutate the parameter.</p>
</li>
<li class="calibre12">
<p class="author1">Callers may pass your function a <code class="calibre18">readonly</code> array.</p>
</li>
</ul>

<p class="author1">There is often an assumption in JavaScript (and TypeScript) that functions don’t mutate their parameters unless explicitly noted. But as we’ll see time and again in this book (particularly Items <a href="ch04.html#jsdoc-repeat" class="calibre9">30</a> and <a href="ch04.html#null-values-to-perimeter" class="calibre9">31</a>), these sorts of implicit understandings can lead to trouble with type checking. Better to make them explicit, both for human readers and for <code class="calibre18">tsc</code>.</p>

<p class="author1">The fix for <code class="calibre18">arraySum</code> is simple: don’t mutate the array!</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">arraySum</code><code class="p">(</code><code class="nx">arr</code>: <code class="nx">readonly</code> <code class="kt">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">num</code> <code class="nx">of</code> <code class="nx">arr</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">num</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">sum</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Now <code class="calibre18">printTriangles</code> does what you expect:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">printTriangles(5)</strong>
0
1
3
6
10</pre>

<p class="author1">If your function does not mutate its parameters, then you should declare them <code class="calibre18">readonly</code>. There’s relatively little downside: users will be able to call them with a broader set of types (<a href="ch04.html#loose-accept-strict-produce" class="calibre9">Item 29</a>), and inadvertent mutations will be caught.</p>

<p class="author1">One downside is that you may need to call functions that haven’t marked their parameters <code class="calibre18">readonly</code>. If these don’t mutate their parameters and are in your control, make them <code class="calibre18">readonly</code>! <code class="calibre18">readonly</code> tends to be contagious: once you mark one function with <code class="calibre18">readonly</code>, you’ll also need to mark all the functions that it calls. This is a good thing since it leads to clearer contracts and better type safety. But if you’re calling a function in another library, you may not be able to change its type declarations, and you may have to resort to a type assertion (<code class="calibre18">param as number[]</code>).</p>

<p class="author1"><code class="calibre18">readonly</code> can also be used to catch a whole class of mutation errors involving local variables. Imagine you’re writing a tool to process a novel. You<a data-primary="Shelley, Mary" data-type="indexterm" id="idm45331668616984" class="calibre9"/> get a sequence of lines and would like to collect them into paragraphs, which are separated by blanks:</p>

<pre data-type="programlisting" class="calibre17">Frankenstein; or, The Modern Prometheus
by Mary Shelley

You will rejoice to hear that no disaster has accompanied the commencement
of an enterprise which you have regarded with such evil forebodings. I arrived
here yesterday, and my first task is to assure my dear sister of my welfare and
increasing confidence in the success of my undertaking.

I am already far north of London, and as I walk in the streets of Petersburgh,
I feel a cold northern breeze play upon my cheeks, which braces my nerves and
fills me with delight.</pre>

<p class="author1">Here’s an attempt:<sup class="calibre44"><a data-type="noteref" href="ch02_split_001.html#idm45331668614424" id="idm45331668614424-marker" class="calibre45">1</a></sup></p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseTaggedText</code><code class="p">(</code><code class="nx">lines</code>: <code class="kd">string</code><code class="p">[])</code><code class="o">:</code> <code class="kt">string</code><code class="p">[][]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">paragraphs</code>: <code class="kd">string</code><code class="p">[][]</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">const</code> <code class="nx">currPara</code>: <code class="kd">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>

  <code class="kd">const</code> <code class="nx">addParagraph</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">currPara</code><code class="p">);</code>
      <code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>  <code class="c">// Clear the lines</code>
    <code class="p">}</code>
  <code class="p">};</code>

  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">line</code> <code class="nx">of</code> <code class="nx">lines</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">line</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">addParagraph</code><code class="p">();</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">currPara</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">line</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="nx">addParagraph</code><code class="p">();</code>
  <code class="kd">return</code> <code class="nx">paragraphs</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">When you run this on the example at the beginning of the item, here’s what you get:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="p">[</code> <code class="p">[],</code> <code class="p">[],</code> <code class="p">[]</code> <code class="p">]</code></pre>

<p class="author1">Well that went horribly wrong!</p>

<p class="author1">The problem with this code is a toxic combination of aliasing (<a href="ch03.html#avoid-aliasing" class="calibre9">Item 24</a>) and mutation. The aliasing happens on this line:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">currPara</code><code class="p">);</code></pre>

<p class="author1">Rather than pushing the contents of <code class="calibre18">currPara</code>, this pushes a reference to the array. When you push a new value to <code class="calibre18">currPara</code> or clear it, this change is also reflected in the entries in <code class="calibre18">paragraphs</code> because they point to the same object.</p>

<p class="author1">In other words, the net effect of this code:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">currPara</code><code class="p">);</code>
<code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>  <code class="c">// Clear lines</code></pre>

<p class="author1">is that you push a new paragraph onto <code class="calibre18">paragraphs</code> and then immediately clear it.</p>

<p class="author1">The problem is that setting <code class="calibre18">currPara.length</code> and calling <code class="calibre18">currPara.push</code> both mutate the <code class="calibre18">currPara</code> array. You can disallow this behavior by declaring it to be <code class="calibre18">readonly</code>. This immediately surfaces a few errors in the implementation:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseTaggedText</code><code class="p">(</code><code class="nx">lines</code>: <code class="kd">string</code><code class="p">[])</code><code class="o">:</code> <code class="kt">string</code><code class="p">[][]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">currPara</code>: <code class="nx">readonly</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">const</code> <code class="nx">paragraphs</code>: <code class="kd">string</code><code class="p">[][]</code> <code class="o">=</code> <code class="p">[];</code>

  <code class="kd">const</code> <code class="nx">addParagraph</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code>
        <code class="nx">currPara</code>
     <code class="c">// ~~~~~~~~ Type 'readonly string[]' is 'readonly' and</code>
     <code class="c">//          cannot be assigned to the mutable type 'string[]'</code>
      <code class="p">);</code>
      <code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>  <code class="c">// Clear lines</code>
            <code class="c">// ~~~~~~ Cannot assign to 'length' because it is a read-only</code>
            <code class="c">// property</code>
    <code class="p">}</code>
  <code class="p">};</code>

  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">line</code> <code class="nx">of</code> <code class="nx">lines</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">line</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">addParagraph</code><code class="p">();</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">currPara</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">line</code><code class="p">);</code>
            <code class="c">// ~~~~ Property 'push' does not exist on type 'readonly string[]'</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="nx">addParagraph</code><code class="p">();</code>
  <code class="kd">return</code> <code class="nx">paragraphs</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">You can fix two of the errors by declaring <code class="calibre18">currPara</code> with <code class="calibre18">let</code> and using nonmutating methods:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">currPara</code>: <code class="nx">readonly</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>
<code class="c">// ...</code>
<code class="nx">currPara</code> <code class="o">=</code> <code class="p">[];</code>  <code class="c">// Clear lines</code>
<code class="c">// ...</code>
<code class="nx">currPara</code> <code class="o">=</code> <code class="nx">currPara</code><code class="p">.</code><code class="nx">concat</code><code class="p">([</code><code class="nx">line</code><code class="p">]);</code></pre>

<p class="author1">Unlike <code class="calibre18">push</code>, <code class="calibre18">concat</code> returns a new array, leaving the original unmodified. By changing the declaration from <code class="calibre18">const</code> to <code class="calibre18">let</code> and adding <code class="calibre18">readonly</code>, you’ve traded one sort of mutability for another. The <code class="calibre18">currPara</code> variable is now free to change which array it points to, but those arrays themselves are not allowed to change.</p>

<p class="author1">This leaves the error about <code class="calibre18">paragraphs</code>. You have three options for fixing this.</p>

<p class="author1">First, you could make a copy of <code class="calibre18">currPara</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">([...</code><code class="nx">currPara</code><code class="p">]);</code></pre>

<p class="author1">This fixes the error because, while <code class="calibre18">currPara</code> remains <code class="calibre18">readonly</code>, you’re free to mutate the copy however you like.</p>

<p class="author1">Second, you could change <code class="calibre18">paragraphs</code> (and the return type of the function) to be an array of <code class="calibre18">readonly string[]</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">paragraphs</code><code class="o">:</code> <code class="p">(</code><code class="nx">readonly</code> <code class="kt">string</code><code class="p">[])[]</code> <code class="o">=</code> <code class="p">[];</code></pre>

<p class="author1">(The grouping is relevant here: <code class="calibre18">readonly string[][]</code> would be a <code class="calibre18">readonly</code> array of mutable arrays, rather than a mutable array of <code class="calibre18">readonly</code> arrays.)</p>

<p class="author1">This works, but it seems a bit rude to users of <code class="calibre18">parseTaggedText</code>. Why do you care what they do with the paragraphs after the function returns?</p>

<p class="author1">Third, you could use an assertion to remove the <code class="calibre18">readonly</code>-ness of the array:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">currPara</code> <code class="kd">as</code> <code class="kt">string</code><code class="p">[]);</code></pre>

<p class="author1">Since you’re assigning <code class="calibre18">currPara</code> to a new array in the very next statement, this doesn’t seem like the most offensive assertion.</p>

<p class="author1">An important caveat to <code class="calibre18">readonly</code> is that it is <em class="calibre3">shallow</em>. You saw this with <code class="calibre18">readonly string[][]</code> earlier. If you have a <code class="calibre18">readonly</code> array of objects, the objects themselves are not <code class="calibre18">readonly</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">dates</code>: <code class="nx">readonly</code> <code class="nb">Date</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="kd">new</code> <code class="nb">Date</code><code class="p">()];</code>
<code class="nx">dates</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kd">new</code> <code class="nb">Date</code><code class="p">());</code>
   <code class="c">// ~~~~ Property 'push' does not exist on type 'readonly Date[]'</code>
<code class="nx">dates</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">setFullYear</code><code class="p">(</code><code class="mi">2037</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">Similar considerations apply to <code class="calibre18">readonly</code>’s cousin for objects, the <code class="calibre18">Readonly</code> generic:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Outer</code> <code class="p">{</code>
  <code class="nx">inner</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">o</code>: <code class="nx">Readonly</code><code class="o">&lt;</code><code class="nx">Outer</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">inner</code><code class="o">:</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">0</code> <code class="p">}};</code>
<code class="nx">o</code><code class="p">.</code><code class="nx">inner</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">1</code> <code class="p">};</code>
<code class="c">// ~~~~ Cannot assign to 'inner' because it is a read-only property</code>
<code class="nx">o</code><code class="p">.</code><code class="nx">inner</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">You can create a type alias and then inspect it in your editor to see exactly what’s <span class="calibre">happening:</span></p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">T</code> <code class="o">=</code> <code class="nx">Readonly</code><code class="o">&lt;</code><code class="nx">Outer</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c">// Type T = {</code>
<code class="c">//   readonly inner: {</code>
<code class="c">//     x: number;</code>
<code class="c">//   };</code>
<code class="c">// }</code></pre>

<p class="author1">The important thing to note is the <code class="calibre18">readonly</code> modifier on <code class="calibre18">inner</code> but not on <code class="calibre18">x</code>. There is no built-in support for deep readonly types at the time of this writing, but it is possible to create a generic to do this. Getting this right is tricky, so I recommend using a library rather than rolling your own. The <code class="calibre18">DeepReadonly</code> generic in <code class="calibre18">ts-essentials</code> is one implementation.</p>

<p class="author1">You<a data-primary="index signatures" data-secondary="readonly and" data-type="indexterm" id="idm45331667946968" class="calibre9"/> can also write <code class="calibre18">readonly</code> on an index signature. This has the effect of preventing writes but allowing reads:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">obj</code><code class="o">:</code> <code class="p">{</code><code class="nx">readonly</code> <code class="p">[</code><code class="nx">k</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="c">// Or Readonly&lt;{[k: string]: number}</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">hi</code> <code class="o">=</code> <code class="mi">45</code><code class="p">;</code>
<code class="c">//  ~~ Index signature in type ... only permits reading</code>
<code class="nx">obj</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">hi</code>: <code class="nx">12</code><code class="p">};</code>  <code class="c">// OK</code>
<code class="nx">obj</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">bye</code>: <code class="nx">34</code><code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">This can prevent issues with aliasing and mutation involving objects rather than arrays.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331667858152">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">If your function does not modify its parameters then declare them <code class="calibre18">readonly</code>. This makes its contract clearer and prevents inadvertent mutations in its <span class="calibre">implementation</span>.</p>
</li>
<li class="calibre12">
<p class="author1">Use <code class="calibre18">readonly</code> to prevent errors with mutation and to find the places in your code where mutations occur.</p>
</li>
<li class="calibre12">
<p class="author1">Understand the difference between <code class="calibre18">const</code> and <code class="calibre18">readonly</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Understand that <code class="calibre18">readonly</code> is shallow.<a data-primary="" data-startref="TSmut02" data-type="indexterm" id="idm45331667832344" class="calibre9"/><a data-primary="" data-startref="Merror2" data-type="indexterm" id="idm45331667831336" class="calibre9"/><a data-primary="" data-startref="reaon02" data-type="indexterm" id="idm45331667830392" class="calibre9"/><a data-primary="" data-startref="const02" data-type="indexterm" id="idm45331667829448" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 18: Use Mapped Types to Keep Values in Sync" data-type="sect1" class="praise"><div class="praise" id="values-in-sync">
<h1 class="calibre16">Item 18: Use Mapped Types to Keep Values in Sync</h1>

<p class="author1">Suppose<a data-primary="in construct" data-secondary="in (mapped type)" data-type="indexterm" id="ICmap02" class="calibre9"/><a data-primary="type system" data-secondary="mapped types" data-type="indexterm" id="TSmap02" class="calibre9"/><a data-primary="mapped types" data-type="indexterm" id="maptype02" class="calibre9"/><a data-primary="values" data-secondary="keeping in sync with mapped types" data-type="indexterm" id="Vsyne02" class="calibre9"/> you’re writing a UI component for drawing scatter plots. It has a few different types of properties that control its display and behavior:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ScatterProps</code> <code class="p">{</code>
  <code class="c">// The data</code>
  <code class="nx">xs</code>: <code class="nx">number</code><code class="p">[];</code>
  <code class="nx">ys</code>: <code class="nx">number</code><code class="p">[];</code>

  <code class="c">// Display</code>
  <code class="nx">xRange</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
  <code class="nx">yRange</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
  <code class="nx">color</code>: <code class="kd">string</code><code class="p">;</code>

  <code class="c">// Events</code>
  <code class="nx">onClick</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">index</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">To avoid unnecessary work, you’d like to redraw the chart only when you need to. Changing data or display properties will require a redraw, but changing the event handler will not. This<a data-primary="React library" data-secondary="optimizations in" data-type="indexterm" id="idm45331667775848" class="calibre9"/> sort of optimization is common in React components, where an event handler Prop might be set to a new arrow function on every render.<sup class="calibre44"><a data-type="noteref" href="ch02_split_001.html#idm45331667743432" id="idm45331667743432-marker" class="calibre45">2</a></sup></p>

<p class="author1">Here’s one way you might implement this optimization:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">shouldUpdate</code><code class="p">(</code>
  <code class="nx">oldProps</code>: <code class="nx">ScatterProps</code><code class="p">,</code>
  <code class="nx">newProps</code>: <code class="nx">ScatterProps</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">k</code>: <code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">oldProps</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">oldProps</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">[</code><code class="nx">k</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">if</code> <code class="p">(</code><code class="nx">k</code> <code class="o">!==</code> <code class="s">'onClick'</code><code class="p">)</code> <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">(See <a href="ch07.html#iterate-objects" class="calibre9">Item 54</a> for an explanation of the <code class="calibre18">keyof</code> declaration in this loop.)</p>

<p class="author1">What happens when you or a coworker add a new property? The <code class="calibre18">shouldUpdate</code> function will redraw the chart whenever it changes. You might call this the conservative or “fail closed” approach. The upside is that the chart will always look right. The downside is that it might be drawn too often.</p>

<p class="author1">A “fail open” approach might look like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">shouldUpdate</code><code class="p">(</code>
  <code class="nx">oldProps</code>: <code class="nx">ScatterProps</code><code class="p">,</code>
  <code class="nx">newProps</code>: <code class="nx">ScatterProps</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">(</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">xs</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">xs</code> <code class="o">||</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">ys</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">ys</code> <code class="o">||</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">xRange</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">xRange</code> <code class="o">||</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">yRange</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">yRange</code> <code class="o">||</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">color</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">color</code>
    <code class="c">// (no check for onClick)</code>
  <code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">With this approach there won’t be any unnecessary redraws, but there might be some <em class="calibre3">necessary</em> draws that get dropped. This violates the “first, do no harm” principle of optimization and so is less common.</p>

<p class="author1">Neither approach is ideal. What you’d really like is to force your coworker or future self to make a decision when adding the new property. You might try adding a <span class="calibre">comment:</span></p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ScatterProps</code> <code class="p">{</code>
  <code class="nx">xs</code>: <code class="nx">number</code><code class="p">[];</code>
  <code class="nx">ys</code>: <code class="nx">number</code><code class="p">[];</code>
  <code class="c">// ...</code>
  <code class="nx">onClick</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">index</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>

  <code class="c">// Note: if you add a property here, update shouldUpdate!</code>
<code class="p">}</code></pre>

<p class="author1">But do you really expect this to work? It would be better if the type checker could enforce this for you.</p>

<p class="author1">If you set it up the right way, it can. The key is to use a mapped type and an object:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">REQUIRES_UPDATE</code><code class="o">:</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">]</code><code class="o">:</code> <code class="kd">boolean</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">xs</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">ys</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">xRange</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">yRange</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">color</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">onClick</code>: <code class="nx">false</code><code class="p">,</code>
<code class="p">};</code>

<code class="kd">function</code> <code class="nx">shouldUpdate</code><code class="p">(</code>
  <code class="nx">oldProps</code>: <code class="nx">ScatterProps</code><code class="p">,</code>
  <code class="nx">newProps</code>: <code class="nx">ScatterProps</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">k</code>: <code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">oldProps</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">oldProps</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">&amp;&amp;</code> <code class="nx">REQUIRES_UPDATE</code><code class="p">[</code><code class="nx">k</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">[k in keyof ScatterProps]</code> tells the type checker that <code class="calibre18">REQUIRES_UPDATES</code> should have all the same properties as <code class="calibre18">ScatterProps</code>. If future you adds a new property to <code class="calibre18">ScatterProps</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ScatterProps</code> <code class="p">{</code>
  <code class="c">// ...</code>
  <code class="nx">onDoubleClick</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Then this will produce an error in the definition of <code class="calibre18">REQUIRES_UPDATE</code>:</p>

<pre data-code-language="ts" data-type="programlisting" id="missing-props-key" class="calibre17"><code class="kd">const</code> <code class="nx">REQUIRES_UPDATE</code><code class="o">:</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">]</code><code class="o">:</code> <code class="kd">boolean</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code>
  <code class="c">//  ~~~~~~~~~~~~~~~ Property 'onDoubleClick' is missing in type</code>
  <code class="c">// ...</code>
<code class="p">};</code></pre>

<p class="author1">This will certainly force the issue! Deleting or renaming a property will cause a similar error.</p>

<p class="author1">It’s important that we used an object with boolean values here. Had we used an array:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">PROPS_REQUIRING_UPDATE</code><code class="o">:</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">)[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="s">'xs'</code><code class="p">,</code>
  <code class="s">'ys'</code><code class="p">,</code>
  <code class="c">// ...</code>
<code class="p">];</code></pre>

<p class="author1">then we would have been forced into the same fail open/fail closed choice.</p>

<p class="author1">Mapped types are ideal if you want one object to have exactly the same properties as another. As in this example, you can use this to make TypeScript enforce constraints on your code.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331667251560">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Use mapped types to keep related values and types synchronized.</p>
</li>
<li class="calibre12">
<p class="author1">Consider using mapped types to force choices when adding new properties to an interface.<a data-primary="" data-startref="Vsyne02" data-type="indexterm" id="idm45331667248472" class="calibre9"/><a data-primary="" data-startref="maptype02" data-type="indexterm" id="idm45331667247496" class="calibre9"/><a data-primary="" data-startref="TSmap02" data-type="indexterm" id="idm45331667246552" class="calibre9"/><a data-primary="" data-startref="ICmap02" data-type="indexterm" id="idm45331667245608" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>







<div data-type="footnotes" class="calibre46"><p data-type="footnote" id="idm45331668614424" class="calibre47"><sup class="calibre48"><a href="ch02_split_001.html#idm45331668614424-marker" class="calibre45">1</a></sup> In practice you might just write <code class="calibre18">lines.join('\n').split(/\n\n+/)</code>, but bear with me.</p><p data-type="footnote" id="idm45331667743432" class="calibre47"><sup class="calibre48"><a href="ch02_split_001.html#idm45331667743432-marker" class="calibre45">2</a></sup> React’s <code class="calibre18">useCallback</code> hook is another technique to avoid creating new functions on every render.</p></div></div></section></body></html>