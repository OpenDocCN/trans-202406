<html><head></head><body><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. BPF Utilities"><div class="chapter" id="bpf_utilities">
<h1><span class="label">Chapter 5. </span>BPF Utilities</h1>


<p>So far, we’ve talked about how you can write BPF programs to get more visibility within your systems.<a data-type="indexterm" data-primary="utilities (BPF)" id="ix_util"/> Over the years, many developers have built tools with BPF for that same purpose. In this chapter we talk about several of the off-the-shelf tools that you can use every day. Many of these tools are advanced versions of some BPF programs that you’ve already seen. Others are tools that will help you gain direct visibility into your own BPF programs.<a data-type="indexterm" data-primary="tools (BPF)" data-seealso="utilities" id="idm46623554642104"/></p>

<p>This chapter covers some tools that will help you in your day-to-day work with BPF. We begin by covering BPFTool, a command-line utility to get more information about your BPF programs. We cover BPFTrace and <code>kubectl-trace</code>, which will help you write BPF programs more efficiently with a concise domain-specific language (DSL). Finally, we talk about eBPF Exporter, an open source project to integrate BPF with Prometheus.</p>






<section data-type="sect1" data-pdf-bookmark="BPFTool"><div class="sect1" id="idm46623554639928">
<h1>BPFTool</h1>

<p>BPFTool is a kernel utility for inspecting of BPF programs and maps.<a data-type="indexterm" data-primary="BPFTool" id="ix_BPFTo"/><a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" id="ix_utilBPFTo"/> This tool doesn’t come installed by default on any Linux distribution, and it’s in heavy development, so you’ll want to compile the version that best supports your Linux kernel. We cover the version of BPFTool distributed with version 5.1 of the Linux kernel.</p>

<p>In the next sections we discuss how to install BPFTool onto your system and how to use it to observe and change the behavior of your BPF programs and maps from the terminal.</p>








<section data-type="sect2" data-pdf-bookmark="Installation"><div class="sect2" id="idm46623554635304">
<h2>Installation</h2>

<p>To install BPFTool, you need to download a copy of the kernel’s source code. There might<a data-type="indexterm" data-primary="BPFTool" data-secondary="installation" id="idm46623554633816"/><a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-tertiary="installation" id="idm46623554632968"/> be some packages for your specific Linux distribution online, but we’re going to cover how to install it from the source because it’s not too complicated.</p>
<ol>
<li>
<p>Use Git to clone the repository from GitHub with <strong><code>git clone https://github.com/torvalds/linux</code></strong>.</p>
</li>
<li>
<p>Check out the specific kernel version tag with <code>git checkout v5.1</code>.</p>
</li>
<li>
<p>Within the kernel’s source, navigate to the directory where BPFTool’s source is stored with <code>cd tools/bpf/bpftool</code>.</p>
</li>
<li>
<p>Compile and install this tool with <code>make &amp;&amp; sudo make install</code>.</p>
</li>

</ol>

<p>You can check that BPFTool is correctly installed by checking its version:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftool --version</code>
bpftool v5.1.0</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Feature Display"><div class="sect2" id="idm46623554603704">
<h2>Feature Display</h2>

<p>One of the basic operations that you can perform with BPFTool is scanning your system to know which BPF features you have access to.<a data-type="indexterm" data-primary="BPFTool" data-secondary="feature display" id="idm46623554602184"/><a data-type="indexterm" data-primary="features, displaying for BPF" id="idm46623554625704"/><a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-tertiary="displaying BPf features" id="idm46623554625064"/> This is great when you don’t remember which version of the kernel introduced which kind of programs or whether the BPF JIT compiler is enabled. To find out the answer to those questions, and many others, run this command:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftool feature</code></pre>

<p>You’ll get some long output with details about all the supported BPF features in your systems. For brevity, we show you a cropped version of that output here:</p>
<pre>Scanning system configuration...
bpf() syscall for unprivileged users is enabled
JIT compiler is enabled
...
Scanning eBPF program types...
eBPF program_type socket_filter is available
eBPF program_type kprobe is NOT available
...
Scanning eBPF map types...
eBPF map_type hash is available
eBPF map_type array is available</pre>

<p>In this output you can see that our system allows unprivileged users to execute the syscall <code>bpf</code>, this call is restricted to certain operations. You can also see that the JIT is enabled. <a data-type="indexterm" data-primary="JIT compilation" id="idm46623554608344"/><a data-type="indexterm" data-primary="compilation" data-secondary="JIT" id="idm46623554607704"/>Newer versions of the kernel enable this JIT by default, and it helps greatly in compiling BPF programs. If your system doesn’t have it enabled, you can run this command to enable it:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># echo 1 &gt; /proc/sys/net/core/bpf_jit_enable</code></pre>

<p>The feature output also shows you which program types and map types are enabled in your system. This command exposes much more information than what we’re showing you here, like BPF helpers supported by program type and many other configuration directives. Feel free to dive into them while exploring your system.</p>

<p>Knowing what features you have at your disposal can be useful, especially if you need to dive into an unknown system. With that, we’re ready to move on to other interesting BPFTool features, like inspecting loaded programs.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Inspecting BPF Programs"><div class="sect2" id="idm46623554612824">
<h2>Inspecting BPF Programs</h2>

<p>BPFTool gives you direct information about BPF programs on the kernel.<a data-type="indexterm" data-primary="programs (BPF)" data-secondary="inspecting with BPFTool" id="ix_progins"/><a data-type="indexterm" data-primary="BPFTool" data-secondary="inspecting BPF programs" id="ix_BPFToinsprg"/><a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-tertiary="inspecting BPF programs" id="ix_utilBPFToprg"/> It allows you to investigate what’s already running in your system. It also allows you to load and pin new BPF programs that have been previously compiled from your command line.</p>

<p>The best starting point to learn how to use BPFTool to work with programs is by inspecting what you have running in your system. To do that, you can run the command <code>bpftool prog show</code>. If you’re using Systemd as your init system, you probably already have a few BPF programs loaded and attached to some cgroups; we talk about these a little later. The output of running that command will look like this:</p>

<pre data-type="programlisting" data-code-language="bash">52: cgroup_skb  tag 7be49e3934a125ba
        loaded_at 2019-03-28T16:46:04-0700  uid 0
        xlated 296B  jited 229B  memlock 4096B  map_ids 52,53
53: cgroup_skb  tag 2a142ef67aaad174
        loaded_at 2019-03-28T16:46:04-0700  uid 0
        xlated 296B  jited 229B  memlock 4096B  map_ids 52,53
54: cgroup_skb  tag 7be49e3934a125ba
        loaded_at 2019-03-28T16:46:04-0700  uid 0
        xlated 296B  jited 229B  memlock 4096B  map_ids 54,55</pre>

<p>The numbers on the left side, before the colon, are the program identifiers; we use them later to investigate what these programs are all about. From this output you can also learn which kinds of programs your system is running. In this case, the system is running three BPF programs attached to cgroup socket buffers. The loading time will likely match when you booted your system if those programs were actually started by Systemd. You can also see how much memory those programs are currently using and the identifiers for the maps associated with them. All of this is useful at first glance, and because we have the program identifiers, we can dive a little bit deeper.</p>

<p>You can add the program identifier to the previous command as an extra argument: <code>bpftool prog show id 52</code>. With that, BPFTool will show you the same information you saw before, but only for the program identified by the ID 52; that way, you can filter out information that you don’t need. This command also supports a <code>--json</code> flag to generate some JSON output. This JSON output is very convenient if you want to manipulate the output. For example, tools like <code>jq</code> will give you a more structured formatting for this data:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftool prog show --json id 52 | jq</code>
<code class="o">{</code>
  <code class="s2">"id"</code>: 52,
  <code class="s2">"type"</code>: <code class="s2">"cgroup_skb"</code>,
  <code class="s2">"tag"</code>: <code class="s2">"7be49e3934a125ba"</code>,
  <code class="s2">"gpl_compatible"</code>: <code class="nb">false</code>,
  <code class="s2">"loaded_at"</code>: 1553816764,
  <code class="s2">"uid"</code>: 0,
  <code class="s2">"bytes_xlated"</code>: 296,
  <code class="s2">"jited"</code>: <code class="nb">true</code>,
  <code class="s2">"bytes_jited"</code>: 229,
  <code class="s2">"bytes_memlock"</code>: 4096,
  <code class="s2">"map_ids"</code>: <code class="o">[</code>
    52,
    53
  <code class="o">]</code>
<code class="o">}</code></pre>

<p>You can also perform more advanced manipulations and filter only the information that you’re interested in. In the next example, we’re interested only in knowing the BPF program identifier, which type of program it is, and when it was loaded in the kernel:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftool prog show --json id 52 | jq -c '[.id, .type, .loaded_at]'</code>
<code class="o">[</code>52,<code class="s2">"cgroup_skb"</code>,1553816764<code class="o">]</code></pre>

<p>When you know a program identifier, you can also get a dump of the whole program using BPFTool; this can be handy when you need to debug the BPF bytecode generated by a compiler:</p>
<pre># bpftool prog dump xlated id 52
   0: (bf) r6 = r1
   1: (69) r7 = *(u16 *)(r6 +192)
   2: (b4) w8 = 0
   3: (55) if r7 != 0x8 goto pc+14
   4: (bf) r1 = r6
   5: (b4) w2 = 16
   6: (bf) r3 = r10
   7: (07) r3 += -4
   8: (b4) w4 = 4
   9: (85) call bpf_skb_load_bytes#7151872
   ...</pre>

<p>This program loaded in our kernel by Systemd is inspecting packet data by using the helper <code>bpf_skb_load_bytes</code>.</p>

<p>If you want a more visual representation of this program, including instruction jumps, you can use the <code>visual</code> keyword in this command. That will generate the output in a format that you can convert to a graph representation with tools like <code>dotty</code>, or any other program that can draw graphs:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftool prog dump xlated id 52 visual &amp;&gt; output.out</code>
<code class="c"># dot -Tpng output.out -o visual-graph.png</code></pre>

<p>You can see the visual representation for a small Hello World program in <a data-type="xref" href="#prog_dump_visual">Figure 5-1</a>.</p>

<figure class="no-frame"><div id="prog_dump_visual" class="figure">
<img src="assets/lbpf_0501.png" alt="Visual representation of a BPF program"/>
<h6><span class="label">Figure 5-1. </span>Visual representation of a BPF program</h6>
</div></figure>

<p>If you’re running version 5.1 or newer of the kernel, you’ll also have access to runtime statistics. They tell you how long the kernel is spending on your BPF programs. This feature might not be enabled in your system by default; you’ll need to run this command first to let the kernel know that it needs to show you that data:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># sysctl -w kernel.bpf_stats_enabled=1</code></pre>

<p>When the stats are enabled, you’ll get two more pieces of information when you run BPFTool: the total amount of time that the kernel has spent running that program (<code>run_time_ns</code>), and how many times it has run it (<code>run_cnt</code>):</p>
<pre>52: cgroup_skb  tag 7be49e3934a125ba  run_time_ns 14397 run_cnt 39
        loaded_at 2019-03-28T16:46:04-0700  uid 0
        xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</pre>

<p>But BPFTool doesn’t only allow you to inspect how your programs are doing; it also lets you load new programs into the kernel and attach some of them to sockets and cgroups. For example, we can load one of our previous programs and pin it to the BPF file system, with this command:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftool prog load bpf_prog.o /sys/fs/bpf/bpf_prog</code></pre>

<p>Because the program is pinned to the filesystem, it won’t terminate after running, and we can see that it’s still loaded with the previous <code>show</code> command:</p>
<pre># bpftool prog show
52: cgroup_skb  tag 7be49e3934a125ba
        loaded_at 2019-03-28T16:46:04-0700  uid 0
        xlated 296B  jited 229B  memlock 4096B  map_ids 52,53
53: cgroup_skb  tag 2a142ef67aaad174
        loaded_at 2019-03-28T16:46:04-0700  uid 0
        xlated 296B  jited 229B  memlock 4096B  map_ids 52,53
54: cgroup_skb  tag 7be49e3934a125ba
        loaded_at 2019-03-28T16:46:04-0700  uid 0
        xlated 296B  jited 229B  memlock 4096B  map_ids 54,55
60: perf_event  name bpf_prog  tag c6e8e35bea53af79
        loaded_at 2019-03-28T20:46:32-0700  uid 0
        xlated 112B  jited 115B  memlock 4096B</pre>

<p>As you can see, BPFTool gives you a lot of information about the programs loaded in your kernel without having to write and compile any code. Let’s see how to work with BPF maps next.<a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-tertiary="inspecting BPF programs" data-startref="ix_utilBPFToprg" id="idm46623554486888"/><a data-type="indexterm" data-primary="programs (BPF)" data-secondary="inspecting with BPFTool" data-startref="ix_progins" id="idm46623554432392"/><a data-type="indexterm" data-primary="BPFTool" data-secondary="inspecting BPF programs" data-startref="ix_BPFToinsprg" id="idm46623554431176"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Inspecting BPF Maps"><div class="sect2" id="idm46623554611912">
<h2>Inspecting BPF Maps</h2>

<p>Besides giving you access to inspect and manipulate BPF programs, BPFTool can give you access to the BPF maps that those programs are using.<a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-tertiary="inspecting BPF maps" id="ix_utilBPFTomp"/><a data-type="indexterm" data-primary="BPFTool" data-secondary="inspecting BPF maps" id="ix_BPFToinsmp"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="inspecting with BPFTool" id="ix_mpsinsBPFTo"/> The command to list all maps and filter maps by their identifiers is similar to the <code>show</code> command that you saw previously. Instead of asking BPFTool to display information for <code>prog</code>, let’s ask it to show us information for <code>map</code>:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftool map show</code>
52: lpm_trie  flags 0x1
        key 8B  value 8B  max_entries <code class="m">1</code>  memlock 4096B
53: lpm_trie  flags 0x1
        key 20B  value 8B  max_entries <code class="m">1</code>  memlock 4096B
54: lpm_trie  flags 0x1
        key 8B  value 8B  max_entries <code class="m">1</code>  memlock 4096B
55: lpm_trie  flags 0x1
        key 20B  value 8B  max_entries <code class="m">1</code>  memlock 4096B</pre>

<p>Those maps match the identifiers that you saw earlier attached to your programs. You can also filter maps by their ID, in the same way we filtered programs by their ID <span class="keep-together">earlier</span>.</p>

<p>You can use BPFTool to create and update maps and to list all the elements within a map. Creating a new map requires the same information that you provide when you initialize a map along with one of your programs. We need to specify which type of map we want to create, the size of the keys and values, and its name. Because we’re not initializing the map along with a program, we also need to pin it to the BPF filesystem so that we can use it later:</p>
<pre># bpftool map create /sys/fs/bpf/counter
    type array key 4 value 4 entries 5 name counter</pre>

<p>If you list the maps in the system after running that command, you’ll see the new map at the bottom of the list:</p>
<pre>52: lpm_trie  flags 0x1
        key 8B  value 8B  max_entries 1  memlock 4096B
53: lpm_trie  flags 0x1
        key 20B  value 8B  max_entries 1  memlock 4096B
54: lpm_trie  flags 0x1
        key 8B  value 8B  max_entries 1  memlock 4096B
55: lpm_trie  flags 0x1
        key 20B  value 8B  max_entries 1  memlock 4096B
56: lpm_trie  flags 0x1
        key 8B  value 8B  max_entries 1  memlock 4096B
57: lpm_trie  flags 0x1
        key 20B  value 8B  max_entries 1  memlock 4096B
58: array  name counter  flags 0x0
        key 4B  value 4B  max_entries 5  memlock 4096B</pre>

<p>After you’ve created the map, you can update and delete elements like we’d do inside a BPF program.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Remember that you cannot remove elements from fixed-size arrays; you can only update them. But you can totally delete elements from other maps, like hash maps.</p>
</div>

<p>If you want to add a new element to the map or update an existing one, you can use the <code>map update</code> command. You can grab the map identifier from the previous <span class="keep-together">example</span>:</p>
<pre># bpftool map update id 58 key 1 0 0 0 value 1 0 0 0</pre>

<p>If you try to update an element with an invalid key or value, BPFTool will return an error:</p>
<pre># bpftool map update id 58 key 1 0 0 0 value 1 0 0
Error: value expected 4 bytes got 3</pre>

<p>BPFTool can give you a dump of all the elements in a map if you need to inspect its values. You can see how BPF initializes all of the elements to a null value when you create fixed-size array maps:</p>
<pre># bpftool map dump id 58
key: 00 00 00 00  value: 00 00 00 00
key: 01 00 00 00  value: 01 00 00 00
key: 02 00 00 00  value: 00 00 00 00
key: 03 00 00 00  value: 00 00 00 00
key: 04 00 00 00  value: 00 00 00 00</pre>

<p>One of the most powerful options that BPFTool gives you is that you can attach precreated maps to new programs and replace the maps that they would initialize with those preallocated maps. That way, you can give programs access to saved data from the beginning, even if you didn’t write the program to read a map from the BPF file system. To do that, you need to set the map you want to initialize when you load the program with BPFTool. You can specify the map by the ordered identifier that it would have when the program loads it, for example 0 for the first map, 1 for the second one, and so on. You can also specify the map by its name, which is usually more convenient:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftool prog load bpf_prog.o /sys/fs/bpf/bpf_prog_2 \</code>
    map name counter /sys/fs/bpf/counter</pre>

<p>In this example we attach the map that we just created to a new program. In this case, we replace the map by its name, because we know that the program initializes a map called <code>counter</code>. You can also use the map’s index position with the keyword <code>idx</code>, as in <code>idx 0</code>, if that’s easier to remember for you.</p>

<p>Accessing BPF maps directly from the command line is useful when you need to debug message passing in real time. BPFTool gives you direct access in a convenient way. Besides introspecting programs and maps, you can use BPFTool to extract much more information from the kernel. Let’s see how to access specific interfaces next.<a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-tertiary="inspecting BPF maps" data-startref="ix_utilBPFTomp" id="idm46623554351736"/><a data-type="indexterm" data-primary="BPFTool" data-secondary="inspecting BPF maps" data-startref="ix_BPFToinsmp" id="idm46623554350184"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="inspecting with BPFTool" data-startref="ix_mpsinsBPFTo" id="idm46623554348968"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Inspecting Programs Attached to Specific Interfaces"><div class="sect2" id="idm46623554429048">
<h2>Inspecting Programs Attached to Specific Interfaces</h2>

<p>Sometimes you’ll find yourself wondering which programs are attached to specific interfaces.<a data-type="indexterm" data-primary="programs (BPF)" data-secondary="attached to specific interfaces, inspecting with BPFTool" id="idm46623554345048"/><a data-type="indexterm" data-primary="BPFTool" data-secondary="inspecting programs attached to specific interfaces" id="idm46623554344104"/><a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-tertiary="inspecting programs attached to specific interfaces" id="idm46623554343064"/> BPF can load programs that work on top of cgroups, Perf events, and network packets. The subcommands <code>cgroup</code>, <code>perf</code>, and <code>net</code> can help you trace back attachments on those interfaces.<a data-type="indexterm" data-primary="Perf events" data-secondary="inspecting programs attached to using BPFTool" id="idm46623554340296"/></p>

<p>The <code>perf</code> subcommand lists all programs attached to tracing points in the system, like kprobes, uprobes, and tracepoints; you can see that listing by running <code>bpftool perf show</code>.</p>

<p>The <code>net</code> subcommand lists programs attached <a data-type="indexterm" data-primary="network packets, inspecting programs attached to using BPFTool" id="idm46623554319944"/>to XDP and Traffic Control.<a data-type="indexterm" data-primary="XDP (Express Data Path)" data-secondary="listing programs attached with net subcommand" id="idm46623554319144"/> Other attachments, like socket filters and reuseport programs, are accessible only by using <code>iproute2</code>.<a data-type="indexterm" data-primary="iproute2 toolkit" id="idm46623554317544"/> You can list the attachments to XDP and TC with <code>bpftool net show</code>, like you’ve seen with other BPF objects.</p>

<p>Finally, the <code>cgroup</code> subcommand lists all programs attached to cgroups.<a data-type="indexterm" data-primary="cgroups" data-secondary="inspecting programs attached to using BPFTool" id="idm46623554315432"/> This subcommand is a little bit different than the other ones you’ve seen. <code>bpftool cgroup show</code> requires the path to the cgroup you want to inspect. If you want to list all the attachments in all cgroups in the system, you’ll need to use <code>bpftool cgroup tree</code>, as shown in this example:</p>
<pre># bpftool cgroup tree
CgroupPath
ID       AttachType      AttachFlags     Name
/sys/fs/cgroup/unified/system.slice/systemd-udevd.service
    5        ingress
    4        egress
/sys/fs/cgroup/unified/system.slice/systemd-journald.service
    3        ingress
    2        egress
/sys/fs/cgroup/unified/system.slice/systemd-logind.service
    7        ingress
    6        egress</pre>

<p>Thanks to BPFTool, you can verify that your programs are attached correctly to any interface in the kernel, giving you quick visibility access to cgroups, Perf, and the network interface.</p>

<p>So far, we’ve talked about how you can enter different commands in your terminal to debug how your BPF programs behave. However, remembering all these commands can be cumbersome when you need them the most. Next we describe how to load several commands from plain-text files so that you can build a set of scripts that you can keep handy without having to retain each option that we’ve talked about.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Loading Commands in Batch Mode"><div class="sect2" id="idm46623554290376">
<h2>Loading Commands in Batch Mode</h2>

<p>It’s common to run several commands over and over while you’re trying to analyze the behavior of one or multiple systems.<a data-type="indexterm" data-primary="BPFTool" data-secondary="loading commands in batch mode" id="idm46623554288856"/><a data-type="indexterm" data-primary="commands" data-secondary="loading in batch mode with BPFTool" id="idm46623554288008"/><a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-tertiary="loading commands in batch mode" id="idm46623554287160"/> You might end up with a collection of commands that you use frequently as part of your toolchain. BPFTool’s batch mode is for you if you don’t want to type those commands every single time.<a data-type="indexterm" data-primary="batch mode, loading commands in (BPFTool)" id="idm46623554285640"/></p>

<p>With batch mode, you can write all of the commands that you want to execute in a file and run all of them at once. You can also write comments in this file by starting a line with #. However, this execution mode is not atomic. BPFTool executes <span class="keep-together">commands</span> line by line, and it will abort the execution if one of the commands fails, leaving the system in the state it was in after running the latest successful command.</p>

<p>This is a short example of a file that batch mode can process:</p>
<pre># Create a new hash map
map create /sys/fs/bpf/hash_map type hash key 4 value 4 entries 5 name hash_map
# Now show all the maps in the system
map show</pre>

<p>If you save those commands in a file called <em>/tmp/batch_example.txt</em>, you’ll be able to load it with <code>bpftool batch file /tmp/batch_example.txt</code>. You’ll get output similar to the following snippet when you run this command for the first time, but if you try to run it again, the command will exit with no output because we already have a map with the name <code>hash_map</code> in the system, and the batch execution will fail in the first line:</p>
<pre># bpftool batch file /tmp/batch_example.txt
2: lpm_trie  flags 0x1
	key 8B  value 8B  max_entries 1  memlock 4096B
3: lpm_trie  flags 0x1
	key 20B  value 8B  max_entries 1  memlock 4096B
18: hash  name hash_map  flags 0x0
	key 4B  value 4B  max_entries 5  memlock 4096B
processed 2 commands</pre>

<p>Batch mode is one of our favorite options in BPFTool. We recommend keeping these batch files in a version control system so that you can share them with your team to create your own set of utility tools. Before jumping to our next favorite utility, let’s see how BPFTool can help you understand the BPF Type Format better.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Displaying BTF Information"><div class="sect2" id="idm46623554278920">
<h2>Displaying BTF Information</h2>

<p>BPFTool can display BPF Type Format (BTF) information for any given binary object when it is present.<a data-type="indexterm" data-primary="BTF (BPF Type Format)" data-secondary="displaying information about with BPFTool" id="idm46623554277336"/><a data-type="indexterm" data-primary="BPFTool" data-secondary="displaying BTF information" id="idm46623554276264"/><a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-tertiary="displaying BTF information" id="idm46623554275256"/> As we mentioned in <a data-type="xref" href="ch02.html#running_your_first_BPF_programs">Chapter 2</a>, BTF annotates program structures with metadata information to help you debug programs.<a data-type="indexterm" data-primary="BPF Type Format" data-see="BTF" id="idm46623554272936"/></p>

<p>For example, it can give you the source file and line numbers for each instruction in a BPF program when you add the keyword <code>linum</code> to <code>prog dump</code>.</p>

<p>More recent versions of BPFTool include a new <code>btf</code> subcommand to help you dive into your programs. The initial focus of this command is to visualize structure types. For example, <code>bpftool btf dump id 54</code> shows all of the BFT types for the program loaded with an ID of 54.<a data-type="indexterm" data-primary="btf subcommand (bpftool)" id="idm46623554269176"/></p>

<p>These are some of the things you can use BPFTool for. It’s a low-friction entry point to any system, especially if you don’t work on that system on a day-to-day basis.<a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTool" data-startref="ix_utilBPFTo" id="idm46623554267880"/><a data-type="indexterm" data-primary="BPFTool" data-startref="ix_BPFTo" id="idm46623554266632"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="BPFTrace"><div class="sect1" id="idm46623554639336">
<h1>BPFTrace</h1>

<p>BPFTrace is a high-level tracing language for BPF.<a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTrace" id="ix_utilBPFTr"/><a data-type="indexterm" data-primary="BPFTrace" id="ix_BPFTr"/><a data-type="indexterm" data-primary="tracing with BPF" data-secondary="using BPFTrace" id="ix_trcBPFTr"/> It allows you to write BPF programs with a concise DSL, and save them as scripts that you can execute without having to compile and load them in the kernel manually. The language is inspired by other well-known tools, like awk and DTrace. If you’re familiar with DTrace and you’ve always missed being able to use it on Linux, you’re going to find in BPFTrace a great substitute.</p>

<p>One of the advantages of using BPFTrace over writing programs directly with BCC or other BPF tooling is that BPFTrace provides a lot of built-in functionality that you don’t need to implement yourself, such as aggregating information and creating histograms. On the other hand, the language that BPFTrace uses is much more limited, and it will get in your way if you try to implement advanced programs. In this section, we show you the most important aspects of the language. We recommend going to the <a href="https://github.com/iovisor/bpftrace">BPFTrace repository on GitHub</a> to learn about it.</p>








<section data-type="sect2" data-pdf-bookmark="Installation"><div class="sect2" id="idm46623554258808">
<h2>Installation</h2>

<p>You can install BPFTrace in several ways, although its developers recommend you use one of the prebuilt packages for your specific Linux distribution. They also maintain a document with all the installation options and prerequisites for your system in their repository. There, you’ll find instructions in the <a href="https://oreil.ly/h9Pha">installation document</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Language Reference"><div class="sect2" id="idm46623554256136">
<h2>Language Reference</h2>

<p>The programs that BPFTrace executes have a terse syntax. We can divide them into three sections: header, action blocks, and footer.<a data-type="indexterm" data-primary="BPFTrace" data-secondary="language reference" id="idm46623554254072"/><a data-type="indexterm" data-primary="headers (BPFTrace)" id="idm46623554253096"/> The header is a special block that BPFTrace executes when it loads the program; it’s commonly used to print some information at the top of the output, like a preamble. <a data-type="indexterm" data-primary="footers (BPFTrace)" id="idm46623554252104"/>In the same way, the footer is a special block that BPFTrace executes once before terminating the program. Both the header and footer are optional sections in a BPFTrace program. A BPFTrace program must have at least one <em>action block</em>.<a data-type="indexterm" data-primary="action blocks (BPFTrace)" id="idm46623554250680"/> Action blocks are where we specify the probes that we want to trace and the actions we perform when the kernel fires the events for those probes.<a data-type="indexterm" data-primary="probes" data-secondary="specifying for BPFTrace" id="idm46623554249640"/> The next snippet shows you these three sections in a basic example:</p>

<pre data-type="programlisting" data-code-language="bash">BEGIN
<code class="o">{</code>
  <code class="nb">printf</code><code class="o">(</code><code class="s2">"starting BPFTrace program\n"</code><code class="o">)</code>
<code class="o">}</code>

kprobe:do_sys_open
<code class="o">{</code>
  <code class="nb">printf</code><code class="o">(</code><code class="s2">"opening file descriptor: %s\n"</code>, str<code class="o">(</code>arg1<code class="o">))</code>
<code class="o">}</code>

END
<code class="o">{</code>
  <code class="nb">printf</code><code class="o">(</code><code class="s2">"exiting BPFTrace program\n"</code><code class="o">)</code>
<code class="o">}</code></pre>

<p>The header section is always marked with the keyword <code>BEGIN</code>, and the footer section is always marked with the keyword <code>END</code>. These keywords are reserved by BPFTrace.<a data-type="indexterm" data-primary="BEGIN and END keywords (BPFTrace)" id="idm46623554226120"/> Action block identifiers define the probe to which you want to attach the BPF action. In the previous example, we printed a log line every time the kernel opens a file.</p>

<p>Besides identifying the program sections, we can already see a few more details about the language syntax in the previous examples. <a data-type="indexterm" data-primary="helper functions in BPFTrace" id="idm46623554241864"/>BPFTrace provides some helpers that are translated to BPF code when the program is compiled. The helper <code>printf</code> is a wrapper around the C function <code>printf</code>, which prints program details when you need it. <code>str</code> is a built-in helper that translates a C pointer to its string representation. Many kernel functions receive pointers to characters as arguments; this helper translates those pointers to strings for you.</p>

<p>BPFTrace could be considered a dynamic language in the sense that it doesn’t know the number of arguments a probe might receive when it’s executed by the kernel. This is why BPFTrace provides argument helpers to access the information that the kernel processes.<a data-type="indexterm" data-primary="argument helpers (in BPFTrace)" id="idm46623554238728"/> BPFTrace generates these helpers dynamically depending on the number of arguments the block receives, and you can access the information by its position in the list of arguments. In the previous example, <code>arg1</code> is the reference to the second argument in the <code>open</code> syscall, which makes reference to the file path.</p>

<p>To execute this example, you can save it in a file and run BPFTrace with the file path as the first argument:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftrace /tmp/example.bt</code></pre>

<p>BPFTrace’s language is designed with scripting in mind. In the previous examples, you’ve seen the terse version of the language, so you can get familiar with it. But many of the programs that you can write with BPFTrace fit on one single line. You don’t need to store those one-line programs in files to execute them; you can run them with the option <code>-e</code> when you execute BPFTrace. For example, the previous counter example can be a one-liner by collapsing the action block into a single line:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># bpftrace -e "kprobe:do_sys_open { @opens[str(arg1)] = count() }"</code></pre>

<p>Now that you know a little bit more about BPFTrace’s language, let’s see how to use it in several scenarios.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Filtering"><div class="sect2" id="idm46623554255480">
<h2>Filtering</h2>

<p>When you run the previous example, you probably get a stream of files that your system is constantly opening, until you press Ctrl-C to exit the program.<a data-type="indexterm" data-primary="BPFTrace" data-secondary="filtering" id="idm46623554201752"/><a data-type="indexterm" data-primary="filtering" data-secondary="in BPFTrace" id="idm46623554200776"/> That’s because we’re telling BPF to print every file descriptor that the kernel opens. There are situations when you want to execute the action block only for specific conditions. BPFTrace calls that <em>filtering</em>.</p>

<p>You can associate one filter to each action block. They are evaluated like action blocks, but the action does not execute if the filter returns a false value.<a data-type="indexterm" data-primary="action blocks (BPFTrace)" data-secondary="associating a filter with" id="idm46623554208552"/> They also have access to the rest of the language, including probe arguments and helpers. These filters are encapsulated within two slashes after the action header:</p>

<pre data-type="programlisting" data-code-language="bash">kprobe:do_sys_open /str<code class="o">(</code>arg1<code class="o">)</code> <code class="o">==</code> <code class="s2">"/tmp/example.bt"</code>/
<code class="o">{</code>
  <code class="nb">printf</code><code class="o">(</code><code class="s2">"opening file descriptor: %s\n"</code>, str<code class="o">(</code>arg1<code class="o">))</code>
<code class="o">}</code></pre>

<p>In this example, we refine our action block to be executed only when the file the kernel is opening is the file that we’re using to store this example. If you run the program with the new filter, you’ll see that it prints the header, but it stops printing there. This is because every file that was triggering our action before is being skipped now thanks to our new filter. If you open the example file several times in a different terminal, you’ll see how the kernel executes the action when the filter matches our file path:</p>
<pre># bpftrace /tmp/example.bt
Attaching 3 probes...
starting BPFTrace program
opening file descriptor: /tmp/example.bt
opening file descriptor: /tmp/example.bt
opening file descriptor: /tmp/example.bt
^Cexiting BPFTrace program</pre>

<p>BPFTrace’s filtering capabilities are super helpful to hide information that you don’t need, keeping data scoped to what you really care about. Next we talk about how BPFTrace makes working with maps seamless.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Dynamic Mapping"><div class="sect2" id="idm46623554170872">
<h2>Dynamic Mapping</h2>

<p>One handy feature that BPFTrace implements is dynamic map associations.<a data-type="indexterm" data-primary="BPFTrace" data-secondary="dynamic mapping with" id="idm46623554169336"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="dynamic mapping in BPFTrace" id="idm46623554168360"/> It can generate BPF maps dynamically that you can use for many of the operations you’ve seen throughout the book. All map associations start with the character <code>@</code>, followed by the name of the map that you want to create. You can also associate update elements in those maps by assigning them values.</p>

<p>If we take the example that we started this section with, we could aggregate how often our system opens specific files. To do that, we need to count how many times the kernel runs the <code>open</code> syscall on a specific file, and then store those counters in a map. To identify those aggregations, we can use the file path as the map’s key. This is how our action block would look in this case:</p>

<pre data-type="programlisting" data-code-language="bash">kprobe:do_sys_open
<code class="o">{</code>
  @opens<code class="o">[</code>str<code class="o">(</code>arg1<code class="o">)]</code> <code class="o">=</code> count<code class="o">()</code>
<code class="o">}</code></pre>

<p>If you run your program again, you’ll get output similar to this:</p>
<pre># bpftrace /tmp/example.bt
Attaching 3 probes...
starting BPFTrace program
^Cexiting BPFTrace program

@opens[/var/lib/snapd/lib/gl/haswell/libdl.so.2]: 1
@opens[/var/lib/snapd/lib/gl32/x86_64/libdl.so.2]: 1
...
@opens[/usr/lib/locale/en.utf8/LC_TIME]: 10
@opens[/usr/lib/locale/en_US/LC_TIME]: 10
@opens[/usr/share/locale/locale.alias]: 12
@opens[/proc/8483/cmdline]: 12</pre>

<p>As you can see, BPFTrace prints the contents of the map when it stops the program execution. And as we expected, it’s aggregating how often the kernel is opening the files in our system. By default, BPFTrace is always going to print the contents of every map it creates when it terminates. You don’t need to specify that you want to print a map; it always assumes that you want to. You can change that behavior by clearing the map inside the <code>END</code> block by using the built-in function <code>clear</code>. This works because printing maps always happens after the footer block is executed.</p>

<p>BPFTrace dynamic mapping is super convenient. It removes a lot of boilerplate required to work with maps and focuses on helping you to collect data easily.</p>

<p>BPFTrace is a powerful tool for your day-to-day tasks. Its scripting language gives you enough flexibility to access every aspect of your system without the ceremony of having to compile and load your BPF program into the kernel manually, and this can help you trace and debug problems in your system from the get-go. Check out the reference guide in its GitHub repository to learn how to take advantage of all of its built-in capabilities, such as automatic histograms and stack trace aggregations.</p>

<p>In the next section we explore how to use BPFTrace inside Kubernetes.<a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="BPFTrace" data-startref="ix_utilBPFTr" id="idm46623554113816"/><a data-type="indexterm" data-primary="tracing with BPF" data-secondary="using BPFTrace" data-startref="ix_trcBPFTr" id="idm46623554112568"/><a data-type="indexterm" data-primary="BPFTrace" data-startref="ix_BPFTr" id="idm46623554111352"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="kubectl-trace"><div class="sect1" id="idm46623554170280">
<h1>kubectl-trace</h1>

<p><code>kubectl-trace</code> is a fantastic plug-in for the Kubernetes command line, <code>kubectl</code>.<a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="kubectl-trace" id="ix_utilkutr"/><a data-type="indexterm" data-primary="tracing with BPF" data-secondary="kubectl-trace plugin" id="ix_trcBPFkutr"/><a data-type="indexterm" data-primary="kubectl-trace" id="ix_kubectltr"/><a data-type="indexterm" data-primary="BPFTrace" data-secondary="using in Kubernetes with kubectl-trace" id="ix_BPFTrku"/> It helps you schedule BPFTrace programs in your Kubernetes cluster without having to install any additional packages or modules. It does this by scheduling a Kubernetes job with a container image that has everything you need to run the program installed already. This image is called <code>trace-runner</code>, and it’s also available in the public Docker registry.</p>








<section data-type="sect2" data-pdf-bookmark="Installation"><div class="sect2" id="idm46623554075800">
<h2>Installation</h2>

<p>You need to install <code>kubectl-trace</code> from its source repository using Go’s toolchain because its<a data-type="indexterm" data-primary="kubectl-trace" data-secondary="installation" id="idm46623554074024"/> developers don’t provide any binary package:</p>

<pre data-type="programlisting" data-code-language="bash">go get -u github.com/iovisor/kubectl-trace/cmd/kubectl-trace</pre>

<p><code>kubectl</code>’s plug-in system will automatically detect this new add-on after Go’s toolchain compiles the program and puts it in the path. <code>kubectl-trace</code> automatically downloads the Docker images that it needs to run in your cluster the first time that you execute it.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Inspecting Kubernetes Nodes"><div class="sect2" id="idm46623554035288">
<h2>Inspecting Kubernetes Nodes</h2>

<p>You can use <code>kubectl-trace</code> to target nodes and pods where containers run, and you can also use it to target processes running on those containers. <a data-type="indexterm" data-primary="kubectl-trace" data-secondary="inspecting Kubernetes nodes" id="idm46623554033064"/>In the first case, you can run pretty much any BPF program that you’d like. However, in the second case, you’re restricted to running only the programs that attach user-space probes to those processes.</p>

<p>If you want to run a BPF program on a specific node, you need a proper identifier so that Kubernetes schedules the job in the appropriate place.<a data-type="indexterm" data-primary="nodes (Kubernetes), running BPF program on" id="idm46623554031224"/><a data-type="indexterm" data-primary="programs (BPF)" data-secondary="running in Kubernetes with kubectl-trace" id="idm46623554030488"/> After you have that identifier, running the program is similar to running the programs you saw earlier. This is how we would run our one-liner to count file openings:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># kubectl trace run node/node_identifier -e \</code>
  <code class="s2">"kprobe:do_sys_open { @opens[str(arg1)] = count() }"</code></pre>

<p>As you can see, the program is exactly the same, but we’re using the command <code>kubectl trace run</code> to schedule it in a specific cluster node. We use the syntax <code>node/...</code> to tell <code>kubectl-trace</code> that we’re targetting a node in the cluster. If we want to target a specific pod, we’d replace <code>node/</code> with <code>pod/</code>.</p>

<p>Running a program on a specific container requires <a data-type="indexterm" data-primary="containers" data-secondary="running BPF program on Kubernetes container" id="idm46623554010824"/>longer syntax; let’s see an example first and go through it:</p>
<pre># kubectl trace run pod/pod_identifier -n application_name -e &lt;&lt;PROGRAM
uretprobe:/proc/$container_pid/exe:"main.main" {
  printf("exit: %d\n", retval)
}
PROGRAM</pre>

<p>There are two interesting things to highlight in this command. The first is that we need the name of the application running in the container to be able to find its process; this corresponds with the <code>application_name</code> in our example. You’ll want to use the name of the binary that’s executed in the container, for example <code>nginx</code> or <code>memcached</code>. Usually, containers run only one process, but this gives us extra guarantees that we’re attaching our program to the correct process. The second aspect to highlight is the inclusion of <code>$container_pid</code> in our BPF program. This is not a BPFTrace helper, but a placeholder that <code>kubectl-trace</code> uses as a replacement for the process identifier. Before running the BPF program, the trace-runner substitutes the placeholder with the appropriate identifier, and it attaches our program to the correct <span class="keep-together">process</span>.</p>

<p>If you run Kubernetes in production, <code>kubectl-trace</code> will make your life much easier when you need to analyze your containers’ behavior.</p>

<p>In this and the previous sections, we’ve focused on tools to help you run BPF programs more efficiently, even within container environments. In the next section we talk about a nice tool to integrate data gathering from BPF programs with Prometheus, a well-known open source monitoring system.<a data-type="indexterm" data-primary="BPFTrace" data-secondary="using in Kubernetes with kubectl-trace" data-startref="ix_BPFTrku" id="idm46623554003384"/><a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="kubectl-trace" data-startref="ix_utilkutr" id="idm46623554049944"/><a data-type="indexterm" data-primary="tracing with BPF" data-secondary="kubectl-trace plugin" data-startref="ix_trcBPFkutr" id="idm46623554048728"/><a data-type="indexterm" data-primary="kubectl-trace" data-startref="ix_kubectltr" id="idm46623554047512"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="eBPF Exporter"><div class="sect1" id="idm46623554046440">
<h1>eBPF Exporter</h1>

<p>eBPF Exporter is a tool that allows you to export custom BPF tracing metrics to Prometheus.<a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="eBPF Exporter" id="ix_utileBPF"/><a data-type="indexterm" data-primary="Prometheus, exporting BPF tracing metrics to" id="idm46623554043784"/><a data-type="indexterm" data-primary="eBPF Exporter" id="ix_eBPF"/> Prometheus is a highly scalable monitoring and alerting system. One key factor that makes Prometheus different from other monitoring systems is that it uses a pull strategy to fetch metrics, instead of expecting the client to push metrics to it. This allows users to write custom exporters that can gather metrics from any system, and Prometheus will pull them using a well-defined API schema. eBPF Exporter implements this API to fetch tracing metrics from BPF programs and import them into Prometheus.</p>








<section data-type="sect2" data-pdf-bookmark="Installation"><div class="sect2" id="idm46623554041416">
<h2>Installation</h2>

<p>Although eBPF Exporter offers binary packages, we recommend installing it from source because there are often no new releases.<a data-type="indexterm" data-primary="eBPF Exporter" data-secondary="installation" id="idm46623554039976"/> Building from source also gives you access to newer functionality built on top of modern versions of BCC, the BPF Compiler Collection.</p>

<p>To install eBPF Exporter from the source, you need to have BCC and Go’s toolchain already installed on your computer.<a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" data-secondary="prerequisite for eBPF Exporter installation" id="idm46623553981064"/><a data-type="indexterm" data-primary="Go language" data-secondary="using to download/install eBPF Exporter" id="idm46623553980216"/> With those prerequisites, you can use Go to download and build the binary for you:</p>

<pre data-type="programlisting" data-code-language="bash">go get -u github.com/cloudflare/ebpf_exporter/...</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Exporting Metrics from BPF"><div class="sect2" id="idm46623553977368">
<h2>Exporting Metrics from BPF</h2>

<p>eBPF Exporter is configured using YAML files, in which you can specify the metrics that you want to collect from the system, the BPF program that generates those <span class="keep-together">metrics</span>, and how they translate to Prometheus.<a data-type="indexterm" data-primary="YAML config files (eBPF Exporter)" id="idm46623553974936"/><a data-type="indexterm" data-primary="metrics" data-secondary="exporting from BPF to Prometheus" id="idm46623553972920"/><a data-type="indexterm" data-primary="Prometheus, exporting BPF tracing metrics to" id="idm46623553972008"/><a data-type="indexterm" data-primary="eBPF Exporter" data-secondary="exporting BPF metrics to Prometheus" id="idm46623553971304"/> When Prometheus sends a request to eBPF Exporter to pull metrics, this tool translates the information that the BPF programs are collecting to metric values. Fortunately, eBPF Exporter bundles many programs that collect very useful information from your system, like instructions per cycle (IPC) and CPU cache hit rates.</p>

<p>A simple configuration file for eBPF Exporter includes three main sections. In the first section, you define the metrics that you want Prometheus to pull from the system. Here is where you translate the data collected in BPF maps to metrics that Prometheus understands. Following is an example of these translations from the project’s examples:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">programs</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">timers</code>
    <code class="nt">metrics</code><code class="p">:</code>
      <code class="nt">counters</code><code class="p">:</code>
        <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">timer_start_total</code>
          <code class="nt">help</code><code class="p">:</code> <code class="l-Scalar-Plain">Timers fired in the kernel</code>
          <code class="nt">table</code><code class="p">:</code> <code class="l-Scalar-Plain">counts</code>
          <code class="nt">labels</code><code class="p">:</code>
            <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">function</code>
              <code class="nt">size</code><code class="p">:</code> <code class="l-Scalar-Plain">8</code>
              <code class="nt">decoders</code><code class="p">:</code>
                <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ksym</code></pre>

<p>We’re defining a metric called <code>timer_start_total</code>, which aggregates how often the kernel starts a timer. We also specify that we want to collect this information from a BPF map called <code>counts</code>. Finally, we define a translation function for the map keys. This is necessary because map keys are usually pointers to the information, and we want to send Prometheus the actual function names.</p>

<p>The second section in this example describes the probes we want to attach our BPF program to.<a data-type="indexterm" data-primary="probes" data-secondary="attaching program to" data-tertiary="in eBPF Exporter" id="idm46623553898280"/> In this case, we want to trace the timer start calls; we use the tracepoint <code>timer:timer_start</code> for that:</p>

<pre data-type="programlisting" data-code-language="bash">    tracepoints:
      timer:timer_start: tracepoint__timer__timer_start</pre>

<p>Here we’re telling eBPF Exporter that we want to attach the BPF function <code>tracepoint__timer__timer_start</code> to this specific tracepoint. Let’s see how to declare that function next:</p>

<pre data-type="programlisting" data-code-language="bash">    code: <code class="p">|</code>
      BPF_HASH<code class="o">(</code>counts, u64<code class="o">)</code><code class="p">;</code>
      // Generates <code class="k">function</code> tracepoint__timer__timer_start
      TRACEPOINT_PROBE<code class="o">(</code>timer, timer_start<code class="o">)</code> <code class="o">{</code>
          counts.increment<code class="o">((</code>u64<code class="o">)</code> args-&gt;function<code class="o">)</code><code class="p">;</code>
          <code class="k">return</code> 0<code class="p">;</code>
      <code class="o">}</code></pre>

<p>The BPF program is inlined within the YAML file. This is probably one of our less favorite parts of this tool because YAML is particular about whitespacing, but it works for small programs like this one. eBPF Exporter uses BCC to compile programs, so we have access to all its macros and helpers.<a data-type="indexterm" data-primary="TRACEPOINT_PROBE macro" id="idm46623553886648"/> The previous snippet uses the macro <code>TRACEPOINT_PROBE</code> to generate the final function that we’ll attach to our tracepoint with the name <code>tracepoint__timer__timer_start</code>.</p>

<p>Cloudflare uses eBPF Exporter to monitor metrics across all of its datacenters. The company made sure to bundle the most common metrics that you’ll want to export from your systems. But as you can see, it’s relatively easy to extend with new metrics.<a data-type="indexterm" data-primary="utilities (BPF)" data-secondary="eBPF Exporter" data-startref="ix_utileBPF" id="idm46623553884488"/><a data-type="indexterm" data-primary="eBPF Exporter" data-startref="ix_eBPF" id="idm46623553883240"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46623553882168">
<h1>Conclusion</h1>

<p>In this chapter we talked about some of the our favorite tools for system analysis. These tools are general enough to have them on hand when you need to debug any kind of anomaly on your system. As you can see, all these tools abstract the concepts that we saw in the previous chapters to help you use BPF even when the environment is not ready for it. This is one of the many advantages of BPF before other analysis tools; because any modern Linux kernel includes the BPF VM, you can build new tools on top that take advantage of these powerful capabilities.</p>

<p>There are many other tools that use BPF for similar purposes, such as Cilium and Sysdig, and we encourage you to try them.</p>

<p>This chapter and <a data-type="xref" href="ch04.html#tracing_with_bpf">Chapter 4</a> dealt mostly with system analysis and tracing, but there is much more that you can do with BPF. In the next chapters we dive into its networking capabilities. We show you how to analyze traffic in any network and how to use BPF to control messages in your network.<a data-type="indexterm" data-primary="utilities (BPF)" data-startref="ix_util" id="idm46623553878168"/></p>
</div></section>







</div></section></body></html>