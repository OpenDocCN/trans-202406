<html><head></head><body><section data-pdf-bookmark="Chapter 18. Desktop Applications with Electron" data-type="chapter" epub:type="chapter"><div class="chapter" id="desktop-introduction">&#13;
<h1><span class="label">Chapter 18. </span>Desktop Applications with Electron</h1>&#13;
&#13;
&#13;
<p><a data-primary="Electron" data-type="indexterm" id="ix_ch18-asciidoc0"/>My<a data-primary="Electron" data-secondary="about" data-type="indexterm" id="idm45339487015672"/> introduction to personal computers was in a school lab full of Apple II machines. Once a week, my classmates and I were ushered into the room, handed some floppy disks, and given a rough set of instructions on how to load an application (typically <em>Oregon Trail</em>). I don’t remember much from these sessions other than feeling completely <em>locked in</em> to the little world I was now able to control. Personal computers have come a long way since the mid-1980s, but we still rely on desktop applications to perform many tasks.</p>&#13;
&#13;
<p>On a typical day, I may access an email client, a text editor, a chat client, spreadsheet software, a music streaming service, and several more desktop applications. Oftentimes, these have a web application equivalent, but the convenience and integration of a desktop application can provide several user experience benefits. However, for years the ability to create these applications felt out of reach. Thankfully, today we are able to use web technologies to build fully featured desktop applications with a small learning curve.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’re Building" data-type="sect1"><div class="sect1" id="idm45339486949496">&#13;
<h1>What We’re Building</h1>&#13;
&#13;
<p>Over the next few chapters we’ll build a desktop client for our social note application, Notedly. Our goal is to use JavaScript and web technologies to develop a desktop application that a user can download and install on their computer. For now, this application will be a simple implementation that wraps our web application within a desktop application shell. Developing our app in this way will allow us to quickly ship a desktop app to those users who are interested, while providing us the flexibility to introduce a custom application for desktop users at a later date.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How We’re Going To Build This" data-type="sect1"><div class="sect1" id="idm45339486947480">&#13;
<h1>How We’re Going To Build This</h1>&#13;
&#13;
<p>To build our application, we’ll be using <a href="https://electronjs.org">Electron</a>, an open source framework for building cross-platform desktop applications with web technologies. It works by utilizing Node.js and Chrome’s underlying browser engine, Chromium. This means that as developers we have access to the world of the browser, Node.js, and operating system–specific abilities, which are typically unavailable in a web environment. Electron was originally developed by GitHub for the <a href="https://atom.io">Atom text editor</a>, but has since been used as a platform for applications both big and small, including Slack, VS Code, Discord, and WordPress Desktop.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45339486943880">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p><a data-primary="Electron" data-secondary="getting started" data-type="indexterm" id="idm45339486942504"/>Before we can start development, we need to make a copy of the&#13;
project starter files to our machine. The <a href="https://github.com/javascripteverywhere/desktop">project’s source code</a> contains all of the scripts and references to third-party libraries that we will need to develop your application. To clone the code to our local machine, open the terminal, navigate to the directory where you keep your projects, and <strong><code>git clone</code></strong> the project repository. If you’ve worked through the API and web chapters, you may also have already created a <em>notedly</em> directory to keep the project code organized:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code><code class="nb">cd </code>Projects&#13;
<code class="nv">$ </code><code class="c"># type the `mkdir notedly` command if you don't yet have a notedly directory</code>&#13;
<code class="nv">$ </code><code class="nb">cd </code>notedly&#13;
<code class="nv">$ </code>git clone git@github.com:javascripteverywhere/desktop.git&#13;
<code class="nv">$ </code><code class="nb">cd </code>desktop&#13;
<code class="nv">$ </code>npm install</pre>&#13;
<div data-type="note" epub:type="note"><h1>Installing Third-Party Dependencies</h1>&#13;
<p>By making a copy of the book’s starter code and running <code>npm install</code> in the directory, you avoid having to again run <code>npm install</code> for any of the individual third-party dependencies.</p>&#13;
</div>&#13;
&#13;
<p>The code is structured as follows:</p>&#13;
<dl>&#13;
<dt>/src</dt>&#13;
<dd>&#13;
<p>This is the directory where you should perform your&#13;
development as you follow along with the book.</p>&#13;
</dd>&#13;
<dt>/solutions</dt>&#13;
<dd>&#13;
<p>This directory contains the solutions for each chapter.&#13;
If you get stuck, these are available for you to consult.</p>&#13;
</dd>&#13;
<dt>/final</dt>&#13;
<dd>&#13;
<p>This directory contains the final working project.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>With our project directory created and dependencies installed, we are ready to begin our development.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Our First Electron App" data-type="sect1"><div class="sect1" id="idm45339486927224">&#13;
<h1>Our First Electron App</h1>&#13;
&#13;
<p><a data-primary="Electron" data-secondary="developing" data-type="indexterm" id="idm45339486915720"/>With our repository cloned to our machine, let’s develop our first Electron app. If you look within your <em>src</em> directory, you’ll see that there are a few files. The <em>index.html</em> file contains bare-bones HTML markup. For now, this file will serve as Electron’s “renderer process,” meaning that it will be the web page displayed as a window by our Electron application.</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="nt">&lt;html&gt;</code>&#13;
  <code class="nt">&lt;head&gt;</code>&#13;
    <code class="nt">&lt;meta</code> <code class="na">charset=</code><code class="s">"UTF-8"</code><code class="nt">&gt;</code>&#13;
    <code class="nt">&lt;title&gt;</code>Notedly Desktop<code class="nt">&lt;/title&gt;</code>&#13;
  <code class="nt">&lt;/head&gt;</code>&#13;
  <code class="nt">&lt;body&gt;</code>&#13;
    <code class="nt">&lt;h1&gt;</code>Hello World!<code class="nt">&lt;/h1&gt;</code>&#13;
  <code class="nt">&lt;/body&gt;</code>&#13;
<code class="nt">&lt;/html&gt;</code></pre>&#13;
&#13;
<p>The <em>index.js</em> file is where we will set up our Electron application. In our application, this file will contain what Electron calls the <a data-primary="main process" data-type="indexterm" id="idm45339486905176"/>“main process,” which defines the application shell. The main process works by creating a <code>BrowserWindow</code> instance in Electron, which serves as the application shell.</p>&#13;
<div data-type="note" epub:type="note"><h1>index.js Versus main.js</h1>&#13;
<p>Though I’ve named the file <em>index.js</em> to follow the pattern found in the rest of our sample applications, it is common in Electron development to name the “main process” file <em>main.js</em>.</p>&#13;
</div>&#13;
&#13;
<p>Let’s set up our main process to display a browser window containing our HTML page. First, import Electron’s <code>app</code> and<a data-primary="browserWindow" data-type="indexterm" id="idm45339486867560"/> <code>browserWindow</code> functionality in <em>src/index.js</em>:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="p">{</code> <code class="nx">app</code><code class="p">,</code> <code class="nx">BrowserWindow</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'electron'</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now we can define our application’s <code>browserWindow</code> and define the file that our application will load. In <em>src/index.js</em>, add the following:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="p">{</code> <code class="nx">app</code><code class="p">,</code> <code class="nx">BrowserWindow</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'electron'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// to avoid garbage collection, declare the window as a variable</code>&#13;
<code class="kd">let</code> <code class="nb">window</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// specify the details of the browser window</code>&#13;
<code class="kd">function</code> <code class="nx">createWindow</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="nb">window</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">BrowserWindow</code><code class="p">({</code>&#13;
    <code class="nx">width</code><code class="o">:</code> <code class="mi">800</code><code class="p">,</code>&#13;
    <code class="nx">height</code><code class="o">:</code> <code class="mi">600</code><code class="p">,</code>&#13;
    <code class="nx">webPreferences</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">nodeIntegration</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="c1">// load the HTML file</code>&#13;
  <code class="nb">window</code><code class="p">.</code><code class="nx">loadFile</code><code class="p">(</code><code class="s1">'index.html'</code><code class="p">);</code>&#13;
&#13;
  <code class="c1">// when the window is closed, reset the window object</code>&#13;
  <code class="nb">window</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'closed'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nb">window</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// when electron is ready, create the application window</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'ready'</code><code class="p">,</code> <code class="nx">createWindow</code><code class="p">);</code></pre>&#13;
&#13;
<p>With this in place, we are ready to run our desktop application locally. In your terminal application, from your project’s directory, run the following:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm start</pre>&#13;
&#13;
<p>This command will run <code>electron src/index.js</code>, launching a development environment version of our application (see <a data-type="xref" href="#desktop_helloworld">Figure 18-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="desktop_helloworld">&#13;
<img alt="An image of our 'Hello World' Electron application" src="assets/jsev_1801.png"/>&#13;
<h6><span class="label">Figure 18-1. </span>Running the start command will launch our “Hello World” Electron <span class="keep-together">application</span></h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="macOS Application Window Details" data-type="sect1"><div class="sect1" id="idm45339486916728">&#13;
<h1>macOS Application Window Details</h1>&#13;
&#13;
<p><a data-primary="Electron" data-secondary="macOS application window details" data-type="indexterm" id="idm45339486715816"/><a data-primary="macOS" data-secondary="Electron and" data-type="indexterm" id="idm45339486714872"/>macOS handles application windows differently from Windows. When a user clicks the “close window” button, the application window closes, but the application itself does not quit. Clicking the application’s icon in the macOS dock will reopen the application window. Electron allows us to implement this functionality. Add the following to the bottom of the <em>src/index.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// quit when all windows are closed.</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'window-all-closed'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// On macOS only quit when a user explicitly quits the application</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">platform</code> <code class="o">!==</code> <code class="s1">'darwin'</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">app</code><code class="p">.</code><code class="nx">quit</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'activate'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// on macOS, re-create the window when the icon is clicked in the dock</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nb">window</code> <code class="o">===</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">createWindow</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>With this added, you can see these changes by quitting the application and rerunning it with the <code>npm start</code> command. Now, if a user is accessing our application with macOS, they will see the expected behavior when closing a window.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Developer Tools" data-type="sect1"><div class="sect1" id="idm45339486614712">&#13;
<h1>Developer Tools</h1>&#13;
&#13;
<p><a data-primary="developer tools" data-type="indexterm" id="idm45339486613176"/><a data-primary="Electron" data-secondary="developer tools" data-type="indexterm" id="idm45339486612472"/>Since Electron is based on the Chromium browser engine (the engine behind Chrome, Microsoft Edge, Opera, and <a href="https://oreil.ly/iz_GY">many other browsers</a>), it also gives us access to Chromium’s Developer Tools. This allows us to perform all of the same JavaScript debugging that we might do in a browser environment. Let’s check if our application is in development mode and, if so, automatically open dev tools when our app launches.</p>&#13;
&#13;
<p>To perform this check, we’ll use the<a data-primary="electron-util library" data-type="indexterm" id="idm45339486609896"/> <a href="https://oreil.ly/JAf2Q"><code>electron-util</code> library</a>. This is a small collection of utilities that will allow us to easily check system conditions and simplifies boilerplate code for common Electron patterns. For now, we’ll be making use of the <code>is</code> module, which will allow us to check if our application is in development mode.</p>&#13;
&#13;
<p>At the top of our <em>src/index.js</em> file, import the module:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="p">{</code> <code class="nx">is</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'electron-util'</code><code class="p">);</code></pre>&#13;
&#13;
<p class="pagebreak-before">Now, in our application code, we can add the following on the line below <span class="keep-together"><code>window.</code></span><code>loadFile(<em>index.html</em>)</code> where we load our HTML file, which will open the development tools when the application is in a development environment (<a data-type="xref" href="#desktop_devtools">Figure 18-2</a>):</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// if in development mode, open the browser dev tools</code>&#13;
<code class="k">if</code> <code class="p">(</code><code class="nx">is</code><code class="p">.</code><code class="nx">development</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nb">window</code><code class="p">.</code><code class="nx">webContents</code><code class="p">.</code><code class="nx">openDevTools</code><code class="p">();</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="desktop_devtools">&#13;
<img alt="A screenshot of our 'Hello World' application with the browser's dev tools open" src="assets/jsev_1802.png"/>&#13;
<h6><span class="label">Figure 18-2. </span>Now when we open our application during development, the browser dev tools will automatically open</h6>&#13;
</div></figure>&#13;
<div data-type="caution"><h1>Electron Security Warning</h1>&#13;
<p>You may notice that our Electron app currently displays a security warning related to an insecure Content Security Policy (CSP). We will address this warning in the next chapter.</p>&#13;
</div>&#13;
&#13;
<p>With easy access to the browser dev tools, we are well prepared to develop a client application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="The Electron API" data-type="sect1"><div class="sect1" id="idm45339486614120">&#13;
<h1>The Electron API</h1>&#13;
&#13;
<p><a data-primary="application programming interface (API)" data-secondary="Electron" data-type="indexterm" id="idm45339486516712"/><a data-primary="Electron" data-secondary="API" data-type="indexterm" id="idm45339486515768"/>One of the advantages of desktop development is that, through the Electron API, we gain access to operating system-level features that are rightfully unavailable in a web browser environment, including:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Notifications</p>&#13;
</li>&#13;
<li>&#13;
<p>Native file drag and drop</p>&#13;
</li>&#13;
<li>&#13;
<p>macOS Dark Mode</p>&#13;
</li>&#13;
<li>&#13;
<p>Custom menus</p>&#13;
</li>&#13;
<li>&#13;
<p>Robust keyboard shortcuts</p>&#13;
</li>&#13;
<li>&#13;
<p>System dialogs</p>&#13;
</li>&#13;
<li>&#13;
<p>The application tray</p>&#13;
</li>&#13;
<li>&#13;
<p>System information</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>As you can imagine, these options allow us to add some unique features and improved user experiences to our desktop clients. We won’t be using these in our simple sample application, but it is worth familiarizing yourself with them. <a href="https://electronjs.org/docs">Electron’s documentation</a> provides detailed examples of each of Electron’s APIs. Additionally, the Electron team has created <a href="https://oreil.ly/Xo7NM"><code>electron-api-demos</code></a>, a fully functioning Electron application that demonstrates many of the unique features of the Electron API.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45339486578904">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>In this chapter we’ve explored the basics of using Electron to build desktop applications with web technologies. The Electron environment offers us, as developers, an opportunity to provide a cross-platform desktop experience to users without learning the intricacies of multiple programming languages and operating systems. Armed with the simple setup we’ve explored in this chapter and knowledge of web development, we are well prepared to build robust desktop applications. In the next chapter, we’ll look at how we can incorporate an existing web app into an Electron shell.<a data-startref="ix_ch18-asciidoc0" data-type="indexterm" id="idm45339486577000"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>