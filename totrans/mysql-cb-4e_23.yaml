- en: Chapter 23\. Monitoring the MySQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 23.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers how to monitor the MySQL Server using various command line
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: The mysqladmin interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information and Performance Schemas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage engines diagnostics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter doesn’t cover managing administrative tasks. Instead, it focuses
    on the server’s observability. Administrators or developers should evaluate outcomes
    from various command line tools on the MySQL server carefully before taking action
    and modifying configuration changes listed in [Chapter 22](ch22.xhtml#nch-admin).
    Rather it discusses what you can find out, and how, by surveying the types of
    information available and how to use that information to answer questions. The
    purpose is not so much to consider specific monitoring problems to illustrate
    your options so you can begin to answer your questions, whatever they are. In
    the case of reactive monitoring on an issue, follow one of the below options.
  prefs: []
  type: TYPE_NORMAL
- en: Determine which of the available information sources pertain to the problem
    at hand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose an approach for using the information: Are you asking a one-time question?
    If so, maybe a few interactive queries are sufficient. If you’re trying to solve
    an issue that may recur or for which you need continuous monitoring, a program-oriented
    approach is better. Will a script written entirely in SQL do the job, or do you
    need to write a program that queries the server and performs additional manipulation
    of the information obtained? (This is typical for operations that cannot be done
    in pure SQL, that have special output formatting requirements, and so forth.)
    If a task must run periodically, maybe you need to set up a scheduled event or
    *cron* job. For browser display, write a web script.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some of the techniques shown here require administrative access, such as accessing
    log files in operating system `MySQL` or use statements that require the `SUPER`
    privilege. For this reason, to carry out the operations described here, you’ll
    likely need to connect to the server as `root` rather than as `cbuser` or grant
    SUPER to cbuser. MySQL installation created ‘root'@'localhost’ superuser account
    that has all privileges as the database user.
  prefs: []
  type: TYPE_NORMAL
- en: 23.1 Why Monitor MySQL Server?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to monitor the server to capture its state, which allows you to verify
    or change settings explained in [Chapter 22](ch22.xhtml#nch-admin) . Knowing the
    state of MySQL server’s wait events and status counters reveals so much information
    about the server limits. Wait events are performance indicators of the server.
    Monitoring can be utilized in two different areas. The most common reasons for
    monitoring needs are troubleshooting errors, crashes or failures. The others may
    include better utilization of hardware layer used for available resources such
    as memory, I/O subsystem, CPU utilization and network bandwidth. Due to hardware
    limitations MySQL can suffer significant degradation in performance hence hardware
    plays important role in database operations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To monitor MySQL server use built-in functionality of MySQL client with the
    power of other built in tools like mysaladmin.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As your MySQL server runs, you want to learn if underlying hardware performing
    well with your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Operating System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before getting into MySQL specific monitoring and troubleshooting it’s recommended
    to verify Operating System (OS) vitals accordingly. In four main categories Memory,
    Input/Output (I/O), CPU and Network resources can be considered major impacts
    to MySQL’s operational behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Utilization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Memory utilization of *mysqld* can be checked via the OS command line. It’s
    essential to have a dedicated MySQL host for each server; hence there’s no race
    for OS resources, including memory. The rule of thumb is to have up to %80 memory
    allocated for a dedicated MySQL server, but you must check your workload and data
    size to calculate the memory needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may confirm this via *sys* schema using *mysql* client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Also watch out for Virtual Memory utilization and make sure your host OS is
    not swapping in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following OS configuration regarding memory utilization is crucial to MySQL’s
    memory allocation. Make sure these to have been configured accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: swappiness
  prefs: []
  type: TYPE_NORMAL
- en: This is a concept of allowing physical memory to be moved to a swap area by
    kernel. It’s recommended to set this value to 1 (one) hence allow kernel to perform
    minimum amount of swapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: NUMA
  prefs: []
  type: TYPE_NORMAL
- en: This is a concept of balancing memory between each CPU cores. MySQL 8 supports
    enabling [NUMA](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_numa_interleave)
    interleaved mode when multiple cores are available. This value is OFF by default.
    By enabling NUMA to interleave mode operating system, allocated memory to be balanced
    amongst CPU cores for better utilization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: OOM killer
  prefs: []
  type: TYPE_NORMAL
- en: In Linux systems, MySQL generally has a concept called Out of Memory killer
    controlled by the kernel. This is to prevent the possible runaway process in Operating
    Systems to avoid race conditions and a server crash. Since MySQL and its optimized
    memory buffers are memory hogs, the Operating System may often kill the mysqld
    process to avert a system-wide crash if not adjusted. As we mentioned earlier,
    we can control how much memory MySQL should allocate from the operating system.
    Still, if OOM kicks in, it’s possible to configure on system level or altogether
    disable (not recommended).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: File System Cache
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems will use cache for all memory operations, while MySQL has
    it’s own optimized caches including InnoDB Buffer Pool. Since there is no need
    to cache data twice we opt out of using File System Cache by setting innodb_flush_method
    to O_DIRECT and its value needs to be changed at startup.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While O_DIRECT flush method works with most installations, it does not work
    well with all storages subsystems. You may need to test it before setting this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I/O Utilization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I/O performance is vital for MySQL Database. Data is read from disks and written
    back causes I/O operation. Depending on the available buffers’ size, all the data
    processed within buffers eventually flushed to disk, which is a very costly operation
    in terms of data transfer. Although the data is cached at the very best has to
    be flushed to the disk regularly. Also, large data sets that don’t fit in the
    memory will have to be read from disks. In modern hardware, we do benefit from
    Solid State. Disks (SSD) for better performance, but it’s beneficial to know where
    the underlying bottlenecks are. You may use *iotop* to observe the I/O impact
    per process on the system; hence may drill down each method for a specific operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use the *iotop* utility interactively to monitor I/O operations. In
    this example we see disk activity for one of the MySQL threads.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the meantime we can check the process list from MySQL Command Line Interface
    to see what’s taking priority over other threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Also we can pin point the process id to identify details about the query for
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can also gather further information about this thread from performance_schema
    by querying ‘table_io_waits_summary_by_table’ which aggregates all table I/O wait
    events, as generated by the wait/io/table/sql/handler instrument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `table_io_waits_summary_by_table` table has the following columns to indicate
    how the table aggregates events: `OBJECT_TYPE`, `OBJECT_SCHEMA`, and `OBJECT_NAME`.
    These columns have the same meaning as in the `events_waits_current` table. They
    identify the table to which the row applies. This table also contains information
    on following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COUNT_*`'
  prefs: []
  type: TYPE_NORMAL
- en: How many times a user requested reads/writes/waits from this table.
  prefs: []
  type: TYPE_NORMAL
- en: '`SUM_*`'
  prefs: []
  type: TYPE_NORMAL
- en: How many reads/writes in total requests from this table.
  prefs: []
  type: TYPE_NORMAL
- en: '`MIN_*/MAX_*/AVG_*`'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum, maximum and average values for this table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This table is also used by the `schema_table_statistics%` views in *sys* schema.
    (For further reading, please refer to the documentation at [table_io_waits_summary_by_table](https://dev.mysql.com/doc/mysql-perfschema-excerpt/5.6/en/performance-schema-table-io-waits-summary-by-table-table.html)
    )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Network Utilization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The network is also very important part of database configuration. Often times
    test and development systems run on local configuration which omits network hops
    between the nodes. If MySQL is running on a dedicated host all request to the
    database will be coming to via application layer or proxy server. Since monitoring
    requires continuous data flow it’s better to utilize a tool that has time series
    historical data at any given time for at least 30 days worth of data to analyze.
    For this we highly recommend [Percona Monitoring and Management (PMM)](https://www.percona.com/software/database-tools/percona-monitoring-and-management)
    for monitoring network utilization, as shown in [Figure 23-1](#pmm_network_img)
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/msc4_2301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-1\. Percona Monitoring and Management - MySQL Instance Summary
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 23.2 Discovering Sources of MySQL Monitoring Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check how the server is operating with available resources.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let the server tell you about itself using built-in utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As your MySQL server runs, you’ll have questions about aspects of its operation
    or performance. Or maybe it’s *not* running and you want to know why.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out what information sources are available so that you can evaluate
    which are applicable and how usable they are for particular questions, here are
    few built-in utilities and information resources to check:'
  prefs: []
  type: TYPE_NORMAL
- en: System variables tell you how the server is configured. ([Recipe 22.1](ch22.xhtml#nch-admin-server-config)
    covers how to check these values.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status variables provide information about operations the server is performing,
    such as number of statements executed, number of disk accesses, memory use, or
    cache efficiency. Status information can help indicate when configuration changes
    are needed, such as increasing the size of a too-small buffer to improve performance,
    or decreasing the size of an underused resource to reduce the server’s memory
    footprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Performance Schema is designed for monitoring and provides a wealth of
    measurements, from high-level information such as which clients are connected
    down to fine-grained information such as which locks a statement holds or which
    files it has open. The Performance Schema is enabled by default since MySQL 5.7\.
    For prior versions to use the Performance Schema, it must be enabled. To enable
    it explicitly at server startup, use this configuration setting:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`As Performance Schema` focuses on performance data of the MySQL Server and
    can be used similarly for highly specific or complex queries, including joins.It
    also helps to clarify everything runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sys schema is a unique schema that does not contain physical tables but views
    and stored routines over Performance Schema tables. Performance Schema provides
    memory instrumentation information that could be much easier accessed by using
    views in *SYS* schema. For memory usage, it is much easier to use *SYS* schema;
    therefore, we recommend using five views that provide memory allocation details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SHOW` statements and tables in the `PERFORMANCE_SCHEMA` database provide information
    ranging from processes running in the server to active storage engines and plug-ins
    to system and status variables. In many cases, these two sources provide the same
    or similar information, but in different display formats. (For example, the `SHOW`
    `PLUGINS` statement and the `PLUGINS` table are related.) Familiarity with both
    sources helps you choose which is more usable in a given situation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For interactive use, `SHOW` is often more convenient because it involves less
    typing than `PERFORMANCE_SCHEMA` queries. Compare these two statements, which
    produce the same result:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`INFORMATION_SCHEMA` queries use `SELECT`, which is more expressive than `SHOW`
    and can be used for highly specific or complex queries, including joins.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`SHOW` output cannot be saved using only SQL. Should you require further processing
    of an `PERFORMANCE_SCHEMA` query result, you can use `INSERT` `INTO` … `SELECT`
    to save the results in a table for further analysis (see [Recipe 6.2](ch06.xhtml#nch-tblmgmt-tblmgmt-into-table)).
    To obtain an individual value, assign a scalar subquery result to a variable:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Some storage engines make information available about themselves. InnoDB, for
    example, has its own system and status variables. It also provides its own `INFORMATION_SCHEMA`
    tables and a set of InnoDB Monitors. The `INFORMATION_SCHEMA` tables provide more
    structured information, and are thus more amenable to analysis using SQL, if they
    contain the information you want. To see which InnoDB-related tables are available,
    use this statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Monitors produce unstructured output. You can eyeball it, but for programmatic
    use, you must parse or extract the information somehow. In some cases, a simple
    *grep* command might suffice:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Server logs provide several types of information. Here are some suggestions
    for using them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error log alerts you to severe problems the server encounters. It’s most
    suited to visual inspection because messages can originate from anywhere in the
    server and there is no fixed format to aid programmatic analysis. It’s often only
    the last part of the file that’s of interest, anyway, because you typically check
    this file to find the reason for the most recent problems. These problems may
    include corrupted table causing crash or even related to *mysql_upgrade* not ran
    further causing issues.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The general query log indicates what queries clients are running. It can aid
    in assessing the nature of the server’s workload. It is the only log that captures
    everything; hence care must be taken when enabling this log. Depending on the
    server’s activity, it may fill up disk space quickly and cause very heavy I/O,
    making things worse while monitoring MySQL. A suggestion is to enable online when
    needed and disable afterward.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The slow log contains queries that may be inefficient. It can help you find
    candidates for optimization.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The server is able to write the general query and slow query logs to files,
    tables, or both. Log tables facilitate analysis better than the files; they are
    more structured and hence subject to analysis using SQL statements. The contents
    are also easier to interpret. Each query row in the `general_log` table shows
    the user associated with it. With the logfile, users are named only on connection
    lines. To identify a user’s queries, you must extract the connection ID from the
    connection line and look for subsequent query lines with the same ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In addition, log tables are managed by the CSV storage engine, so the table
    datafiles are written in comma-separated values format. Look in the *mysql* directory
    under the server’s data directory for files named *general_log.CSV* and *slow_log.CSV*.
    You can process them with tools that read CSV files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To get information from a log, it must be enabled (see [Recipe 22.3](ch22.xhtml#nch-admin-server-logs)
    for instructions).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `EXPLAIN` statement can be useful for checking long-running queries. Although
    `EXPLAIN` is most often used to see execution plans for prospective queries, MySQL
    5.7.2 and up has the capability of using `EXPLAIN` to examine queries currently
    executing in other sessions. If a query seems to be stuck, this may help you understand
    why. Use `SHOW` `PROCESSLIST` or the `INFORMATION_SCHEMA` `PROCESSLIST` table
    to determine the connection ID of the session running the problem query, then
    point `EXPLAIN` at it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`EXPLAIN` can produce output in tabular, tree or `JSON` format. The latter
    can be parsed and manipulated by standard JSON modules in your programming language
    of choice.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 23.3 Checking Server Uptime and Progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know if the server is running, and if so, how long it has been up.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use mysqladmin and MySQL CLI utilities to find out if it’s up.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To tell whether the server is running, just try connecting to it. If the connection
    succeeds or you get an error that’s from the server itself, the server is up.
    *mysqladmin* `ping` is a good choice here, for interactive use or from within
    shell scripts. This result indicates the server is running although you should
    be alerted by the monitoring system that server is down::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This connection attempt fails, but the server itself returns the second error
    message, so it’s not down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This result indicates complete connection failure; the server is down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If the server is not up, check the error log to find out why.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server is up, its uptime (in seconds) can be determined multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use *mysqladmin* `status`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A disadvantage of this approach for programmatic use is that you must parse
    the output to extract the value of interest.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Examine the `Uptime` status variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use built-in CLI command to show status of the current connection
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A server not running is obviously cause for concern. But there may be issues
    even if it is running. If you frequently find that server uptime resets in the
    absence of scheduled restarts, something may be causing the server to exit, and
    you should investigate. Again, check the error log to see why.
  prefs: []
  type: TYPE_NORMAL
- en: As your MySQL server runs, you’ll have questions about aspects of its operation
    or performance. Or maybe it’s *not* running and you want to know why.
  prefs: []
  type: TYPE_NORMAL
- en: 23.4 Troubleshooting Server Start Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server quits shortly after it’s started, and you want to know what caused
    it and what you can do about it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check the error log for details.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the server stops shortly after you start it, a likely cause is a misconfiguration
    in the server options file. The error log helps you here. But don’t be misled
    by mere warnings, which do not signify that the server quit. For example, the
    following message means only that *innodb_ft_min_token_size* need be corrected
    to make the warning go away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, check for [ERROR] lines, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see server is complaining about a typo *innodb_ft_min_token_size*
    that preventing it to start properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other server start problems are:'
  prefs: []
  type: TYPE_NORMAL
- en: Misconfiguration of my.cnf variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple configuration files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing operating system permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect path setting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over allocating available memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing `mysql_upgrade` step after version upgrade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of version 8.0.16 *mysql_upgrade* is not needed anymore. But when upgrading
    to any version prior 8.0.16 you must run this utility.
  prefs: []
  type: TYPE_NORMAL
- en: 23.5 Determining the IO Utilization of the MySQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know the number of queries hitting MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check utilization status variables for details.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This question might be prompted by simple curiosity, or there might be a performance
    issue. Monitoring statement execution over time and summarizing the results can
    reveal patterns, such as a time of day or day of the week when activity is cumbersome.
    Perhaps several report generators are configured to start at the same time. Staggering
    them will help your server by spreading the load. It is crucial to capture baseline
    data to compare several reads for a given period.
  prefs: []
  type: TYPE_NORMAL
- en: 'In programmatic context, you might write a long-running application that probes
    the server periodically for the `Queries` and `Uptime` values, to determine a
    running display of statement-execution activity. To avoid reconnecting each time
    you issue the statements, ask the server for its session timeout period and probe
    it at intervals shorter than that value. To get the session timeout value (in
    seconds), use this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The default value is 28,800 (8 hours). If it’s configured to a value shorter
    than your desired probe interval, set it higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding discussion uses `Queries`, which indicates the total number of
    statements executed. Options for more fine-grained analysis are available.
  prefs: []
  type: TYPE_NORMAL
- en: The server maintains a set of `Com_`*`xxx`* status variables that count executions
    of particular statements. For example, `Com_insert` and `Com_update` count `INSERT`
    and `UPDATE` statements, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After MySQL version 5.7, some of the instruments in `information_schema` migrated
    to `performance_schema`; hence querying `performance_schema` was advised for such
    monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since Performance Schema has comprehensive details about events, it no longer
    has *Com Stats* values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You also may want to calculate Innodb Buffer Pool Cache hit ratio to answer
    on a question how many requests to InnoDB could be resolved without disk access.
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer the this question, use status variable information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Status variable `Innodb_buffer_pool_read_requests` holds value of how many times
    SQL queries requested data from the InnoDB buffer pool. This value could be also
    understood as a number of queries to InnoDB. Variable `Innodb_buffer_pool_reads`
    holds the metric on how many such queries were resolved from the InnoDB buffer
    pool without touching tablespace files on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: '`SHOW GLOBAL STATUS` counts the number of queries since server startup, but
    it’s a variable value. If you wait for certain amount of time and re-run the same
    query you’ll have a hit/ratio.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example InnoDB received `53626254 - 51504330 = 2121924` requests for
    data, and was able to resolve `2214763 - 1830647 = 384116` requests using buffer
    only. Thus InnoDB buffer pool hit ratio is `384116 / 2121924 = 0.18`. This means
    that the server either just started and the InnoDB buffer pool does not contain
    active data set yet. Or it is too small and InnoDB has to purge pages from the
    buffer pool too often and then re-read them back. Ideally InnoDB buffer pool hit
    ratio should be near 1 (one).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you have OLTP in memory workload you may have %100 of queries in memory.
    The profile of the queries may change significantly which can make hit/ratio metric
    surrogate. It’s insufficient to just to monitor hit ratio for in memory operations.
  prefs: []
  type: TYPE_NORMAL
- en: 23.6 Determining MySQL Thread’s CPU Utilization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find the process causing high cpu utilization on your server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `THREAD_OS_ID` value to corelate from Performance Schema’s `THREADS` table.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CPU utilization of the process is somewhat problematic in finding slowness
    caused by an individual query. Sometimes this can be a runaway job or a running
    process for a large data set. You may see this type of behavior on month ends
    where a query or a job runs only once a month to process quarterly or statistical
    computation. The `threads` table contains information about each thread created
    after server start. It contains whether the thread is historical (if instrumented
    see [Pre-Filtering by Thread](https://dev.mysql.com/doc/refman/8.0/en/performance-schema-thread-filtering.html).
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'On Linux systems `THREAD_OS_ID` corresponds to the value of `gettid()` function.
    This value is exposed to `top` or `proc` file system (/proc/[pid]/task/[tid]).
    To help identify related `THREAD_OS_ID` there are few methods outside of scraping
    `proc` file system by using built-in command line utilities. `ps -L aux` gives
    enough detail with the corresponding thread using higher `CPU` then others. Parent
    id of MySQL `mysqld_pid` can also be identified with `pidof mysqld` in conjunction
    with `ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will give us the *thread_os_id* hint that we will use to figure out what
    it is doing?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The other alternative would be using `pidstat` command (requires sysstat package).
    First find the process id of *mysqld* and execute following: pidstat -t -p {mysqld_pid}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can see in our test run a *thread_os_id* is consuming %21 of CPU from above
    output. In order to co-relate this with MySQL running threads we follow the *Performance
    Schema Query*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about *THREADS* table please refer [The threads Table](https://dev.mysql.com/doc/mysql-perfschema-excerpt/8.0/en/performance-schema-threads-table.html).
  prefs: []
  type: TYPE_NORMAL
- en: 23.7 Determining If MySQL Has Reached Its Connection Limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know the limits of the MySQL server handling connections
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check the configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s often the case that a server function is assessed using a combination of
    configuration settings plus current operational status. Typically, the former
    comes from system variables, whereas the latter comes from status variables. Connection
    management is an example of this concept. The `max_connections` system variable
    indicates the maximum number of simultaneous connections the server permits, and
    the `Threads_connected` status variable shows how many clients are currently connected
    and and the `Threads_running` status variable shows how many clients are currently
    active. Furthermore `Threads_running` is very important value for following reasons.
  prefs: []
  type: TYPE_NORMAL
- en: If number of running threads increases above number of CPU cores they start
    to compete for CPU resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If two threads (no matter how many threads connected) compete for the same row,
    table or other database object, engine-level table lock set at the server level
    or metadata lock (MD) is in place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since MySQL is a single process application with multi-threaded architecture,
    each connection creates a thread. To monitor maximum connections reached, issue
    the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If `threads_connected` is regularly close to the value of `max_connections`,
    you might need to bump up the value of the latter. If there is always a wide gap,
    you can decrease `max_connections`. For further reading this post explains how
    MySQL handles connections and its capabilities please refer [MySQL Connection
    Handling and Scaling](https://mysqlserverteam.com/mysql-connection-handling-and-scaling/).
  prefs: []
  type: TYPE_NORMAL
- en: One area also impacts performance of MySQL is Mutex and Meta Data Locks on highly
    concurrent environment. As seen above reading threads at some point will start
    competing each other when same resources requested from the database. The way
    InnoDB handles this is to put an exclusive lock on particular memory resource
    that the other thread have to wait for same resource. While this is handled with
    mutex operation in MySQL all DDL (Data Definition Language) as known as table
    structure change operations handled with Meta Data Locks.
  prefs: []
  type: TYPE_NORMAL
- en: 23.8 Verifying that the Buffer Pool Is Sized Properly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know the limits of the MySQL server handling connections.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Determine storage engine memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The InnoDB storage engine has a data buffer. To keep physical I/O minimal, DBA
    should make sure to utilize server memory efficiently. InnoDB Buffer Cache improves
    index key lookups, and data read operations; hence most data access will occur
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the cache sizes, check the relevant system variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `SHOW` `VARIABLES` or the `PERFORMANCE_SCHEMA` `GLOBAL_VARIABLES`
    table. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The efficiency measure that determines how well the read ratio is operating
    is its hit rate: the rate at which read requests from the InnoDB Buffer Pool are
    satisfied from the buffer pool without reading data from disk. If data is in the
    cache, it’s a hit; if not, it’s a miss. The hit ratio is a high correlation but
    not a guaranteed metric; hence OLTP (Online Transaction Processing) rate is more
    important. It’s also possible to verify how well the InnoDB Buffer Pool is utilized
    from data via Performance Schema.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can also determine memory allocation for the Buffer Pool using `sys` schema.
    It’s crucial to configure Buffer Pool at startup to allocate memory resources
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The required information can be obtained from either `SHOW` `STATUS` or the
    `GLOBAL_STATUS` table. However, when executing queries within a program and saving
    the results, we must account for differences between `SHOW` statements and selecting
    from `performance_schema` tables. The following queries retrieve similar information,
    but the column headings differ in letter case and sometimes in name, and variable
    names differ in letter case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To enable applications to be agnostic with respect to whether the variable information
    comes from `SHOW` or `information_schema`, force variable names to a consistent
    letter case and use that case in expressions that reference the variables. It
    doesn’t matter which letter case you choose, as long as you use it consistently.
    The following discussion uses uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple routine (in Ruby) that takes a database handle, fetches the
    status variables, and returns them as a hash of values keyed by names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the information using a `SHOW` statement instead, replace the query
    with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The code applies the `upcase` method to the variable names. That way, no matter
    whether the routine uses `GLOBAL_STATUS` or `SHOW` to obtain the information,
    the resulting hash has elements accessed by uppercase variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate a hit rate, pass the variable hash and the names of the reads
    and requests variables to this routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re all set. Call the routines that fetch status information and calculate
    the hit rates like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script to see your server’s hit rates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For tasks involving system variables, code similar to `get_status_variables()`
    suffices. This implementation uses the `GLOBAL_VARIABLES` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `SHOW` instead, replace the query with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 23.9 Finding Information About the Storage Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to pin specific problem about MySQL’s pluggable storage engine architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use MySQL’s *mysql* client and interact with storage engine directly.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re all set. Call the `SHOW ENGINE` command from *mysql* client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: SHOW ENGINE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SHOW ENGINE displays operational information about a storage engine. It requires
    the PROCESS privilege. The statement has these variants for INNODB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The first command *SHOW ENGINE INNODB STATUS* shows extensive information about
    InnoDB storage engine in sections. In order to digest this information it’s possible
    to capture output of this command and parse it via command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: For example, it can reach the Buffer Pool Information easily with the same command.
    This information is very useful when you need to acquire information fast, accurately,
    and without any impact to running the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If you are monitoring single event you may set the pager and repeatedly monitor
    its value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Let’s have a look at Mutex information on the idle system. The resulting *SHOW*
    statement would be much longer as if threads compete for the resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![](Images/msc4_2302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-2\. InnoDB Architecture *© 2021, Oracle Corporation and/or its affiliates.
    (2021). InnoDB Architecture [Figure]. https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html*
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see above InnoDB consists of two types of structures. First part
    In-Memory and the second part is in On-Disk. InnoDB utilizes host OS memory efficiently
    by its internal memory management protocol. As mentioned in introduction section
    of this chapter memory utilization is important factor in MySQL monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: As InnoDB is the far most complex and adopted storage engine in MySQL ecosystem
    it also comes with *Components* for even further debugging internals. Although
    this is an advanced topic it’s good know that you can add plugins to the MySQL
    server. For future reading please refer to [MySQL Documentation.](https://dev.mysql.com/doc/refman/8.0/en/server-plugins.html)
  prefs: []
  type: TYPE_NORMAL
- en: 23.10 Using the Error Log File to Troubleshoot MySQL Server Crashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My application reports “MySQL Server has gone away” (error 2006).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are possible scenarios for this very common error. They include:'
  prefs: []
  type: TYPE_NORMAL
- en: OOM (Out of Memory) Killer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL Signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crashing bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various other reasons such as server timeout, removed system files etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes even Error Log will be misleading to troubleshoot it. So it’s also
    advised to check system logs such as /var/log/messages.
  prefs: []
  type: TYPE_NORMAL
- en: Discussions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An error log is one of the most critical monitoring MySQL server statuses. From
    startup to shutdown, it will log all events to this file. Pro-actively monitoring
    this file will give enough information about the current and past events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The error log is tunable in MySQL 8.0 and can be fine-tuned to log and filter
    events by given criteria. For details please refer to [MySQL documentation.](https://dev.mysql.com/doc/refman/8.0/en/error-log-configuration.html)
  prefs: []
  type: TYPE_NORMAL
- en: Here are some pointers to the monitoring and finding solution to this error.
  prefs: []
  type: TYPE_NORMAL
- en: Server Crash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The server may have disconnected while executing a large query. The client has
    timed out during a long running query in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This maybe one of few reasons to check. Often times `max_allowed_packet` size
    is too small for a large query like the above crashing *for* loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Server Timeout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The connection between the application and the results of the query returning
    for each request has a timeout variable. One of the common timeout variables to
    monitor is *wait_timeout*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate this we will set the `wait_timeout` value to very low of 4 seconds
    and re run the same query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 23.11 Slow Query Log File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the slow query log to identify slow queries.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enable slow query log and set threshold to filter queries to address them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL can log all queries. By adjusting how slow queries are recorded, it’s
    possible to capture all queries and digest them. The default Slow Query Logging
    is set to 10 seconds, which means any query taking longer than 10 seconds is only
    shown in the log file.
  prefs: []
  type: TYPE_NORMAL
- en: You can control behavior of the slow query log using number of variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The most essential among them is `slow_query_log` that enables or disables slow
    query logging. It is `OFF` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Slow query log threshold is controlled with the variable `long_query_time`.
    You may start tuning your queries that are logged with the default threshold and
    then decrease it in steps. Finally set `long_query_time` to 0 to log all the queries.
  prefs: []
  type: TYPE_NORMAL
- en: Logging all the queries.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is common practice to run slow query log with `long_query_time` set to 0\.
    This way you will have information about performance of all the queries. Then
    you can run such programs as *pt-query-digest* or *mysqldumpslow* that can create
    digests of the queries.
  prefs: []
  type: TYPE_NORMAL
- en: To enable logging of all the queries set `long_query_time` to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now we’re ready to test simple query as it will log everything by having long_query_time=0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we may see that `Query_time` is pretty small that is expected,
    because the table itself is small. But number of rows that MySQL had to examine
    to resolve this query (`Rows_examined`) is greater (11) than the number of rows
    that the query sent to the client (`Rows_sent: 6`). This means that there is a
    very good chance that the query needs to be optimized.'
  prefs: []
  type: TYPE_NORMAL
- en: We can start optimizing the query by running *EXPLAIN*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Setting value of `long_query_time` to 0 enables logging of every single query..
    You need to be careful on busy system where your file system either can be filled
    or slowed down due to i/o operation.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use logging into the table when setting `long_query_time` to 0, because
    storage engine CSV is not designed for working in high concurrent environments
    and can affect performance as well.
  prefs: []
  type: TYPE_NORMAL
- en: 23.12 Monitoring with the General Query Log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to identify what activity each client is engaged.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enable general query log to to investigate them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL general query log is proof of record for what mysqld is doing. By enabling
    this log, it allows administrator monitoring the how life of user connection interacts
    with mysqld.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By enabling general query log you instruct MySQL server to log all the queries
    it receives. You need to be careful on busy system where your file system either
    can be filled or slowed down due to increased I/O operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: To enable `general_log` in runtime use *SET* command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re ready to monitor everything. This value is dynamic and we set at
    runtime. If you want it to set it persistently at startup see [Recipe 22.1](ch22.xhtml#nch-admin-server-config):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect another session and run following command while tailing the general
    query log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike MySQL slow query log, general query log does not log query execution
    time. Instead, it logs end to end clean record of what happens for each session
    in sequential order. This information may be useful for debugging MySQL crashes
    or figuring out what queries the application is sending.
  prefs: []
  type: TYPE_NORMAL
- en: 23.13 Using the Binary Log to Identify Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to track data changes for given period.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enable binary log to investigate them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL can log all data changes to a binary log format, which has three purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Configure primary and replica setup. By enabling this feature we can setup MySQL
    replicated topology explained in [Chapter 3](ch03.xhtml#nch-replication)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point-in-time recovery after full backup taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting or investigating an event for a specific time period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binary log is enabled by setting `--log-bin` at startup. Setting this value
    allows MySQL to track data changes to a binary log file. Logfile contains a set
    of sequential log files along with an index file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: $ `/usr/bin/mysqlbinlog  binlog.000003 -v |more`
  prefs: []
  type: TYPE_NORMAL
- en: '#210208 19:39:03 server id 1  end_log_pos 517272 CRC32 0x043a9ff4 ↩'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write_rows: table id 112 flags: STMT_END_F'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: INSERT INTO `test`.`sbtest1`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '@1=1'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '@2=21417'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '@3=''83868641912-28773972837-60736120486-75162659906-27563526494-↩'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 20381887404-41576422241-93426793964-56405065102-33518432330'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '@4=''67847967377-48000963322-62604785301-91415491898-96926520291'''
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: /usr/bin/mysqlbinlog --start-datetime="2020-11-29 10:50:32"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: binlog.000003 -v |more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: $ `/usr/bin/mysqlbinlog --start-datetime="2020-11-29 10:50:32"  binlog.000003
    \`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '> `-v| grep -i -e "update" -e "insert"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '> `-e "delete" -e "drop" -e "alter"  |cut -c1-100 | tr ''[A-Z]'' ''[a-z]''`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '> ``| sed -e "s/\t/ /g;s/\`//g;s/(.*$//;s/ set .*$//;s/ as .*$//"``'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '> `| sed -e "s/ where .*$//" | sort | uniq -c | sort -nr`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '50000 ### insert into test.sbtest9'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '50000 ### insert into test.sbtest9'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '50000 ### insert into test.sbtest8'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '50000 ### insert into test.sbtest7'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
