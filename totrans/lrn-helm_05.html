<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Developing Templates"><div class="chapter" id="developing_templates">
<h1><span class="label">Chapter 5. </span>Developing Templates</h1>


<p>Templates are at the heart of Helm charts, and they make up a majority of the files and content of a chart. These are the files that live within the <em>templates</em> directory.<a data-type="indexterm" data-primary="templates" data-secondary="about" id="idm46125999062184"/><a data-type="indexterm" data-primary="templates" data-secondary="chart create command" data-tertiary="directory structure" id="idm46125999061176"/><a data-type="indexterm" data-primary="charts" data-secondary="about" data-tertiary="templates" id="idm46125999059960"/> Helm will render the templates and send them to Kubernetes when you run commands like <code>helm install</code> and <code>helm upgrade</code>. <a data-type="indexterm" data-primary="templates" data-secondary="helm template command" id="idm46125999057784"/><a data-type="indexterm" data-primary="template command" id="idm46125999056776"/>If you use the <code>helm template</code> command, the templates are rendered and displayed as output (i.e., sent to standard out).</p>

<p>The template engine enables a wide range of ways to build templates. In simple situations, you can substitute values in Kubernetes manifest YAML files with values passed in by the user or from the <em>values.yaml</em> file. In more complex situations, you can build logic into templates that simplify what chart consumers need to input.  Or you can build in features that can configure applications themselves.</p>

<p>In this chapter you will learn how to develop templates and understand how the template syntax works. We’ll also cover a number of cool features that Helm has added to the templates that enable you to work with YAML and interact with Kubernetes. Along the way we will look at some patterns you can apply to your own templates.</p>






<section data-type="sect1" data-pdf-bookmark="The Template Syntax"><div class="sect1" id="idm46125999053432">
<h1>The Template Syntax</h1>

<p>Helm uses the Go text template engine provided as part of the Go standard library.<a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" id="ch05-syn"/><a data-type="indexterm" data-primary="Go programming language" data-secondary="template engine" data-tertiary="syntax of templates" id="idm46125999050456"/><a data-type="indexterm" data-primary="Helm" data-secondary="Go programming language" data-tertiary="template syntax" id="idm46125999049240"/> The syntax is used in <code>kubectl</code> (the command-line application for Kubernetes) templates, Hugo (the static site generator), and numerous other applications built in Go. The template engine, as it is used in Helm, is designed to work with various types of text files.</p>

<p>You don’t need to know the Go programming language to develop templates. There are some Go-isms in the template engine, but if you don’t know Go you can treat them as nuances of the template language. We will call them out as you learn to develop templates.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125999046408">
<h5>Why Go’s Template Engine?</h5>
<p>When Helm was being developed and a need arose for a template engine, <a data-type="indexterm" data-primary="Go programming language" data-secondary="template engine" data-tertiary="why Go" id="idm46125999045112"/><a data-type="indexterm" data-primary="Helm" data-secondary="Go programming language" data-tertiary="why Go" id="idm46125999043864"/><a data-type="indexterm" data-primary="templates" data-secondary="about" data-tertiary="why Go" id="idm46125999042648"/><a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="why Go" id="idm46125999041432"/>the template engine provided in the standard library for Go was the most mature and stable option. Additionally, this template engine had a security model and was maintained by Google with a security policy. It was the best choice.</p>

<p>Since that time, more general-purpose template engines have been made available to Go. The Helm project has been open to supporting other template engines and for several years had a code extension point where they could be added. Over that time there was only mild interest in other template systems, and no one was motivated enough to contribute support for one.</p>

<p>The Go template syntax is similar to those of other systems and has proven to be capable of handing the needs of Helm users.</p>
</div></aside>








<section data-type="sect2" data-pdf-bookmark="Actions"><div class="sect2" id="idm46125999038264">
<h2>Actions</h2>

<p>Logic, control structures, and data evaluations are wrapped by <code>{{</code> and <code>}}</code>. These are called actions.<a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="actions" id="idm46125999035832"/><a data-type="indexterm" data-primary="actions in templates" id="idm46125999034584"/><a data-type="indexterm" data-primary="curly brackets ({ }) in templates" id="idm46125999033912"/><a data-type="indexterm" data-primary="{ } (curly brackets) in templates" data-primary-sortas=" { } curly brackets" id="idm46125999033176"/> Anything outside of actions is copied to output.</p>

<p>When the curly brackets are used to start and stop actions they can be accompanied by a <code>-</code> to remove leading or trailing whitespace. The following example illustrates this:</p>

<pre data-type="programlisting">{{ "Hello" -}} , {{- "World" }}</pre>

<p>The generated output of this is “Hello,World.” The whitespace has been removed from the side with the <code>-</code> up to the next nonwhitespace character. There needs to be an ASCII whitespace between the <code>-</code> and the rest of the action. For example, <code>{{–12}}</code> evaluates to –12 because the <code>-</code> is considered part of the number instead of the bracket.</p>

<p>Within actions there are a wide variety of features you can leverage, including pipelines, if/else statements, loops, variables, subtemplates, and functions. Using these together provides a powerful way to program templates.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Information Helm Passes to Templates"><div class="sect2" id="idm46125999284600">
<h2>Information Helm Passes to Templates</h2>

<p>When Helm renders a template it passes a single data object to the template<a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="information Helm passes to templates" id="ch05-info"/><a data-type="indexterm" data-primary="templates" data-secondary="information Helm passes to" id="ch05-info2"/><a data-type="indexterm" data-primary="information Helm passes to templates" id="ch05-info3"/><a data-type="indexterm" data-primary="dot objects (.)" id="idm46125999279080"/><a data-type="indexterm" data-primary="information Helm passes to templates" data-secondary="dot objects" id="idm46125999278408"/><a data-type="indexterm" data-primary="templates" data-secondary="information Helm passes to" data-tertiary="dot objects" id="idm46125999277448"/><a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="dot objects" id="idm46125999276216"/><a data-type="indexterm" data-primary=". (dot objects) in templates" data-primary-sortas=".  dot objects" id="idm46125999275000"/> with information you can access. Inside the template that object is represented as a <code>.</code> (i.e., a period). It is referred to as a dot. This object has a wide variety of information available on it.</p>

<p>In <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a>, you already saw how values in the <em>values.yaml</em> file <a data-type="indexterm" data-primary="values.yaml file" data-secondary="Values from" id="idm46125999271640"/><a data-type="indexterm" data-primary="Values" data-secondary="values.yaml file providing" id="idm46125999270632"/>are available as properties on <code>.Values</code>. The properties on <code>.Values</code> are specific to each chart based entirely on the values in the <em>values.yaml</em> file and those passed into a chart. The properties on <code>.Values</code> do not have a schema and vary from chart to chart.</p>

<p>In addition to the values, information about the release, as first described <a data-type="indexterm" data-primary="Release object" id="idm46125999267512"/>in <a data-type="xref" href="ch02.xhtml#Using_Helm">Chapter 2</a>, can be accessed as properties of <code>.Release</code>. This information includes:<a data-type="indexterm" data-primary="releases" data-secondary="information in release records" data-tertiary="Release for information" id="idm46125999265416"/><a data-type="indexterm" data-primary="information in release records" data-secondary="Release for information" id="idm46125999264104"/></p>
<dl>
<dt><code>.Release.Name</code></dt>
<dd>
<p>The name of the release.</p>
</dd>
<dt><code>.Release.Namespace</code></dt>
<dd>
<p>Contains the namespace the chart is being released to.</p>
</dd>
<dt><code>.Release.IsInstall</code></dt>
<dd>
<p>Set to <code>true</code> when the release is a workload being installed.</p>
</dd>
<dt><code>.Release.IsUpgrade</code></dt>
<dd>
<p>Set to <code>true</code> when the release is an upgrade or rollback.</p>
</dd>
<dt><code>.Release.Service</code></dt>
<dd>
<p>Lists the service performing the release. When Helm installs a chart, this value is set to <code>"Helm"</code>. Different applications, those that build on Helm, can set this to their own value.</p>
</dd>
</dl>

<p>The information in the <em>Chart.yaml</em> file can also be found on the data <a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="information Helm passes to templates" id="idm46125999252728"/><a data-type="indexterm" data-primary="YAML" data-secondary="Chart.yaml" data-tertiary="information Helm passes to templates" id="idm46125999251688"/><a data-type="indexterm" data-primary="Chart object" id="idm46125999250456"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="Chart object information" id="idm46125999249784"/>object at <code>.Chart</code>. This information does follow the schema for the <em>Chart.yaml</em> file. This includes:</p>
<dl>
<dt><code>.Chart.Name</code></dt>
<dd>
<p>Contains the name of the chart.</p>
</dd>
<dt><code>.Chart.Version</code></dt>
<dd>
<p>The version of the chart.</p>
</dd>
<dt><code>.Chart.AppVersion</code></dt>
<dd>
<p>The application version, if set.</p>
</dd>
<dt><code>.Chart.Annotations</code></dt>
<dd>
<p>Contains a key/value list of annotations.</p>
</dd>
</dl>

<p>Each of the properties that can be in a <em>Chart.yaml</em> file is accessible. The <a data-type="indexterm" data-primary="names" data-secondary="Chart.yaml versus Chart object" id="idm46125999240632"/>names differ in that they start with a lowercase letter in <em>Chart.yaml</em> but start with an uppercase letter when they are properties on the <code>.Chart</code> object.</p>

<p>If you want to pass custom information from the <em>Chart.yaml</em> file to the templates, <a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="Chart object information" data-tertiary="custom information" id="idm46125999237736"/>you need to use annotations. The <code>.Chart</code> object only contains the fields from the <em>Chart.yaml</em> file that are in the schema. You can’t add new fields to pass them in, but you can add your custom information to the annotations.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125999235160">
<h5>Uppercase Property Names</h5>
<p>Property names on data objects passed into templates begin with uppercase letters.<a data-type="indexterm" data-primary="names" data-secondary="property names on data objects" id="idm46125999233816"/><a data-type="indexterm" data-primary="property names" id="idm46125999232776"/><a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="property names" id="idm46125999232104"/><a data-type="indexterm" data-primary="Go programming language" data-secondary="property names" id="idm46125999230888"/> This is a product of Helm being written in the Go programming language. In Go, public properties start with an uppercase letter and private properties start with a lowercase letter. When accessing the data object you just need to remember that the first letter is uppercase.</p>
</div></aside>

<p>Different Kubernetes clusters can have different capabilities. This can depend on<a data-type="indexterm" data-primary="Capabilities object" id="idm46125999229016"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Capabilities object" id="idm46125999228312"/><a data-type="indexterm" data-primary="cluster capabilities" id="idm46125999227368"/> things like the version of Kubernetes you are using or if there are custom resource definitions (CRDs) installed. Helm provides some data about the capabilities of the cluster as properties of <code>.Capabilities</code>. Helm interrogates the cluster you are deploying an application into to get this information. This includes:</p>
<dl>
<dt><code>.Capabilities.APIVersions</code></dt>
<dd>
<p>Contains the API versions and resource types available<a data-type="indexterm" data-primary="APIVersion of Kubernetes" id="idm46125999223960"/><a data-type="indexterm" data-primary="version of Kubernetes" id="idm46125999223240"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="version determination" id="idm46125999222568"/> in your cluster. You will learn how to use this in a little bit.</p>
</dd>
<dt><code>.Capabilities.KubeVersion.Version</code></dt>
<dd>
<p>The full Kubernetes version.</p>
</dd>
<dt><code>.Capabilities.KubeVersion.Major</code></dt>
<dd>
<p>Contains the major Kubernetes version. Because Kubernetes has not been incrementing the major version, this is set to <code>1</code>.</p>
</dd>
<dt><code>.Capabilities.KubeVersion.Minor</code></dt>
<dd>
<p>The minor version of Kubernetes being used in the cluster.</p>
</dd>
</dl>

<p>When <code>helm template</code> is used, Helm does not interrogate a cluster the same <a data-type="indexterm" data-primary="template command" data-secondary="cluster not interrogated" id="idm46125999215304"/><a data-type="indexterm" data-primary="templates" data-secondary="helm template command" data-tertiary="cluster not interrogated" id="idm46125999214360"/>way it does for <code>helm install</code> or <code>helm upgrade</code>. The capabilities information provided to templates being processed when <code>helm template</code> is run is default information Helm already knows about compliant Kubernetes clusters. Helm works this way because the <code>template</code> command is expected to only be used for processing templates and doing so in a manner that does not accidentally leak information from a configured cluster.</p>

<p>Charts can contain custom files. For example, you can have a configuration file<a data-type="indexterm" data-primary="charts" data-secondary="custom files within" id="idm46125999210488"/><a data-type="indexterm" data-primary="ConfigMaps (Kubernetes)" data-secondary="custom files in charts" id="idm46125999209512"/><a data-type="indexterm" data-primary="Secrets (Kubernetes)" data-secondary="custom files in charts" id="idm46125999208568"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Secrets" data-tertiary="custom files in charts" id="idm46125999207624"/> you want to pass to an application through a <code>ConfigMap</code> or <code>Secret</code> as a file in the chart. The nonspecial files in a chart that are not listed in the <em>.helmignore</em> file are available on <code>.Files</code> within templates. This will not give you access to the template files.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125999204520">
<h5>The .helmignore File</h5>
<p>You can include files in a chart directory that you do not want packaged up<a data-type="indexterm" data-primary=".helmignore file" data-primary-sortas=". dot helmignore" id="idm46125999202968"/><a data-type="indexterm" data-primary=".helmignore file" data-primary-sortas="dot helmignore" id="idm46125999201992"/><a data-type="indexterm" data-primary=".helmignore file" data-primary-sortas="helmignore" id="idm46125999201048"/><a data-type="indexterm" data-primary="charts" data-secondary="custom files within" data-tertiary=".helmignore file" data-tertiary-sortas="dot helmignore" id="idm46125999200104"/><a data-type="indexterm" data-primary="information Helm passes to templates" data-secondary=".helmignore file" data-secondary-sortas="dot helmignore" id="idm46125999198616"/><a data-type="indexterm" data-primary="templates" data-secondary="information Helm passes to" data-tertiary=".helmignore file" data-tertiary-sortas="dot helmignore" id="idm46125999197432"/><a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary=".helmignore file" data-tertiary-sortas="dot helmignore" id="idm46125999195976"/> in a chart archive and that you do not want to be used by Helm or the chart. List those files in a <em>.helmignore</em> file at the root of the chart alongside the <em>Chart.yaml</em> file.</p>

<p>A <em>.helmignore</em> file is similar to a <em>.gitignore</em> file in Git, the source code management system. Individual files, directories, and patterns of files to ignore can be listed. When <code>helm create</code> is run to generate a new chart, it includes a <em>.helmignore</em> file that ignores common source control management systems and editor files.</p>
</div></aside>

<p>The final piece of data passed into the template is details about the current template being executed. Helm passes in:</p>
<dl>
<dt><code>.Template.Name</code></dt>
<dd>
<p>Contains the namespaced filepath to the template. For example, in the <em>anvil</em> chart from <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a> a path would be <em>anvil/templates/deployment.yaml</em>.</p>
</dd>
<dt><code>.Template.BasePath</code></dt>
<dd>
<p>The namespaced path to the <em>templates</em> directory of the current chart (e.g., <em>anvil/templates</em>).</p>
</dd>
</dl>

<p>Later in this chapter you will learn how you can change the scope of <code>.</code> in some circumstances.<a data-type="indexterm" data-primary="scope" data-secondary="dot objects" id="idm46125999183304"/><a data-type="indexterm" data-primary="dot objects (.)" data-secondary="scope of dot" id="idm46125999182296"/><a data-type="indexterm" data-primary=". (dot objects) in templates" data-secondary="scope of dot" data-primary-sortas=".  dot objects" id="idm46125999181352"/> When the scope changes, properties like <code>.Capabilities.KubeVersion.Minor</code> will become inaccessible at that location. When template execution begins, <code>.</code> is mapped to <code>$</code> and <code>$</code> does not change. Even when the scope changes, <code>$.Capabilities.KubeVersion.Minor</code> and other passed-in data is still accessible. You will find <code>$</code> is typically only used when the scope has changed.<a data-type="indexterm" data-startref="ch05-info" id="idm46125999177288"/><a data-type="indexterm" data-startref="ch05-info2" id="idm46125999176584"/><a data-type="indexterm" data-startref="ch05-info3" id="idm46125999175912"/></p>

<p>Now that you’ve learned about the data being passed into the template, we will look at how you can use and manipulate that data within a template.<a data-type="indexterm" data-primary="data Helm passes to templates" data-see="information Helm passes to templates" id="idm46125999174952"/><a data-type="indexterm" data-primary="data in release records" data-see="information in release records" id="idm46125999173896"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Pipelines"><div class="sect2" id="idm46125999283976">
<h2>Pipelines</h2>

<p>A pipeline is a sequence of commands, functions, and variables chained together.<a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="pipelines" id="idm46125999171240"/><a data-type="indexterm" data-primary="pipelines in template syntax" data-secondary="about" id="idm46125999169992"/> The value of a variable or the output of a function is used as the input to the next function in a pipeline. The output of the final element of a pipeline is the output of the pipeline. The following illustrates a simple pipeline:<a data-type="indexterm" data-primary="| (pipe) in templates" data-primary-sortas="| pipe" id="idm46125999168664"/></p>

<pre data-type="programlisting">character: {{ .Values.character | default "Sylvester" | quote }}</pre>

<p>There are three parts to this pipeline, each separated by a <code>|</code>. The first is 
<span class="keep-together"><code>.Values.character</code></span>, which is a calculated value of <code>character</code>. This is either the value of <code>character</code> from the <em>values.yaml</em> file or one passed in when the chart is being rendered by <code>helm install</code>, <code>helm upgrade</code>, or <code>helm template</code>. <a data-type="indexterm" data-primary="default function" id="idm46125999162408"/><a data-type="indexterm" data-primary="pipelines in template syntax" data-secondary="default function" id="idm46125999161672"/>This value is passed as the last argument to the <code>default</code> function. If the value is empty, <code>default</code> will use the value of “Sylvester” in its place. The output of <code>default</code> is passed as an input to <code>quote</code>, which ensures the value is wrapped in quotation marks. The output of <code>quote</code> is returned from the action.</p>

<p>Pipelines are a powerful tool you can use to transform data you want in the template. They can be used for a variety of purposes, from creating powerful transformations to protecting against simple bugs. Can you spot the bug in the following YAML output?<a data-type="indexterm" data-primary="YAML" data-secondary="output string potential errors" id="idm46125999157992"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="YAML output string potential errors" id="idm46125999157000"/><a data-type="indexterm" data-primary="errors" data-see="debugging and troubleshooting" id="idm46125999156024"/><a data-type="indexterm" data-primary="string output potential errors" id="idm46125999155064"/></p>

<pre data-type="programlisting">id: 12345e2</pre>

<p>The value of <code>id</code> looks like a string, but it is not. The only letter is an <em>e</em>, and the rest are numbers. YAML parsers, including the one used by Kubernetes, will interpret that as a number in scientific notation. This will cause errors. A short string like this is a common output when you get a shortened version of a digest or commit ID from Git. A simple fix is to wrap the value in quotes:</p>

<pre data-type="programlisting">id: "12345e2"</pre>

<p>When the value is wrapped in quotes, the YAML parsers will interpret it as a string. <a data-type="indexterm" data-primary="quote function for string output" id="idm46125999150936"/><a data-type="indexterm" data-primary="pipelines in template syntax" data-secondary="quote function" id="idm46125999150216"/><a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="quote function" id="idm46125999149256"/>This is a case where using the <code>quote</code> function on the end of a pipeline can fix or avoid a bug.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125999147400">
<h5>Unix Pipeline</h5>
<p>In Unix and Unix-like systems (e.g., Linux) a pipeline is where the output of one application<a data-type="indexterm" data-primary="Unix pipelines" id="idm46125999145960"/><a data-type="indexterm" data-primary="Linux pipelines" id="idm46125999145256"/><a data-type="indexterm" data-primary="pipelines in template syntax" data-secondary="about" id="idm46125999144584"/> is used as an input in the next application. Applications that each do one thing can be chained together using their inputs and outputs as interfaces.</p>

<p>Pipelines originated from <a data-type="indexterm" data-primary="McIlroy, Douglas" id="idm46125999142904"/>Douglas McIlroy and were later incorporated into the Unix philosophy by <a data-type="indexterm" data-primary="Thompson, Ken" id="idm46125999142072"/>Ken Thompson, who worked on the design and implementation of the original Unix operating system. Two principles from the Unix philosophy include “make each program do one thing well” and “expect the output of every program to become the input to another, as yet unknown, program.”</p>

<p>Ken Thompson and <a data-type="indexterm" data-primary="Pike, Rob" id="idm46125999140584"/><a data-type="indexterm" data-primary="Go programming language" data-secondary="creators of" id="idm46125999139848"/>Rob Pike, another member of the Unix team, are two of the original creators of the Go programming language.</p>
</div></aside>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Template Functions"><div class="sect2" id="idm46125999172344">
<h2>Template Functions</h2>

<p>Within actions and pipelines, there are template functions you can use. <a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="functions" id="ch05-func2"/><a data-type="indexterm" data-primary="functions in templates" id="ch05-func"/>You have already seen some of these, including the <code>default</code> and <code>quote</code> functions described earlier in this chapter. Functions provide a means to transform the data you have into the format you need rendered or to generate data where none exists.</p>

<p>Most of the functions are provided by Helm and are designed to be useful when building charts. The functions range from the simple, like the <code>indent</code> and <code>nindent</code> functions used to indent output, to the complex ones that are able to reach into the cluster and get information on current resources and resource types.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125999131464">
<h5>Sprig Library</h5>
<p>Many of the functions found in Helm templates are provided by a library named <a href="https://oreil.ly/fBfwm">Sprig</a>.<a data-type="indexterm" data-primary="functions in templates" data-secondary="Sprig library" id="idm46125999129448"/><a data-type="indexterm" data-primary="Sprig library of template functions" id="idm46125999128440"/><a data-type="indexterm" data-primary="Go programming language" data-secondary="Sprig library of template functions" id="idm46125999127704"/> These functions were developed alongside Helm, by Helm authors, with chart use cases in mind. They were placed into a separate library because they were generic enough that other applications could use them, too.</p>

<p>This is useful to know if you need functions for your Go-based application, <a data-type="indexterm" data-primary="resources for learning" data-secondary="Sprig library of template functions" id="idm46125999126008"/>find an issue in a function and want to report or fix it, or want to contribute a function of your own to Helm.</p>
</div></aside>

<p>To illustrate functions we can look at a common pattern used in charts to improve readability. When <code>helm create</code> is run, as you saw in <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a>, a Kubernetes <code>Deployment</code> template is created as part of the chart. The <code>Deployment</code> template includes a section for  a security context:<a data-type="indexterm" data-primary="building charts" data-secondary="Deployment template" data-tertiary="security context readable" id="idm46125999121672"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="Deployment template security context" id="idm46125999120456"/><a data-type="indexterm" data-primary="Deployment (Kubernetes)" data-secondary="security context readability" id="idm46125999119224"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Deployment" data-tertiary="security context readability" id="idm46125999118264"/><a data-type="indexterm" data-primary="templates" data-secondary="Deployment" data-tertiary="security context readability" id="idm46125999117032"/><a data-type="indexterm" data-primary="YAML" data-secondary="Deployment" data-tertiary="security context readability" id="idm46125999115800"/><a data-type="indexterm" data-primary="toYaml function" id="idm46125999114568"/><a data-type="indexterm" data-primary="YAML" data-secondary="toYaml function" id="idm46125999113896"/></p>

<pre data-type="programlisting">      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}</pre>
<div data-type="tip"><h6>Tip</h6>
<p>Read the full chart from <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a> at <a href="https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil"><em class="hyperlink">https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil</em></a>.</p>
</div>

<p>In the <em>values.yaml</em> file there is a YAML entry for <code>podSecurityContext</code>. This is meant to be the exact YAML passed in the <code>template</code> section of a <code>Deployment</code> for 
<span class="keep-together"><code>securityContext</code></span>. Inside, the template the information from the <em>values.yaml</em> file is no longer YAML. Instead it is a data object. The <code>toYaml</code> function turns the data into YAML.</p>

<p>The YAML under <code>securityContext</code> needs to be indented properly or the Deployment’s manifest will have YAML errors due to a section not being properly indented. This is accomplished through the use of two functions. To the left of <code>toYaml</code> a <code>-</code> is used with <code>{{</code> to remove all the whitespace up to the <code>:</code> on the previous line. The output of <code>toYaml</code> is passed to <code>nindent</code>. This function adds a newline at the start of the text it receives and then indents each line.</p>

<p><code>nindent</code> is used instead of the <code>indent</code> function for readability. <a data-type="indexterm" data-primary="nindent function" id="idm46125999100008"/><a data-type="indexterm" data-primary="indent function" id="idm46125999099304"/>The <code>indent</code> function does not add a newline at the beginning. <code>nindent</code> is used so that the YAML under <code>securityContext</code> can be on a new line. This is another common pattern found in templates.</p>
<div data-type="tip"><h6>Tip</h6>
<p>In addition to <code>toYaml</code>, Helm has functions to convert data to <a data-type="indexterm" data-primary="JSON (JavaScript Object Notation)" data-secondary="toJson function" id="idm46125999095368"/><a data-type="indexterm" data-primary="toJson function" id="idm46125999094424"/><a data-type="indexterm" data-primary="toToml function" id="idm46125999093752"/>JSON with <code>toJson</code> and to TOML with <code>toToml</code>. <code>toYaml</code> is often used when creating Kubernetes manifests, while <code>toJson</code> and <code>toToml</code> are more often used when creating configuration files to be passed to applications through <code>Secret</code>s and <code>ConfigMap</code>s.</p>
</div>

<p>The order of arguments passed into a function is intentional. When pipelines are used, the output of one function is passed as the last argument to the next function in the pipeline. In the previous example the output of <code>toYaml</code> is passed as the last argument to <code>nindent</code>, which takes two arguments. The order of arguments on functions is designed for common pipeline use cases.</p>

<p>There are more than a <a href="https://oreil.ly/Xtoya">hundred functions</a> available to use within templates. These include functions for handling math, dictionaries and lists, reflection, hash generation, date functions, and much more.<a data-type="indexterm" data-startref="ch05-func" id="idm46125999086968"/><a data-type="indexterm" data-startref="ch05-func2" id="idm46125999086264"/><a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="functions available listed" id="idm46125999085592"/><a data-type="indexterm" data-primary="functions in templates" data-secondary="list of available" id="idm46125999084312"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="template functions available" id="idm46125999083368"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Methods"><div class="sect2" id="idm46125999137928">
<h2>Methods</h2>

<p>Up to this point, you have seen template functions. Helm also includes functions that detect the capabilities of a Kubernetes cluster and methods to work with files.<a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="methods" id="idm46125999080536"/></p>

<p>The <code>.Capabilities</code> object has the method <code>.Capabilities.APIVersions.Has</code>, <a data-type="indexterm" data-primary="methods in templates" data-secondary="Capabilities object" id="idm46125999077784"/>which takes in a single argument for the <a data-type="indexterm" data-primary="Capabilities object" data-secondary="APIVersions.Has method" id="idm46125999076680"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Capabilities object" data-tertiary="APIVersions.Has method" id="idm46125991649880"/><a data-type="indexterm" data-primary="version of Kubernetes" data-secondary="resource availability determination" id="idm46125991648792"/><a data-type="indexterm" data-primary="APIVersion of Kubernetes" data-secondary="resource availability determination" id="idm46125991647944"/><a data-type="indexterm" data-primary="resources" data-secondary="resource availability determination" id="idm46125991647096"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="version determination" data-tertiary="resource availability determination" id="idm46125991646248"/>Kubernetes API or type you want to check the existence of. It returns either true or false to let you know if that resource is available in your cluster. You can check for a group and version such as <code>batch/v1</code> or a resource type such as <code>apps/v1/Deployment</code>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Checking for the existence of resources and API groups is useful when dealing with custom resource definitions and multiple versions of Kubernetes resource types. As Kubernetes API versions move from alpha, to beta, to released versions, you want to use the latest version of a resource type as alpha and beta are deprecated and removed from Kubernetes. If your application will be installed on a wide range of Kubernetes versions, it is useful to support API versions in all of those clusters.</p>
</div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>When <code>helm template</code> is used, Helm will use a default set of <a data-type="indexterm" data-primary="template command" data-secondary="cluster not interrogated" id="idm46125991641384"/><a data-type="indexterm" data-primary="templates" data-secondary="helm template command" data-tertiary="cluster not interrogated" id="idm46125991640536"/>API versions for a compliant Kubernetes cluster instead of interacting with your cluster to generate the known capabilities.</p>
</div>

<p>The other place you will find methods is on <code>.Files</code>. It includes the following methods to help you work with files:<a data-type="indexterm" data-primary="methods in templates" data-secondary="Files object" id="idm46125991638280"/><a data-type="indexterm" data-primary="Files object methods" id="idm46125991637432"/></p>
<dl>
<dt><code>.Files.Get name</code></dt>
<dd>
<p>Provides a means of getting the contents of the file as a string. <code>name</code>, in this case, is the name including filepath from the root of the chart.</p>
</dd>
<dt><code>.Files.GetBytes</code></dt>
<dd>
<p>Similar to <code>.Files.Get</code> but instead of returning a string, the file is returned as an array of bytes. In Go terms, this is a byte slice (i.e., <code>[]byte</code>).</p>
</dd>
<dt><code>.Files.Glob</code></dt>
<dd>
<p>Accepts a glob pattern and returns another <code>files</code> object containing only the files whose names match the pattern.</p>
</dd>
<dt><code>.Files.AsConfig</code></dt>
<dd>
<p>Takes a files group and returns it as flattened YAML suitable to include in the <code>data</code> section of a Kubernetes <code>ConfigMap</code> manifest. This is useful when paired with <code>.Files.Glob</code>.</p>
</dd>
<dt><code>.Files.AsSecrets</code></dt>
<dd>
<p>Similar to <code>.Files.AsConfig</code>. Instead of returning flattened YAML it returns the data in a format that can be included in the <code>data</code> section of a Kubernetes <code>Secret</code> manifest. It’s Base64 encoded. This is useful when paired with <code>.Files.Glob</code>. For example, 
<span class="keep-together"><code>{{ .Files.Glob("mysecrets/**").AsSecrets }}</code></span>.</p>
</dd>
<dt><code>.Files.Lines</code></dt>
<dd>
<p>Has an argument for a filename and returns the contents of the file as an array split by newlines (i.e., <code>\n</code>).</p>
</dd>
</dl>

<p>To illustrate the use of these, the following template is from an <em>example</em> chart. It reads all the files in the <em>config</em> subdirectory of a chart and embeds each one in a <code>Secret</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Secret</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">include "example.fullname" .</code> <code class="p-Indicator">}}</code>
<code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">Opaque</code>
<code class="nt">data</code><code class="p">:</code>
<code class="p-Indicator">{{</code> <code class="nv">(.Files.Glob "config/*").AsSecrets | indent 2</code> <code class="p-Indicator">}}</code></pre>

<p>As the following example output from Helm shows, each file can be found at its own key in the file:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Secret</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">myapp</code>
<code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">Opaque</code>
<code class="nt">data</code><code class="p">:</code>
  <code class="nt">jetpack.ini</code><code class="p">:</code> <code class="l-Scalar-Plain">ZW5hYmxlZCA9IHRydWU=</code>
  <code class="nt">rocket.yaml</code><code class="p">:</code> <code class="l-Scalar-Plain">ZW5hYmxlZDogdHJ1ZQ==</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Querying Kubernetes Resources In Charts"><div class="sect2" id="idm46125991582536">
<h2>Querying Kubernetes Resources In Charts</h2>

<p>Helm contains a template function that enables you to look up resources in the Kubernetes cluster.<a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="querying Kubernetes resources" id="idm46125991545896"/><a data-type="indexterm" data-primary="resources" data-secondary="querying in charts" id="idm46125991544712"/><a data-type="indexterm" data-primary="charts" data-secondary="Kubernetes resources queried" id="idm46125991543768"/><a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="functions" id="idm46125991542856"/><a data-type="indexterm" data-primary="functions in templates" data-secondary="lookup function" id="idm46125991541640"/> The <code>lookup</code> template function is able to return either an individual object or a list of objects. This function returns an empty response when commands that do not interact with the cluster are executed.</p>

<p>The following example looks up a <code>Deployment</code> named <em>runner</em> in the <em>anvil</em> namespace and makes the metadata annotations available:<a data-type="indexterm" data-primary="metadata annotations via resource lookup" id="idm46125991538216"/><a data-type="indexterm" data-primary="resources" data-secondary="annotating" id="idm46125991537416"/></p>

<pre data-type="programlisting">{{ (lookup "apps/v1" "Deployment" "anvil" "runner").metadata.annotations }}</pre>

<p>There are four arguments passed into the <code>lookup</code> function:</p>
<dl>
<dt>API version</dt>
<dd>
<p>This is the version of any object, whether included in Kubernetes or installed as part of an add-on. Examples of this look like <code>"v1"</code> and <code>"apps/v1"</code>.</p>
</dd>
<dt>Kind of object</dt>
<dd>
<p>This can be any resource type.</p>
</dd>
<dt>Namespace to look for the object in</dt>
<dd>
<p>This can be left blank to look in all namespaces you have access to or for global resources such as Namespace.</p>
</dd>
<dt>Name of the resource you are looking for</dt>
<dd>
<p>This can be left blank to return a list of resources instead of a specific one.</p>
</dd>
</dl>

<p>When a list of resources is returned, you will need to loop over the results<a data-type="indexterm" data-primary="lookup function" data-secondary="returning dict or list" id="idm46125991527576"/><a data-type="indexterm" data-primary="lists" data-secondary="lookup function returning" id="idm46125991526600"/><a data-type="indexterm" data-primary="dicts" data-secondary="lookup for an object" id="idm46125991525592"/> to access the data on each of the individual objects. Where a lookup for an object returns a <em>dict</em>, a lookup for a list of objects returns a <em>list</em>. These are two different types Helm provides for use in templates.</p>

<p>When a list is returned, the objects are on the <code>items</code> property:</p>

<pre data-type="programlisting">{{ (lookup "v1" "ConfigMap" "anvil" "").items }}</pre>

<p>The items can be iterated over using a loop, which you will learn about later in the chapter. This example returns all the <a data-type="indexterm" data-primary="ConfigMaps (Kubernetes)" data-secondary="lookup for list of" id="idm46125991521304"/><code>ConfigMap</code>s in the <em>anvil</em> namespace, assuming you have access to the namespace.</p>

<p>You should be careful when using this function. For example, it will <a data-type="indexterm" data-primary="lookup function" data-secondary="dry run versus upgrade" id="idm46125991496888"/><a data-type="indexterm" data-primary="dry-run flag" data-secondary="lookup in dry run" id="idm46125991496040"/><a data-type="indexterm" data-primary="templates" data-secondary="debugging" data-tertiary="dry-run flag" id="idm46125991495192"/>return different results when used as part of a dry run as opposed to when an upgrade is run. A dry run does not interact with a cluster, so this function will return no results. When an upgrade is run it will return results.</p>

<p>The results returned when installing or upgrading in various clusters can also be different. For example, in a development environment and in a production environment the resources installed in a cluster will have differences that can lead to unequal responses.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="if/else/with"><div class="sect2" id="idm46125991589752">
<h2>if/else/with</h2>

<p>Go templates have <code>if</code> and <code>else</code> statements along with something similar but <a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="if/else/with" id="idm46125991489816"/><a data-type="indexterm" data-primary="if statements in templates" id="idm46125991488536"/><a data-type="indexterm" data-primary="conditional statements in templates" id="idm46125991487896"/>mildly different called <code>with</code>. <code>if</code> and <code>else</code> work the same way they do in most programming languages. To illustrate an <code>if</code> statement, we can look at a pattern from the chart generated using the <code>helm create</code> command covered in <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a>. In that chart the <em>values.yaml</em> file contains a section on <code>ingress</code> with an enabled property. It looks like:</p>

<pre data-type="programlisting">ingress:
  enabled: false</pre>

<p>In the <em>ingress.yaml</em> file that creates the <code>Ingress</code> resource for Kubernetes, the first and last lines are for the <code>if</code> statement that implements this:<a data-type="indexterm" data-primary="end statements in templates" id="idm46125991480952"/><a data-type="indexterm" data-primary="enabled property" data-secondary="if statements evaluating" id="idm46125991480184"/></p>

<pre data-type="programlisting">{{- if .Values.ingress.enabled -}}
...
{{- end }}</pre>

<p>In this case, the <code>if</code> statement evaluates whether the output of the pipeline following the <code>if</code> statement is true or false. If it’s true, the content inside is evaluated. In order to know where the end of the block is, you need an <code>end</code> statement. This is important because indentation or more typical brackets could be part of the material you want rendered.</p>

<p>Using <code>if</code> statements is how the common <em>enabled</em> pattern is typically implemented.</p>

<p><code>if</code> statements can have an <code>else</code> statement that is executed if the <code>if</code> statement<a data-type="indexterm" data-primary="else statements in templates" id="idm46125991473624"/> evaluates to false. The following example prints a YAML comment to output when <code>Ingress</code> is not enabled:</p>

<pre data-type="programlisting">{{- if .Values.ingress.enabled -}}
...
{{- else -}}
# Ingress not enabled
{{- end }}</pre>

<p>Sometimes you will want to have multiple elements evaluated in an <code>if</code> statement by <a data-type="indexterm" data-primary="and statements in templates" id="idm46125991470360"/><a data-type="indexterm" data-primary="if statements in templates" data-secondary="and/or statements" id="idm46125991469656"/><a data-type="indexterm" data-primary="or statements in templates" id="idm46125991468696"/><a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="functions" id="idm46125991468008"/><a data-type="indexterm" data-primary="functions in templates" data-secondary="and/or functions" id="idm46125991466792"/><a data-type="indexterm" data-primary="functions in templates" data-secondary="eq function" id="idm46125991465848"/>combining them with an <code>and</code> or an <code>or</code> statement. In templates this is a little different than you might be used to. Consider the following segment from a template:</p>

<pre data-type="programlisting">{{- if and .Values.characters .Values.products -}}
...
{{- end }}</pre>

<p>In this case <code>and</code> is implemented as a function with two arguments. That means <code>and</code> comes before either of the two items being used. The same idea applies to the use of <code>or</code>, which is also implemented as a function.</p>

<p>When one of the elements to be used with <code>and</code> or <code>or</code> is a function or pipeline, you can use parentheses. The following example has one of the arguments to <code>or</code> being an equal check:<a data-type="indexterm" data-primary="eq function for equality" id="idm46125991459224"/></p>

<pre data-type="programlisting">{{- if or (eq .Values.character "Wile E. Coyote") .Values.products -}}
...
{{- end }}</pre>

<p>The output of the equality check, implemented using the <code>eq</code> function, is passed as the first argument to <code>or</code>. The parentheses enable you to group elements together to build more complex logic.</p>

<p><code>with</code> is similar to <code>if</code> with the caveat that the scope within a <code>with</code> block changes.<a data-type="indexterm" data-primary="with statements in templates" id="idm46125991454520"/><a data-type="indexterm" data-primary="scope" data-secondary="with statements" id="idm46125991453816"/> To continue with an example from <code>Ingress</code>, the following block shows the scope change:</p>

<pre data-type="programlisting">  {{- with .Values.ingress.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}</pre>

<p>If the value passed into <code>with</code> is empty, the block is skipped. If the value is not 
<span class="keep-together">empty, the</span> block is executed and the value of <code>.</code> inside the block is 
<span class="keep-together"><code>.Values.ingress.annotations</code></span>. In this situation, the scope within the block has changed to the value checked by <code>with</code>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The pattern of checking a value using <code>with</code> and then sending it to <a data-type="indexterm" data-primary="values.yaml file" data-secondary="with conditional output" id="idm46125991446376"/><a data-type="indexterm" data-primary="YAML" data-secondary="values.yaml file" data-tertiary="with for conditional output" id="idm46125991445400"/>output using the <code>toYaml</code> and <code>nindent</code> functions is common for elements you have in a <em>values.yaml</em> file that you want to directly output in a template. This is regularly used for image pull secrets, node selectors, and more.</p>
</div>

<p>Just like with <code>if</code> statements, <code>with</code> can have an accompanying <code>else</code> block that you can use when the value is empty.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Variables"><div class="sect2" id="idm46125991492136">
<h2>Variables</h2>

<p>Within templates you can create your own variables and use them to pass as <a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="variables" id="idm46125991439448"/><a data-type="indexterm" data-primary="functions in templates" data-secondary="variables as arguments" id="idm46125991438200"/><a data-type="indexterm" data-primary="variables in templates" id="idm46125991437256"/><a data-type="indexterm" data-primary="$ (dollar sign) in variable names" data-primary-sortas="$ dollar sign" id="idm46125991436584"/><a data-type="indexterm" data-primary="names" data-secondary="variables" id="idm46125991435624"/><a data-type="indexterm" data-primary="dollar sign ($) in variable names" id="idm46125991434680"/>arguments to functions, print in the output, and more. Variables start with a <code>$</code> and are typed. Once a variable is created for one type, such as a string, you cannot set the value to another type, such as an integer.</p>

<p>Creating and initializing a variable has a special syntax through the use of <code>:=</code>, like the following example:<a data-type="indexterm" data-primary="Values" data-secondary="variable initialization" id="idm46125991432200"/><a data-type="indexterm" data-primary="colon equals sign (:=) to initialize" id="idm46125991431224"/><a data-type="indexterm" data-primary=":= (colon equals sign) to initialize" data-primary-sortas=":= colon equals" id="idm46125991430488"/></p>

<pre data-type="programlisting">{{ $var := .Values.character }}</pre>

<p>In this case a new variable is created and the value of <code>.Values.character</code> is assigned to it. This variable can be used elsewhere; for example:</p>

<pre data-type="programlisting">character: {{ $var | default "Sylvester" | quote }}</pre>

<p>The value of <code>$var</code> is passed to <code>default</code> in the same way <code>.Values.character</code> was passed earlier in the chapter.</p>

<p>The method to create a variable with an initial value is different from the method <a data-type="indexterm" data-primary="equals sign (=) assigning new value" id="idm46125991424904"/><a data-type="indexterm" data-primary="= (equals sign) assigning new value" data-primary-sortas="= equals sign" id="idm46125991424136"/>used to change the value of an existing variable. When you assign a new value to the existing variable, you use <code>=</code>. For example:</p>

<pre data-type="programlisting">{{ $var := .Values.character }}
{{ $var = "Tweety" }}</pre>

<p>In this case the variable is changed in another action. Variables live on for the life of the template execution and are available in the same action or different ones later in the template.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Variable handling is reflective of the syntax and style used in the <a data-type="indexterm" data-primary="Go programming language" data-secondary="variable handling" id="idm46125991420024"/>Go programming language. It follows the same semantics through the use of <code>:=</code>, <code>=</code>, and typing.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Loops"><div class="sect2" id="idm46125991440456">
<h2>Loops</h2>

<p>Using loops is a common method to simplify a user’s interaction with a chart. <a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="loops" id="idm46125991416024"/><a data-type="indexterm" data-primary="loops in templates" id="idm46125991414776"/><a data-type="indexterm" data-primary="lists" data-secondary="loops in templates" id="idm46125991414104"/><a data-type="indexterm" data-primary="iteration (loops) in templates" id="idm46125991413160"/>For example, you can use loops to collect a list of hosts to use when exposing a web application, through values, and then loop over the list to create more complex Kubernetes <code>Ingress</code> resources.</p>

<p>The loop syntax in templates is a little different than that in many programming languages. <a data-type="indexterm" data-primary="range function" id="idm46125991411032"/>Instead of <code>for</code> loops, there are <code>range</code> loops that can be used to <a data-type="indexterm" data-primary="dicts" data-secondary="loops in templates" id="idm46125991409336"/>iterate over <em>dicts</em> (also known as maps) and lists.</p>

<p class="pagebreak-before">The following example illustrates dicts and lists:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="c1"># An example list in YAML</code>
<code class="nt">characters</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Sylvester</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Tweety</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Road Runner</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Wile E. Coyote</code>

<code class="c1"># An example map in YAML</code>
<code class="nt">products</code><code class="p">:</code>
  <code class="nt">anvil</code><code class="p">:</code> <code class="l-Scalar-Plain">They ring like a bell</code>
  <code class="nt">grease</code><code class="p">:</code> <code class="l-Scalar-Plain">50% slippery</code>
  <code class="nt">boomerang</code><code class="p">:</code> <code class="l-Scalar-Plain">Guaranteed to return</code></pre>

<p>You can think of a list as an array, while a map, with a key name and value,<a data-type="indexterm" data-primary="lists" data-secondary="about" id="idm46125991394392"/><a data-type="indexterm" data-primary="dicts" data-secondary="about" id="idm46125991393544"/> is similar to dictionaries in Python or a HashMap in Java. <a data-type="indexterm" data-primary="dicts" data-secondary="dict function" id="idm46125991384568"/><a data-type="indexterm" data-primary="lists" data-secondary="list function" id="idm46125991383624"/>Within Helm templates you can create your own dictionaries and lists using the <code>dict</code> and <code>list</code> functions.</p>

<p>There are two ways you can use the <code>range</code> function. The following example iterates over the <em>characters</em> while changing the scope, which is the value of <code>.</code>:<a data-type="indexterm" data-primary="dot (.) in range loops" id="idm46125991380152"/><a data-type="indexterm" data-primary=". (dot) in range loops" data-primary-sortas=". dot" id="idm46125991379416"/></p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">characters</code><code class="p">:</code>
<code class="p-Indicator">{{</code><code class="nv">- range .Values.characters</code> <code class="p-Indicator">}}</code>
  <code class="p-Indicator">-</code> <code class="p-Indicator">{{</code> <code class="nv">. | quote</code> <code class="p-Indicator">}}</code>
<code class="p-Indicator">{{</code><code class="nv">- end</code> <code class="p-Indicator">}}</code></pre>

<p>In this case <code>range</code> iterates over each item in the list and sets the value of <code>.</code> to the value of each item in the list as Helm iterates over the item. In this example, the value is passed to <code>quote</code> in the pipeline. The scope for <code>.</code> is changed in the block up to <code>end</code>, which acts as the closing bracket or statement for the loop.</p>

<p>The output of this snippet is:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">characters</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="s">"Sylvester"</code>
  <code class="p-Indicator">-</code> <code class="s">"Tweety"</code>
  <code class="p-Indicator">-</code> <code class="s">"Road</code><code class="nv"> </code><code class="s">Runner"</code>
  <code class="p-Indicator">-</code> <code class="s">"Wile</code><code class="nv"> </code><code class="s">E.</code><code class="nv"> </code><code class="s">Coyote"</code></pre>

<p>The other way to use <code>range</code> is by having it create new variables for the key and value. This will work on both lists and dicts. This next example creates the variables that you can use in the block:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">products</code><code class="p">:</code>
<code class="p-Indicator">{{</code><code class="nv">- range $key</code><code class="p-Indicator">,</code> <code class="nv">$value</code> <code class="p-Indicator">:</code><code class="nv">= .Values.products</code> <code class="p-Indicator">}}</code>
  <code class="p-Indicator">-</code> <code class="p-Indicator">{{</code> <code class="nv">$key</code> <code class="p-Indicator">}}:</code> <code class="p-Indicator">{{</code> <code class="nv">$value | quote</code> <code class="p-Indicator">}}</code>
<code class="p-Indicator">{{</code><code class="nv">- end</code> <code class="p-Indicator">}}</code></pre>

<p>The <code>$key</code> variable contains the key in a map or dict and a number in a list. <code>$value</code> contains the value. If this is a complex type, such as another dict, that will be available as the <code>$value</code>. The new variables are in scope up to the end of the <code>range</code> block, which is signified by the corresponding <code>end</code> action. The output of this example is:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">products</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">anvil</code><code class="p">:</code> <code class="s">"They</code><code class="nv"> </code><code class="s">ring</code><code class="nv"> </code><code class="s">like</code><code class="nv"> </code><code class="s">a</code><code class="nv"> </code><code class="s">bell"</code>
  <code class="p-Indicator">-</code> <code class="nt">boomerang</code><code class="p">:</code> <code class="s">"Guaranteed</code><code class="nv"> </code><code class="s">to</code><code class="nv"> </code><code class="s">return"</code>
  <code class="p-Indicator">-</code> <code class="nt">grease</code><code class="p">:</code> <code class="s">"50%</code><code class="nv"> </code><code class="s">slippery"</code></pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125991242072">
<h5>Under the Hood: dict and list</h5>
<p>Within Go, lists are represented as slices that are backed by arrays. The <a data-type="indexterm" data-primary="lists" data-secondary="about" id="idm46125991196024"/><a data-type="indexterm" data-primary="lists" data-secondary="list function" id="idm46125991195080"/>value is an interface, so it could be a variety of types. For example, if you use the <code>list</code> function to create a list within a template the returned value would be typed as <code>[]interface{}</code>. When actions are taken on the value, reflection is used to figure out the type and how to act on that type.</p>

<p>A map or dict is represented a little differently. They are typically <a data-type="indexterm" data-primary="dicts" data-secondary="about" id="idm46125991192568"/><a data-type="indexterm" data-primary="maps" data-see="dicts" id="idm46125991191592"/>represented as <code>map[<em>string</em>]interface{}</code>. This is the type returned from the <code>dict</code> function that you can use within templates. As with lists, the value type is figured out using reflection when action is taken on the value.<a data-type="indexterm" data-startref="ch05-syn" id="idm46125991188984"/></p>
</div></aside>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Named Templates"><div class="sect1" id="idm46125999052936">
<h1>Named Templates</h1>

<p>There are times where you will want to create a template to call from within your <a data-type="indexterm" data-primary="templates" data-secondary="named templates" id="ch05-nam"/><a data-type="indexterm" data-primary="named templates" id="ch05-nam2"/>template of a Kubernetes manifest—for example, when you have a value generated by some complex logic or when you have a section that is repeated across numerous Kubernetes manifests. You can create your own templates, which Helm won’t automatically render, and use them within templates of Kubernetes manifests.</p>

<p>An example of this can be found when you run <code>helm create</code> to generate a chart. By default Helm creates several Kubernetes manifests with some shared elements, such as labels. To keep the labels consistent and so they only need to be updated in one place, Helm generates a template and then calls that template each time the labels are needed.</p>

<p>There are two types of labels used in the templates. There are the labels <a data-type="indexterm" data-primary="create command" data-secondary="label management with named templates" id="ch05-label2"/><a data-type="indexterm" data-primary="labels" data-secondary="management with named templates" id="ch05-label"/>used on higher-level resources, such as <code>Deployment</code>s, and then there are the labels used in specifications that are paired with selectors used for updates. These labels need to be treated differently because the labels used on specifications and selectors are typically immutable. This means you won’t want them to contain elements such as application versions because those can change as an application is upgraded, but the specifications and selectors cannot be updated with new versions.</p>

<p>The following template selection contains the selector labels used to generate specifications and selector sections in the generated template. The name, <em>anvil</em>, is from the chart generated in <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a>:</p>

<pre data-type="programlisting">{{/*
Selector labels <a class="co" id="co_developing_templates_CO1-1" href="#callout_developing_templates_CO1-1"><img src="Images/1.png" alt="1"/></a>
*/}}
{{- define "anvil.selectorLabels" -}} <a class="co" id="co_developing_templates_CO1-2" href="#callout_developing_templates_CO1-2"><img src="Images/2.png" alt="2"/></a>
app.kubernetes.io/name: {{ include "anvil.name" . }} <a class="co" id="co_developing_templates_CO1-3" href="#callout_developing_templates_CO1-3"><img src="Images/3.png" alt="3"/></a>
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end -}} <a class="co" id="co_developing_templates_CO1-4" href="#callout_developing_templates_CO1-4"><img src="Images/4.png" alt="4"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_developing_templates_CO1-1" href="#co_developing_templates_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>A comment prior to defining the function. Comments in actions open with <code>/*</code> and are closed by <code>*/</code>.</p></dd>
<dt><a class="co" id="callout_developing_templates_CO1-2" href="#co_developing_templates_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>You define a template with a <code>define</code> statement followed by the name for the template.</p></dd>
<dt><a class="co" id="callout_developing_templates_CO1-3" href="#co_developing_templates_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The content of a template is just like the content of any other template.</p></dd>
<dt><a class="co" id="callout_developing_templates_CO1-4" href="#co_developing_templates_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The definition for a template is closed through an <code>end</code> statement that matches to the <code>define</code> statement.</p></dd>
</dl>

<p>This template includes several useful things you should consider using in your own templates:</p>
<ol>
<li>
<p>A comment describing the template. This is ignored when the <a data-type="indexterm" data-primary="templates" data-secondary="comments in" id="idm46125991124584"/><a data-type="indexterm" data-primary="comments in templates" id="idm46125991123608"/>template is rendered but is useful in the same way code comments are.</p>
</li>
<li>
<p>The name is namespaced, using <code>.</code> as the separator, to include the chart name.<a data-type="indexterm" data-primary="Kubernetes" data-secondary="namespace" data-tertiary="named templates" id="idm46125991121272"/><a data-type="indexterm" data-primary="templates" data-secondary="library charts" data-tertiary="namespacing template name" id="idm46125991120024"/><a data-type="indexterm" data-primary="namespace (Kubernetes)" data-secondary="named templates" id="idm46125991118792"/><a data-type="indexterm" data-primary="library charts" data-secondary="namespacing template name" id="idm46125991117848"/><a data-type="indexterm" data-primary="dependencies between charts" data-secondary="namespacing template name" id="idm46125991116888"/><a data-type="indexterm" data-primary="charts" data-secondary="library charts" data-tertiary="namespacing template name" id="idm46125991115912"/><a data-type="indexterm" data-primary="charts" data-secondary="dependencies" data-tertiary="namespacing template name" id="idm46125991114680"/> In <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a> you will learn about library charts and dependent charts. Using a namespace on a template name enables the use of library charts and avoids collisions on dependent charts.</p>
</li>
<li>
<p>The <code>define</code> and <code>end</code> calls use actions that remove whitespace before and after them so that their use does not add extra lines to the final output YAML.</p>
</li>

</ol>

<p>This template is called in the <code>spec</code> section of resources, such as the <code>Deployment</code> in the <em>anvil</em> chart:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">spec</code><code class="p">:</code>
  <code class="nt">replicas</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">.Values.replicaCount</code> <code class="p-Indicator">}}</code>
  <code class="nt">selector</code><code class="p">:</code>
    <code class="nt">matchLabels</code><code class="p">:</code>
      <code class="p-Indicator">{{</code><code class="nv">- include "anvil.selectorLabels" . | nindent 6</code> <code class="p-Indicator">}}</code>
  <code class="nt">template</code><code class="p">:</code>
    <code class="nt">metadata</code><code class="p">:</code>
      <code class="nt">labels</code><code class="p">:</code>
        <code class="p-Indicator">{{</code><code class="nv">- include "anvil.selectorLabels" . | nindent 8</code> <code class="p-Indicator">}}</code></pre>

<p>The <code>matchLabels</code> section here is immutable, so it cannot be changed and it looks for the <code>labels</code> in the <code>template</code> section.</p>

<p>There are two functions you can use to include another template in your template. <a data-type="indexterm" data-primary="template function for including a template" id="idm46125991094616"/>The <code>template</code> function is a basic function for including another template. It cannot be used in pipelines. <a data-type="indexterm" data-primary="include function to include a template" id="idm46125991083752"/><a data-type="indexterm" data-primary="pipelines in template syntax" data-secondary="including another function" id="idm46125991083080"/><a data-type="indexterm" data-primary="nindent function" data-secondary="including another template" id="idm46125991082200"/>Then there is the <code>include</code> function that works in a similar manner but can be used in pipelines. In the preceding example, <code>include</code> is used to call another template and the output of that template is passed to <code>nindent</code> to ensure the output has the proper indentation level. Since the output has a different indentation level for each call, the indentation level cannot be included as part of the template that defines it.</p>

<p>The <code>include</code> function takes two arguments. The first is the name of the template to call. This needs to be the full name including any namespace. The second is the data object to pass. This can be one you create yourself, using the <code>dict</code> function, or it can be all or part of the global object used within the template. In this case the whole global object is passed in.</p>

<p>The template function Helm created to generate the wider selection of labels, used on the labels for the higher-level resources where the labels are mutable, both adds labels and includes the selector labels. It has user-defined templates that call other user-defined templates:</p>

<pre data-type="programlisting">{{/*
Common labels
*/}}
{{- define "anvil.labels" -}}
helm.sh/chart: {{ include "anvil.chart" . }}
{{ include "anvil.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end -}}</pre>

<p>Because these labels are mutable, there are useful labels included here that will change for various reasons. So as not to repeat the labels used for selectors, which are useful here as well, those labels are included by calling the function that generates them.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125991075512">
<h5>Kubernetes Recommended Labels</h5>
<p>The Kubernetes documentation recommends a set of common labels that you can <a data-type="indexterm" data-primary="labels" data-secondary="management with named templates" data-tertiary="Kubernetes recommended labels" id="idm46125991073976"/><a data-type="indexterm" data-primary="manifests" data-secondary="label recommendations by Kubernetes" id="idm46125991072648"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="label recommendations" id="idm46125991071688"/><a data-type="indexterm" data-primary="names" data-secondary="label recommendations by Kubernetes" id="idm46125991070744"/>apply to your workload manifests. The chart generated by <code>helm create</code> includes templates that generate these labels for you.</p>

<p>The labels begin with the prefix <em>app.kubernetes.io</em> followed by <em>/</em> as a separator. The Kubernetes documentation for labels notes that a prefix should be used for any labels generated by automation and that those without a prefix are private to the user. These labels are for users, like you, and for various tools.</p>

<p>These labels include the application’s name, the instance of the application (you can run an application more than once in a cluster and even a single namespace), the version of the application, a component type used to show where it fits in a larger 
<span class="keep-together">application</span>, what the application is part of, and the name of the tool used to manage the life cycle of the application (e.g., Helm). These labels are useful when linking applications together, displaying metadata in a user interface, and querying for information at the Kubernetes API.</p>

<p>You can learn more about the labels, which includes examples, in the<a data-type="indexterm" data-primary="resources for learning" data-secondary="label recommendations by Kubernetes" id="idm46125991065640"/> <a href="https://oreil.ly/uAFIm">Kubernetes documentation</a>.</p>
</div></aside>

<p>Another situation you may find yourself in where a named template would be useful is <a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="complex logic in named template" id="idm46125991063368"/><a data-type="indexterm" data-primary="named templates" data-secondary="getImage example" id="idm46125991062168"/>when you want to encapsulate complex logic. To illustrate this idea, consider a chart where you want to be able to pass in a container version as a tag, a digest, or fall back on the application version as a default. The part of the <code>Pod</code> specification that accepts the container image, including the version, is a single line. To provide all three of those options you need many lines of logic:<a data-type="indexterm" data-primary="containers" data-secondary="container images" data-tertiary="getImage example" id="idm46125991060280"/><a data-type="indexterm" data-primary="images (container images)" data-secondary="getImage example" id="idm46125991059032"/></p>

<pre data-type="programlisting">{{- define "anvil.getImage" -}}
{{- if .Values.image.digest -}}
{{ .Values.image.repository }}@{{ .Values.image.digest }}
{{- else -}}
{{ .Values.image.repository }}:
{{- .Values.image.tag | default .Chart.AppVersion }}
{{- end -}}
{{- end -}}</pre>

<p>This new <code>getImage</code> template is able to handle a digest, tag, and default to the application version if neither of the other two are present. First, a digest is checked for and used. A digest is immutable, and it is the most precise method to specify the revision of an image to use. If no digest is passed in, a tag is checked. Tags are pointers to digests and can be changed. If no tag is found, the <code>AppVersion</code> is used as a tag.</p>

<p>This function targets the structure of the <em>anvil</em> chart, first created for <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a>. The image details are expected to be within the structure of that chart and its <em>values.yaml</em> file.</p>

<p>In the template for the <code>Deployment</code>, the image would be referenced using the new function:</p>

<pre data-type="programlisting">image: "{{ include "anvil.getImage" . }}"</pre>

<p>Templates can act like functions in a software program. They are a useful way for you to break off complex logic and have shared functionality.<a data-type="indexterm" data-startref="ch05-nam" id="idm46125991022104"/><a data-type="indexterm" data-startref="ch05-nam2" id="idm46125991021400"/><a data-type="indexterm" data-startref="ch05-label" id="idm46125991020728"/><a data-type="indexterm" data-startref="ch05-label2" id="idm46125991020056"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Structuring Your Templates for Maintainability"><div class="sect1" id="idm46125991187240">
<h1>Structuring Your Templates for Maintainability</h1>

<p>There is limited structure that is enforced on the templates in the <em>templates</em> directory.<a data-type="indexterm" data-primary="templates" data-secondary="structuring for maintainability" id="idm46125991017624"/> Multiple Kubernetes manifests can be in the same YAML file, which means that the templates for multiple Kubernetes manifests can be in the same file, too. Named 
<span class="keep-together">templates</span> can live in any of the template files and be referenced in the others. The <em>NOTES.txt</em> template is a special file that displays to the user, and tests are handled in a special way. Tests are covered in <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a>. Other than that, it is a blank canvas for you to create templates.</p>

<p>To aid in creating maintainable templates that are easy to navigate, the Helm maintainers recommend several patterns. These patterns are useful for a few reasons:</p>

<ul>
<li>
<p>You may go long periods without making structural changes to the templates in a chart and then come back to it. Being able to quickly rediscover the layout will make the processes faster.</p>
</li>
<li>
<p>Other people will look at the templates in charts. This may be team members who create the chart or those that consume it. Consumers can, and sometimes do, open up a chart to inspect it prior to installing it or as part of a process to fork it.</p>
</li>
<li>
<p>When you debug a chart, which is covered in the next section, it is easier to do so with some structure in the templates.</p>
</li>
</ul>

<p>The first pattern is that each Kubernetes manifest should be in its own template file and that file should have a <a data-type="indexterm" data-primary="names" data-secondary="descriptive template names" id="idm46125991009496"/>descriptive name. For example, name your template <em>deployment.yaml</em> if there is a single deployment. If you have the case of multiple manifests of the same type, such as the case when you have a database deployed using primaries and replicas, you use names such as <em>statefulset-primary.yaml</em> and <em>statefulset-replica.yaml</em>.</p>

<p>A second guideline is to put the named templates, which you include in your own <a data-type="indexterm" data-primary="named templates" data-secondary="_helpers.tpl file for" id="idm46125991006472"/><a data-type="indexterm" data-primary="templates" data-secondary="named templates" data-tertiary="_helpers.tpl file for" id="idm46125991005496"/><a data-type="indexterm" data-primary="_ (underscore) before file names" data-secondary="_helpers.tpl file for named templates" data-primary-sortas="_ underscore" id="idm46125991004280"/><a data-type="indexterm" data-primary="underscore (_) before file names" data-secondary="_helpers.tpl file for named templates" id="idm46125991002984"/>templates, into a file named <em>_helpers.tpl</em>. Because these are essentially helper templates for your other templates, the name is descriptive. As mentioned earlier, the _ at the start of the name causes it to bubble up to the top of directory listings so you can easily find it among your templates.</p>

<p>When you use the <code>helm create</code> command to start a new chart, the contents of the templates it starts with, by default, will already follow these patterns.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Debugging Templates"><div class="sect1" id="idm46125991000088">
<h1>Debugging Templates</h1>

<p>When developing templates it’s useful to debug the templates. Helm provides three features you can use in your development workflow to find issues. These are in addition to testing, which is covered in <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a>.</p>








<section data-type="sect2" data-pdf-bookmark="Dry Run"><div class="sect2" id="idm46125990997400">
<h2>Dry Run</h2>

<p>The commands to install, upgrade, roll back, and uninstall Helm charts all have a <a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="dry-run flag" id="idm46125990995512"/><a data-type="indexterm" data-primary="dry-run flag" id="idm46125990994568"/><a data-type="indexterm" data-primary="templates" data-secondary="debugging" data-tertiary="dry-run flag" id="idm46125990993896"/><a data-type="indexterm" data-primary="install command" data-secondary="dry-run flag" id="idm46125990992680"/><a data-type="indexterm" data-primary="upgrades" data-secondary="dry-run flag" id="idm46125990991736"/>flag to initiate a dry run and simulate the process but not fully execute on that process. This is accomplished using the <code>--dry-run</code> flag on these commands. For example, if you use the <code>--dry-run</code> flag on the <code>install</code> command on the <em>anvil</em> chart, you could use the command <code>helm install myanvil anvil --dry-run</code>. Helm would render the templates, check the templates to make sure what would be sent to Kubernetes was well formed, and would then send it to output. The output would look similar to the output on a normal install but would have two additional sections:</p>

<pre data-type="programlisting">NAME: myanvil
LAST DEPLOYED: Tue Jun  9 06:58:58 2020
NAMESPACE: default
STATUS: pending-install
REVISION: 1
HOOKS:
...
MANIFEST:
...
NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default ↵
    -l "app.kubernetes.io/name=anvil,app.kubernetes.io/instance=myanvil" ↵
    -o jsonpath="{.items[0].metadata.name}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace default port-forward $POD_NAME 8080:80</pre>

<p>The two new sections are the <em>HOOKS</em> and <em>MANIFEST</em> sections that will contain the YAML Helm would normally pass to Kubernetes. Instead it is sent to the output. For brevity the full generated YAML is not included because this would be pages long.</p>

<p>If there were a problem in the templates, the response would be quite different. To illustrate this, try removing the first <code>}</code> from the <em>deployment.yaml</em> file in the <em>anvil</em> chart and performing a dry-run install again. Removing the <code>}</code> will cause an error parsing the actions in the templates. Instead of outputting the status, Helm will output an error like:</p>

<pre data-type="programlisting">Error: parse error at (anvil/templates/deployment.yaml:4): unexpected "}" in
operand</pre>

<p>The information here outlines a hint where to look for the issue. It includes:</p>

<ul>
<li>
<p>The file where the error is occurring. <em>anvil/templates/deployment.yaml</em>, in this case.</p>
</li>
<li>
<p>The line number in the file where the error occurred. Here it is line 4.</p>
</li>
<li>
<p>An error message with a hint about the problem. The error message will often not display what the issue is, but rather where the parser is having an issue. In this case a single <code>}</code> is unexpected.</p>
</li>
</ul>

<p>Helm will check for more than errors in the template syntax. It will also check the syntax of the output. To illustrate this, in the same <em>deployment.yaml</em> file remove the <code>apiVersion:</code> at the start of it. Make sure to add back the missing <code>}</code> so that the action is fixed. The beginning of the file will now look like:</p>

<pre data-type="programlisting">apps/v1
kind: Deployment</pre>

<p>Performing a dry-run install will produce the following output:</p>

<pre data-type="programlisting">Error: YAML parse error on anvil/templates/deployment.yaml: error converting
YAML to JSON: yaml: line 2: mapping values are not allowed in this context</pre>

<p>You might be wondering why there is an error converting between YAML and JSON. This is a product of the YAML parsing library that Helm and Kubernetes use. The useful part of the error message is the part that starts with <code>line 2</code>. The first line is not complete, so the second line is in the wrong context even though it is well formed. The file is not valid YAML, and Helm is telling you where to start looking for the problem. If you took the same section of YAML and tested it in an online YAML validator, you would get the same error.</p>

<p>Helm is also able to validate the schemas of Kubernetes resources. This is <a data-type="indexterm" data-primary="manifests" data-secondary="schema definitions from Kubernetes" id="idm46125990971144"/><a data-type="indexterm" data-primary="schema validation of Kubernetes resources" id="idm46125990970152"/><a data-type="indexterm" data-primary="resources" data-secondary="schema validation" id="idm46125990969384"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="resources" data-tertiary="schema validation" id="idm46125990968440"/>accomplished because Kubernetes provides schema definitions for its manifests. To illustrate this, change the <code>apiVersion</code> in the <em>deployment.yaml</em> to be <code>foo</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">foo</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code></pre>

<p>Performing a dry-run install will produce the following output:</p>

<pre data-type="programlisting">Error: unable to build kubernetes objects from release manifest: error
validating "": error validating data: apiVersion not set</pre>

<p>The deployment is no longer valid, and Helm was able to provide specific feedback on what is missing. In this case, the <code>apiVersion</code> property is not set.</p>

<p>Utilizing a dry-run isn’t the only way you can get access to this feature. The 
<span class="keep-together"><code>helm template</code></span> command<a data-type="indexterm" data-primary="template command" data-secondary="cluster not interrogated" id="idm46125990956088"/><a data-type="indexterm" data-primary="template command" data-secondary="debugging templates" id="idm46125990955144"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="helm template command" id="idm46125990954200"/> provides a similar experience but without the full debugging feature set. The <code>template</code> command does turn the <code>template</code> commands into YAML. At this point it will provide an error if the generated YAML cannot be parsed. What it won’t do is validate the YAML against the Kubernetes schema. The <code>template</code> command won’t warn you if <code>apiVersion</code> is turned to <code>foo</code>. This is due to Helm not communicating with a Kubernetes cluster to get the schema for validation when the <code>template</code> command is used.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Getting Installed Manifests"><div class="sect2" id="idm46125990996776">
<h2>Getting Installed Manifests</h2>

<p>There are times where you install an application into a cluster and something else changes the manifests afterwards.<a data-type="indexterm" data-primary="get command" data-secondary="manifest retrieval" id="idm46125990944696"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="helm get command" data-tertiary="manifests" id="idm46125990943720"/><a data-type="indexterm" data-primary="manifests" data-secondary="helm get command to retrieve" id="idm46125990942536"/><a data-type="indexterm" data-primary="YAML" data-secondary="manifests for resources" data-tertiary="helm get command to retrieve" id="idm46125990941576"/><a data-type="indexterm" data-primary="resources" data-secondary="manifests" data-tertiary="helm get command to retrieve" id="idm46125990940344"/><a data-type="indexterm" data-primary="service meshes" data-secondary="manifest changes" id="idm46125990939112"/><a data-type="indexterm" data-primary="templates" data-secondary="debugging" data-tertiary="manifests" id="idm46125990938168"/> This leads to differences between what you declared and what you have running. One example of this is when a service mesh automatically adds a sidecar container to the <code>Pod</code>s created by your Helm charts.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125990918792">
<h5>Service Mesh</h5>
<p>A service mesh is a layer of infrastructure used to manage <a data-type="indexterm" data-primary="service meshes" id="idm46125990917656"/>service-to-service communications. In Kubernetes, a service mesh uses a sidecar proxy container added to <code>Pod</code>s to handle the communication. Many service mesh platforms offer the ability to automatically inject the sidecar proxies by altering the configuration of manifests.</p>
</div></aside>

<p>You can get the original manifests deployed by Helm using the <code>helm get manifest</code> command. This command will retrieve the manifests for a release as they were when Helm installed the release. It is able to retrieve this information for any revision of a release still available in the history, as found using the <code>helm history</code> command.</p>

<p>To continue the <em>myanvil</em> example, to retrieve the manifests for this instance of the <em>anvil</em> chart you would run:</p>

<pre data-type="programlisting">$ helm get manifest myanvil</pre>

<p>The output will include all of the manifests with <code>---</code> at the start of each new manifest. The following is the first 15 lines from the output:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nn">---</code>
<code class="c1"># Source: anvil/templates/serviceaccount.yaml</code>
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ServiceAccount</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">myanvil-anvil</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="nt">helm.sh/chart</code><code class="p">:</code> <code class="l-Scalar-Plain">anvil-0.1.0</code>
    <code class="nt">app.kubernetes.io/name</code><code class="p">:</code> <code class="l-Scalar-Plain">anvil</code>
    <code class="nt">app.kubernetes.io/instance</code><code class="p">:</code> <code class="l-Scalar-Plain">myanvil</code>
    <code class="nt">app.kubernetes.io/version</code><code class="p">:</code> <code class="s">"9.17.49"</code>
    <code class="nt">app.kubernetes.io/managed-by</code><code class="p">:</code> <code class="l-Scalar-Plain">Helm</code>
<code class="nn">---</code>
<code class="c1"># Source: anvil/templates/service.yaml</code>
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Service</code>
<code class="nn">...</code></pre>

<p><code>---</code> is used as a separator between YAML documents. In addition to that, Helm adds a YAML comment with the source template used to generate the manifest.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Linting Charts"><div class="sect2" id="idm46125990946216">
<h2>Linting Charts</h2>

<p>Some of the problems you will encounter don’t show up as violations of the <a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="linting charts" id="idm46125990868632"/><a data-type="indexterm" data-primary="linting charts" id="idm46125990867688"/><a data-type="indexterm" data-primary="templates" data-secondary="debugging" data-tertiary="linting charts" id="idm46125990867016"/><a data-type="indexterm" data-primary="names" data-secondary="lint detecting problems" id="idm46125990865800"/><a data-type="indexterm" data-primary="building charts" data-secondary="linting" id="idm46125990864856"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="linting" id="idm46125990863912"/>API specification and aren’t problems in the templates. For example, Kubernetes resources are required to have names that can be used as part of a domain name. This restricts the characters that you can use in names and their length. The OpenAPI schema provided by Kubernetes does not provide enough information to detect names that will fail when sent to Kubernetes. The <em>lint</em> command, previously covered in <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a>, is able to detect problems like this and tell you where they are.</p>

<p>To illustrate this you can modify the <em>anvil</em> chart to add <code>Wile</code> to the end of the Deployment name in <em>deployment.yaml</em>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">include "anvil.fullname" .</code> <code class="p-Indicator">}}</code><code class="l-Scalar-Plain">-Wile</code></pre>

<p>Running <code>helm lint anvil</code> will produce an error informing you of the issue:</p>

<pre data-type="programlisting">$ helm lint anvil
==&gt; Linting anvil
[ERROR] templates/deployment.yaml: object name does not conform to Kubernetes
naming requirements: "test-release-anvil-Wile"

Error: 1 chart(s) linted, 1 chart(s) failed</pre>

<p>In this case, <code>helm lint</code> is pointing you to a problem and telling you where it is 
<span class="keep-together">happening</span>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46125990837336">
<h1>Conclusion</h1>

<p>The templates you include in a chart provide a powerful ability to create resources within Kubernetes. It’s akin to a programming language around templates. The template system has features like logic, built-in functions, custom templates, and debugging. This means you can collect the input you desire through values and generate the Kubernetes manifests you need.</p>

<p>There is still more to charts, including dependencies, testing, schemas for values files, and more. <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a> is going to expand on what you can have and do with charts.</p>
</div></section>







</div></section></div></body></html>