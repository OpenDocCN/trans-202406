- en: Chapter 3\. Cluster Hardening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The domain “cluster hardening” touches on topics important to keep a cluster
    as secure as possible once it has been set up and configured initially. As part
    of the discussion of this chapter, you may notice that I will reference concepts
    and practices that usually fall into the hands of Kubernetes administrators. Where
    appropriate, I will provide links to the topics that have already been covered
    by the CKA exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to the Kubernetes API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring role-based access control (RBAC) to minimize exposure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercising caution in using service accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating Kubernetes frequently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the Kubernetes API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API server is the gateway to the Kubernetes cluster. Any human user, client
    (e.g., `kubectl`), cluster component, or service account will access the API server
    by making a RESTful API call via HTTPS. It is *the* central point for performing
    operations like creating a Pod, or deleting a Service.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll only focus on the security-specific aspects relevant
    to the API server. For a detailed discussion on the inner workings of the API
    server and the usage of the Kubernetes API, refer to the book [*Managing Kubernetes*](https://learning.oreilly.com/library/view/managing-kubernetes/9781492033905)
    by Brendan Burns and Craig Tracey (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: Processing a Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 3-1](#api-server-request-processing) illustrates the stages a request
    goes through when a call is made to the API server. For reference, you can find
    more information in the [Kubernetes documentation](https://oreil.ly/DuLdf).'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0301](assets/ckss_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. API server request processing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first stage of request processing is *authentication*. Authentication validates
    the identity of the caller by inspecting the client certificates or bearer tokens.
    If the bearer token is associated with a service account, then it will be verified
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The second stage determines if the identity provided in the first stage can
    access the verb and HTTP path request. Therefore, stage two deals with *authorization*
    of the request, which is implemented with the standard Kubernetes RBAC model.
    Here, we’d ensure that the service account is allowed to list Pods or create a
    new Service object if that’s what has been requested.
  prefs: []
  type: TYPE_NORMAL
- en: The third stage of request processing deals with *admission control*. Admission
    control verifies if the request is well-formed and potentially needs to be modified
    before the request is processed. An admission control policy could, for example,
    ensure that the request for creating a Pod includes the definition of a specific
    label. If it doesn’t define the label, then the request is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The last stage of the process ensures that the resource included in the request
    is valid. Request *validation* can be implemented as part of admission control
    but doesn’t have to be. For example, this stage ensures that the name of a Service
    object sticks to the standard Kubernetes naming rules for provided DNS names.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the API Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s easy to determine the endpoint for the API server by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the given Kubernetes cluster, the API server has been exposed via the URL
    [*https://172.28.40.5:6443*](https://172.28.40.5:6443). Alternatively, you can
    also have a look at the command line options `--advertise-address` and `--secure-port`
    in the configuration file of the API server to determine the endpoint. You can
    find the API server configuration file at `/etc/kubernetes/manifests/kube-apiserver.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an insecure port for the API server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to configure the API server to use an insecure port (e.g., 80) has
    been deprecated in Kubernetes 1.10\. With version 1.24, the insecure port flags
    `--port` and `--insecure-port` have been removed completely and therefore cannot
    be used to configure the API server anymore. See the [release notes](https://oreil.ly/OTsmV)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Using the kubernetes Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kubernetes makes accessing the API server a little bit more convenient for
    specific use cases. For example, you may want to send a request to the Kubernetes
    API from a Pod. Instead of using the IP address and port for the API server, you
    can simply refer to the Service named `kubernetes.default.svc` instead. This special
    Service lives in the `default` namespace and is stood up by the cluster automatically.
    Deleting the Service will automatically recreate it. You can easily find the Service
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon inspection of the endpoints of this Service, you will see that it points
    to the IP address and port of the API server, as demonstrated by executing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The IP address and port of the Service is also exposed to the Pod via environment
    variables. You can read the values of the environment variables from a program
    running inside of a container. The Service’s IP address is reflected by the environment
    variable `KUBERNETES_SERVICE_HOST`. The port can be accessed using the environment
    variable `KUBERNETES_SERVICE_PORT`. To render the environment, simply access the
    environment variables using the `env` command in a temporary Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `kubernetes` Service in the section [“Minimizing Permissions
    for a Service Account”](#minimizing-permissions-service-account).
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command makes an anonymous call to the API using the `curl` command
    line tool to list all namespaces. The option `-k` avoids verifying the server’s
    TLS certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the JSON-formatted HTTP response body, anonymous calls are
    accepted by the API server but do not have the appropriate permissions for the
    operation. Internally, Kubernetes maps the call to the [username `system:anonymous`](https://oreil.ly/_HrbF),
    which effectively isn’t authorized to execute the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Access with a client certificate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make a request as an authorized user, you need to either create a new one
    or use the existing, default user with administrator permissions named `kubernetes-admin`.
    We won’t go through the process of creating a new user right now. For more information
    on creating a user, refer to [“Restricting User Permissions”](#restricting-user-permissions).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command lists all available users, including their client certificate
    and key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cluster_hardening_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The base64-encoded value of the certificate authority
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cluster_hardening_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The user entry with administrator permissions created by default
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_cluster_hardening_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The base64-encoded value of the user’s client certificate
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_cluster_hardening_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The base64-encoded value of the user’s private key
  prefs: []
  type: TYPE_NORMAL
- en: 'For making a call using the user `kubernetes-admin`, we’ll need to extract
    the base64-encoded values for the CA, client certificate, and private key into
    files as a base64-decoded value. The following command copies the base64-encoded
    value and uses the tool `base64` to decode it before it is written to a file.
    The CA value will be stored in the file `ca`, the client certificate value in
    `kubernetes-admin.crt`, and the private key in `kubernetes-admin.key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now point the `curl` command to those files with the relevant command
    line option. The request to the API server should properly authenticate and return
    all existing namespaces, as the `kubernetes-admin` has the appropriated permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Restricting Access to the API Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re exposing the API server to the internet, ask yourself if it is necessary.
    Some cloud providers offer the option of creating a private cluster, which will
    limit or completely disable public access to the API server. For more information,
    see the documentation pages for [EKS](https://oreil.ly/W4Oma) and [GKE](https://oreil.ly/c7G-g).
  prefs: []
  type: TYPE_NORMAL
- en: If you are operating an on-premises Kubernetes cluster, you will need to instantiate
    firewall rules that prevent access to the API server. Setting up firewall rules
    is out of scope for the exam and therefore won’t be discussed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Can Call the API Server from the Internet'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud providers sometimes expose the API server to the internet to simplify
    administrative access. An attacker can try to make an anonymous request to the
    API server endpoint by declining to provide a client certificate or bearer token.
    If the attacker is lucky enough to capture user credentials, then an authenticated
    call can be performed. Depending on the permissions assigned to the user, malicious
    operations can be executed. [Figure 3-2](#api-server-attacker) illustrates an
    attacker calling the API server from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0302](assets/ckss_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. An attacker calls the API server from the internet
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this chapter, we will have a look at how to restrict access to the API server
    and how to implement RBAC with limited permissions by example. [“Understanding
    Open Policy Agent (OPA) and Gatekeeper”](ch05.xhtml#opa-gatekeeper) will review
    admission control with the help of OPA Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting User Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve seen that we can use the credentials of the `kubernetes-admin` user to
    make calls to the Kubernetes API. This user should be used very sparingly, nor
    should the credentials be shared with a lot of humans. A lot of damage can be
    done if the credentials fall into the wrong hands. Reserve this user exclusively
    for humans in charge of cluster administration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For other stakeholders of your Kubernetes cluster, you should set up a dedicated
    user with a limited set of permissions. You may have specific roles in your organization
    you can map to. For example, you may have a developer role that should be allowed
    to manage Deployments, Pods, ConfigMaps, Secrets, and Services, but nothing else.
    To create a new user and assign the relevant RBAC permissions, refer to the [Kubernetes
    documentation](https://oreil.ly/n8EMD). In a nutshell, there are four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and approve a CertificateSigningRequest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Role and a RoleBinding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the user to the [kubeconfig file](https://oreil.ly/OKs9g).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will cover the process in detail, but will come back to the RBAC concept
    in more detail for a service account in [“Minimizing Permissions for a Service
    Account”](#minimizing-permissions-service-account).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a private key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a private key using the `openssl` executable. Provide an expressive
    file name, such as `<username>.key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a certificate signing request (CSR) in a file with the extension `.csr`.
    You need to provide the private key from the previous step. The following command
    uses the username `johndoe` when asked for entering the “Common Name” value. All
    other input requests are optional and can be filled in as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the base64-encoded value of the CSR file content with the following
    command. You will need it when creating the CertificateSigningRequest object in
    the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating and approving a CertificateSigningRequest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following script creates a CertificateSigningRequest object. A [CertificateSigningRequest
    resource](https://oreil.ly/ltFbE) is used to request that a certificate be signed
    by a denoted signer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The value for `kubernetes.io/kube-apiserver-client` for the attribute `spec.signerName`
    signs certificates that will be honored as client certificates by the API server.
    Use the base64-encoded value from the previous step and assign it as a value to
    the attribute `spec.request`. Finally, the optional attribute `spec.expirationSeconds`
    determines the lifespan of the certificate. The assigned value `86400` makes the
    certificate valid for a one day. You will want to increase the expiration time
    depending on how long you want the certificate to last, or simply refrain from
    adding the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the CertificateSigningRequest object, the condition will be
    “Pending.” You will need to approve the signing request within 24 hours or the
    object will be deleted automatically as a means to garbage-collect unnecessary
    objects in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `certificate approve` command to approve the signing request. As a
    result, the condition changes to “Approved,Issued”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, export the issued certificate from the approved CertificateSigningRequest
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Role and a RoleBinding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s time to assign RBAC permissions. In this step, you will create a Role
    and a RoleBinding for the user. The Role models an “application developer” role
    within the organization. A developer should only be allowed to get, list, update,
    and delete Pods. The following imperative command creates the Role object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll bind the Role to the user named `johndoe`. Use the imperative command
    `create rolebinding` to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Adding the user to the kubeconfig file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this last step, you will need to add the user to the kubeconfig file and
    create the context for a user. Be aware that the cluster name is `minikube` in
    the following command, as we are trying this out in a minikube installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s time to switch to the user context named `johndoe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `kubectl` as the client that makes calls to the API server, we’ll verify
    that the operation should be allowed. The API call for listing all Pods in the
    `default` namespace was authenticated and authorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command indicates that the `default` namespace doesn’t contain
    any Pod object at this time but the call was successful. Let’s also test the negative
    case. Listing namespaces is a non-permitted operation for the user. Executing
    the relevant `kubectl` command will return with an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done with verifying permissions, you may want to switch back to
    the context with admin permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Scenario: An Attacker Can Call the API Server from a Service Account'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A user represents a real person who commonly interacts with the Kubernetes cluster
    using the `kubectl` executable or the UI dashboard. Under rare conditions, applications
    running inside of a Pod’s container need to interact with the Kubernetes API.
    A typical example for such a requirement is the package manager [Helm](https://helm.sh).
    Helm manages Kubernetes resources based on the YAML manifests bundled in a Helm
    chart. Kubernetes uses a service account to authenticate the Helm service process
    with the API server through an authentication token. This service account can
    be assigned to a Pod and mapped to RBAC rules.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker who gains access to the Pod will likely also be able to misuse the
    service account to make calls to the Kubernetes API, as shown in [Figure 3-3](#service-account-attacker).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0303](assets/ckss_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. An attacker uses a service account to call the API server
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Minimizing Permissions for a Service Account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to limit the permissions to only those service accounts that
    are really necessary for the application to function. The next sections will explain
    how to achieve this to minimize the potential attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: For this scenario to work, you’ll need to create a ServiceAccount object and
    assign it to the Pod. Service accounts can be tied in with RBAC and assigned a
    Role and RoleBinding to define what operations they should be allowed to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the service account to a Pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a starting point, we are going to a set up a Pod that lists all Pods and
    Deployments in the namespace `k97` by calling the Kubernetes API. The call is
    made as part of an infinite loop every ten seconds. The response from the API
    call will be written to standard output accessible via the Pod’s logs.
  prefs: []
  type: TYPE_NORMAL
- en: To authenticate against the API server, we’ll send a bearer token associated
    with the service account used by the Pod. The default behavior of a service account
    is to auto-mount API credentials on the path `/var/run/secrets/kubernetes.io/serviceaccount/token`.
    We’ll simply get the contents of the file using the `cat` command line tool and
    send them along as a header for the HTTP request. [Example 3-1](#service-account-pod-setup)
    defines the namespace, the service account, and the Pod in a single YAML manifest
    file `setup.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. YAML manifest for assigning a service account to a Pod
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the objects from the YAML file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the default permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Pod named `list-objects` makes a call to the API server to retrieve the
    list of Pods and Deployments in dedicated containers. The container `pods` performs
    the call to list Pods. The container `deployments` sends a request to the API
    server to list Deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained in the [Kubernetes documentation](https://oreil.ly/gBp30), the
    default RBAC policies do not grant any permissions to service accounts outside
    of the `kube-system` namespace. The logs of the containers `pods` and `deployments`
    return an error message indicating that the service account `sa-api` is not authorized
    to list the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we’ll stand up a ClusterRole and RoleBinding object with the required
    API permissions to perform the necessary calls.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ClusterRole
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start by defining the ClusterRole named `list-pods-clusterrole` shown in [Example 3-2](#list-pods-clusterrole)
    in the file `clusterrole.yaml`. The set of the rules only adds the Pod resource
    and the verb `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. YAML manifest for a ClusterRole that allows listing Pods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the object by pointing to its corresponding YAML manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Creating the RoleBinding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Example 3-3](#rolebinding-service-account) defines the YAML manifest for the
    RoleBinding in the file `rolebinding.yaml`. The RoleBinding maps the ClusterRole
    `list-pods-clusterrole` to the service account named `sa-pod-api` and only applies
    to the namespace `k97`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3\. YAML manifest for a RoleBinding attached to a service account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create both the RoleBinding object using the `apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the granted permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the granted `list` permissions, the service account can now properly retrieve
    all the Pods in the `k97` namespace. The `curl` command in the `pods` container
    succeeds, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We did not grant any permissions to the service account for other resources.
    Listing the Deployments in the `k97` namespace still fails. The following output
    shows the response from the `curl` command in the `deployments` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to modify the ClusterRole object to allow listing Deployment objects
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling automounting of a service account token
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Pod described in the previous section used the service account’s token as
    a means to authenticate against the API server. Mounting the token file at `/var/run/secrets/kubernetes.io/serviceaccount/token`
    is the standard behavior of every service account. You will really only need the
    contents of the file if the Pod actually interacts with the Kubernetes API. In
    all other cases, this behavior poses a potential security risk as access to the
    Pod will directly lead an attacker to the token.
  prefs: []
  type: TYPE_NORMAL
- en: You can disable the automount behavior for a service account object by assigning
    the value `false` to the attribute `automountServiceAccountToken`, as shown in
    [Example 3-4](#service-account-disable-automount).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4\. Opting out of a service account’s token automount behavior
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you want to disable the automount behavior for individual Pods, use the attribute
    `spec.automountServiceAccountToken` in the Pod definition. [Example 3-5](#pod-serviceaccount-disable-automount)
    shows a YAML manifest for a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5\. Disabling token automounting for a service account in a Pod
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Generating a service account token
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a variety of use cases that speak for wanting to create a service
    account that *disables* token automounting. For example, you may need access to
    the Kubernetes API from an external tool or a continuous delivery pipeline to
    query for information about existing objects. Authenticating against the API server
    in those scenarios still requires a token. The scenarios listed do not necessarily
    run a Pod with an assigned service account, but simply perform a RESTful API call
    from a tool like `curl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a token manually, execute the `create token` command and provide
    the name of the service account as an argument. The output of the command renders
    the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You’ll need to store the token in a safe place, e.g., a password manager. You
    cannot retrieve the token again if you lose it. You can only recreate it with
    the same command, which will automatically invalidate the previous token. All
    references that use the token will have to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For automated processes, it might be helpful to generate a token with a limited
    lifespan. The `--duration` will automatically invalidate the token after the “time-to-life”
    runs out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Secret for a service account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With Kubernetes 1.24, a ServiceAccount object does not automatically create
    a corresponding Secret object containing the token anymore. See the [release notes](https://oreil.ly/MSPuX)
    for more information. Listing the ServiceAccount object renders 0 for the number
    of Secrets. The object also doesn’t contain the `secrets` attribute anymore in
    the YAML representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can either generate the token using the `create token` command, as described
    in [“Generating a service account token”](#generating-serviceaccount-token), or
    manually create a corresponding Secret. [Example 3-6](#serviceaccount-secret)
    shows a YAML manifest for such a Secret.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-6\. Creating a Secret for a service account manually
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign the service account to the Secret, add the annotation with the key
    `kubernetes.io/service-account.name`. The following command creates the Secret
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the token in the “Data” section when describing the Secret object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Updating Kubernetes Frequently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing a Kubernetes cluster with a specific version is not a one-time fire-and-forget
    operation. Even if you used the latest Long-Term Support (LTS) Release at the
    time of installation, it does not guarantee that your cluster is without security
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: As time goes by, security-related bugs and weaknesses will be discovered. This
    statement includes the underlying operating system and the dependencies the cluster
    nodes run on. An attacker can easily look up security vulnerabilities in the publicly
    disclosed [Common Vulnerabilities and Exposures (CVE) database](https://oreil.ly/FHhXD)
    and exploit them.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning Scheme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s up to the cluster administrator to update the Kubernetes version across
    all nodes on a regular basis. Kubernetes follows the [semantic versioning scheme](https://semver.org).
    A Semantic Version consists of a major version, minor version, and patch version.
    For example, for the Kubernetes version 1.24.3, the major version is 1, the minor
    version is 24, and the patch version is 3.
  prefs: []
  type: TYPE_NORMAL
- en: Each portion of the version carries a specific meaning. A change to the major
    version portion indicates a breaking change. Incrementing the minor version portion
    means that new functionality has been added in a backward-compatible manner. The
    patch version portion simply fixes a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking changes in Kubernetes with minor version updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s important to mention that Kubernetes doesn’t always stick to the strict
    interpretation of semantic versioning. For example, the PodSecurityPolicy (PSP)
    admission controller has been replaced by the Pod Security Admission concept in
    [version 1.25.0](https://oreil.ly/JE-i8). Conventionally, those changes should
    only happen with a major version update. Reference the [Kubernetes deprecation
    policy](https://oreil.ly/on9lu) for a better understanding on how an API, a flag,
    or a feature is phased out.
  prefs: []
  type: TYPE_NORMAL
- en: Release Cadence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can expect [a new minor version release](https://oreil.ly/LGIn5) of Kubernetes
    every three months. The release may include new features and additional bug fixes.
    Security fixes may be implemented as needed for the latest release of Kubernetes
    and will be backported to the two minor releases before that. Always staying on
    top of updating to the latest releases for your own cluster(s) takes quite a bit
    of people-power. You will need to reserve time for those activities accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the Upgrade Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is recommended to upgrade from a minor version to the next higher one (e.g.,
    from 1.23 to 1.24), or from a patch version to a more recent one (e.g., from 1.24.1
    to 1.24.3). Abstain from jumping up multiple minor versions to avoid unexpected
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a full description of the [upgrade steps](https://oreil.ly/RxC9j)
    in the official Kubernetes documentation. [Figure 3-4](#cluster_version_upgrade_process)
    illustrates the upgrade process on a high level.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster version upgrade process is already part of the CKA exam. Given that
    you have to pass the CKA as a prerequisite, I would assume that you already know
    how to perform the process. For a detailed description, refer to [*Certified Kubernetes
    Administrator (CKA) Study Guide*](https://oreil.ly/cka-study-guide).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0304](assets/ckss_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Process for a cluster version upgrade
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users, clients applications (such as `kubectl` or `curl`), Pods using service
    accounts, and cluster components all communicate with the API server to manage
    objects. It’s paramount to secure the API server to prevent access with malicious
    intent.
  prefs: []
  type: TYPE_NORMAL
- en: To minimize the attack surface area, avoid exposing the API server to the internet
    using firewall rules. For every user or service account, restrict the permissions
    to execute operations against the Kubernetes API to the bare minimum using RBAC
    rules. With minimized permissions, attackers can cause far less damage in case
    they can gain access to credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to upgrade the version of your Kubernetes cluster. Incorporating bug
    and security fixes will decrease the risk of exposing unnecessary vulnerabilities
    attackers can use to their advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practice interacting with the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter demonstrated the different ways to communicate with the Kubernetes
    API. We performed API requests by switching to a user context, and with the help
    of a RESTful API call using `curl`. You will need to understand how to determine
    the endpoint of the API server and how to use different authentication methods,
    e.g., client credentials and bearer tokens. Explore the Kubernetes API and its
    endpoints on your own for broader exposure.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the implications of defining RBAC rules for users and service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous user requests to the Kubernetes API will not allow any substantial
    operations. For requests coming from a user or a service account, you will need
    to carefully analyze permissions granted to the subject. Learn the ins and outs
    of defining RBAC rules by creating the relevant objects to control permissions.
    Service accounts automount a token when used in a Pod. Only expose the token as
    a Volume if you are intending to make API calls from the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware of Kubernetes release cadence and the need for upgrading the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster needs to be cared for over time for security reasons. Attackers
    may try to take advantage of known vulnerabilities in outdated Kubernetes versions.
    The version upgrade process is part of every administrator’s job and shouldn’t
    be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  prefs: []
  type: TYPE_NORMAL
- en: Create a client certificate and key for the user named `jill` in the group `observer`.
    With the admin context, create the context for the user `jill`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the group (not the user!), define a Role and RoleBinding in the `default`
    namespace that allow the verbs `get`, `list`, and `watch` for the resources Pods,
    ConfigMaps, and Secrets. Create the objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the user context and execute a `kubectl` command that allows one of
    the granted operations, and one `kubectl` command that should not be permitted.
    Switch back to the `admin` context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Pod named `service-list` in the namespace `t23`. The container uses
    the image `alpine/curl:3.14` and makes a `curl` call to the Kubernetes API that
    lists Service objects in the `default` namespace in an infinite loop. Create and
    attach the service account `api-call`. Inspect the container logs after the Pod
    has been started. What response do you expect to see from the `curl` command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign a ClusterRole and RoleBinding to the service account that only allows
    the operation needed by the Pod. Have a look at the response from the `curl` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Pod so that automounting of the service account token is disabled.
    Retrieve the token value and use it directly with the `curl` command. Make sure
    that the `curl` command can still authorize the operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch03/upgrade-version* of the checked-out GitHub
    repository [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Start up the
    VMs running the cluster using the command `vagrant up`. Upgrade all nodes of the
    cluster from Kubernetes 1.25.6 to 1.26.1\. The cluster consists of a single control
    plane node named `kube-control-plane`, and one worker node named `kube-worker-1`.
    Once done, shut down the cluster using `vagrant destroy -f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Prerequisite:* This exercise requires the installation of the tools [Vagrant](https://oreil.ly/FiyeH)
    and [VirtualBox](https://oreil.ly/WW8IK).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
