<html><head></head><body><section data-pdf-bookmark="Chapter 4. Working with Kubernetes Objects" data-type="chapter" epub:type="chapter"><div class="chapter" id="idm45979389890944">&#13;
<h1><span class="label">Chapter 4. </span>Working with Kubernetes Objects</h1>&#13;
&#13;
<blockquote class="epigraph">&#13;
<p>I can’t understand why people are frightened of new ideas. I’m frightened of the old ones.</p>&#13;
<p data-type="attribution">John Cage</p>&#13;
</blockquote>&#13;
&#13;
<p><a data-primary="Kubernetes" data-secondary="Kubernetes objects" data-type="indexterm" id="ix_04-objects-adoc0"/>In <a data-type="xref" href="ch02.html#firststeps">Chapter 2</a>, you built and deployed an application to Kubernetes. In this chapter, you’ll learn about the fundamental Kubernetes objects involved in that process: Pods, Deployments, and Services. You’ll also find out how to use the essential Helm tool to manage applications in Kubernetes.</p>&#13;
&#13;
<p>After working through the example in <a data-type="xref" href="ch02.html#runningdemo">“Running the Demo App”</a>, you should have a container image running in the Kubernetes cluster, but how does that actually work? Under the hood, the <code>kubectl run</code> command creates a Kubernetes resource called a Deployment. So what’s that? And how does a Deployment actually run your container image?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deployments" data-type="sect1"><div class="sect1" id="deployments-intro">&#13;
<h1>Deployments</h1>&#13;
&#13;
<p><a data-primary="Deployment objects" data-type="indexterm" id="ix_04-objects-adoc1"/>Think <a data-primary="Deployment objects" data-secondary="introduction" data-type="indexterm" id="idm45979389879808"/>back to how you ran the demo app with Docker. The <code>docker container run</code> command started the container, and it ran until you killed it with <code>docker stop</code>.</p>&#13;
&#13;
<p>But suppose that the container exits for some other reason: maybe the program crashed, or there was a system error, or your machine ran out of disk space, or a cosmic ray hit your CPU at the wrong moment (unlikely, but it does happen). Assuming this is a production application, that means you now have unhappy users, until someone can get to a terminal and type <code>docker container run</code> to start the container again.</p>&#13;
&#13;
<p>That’s an unsatisfactory arrangement. What you really want is a kind of supervisor program that continually checks that the container is running, and, if it ever stops, starts it again immediately. On traditional servers, you can use a tool like <code>systemd</code>, <code>runit</code>, or <code>supervisord</code> to do this; Docker has something similar, and you won’t be surprised to know that Kubernetes has a supervisor feature too: the Deployment.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Supervising and Scheduling" data-type="sect2"><div class="sect2" id="idm45979389874176">&#13;
<h2>Supervising and Scheduling</h2>&#13;
&#13;
<p>For each program that Kubernetes has to supervise, it creates a corresponding Deployment object, which records some information about the program: the name of the container image, the number of replicas you want to run, and whatever else it needs to know to start the container.</p>&#13;
&#13;
<p>Working together with the Deployment resource is a kind of Kubernetes component called a <em>controller</em>. Controllers are basically pieces of code that run continuously in a loop, and watch the resources that they’re responsible for, making sure they’re present and working. If a given Deployment isn’t running enough replicas, for whatever reason, the controller will create some new ones. (If there were too many replicas for some reason, the controller would shut down the excess ones. Either way, the controller makes sure that the real state matches the desired state.)</p>&#13;
&#13;
<p>Actually, a Deployment doesn’t manage replicas directly: instead, it automatically creates an associated object called a ReplicaSet, which handles that. We’ll talk more about ReplicaSets in a moment in <a data-type="xref" href="#replicaset-intro">“ReplicaSets”</a>, but since you generally interact only with Deployments, let’s get more familiar with them first.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Restarting Containers" data-type="sect2"><div class="sect2" id="idm45979389869264">&#13;
<h2>Restarting Containers</h2>&#13;
&#13;
<p><a data-primary="Deployment objects" data-secondary="restart policy" data-type="indexterm" id="idm45979389867920"/>At first sight, the way Deployments behave might be a little surprising. If your container finishes its work and exits, the Deployment will restart it. If it crashes, or if you kill it with a signal, or terminate it with <code>kubectl</code>, the Deployment will restart it. (This is how you should think about it conceptually; the reality is a little more complicated, as we’ll see.)</p>&#13;
&#13;
<p>Most Kubernetes applications are designed to be long-running and reliable, so this behavior makes sense: containers can exit for all sorts of reasons, and in most cases all a human operator would do is restart them, so that’s what Kubernetes does by default.</p>&#13;
&#13;
<p>It’s possible to change this policy for an individual container: for example, to never restart it, or to restart it only on failure, not if it exited normally (see <a data-type="xref" href="ch08.html#restartpolicies">“Restart Policies”</a>). However, the default behavior (restart always) is usually what you want.</p>&#13;
&#13;
<p>A Deployment’s job is to watch its associated containers and make sure that the specified number of them is always running. If there are fewer, it will start more. If there are too many, it will terminate some. This is much more powerful and flexible than a traditional supervisor-type program.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating Deployments" data-type="sect2"><div class="sect2" id="idm45979389863136">&#13;
<h2>Creating Deployments</h2>&#13;
&#13;
<p>Go ahead and create a Deployment using our demo container image in your local <a data-primary="kubectl" data-secondary="commands" data-tertiary="create deployment" data-type="indexterm" id="idm45979389861136"/>Kubernetes environment so we can dive into how they work:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl create deployment demo --image=cloudnatived/demo:hello</code></strong><code class="go">&#13;
</code><code class="go">deployment.apps/demo created</code></pre>&#13;
&#13;
<p><a data-primary="Deployment objects" data-secondary="listing" data-type="indexterm" id="idm45979389852352"/><a data-primary="kubectl" data-secondary="commands" data-tertiary="get" data-type="indexterm" id="idm45979389851584"/>You can see all the Deployments active in your current <em>namespace</em> (see <a data-type="xref" href="ch05.html#namespaces">“Using Namespaces”</a>) by running the following command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get deployments</code></strong><code class="go">&#13;
</code><code class="go">NAME   READY   UP-TO-DATE   AVAILABLE   AGE&#13;
</code><code class="go">demo   1/1     1            1           37s</code></pre>&#13;
&#13;
<p><a data-primary="Deployment objects" data-secondary="describing" data-type="indexterm" id="idm45979389826240"/><a data-primary="kubectl" data-secondary="commands" data-tertiary="describe" data-type="indexterm" id="idm45979389825504"/>To get more detailed information on this specific Deployment, run the following command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl describe deployments/demo</code></strong><code class="go">&#13;
</code><code class="go">Name:                   demo&#13;
</code><code class="go">Namespace:              default&#13;
</code><code class="go">...&#13;
</code><code class="go">Labels:                 app=demo&#13;
</code><code class="go">Annotations:            deployment.kubernetes.io/revision: 1&#13;
</code><code class="go">Selector:               app=demo&#13;
</code><code class="go">...</code></pre>&#13;
&#13;
<p>As you can see, there’s a lot of information here, most of which isn’t important for now. <a data-primary="Pod objects" data-secondary="template" data-type="indexterm" id="idm45979389786080"/>Let’s look more closely at the <code>Pod Template</code> section, though:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="go">Pod Template:</code>&#13;
<code class="go">  Labels:  app=demo</code>&#13;
<code class="go">  Containers:</code>&#13;
<code class="go">   demo:</code>&#13;
<code class="go">    Image:        cloudnatived/demo:hello</code>&#13;
<code class="go">    Port:         &lt;none&gt;</code>&#13;
<code class="go">    Host Port:    &lt;none&gt;</code>&#13;
<code class="go">    Environment:  &lt;none&gt;</code>&#13;
<code class="go">    Mounts:       &lt;none&gt;</code>&#13;
<code class="go">  Volumes:        &lt;none&gt;</code>&#13;
<code class="go">...</code></pre>&#13;
&#13;
<p>You know that a Deployment contains the information Kubernetes needs to run the container, and here it is.<a data-startref="ix_04-objects-adoc1" data-type="indexterm" id="idm45979389764864"/> But what’s a Pod Template? Actually, before we answer that, what’s a Pod?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pods" data-type="sect1"><div class="sect1" id="pods-intro">&#13;
<h1>Pods</h1>&#13;
&#13;
<p><a data-primary="Pod objects" data-secondary="introduction to" data-type="indexterm" id="idm45979389750144"/>A <em>Pod</em> is the Kubernetes object that represents a group of one or more containers (<em>pod</em> is also the name for a group of whales, which fits in with the vaguely seafaring flavor of Kubernetes metaphors).</p>&#13;
&#13;
<p>Why doesn’t a Deployment just manage an individual container directly? The answer is that sometimes a set of containers needs to be scheduled together, running on the same node, and communicating locally, perhaps sharing storage. This is where Kubernetes starts to grow beyond simply running containers directly on a host using something like Docker. It manages entire combinations of containers, their configuration, and storage, etc. across a cluster of nodes.</p>&#13;
&#13;
<p>For example, a blog application might have one container that syncs content with a Git repository, and an NGINX web server container that serves the blog content to users. Since they share data, the two containers need to be scheduled together in a Pod. In practice, though, many Pods only have one container, as in this case. (See <a data-type="xref" href="ch08.html#whatbelongsinapod">“What Belongs in a Pod?”</a> for more about this.)</p>&#13;
&#13;
<p>So a Pod specification (<em>spec</em> for short) has a list of <code>containers</code>, and in our example there is only one container, <code>demo</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="go">demo:</code>&#13;
<code class="go"> Image:        cloudnatived/demo:hello</code></pre>&#13;
&#13;
<p>The <code>Image</code> spec is our demo Docker container image from Docker Hub, which is all the information a Kubernetes Deployment needs to start the Pod and keep it running.</p>&#13;
&#13;
<p>And that’s an important point. The <code>kubectl create deployment</code> command didn’t actually create the Pod directly. Instead it created a Deployment, and <em>then</em> the Deployment created a ReplicaSet, which created the Pod. The Deployment is a declaration of your desired state: “A Pod should be running with the <code>demo</code> container inside it.”</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ReplicaSets" data-type="sect1"><div class="sect1" id="replicaset-intro">&#13;
<h1>ReplicaSets</h1>&#13;
&#13;
<p><a data-primary="ReplicaSet objects" data-type="indexterm" id="idm45979389712176"/>Deployments don’t manage Pods directly. That’s the job of the ReplicaSet object.</p>&#13;
&#13;
<p>A ReplicaSet is responsible for a group of identical Pods, or <em>replicas</em>. If there are too few (or too many) Pods, compared to the specification, the ReplicaSet controller will start (or stop) some Pods to rectify the situation.</p>&#13;
&#13;
<p>Deployments, in turn, manage ReplicaSets, and control how the replicas behave when you update them—by rolling out a new version of your application, for example (see <a data-type="xref" href="ch13.html#deploymentstrategies">“Deployment Strategies”</a>). When you update the Deployment, a new ReplicaSet is created to manage the new Pods, and when the update is completed, the old ReplicaSet and its Pods are terminated.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#img-deployment">Figure 4-1</a>, each ReplicaSet (V1, V2, V3) represents a different version of the application, with its corresponding Pods.</p>&#13;
&#13;
<figure><div class="figure" id="img-deployment">&#13;
<img alt="Diagram of a Deployment managing ReplicaSets" src="assets/cndk_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>Deployments, ReplicaSets, and Pods</h6>&#13;
</div></figure>&#13;
&#13;
<p>Usually, you won’t interact with ReplicaSets directly, since Deployments do the work for you—but it’s useful to know what they are.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Maintaining Desired State" data-type="sect1"><div class="sect1" id="maintainingstates">&#13;
<h1>Maintaining Desired State</h1>&#13;
&#13;
<p>Kubernetes controllers continually check the desired state specified by each resource against the actual state of the cluster, and make any necessary adjustments to keep them in sync. <a data-primary="reconciliation loop" data-type="indexterm" id="idm45979389686800"/>This process is called the <em>reconciliation loop</em>, because it loops forever, trying to reconcile the actual state with the desired state.</p>&#13;
&#13;
<p>For example, when you first create the <code>demo</code> Deployment, there is no <code>demo</code> Pod running. So Kubernetes will start the required Pod immediately. If it ever stops, Kubernetes will start it again, so long as the Deployment still exists.</p>&#13;
&#13;
<p>Let’s verify that right now by removing the Pod manually. First, check that the Pod is indeed running:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods --selector app=demo</code></strong><code class="go">&#13;
</code><code class="go">NAME                    READY   STATUS    RESTARTS   AGE&#13;
</code><code class="go">demo-794889fc8d-5ddsg   1/1     Running   0          33s</code></pre>&#13;
&#13;
<p>Note that the name of the Pod will be unique for you. You can also see the ReplicaSet that created this Pod by running:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get replicaset --selector app=demo</code></strong><code class="go">&#13;
</code><code class="go">NAME              DESIRED   CURRENT   READY   AGE&#13;
</code><code class="go">demo-794889fc8d   1         1         1       64s</code></pre>&#13;
&#13;
<p>See how the ReplicaSet has a randomly generated ID that matches the beginning part of the demo Pod name above? In this example, the <code>demo-794889fc8d</code> ReplicaSet created one Pod named <code>demo-794889fc8d-5ddsg</code>.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="delete" data-type="indexterm" id="idm45979389649888"/>Now, run the following command to remove the Pod:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl delete pods --selector app=demo</code></strong><code class="go">&#13;
</code><code class="go">pod "demo-794889fc8d-bdbcp" deleted</code></pre>&#13;
&#13;
<p>List the Pods again:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods --selector app=demo</code></strong><code class="go">&#13;
</code><code class="go">NAME                    READY     STATUS        RESTARTS   AGE&#13;
</code><code class="go">demo-794889fc8d-qbcxm   1/1       Running       0          5s&#13;
</code><code class="go">demo-794889fc8d-bdbcp   0/1       Terminating   0          1h</code></pre>&#13;
&#13;
<p><a data-primary="Terminating status" data-type="indexterm" id="idm45979389603856"/>You may catch the original Pod shutting down (its status is <code>Terminating</code>), but it’s already been replaced by a new Pod, which is only five seconds old. You can also see that the new Pod has the same ReplicaSet, <code>demo-794889fc8d</code>, but a new unique Pod name <code>demo-794889fc8d-qbcxm</code>. That’s the reconciliation loop at work.</p>&#13;
&#13;
<p>You told Kubernetes, by means of the Deployment you created, that the <code>demo</code> Pod should <em>always</em> be running one replica. It takes you at your word, and even if you delete the Pod yourself, Kubernetes assumes you must have made a mistake, and helpfully starts a new Pod to replace it for you.</p>&#13;
&#13;
<p>Once you’ve finished experimenting with the Deployment, shut it down and clean up using the following command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl delete all --selector app=demo</code></strong><code class="go">&#13;
</code><code class="go">pod "demo-794889fc8d-qbcxm" deleted&#13;
</code><code class="go">deployment.apps "demo" deleted&#13;
</code><code class="go">replicaset.apps "demo-794889fc8d" deleted</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Kubernetes Scheduler" data-type="sect1"><div class="sect1" id="idm45979389704784">&#13;
<h1>The Kubernetes Scheduler</h1>&#13;
&#13;
<p><a data-primary="scheduler" data-secondary="introduction" data-type="indexterm" id="idm45979389576736"/>We’ve said things like <em>the Deployment will create Pods</em> and <em>Kubernetes will start the required Pod</em>, without really explaining how that happens.</p>&#13;
&#13;
<p>The Kubernetes <em>scheduler</em> is the component responsible for this part of the process. When a Deployment (via its associated ReplicaSet) decides that a new replica is needed, it creates a Pod resource in the Kubernetes database. Simultaneously, this Pod is added to a queue, which is like the scheduler’s inbox.</p>&#13;
&#13;
<p>The scheduler’s job is to watch its queue of unscheduled Pods, grab the next Pod from it, and find a node to run it on. It will use a few different criteria, including the Pod’s resource requests, to choose a suitable node, assuming there is one available (we’ll talk more about this process in <a data-type="xref" href="ch05.html#resources">Chapter 5</a>).</p>&#13;
&#13;
<p><a data-primary="kubelet" data-type="indexterm" id="idm45979389571728"/>Once the Pod has been scheduled on a node, the kubelet running on that node picks it up and takes care of actually starting its containers (see <a data-type="xref" href="ch03.html#nodecomponents">“Node Components”</a>).</p>&#13;
&#13;
<p>When you deleted a Pod in <a data-type="xref" href="#maintainingstates">“Maintaining Desired State”</a>, it was the <span class="keep-together">ReplicaSet</span> that spotted this and started a replacement. It <em>knows</em> that a <code>demo</code> Pod should be running on its node, and if it doesn’t find one, it will start one. (What would happen if you shut the node down altogether? Its Pods would become unscheduled and go back into the scheduler’s queue, to be reassigned to other nodes.)</p>&#13;
&#13;
<p><a data-primary="Evans, Julia" data-type="indexterm" id="idm45979389546896"/>Stripe engineer Julia Evans has written a delightfully clear explanation of <a href="https://oreil.ly/APoqF">how scheduling works in Kubernetes</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Resource Manifests in YAML Format" data-type="sect1"><div class="sect1" id="applying">&#13;
<h1>Resource Manifests in YAML Format</h1>&#13;
&#13;
<p><a data-primary="YAML" data-secondary="resource manifests in" data-type="indexterm" id="ix_04-objects-adoc20"/><a data-primary="manifest" data-type="indexterm" id="ix_04-objects-adoc2"/>Now <a data-primary="manifest" data-secondary="introduction" data-type="indexterm" id="idm45979389540912"/>that you know how to run an application in Kubernetes, is that it? Are you done? Not quite. Using the <code>kubectl create</code> command to create a Deployment is useful, but limited. Suppose that you want to change something about the <span class="keep-together">Deployment spec:</span> the image name or version, say. You could delete the existing Deployment (using <code>kubectl delete</code>) and create a new one with the right fields. But let’s see if we can do better.</p>&#13;
&#13;
<p>Because Kubernetes is inherently a <em>declarative</em> system, continuously reconciling actual state with desired state, all you need to do is change the desired state—the Deployment spec—and Kubernetes will do the rest.  How do you do that?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Resources Are Data" data-type="sect2"><div class="sect2" id="idm45979389537248">&#13;
<h2>Resources Are Data</h2>&#13;
&#13;
<p>All Kubernetes resources, such as Deployments or Pods, are represented by records in its internal database. The reconciliation loop watches the database for any changes to those records, and takes the appropriate action. In fact, all the <code>kubectl create</code> command does is add a new record in the database corresponding to a Deployment, and Kubernetes does the rest.</p>&#13;
&#13;
<p>But you don’t need to use <code>kubectl create</code> in order to interact with Kubernetes. You can also create and edit the resource <em>manifest</em> (the specification for the desired state of the resource) directly. You can (and should) keep the manifest file in a version control system, and instead of running imperative commands to make on-the-fly changes, you can change your manifest files and then tell Kubernetes to read the updated data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deployment Manifests" data-type="sect2"><div class="sect2" id="deploymentmanifests">&#13;
<h2>Deployment Manifests</h2>&#13;
&#13;
<p><a data-primary="YAML" data-secondary="deployment manifests" data-type="indexterm" id="idm45979389531712"/><a data-primary="Deployment objects" data-secondary="manifest" data-type="indexterm" id="idm45979389530736"/>The usual format for Kubernetes manifest files is YAML, although it can also understand the JSON format. So what does the YAML manifest for a Deployment look like?</p>&#13;
&#13;
<p>Have a look at our example for the demo application (<em>hello-k8s/k8s/deployment.yaml</em>):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cloudnatived/demo:hello</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w"/></pre>&#13;
&#13;
<p>At first glance, this looks complicated, but it’s mostly boilerplate. The only interesting parts are the same information that you’ve already seen in various forms: the container image name and port. When you gave this information to <code>kubectl create</code> earlier, it created the equivalent of this YAML manifest behind the scenes and submitted it to Kubernetes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using kubectl apply" data-type="sect2"><div class="sect2" id="idm45979389524000">&#13;
<h2>Using kubectl apply<a data-primary="YAML" data-secondary="and kubectl apply" data-secondary-sortas="kubectl apply" data-type="indexterm" id="idm45979389466352"/></h2>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="apply" data-type="indexterm" id="idm45979389464848"/><a data-primary="manifest" data-secondary="applying" data-type="indexterm" id="idm45979389463600"/>To use the full power of Kubernetes as a declarative infrastructure as code system, submit YAML manifests to the cluster yourself, using the <code>kubectl apply</code> command.</p>&#13;
&#13;
<p>Try it with our example Deployment manifest, <em>hello-k8s/k8s/deployment.yaml</em> in the <a href="https://oreil.ly/LAI8f">demo repository</a>.<sup><a data-type="noteref" href="ch04.html#idm45979389460432" id="idm45979389460432-marker">1</a></sup></p>&#13;
&#13;
<p>Run the following commands in your cloned copy of the demo repo:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">cd hello-k8s</code></strong><code class="go">&#13;
</code><strong><code class="go">kubectl apply -f k8s/deployment.yaml</code></strong><code class="go">&#13;
</code><code class="go">deployment.apps "demo" created</code></pre>&#13;
&#13;
<p>After a few seconds, a <code>demo</code> Pod should be running:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods --selector app=demo</code></strong><code class="go">&#13;
</code><code class="go">NAME                   READY   STATUS    RESTARTS   AGE&#13;
</code><code class="go">demo-c77cc8d6f-nc6fm   1/1     Running   0          13s</code></pre>&#13;
&#13;
<p>We’re not quite done, though, because in order to connect to the <code>demo</code> Pod with a web browser, we’re going to create a Service, which is a Kubernetes resource that lets you connect to your deployed Pods (more on this in a moment).</p>&#13;
&#13;
<p>First, let’s explore what a Service is, and why we need one.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Service Resources" data-type="sect2"><div class="sect2" id="services">&#13;
<h2>Service Resources</h2>&#13;
&#13;
<p><a data-primary="YAML" data-secondary="and service resources" data-secondary-sortas="service resources" data-type="indexterm" id="ix_04-objects-adoc21"/><a data-primary="Service objects" data-secondary="introduction" data-type="indexterm" id="idm45979389322752"/>Suppose you want to make a network connection to a Pod (such as our example application). How do you do that? You could find out the Pod’s IP address and connect directly to that address and the app’s port number. But the IP address may change when the Pod is restarted, so you’ll have to keep looking it up to make sure it’s up-to-date.</p>&#13;
&#13;
<p>Worse, there may be multiple replicas of the Pod, each with different addresses. Every other application that needs to contact the Pod would have to maintain a list of those addresses, which doesn’t sound like a great idea.</p>&#13;
&#13;
<p>Fortunately, there’s a better way: a <a data-primary="labels" data-secondary="Service matching" data-type="indexterm" id="idm45979389320880"/>Service resource gives you a single, unchanging IP address or DNS name that will be automatically routed to any matching Pod. Later on in <a data-type="xref" href="ch09.html#ingress">“Ingress”</a>, we will talk about the Ingress resource, which allows for more advanced routing and using TLS certificates.</p>&#13;
&#13;
<p>But for now, let’s take a closer look at how a Kubernetes Service works.</p>&#13;
&#13;
<p>You can think of a Service as being like a web proxy or a load balancer, forwarding requests to a set of <em>backend</em> Pods (<a data-type="xref" href="#img-service">Figure 4-2</a>). However, it isn’t restricted to web ports: a Service can forward traffic from any port to any other port, as detailed in the <code>ports</code> part of the spec.</p>&#13;
&#13;
<figure><div class="figure" id="img-service">&#13;
<img alt="Diagram showing a Service forwarding traffic to Pods" src="assets/cndk_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>A Service provides a persistent endpoint for a group of Pods</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-primary="Service objects" data-secondary="manifest" data-type="indexterm" id="idm45979389297360"/>Here’s the YAML manifest of the Service for our demo app:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterIP</code><code class="w"/></pre>&#13;
&#13;
<p>You can see that it looks somewhat similar to the Deployment resource we showed earlier. However, the <code>kind</code> is <code>Service</code>, instead of <code>Deployment</code>, and the <code>spec</code> just includes a list of <code>ports</code>, plus a <code>selector</code> and a <code>type</code>.</p>&#13;
&#13;
<p><a data-primary="port forwarding" data-secondary="via Service" data-type="indexterm" id="idm45979389209888"/><a data-primary="Service objects" data-secondary="port forwarding" data-type="indexterm" id="idm45979389208912"/>If you zoom in a little, you can see that the Service is forwarding its port 8888 to the Pod’s port 8888:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nn">...</code><code class="w">&#13;
</code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><strong><code class="l-Scalar-Plain">8888</code></strong><code class="w">&#13;
</code><code class="w">  </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><strong><code class="l-Scalar-Plain">8888</code></strong></pre>&#13;
&#13;
<p>The <code>selector</code> is the part that tells the Service how to route requests to particular Pods. <a data-primary="Service objects" data-secondary="matching labels" data-type="indexterm" id="idm45979389165472"/>Requests will be forwarded to any Pods matching the specified set of labels; in this case, just <code>app: demo</code> (see <a data-type="xref" href="ch09.html#labels">“Labels”</a>). In our example, there’s only one Pod that matches, but if there were multiple Pods, the Service would send each request to a randomly selected one.<sup><a data-type="noteref" href="ch04.html#idm45979389163376" id="idm45979389163376-marker">2</a></sup></p>&#13;
&#13;
<p>In this respect, a Kubernetes Service is a little like a traditional load balancer, and, in fact, both Services and Ingresses can automatically create cloud load balancers (see <a data-type="xref" href="ch09.html#ingress">“Ingress”</a>).</p>&#13;
&#13;
<p>For now, the main thing to remember is that a Deployment manages a set of Pods for your application, and a Service gives you a single entry point for requests to those Pods.</p>&#13;
&#13;
<p>Go ahead and apply the manifest now, to create the Service:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl apply -f k8s/service.yaml</code></strong><code class="go">&#13;
</code><code class="go">service "demo" created&#13;
</code><code class="go">&#13;
</code><strong><code class="go">kubectl port-forward service/demo 9999:8888</code></strong><code class="go">&#13;
</code><code class="go">Forwarding from 127.0.0.1:9999 -&gt; 8888&#13;
</code><code class="go">Forwarding from [::1]:9999 -&gt; 8888</code></pre>&#13;
&#13;
<p>As before, <code>kubectl port-forward</code> will connect the <code>demo</code> pod to a port on your local machine so that you can connect to <em>http://localhost:9999/</em> with your web browser.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="delete -f" data-type="indexterm" id="idm45979389125760"/>Once you’re satisfied that everything is working correctly, run the following command to clean up before moving on to the next section:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl delete -f k8s/</code></strong><code class="go">&#13;
</code><code class="go">deployment.apps "demo" deleted&#13;
</code><code class="go">service "demo" deleted</code></pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You can use <code>kubectl delete</code> with a label selector, as we did earlier on, to delete all resources that match the selector (see <a data-type="xref" href="ch09.html#labels">“Labels”</a>). Alternatively, you can use <code>kubectl delete -f</code>, as here, with a directory of manifests. All the resources described by the manifest files will be deleted.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45979389095744">&#13;
<h5>Exercise</h5>&#13;
<p>Modify the <em>k8s/deployment.yaml</em> file to change the number of replicas to 3. Reapply the manifest using <code>kubectl apply</code> and check that you get three <code>demo</code> Pods instead of one, using <code>kubectl get pods</code>.<a data-startref="ix_04-objects-adoc21" data-type="indexterm" id="idm45979389092624"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Querying the Cluster with kubectl" data-type="sect2"><div class="sect2" id="querykubectl">&#13;
<h2>Querying the Cluster with kubectl</h2>&#13;
&#13;
<p>The <code>kubectl</code> tool is the Swiss Army knife of Kubernetes: it applies configuration, creates, modifies, and destroys resources, and can also query the cluster for information about the resources that exist, as well as their status.</p>&#13;
&#13;
<p>We’ve already seen how to use <code>kubectl get</code> to query Pods and Deployments. You can also use it to see what nodes exist in your cluster.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="get nodes" data-type="indexterm" id="idm45979389069488"/>If you are running minikube, it should look something like this:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get nodes</code></strong><code class="go">&#13;
</code><code class="go">NAME       STATUS   ROLES                  AGE   VERSION&#13;
</code><code class="go">minikube   Ready    control-plane,master   17d   v1.21.2</code></pre>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="get all" data-type="indexterm" id="idm45979389061088"/>If you want to see resources of all types, use <code>kubectl get all</code>. (In fact, this doesn’t show literally <em>all</em> resources, just the most common types, but we won’t quibble about that for now.)</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="describe" data-type="indexterm" id="idm45979389058608"/>To see comprehensive information about an individual Pod (or any other resource), use <code>kubectl describe</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl describe pod/demo-dev-6c96484c48-69vss</code></strong><code class="go">&#13;
</code><code class="go">Name:         demo-794889fc8d-7frgb&#13;
</code><code class="go">Namespace:    default&#13;
</code><code class="go">Priority:     0&#13;
</code><code class="go">Node:         minikube/192.168.49.2&#13;
</code><code class="go">Start Time:   Mon, 02 Aug 2021 13:21:25 -0700&#13;
</code><code class="go">...&#13;
</code><code class="go">Containers:&#13;
</code><code class="go">  demo:&#13;
</code><code class="go">    Container ID:   docker://646aaf7c4baf6d...&#13;
</code><code class="go">    Image:          cloudnatived/demo:hello&#13;
</code><code class="go">...&#13;
</code><code class="go">Conditions:&#13;
</code><code class="go">  Type           Status&#13;
</code><code class="go">  Initialized    True&#13;
</code><code class="go">  Ready          True&#13;
</code><code class="go">  PodScheduled   True&#13;
</code><code class="go">...&#13;
</code><code class="go">Events:&#13;
</code><code class="go">  Type    Reason     Age   From               Message&#13;
</code><code class="go">  ----    ------     ----  ----               -------&#13;
</code><code class="go">  Normal  Scheduled  1d    default-scheduler  Successfully assigned demo-dev...&#13;
</code><code class="go">  Normal  Pulling    1d    kubelet            pulling image "cloudnatived/demo...&#13;
</code><code class="go">...</code></pre>&#13;
&#13;
<p>In the example output, you can see that <code>kubectl</code> gives you some basic information about the container itself, including its image identifier and status, along with an ordered list of events that have happened to the container. (We’ll learn a lot more about the power of <code>kubectl</code> in <a data-type="xref" href="ch07.html#powertools">Chapter 7</a>.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Taking Resources to the Next Level" data-type="sect2"><div class="sect2" id="idm45979389091504">&#13;
<h2>Taking Resources to the Next Level</h2>&#13;
&#13;
<p>You now know everything you need to know to deploy applications to Kubernetes clusters using declarative YAML manifests. But there’s a lot of repetition in these files: for example, you’ve repeated the name <code>demo</code>, the label selector <code>app: demo</code>, and the port <code>8888</code> several times.</p>&#13;
&#13;
<p>Shouldn’t you be able to just specify those values once, and then reference them wherever they occur through the Kubernetes manifests?</p>&#13;
&#13;
<p>For example, it would be great to be able to define variables called something like <code>container.name</code> and <code>container.port</code>, and then use them wherever they’re needed in the YAML files. Then, if you needed to change the name of the app or the port number it listens on, you’d only have to change them in one place, and all the manifests would be updated automatically.</p>&#13;
&#13;
<p>Fortunately, there’s a tool for that, and in the final section of this chapter we’ll show you a little of what it can do.<a data-startref="ix_04-objects-adoc2" data-type="indexterm" id="idm45979389009184"/><a data-startref="ix_04-objects-adoc20" data-type="indexterm" id="idm45979388981312"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Helm: A Kubernetes Package Manager" data-type="sect1"><div class="sect1" id="helm-intro">&#13;
<h1>Helm: A Kubernetes Package Manager</h1>&#13;
&#13;
<p><a data-primary="Helm" data-type="indexterm" id="ix_04-objects-adoc3"/>One <a data-primary="Helm" data-secondary="introduction" data-type="indexterm" id="idm45979388978320"/>popular package manager for Kubernetes is called Helm, and it works just the way we’ve described in the previous section. You can use the <code>helm</code> command-line tool to install and configure applications (your own or anyone else’s), and you can create packages called Helm <em>charts</em>, which completely specify the resources needed to run the application, its dependencies, and its configurable settings.</p>&#13;
&#13;
<p>Helm is part of the Cloud Native Computing Foundation family of projects (see <a data-type="xref" href="ch01.html#cloudnative">“Cloud Native”</a>), which reflects its stability and widespread adoption.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>It’s important to realize that a Helm chart, unlike the binary software packages used by tools like APT or Yum, doesn’t actually include the container image itself. Instead, it simply contains metadata about where the image can be found, just as a Kubernetes Deployment does.</p>&#13;
&#13;
<p>When you install the chart, Kubernetes itself will locate and download the binary container image from the place you specified. In fact, a Helm chart is really just a convenient wrapper around Kubernetes YAML manifests.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing Helm" data-type="sect2"><div class="sect2" id="idm45979388972880">&#13;
<h2>Installing Helm</h2>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="installing" data-type="indexterm" id="idm45979388971504"/>Follow the <a href="https://oreil.ly/NgSTe">Helm installation instructions</a> for your operating system.</p>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="commands" data-tertiary="version" data-type="indexterm" id="idm45979388969408"/>To verify that Helm is installed and working, run:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">helm version</code></strong><code class="go">&#13;
</code><code class="go">version.BuildInfo{Version:"v3...GoVersion:"go1.16.5"}</code></pre>&#13;
&#13;
<p>Once this command succeeds, you’re ready to start using Helm.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing a Helm Chart" data-type="sect2"><div class="sect2" id="helm-example-install">&#13;
<h2>Installing a Helm Chart</h2>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="installing and using" data-type="indexterm" id="idm45979388962208"/>What would the Helm chart for our demo application look like? In the <em>hello-helm3</em> directory, you’ll see a <em>k8s</em> subdirectory, which in the previous example (<code>hello-k8s</code>) contained just the Kubernetes manifest files to deploy the application. Now it contains a Helm chart, in the <em>demo</em> directory:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">ls k8s/demo</code></strong><code class="go">&#13;
</code><code class="go">Chart.yaml  production-values.yaml  staging-values.yaml  templates  values.yaml</code></pre>&#13;
&#13;
<p>We’ll see what all these files are for in <a data-type="xref" href="ch12.html#helmcharts">“What’s Inside a Helm Chart?”</a>, but for now, let’s use Helm to install the demo application. First, clean up the resources from any previous deployments:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl delete all --selector app=demo</code></strong></pre>&#13;
&#13;
<p>Then run the following command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">helm upgrade --install demo ./k8s/demo</code></strong><code class="go">&#13;
</code><code class="go">NAME: demo&#13;
</code><code class="go">LAST DEPLOYED: Mon Aug  2 13:37:21 2021&#13;
</code><code class="go">NAMESPACE: default&#13;
</code><code class="go">STATUS: deployed&#13;
</code><code class="go">REVISION: 1&#13;
</code><code class="go">TEST SUITE: None</code></pre>&#13;
&#13;
<p>If you use your <code>kubectl get deployment</code> and <code>kubectl get service</code> commands that you learned earlier, you will see that Helm has created a Deployment resource (which starts a Pod) and a Service, just as in the previous examples. The <code>helm upgrade --install</code> command also creates a Kubernetes Secret with a Type of <code>helm.sh/release.v1</code> to track the release.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Charts, Repositories, and Releases" data-type="sect2"><div class="sect2" id="idm45979388887168">&#13;
<h2>Charts, Repositories, and Releases</h2>&#13;
&#13;
<p>These are the three most important Helm terms you need to know:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a data-primary="Helm chart" data-secondary="definition" data-type="indexterm" id="idm45979388884832"/>A <em>chart</em> is a Helm package, containing all the resource definitions necessary to run an application in Kubernetes.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <em>repository</em> is a place where charts can be collected and shared.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <em>release</em> is a particular instance of a chart running in a Kubernetes cluster.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are some parallels with Helm resources to Docker containers:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a data-primary="Helm chart" data-secondary="repository" data-type="indexterm" id="idm45979388858528"/>A Helm <em>repository</em> is a server where charts are stored and downloaded from clients, similar to how a container registry stores and serves container images, like Docker Hub.</p>&#13;
</li>&#13;
<li>&#13;
<p><a data-primary="Helm chart" data-secondary="release" data-type="indexterm" id="idm45979388856272"/>A Helm <em>release</em> is when a chart is installed into a cluster, much like when a published Docker image is launched as a running container.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Helm charts can be downloaded and installed from repository servers, or installed directly by pointing to a local path of a directory containing the Helm YAML files on the filesystem.</p>&#13;
&#13;
<p>One chart can be installed many times into the same cluster. For example, you might be running multiple copies of the Redis chart for various applications, each serving as a backend for different websites. Each separate instance of the Helm chart is a distinct release.</p>&#13;
&#13;
<p>You may also want to centrally install something in your cluster used by all of your apps, like <a href="https://oreil.ly/Ys0Xu">Prometheus</a> for centralized monitoring, or the <a href="https://oreil.ly/ZSpg6">NGINX Ingress Controller</a> for handling incoming web requests.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Listing Helm Releases" data-type="sect2"><div class="sect2" id="idm45979388851024">&#13;
<h2>Listing Helm Releases</h2>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="commands" data-tertiary="list" data-type="indexterm" id="idm45979388849344"/><a data-primary="Helm" data-secondary="release" data-type="indexterm" id="idm45979388848096"/>To check what releases you have running at any time, run <code>helm list</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">helm list</code></strong><code class="go">&#13;
</code><code class="go">NAME  NAMESPACE REVISION  UPDATED STATUS    CHART&#13;
</code><code class="go">demo  default   1         ...     deployed  demo-1.0.1</code></pre>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="commands" data-tertiary="status" data-type="indexterm" id="idm45979388842032"/>To see the exact status of a particular release, run <code>helm status</code> followed by the name of the release. You’ll see the same information that you did when you first deployed the release.</p>&#13;
&#13;
<p>Later in the book, we’ll show you how to build your own Helm charts for your applications (see <a data-type="xref" href="ch12.html#helmcharts">“What’s Inside a Helm Chart?”</a>). For now, just know that Helm is a handy way to install applications from public charts.</p>&#13;
&#13;
<p>Many popular applications are hosted in various Helm repositories and maintained by the package providers. You can add Helm repositories and install their charts, and you can also host and publish your own Helm charts for your own applications.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You can see many examples of popular Helm charts hosted on <a href="https://artifacthub.io">Artifact Hub</a>, another CNCF project.<a data-startref="ix_04-objects-adoc3" data-type="indexterm" id="idm45979388836816"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45979388835824">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This is primarily a book about using Kubernetes, not diving deep into the details of how Kubernetes works. Our aim is to show you what Kubernetes can <em>do</em>, and bring you quickly to the point where you can run real workloads in production. However, it’s useful to know at least some of the main pieces of machinery you’ll be working with, such as Pods and Deployments. In this chapter, we’ve briefly introduced some of the most important ones. We also recommend <a href="https://oreil.ly/Fxs6E"><em>Managing Kubernetes</em></a>, <a href="https://oreil.ly/ZsROQ"><em>Production Kubernetes</em></a>, and the <a href="https://oreil.ly/Chk5v"><em>Kubernetes the Hard Way</em> repo</a> for those looking to get more familiar with what is going on under the hood.</p>&#13;
&#13;
<p>As fascinating as the technology is to geeks like us, we’re also interested in getting stuff done. Therefore, we haven’t exhaustively covered every kind of resource <span class="keep-together">Kubernetes</span> provides, because there are a <em>lot</em>, and many of them you almost certainly won’t need (at least, not yet).</p>&#13;
&#13;
<p class="less_space pagebreak-before">The key points we think you need to know right now are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The Pod is the fundamental unit of work in Kubernetes, specifying a single container or group of communicating containers that are scheduled together.</p>&#13;
</li>&#13;
<li>&#13;
<p>A Deployment is a high-level Kubernetes resource that declaratively manages Pods, deploying, scheduling, updating, and restarting them when necessary.</p>&#13;
</li>&#13;
<li>&#13;
<p>A Service is the Kubernetes equivalent of a load balancer or proxy, routing traffic to its matching Pods via a single, well-known, durable IP address or DNS name.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Kubernetes scheduler watches for a Pod that isn’t yet running on any node, finds a suitable node for it, and instructs the kubelet on that node to run the Pod.</p>&#13;
</li>&#13;
<li>&#13;
<p>Resources like Deployments are represented by records in Kubernetes’s internal database. Externally, these resources can be represented by text files (known as <em>manifests</em>) in YAML format. The manifest is a declaration of the desired state of the resource.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>kubectl</code> is the main tool for interacting with Kubernetes, allowing you to apply manifests, query resources, make changes, delete resources, and do many other tasks.</p>&#13;
</li>&#13;
<li>&#13;
<p>Helm is a Kubernetes package manager. It simplifies configuring and deploying Kubernetes applications, allowing you to use a single set of bundled manifests and templates used to generate parameterized Kubernetes YAML files, instead of having to maintain the raw YAML files yourself.<a data-startref="ix_04-objects-adoc0" data-type="indexterm" id="idm45979388801840"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45979389460432"><sup><a href="ch04.html#idm45979389460432-marker">1</a></sup> <em>k8s</em>, pronounced <em>kates</em>, is a common abbreviation for <em>Kubernetes</em>, following the geeky pattern of abbreviating words as a <em>numeronym</em>: their first and last letters, plus the number of letters in between (<em>k-8-s</em>). See also <em>i18n</em> (internationalization), <em>a11y</em> (accessibility), and <em>o11y</em> (observability).</p><p data-type="footnote" id="idm45979389163376"><sup><a href="ch04.html#idm45979389163376-marker">2</a></sup> This is the default load-balancing algorithm; Kubernetes versions 1.10+ support other algorithms too, such as <em>least connection</em>. See the <a href="https://oreil.ly/YZDrx">Kubernetes documentation</a> for more.</p></div></div></section></body></html>