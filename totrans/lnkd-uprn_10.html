<html><head></head><body><section data-pdf-bookmark="Chapter 10. Observing Your Platform with Linkerd" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="LUAR_observability">
<h1 class="calibre7"><span class="calibre">Chapter 10. </span>Observing Your Platform with Linkerd</h1>


<p class="author1">One of the challenges of working<a data-primary="observability" data-secondary="about" data-type="indexterm" id="id1369" class="calibre4"/><a data-primary="microservices architecture" data-secondary="observability" data-type="indexterm" id="id1370" class="calibre4"/><a data-primary="booksapp application" data-secondary="observability" data-tertiary="about" data-type="indexterm" id="ch10-kaapab" class="calibre4"/><a data-primary="emojivoto application" data-secondary="observability" data-tertiary="about" data-type="indexterm" id="ch10-kaapab2" class="calibre4"/> with microservices applications is monitoring
them. When dealing with multiple development teams, even in a single language,
understanding which workloads are communicating and surfacing useful metrics from those communications can be a huge challenge. Every developer,
language, and framework will prioritize different details, and organizations
need a single way to view all those different services.</p>

<p class="author1"><em class="hyperlink">Observability</em> refers to this ability<a data-primary="observability" data-secondary="Linkerd for" data-tertiary="about" data-type="indexterm" id="ch10-L4" class="calibre4"/> to understand a system by looking at it
from the outside. An application can be more or less observable, so when we
talk about observability in Linkerd we’re referring to how it impacts the
observability of your applications. In this chapter, we’ll look at how Linkerd
increases observability by providing all your apps with standard metrics,
allowing you to see the relationships between your microservices, and allowing
you to intercept and analyze interapp communications.</p>






<section data-pdf-bookmark="Why Do We Need This?" data-type="sect1" class="preface"><div class="preface" id="id213">
<h1 class="calibre8">Why Do We Need This?</h1>

<p class="author1">As with application security, microservices<a data-primary="observability" data-secondary="about" data-tertiary="why needed" data-type="indexterm" id="id1371" class="calibre4"/> present new challenges for
platform engineers. The ability to dynamically scale components, create and
update services on demand, and dynamically provision infrastructure increases
the difficulty of understanding the health of our applications. As your
organization builds out your platform for application developers, it’s
important that you make it easy for teams to do the right thing.</p>
</div></section>






<section data-pdf-bookmark="How Does Linkerd Help?" data-type="sect1" class="preface"><div class="preface" id="id79">
<h1 class="calibre8">How Does Linkerd Help?</h1>

<p class="author1">Linkerd helps make observability part of your platform. When you add a
workload to the mesh, it begins to automatically surface important information
about that workload’s behavior. That means that when we add Linkerd to
our platform, we make it easy for all our application teams to do the right
thing in terms of observability. If you allow your application to join the
mesh, you can automatically surface performance, health, and relationship data
about your app in a standard way. If you go deeper and build service profiles,
you can save and share critical information about the individual routes
within your apps.</p>

<p class="author1">As we go through this chapter, we’ll explore how to observe your applications
with Linkerd using the <code class="calibre9">linkerd</code> CLI. Everything we cover via the CLI can also
be surfaced via the Linkerd Viz dashboard. We’ll cover the dashboard near the
end of this chapter.</p>

<p class="author1">As we mentioned in <a data-type="xref" href="ch01.html#LUAR_service_mesh_101" class="calibre4">Chapter 1</a>, there are three golden metrics
that have repeatedly proven critical for understanding what’s going on in a
microservices application: traffic, success rate, and latency (see <a data-type="xref" href="ch01.html#golden-metrics" class="calibre4">Figure 1-8</a>).</p>

<p class="author1">In a microservices application, having these metrics available for every
workload is critical: with just these golden metrics, you should be able to
understand how well a given workload is performing as well as what areas of
your system need special attention or optimization.</p>

<p class="author1">The Linkerd proxy automatically collects detailed metrics from every
workload and request and makes them available via Prometheus, so that you
can surface this information within your organization using a variety of widely available
tools.<a data-startref="ch10-L4" data-type="indexterm" id="id1372" class="calibre4"/></p>
</div></section>






<section data-pdf-bookmark="Observability in Linkerd" data-type="sect1" class="preface"><div class="preface" id="id80">
<h1 class="calibre8">Observability in Linkerd</h1>

<p class="author1">We’ll use the booksapp and emojivoto applications to demonstrate
observability in Linkerd. Both of these applications deliberately include
various failures: we’ll use Linkerd observability tools to find where,
exactly, the failures are. (Fixing them is left as an exercise for the
reader!)<a data-startref="ch10-kaapab" data-type="indexterm" id="id1373" class="calibre4"/><a data-startref="ch10-kaapab2" data-type="indexterm" id="id1374" class="calibre4"/></p>








<section data-pdf-bookmark="Setting Up Your Cluster" data-type="sect2" class="preface"><div class="preface" id="id214">
<h2 class="calibre27">Setting Up Your Cluster</h2>

<p class="author1">You’ll need a cluster with Linkerd<a data-primary="observability" data-secondary="Linkerd for" data-tertiary="setting up your cluster" data-type="indexterm" id="id1375" class="calibre4"/><a data-primary="emojivoto application" data-secondary="observability" data-tertiary="setting up your cluster" data-type="indexterm" id="id1376" class="calibre4"/><a data-primary="booksapp application" data-secondary="observability" data-tertiary="setting up your cluster" data-type="indexterm" id="id1377" class="calibre4"/> and Linkerd Viz already installed (please
refer to <a data-type="xref" href="ch03.html#LUAR_deploying_linkerd" class="calibre4">Chapter 3</a> if you want a refresher on setting up such
a cluster). <a data-primary="emojivoto application" data-secondary="observability" data-tertiary="cloning emojivoto repository" data-type="indexterm" id="id1378" class="calibre4"/><a data-primary="booksapp application" data-secondary="observability" data-tertiary="cloning booksapp repository" data-type="indexterm" id="id1379" class="calibre4"/><a data-primary="observability" data-secondary="Linkerd for" data-tertiary="cloning the applications" data-type="indexterm" id="id1380" class="calibre4"/>We’ll start by cloning the
<a href="https://oreil.ly/LJou0" class="calibre4">booksapp sample application</a>
and <a href="https://oreil.ly/0n5Gd" class="calibre4">emojivoto sample application</a>
repositories, as shown in <a data-type="xref" href="#EX12-clone" class="calibre4">Example 10-1</a>, since we’ll need the repositories to
appropriately profile these sample applications.</p>
<div data-type="example" id="EX12-clone" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 10-1. </span>Cloning the repos</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Clone the booksapp repo</code>
$<code class="w"> </code>git<code class="w"> </code>clone<code class="w"> </code>https://github.com/BuoyantIO/booksapp.git<code class="w"/>

<code class="c"># Clone the emojivoto repo</code>
$<code class="w"> </code>git<code class="w"> </code>clone<code class="w"> </code>https://github.com/BuoyantIO/emojivoto.git<code class="w"/></pre></div>

<p class="author1">Next, we can get the applications up and running in our cluster, as shown in

<span class="calibre"><a data-type="xref" href="#EX12-install-apps" class="calibre4">Example 10-2</a>.</span></p>
<div data-type="example" id="EX12-install-apps" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 10-2. </span>Setting up our apps</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Install booksapp</code>
$<code class="w"> </code>kubectl<code class="w"> </code>create<code class="w"> </code>ns<code class="w"> </code>booksapp<code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="se">\</code>
<code class="w">  </code>curl<code class="w"> </code>--proto<code class="w"> </code><code class="s">'=https'</code><code class="w"> </code>--tlsv1.2<code class="w"> </code>-sSfL<code class="w"> </code>https://run.linkerd.io/booksapp.yml<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>linkerd<code class="w"> </code>inject<code class="w"> </code>-<code class="w"> </code><code class="p">|</code><code class="w"> </code>kubectl<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

<code class="c"># Install emojivoto</code>
$<code class="w"> </code>curl<code class="w"> </code>--proto<code class="w"> </code><code class="s">'=https'</code><code class="w"> </code>--tlsv1.2<code class="w"> </code>-sSfL<code class="w"> </code>https://run.linkerd.io/emojivoto.yml<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>linkerd<code class="w"> </code>inject<code class="w"> </code>-<code class="w"> </code><code class="p">|</code><code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

<code class="c"># Check that booksapp is ready</code>
$<code class="w"> </code>linkerd<code class="w"> </code>check<code class="w"> </code>--proxy<code class="w"> </code>--namespace<code class="w"> </code>booksapp<code class="w"/>

<code class="c"># Check that emojivoto is ready</code>
$<code class="w"> </code>linkerd<code class="w"> </code>check<code class="w"> </code>--proxy<code class="w"> </code>--namespace<code class="w"> </code>emojivoto<code class="w"/></pre></div>

<p class="author1">Once our check returns healthy,<a data-primary="observability" data-secondary="Linkerd for" data-tertiary="gathering application metrics" data-type="indexterm" id="id1381" class="calibre4"/><a data-primary="emojivoto application" data-secondary="observability" data-tertiary="gathering application metrics" data-type="indexterm" id="id1382" class="calibre4"/><a data-primary="booksapp application" data-secondary="observability" data-tertiary="gathering application metrics" data-type="indexterm" id="id1383" class="calibre4"/> we can start looking at our applications using
the <code class="calibre9">linkerd viz</code> command, as shown in <a data-type="xref" href="#EX12-linkerd-viz-basics" class="calibre4">Example 10-3</a>. Note that it
may take a minute or so for Linkerd Viz to start showing any data, since it
has to start by collecting enough data to generate statistics.</p>
<div data-type="example" id="EX12-linkerd-viz-basics" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 10-3. </span>Gathering application metrics</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># View namespace metrics</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>ns<code class="w"/>

<code class="c"># View deployment metrics</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"/>

<code class="c"># View Pod metrics</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>pod<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>pod<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"/></pre></div>

<p class="author1">You can immediately see just from these basic queries that the emojivoto
and book⁠sapp applications are both having reliability issues. In the following
sections, we’ll dive deeper into our applications to isolate the source of the
problem.</p>
</div></section>








<section data-pdf-bookmark="Tap" data-type="sect2" class="preface"><div class="preface" id="id160">
<h2 class="calibre27">Tap</h2>

<p class="author1">Linkerd Viz Tap allows authorized<a data-primary="Linkerd Viz extension" data-secondary="Tap component" data-type="indexterm" id="id1384" class="calibre4"/><a data-primary="Tap component of Linkerd Viz extension" data-secondary="observability in Linkerd" data-type="indexterm" id="id1385" class="calibre4"/><a data-primary="metadata via Tap of Linkerd Viz" data-secondary="observability in Linkerd" data-type="indexterm" id="id1386" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="Tap component" data-tertiary="observability in Linkerd" data-type="indexterm" id="id1387" class="calibre4"/><a data-primary="observability" data-secondary="Linkerd for" data-tertiary="Tap component of Linkerd Viz" data-type="indexterm" id="id1388" class="calibre4"/> users to collect metadata about the requests
flowing between your applications. It will surface details about request
headers, URIs, response codes, and more, permitting you to access this data
on demand for 
<span class="calibre">debugging,</span> as shown in <a data-type="xref" href="#EX12-basic-tap-command" class="calibre4">Example 10-4</a>. <a data-primary="TLS (Transport Layer Security)" data-secondary="Tap validating status" data-type="indexterm" id="id1389" class="calibre4"/><a data-primary="Tap component of Linkerd Viz extension" data-secondary="TLS status validation" data-type="indexterm" id="id1390" class="calibre4"/>Tap also
provides convenient tooling for validating the TLS status of your interapp connections.</p>
<div data-type="example" id="EX12-basic-tap-command" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 10-4. </span>Viewing Tap data</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Tap the emojivoto web frontend</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>tap<code class="w"> </code>deploy/web<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/></pre></div>

<p class="author1">The <code class="calibre9">linkerd viz tap</code> command will run until you send it the break signal. It displays
live data from the proxy, which will give details about the individual requests
that go to and from the web deployment. Each line will show the source and
destination details, TLS status, any status information, and other metadata as
available.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Installing Tap</h1>
<p class="author1">Tap is built into the Linkerd Viz extension,<a data-primary="Tap component of Linkerd Viz extension" data-secondary="installing" data-type="indexterm" id="id1391" class="calibre4"/> so it will be automatically
installed by the <code class="calibre9">linkerd viz install</code> command. However, if any of your
workloads were running before you installed Viz, you’ll need to restart those
workloads before Tap will be available.</p>
</div>

<p class="author1">Tap data is a powerful diagnostic tool that can provide insights into how
exactly your apps are communicating with one another. If Tap is enabled when
you view a workload in the Linkerd Viz dashboard, it will automatically
display a summary of requests. Be sure to try to
view the Tap data for emojivoto’s workloads when you look at the Viz
dashboard later in this chapter.</p>
</div></section>








<section data-pdf-bookmark="Service Profiles" data-type="sect2" class="preface"><div class="preface" id="id81">
<h2 class="calibre27">Service Profiles</h2>

<p class="author1">Linkerd <em class="hyperlink">service profiles</em>, embodied<a data-primary="ServiceProfile resources" data-secondary="service profiles" data-type="indexterm" id="id1392" class="calibre4"/><a data-primary="ServiceProfile resources" data-type="indexterm" id="id1393" class="calibre4"/><a data-primary="observability" data-secondary="Linkerd for" data-tertiary="ServiceProfile resources" data-type="indexterm" id="id1394" class="calibre4"/><a data-primary="observability" data-secondary="Linkerd for" data-tertiary="service profiles" data-type="indexterm" id="id1395" class="calibre4"/> by the ServiceProfile resource, allow you
to give the mesh detailed information about how a given workload is used. At
its most basic level, a ServiceProfile defines what routes are allowed for a
workload. Once routes are defined, you can configure per-route metrics,
timeouts, and retries, as well as which HTTP statuses will be considered failures.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">ServiceProfile and HTTPRoute</h1>
<p class="author1">The Linkerd project is in the midst of a <a data-primary="Gateway API" data-secondary="Linkerd project toward fully adopting" data-type="indexterm" id="id1396" class="calibre4"/><a data-primary="ServiceProfile resources" data-secondary="deprecation beginning" data-type="indexterm" id="id1397" class="calibre4"/><a data-primary="Linkerd" data-secondary="Gateway API full adoption" data-type="indexterm" id="id1398" class="calibre4"/><a data-primary="APIs" data-secondary="Gateway API" data-tertiary="Linkerd project toward fully adopting" data-type="indexterm" id="id1399" class="calibre4"/>transition to fully adopting
<a href="https://oreil.ly/Onjs9" class="calibre4">Gateway API</a>. As the project works toward
that objective, you’ll see a few Linkerd custom resources, including
ServiceProfile, begin to be deprecated.</p>

<p class="author1">In Linkerd 2.13 and 2.14, ServiceProfile and HTTPRoute often have mutually
exclusive functionality, <a data-primary="ServiceProfile resources" data-secondary="documentation URL" data-type="indexterm" id="id1400" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="ServiceProfile resources" data-type="indexterm" id="id1401" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="ServiceProfile resources" data-type="indexterm" id="id1402" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="ServiceProfile resources" data-type="indexterm" id="id1403" class="calibre4"/>which makes it particularly important to review the
<a href="https://oreil.ly/zJk_j" class="calibre4">ServiceProfile documentation</a>
to verify the current state of ServiceProfile as you begin using these resources in
your cluster.</p>
</div>

<p class="author1">You can build out ServiceProfiles<a data-primary="ServiceProfile resources" data-secondary="building" data-type="indexterm" id="id1404" class="calibre4"/> in a number of ways. The most flexible way
is to write them by hand, but the Linkerd CLI provides a few
different ways to generate them automatically, as you’ll see in the following sections.</p>










<section data-pdf-bookmark="Configuring routes for emojivoto" data-type="sect3" class="preface"><div class="preface" id="id161">
<h3 class="calibre33">Configuring routes for emojivoto</h3>

<p class="author1">The emojivoto application has three workloads:<a data-primary="ServiceProfile resources" data-secondary="building" data-tertiary="emojivoto protobuf files for" data-type="indexterm" id="id1405" class="calibre4"/><a data-primary="emojivoto application" data-secondary="observability" data-tertiary="ServiceProfiles built with emojivoto" data-type="indexterm" id="id1406" class="calibre4"/><a data-primary="observability" data-secondary="Linkerd for" data-tertiary="ServiceProfiles built via emojivoto" data-type="indexterm" id="id1407" class="calibre4"/></p>

<ul class="printings">
<li class="calibre6">
<p class="author1">The <code class="calibre9">emoji</code> and <code class="calibre9">voting</code> workloads use gRPC for communication, with their
gRPC messages defined in protobuf files.</p>
</li>
<li class="calibre6">
<p class="author1">The <code class="calibre9">web</code> workload uses HTTP to interact with a web browser.</p>
</li>
</ul>

<p class="author1">We’ll start with <code class="calibre9">emoji</code> and <code class="calibre9">voting</code>, since they have <em class="hyperlink">protobuf</em> files.
Protobuf files work as a guide to our APIs, and they can be consumed by the
Linkerd CLI to automatically create ServiceProfiles, as shown in
<a data-type="xref" href="#EX12-protobuf-to-serviceprofile" class="calibre4">Example 10-5</a>.<a data-primary="Linkerd Viz extension" data-secondary="routes" data-tertiary="ServiceProfile creation code" data-type="indexterm" id="id1408" class="calibre4"/></p>
<div data-type="example" id="EX12-protobuf-to-serviceprofile" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 10-5. </span>Creating ServiceProfiles from protobuf files</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Begin by checking for any existing routes.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>routes<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>deploy<code class="w"/>

<code class="c"># The output will show every workload in the emojivoto</code>
<code class="c"># namespace with a default route. We will now work to</code>
<code class="c"># create application-specific routes for emoji and</code>
<code class="c"># voting.</code>

<code class="c"># Create a ServiceProfile object.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>profile<code class="w"> </code>--proto<code class="w"> </code>emojivoto/proto/Emoji.proto<code class="w"> </code>emoji-svc<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/>

<code class="c"># This creates, but doesn't apply, the ServiceProfile</code>
<code class="c"># for the emoji service. Take a minute to review the</code>
<code class="c"># profile object so you understand the basic structure.</code>
<code class="c"># We'll be using these ServiceProfiles again in the</code>
<code class="c"># next chapter.</code>

<code class="c"># Create and apply ServiceProfiles for emoji and voting.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>profile<code class="w"> </code>--proto<code class="w"> </code>emojivoto/proto/Emoji.proto<code class="w"> </code>emoji-svc<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>profile<code class="w"> </code>--proto<code class="w"> </code>emojivoto/proto/Voting.proto<code class="w"> </code>voting-svc<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

<code class="c"># Now you can view the updated route data in your environment to see</code>
<code class="c"># your deployed applications. You may need to wait a minute</code>
<code class="c"># for data to populate.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>routes<code class="w"> </code>deploy/emoji<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>routes<code class="w"> </code>deploy/voting<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/>

<code class="c"># Each app will show and store details about which routes have</code>
<code class="c"># been accessed.</code></pre></div>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Storing Linkerd Viz Metrics</h1>
<p class="author1">Once you’ve created ServiceProfiles for your applications,<a data-primary="Linkerd Viz extension" data-secondary="Prometheus instance" data-tertiary="persistent storage needed for production" data-type="indexterm" id="id1409" class="calibre4"/><a data-primary="Prometheus" data-secondary="persistent storage needed for production" data-type="indexterm" id="id1410" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="Tap component" data-tertiary="data stored in Prometheus" data-type="indexterm" id="id1411" class="calibre4"/><a data-primary="Tap component of Linkerd Viz extension" data-secondary="observability in Linkerd" data-tertiary="data stored in Prometheus" data-type="indexterm" id="id1412" class="calibre4"/><a data-primary="observability" data-secondary="Linkerd for" data-tertiary="storing Linkerd Viz metrics" data-type="indexterm" id="id1413" class="calibre4"/> Linkerd’s Viz
extension will store that data in Prometheus. <a data-primary="Linkerd Viz extension" data-secondary="Prometheus instance" data-tertiary="not for production" data-type="indexterm" id="id1414" class="calibre4"/><a data-primary="production" data-secondary="Prometheus instance of Linkerd Viz" data-type="indexterm" id="id1415" class="calibre4"/><a data-primary="Prometheus" data-secondary="instance with Linkerd Viz extension" data-tertiary="not for production" data-type="indexterm" id="id1416" class="calibre4"/>A very important part of taking
Linkerd to production is planning how you’ll manage this Prometheus data in
the long term. The Prometheus component that ships with Linkerd Viz is <em class="hyperlink">not</em>
sufficient for long-term data collection: it stores data in memory, and it
<em class="hyperlink">will</em> lose data every time it restarts.</p>
</div>

<p class="author1">With our routes created for <code class="calibre9">emoji</code> and <code class="calibre9">voting</code>, we have two-thirds of our
application covered with ServiceProfiles. That leaves the <code class="calibre9">web</code> component.
Although we know this must speak HTTP because we talk to it
with a browser, unfortunately the authors of this component didn’t actually write any API
documentation for it at all. <a data-primary="ServiceProfile resources" data-secondary="building" data-tertiary="Linkerd Viz Tap for" data-type="indexterm" id="id1417" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="Tap component" data-tertiary="ServiceProfile built from" data-type="indexterm" id="id1418" class="calibre4"/><a data-primary="Tap component of Linkerd Viz extension" data-secondary="observability in Linkerd" data-tertiary="ServiceProfile built with Tap" data-type="indexterm" id="id1419" class="calibre4"/><a data-primary="observability" data-secondary="Linkerd for" data-tertiary="Tap component of Linkerd Viz" data-type="indexterm" id="id1420" class="calibre4"/>This leaves us to figure out how to build
a ServiceProfile with no information about how the API is structured.</p>

<p class="author1">Thankfully, we can use Linkerd’s Tap functionality to do just that, as shown
in <a data-type="xref" href="#EX12-tap-serviceprofiles" class="calibre4">Example 10-6</a>.<a data-primary="Linkerd Viz extension" data-secondary="routes" data-tertiary="ServiceProfile creation code" data-type="indexterm" id="id1421" class="calibre4"/></p>
<div data-type="example" id="EX12-tap-serviceprofiles" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 10-6. </span>Creating ServiceProfiles with Tap</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Create a new ServiceProfile with Tap.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>profile<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>web-svc<code class="w"> </code>--tap<code class="w"> </code>deploy/web<code class="w"> </code>--tap-duration<code class="w"> </code>10s<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

<code class="c"># After you run that command, you should expect to see a</code>
<code class="c"># 10-second pause as Linkerd watches live traffic to the</code>
<code class="c"># service in question and builds a profile.</code>

<code class="c"># View the new profile.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>serviceprofile<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>web-svc.emojivoto.svc.cluster.local<code class="w"> </code>-o<code class="w"> </code>yaml<code class="w"/>

<code class="c"># You will see the object created with two routes, list and vote.</code>

<code class="c"># View the updated route data for web. You may need to allow a minute</code>
<code class="c"># for data to populate.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>routes<code class="w"> </code>deploy/web<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"/></pre></div>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Linkerd Default Routes</h1>
<p class="author1">Linkerd’s ServiceProfile objects are<a data-primary="ServiceProfile resources" data-secondary="default routes" data-type="indexterm" id="id1422" class="calibre4"/><a data-primary="observability" data-secondary="Linkerd for" data-tertiary="ServiceProfile default routes" data-type="indexterm" id="id1423" class="calibre4"/> intended to define an entire API, but
what happens when we make a mistake, or when an API changes without the
profiles being updated? That’s where the default route comes in: any route
that isn’t explicitly defined in a ServiceProfile is treated as a default
route.</p>

<p class="author1">Default routes are subject to default policies regarding retries and timeouts.
Data about traffic on default routes is aggregated into the catchall
<code class="calibre9">[DEFAULT]</code> route entry.</p>
</div>
</div></section>










<section data-pdf-bookmark="Building routes for booksapp" data-type="sect3" class="preface"><div class="preface" id="id215">
<h3 class="calibre33">Building routes for booksapp</h3>

<p class="author1">Now that we’re finished with the<a data-primary="observability" data-secondary="Linkerd for" data-tertiary="ServiceProfiles built via booksapp" data-type="indexterm" id="id1424" class="calibre4"/><a data-primary="booksapp application" data-secondary="observability" data-tertiary="ServiceProfiles built with booksapp" data-type="indexterm" id="id1425" class="calibre4"/> emojivoto application, we need to set
things up for the booksapp application.</p>

<p class="author1">Whereas emojivoto included protobuf files for some of its APIs, booksapp ships
with OpenAPI definitions instead. Like protobuf files, OpenAPI definitions
(often called “Swagger definitions,” after an earlier version of the standard)
serve as definitions of how to use the API, and Linkerd knows how to read
them to create ServiceProfiles.</p>

<p class="author1">Creating a ServiceProfile with an OpenAPI or Swagger definition is almost
exactly like creating a ServiceProfile from a protobuf file, as shown in
<a data-type="xref" href="#EX12-openapi-to-serviceprofile" class="calibre4">Example 10-7</a>. Please be sure to follow along, as we’ll
be using these ServiceProfiles again in <a data-type="xref" href="ch11.html#LUAR_reliability" class="calibre4">Chapter 11</a>!<a data-primary="Linkerd Viz extension" data-secondary="routes" data-tertiary="ServiceProfile creation code" data-type="indexterm" id="id1426" class="calibre4"/></p>
<div data-type="example" id="EX12-openapi-to-serviceprofile" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 10-7. </span>Creating ServiceProfiles with OpenAPI definitions</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Create routes for booksapp.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>profile<code class="w"> </code>--open-api<code class="w"> </code>booksapp/swagger/authors.swagger<code class="w"> </code>authors<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>profile<code class="w"> </code>--open-api<code class="w"> </code>booksapp/swagger/webapp.swagger<code class="w"> </code>webapp<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>profile<code class="w"> </code>--open-api<code class="w"> </code>booksapp/swagger/books.swagger<code class="w"> </code>books<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

<code class="c"># With that, we've profiled our applications. We can now wait a minute</code>
<code class="c"># and view the relevant route information.</code>

<code class="c"># View route data for booksapp.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>routes<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"/>

<code class="c"># You should see a number of routes with varying success rates.</code>
<code class="c"># In Chapter 11 we'll use some of Linkerd's reliability</code>
<code class="c"># features to help address the issues booksapp is having.</code></pre></div>
</div></section>
</div></section>








<section data-pdf-bookmark="Topology" data-type="sect2" class="preface"><div class="preface" id="id162">
<h2 class="calibre27">Topology</h2>

<p class="author1">With routes, metrics, and Tap data,<a data-primary="observability" data-secondary="Linkerd for" data-tertiary="viewing edges" data-type="indexterm" id="id1427" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="edges command" data-type="indexterm" id="id1428" class="calibre4"/> we have a lot of useful ways to understand
what our apps are doing without requiring developers to include
instrumentation in their applications. Another common challenge is figuring
out which of all these possible calls are actually happening in the
application, and from which workload to which workload. Linkerd can also
surface that information for you.</p>

<p class="author1">In <a data-type="xref" href="#EX12-viewing-edges" class="calibre4">Example 10-8</a>, we’ll examine the relationships between the
components of the booksapp application. You can, and should, try to explore
emojivoto on your own.</p>
<div data-type="example" id="EX12-viewing-edges" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 10-8. </span>Viewing edges in Linkerd</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Start by getting the deployments in the booksapp namespace.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"/>

<code class="c"># You'll see four deployments: traffic, webapp, authors, and books.</code>

<code class="c"># Now, dig into the relationship between these components with</code>
<code class="c"># the linkerd viz edges command.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>edges<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"/></pre></div>

<p class="author1">The output is broken up into five columns:</p>
<dl class="calibre10">
<dt class="calibre11"><code class="calibre14">SRC</code></dt>
<dd class="calibre12">
<p class="calibre13">The source of the traffic</p>
</dd>
<dt class="calibre11"><code class="calibre14">DST</code></dt>
<dd class="calibre12">
<p class="calibre13">The destination of the traffic</p>
</dd>
<dt class="calibre11"><code class="calibre14">SRC_NS</code></dt>
<dd class="calibre12">
<p class="calibre13">The namespace where the traffic originated</p>
</dd>
<dt class="calibre11"><code class="calibre14">DST_NS</code></dt>
<dd class="calibre12">
<p class="calibre13">The namespace where the traffic went</p>
</dd>
<dt class="calibre11"><code class="calibre14">SECURED</code></dt>
<dd class="calibre12">
<p class="calibre13">Whether or not the traffic is encrypted via Linkerd’s mTLS</p>
</dd>
</dl>

<p class="author1">The resulting output gives you an overview of the relationships between the
book⁠sapp components. It shows that the Prometheus instance in the
<code class="calibre9">linkerd-viz</code> namespace is talking to each deployment in the <code class="calibre9">booksapp</code>
namespace. Beyond that, we can see that <code class="calibre9">traffic</code> talks to <code class="calibre9">webapp</code>, <code class="calibre9">webapp</code>
talks to <code class="calibre9">books</code> and <code class="calibre9">authors</code>, and <code class="calibre9">books</code> and <code class="calibre9">authors</code> talk to each other.</p>

<p class="author1">The <code class="calibre9">linkerd viz edges</code> command will work for Pods or any other workload type
within Kubernetes.</p>
</div></section>
</div></section>






<section data-pdf-bookmark="Linkerd Viz" data-type="sect1" class="preface"><div class="preface" id="id163">
<h1 class="calibre8">Linkerd Viz</h1>

<p class="author1">You’ve likely noticed that a number<a data-primary="observability" data-secondary="Linkerd Viz dashboard" data-type="indexterm" id="id1429" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="observability" data-type="indexterm" id="id1430" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="about" data-type="indexterm" id="id1431" class="calibre4"/> of the commands we used in this chapter
were <code class="calibre9">linkerd viz</code> commands. This is the Linkerd Viz extension that we
introduced back in <a data-type="xref" href="ch02.html#LUAR_intro_to_linkerd" class="calibre4">Chapter 2</a>. It ships with the core
Linkerd system because it’s often extremely useful, but it was split out from
the core into an extension in Linkerd 2.10, so that not everyone is forced to
run it.</p>

<p class="author1">The Viz extension provides a great many CLI tools for observing your Linkerd
installation, along with a web-based dashboard that provides a graphical interface
for exploring your Linkerd environment.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Protecting the Viz Dashboard Is Up to You</h1>
<p class="author1">As described in <a data-type="xref" href="ch02.html#LUAR_intro_to_linkerd" class="calibre4">Chapter 2</a>, there’s <a data-primary="Linkerd Viz extension" data-secondary="dashboard unauthenticated" data-type="indexterm" id="id1432" class="calibre4"/><a data-primary="authentication" data-secondary="Linkerd Viz dashboard unauthenticated" data-type="indexterm" id="id1433" class="calibre4"/><a data-primary="dashboards" data-secondary="Linkerd Viz extension" data-tertiary="unauthenticated" data-type="indexterm" id="id1434" class="calibre4"/>no user authentication
built into the Linkerd Viz dashboard. You’ll need to tackle that using an API
gateway or the like if you want to expose Linkerd Viz to the network—or,
alternatively, leave the dashboard inaccessible from outside the cluster, and
simply use the <code class="calibre9">linkerd viz dashboard</code> CLI command to bring up the dashboard
in a web browser, via a port forward.</p>
</div>

<p class="author1">Use the following command to open the Viz dashboard:</p>

<pre data-type="programlisting" class="calibre36">$ linkerd viz dashboard</pre>

<p class="author1">Now explore it on your own. Try to find the per-namespace and per-workload metrics.
Also take a look at an individual namespace, like <code class="calibre9">emojivoto</code>, and explore the topology.</p>

<p class="author1">Linkerd’s Viz dashboard includes Prometheus and can easily work with Grafana, as shown in <a data-type="xref" href="#EX12-production-prometheus" class="calibre4">Example 10-9</a>.
As we’ve said a few times before,<a data-primary="Linkerd Viz extension" data-secondary="Prometheus instance" data-tertiary="not for production" data-type="indexterm" id="id1435" class="calibre4"/><a data-primary="production" data-secondary="Prometheus instance of Linkerd Viz" data-type="indexterm" id="id1436" class="calibre4"/><a data-primary="Prometheus" data-secondary="instance with Linkerd Viz extension" data-tertiary="not for production" data-type="indexterm" id="id1437" class="calibre4"/> it’s <em class="hyperlink">critical</em> to realize that the default
Linkerd Viz install will create an in-memory Prometheus instance that is
<em class="hyperlink">only</em> viable for demo purposes, and <em class="hyperlink">must not</em> be relied upon for production
use. We recommend you use a separate Prometheus instance for collecting your
Linkerd metrics.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Linkerd and Grafana</h1>
<p class="author1">In earlier versions of Linkerd, <code class="calibre9">linkerd viz install</code> automatically installed<a data-primary="Linkerd Viz extension" data-secondary="Grafana dashboards" data-tertiary="installation" data-type="indexterm" id="id1438" class="calibre4"/><a data-primary="dashboards" data-secondary="Grafana dashboards" data-tertiary="installation" data-type="indexterm" id="id1439" class="calibre4"/><a data-primary="Grafana dashboards" data-secondary="installation" data-type="indexterm" id="id1440" class="calibre4"/><a data-primary="production" data-secondary="Linkerd Viz production-ready install" data-type="indexterm" id="id1441" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="production-ready install" data-type="indexterm" id="id1442" class="calibre4"/>
Grafana. As of Linkerd 2.12, Grafana licensing changes mean that we’re no
longer allowed to do that. Grafana still works beautifully with Linkerd Viz,
but for Linkerd 2.12 and later you need to install it by hand and configure it to talk to the same
Prometheus that Linkerd Viz uses.</p>
</div>
<div data-type="example" id="EX12-production-prometheus" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 10-9. </span>Production-ready Linkerd Viz install</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># The first step of a production-ready Viz dashboard install</code>
<code class="c"># involves installing a standalone Prometheus instance.</code>
<code class="c"># This guide assumes you've done that in the linkerd-viz</code>
<code class="c"># namespace.</code>

<code class="c"># With that done, you can install Grafana.</code>
$<code class="w"> </code>helm<code class="w"> </code>repo<code class="w"> </code>add<code class="w"> </code>grafana<code class="w"> </code>https://grafana.github.io/helm-charts<code class="w"/>
$<code class="w"> </code>helm<code class="w"> </code>repo<code class="w"> </code>update<code class="w"/>
$<code class="w"> </code>helm<code class="w"> </code>install<code class="w"> </code>grafana<code class="w"> </code>-n<code class="w"> </code>grafana<code class="w"> </code>--create-namespace<code class="w"> </code>grafana/grafana<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-f<code class="w"> </code>https://raw.githubusercontent.com/linkerd/linkerd2/main/grafana/values.yaml<code class="w"/>

<code class="c"># The example install uses a values file provided by the</code>
<code class="c"># Linkerd team. It includes important configurations that</code>
<code class="c"># allow the dashboard to properly use Grafana. You can</code>
<code class="c"># read more in the official Linkerd docs:</code>
<code class="c"># https://linkerd.io/2/tasks/grafana/</code>

<code class="c"># After Grafana is installed, install Linkerd Viz and</code>
<code class="c"># tell it to use your Grafana instance.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>install<code class="w"> </code>--set<code class="w"> </code>grafana.url<code class="o">=</code>grafana.grafana:3000<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/></pre></div>
</div></section>






<section data-pdf-bookmark="Audit Trails and Access Logs" data-type="sect1" class="preface"><div class="preface" id="id82">
<h1 class="calibre8">Audit Trails and Access Logs</h1>

<p class="author1">Hardening our environments against<a data-primary="observability" data-secondary="access logging" data-type="indexterm" id="id1443" class="calibre4"/><a data-primary="access logging" data-type="indexterm" id="id1444" class="calibre4"/> intrusion doesn’t end at reducing the risk
and impact of an incident. Having a strong security posture also means being
able to rapidly detect when something abnormal has occurred and providing
data that allows your security team to understand exactly what you have in
place. For Linkerd, much of this data is contained in the system logs of the
control plane containers, accessible via <code class="calibre9">kubectl log</code>. It’s definitely worth
ensuring that you have a strategy for collecting and analyzing log messages
that is accessible to your security team.</p>

<p class="author1">Beyond normal log messages and events, some users need a detailed history
of all the HTTP requests that transit the proxy. This requires <em class="hyperlink">access logging</em>.</p>








<section data-pdf-bookmark="Access Logging: The Good, the Bad, and the Ugly" data-type="sect2" class="preface"><div class="preface" id="id164">
<h2 class="calibre27">Access Logging: The Good, the Bad, and the Ugly</h2>

<p class="author1">Access logging in Linkerd means<a data-primary="observability" data-secondary="access logging" data-tertiary="pros and cons" data-type="indexterm" id="id1445" class="calibre4"/><a data-primary="access logging" data-secondary="pros and cons" data-type="indexterm" id="id1446" class="calibre4"/> the proxy will write a log message for every
HTTP request it processes. In an environment where you have a number of
services talking to each other, that can very quickly turn into a huge volume
of log messages, so it’s definitely worth checking the
<a href="https://oreil.ly/zEFj_" class="calibre4">official Linkerd docs</a> before
you implement access logging. We will go into the high-level concepts and
practical steps, but the logs are an area where things can change between
versions of Linkerd, so be sure to test your setup after looking over the
docs.</p>










<section data-pdf-bookmark="The good" data-type="sect3" class="preface"><div class="preface" id="id323">
<h3 class="calibre33">The good</h3>

<p class="author1">Access logging will give you hugely detailed information about the interactions between your applications. It is configurable; you can emit the messages in either <code class="calibre9">apache</code> or <code class="calibre9">json</code> format so that they’re easier to consume programmatically. With access logging enabled, your security teams will have tremendous amounts of data to help them understand the impact and extent of any security incident.</p>
</div></section>










<section data-pdf-bookmark="The bad" data-type="sect3" class="preface"><div class="preface" id="id324">
<h3 class="calibre33">The bad</h3>

<p class="author1">Storing and processing these logs is expensive, requires significant engineering overhead, and uses up significant resources in your cluster. Your platform or security teams will need to manage log aggregation tooling and log collection agents on your clusters. Access logging will increase the costs of running your platform.</p>
</div></section>










<section data-pdf-bookmark="The ugly" data-type="sect3" class="preface"><div class="preface" id="id325">
<h3 class="calibre33">The ugly</h3>

<p class="author1">HTTP access logging is disabled by default in Linkerd because it has a performance impact on the proxies in terms of both CPU and latency. That means your application response times and compute costs will increase when you enable it. To what extent will depend very much on your level and type of traffic.</p>
</div></section>
</div></section>








<section data-pdf-bookmark="Enabling Access Logging" data-type="sect2" class="preface"><div class="preface" id="id165">
<h2 class="calibre27">Enabling Access Logging</h2>

<p class="author1">You can set the access logging <a data-primary="observability" data-secondary="access logging" data-tertiary="enabling" data-type="indexterm" id="id1447" class="calibre4"/><a data-primary="access logging" data-secondary="enabling" data-type="indexterm" id="id1448" class="calibre4"/>configuration at the workload, namespace, or Pod level. In any case, you’ll need to set the following annotation:</p>

<pre data-code-language="yaml" data-type="programlisting" class="calibre36"><code class="nt">config.linkerd.io/access-log</code><code class="p">:</code><code class="w"> </code><code class="calibre9">apache</code><code class="w"/></pre>

<p class="author1">Or:</p>

<pre data-code-language="yaml" data-type="programlisting" class="calibre36"><code class="nt">config.linkerd.io/access-log</code><code class="p">:</code><code class="w"> </code><code class="calibre9">json</code><code class="w"/></pre>

<p class="author1">After it’s set, you need to restart the targeted workloads to begin collecting logs.</p>

<p class="author1">We recommend that you test the performance impacts of enabling access logging in your application before rolling it out to production. That will give your organization the data it needs to make an informed decision about access logging in Linkerd.</p>
</div></section>
</div></section>






<section data-pdf-bookmark="Summary" data-type="sect1" class="preface"><div class="preface" id="id326">
<h1 class="calibre8">Summary</h1>

<p class="author1">Observability in Linkerd ranges from simple metrics to access logging. Linkerd
allows us to understand the behavior, performance, and characteristics of our
apps without requiring application developers to make any modifications. The
power of a service mesh lies in allowing the platform team to provide
observability to app teams as a feature of the platform. It also ensures that
all apps can be understood and compared in a uniform fashion.</p>
</div></section>
</div></section></body></html>