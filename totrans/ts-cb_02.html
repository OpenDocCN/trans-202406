<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Project Setup" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch01">&#13;
<h1><span class="label">Chapter 1. </span>Project Setup</h1>&#13;
&#13;
&#13;
<p><a data-primary="project setup" data-secondary="overview" data-type="indexterm" id="id388"/>You want to get started with TypeScript, fantastic! The big question is: how do you start? You can integrate TypeScript into your projects in many ways, and all are slightly different depending on your project’s needs. Just as JavaScript runs on many runtimes, there are plenty of ways to configure TypeScript so it meets your target’s needs.</p>&#13;
&#13;
<p>This chapter covers all the possibilities of introducing TypeScript to your project, as an extension next to JavaScript that gives you basic autocompletion and error indication, up to full-fledged setups for full-stack applications on Node.js and the browser.</p>&#13;
&#13;
<p>Since JavaScript tooling is a field with endless possibilities—​some say that a new JavaScript build chain is released every week, almost as much as new frameworks—​this chapter focuses more on what you can do with the TypeScript compiler alone, without any extra tool.</p>&#13;
&#13;
<p>TypeScript offers everything you need for your transpilation needs, except the ability to create minified and optimized bundles for web distribution. Bundlers like <a href="https://esbuild.github.io">ESBuild</a> or <a href="https://webpack.js.org">Webpack</a> take care of this task. Also, there are setups that include other transpilers like <a href="https://babeljs.io">Babel.js</a> that can play nicely with TypeScript.</p>&#13;
&#13;
<p>Bundlers and other transpilers are not within the scope of this chapter. Refer to their documentation for the inclusion of TypeScript and use the knowledge in this chapter to get the right configuration setup.</p>&#13;
&#13;
<p>TypeScript being a project with more than a decade of history, it carries some remains from older times that, for the sake of compatibility, TypeScript can’t just get rid of. Therefore, this chapter will spotlight modern JavaScript syntax and recent developments in web standards.</p>&#13;
&#13;
<p>If you still need to target Internet Explorer 8 or Node.js 10, first: I’m sorry, these platforms are really hard to develop for. However, second: you will be able to put together the pieces for older platforms with the knowledge from this chapter and the <a href="https://typescriptlang.org">official TypeScript documentation</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagenumrestart" data-pdf-bookmark="1.1 Type-Checking JavaScript" data-type="sect1"><div class="sect1" id="ch01_item_type-checking-javascript">&#13;
<h1>1.1 Type-Checking JavaScript</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id1">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="JavaScript" data-secondary="type-checking" data-type="indexterm" id="ix_0101-asciidoc0"/><a data-primary="project setup" data-secondary="type-checking JavaScript" data-type="indexterm" id="ix_0101-asciidoc1"/><a data-primary="type-checking" data-type="indexterm" id="ix_0101-asciidoc2"/>You want to get basic type-checking for JavaScript with the least amount of effort &#13;
<span class="keep-together">possible.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id2">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="@ts-check" data-primary-sortas="ts-check" data-type="indexterm" id="id389"/>Add a single-line comment with <code>@ts-check</code> at the beginning of every JavaScript file you want to type-check. With the right editors, you already get red squiggly lines whenever TypeScript encounters things that don’t quite add up.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id3">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>TypeScript has been designed as a superset of JavaScript, and every valid JavaScript is also valid TypeScript. This means TypeScript is also really good at figuring out potential errors in regular JavaScript code.</p>&#13;
&#13;
<p>We can use this if we don’t want a full-blown TypeScript setup but want some basic hints and type-checks to ease our development workflow.</p>&#13;
&#13;
<p><a data-primary="IDE" data-type="indexterm" id="id390"/><a data-primary="text editors" data-type="indexterm" id="id391"/>A good prerequisite if you only want to type-check JavaScript is a good editor or IDE. <a data-primary="Visual Studio Code (VSCode)" data-type="indexterm" id="id392"/>An editor that goes really well with TypeScript is <a href="https://code.visualstudio.com">Visual Studio Code</a>. Visual Studio Code—or VSCode for short—was the first major project to utilize TypeScript, even before TypeScript’s release.</p>&#13;
&#13;
<p>A lot of people recommend VSCode if you want to write JavaScript or TypeScript. But really, every editor is great as long as it features TypeScript support. And nowadays most of them do.</p>&#13;
&#13;
<p>With Visual Studio Code we get one very important thing for type-checking JavaScript: red squiggly lines when something doesn’t quite add up, as you can see in <a data-type="xref" href="#img-vscode-error">Figure 1-1</a>. This is the lowest barrier to entry. TypeScript’s type system has different levels of strictness when working with a codebase.</p>&#13;
&#13;
<figure><div class="figure" id="img-vscode-error">&#13;
<img alt="tscb 0101" src="assets/tscb_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>Red squiggly lines in code editors: first-level feedback if something in your code doesn’t add up</h6>&#13;
</div></figure>&#13;
&#13;
<p>First, the type system will try to <em>infer</em> types from JavaScript code through usage. If you have a line like this in your code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">let</code> <code class="nx">a_number</code> <code class="o">=</code> <code class="mi">1000</code><code class="p">;</code></pre>&#13;
&#13;
<p>TypeScript will correctly infer <code>number</code> as the type of <code>a_number</code>.</p>&#13;
&#13;
<p>One difficulty with JavaScript is that types are dynamic. Bindings via <code>let</code>, <code>var</code>, or <code>const</code> can change type based on usage.<sup><a data-type="noteref" href="ch01.html#id393" id="id393-marker">1</a></sup> Take a look at the following example:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">let</code> <code class="nx">a_number</code> <code class="o">=</code> <code class="mi">1000</code><code class="p">;</code>&#13;
&#13;
<code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mf">0.5</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">a_number</code> <code class="o">=</code> <code class="s2">"Hello, World!"</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a_number</code> <code class="o">*</code> <code class="mi">10</code><code class="p">);</code></pre>&#13;
&#13;
<p class="pagebreak-before">We assign a number to <code>a_number</code> and change the binding to a <code>string</code> if the condition in the next line evaluates to true. This wouldn’t be much of a problem if we didn’t try to multiply <code>a_number</code> on the last line. In approximately 50% of all cases, this example will produce unwanted behavior.</p>&#13;
&#13;
<p>TypeScript can help here. <a data-primary="@ts-check" data-primary-sortas="ts-check" data-type="indexterm" id="id394"/>With the addition of a single-line comment with <code>@ts-check</code> at the very top of our JavaScript file, TypeScript activates the next strictness level: type-checking JavaScript files based on the type information available in the &#13;
<span class="keep-together">JavaScript</span> file.</p>&#13;
&#13;
<p>In our example, TypeScript will figure out that we tried to assign a string to a binding that TypeScript has inferred to be a number. We will get an error in our editor:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// @ts-check</code>&#13;
<code class="kd">let</code> <code class="nx">a_number</code> <code class="o">=</code> <code class="mi">1000</code><code class="p">;</code>&#13;
&#13;
<code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mf">0.5</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">a_number</code> <code class="o">=</code> <code class="s2">"Hello, World!"</code><code class="p">;</code>&#13;
<code class="c1">// ^-- Type 'string' is not assignable to type 'number'.ts(2322)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a_number</code> <code class="o">*</code> <code class="mi">10</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now we can start to fix our code, and TypeScript will guide us.</p>&#13;
&#13;
<p>Type inference for JavaScript goes a long way. In the following example, TypeScript infers types by looking at operations like multiplication and addition as well as default values:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">addVAT</code><code class="p">(</code><code class="nx">price</code><code class="p">,</code> <code class="nx">vat</code> <code class="o">=</code> <code class="mf">0.2</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">price</code> <code class="o">*</code> <code class="p">(</code><code class="mi">1</code> <code class="o">+</code> <code class="nx">vat</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The function <code>addVat</code> takes two arguments. The second argument is optional, as it has been set to a default value of <code>0.2</code>. TypeScript will alert you if you try to pass a value that doesn’t work:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">addVAT</code><code class="p">(</code><code class="mi">1000</code><code class="p">,</code> <code class="s2">"a string"</code><code class="p">);</code>&#13;
<code class="c1">//           ^-- Argument of type 'string' is not assignable</code>&#13;
<code class="c1">//               to parameter of type 'number'.ts(2345)</code></pre>&#13;
&#13;
<p>Also, since we use multiplication and addition operations within the function body, TypeScript understands that we will return a number from this function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">addVAT</code><code class="p">(</code><code class="mi">1000</code><code class="p">).</code><code class="nx">toUpperCase</code><code class="p">();</code>&#13;
<code class="c1">//           ^-- Property 'toUpperCase' does not</code>&#13;
<code class="c1">//               exist on type 'number'.ts(2339)</code></pre>&#13;
&#13;
<p>In some situations you need more than type inference. <a data-primary="JSDoc" data-type="indexterm" id="id395"/>In JavaScript files, you can annotate function arguments and bindings through JSDoc type annotations. <a href="https://jsdoc.app">JSDoc</a> is a comment convention that allows you to describe your variables and function &#13;
<span class="keep-together">interfaces</span> in a way that’s not only readable for humans but also interpretable by machines. TypeScript will pick up your annotations and use them as types for the type system:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/** @type {number} */</code>&#13;
<code class="kd">let</code> <code class="nx">amount</code><code class="p">;</code>&#13;
&#13;
<code class="nx">amount</code> <code class="o">=</code> <code class="s1">'12'</code><code class="p">;</code>&#13;
<code class="c1">//       ^-- Argument of type 'string' is not assignable</code>&#13;
<code class="c1">//           to parameter of type 'number'.ts(2345)</code>&#13;
&#13;
<code class="cm">/**</code>&#13;
<code class="cm"> * Adds VAT to a price</code>&#13;
<code class="cm"> *</code>&#13;
<code class="cm"> * @param {number} price The price without VAT</code>&#13;
<code class="cm"> * @param {number} vat The VAT [0-1]</code>&#13;
<code class="cm"> *</code>&#13;
<code class="cm"> * @returns {number}</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">addVAT</code><code class="p">(</code><code class="nx">price</code><code class="p">,</code> <code class="nx">vat</code> <code class="o">=</code> <code class="mf">0.2</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">price</code> <code class="o">*</code> <code class="p">(</code><code class="mi">1</code> <code class="o">+</code> <code class="nx">vat</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>JSDoc also allows you to define new, complex types for objects:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * @typedef {Object} Article</code>&#13;
<code class="cm"> * @property {number} price</code>&#13;
<code class="cm"> * @property {number} vat</code>&#13;
<code class="cm"> * @property {string} string</code>&#13;
<code class="cm"> * @property {boolean=} sold</code>&#13;
<code class="cm"> */</code>&#13;
&#13;
<code class="cm">/**</code>&#13;
<code class="cm"> * Now we can use Article as a proper type</code>&#13;
<code class="cm"> * @param {[Article]} articles</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">totalAmount</code><code class="p">(</code><code class="nx">articles</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">articles</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">total</code><code class="p">,</code> <code class="nx">article</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">total</code> <code class="o">+</code> <code class="nx">addVAT</code><code class="p">(</code><code class="nx">article</code><code class="p">);</code>&#13;
  <code class="p">},</code> <code class="mi">0</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The syntax might feel a bit clunky, though; we will find better ways to annotate objects in <a data-type="xref" href="#ch01_item_types_on_the_side">Recipe 1.3</a>.</p>&#13;
&#13;
<p>Given that you have a JavaScript codebase that is well documented via JSDoc, adding a single line on top of your files will give you a really good understanding if something goes wrong in your code.<a data-startref="ix_0101-asciidoc2" data-type="indexterm" id="id396"/><a data-startref="ix_0101-asciidoc1" data-type="indexterm" id="id397"/><a data-startref="ix_0101-asciidoc0" data-type="indexterm" id="id398"/><a data-primary="annotations" data-see="type annotations" data-type="indexterm" id="id399"/><a data-primary="arguments" data-see="function arguments" data-type="indexterm" id="id400"/><a data-primary="external type definitions" data-see="standard library and external type definitions" data-type="indexterm" id="id401"/><a data-primary="overloads" data-see="function overloads" data-type="indexterm" id="id402"/><a data-primary="type definitions" data-secondary="external" data-see="standard library and external type definitions" data-type="indexterm" id="id403"/><a data-primary="types" data-secondary="development strategies" data-see="type development strategies" data-type="indexterm" id="id404"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.2 Installing TypeScript" data-type="sect1"><div class="sect1" id="ch01_item_installing">&#13;
<h1>1.2 Installing TypeScript</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id4">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="installation (TypeScript)" data-type="indexterm" id="ix_0201-asciidoc0"/><a data-primary="project setup" data-secondary="installing TypeScript" data-type="indexterm" id="ix_0201-asciidoc1"/><a data-primary="TypeScript (generally)" data-secondary="installing" data-type="indexterm" id="ix_0201-asciidoc2"/>Red squigglies in the editor are not enough: you want command-line feedback, status codes, configuration, and options to type-check JavaScript and compile TypeScript.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id5">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="NPM" data-type="indexterm" id="ix_0201-asciidoc3"/>Install TypeScript via Node’s primary package registry: <a href="https://npmjs.com">NPM</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id6">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="Node.js" data-type="indexterm" id="id405"/>TypeScript is written in TypeScript, compiled to JavaScript, and uses the <a href="https://nodejs.org">Node.js JavaScript runtime</a> as its primary execution environment.<sup><a data-type="noteref" href="ch01.html#id406" id="id406-marker">2</a></sup> Even if you’re not writing a Node.js app, the tooling for your JavaScript applications will run on Node. So, make sure you get Node.js from <a href="https://nodejs.org">the official website</a> and get familiar with its command-line tools.</p>&#13;
&#13;
<p><a data-primary="package.json" data-type="indexterm" id="id407"/>For a new project, make sure you initialize your project’s folder with a fresh &#13;
<span class="keep-together"><em>package.json</em>.</span> This file contains all the information for Node and its package manager NPM to figure out your project’s contents. Generate a new <em>package.json</em> file with default contents in your project’s folder with the NPM command-line tool:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npm<code class="w"> </code>init<code class="w"> </code>-y<code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Throughout this book, you will see commands that should be executed in your terminal. For convenience, we show these commands as they would appear on BASH or similar shells available for Linux, macOS, or the Windows subsystem for Linux. <a data-primary="$ (dollar sign; CLI convention)" data-type="indexterm" id="id408"/>The leading <code>$</code> sign is a convention to indicate a command, but it is not meant to be written by you. Note that all commands also work on the regular &#13;
<span class="keep-together">Windows</span> command-line interface as well as PowerShell.</p>&#13;
</div>&#13;
&#13;
<p>NPM is Node’s package manager. It comes with a CLI, a registry, and other tools that allow you to install dependencies. Once you initialize your <em>package.json</em>, install &#13;
<span class="keep-together">TypeScript</span> from NPM. We install it as a development dependency, meaning that TypeScript won’t be included if you intend to publish your project as a library to &#13;
<span class="keep-together">NPM itself:</span></p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>-D<code class="w"> </code>typescript<code class="w"/></pre>&#13;
&#13;
<p><a data-primary="TypeScript (generally)" data-secondary="global versus per-project installation" data-type="indexterm" id="id409"/>You can globally install TypeScript so you have the TypeScript compiler available everywhere, but I strongly suggest installing TypeScript separately per project. Depending on how frequently you visit your projects, you will end up with different TypeScript versions that are in sync with your project’s code. Installing (and updating) TypeScript globally might break projects you haven’t touched in a while.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you install frontend dependencies via NPM, you will need an additional tool to make sure that your code also runs in your browser: a bundler. TypeScript doesn’t include a bundler that works with the supported module systems, so you need to set up the proper tooling. Tools like <a href="https://webpack.js.org">Webpack</a> are common, and so is <a href="https://esbuild.github.io">ESBuild</a>. All tools are designed to execute TypeScript as well. Or you can go full native, as described in <a data-type="xref" href="#ch01_item_es_modules">Recipe 1.8</a>.<a data-startref="ix_0201-asciidoc3" data-type="indexterm" id="id410"/></p>&#13;
</div>&#13;
&#13;
<p>Now that TypeScript is installed, initialize a new TypeScript project. Use NPX for that: it allows you to execute a command-line utility that you installed relative to your project.</p>&#13;
&#13;
<p>With:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npx<code class="w"> </code>tsc<code class="w"> </code>--init<code class="w"/></pre>&#13;
&#13;
<p><a data-primary="tsconfig.json" data-type="indexterm" id="id411"/>you can run your project’s local version of the TypeScript compiler and pass the <code>init</code> flag to create a new <em>tsconfig.json</em>.</p>&#13;
&#13;
<p>The <em>tsconfig.json</em> is the main configuration file for your TypeScript project. It contains all the configuration needed so that TypeScript understands how to interpret your code, how to make types available for dependencies, and if you need to turn certain features on or off.</p>&#13;
&#13;
<p>Per default, TypeScript sets these options for you:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"target"</code><code class="p">:</code><code class="w"> </code><code class="s2">"es2016"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"commonjs"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"esModuleInterop"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"forceConsistentCasingInFileNames"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"skipLibCheck"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Let’s look at them in detail.</p>&#13;
&#13;
<p><code>target</code> is <code>es2016</code>, which means that if you run the TypeScript compiler, it will compile your TypeScript files to an ECMAScript 2016 compatible syntax. Depending on your supported browsers or environments, you can set that either to something more recent (ECMAScript versions are named after the year of release) or to something older such as <code>es5</code> for people who have to support very old Internet Explorer versions. Of course, I hope you don’t have to.</p>&#13;
&#13;
<p><code>module</code> is <code>commonjs</code>. This allows you to write ECMAScript module syntax, but instead of carrying this syntax over to the output, TypeScript will compile it to the CommonJS format. This means that:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">name</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./my-module"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>&#13;
<code class="c1">//...</code></pre>&#13;
&#13;
<p>becomes:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">my_module_1</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"./my-module"</code><code class="p">);</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">my_module_1</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code></pre>&#13;
&#13;
<p>once you compile. CommonJS was the module system for Node.js and has become very common because of Node’s popularity. Node.js has since adopted ECMAScript modules as well, something we’ll tackle in <a data-type="xref" href="#ch01_item_modules">Recipe 1.9</a>.</p>&#13;
&#13;
<p><a data-primary="esModuleInterop" data-type="indexterm" id="id412"/><code>esModuleInterop</code> ensures modules that aren’t ECMAScript modules are aligned to the standard once imported. <code>forceConsistentCasingInFileNames</code> helps people using case-sensitive file systems cooperate with folks who use case-insensitive file systems. And <code>skipLibCheck</code> assumes that your installed type definition files (more on that later) have no errors. So your compiler won’t check them and will become a little faster.</p>&#13;
&#13;
<p><a data-primary="strict mode" data-type="indexterm" id="id413"/>One of the most interesting features is TypeScript’s strict mode. If set to <code>true</code>, TypeScript will behave differently in certain areas. It’s a way for the TypeScript team to define their view on how the type system should behave.</p>&#13;
&#13;
<p>If TypeScript introduces a breaking change because the view on the type system changes, it will get incorporated in strict mode. This ultimately means that your code might break if you update TypeScript and always run in strict mode.</p>&#13;
&#13;
<p>To give you time to adapt to changes, TypeScript also allows you to turn certain strict mode features on or off, feature by feature.</p>&#13;
&#13;
<p>In addition to the default settings, I strongly recommend two more:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">//...</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"rootDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./src"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"outDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./dist"</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">This tells TypeScript to pick up source files from a <em>src</em> folder and put the compiled files into a <em>dist</em> folder. This setup allows you to separate your built files from the ones you author. You will have to create the <em>src</em> folder, of course; the <em>dist</em> folder will be created after you compile.</p>&#13;
&#13;
<p>Oh, compilation. Once you have your project set up, create an <em>index.ts</em> file in <code>src</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hello World"</code><code class="p">);</code></pre>&#13;
&#13;
<p>The <em>.ts</em> extension indicates it’s a TypeScript file. Now run:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npx<code class="w"> </code>tsc<code class="w"/></pre>&#13;
&#13;
<p>in your command line and see the compiler at work.<a data-startref="ix_0201-asciidoc2" data-type="indexterm" id="id414"/><a data-startref="ix_0201-asciidoc1" data-type="indexterm" id="id415"/><a data-startref="ix_0201-asciidoc0" data-type="indexterm" id="id416"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.3 Keeping Types on the Side" data-type="sect1"><div class="sect1" id="ch01_item_types_on_the_side">&#13;
<h1>1.3 Keeping Types on the Side</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id205">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="JavaScript" data-secondary="keeping types on the side" data-type="indexterm" id="ix_0301-asciidoc0"/><a data-primary="project setup" data-secondary="keeping types on the side" data-type="indexterm" id="ix_0301-asciidoc1"/>You want to write regular JavaScript with no extra build step but still get some editor support and proper type information for your functions. However, you don’t want to define your complex object types with JSDoc as shown in <a data-type="xref" href="#ch01_item_type-checking-javascript">Recipe 1.1</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id417">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Keep type definition files “on the side” and run the TypeScript compiler in the “check JavaScript” mode.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id7">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Gradual adoption has always been a dedicated goal for TypeScript. With this technique, which I dubbed “types on the side,” you can write TypeScript syntax for object types and advanced features like generics and conditional types (see <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>) instead of clunky JSDoc comments, but you still write JavaScript for your actual app.</p>&#13;
&#13;
<p>Somewhere in your project, maybe in a <em>@types</em> folder, create a type definition file. Its ending is <em>.d.ts</em>, and as opposed to regular <em>.ts</em> files, its purpose is to hold declarations but no actual code.</p>&#13;
&#13;
<p>This is where you can write your interfaces, type aliases, and complex types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// @types/person.d.ts</code>&#13;
&#13;
<code class="c1">// An interface for objects of this shape</code>&#13;
<code class="kr">export</code> <code class="kr">interface</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// An interface that extends the original one</code>&#13;
<code class="c1">// this is tough to write with JSDoc comments alone.</code>&#13;
<code class="kr">export</code> <code class="kr">interface</code> <code class="nx">Student</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="nx">semester</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that you export the interfaces from the declaration files. This is so you can import them in your JavaScript files:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// index.js</code>&#13;
<code class="cm">/** @typedef { import ("../@types/person").Person } Person */</code></pre>&#13;
&#13;
<p>The comment on the first line tells TypeScript to import the <code>Person</code> type from <em>@types/person</em> and make it available under the name <code>Person</code>.</p>&#13;
&#13;
<p>Now you can use this identifier to annotate function parameters or objects just like you would with primitive types like <code>string</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// index.js, continued</code>&#13;
&#13;
<code class="cm">/**</code>&#13;
<code class="cm"> * @param {Person} person</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-primary="@ts-check" data-primary-sortas="ts-check" data-type="indexterm" id="id418"/>To make sure that you get editor feedback, you still need to set <code>@ts-check</code> at the beginning of your JavaScript files as described in <a data-type="xref" href="#ch01_item_type-checking-javascript">Recipe 1.1</a>. Or, you can configure your project to always check JavaScript.</p>&#13;
&#13;
<p>Open <em>tsconfig.json</em> and set the <code>checkJs</code> flag to <code>true</code>. This will pick up all the JavaScript files from your <em>src</em> folder and give you constant feedback on type errors in your editor. You also can run <code>npx tsc</code> to see if you have errors in your command line.</p>&#13;
&#13;
<p>If you don’t want TypeScript to transpile your JavaScript files to older versions of JavaScript, make sure you set <code>noEmit</code> to <code>true</code>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"checkJs"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"noEmit"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>With that, TypeScript will look at your source files and will give you all the type information you need, but it won’t touch your code.</p>&#13;
&#13;
<p>This technique is also known to scale. Prominent JavaScript libraries like <a href="https://preactjs.org">Preact</a> work like this and provide fantastic tooling for their users as well as their contributors.<a data-startref="ix_0301-asciidoc1" data-type="indexterm" id="id419"/><a data-startref="ix_0301-asciidoc0" data-type="indexterm" id="id420"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.4 Migrating a Project to TypeScript" data-type="sect1"><div class="sect1" id="ch01_item_migrating">&#13;
<h1>1.4 Migrating a Project to TypeScript</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id8">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="JavaScript" data-secondary="migrating a project to TypeScript" data-type="indexterm" id="ix_0401-asciidoc0"/><a data-primary="migration, JavaScript to TypeScript" data-type="indexterm" id="ix_0401-asciidoc1"/><a data-primary="project setup" data-secondary="migrating a project to TypeScript" data-type="indexterm" id="ix_0401-asciidoc2"/><a data-primary="TypeScript (generally)" data-secondary="migrating a JavaScript project to" data-type="indexterm" id="ix_0401-asciidoc3"/>You want to get the full benefits of TypeScript for your project, but you need to migrate an entire codebase.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id421">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Rename your modules file by file from <em>.js</em> to <em>.ts</em>. Use several compiler options and features that help you iron out errors.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id9">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The benefit of having TypeScript files instead of JavaScript files with types is that your types and implementations are in one file, which gives you better editor support and access to more TypeScript features, and increases compatibility with other tools.</p>&#13;
&#13;
<p>However, just renaming all files from <em>.js</em> to <em>.ts</em> most likely will result in tons of errors. This is why you should go file by file and gradually increase type safety as you go along.</p>&#13;
&#13;
<p>The biggest problem when migrating is that you’re suddenly dealing with a TypeScript project, not with JavaScript. Still, lots of your modules will be JavaScript and, with no type information, they will fail the type-checking step.</p>&#13;
&#13;
<p>Make it easier for yourself and for TypeScript by turning off type-checking for JavaScript, but allow TypeScript modules to load and refer to JavaScript files:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"checkJs"</code><code class="p">:</code><code class="w"> </code><code class="kc">false</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"allowJs"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Should you run <code>npx tsc</code> now, you will see that TypeScript picks up all JavaScript and TypeScript files in your source folder and creates respective JavaScript files in your destination folder. TypeScript will also transpile your code to be compatible with the specified target version.</p>&#13;
&#13;
<p><a data-primary="dependencies" data-secondary="migrating a JavaScript project to TypeScript" data-type="indexterm" id="id422"/>If you are working with dependencies, you will see that some of them don’t come with type information. This will also produce TypeScript errors:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="nx">_</code> <code class="nx">from</code> <code class="s2">"lodash"</code><code class="p">;</code>&#13;
<code class="c1">//            ^- Could not find a declaration</code>&#13;
<code class="c1">//               file for module 'lodash'.</code></pre>&#13;
&#13;
<p class="pagebreak-before">Install third-party type definitions to get rid of this error. See <a data-type="xref" href="#ch01_item_definitely_typed">Recipe 1.5</a>.</p>&#13;
&#13;
<p>Once you migrate file by file, you might realize that you won’t be able to get all typings for one file in one go. There are dependencies, and you will quickly go down the rabbit hole of having too many files to adjust before you can tackle the one that you actually need.</p>&#13;
&#13;
<p>You can always decide just to live with the error. By default, TypeScript sets the compiler option <code>noEmitOnError</code> to <code>false</code>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"noEmitOnError"</code><code class="p">:</code><code class="w"> </code><code class="kc">false</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>This means that no matter how many errors you have in your project, TypeScript will generate result files, trying not to block you. This might be a setting you want to turn on after you finish migrating.</p>&#13;
&#13;
<p><a data-primary="noImplicitAny flag" data-type="indexterm" id="id423"/>In strict mode, TypeScript’s feature flag <code>noImplicitAny</code> is set to <code>true</code>. This flag will make sure that you don’t forget to assign a type to a variable, constant, or function parameter. Even if it’s just <code>any</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// This doesn't make sense, but is ok with any</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">gobbleydegook</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// This also doesn't make sense, but any allows it</code>&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="mi">123</code><code class="p">);</code></pre>&#13;
&#13;
<p><a data-primary="any type" data-secondary="basics" data-type="indexterm" id="id424"/><code>any</code> is the catchall type in TypeScript. Every value is compatible with <code>any</code>, and <code>any</code> allows you to access every property or call every method. <code>any</code> effectively turns off type-checking, giving you some room to breathe during your migration process.</p>&#13;
&#13;
<p>Alternatively, you can annotate your parameters with <code>unknown</code>. This also allows you to pass everything to a function but won’t allow you to do anything with it until you know more about the type.</p>&#13;
&#13;
<p>You can also decide to ignore errors by adding a <code>@ts-ignore</code> comment before the line you want to exclude from type-checking. A <code>@ts-nocheck</code> comment at the beginning of your file turns off type-checking entirely for this particular module.</p>&#13;
&#13;
<p><a data-primary="@ts-expect-error" data-primary-sortas="ts-expect-error" data-type="indexterm" id="id425"/>A comment directive that is fantastic for migration is <code>@ts-expect-error</code>. It works like <code>@ts-ignore</code> as it will swallow errors from the type-checking progress but will produce red squiggly lines if no type error is found.</p>&#13;
&#13;
<p class="pagebreak-before">When migrating, this helps you find the spots that you successfully moved to TypeScript. When there are no <code>@ts-expect-error</code> directives left, you’re done:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// This error will be swallowed</code>&#13;
<code class="c1">// @ts-expect-error</code>&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="mi">123</code><code class="p">);</code>&#13;
&#13;
&#13;
<code class="kd">function</code> <code class="nx">printNumber</code><code class="p">(</code><code class="nx">nr</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">nr</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// v- Unused '@ts-expect-error' directive.ts(2578)</code>&#13;
<code class="c1">// @ts-expect-error</code>&#13;
<code class="nx">printNumber</code><code class="p">(</code><code class="mi">123</code><code class="p">);</code></pre>&#13;
&#13;
<p>The great thing about this technique is that you flip responsibilities. Usually, you have to make sure that you pass in the right values to a function; now you can make sure that the function is able to handle the right input.</p>&#13;
&#13;
<p>All possibilities for getting rid of errors throughout your migration process have one thing in common: they’re explicit. You need to explicitly set <code>@ts-expect-error</code> comments, annotate function parameters as <code>any</code>, or ignore files entirely from type-checking. With that, you can always search for those escape hatches during the migration process and make sure that, over time, you got rid of them all.<a data-startref="ix_0401-asciidoc3" data-type="indexterm" id="id426"/><a data-startref="ix_0401-asciidoc2" data-type="indexterm" id="id427"/><a data-startref="ix_0401-asciidoc1" data-type="indexterm" id="id428"/><a data-startref="ix_0401-asciidoc0" data-type="indexterm" id="id429"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.5 Loading Types from Definitely Typed" data-type="sect1"><div class="sect1" id="ch01_item_definitely_typed">&#13;
<h1>1.5 Loading Types from Definitely Typed</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id10">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="DefinitelyTyped repository" data-type="indexterm" id="ix_0501-asciidoc0"/><a data-primary="project setup" data-secondary="loading types from DefinitelyTyped" data-type="indexterm" id="ix_0501-asciidoc1"/><a data-primary="types" data-secondary="loading from DefinitelyTyped" data-type="indexterm" id="ix_0501-asciidoc2"/><a data-primary="types" data-seealso="specific types" data-type="indexterm" id="id430"/>You rely on a dependency that hasn’t been written in TypeScript and therefore lacks typings.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id431">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>From <a href="https://oreil.ly/nZ4xZ">Definitely Typed</a>, install community-maintained type definitions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id11">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Definitely Typed is one of the biggest and most active repositories on GitHub and collects high-quality TypeScript type definitions developed and maintained by &#13;
<span class="keep-together">the community.</span></p>&#13;
&#13;
<p>The number of maintained type definitions is close to 10,000, and there is rarely a JavaScript library not available.</p>&#13;
&#13;
<p>All type definitions are linted, checked, and deployed to the Node.js package registry NPM under the <code>@types</code> namespace. NPM has an indicator on each package’s information site that shows if Definitely Typed type definitions are available, as you can see in <a data-type="xref" href="#img-npm-react">Figure 1-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-npm-react">&#13;
<img alt="tscb 0102" src="assets/tscb_0102.png"/>&#13;
<h6><span class="label">Figure 1-2. </span>The NPM site for React shows a DT logo next to the package name; this &#13;
<span class="keep-together">indicates</span> available type definitions from Definitely Typed</h6>&#13;
</div></figure>&#13;
&#13;
<p>Clicking on this logo leads you to the actual site for type definitions. If a package has first-party type definitions already available, it shows a small TS logo next to the package name, as shown in <a data-type="xref" href="#img-npm-types-react">Figure 1-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-npm-types-react">&#13;
<img alt="tscb 0103" src="assets/tscb_0103.png"/>&#13;
<h6><span class="label">Figure 1-3. </span>Type definitions for React from Definitely Typed</h6>&#13;
</div></figure>&#13;
&#13;
<p>To install, for example, typings for the popular JavaScript framework React, you install the <code>@types/react</code> package to your local dependencies:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="c1"># Installing React</code>&#13;
$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>--save<code class="w"> </code>react<code class="w"/>&#13;
&#13;
<code class="c1"># Installing Type Definitions</code>&#13;
$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>--save-dev<code class="w"> </code>@types/react<code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In this example we install types to development dependencies, since we consume them while developing the application, and the compiled result has no use of the types anyway.</p>&#13;
</div>&#13;
&#13;
<p>By default, TypeScript will pick up type definitions it can find that are in visible <em>@types</em> folders relative to your project’s root folder. It will also pick up all type definitions from <em>node_modules/@types</em>; note that this is where NPM installs, for &#13;
<span class="keep-together">example, <code>@types/react</code>.</span></p>&#13;
&#13;
<p>We do this because the <code>typeRoots</code> compiler option in <em>tsconfig.json</em> is set to <code>@types</code> and <code>./node_modules/@types</code>. Should you need to override this setting, make sure to include the original folders if you want to pick up type definitions from Definitely Typed:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"typeRoots"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"./typings"</code><code class="p">,</code><code class="w"> </code><code class="s2">"./node_modules/@types"</code><code class="p">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Note that just by installing type definitions into <em>node_modules/@types</em>, TypeScript will load them during compilation. This means that if some types declare globals, TypeScript will pick them up.</p>&#13;
&#13;
<p>You might want to explicitly state which packages should be allowed to contribute to the global scope by specifying them in the <code>types</code> setting in your compiler options:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"types"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"node"</code><code class="p">,</code><code class="w"> </code><code class="s2">"jest"</code><code class="p">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Note that this setting will only affect the contributions to the global scope. If you load node modules via import statements, TypeScript still will pick up the correct types from <em>@types</em>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// If `@types/lodash` is installed, we get proper</code>&#13;
<code class="c1">// type defintions for this NPM package</code>&#13;
<code class="kr">import</code> <code class="nx">_</code> <code class="nx">from</code> <code class="s2">"lodash"</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">flattenDeep</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="p">[</code><code class="mi">4</code><code class="p">]],</code> <code class="mi">5</code><code class="p">]]);</code></pre>&#13;
&#13;
<p>We will revisit this setting in <a data-type="xref" href="#ch01_item_testing">Recipe 1.7</a>.<a data-startref="ix_0501-asciidoc2" data-type="indexterm" id="id432"/><a data-startref="ix_0501-asciidoc1" data-type="indexterm" id="id433"/><a data-startref="ix_0501-asciidoc0" data-type="indexterm" id="id434"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.6 Setting Up a Full-Stack Project" data-type="sect1"><div class="sect1" id="ch01_item_fullstack">&#13;
<h1>1.6 Setting Up a Full-Stack Project</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id12">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="full-stack application" data-type="indexterm" id="ix_0601-asciidoc0"/><a data-primary="Node.js" data-secondary="writing full-stack application targeting" data-type="indexterm" id="ix_0601-asciidoc1"/><a data-primary="project setup" data-secondary="full-stack project" data-type="indexterm" id="ix_0601-asciidoc2"/>You want to write a full-stack application targeting Node.js and the browser, with shared dependencies.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id435">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create two <em>tsconfig</em> files for each frontend and backend, and load shared &#13;
<span class="keep-together">dependencies</span> as composites.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id13">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="JavaScript" data-secondary="Node.js features versus" data-type="indexterm" id="id436"/><a data-primary="Node.js" data-secondary="JavaScript features versus" data-type="indexterm" id="id437"/>Node.js and the browser both run JavaScript, but they have a very different understanding of what developers should do with the environment. Node.js is meant for servers, command-line tools, and everything that runs without a UI—<em>headless</em>. It has its own set of APIs and standard library. This little script starts an HTTP server:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code><code> </code><code class="nx">http</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="s1">'http'</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_project_setup_CO1-1" id="co_project_setup_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="kr">const</code><code> </code><code class="nx">hostname</code><code> </code><code class="o">=</code><code> </code><code class="s1">'127.0.0.1'</code><code class="p">;</code><code>&#13;
</code><code class="kr">const</code><code> </code><code class="nx">port</code><code> </code><code class="o">=</code><code> </code><code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code><code> </code><code class="o">||</code><code> </code><code class="mi">3000</code><code class="p">;</code><code> </code><a class="co" href="#callout_project_setup_CO1-2" id="co_project_setup_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
&#13;
</code><code class="kr">const</code><code> </code><code class="nx">server</code><code> </code><code class="o">=</code><code> </code><code class="nx">http</code><code class="p">.</code><code class="nx">createServer</code><code class="p">(</code><code class="p">(</code><code class="nx">req</code><code class="p">,</code><code> </code><code class="nx">res</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">res</code><code class="p">.</code><code class="nx">statusCode</code><code> </code><code class="o">=</code><code> </code><code class="mi">200</code><code class="p">;</code><code>&#13;
  </code><code class="nx">res</code><code class="p">.</code><code class="nx">setHeader</code><code class="p">(</code><code class="s1">'Content-Type'</code><code class="p">,</code><code> </code><code class="s1">'text/plain'</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">res</code><code class="p">.</code><code class="nx">end</code><code class="p">(</code><code class="s1">'Hello World'</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="nx">server</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="nx">port</code><code class="p">,</code><code> </code><code class="nx">hostname</code><code class="p">,</code><code> </code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="sb">Server running at http://</code><code class="si">${</code><code class="nx">hostname</code><code class="si">}</code><code class="sb">:</code><code class="si">${</code><code class="nx">port</code><code class="si">}</code><code class="sb">/</code><code class="sb">`</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_project_setup_CO1-3" id="co_project_setup_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre>&#13;
&#13;
<p>While it’s without a doubt JavaScript, some things are unique to Node.js:</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_project_setup_CO1-1" id="callout_project_setup_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>"http"</code> is a built-in Node.js module for everything related to HTTP. It is loaded via <code>require</code>, which is an indicator for Node’s module system called <em>CommonJS</em>. There are other ways to load modules in Node.js as we see in <a data-type="xref" href="#ch01_item_modules">Recipe 1.9</a>, but recently CommonJS has been the most common.</p></dd>&#13;
<dt><a class="co" href="#co_project_setup_CO1-2" id="callout_project_setup_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>process</code> object is a global object containing information on environment variables and the current Node.js process in general. This is also unique to Node.js.</p></dd>&#13;
<dt><a class="co" href="#co_project_setup_CO1-3" id="callout_project_setup_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>console</code> and its functions are available in almost every JavaScript runtime, but what it does in Node is different from what it does in the browser. In Node, it prints on STDOUT; in the browser, it will print a line to the development tools.</p></dd>&#13;
</dl>&#13;
&#13;
<p>There are of course many more unique APIs for Node.js. But the same goes for JavaScript in the browser:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code><code> </code><code class="p">{</code><code> </code><code class="nx">msg</code><code> </code><code class="p">}</code><code> </code><code class="nx">from</code><code> </code><code class="sb">`</code><code class="sb">./msg.js</code><code class="sb">`</code><code class="p">;</code><code> </code><a class="co" href="#callout_project_setup_CO2-1" id="co_project_setup_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s1">'button'</code><code class="p">)</code><code class="o">?</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code><code> </code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_project_setup_CO2-2" id="co_project_setup_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_project_setup_CO2-3" id="co_project_setup_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre>&#13;
<dl class="calloutlist pagebreak-before">&#13;
<dt><a class="co" href="#co_project_setup_CO2-1" id="callout_project_setup_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>After years without a way to load modules, ECMAScript modules have found their way into JavaScript and the browsers. This line loads an object from another JavaScript module. This runs in the browser natively and is a second module system for Node.js (see <a data-type="xref" href="#ch01_item_modules">Recipe 1.9</a>).</p></dd>&#13;
<dt><a class="co" href="#co_project_setup_CO2-2" id="callout_project_setup_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>JavaScript in the browser is meant to interact with UI events. The <code>document</code> object and the idea of a <code>querySelector</code> that points to elements in the <em>Document Object Model (DOM)</em> are unique to the browser. So is adding an event listener and listening on “click” events. You don’t have this in Node.js.</p></dd>&#13;
<dt><a class="co" href="#co_project_setup_CO2-3" id="callout_project_setup_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>And again, <code>console</code>. It has the same API as in Node.js, but the result is a bit &#13;
<span class="keep-together">different.</span></p></dd>&#13;
</dl>&#13;
&#13;
<p>The differences are so big, it’s hard to create one TypeScript project that handles both. If you are writing a full-stack application, you need to create two TypeScript configuration files that deal with each part of your stack.</p>&#13;
&#13;
<p>Let’s work on the backend first. Let’s assume you want to write an Express.js server in Node.js (Express is a popular server framework for Node). First, you create a new NPM project as shown in <a data-type="xref" href="#ch01_item_type-checking-javascript">Recipe 1.1</a>. Then, install Express as a dependency:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>--save<code class="w"> </code>express<code class="w"/></pre>&#13;
&#13;
<p>And install type definitions for Node.js and Express from Definitely Typed:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>-D<code class="w"> </code>@types/express<code class="w"> </code>@types/node<code class="w"/></pre>&#13;
&#13;
<p>Create a new folder called <em>server</em>. This is where your Node.js code goes. Instead of creating a new <em>tsconfig.json</em> via <code>tsc</code>, create a new <em>tsconfig.json</em> in your project’s <em>server</em> folder. Here are the contents:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// server/tsconfig.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"target"</code><code class="p">:</code><code class="w"> </code><code class="s2">"ESNext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"lib"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"ESNext"</code><code class="p">],</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"commonjs"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"rootDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"moduleResolution"</code><code class="p">:</code><code class="w"> </code><code class="s2">"node"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"types"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"node"</code><code class="p">],</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"outDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"../dist/server"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"esModuleInterop"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"forceConsistentCasingInFileNames"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"skipLibCheck"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">You should already know a lot of this, but a few things stand out:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>module</code> property is set to <code>commonjs</code>, the original Node.js module system. All <code>import</code> and <code>export</code> statements will be transpiled to their CommonJS counterpart.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>types</code> property is set to <code>["node"]</code>. This property includes all the libraries you want to have globally available. If <code>"node"</code> is in the global scope, you will get type information for <code>require</code>, <code>process</code>, and other Node.js specifics that are in the global space.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To compile your server-side code, run:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npx<code class="w"> </code>tsc<code class="w"> </code>-p<code class="w"> </code>server/tsconfig.json<code class="w"/></pre>&#13;
&#13;
<p>Now for the client:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// client/tsconfig.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"target"</code><code class="p">:</code><code class="w"> </code><code class="s2">"ESNext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"lib"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"DOM"</code><code class="p">,</code><code class="w"> </code><code class="s2">"ESNext"</code><code class="p">],</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"ESNext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"rootDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"moduleResolution"</code><code class="p">:</code><code class="w"> </code><code class="s2">"node"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"types"</code><code class="p">:</code><code class="w"> </code><code class="p">[],</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"outDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"../dist/client"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"esModuleInterop"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"forceConsistentCasingInFileNames"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"skipLibCheck"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>There are some similarities, but again, a few things stand out:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You add <code>DOM</code> to the <code>lib</code> property. This gives you type definitions for everything related to the browser. Where you needed to install Node.js typings via Definitely Typed, TypeScript ships the most recent type definitions for the browser with the compiler.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>types</code> array is empty. This will <em>remove</em> <code>"node"</code> from our global typings. Since you only can install type definitions per <em>package.json</em>, the <code>"node"</code> type definitions we installed earlier would be available in the entire code base. For the &#13;
<span class="keep-together"><code>client</code></span> part, however, you want to get rid of them.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To compile your frontend code, run:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npx<code class="w"> </code>tsc<code class="w"> </code>-p<code class="w"> </code>client/tsconfig.json<code class="w"/></pre>&#13;
&#13;
<p>Please note that you configured two distinct <em>tsconfig.json</em> files. Editors like Visual Studio Code pick up configuration information only for <em>tsconfig.json</em> files per folder. You could as well name them <em>tsconfig.server.json</em> and <em>tsconfig.client.json</em> and have them in your project’s root folder (and adjust all directory properties). <code>tsc</code> will use the correct configurations and throw errors if it finds any, but the editor will mostly stay silent or work with a default configuration.</p>&#13;
&#13;
<p>Things get a bit hairier if you want to have shared dependencies. One way to achieve shared dependencies is to use project references and composite projects. This means that you extract your shared code in its own folder, but tell TypeScript that this is meant to be a dependency project of another one.</p>&#13;
&#13;
<p>Create a <em>shared</em> folder on the same level as <em>client</em> and <em>server</em>. Create a <em>tsconfig.json</em> in <em>shared</em> with these contents:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// shared/tsconfig.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"composite"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"target"</code><code class="p">:</code><code class="w"> </code><code class="s2">"ESNext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"ESNext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"rootDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"../shared/"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"moduleResolution"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Node"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"types"</code><code class="p">:</code><code class="w"> </code><code class="p">[],</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"declaration"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"outDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"../dist/shared"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"esModuleInterop"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"forceConsistentCasingInFileNames"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"skipLibCheck"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Two things stand out again:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The flag <code>composite</code> is set to <code>true</code>. This allows other projects to reference this one.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>declaration</code> flag is also set to <code>true</code>. This will generate <em>d.ts</em> files from your code so other projects can consume type information.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To include them in your client and server code, add this line to <em>client/tsconfig.json</em> and <em>server/tsconfig.json</em>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// server/tsconfig.json</code><code class="w"/>&#13;
<code class="c1">// client/tsconfig.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Same as before</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"references"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nt">"path"</code><code class="p">:</code><code class="w"> </code><code class="s2">"../shared/tsconfig.json"</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">]</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>And you are all set. You can write shared dependencies and include them in your &#13;
<span class="keep-together">client</span> and server code.</p>&#13;
&#13;
<p>There is a caveat, however. This works great if you share, for example, only models and type information, but the moment you share actual functionality, you will see that the two different module systems (CommonJS in Node, ECMAScript modules in the browser) can’t be unified in one compiled file. You either create an ESNext module and can’t import it in CommonJS code or create CommonJS code and can’t import it in the browser.</p>&#13;
&#13;
<p>There are two things you can do:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Compile to CommonJS and let a bundler take care of the module resolution work for the browser.</p>&#13;
</li>&#13;
<li>&#13;
<p>Compile to ECMAScript modules and write modern Node.js applications based on ECMAScript modules. See <a data-type="xref" href="#ch01_item_modules">Recipe 1.9</a> for more information.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Since you are starting out new, I strongly recommend the second option.<a data-startref="ix_0601-asciidoc2" data-type="indexterm" id="id438"/><a data-startref="ix_0601-asciidoc1" data-type="indexterm" id="id439"/><a data-startref="ix_0601-asciidoc0" data-type="indexterm" id="id440"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.7 Setting Up Tests" data-type="sect1"><div class="sect1" id="ch01_item_testing">&#13;
<h1>1.7 Setting Up Tests</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id206">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="project setup" data-secondary="test setup" data-type="indexterm" id="ix_0701-asciidoc0"/><a data-primary="tests" data-secondary="setup when globals for testing frameworks interfere with production code" data-type="indexterm" id="ix_0701-asciidoc1"/>You want to write tests, but the globals for testing frameworks interfere with your production code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id441">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a separate <em>tsconfig</em> for development and build, and exclude all test files in the latter one.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id14">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="Node.js" data-secondary="testing frameworks" data-type="indexterm" id="ix_0701-asciidoc2"/>In the JavaScript and Node.js ecosystem, there are a lot of unit testing frameworks and test runners. They vary in detail, have different opinions, or are tailored for certain needs. Some of them might just be prettier than others.</p>&#13;
&#13;
<p><a data-primary="Mocha" data-type="indexterm" id="ix_0701-asciidoc3"/>While test runners like <a href="https://oreil.ly/R6xFr">Ava</a> rely on importing modules to get the framework into scope, others provide a set of globals. Take <a href="https://mochajs.org">Mocha</a>, for example:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="nx">assert</code> <code class="nx">from</code> <code class="s2">"assert"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">add</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">".."</code><code class="p">;</code>&#13;
&#13;
<code class="nx">describe</code><code class="p">(</code><code class="s2">"Adding numbers"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">it</code><code class="p">(</code><code class="s2">"should add two numbers"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">assert</code><code class="p">.</code><code class="nx">equal</code><code class="p">(</code><code class="nx">add</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code> <code class="mi">5</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p><code>assert</code> comes from the Node.js built-in assertion library, but <code>describe</code>, <code>it</code>, and many more are globals provided by Mocha. They also only exist when the Mocha CLI is running.</p>&#13;
&#13;
<p>This provides a bit of a challenge for your type setup, as those functions are necessary to write tests but aren’t available when you execute your actual application.</p>&#13;
&#13;
<p>The solution is to create two different configuration files: a regular <em>tsconfig.json</em> for development that your editor can pick up (remember <a data-type="xref" href="#ch01_item_fullstack">Recipe 1.6</a>) and a separate <em>tsconfig.build.json</em> that you use when you want to compile your application.</p>&#13;
&#13;
<p>The first one includes all the globals you need, including types for Mocha; the latter makes sure no test file is included within your compilation.</p>&#13;
&#13;
<p>Let’s go through this step by step. We look at Mocha as an example, but other test runners that provide globals like <a href="https://jestjs.io">Jest</a> work just the same way.</p>&#13;
&#13;
<p>First, install Mocha and its types:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>--save-dev<code class="w"> </code>mocha<code class="w"> </code>@types/mocha<code class="w"> </code>@types/node<code class="w"/></pre>&#13;
&#13;
<p>Create a new <em>tsconfig.base.json</em>. Since the only differences between development and build are the set of files to be included and the libraries activated, you want to have all the other compiler settings located in one file you can reuse for both. An example file for a Node.js application would look like this:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// tsconfig.base.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"target"</code><code class="p">:</code><code class="w"> </code><code class="s2">"esnext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"commonjs"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"esModuleInterop"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"forceConsistentCasingInFileNames"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"outDir"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./dist"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"skipLibCheck"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>The source files should be located in  <em>src</em>; test files should be located in an adjacent folder <em>test</em>. The setup you create in this recipe will also allow you to create files ending with <em>.test.ts</em> anywhere in your project.</p>&#13;
&#13;
<p>Create a new <em>tsconfig.json</em> with your base development configuration. This one is used for editor feedback and for running tests with Mocha. You extend the basic settings from <em>tsconfig.base.json</em> and inform TypeScript which folders to pick up &#13;
<span class="keep-together">for compilation:</span></p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// tsconfig.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"extends"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./tsconfig.base.json"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"types"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"node"</code><code class="p">,</code><code class="w"> </code><code class="s2">"mocha"</code><code class="p">],</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"rootDirs"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"test"</code><code class="p">,</code><code class="w"> </code><code class="s2">"src"</code><code class="p">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Note that you add <code>types</code> for Node and Mocha. The <code>types</code> property defines which globals are available and, in the development setting, you have both.<a data-startref="ix_0701-asciidoc3" data-type="indexterm" id="id442"/></p>&#13;
&#13;
<p>Additionally, you might find that compiling your tests before executing them is cumbersome. There are shortcuts to help you. For example, <code>ts-node</code> runs your local installation of Node.js and does an in-memory TypeScript compilation first:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>--save-dev<code class="w"> </code>ts-node<code class="w"/>&#13;
$<code class="w"> </code>npx<code class="w"> </code>mocha<code class="w"> </code>-r<code class="w"> </code>ts-node/register<code class="w"> </code>tests/*.ts<code class="w"/></pre>&#13;
&#13;
<p>With the development environment set up, it’s time for the build environment. Create a <em>tsconfig.build.json</em>. It looks similar to <em>tsconfig.json</em>, but you will spot the difference right away:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// tsconfig.build.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"extends"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./tsconfig.base.json"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"types"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"node"</code><code class="p">],</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"rootDirs"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"src"</code><code class="p">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"exclude"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"**/*.test.ts"</code><code class="p">,</code><code class="w"> </code><code class="s2">"**/test/**"</code><code class="p">]</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In addition to changing <code>types</code> and <code>rootDirs</code>, you define which files to exclude from type-checking and compilation. You use wild-card patterns that exclude all files ending with <em>.test.ts</em> that are located in test folders. Depending on your taste, you can also add <em>.spec.ts</em> or <em>spec</em> folders to this array.</p>&#13;
&#13;
<p>Compile your project by referring to the right JSON file:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npx<code class="w"> </code>tsc<code class="w"> </code>-p<code class="w"> </code>tsconfig.build.json<code class="w"/></pre>&#13;
&#13;
<p>You will see that in the result files (located in <code>dist</code>), you won’t see any test file. Also, while you still can access <code>describe</code> and <code>it</code> when editing your source files, you will get an error if you try to compile:</p>&#13;
&#13;
<pre data-type="programlisting">$ npx tsc -p tsconfig.build.json&#13;
&#13;
src/index.ts:5:1 - error TS2593: Cannot find name 'describe'.&#13;
Do you need to install type definitions for a test runner?&#13;
Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha`&#13;
and then add 'jest' or 'mocha' to the types field in your tsconfig.&#13;
&#13;
5 describe("this does not work", () =&gt; {})&#13;
  ~~~~~~~~&#13;
&#13;
&#13;
Found 1 error in src/index.ts:5</pre>&#13;
&#13;
<p>If you don’t like polluting your globals during development mode, you can choose a similar setup as in <a data-type="xref" href="#ch01_item_fullstack">Recipe 1.6</a>, but it won’t allow you to write tests adjacent to your source files.<a data-startref="ix_0701-asciidoc2" data-type="indexterm" id="id443"/></p>&#13;
&#13;
<p>Finally, you can always opt for a test runner that prefers the module system.<a data-startref="ix_0701-asciidoc1" data-type="indexterm" id="id444"/><a data-startref="ix_0701-asciidoc0" data-type="indexterm" id="id445"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.8 Typing ECMAScript Modules from URLs" data-type="sect1"><div class="sect1" id="ch01_item_es_modules">&#13;
<h1>1.8 Typing ECMAScript Modules from URLs</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id15">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="ECMAScript" data-secondary="typing ECMAScript modules from URLS" data-type="indexterm" id="ix_0801-asciidoc0"/><a data-primary="project setup" data-secondary="typing ECMAScript modules from URLS" data-type="indexterm" id="ix_0801-asciidoc1"/><a data-primary="URLs, typing ECMAScript modules from" data-type="indexterm" id="ix_0801-asciidoc2"/>You want to work without bundlers and use the browser’s module-loading capabilities for your app, yet you still want to have all the type information.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id16">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="js extension, TypeScript and" data-type="indexterm" id="id446"/>Set <code>target</code> and <code>module</code> in your <em>tsconfig</em>’s compiler options to <code>esnext</code> and point to your modules with a <em>.js</em> extension. In addition, install types to dependencies via NPM, and use the <code>path</code> property in your <em>tsconfig</em> to tell TypeScript where to look for types:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// tsconfig.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"target"</code><code class="p">:</code><code class="w"> </code><code class="s2">"esnext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"esnext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"paths"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"https://esm.sh/lodash@4.17.21"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">        </code><code class="s2">"node_modules/@types/lodash/index.d.ts"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">]</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id17">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Modern browsers support module loading out of the box. Instead of bundling your app into a smaller set of files, you can use the raw JavaScript files directly.</p>&#13;
&#13;
<p>Content Delivery Networks (CDNs) like <a href="https://esm.sh">esm.sh</a>, <a href="https://unpkg.com">unpkg</a>, and others are designed to distribute node modules and JavaScript dependencies as URLs, consumable by native ECMAScript module loading.</p>&#13;
&#13;
<p>With proper caching and state-of-the-art HTTP, ECMAScript modules become a real alternative for apps.</p>&#13;
&#13;
<p>TypeScript does not include a modern bundler, so you would need to install an extra tool anyway. But if you decide to go module first, there are a few things to consider when working with TypeScript.</p>&#13;
&#13;
<p>What you want to achieve is to write <code>import</code> and <code>export</code> statements in TypeScript but preserve the module-loading syntax and let the browser handle module resolution:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// File module.ts</code>&#13;
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// File index.ts</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">obj</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./module"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code></pre>&#13;
&#13;
<p>To achieve this, tell TypeScript to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Compile to an ECMAScript version that understands modules</p>&#13;
</li>&#13;
<li>&#13;
<p>Use the ECMAScript module syntax for module code generation</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Update two properties in your <em>tsconfig.json</em>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// tsconfig.json</code>&#13;
<code class="p">{</code>&#13;
  <code class="s2">"compilerOptions"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="s2">"target"</code><code class="o">:</code> <code class="s2">"esnext"</code><code class="p">,</code>&#13;
    <code class="s2">"module"</code><code class="o">:</code> <code class="s2">"esnext"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>module</code> tells TypeScript how to transform import and export statements. The default converts module loading to CommonJS, as seen in <a data-type="xref" href="#ch01_item_installing">Recipe 1.2</a>. Setting <code>module</code> to <code>esnext</code> will use ECMAScript module loading and thus preserve the syntax.</p>&#13;
&#13;
<p><code>target</code> tells TypeScript the ECMAScript version you want to transpile your code to. Once a year, there’s a new ECMAScript release with new features. Setting <code>target</code> to <code>esnext</code> will always target the latest ECMAScript version.</p>&#13;
&#13;
<p>Depending on your compatibility goals, you might want to set this property to the ECMAScript version compatible with the browsers you want to support. This is usually a version with a year (e.g. <code>es2015</code>, <code>es2016</code>, <code>es2017</code>, etc). ECMAScript modules work with every version from <code>es2015</code> on. If you go for an older version, you won’t be able to load ECMAScript modules natively in the browser.</p>&#13;
&#13;
<p>Changing these compiler options already does one important thing: it leaves the syntax intact. A problem occurs once you want to run your code.</p>&#13;
&#13;
<p>Usually, import statements in TypeScript point to files without an extension. You write <code>import { obj } from "./module"</code>, leaving out <em>.ts</em>. Once you compile, this extension is still missing. But the browser needs an extension to actually point to the respective JavaScript file.</p>&#13;
&#13;
<p>The solution: Add a <em>.js</em> extension, even though you are pointing to a <em>.ts</em> file when you develop. TypeScript is smart enough to pick that up:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// index.ts</code>&#13;
&#13;
<code class="c1">// This still loads types from 'module.ts', but keeps</code>&#13;
<code class="c1">// the reference intact once we compile it.</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">obj</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./module.js'</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code></pre>&#13;
&#13;
<p>For your project’s modules, that’s all you need!</p>&#13;
&#13;
<p>It gets a lot more interesting when you want to use dependencies. If you go native, you might want to load modules from a CDN, like <a href="https://esm.sh">esm.sh</a>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="nx">_</code> <code class="nx">from</code> <code class="s2">"https://esm.sh/lodash@4.17.21"</code>&#13;
<code class="c1">//             ^- Error 2307</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">flattenDeep</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="p">[</code><code class="mi">4</code><code class="p">]],</code> <code class="mi">5</code><code class="p">]]);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code></pre>&#13;
&#13;
<p>TypeScript will error with the following message: “Cannot find module <em>…​</em> or its corresponding type declarations. (2307)”</p>&#13;
&#13;
<p>TypeScript’s module resolution works when files are on your disk, not on a server via HTTP. To get the info we need, we have to provide TypeScript with a resolution of our own.</p>&#13;
&#13;
<p>Even though we are loading dependencies from URLs, the type information for these dependencies lives with NPM. For <code>lodash</code>, you can install type information from Definitely Typed:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>-D<code class="w"> </code>@types/lodash<code class="w"/></pre>&#13;
&#13;
<p>For dependencies that come with their own types, you can install the dependencies directly:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>-D<code class="w"> </code>preact<code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">Once the types are installed, use the <code>path</code> property in your compiler options to tell TypeScript how to resolve your URL:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// tsconfig.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"paths"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"https://esm.sh/lodash@4.17.21"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">        </code><code class="s2">"node_modules/@types/lodash/index.d.ts"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">]</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Be sure to point to the right file!</p>&#13;
&#13;
<p>There’s also an escape hatch if you don’t want to use typings, or if you just can’t find typings. <a data-primary="any type" data-secondary="disabling type-checking with" data-type="indexterm" id="id447"/>Within TypeScript, we can use <code>any</code> to intentionally disable type-checking. For modules, we can do something very similar—ignore the TypeScript error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// @ts-ignore</code>&#13;
<code class="kr">import</code> <code class="nx">_</code> <code class="nx">from</code> <code class="s2">"https://esm.sh/lodash@4.17.21"</code></pre>&#13;
&#13;
<p><a data-primary="ts-ignore" data-type="indexterm" id="id448"/><code>ts-ignore</code> removes the <em>next</em> line from type-checking and can be used everywhere you want to ignore type errors (see <a data-type="xref" href="#ch01_item_migrating">Recipe 1.4</a>). This effectively means that you won’t get any type information for your dependencies and you might run into errors, but it might be the ultimate solution for unmaintained, old dependencies that you just need but won’t find any types for.<a data-startref="ix_0801-asciidoc2" data-type="indexterm" id="id449"/><a data-startref="ix_0801-asciidoc1" data-type="indexterm" id="id450"/><a data-startref="ix_0801-asciidoc0" data-type="indexterm" id="id451"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.9 Loading Different Module Types in Node" data-type="sect1"><div class="sect1" id="ch01_item_modules">&#13;
<h1>1.9 Loading Different Module Types in Node</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id18">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="CommonJS" data-type="indexterm" id="ix_0901-asciidoc0"/><a data-primary="ECMAScript" data-secondary="loading different module types in Node.js" data-type="indexterm" id="ix_0901-asciidoc1"/><a data-primary="modules" data-secondary="loading different module types in Node.js" data-type="indexterm" id="ix_0901-asciidoc2"/><a data-primary="Node.js" data-secondary="loading different module types in" data-type="indexterm" id="ix_0901-asciidoc3"/><a data-primary="project setup" data-secondary="loading different module types in Node.js" data-type="indexterm" id="ix_0901-asciidoc4"/><a data-primary="project setup" data-secondary="loading types in Node" data-type="indexterm" id="ix_0901-asciidoc5"/>You want to use ECMAScript modules in Node.js and the CommonJS interoperability feature for libraries.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id452">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Set TypeScript’s module resolution to <code>"nodeNext"</code> and name your files <em>.mts</em> or <em>.cts</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id19">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>With the advent of Node.js, the CommonJS module system has become one of the most popular module systems in the JavaScript ecosystem.</p>&#13;
&#13;
<p>The idea is simple and effective: define exports in one module and require them &#13;
<span class="keep-together">in another:</span></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// person.js</code>&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">printPerson</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// index.js</code>&#13;
<code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"./person"</code><code class="p">);</code>&#13;
<code class="nx">person</code><code class="p">.</code><code class="nx">printPerson</code><code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code> <code class="p">});</code></pre>&#13;
&#13;
<p>This system has been a huge influence on ECMAScript modules and also has been the default for TypeScript’s module resolution and transpiler. If you look at the ECMAScript modules syntax in <a data-type="xref" href="#listing_cts">Example 1-1</a>, you can see that the keywords allow for different transpilations. This means that with the <code>commonjs</code> module setting, your <code>import</code> and <code>export</code> statements are transpiled to <code>require</code> and <code>exports</code>.</p>&#13;
<div data-type="example" id="listing_cts">&#13;
<h5><span class="label">Example 1-1. </span>Using the ECMAScript module system</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// person.ts</code>&#13;
<code class="nx">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="nx">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="nx">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// index.ts</code>&#13;
<code class="kr">import</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">person</code> <code class="nx">from</code> <code class="s2">"./person"</code><code class="p">;</code>&#13;
<code class="nx">person</code><code class="p">.</code><code class="nx">printPerson</code><code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code> <code class="p">});</code></pre></div>&#13;
&#13;
<p>With ECMAScript modules stabilizing, Node.js has also started to adopt them. Even though the basics of both module systems seem to be very similar, there are some differences in the details, such as handling default exports or loading ECMAScript modules asynchronously.</p>&#13;
&#13;
<p>As there is no way to treat both module systems the same but with different syntax, the Node.js maintainers decided to give both systems room and assigned different file endings to indicate the preferred module type. <a data-type="xref" href="#table_mjs_cjs_js">Table 1-1</a> shows the different endings, how they’re named in TypeScript, what TypeScript compiles them to, and what they can import. Thanks to the CommonJS interoperability, it’s fine to import CommonJS modules from ECMAScript modules, but not the other way around.</p>&#13;
<table id="table_mjs_cjs_js">&#13;
<caption><span class="label">Table 1-1. </span>Module endings and what they import</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Ending</th>&#13;
<th>TypeScript</th>&#13;
<th>Compiles to</th>&#13;
<th>Can import</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><em>.js</em></p></td>&#13;
<td><p><em>.ts</em></p></td>&#13;
<td><p>CommonJS</p></td>&#13;
<td><p><em>.js</em>, <em>.cjs</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>.cjs</em></p></td>&#13;
<td><p><em>.cts</em></p></td>&#13;
<td><p>CommonJS</p></td>&#13;
<td><p><em>.js</em>, <em>.cjs</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>.mjs</em></p></td>&#13;
<td><p><em>.mts</em></p></td>&#13;
<td><p>ES Modules</p></td>&#13;
<td><p><em>.js</em>, <em>.cjs</em>, <em>.mjs</em></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Library developers who publish on NPM get extra information in their <em>package.json</em> file to indicate the main type of a package (<code>module</code> or <code>commonjs</code>), and to point to a list of main files or fallbacks so module loaders can pick up the right file:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// package.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"dependency"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"type"</code><code class="p">:</code><code class="w"> </code><code class="s2">"module"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"exports"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">"."</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="c1">// Entry-point for `import "dependency"` in ES Modules</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"import"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./esm/index.js"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="c1">// Entry-point for `require("dependency") in CommonJS</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"require"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./commonjs/index.cjs"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">     </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// CommonJS Fallback</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"main"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./commonjs/index.cjs"</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In TypeScript, you write mainly ECMAScript module syntax and let the compiler decide which module format to create in the end. Now there are possibly two: CommonJS and ECMAScript modules.</p>&#13;
&#13;
<p>To allow for both, you can set module resolution in your <em>tsconfig.json</em> to <code>NodeNext</code>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"NodeNext"</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>With that flag, TypeScript will pick up the right modules as described in your dependencies <em>package.json</em>, will recognize <em>.mts</em> and <em>.cts</em> endings, and will follow <a data-type="xref" href="#table_mjs_cjs_js">Table 1-1</a> for module imports.</p>&#13;
&#13;
<p>For you as a developer, there are differences in importing files. Since CommonJS didn’t require endings when importing, TypeScript still supports imports without endings. The example in <a data-type="xref" href="#listing_cts">Example 1-1</a> still works, if all you use is CommonJS.</p>&#13;
&#13;
<p class="pagebreak-before">Importing with file endings, just like in <a data-type="xref" href="#ch01_item_es_modules">Recipe 1.8</a>, allows modules to be imported in both ECMAScript modules and CommonJS modules:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// index.mts</code>&#13;
<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">person</code> <code class="nx">from</code> <code class="s2">"./person.js"</code><code class="p">;</code> <code class="c1">// works in both</code>&#13;
<code class="nx">person</code><code class="p">.</code><code class="nx">printPerson</code><code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">});</code></pre>&#13;
&#13;
<p>Should CommonJS interoperability not work, you can always fall back on a <code>require</code> statement. Add <code>"node"</code> as global types to your compiler options:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// tsconfig.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"NodeNext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"types"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"node"</code><code class="p">],</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Then, import with this TypeScript-specific syntax:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// index.mts</code>&#13;
<code class="kr">import</code> <code class="nx">person</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"./person.cjs"</code><code class="p">);</code>&#13;
&#13;
<code class="nx">person</code><code class="p">.</code><code class="nx">printPerson</code><code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code> <code class="p">});</code></pre>&#13;
&#13;
<p>In a CommonJS module, this will be just another <code>require</code> call; in ECMAScript modules, this will include Node.js helper functions:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// compiled index.mts</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">createRequire</code> <code class="nx">as</code> <code class="nx">_createRequire</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"module"</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">__require</code> <code class="o">=</code> <code class="nx">_createRequire</code><code class="p">(</code><code class="kr">import</code><code class="p">.</code><code class="nx">meta</code><code class="p">.</code><code class="nx">url</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="nx">__require</code><code class="p">(</code><code class="s2">"./person.cjs"</code><code class="p">);</code>&#13;
<code class="nx">person</code><code class="p">.</code><code class="nx">printPerson</code><code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code> <code class="p">});</code></pre>&#13;
&#13;
<p>Note that this will reduce compatibility with non-Node.js environments like the browser, but it might eventually fix interoperability issues.<a data-startref="ix_0901-asciidoc5" data-type="indexterm" id="id453"/><a data-startref="ix_0901-asciidoc4" data-type="indexterm" id="id454"/><a data-startref="ix_0901-asciidoc3" data-type="indexterm" id="id455"/><a data-startref="ix_0901-asciidoc2" data-type="indexterm" id="id456"/><a data-startref="ix_0901-asciidoc1" data-type="indexterm" id="id457"/><a data-startref="ix_0901-asciidoc0" data-type="indexterm" id="id458"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.10 Working with Deno and Dependencies" data-type="sect1"><div class="sect1" id="id290">&#13;
<h1>1.10 Working with Deno and Dependencies</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id20">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="Deno" data-type="indexterm" id="ix_1001-asciidoc0"/><a data-primary="project setup" data-secondary="working with Deno and dependencies" data-type="indexterm" id="ix_1001-asciidoc1"/>You want to use TypeScript with Deno, a modern JavaScript runtime for applications outside the browser.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id459">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>That’s easy; TypeScript is built in.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id21">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="Node.js" data-secondary="Deno versus" data-type="indexterm" id="id460"/>Deno is a modern JavaScript runtime created by the same people who developed Node.js. Deno is similar to Node.js in many ways, but with significant differences:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Deno adopts web platform standards for their main APIs, meaning that you will find it easier to port code from the browser to the server.</p>&#13;
</li>&#13;
<li>&#13;
<p>It allows file system or network access only if you explicitly activate it.</p>&#13;
</li>&#13;
<li>&#13;
<p>It doesn’t handle dependencies via a centralized registry, but—again adopting browser features—via URLs.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Oh, and it comes with built-in development tooling and TypeScript!</p>&#13;
&#13;
<p>Deno is the tool with the lowest barrier if you want to try TypeScript. No need to download any other tool (the <code>tsc</code> compiler is already built in), no need for TypeScript configurations. You write <em>.ts</em> files, and Deno handles the rest:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// main.ts</code>&#13;
<code class="kd">function</code> <code class="nx">sayHello</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Hello </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">sayHello</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">);</code></pre>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>deno<code class="w"> </code>run<code class="w"> </code>main.ts<code class="w"/></pre>&#13;
&#13;
<p>Deno’s TypeScript can do everything <code>tsc</code> can do, and it is updated with every Deno update. However, there are some differences when you want to configure it.</p>&#13;
&#13;
<p>First, the default configuration has differences in its default settings as opposed to the default configuration issued by <code>tsc --init</code>. Strict mode feature flags are set differently, and it includes support for React (on the server side!).</p>&#13;
&#13;
<p>To make changes to the configuration, you should create a <em>deno.json</em> file in your root folder. Deno will automatically pick this up, unless you tell it not to. <em>deno.json</em> includes several configurations for the Deno runtime, including TypeScript compiler options:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Your TSC compiler options</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"fmt"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Options for the auto-formatter</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"lint"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Options for the linter</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>You can see more possibilities on the <a href="https://oreil.ly/zGA--">Deno website</a>.</p>&#13;
&#13;
<p>The default libraries are different as well. Even though Deno supports web platform standards and has browser-compatible APIs, it needs to make some cuts because there is no graphical user interface. That’s why some types—for example, the DOM library—clash with what Deno provides.</p>&#13;
&#13;
<p>Some libraries of interest are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>deno.ns</em>, the default Deno namespace</p>&#13;
</li>&#13;
<li>&#13;
<p><em>deno.window</em>, the global object for Deno</p>&#13;
</li>&#13;
<li>&#13;
<p><em>deno.worker</em>, the equivalent for Web Workers in the Deno runtime</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>DOM and subsets are included in Deno, but they are not switched on by default. If your application targets both the browser and Deno, configure Deno to include all browser and Deno libraries:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">// deno.json</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"target"</code><code class="p">:</code><code class="w"> </code><code class="s2">"esnext"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"lib"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"dom"</code><code class="p">,</code><code class="w"> </code><code class="s2">"dom.iterable"</code><code class="p">,</code><code class="w"> </code><code class="s2">"dom.asynciterable"</code><code class="p">,</code><code class="w"> </code><code class="s2">"deno.ns"</code><code class="p">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p><a href="https://alephjs.org">Aleph.js</a> is an example of a framework that targets both Deno and the browser.</p>&#13;
&#13;
<p><a data-primary="dependencies" data-secondary="Deno and" data-type="indexterm" id="id461"/>Also different with Deno is how type information for dependencies is distributed. External dependencies in Deno are loaded via URLs from a CDN. Deno itself hosts its standard library at <a class="bare" href="https://deno.land/std"><em class="hyperlink">https://deno.land/std</em></a>.</p>&#13;
&#13;
<p>But you can also use CDNs like <a href="https://esm.sh">esm.sh</a> or <a href="https://unpkg.com">unpkg</a>, like in <a data-type="xref" href="#ch01_item_es_modules">Recipe 1.8</a>. These CDNs distribute types by sending an <code>X-TypeScript-Types</code> header with the HTTP request, showing Deno was to load type declarations. This also goes for dependencies that don’t have first-party type declarations but rely on &#13;
<span class="keep-together">Definitely</span> Typed.</p>&#13;
&#13;
<p>So the moment you install your dependency, Deno will fetch not only the source files but also all the type information.</p>&#13;
&#13;
<p>If you don’t load a dependency from a CDN but rather have it locally, you can point to a type declaration file the moment you import the dependency:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// @deno-types="./charting.d.ts"</code>&#13;
<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">charting</code> <code class="nx">from</code> <code class="s2">"./charting.js"</code><code class="p">;</code></pre>&#13;
&#13;
<p class="pagebreak-before">or include a reference to the typings in the library itself:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// charting.js</code>&#13;
<code class="c1">/// &lt;reference types="./charting.d.ts" /&gt;</code></pre>&#13;
&#13;
<p><a data-primary="triple-slash directives" data-type="indexterm" id="id462"/>This reference is also called a <em>triple-slash directive</em> and is a TypeScript feature, not a Deno feature. There are various triple-slash directives, mostly used for pre-ECMAScript module dependency systems. The <a href="https://oreil.ly/EvUWm">documentation</a> gives a really good overview. If you stick with ECMAScript modules, you most likely won’t use triple-slash directives, though.<a data-startref="ix_1001-asciidoc1" data-type="indexterm" id="id463"/><a data-startref="ix_1001-asciidoc0" data-type="indexterm" id="id464"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="1.11 Using Predefined Configurations" data-type="sect1"><div class="sect1" id="ch01_item_configurations">&#13;
<h1>1.11 Using Predefined Configurations</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id22">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="configurations, predefined" data-type="indexterm" id="ix_1101-asciidoc0"/><a data-primary="project setup" data-secondary="using predefined configurations" data-type="indexterm" id="ix_1101-asciidoc1"/>You want to use TypeScript for a certain framework or platform but don’t know where to start with your configuration.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id23">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="tsconfig/bases" data-type="indexterm" id="id465"/>Use a predefined configuration from <a href="https://oreil.ly/ljsVT"><em>tsconfig/bases</em></a> and extend from there.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id24">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Just like Definitely Typed hosts community-maintained type definitions for popular libraries, <em>tsconfig/bases</em> hosts a set of community-maintained recommendations for TypeScript configurations you can use as a starting point for your own project. This includes frameworks like Ember.js, Svelte, or Next.js as well as JavaScript runtimes like Node.js and Deno.</p>&#13;
&#13;
<p>The configuration files are reduced to a minimum, dealing mostly with recommended libraries, modules, and target settings, and a bunch of strict mode flags that make sense for the respective environment.</p>&#13;
&#13;
<p>For example, this is the recommended configuration for Node.js 18, with a recommended strict mode setting and with ECMAScript modules:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"$schema"</code><code class="p">:</code><code class="w"> </code><code class="s2">"https://json.schemastore.org/tsconfig"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"display"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Node 18 + ESM + Strictest"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"lib"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">      </code><code class="s2">"es2022"</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">],</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"es2022"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"target"</code><code class="p">:</code><code class="w"> </code><code class="s2">"es2022"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"esModuleInterop"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"skipLibCheck"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"forceConsistentCasingInFileNames"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"moduleResolution"</code><code class="p">:</code><code class="w"> </code><code class="s2">"node"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"allowUnusedLabels"</code><code class="p">:</code><code class="w"> </code><code class="kc">false</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"allowUnreachableCode"</code><code class="p">:</code><code class="w"> </code><code class="kc">false</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"exactOptionalPropertyTypes"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"noFallthroughCasesInSwitch"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"noImplicitOverride"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"noImplicitReturns"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"noPropertyAccessFromIndexSignature"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"noUncheckedIndexedAccess"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"noUnusedLocals"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"noUnusedParameters"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"importsNotUsedAsValues"</code><code class="p">:</code><code class="w"> </code><code class="s2">"error"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"checkJs"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>To use this configuration, install it via NPM:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>npm<code class="w"> </code>install<code class="w"> </code>--save-dev<code class="w"> </code>@tsconfig/node18-strictest-esm<code class="w"/></pre>&#13;
&#13;
<p>and wire it up in your own TypeScript configuration:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"extends"</code><code class="p">:</code><code class="w"> </code><code class="s2">"@tsconfig/node18-strictest-esm/tsconfig.json"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>This will pick up all the settings from the predefined configuration. You can now start setting your own properties, for example, root and out directories.<a data-startref="ix_1101-asciidoc1" data-type="indexterm" id="id466"/><a data-startref="ix_1101-asciidoc0" data-type="indexterm" id="id467"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id393"><sup><a href="ch01.html#id393-marker">1</a></sup> Objects assigned to a <code>const</code> binding can still change values and properties, and thus change their types.</p><p data-type="footnote" id="id406"><sup><a href="ch01.html#id406-marker">2</a></sup> TypeScript also works in other JavaScript runtimes, such as Deno and the browser, but they are not intended as main targets.</p></div></div></section></body></html>