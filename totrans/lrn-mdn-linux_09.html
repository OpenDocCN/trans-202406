<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Advanced Topics"><div class="chapter" id="advanced">
<h1><span class="label">Chapter 9. </span>Advanced Topics</h1>


<p>This final chapter is a bit of a mixed bag. We cover
a range of topics, from virtual machines to security to new ways to
use Linux. What the topics in this chapter have in common is that most of
them are relevant for you only if you have a specific use case in mind,
or if you require them in a professional setup.</p>

<p>We start off the chapter with how processes on a single machine can communicate
and share data. There is a wealth of interprocess communication (IPC) mechanisms
available, and here we focus on well-established and -used features: signals, named pipes,
and Unix domain sockets.</p>

<p>Then, we look at virtual machines (VMs). In contrast to the containers
we discussed in <a data-type="xref" href="ch06.xhtml#containers">“Containers”</a> (which are good for application-level dependency
management), VMs provide strong isolation for your workloads. You come across
VMs most often in the context of the public cloud and in the general case in
data centers. Having said that, using VMs locally can also be useful, such as for testing or to simulate distributed systems.</p>

<p>The next section in this chapter focuses on modern Linux distributions, which
are usually container-centric and assume immutability. You’ll often find said distros in the context of distributed systems such as Kubernetes.</p>

<p>We then move on to selected security topics, covering Kerberos, a widely used
authentication suite, and pluggable authentication modules (PAM), an extension
mechanism Linux provides for authentication.</p>

<p>In the last part of this chapter, we review Linux solutions and use cases that,
at the time of writing, are not yet mainstream. But they could be relevant to you
and are worth exploring.</p>






<section data-type="sect1" data-pdf-bookmark="Interprocess Communication"><div class="sect1" id="ipc">
<h1>Interprocess Communication</h1>

<p><a data-type="indexterm" data-primary="interprocess communication (IPC)" id="ix_ch09-asciidoc0"/>In Linux there is a long list of
<a href="https://oreil.ly/tWp40">interprocess communication
(IPC)</a> options available, ranging from pipes to sockets to shared memory. IPC enables
processes to communicate, synchronize activities, and share data. For example,
the <a href="https://oreil.ly/aZur8">Docker daemon</a>
uses configurable sockets to manage containers. In this section, we review some
popular IPC options and their use cases.</p>








<section data-type="sect2" data-pdf-bookmark="Signals"><div class="sect2" id="signals">
<h2>Signals</h2>

<p><a data-type="indexterm" data-primary="interprocess communication (IPC)" data-secondary="signals" id="idm45805425920304"/><a data-type="indexterm" data-primary="signals" data-secondary="about" id="idm45805425919312"/><a href="https://oreil.ly/0y6ru"><em>Signals</em></a> were originally
developed as a way for the kernel to notify user space processes about a
certain event. Think of signals as an asynchronous notification sent to a process.
There are many signals available (use the <code>man 7 signal</code> command to learn more),
and most of them come with a default action, such as stop or terminate the process.</p>

<p>With most signals, you define a custom handler, rather than letting Linux carry
on with the default action. This is useful when you want to, for example,
do some clean-up work or simply ignore certain signals. <a data-type="xref" href="#tab-signals">Table 9-1</a> shows
the most common signals that you should be familiar with.</p>
<table id="tab-signals">
<caption><span class="label">Table 9-1. </span>Common signals</caption>
<thead>
<tr>
<th>Signal</th>
<th>Meaning</th>
<th>Default action</th>
<th>Handle option</th>
<th>Key combination</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>SIGHUP</code></p></td>
<td><p>Tell a daemon process to reread its config file</p></td>
<td><p>Terminate process</p></td>
<td><p><code>nohup</code> or custom handler</p></td>
<td><p>N/A</p></td>
</tr>
<tr>
<td><p><code>SIGINT</code></p></td>
<td><p>User interruption from keyboard</p></td>
<td><p>Terminate process</p></td>
<td><p>Custom handler</p></td>
<td><p>Ctrl+C</p></td>
</tr>
<tr>
<td><p><code>SIGQUIT</code></p></td>
<td><p>User quit from keyboard</p></td>
<td><p><a href="https://oreil.ly/jeuEo">core dump</a> and terminate process</p></td>
<td><p>Custom handler</p></td>
<td><p>Ctrl+\</p></td>
</tr>
<tr>
<td><p><code>SIGKILL</code></p></td>
<td><p>Kill signal</p></td>
<td><p>Terminate process</p></td>
<td><p>Cannot be handled</p></td>
<td><p>N/A</p></td>
</tr>
<tr>
<td><p><code>SIGSTOP</code></p></td>
<td><p>Stop process</p></td>
<td><p>Stop process</p></td>
<td><p>Cannot be handled</p></td>
<td><p>N/A</p></td>
</tr>
<tr>
<td><p><code>SIGTSTP</code></p></td>
<td><p>User caused stop from keyboard</p></td>
<td><p>Stop process</p></td>
<td><p>Custom handler</p></td>
<td><p>Ctrl+Z</p></td>
</tr>
<tr>
<td><p><code>SIGTERM</code></p></td>
<td><p>Graceful termination</p></td>
<td><p>Terminate process</p></td>
<td><p>Custom handler</p></td>
<td><p>N/A</p></td>
</tr>
</tbody>
</table>

<p>There are also signals that don’t have defined meanings (<code>SIGUSR1</code> and <code>SIGUSR2</code>)
that processes can use to communicate with each other, sending asynchronous
notification, if both parties agree on the semantics of the signal.</p>

<p>One typical way to send a signal to a process is the somewhat strangely named
<code>kill</code> command (due to its default behavior to cause processes to terminate):</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code class="k">while</code><code> </code><code class="nb">true</code><code> </code><code class="p">;</code><code> </code><code class="k">do</code><code> </code><code>sleep</code><code> </code><code class="m">1</code><code> </code><code class="p">;</code><code> </code><code class="k">done</code><code> </code><code class="p">&amp;</code><code> </code><a class="co" id="co_advanced_topics_CO1-1" href="#callout_advanced_topics_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="o">[</code><code class="m">1</code><code class="o">]</code><code> </code><code class="m">17030</code><code> </code><a class="co" id="co_advanced_topics_CO1-2" href="#callout_advanced_topics_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>

</code><code>$</code><code> </code><code>ps</code><code> </code><a class="co" id="co_advanced_topics_CO1-3" href="#callout_advanced_topics_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
  </code><code>PID</code><code> </code><code>TTY</code><code>          </code><code>TIME</code><code> </code><code>CMD</code><code>
</code><code class="m">16939</code><code> </code><code>pts/2</code><code>    </code><code class="m">00</code><code>:00:00</code><code> </code><code>bash</code><code>
</code><code class="m">17030</code><code> </code><code>pts/2</code><code>    </code><code class="m">00</code><code>:00:00</code><code> </code><code>bash</code><code> </code><a class="co" id="co_advanced_topics_CO1-4" href="#callout_advanced_topics_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code class="m">17041</code><code> </code><code>pts/2</code><code>    </code><code class="m">00</code><code>:00:00</code><code> </code><code>sleep</code><code>
</code><code class="m">17045</code><code> </code><code>pts/2</code><code>    </code><code class="m">00</code><code>:00:00</code><code> </code><code>ps</code><code>

</code><code>$</code><code> </code><code class="nb">kill</code><code> </code><code class="m">17030</code><code> </code><a class="co" id="co_advanced_topics_CO1-5" href="#callout_advanced_topics_CO1-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>
</code><code class="o">[</code><code class="m">1</code><code class="o">]</code><code>+</code><code>  </code><code>Terminated</code><code>              </code><code class="k">while</code><code> </code><code>true</code><code class="p">;</code><code> </code><code class="k">do</code><code>
    </code><code>sleep</code><code> </code><code class="m">1</code><code class="p">;</code><code>
</code><code class="k">done</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_advanced_topics_CO1-1" href="#co_advanced_topics_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>We set up a very simple program here that simply sleeps. With <code>&amp;</code>, we
put it into the background.</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO1-2" href="#co_advanced_topics_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The shell job control confirms that our program runs as a job with ID 1 in
the background and reports its PID (<code>17030</code>).</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO1-3" href="#co_advanced_topics_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Using <code>ps</code>, we check if the program is still running.</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO1-4" href="#co_advanced_topics_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Here is our program (compare PID).</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO1-5" href="#co_advanced_topics_CO1-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>By default, <code>kill</code> sends the <code>SIGTERM</code> to the process, and the default action
is to terminate the process gracefully. We provide <code>kill</code> with the PID of our process (<code>17030</code>), and since we didn’t register a custom handler, it is
terminated.</p></dd>
</dl>

<p>Now we’ll look at how to handle a signal with
<a href="https://oreil.ly/pp6O4"><code>trap</code></a>. This allows us
to define a custom handler in a shell environment (command line
or script):</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code class="nb">trap</code><code> </code><code class="s2">"echo kthxbye"</code><code> </code><code>SIGINT</code><code> </code><code class="p">;</code><code> </code><code class="k">while</code><code> </code><code class="nb">true</code><code> </code><code class="p">;</code><code> </code><code class="k">do</code><code> </code><code>sleep</code><code> </code><code class="m">1</code><code> </code><code class="p">;</code><code> </code><code class="k">done</code><code> </code><a class="co" id="co_advanced_topics_CO2-1" href="#callout_advanced_topics_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>^Ckthxbye</code><code> </code><a class="co" id="co_advanced_topics_CO2-2" href="#callout_advanced_topics_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_advanced_topics_CO2-1" href="#co_advanced_topics_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>With <code>trap "echo kthxbye" SIGINT</code>, we register a handler, telling Linux
that when the user presses Ctrl+C (causing a <code>SIGINT</code> signal to be sent to
our process), Linux should execute <code>echo kthxbye</code> before the default action (terminate).</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO2-2" href="#co_advanced_topics_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>We see the user interruption (<code>^C</code> is the same as Ctrl+C) and then our
custom handler getting executed, printing <code>kthxbye</code>, as expected.</p></dd>
</dl>

<p class="pagebreak-after">Signals are a simple yet powerful IPC mechanism, and now you know the basics of
how to send and handle signals in Linux. Next up, we discuss two more elaborate
and powerful IPC mechanisms—named pipes and UNIX domain sockets.</p>
</div></section>













<section data-type="sect2" class="less_space" data-pdf-bookmark="Named Pipes"><div class="sect2" id="npipes">
<h2>Named Pipes</h2>

<p><a data-type="indexterm" data-primary="interprocess communication (IPC)" data-secondary="named pipes" id="idm45805425699744"/><a data-type="indexterm" data-primary="named pipes" id="idm45805425698528"/><a data-type="indexterm" data-primary="pipes (|)" data-secondary="named" id="idm45805425697856"/>In <a data-type="xref" href="ch03.xhtml#shell-streams">“Streams”</a>, we talked about pipes (<code>|</code>) that you can use to pass
data from one process to another by connecting the <code>stdout</code> of one process with
<code>stdin</code> of another process.  We call these pipes <em>unnamed</em>. Taking this idea a step further,
<a href="https://oreil.ly/iHMrK">named pipes</a> are pipes to which you
can assign custom names.</p>

<p>Just like unnamed pipes, named pipes work with normal file I/O (<code>open</code>, <code>write</code>, etc.)
and provide first in, first out (FIFO) delivery. Unlike unnamed pipes, the lifetime
of a named pipe is not limited to the processes it’s used with. Technically,
named pipes are a wrapper around pipes, using the <code>pipefs</code> pseudo filesystem
(see <a data-type="xref" href="ch05.xhtml#pseudo-fs">“Pseudo Filesystems”</a>).</p>

<p>Let’s see a named pipe in action to better appreciate what you can do with
them. We create a named pipe called <code>examplepipe</code> in the following, along with
one publisher and one consumer process:</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>mkfifo</code><code> </code><code>examplepipe</code><code> </code><a class="co" id="co_advanced_topics_CO3-1" href="#callout_advanced_topics_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>

</code><code>$</code><code> </code><code>ls</code><code> </code><code>-l</code><code> </code><code>examplepipe</code><code>
</code><code>prw-rw-r--</code><code> </code><code class="m">1</code><code> </code><code>mh9</code><code> </code><code>mh9</code><code> </code><code class="m">0</code><code> </code><code>Oct</code><code>  </code><code class="m">2</code><code> </code><code class="m">14</code><code>:04</code><code> </code><code>examplepipe</code><code> </code><a class="co" id="co_advanced_topics_CO3-2" href="#callout_advanced_topics_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>

</code><code>$</code><code> </code><code class="k">while</code><code> </code><code class="nb">true</code><code> </code><code class="p">;</code><code> </code><code class="k">do</code><code> </code><code class="nb">echo</code><code> </code><code class="s2">"x"</code><code> </code><code>&gt;</code><code> </code><code>examplepipe</code><code> </code><code class="p">;</code><code> </code><code>sleep</code><code> </code><code class="m">5</code><code> </code><code class="p">;</code><code> </code><code class="k">done</code><code> </code><code class="p">&amp;</code><code> </code><a class="co" id="co_advanced_topics_CO3-3" href="#callout_advanced_topics_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code class="o">[</code><code class="m">1</code><code class="o">]</code><code> </code><code class="m">19628</code><code>

</code><code>$</code><code> </code><code class="k">while</code><code> </code><code class="nb">true</code><code> </code><code class="p">;</code><code> </code><code class="k">do</code><code> </code><code>cat</code><code> </code><code>&lt;</code><code> </code><code>examplepipe</code><code> </code><code class="p">;</code><code> </code><code>sleep</code><code> </code><code class="m">5</code><code> </code><code class="p">;</code><code> </code><code class="k">done</code><code> </code><code class="p">&amp;</code><code> </code><a class="co" id="co_advanced_topics_CO3-4" href="#callout_advanced_topics_CO3-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code class="o">[</code><code class="m">2</code><code class="o">]</code><code> </code><code class="m">19636</code><code>
</code><code>x</code><code> </code><a class="co" id="co_advanced_topics_CO3-5" href="#callout_advanced_topics_CO3-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>
</code><code>x</code><code>
</code><code>...</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_advanced_topics_CO3-1" href="#co_advanced_topics_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>We create a named pipe called <code>examplepipe</code>.</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO3-2" href="#co_advanced_topics_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Looking at the pipe with <code>ls</code> reveals its type: the first letter is a <code>p</code>,
indicating it’s a named pipe we’re looking at.</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO3-3" href="#co_advanced_topics_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Using a loop, we publish the character <code>x</code> into our pipe. Note that unless
some other process reads from <code>examplepipe</code>, the pipe is blocked.
No further writing into it is possible.</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO3-4" href="#co_advanced_topics_CO3-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>We launch a second process that reads from the pipe in a loop.</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO3-5" href="#co_advanced_topics_CO3-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>As a result of our setup we see <code>x</code> appearing on the terminal, roughly
every five seconds. In other words, it appears every time the process with PID
<code>19636</code> is able to read from the named pipe with <code>cat</code>.</p></dd>
</dl>

<p>Named pipes are easy to use. Thanks to their design, they look and feel like
normal files. But they’re also limited, since they support only one direction
and one consumer. The next IPC mechanism we look at addresses these limitations.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="UNIX Domain Sockets"><div class="sect2" id="usock">
<h2>UNIX Domain Sockets</h2>

<p><a data-type="indexterm" data-primary="domain sockets" id="idm45805425557344"/><a data-type="indexterm" data-primary="interprocess communication (IPC)" data-secondary="UNIX domain sockets" id="idm45805425556640"/><a data-type="indexterm" data-primary="UNIX domain sockets" id="idm45805425555728"/>We’ve already talked about sockets in the context of networking. There are also
other kinds of sockets that work exclusively in the context of a single machine,
and one such kind is called <a href="https://oreil.ly/nCd6r">UNIX
domain sockets</a>: these are bidirectional, multiway communication endpoints.
This means you can have multiple 
<span class="keep-together">consumers.</span></p>

<p>Domain sockets come in <a href="https://oreil.ly/AlVUf">three
flavors</a>: stream-oriented (<code>SOCK_STREAM</code>), datagram-oriented (<code>SOCK_DGRAM</code>), and sequenced-packet (<code>SOCK_SEQPACKET</code>). The addressing works based on filesystem pathnames. Rather than
having IP addresses and ports, a simple file path is sufficient.</p>

<p>Usually, you would be using domain sockets
<a href="https://oreil.ly/o8Ikj">programmatically</a>.
However, you might find yourself in a situation where you need to troubleshoot
a system and want to use, for example, the <a href="https://oreil.ly/lWjrs"><code>socat</code>
tool</a> from the command line to interact manually with a socket.<a data-type="indexterm" data-startref="ix_ch09-asciidoc0" id="idm45805425549072"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Virtual Machines"><div class="sect1" id="virtual-machines">
<h1>Virtual Machines</h1>

<p><a data-type="indexterm" data-primary="virtual machines (VMs)" id="ix_ch09-asciidoc1"/>This section is about an established technique that allows us to emulate
multiple VMs using a physical machine such as your
laptop or a server in a data center. This yields a more flexible and powerful
way to run different workloads, potentially from different tenants in a strongly
isolated manner. We focus on hardware-assisted virtualization for x86
architectures.</p>

<p>In <a data-type="xref" href="#fig-virt">Figure 9-1</a>, you see the virtualization architecture on a conceptual level, comprising the following (starting from the bottom):</p>
<dl>
<dt>The CPU</dt>
<dd>
<p>Must support hardware virtualization.</p>
</dd>
<dt>The kernel-based virtual machine</dt>
<dd>
<p>Found in the Linux kernel; discussed in <a data-type="xref" href="#kvm">“Kernel-Based Virtual Machine”</a>.</p>
</dd>
<dt>Components in the user space</dt>
<dd>
<p>Components in the user space include the following:</p>
<dl>
<dt>A Virtual Machine Monitor (VMM)</dt>
<dd>
<p>Manages VMs and emulates
   virtual devices, such as  <a href="https://www.qemu.org">QEMU</a> and Firecracker
   (see <a data-type="xref" href="#firecracker">“Firecracker”</a>). There is also <a href="https://libvirt.org">libvirt</a>, a
   library that exposes a generic API aiming to standardize VMM,
   which you can use programmatically (not explicitly shown in the figure;
   consider it part of the VMM block).</p>
</dd>
<dt>The guest kernel</dt>
<dd>
<p>Typically also a Linux kernel but could also be Windows.</p>
</dd>
<dt>The guest processes</dt>
<dd>
<p>Running on the guest kernel.</p>
</dd>
</dl>
</dd>
</dl>

<figure><div id="fig-virt" class="figure">
<img src="Images/lmlx_0901.png" alt="lmlx 0901" width="600" height="451"/>
<h6><span class="label">Figure 9-1. </span>Virtualization architecture</h6>
</div></figure>

<p>The processes that run natively on the host kernel (in <a data-type="xref" href="#fig-virt">Figure 9-1</a>, process 1 and process
2) are isolated from the guest processes. This means that in general the
physical CPU and memory of the host are not affected by guest activities. For
example, if there’s an attack going on in the VM, the host kernel and processes
are unaffected (as long as the VM is not given special access to the host
system). Note that there may be exceptions to this in practice, such
as <a href="https://oreil.ly/L7qH9">rowhammer</a> or
<a href="https://oreil.ly/ZlgRE">Meltdown and Spectre</a>.</p>








<section data-type="sect2" data-pdf-bookmark="Kernel-Based Virtual Machine"><div class="sect2" id="kvm">
<h2>Kernel-Based Virtual Machine</h2>

<p><a data-type="indexterm" data-primary="kernel-based virtual machine (KVM)" id="idm45805425525440"/><a data-type="indexterm" data-primary="virtual machines (VMs)" data-secondary="KVM" id="idm45805425524672"/>The <a href="https://oreil.ly/vTINW">Kernel-based Virtual Machine (KVM)</a>
is a Linux-native virtualization solution for x86 hardware that supports virtualization
extensions, such as the case with
<a href="https://oreil.ly/XXAM8"><span class="keep-together">AMD-V</span></a> or
<a href="https://oreil.ly/SAbNc">Intel VT</a>.</p>

<p class="pagebreak-after">There are two parts to the KVM kernel modules: the core module (<code>kvm.ko</code>) and
CPU architecture-specific modules (<code>kvm-intel.ko</code>/<code>kvm-amd.ko</code>). With KVM,
the Linux kernel is the hypervisor, taking care of most of the heavy lifting.
In addition, there are drivers such as the integrated
<a href="https://oreil.ly/g37Qe">Virtio</a> that allow for I/O 
<span class="keep-together">virtualization.</span></p>

<p>Today, hardware usually supports virtualization and KVM is already available,
but in order to see if your system is capable of using KVM, you can do
the following check (output edited):</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>grep</code><code> </code><code class="s1">'svm\|vmx'</code><code> </code><code>/proc/cpuinfo</code><code> </code><a class="co" id="co_advanced_topics_CO4-1" href="#callout_advanced_topics_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>flags</code><code>           </code><code>:</code><code> </code><code>fpu</code><code> </code><code>vme</code><code> </code><code>de</code><code> </code><code>pse</code><code> </code><code>tsc</code><code> </code><code>msr</code><code> </code><code>pae</code><code> </code><code>mce</code><code> </code><code>cx8</code><code> </code><code>apic</code><code> </code><code>sep</code><code> </code><code>mtrr</code><code> </code><code>pge</code><code> </code><code>mca</code><code> </code><code>cmov</code><code>
</code><code>pat</code><code> </code><code>pse36</code><code> </code><code>clflush</code><code> </code><code>dts</code><code> </code><code>acpi</code><code> </code><code>mmx</code><code> </code><code>fxsr</code><code> </code><code>sse</code><code> </code><code>sse2</code><code> </code><code>ss</code><code> </code><code>ht</code><code> </code><code>tm</code><code> </code><code>pbe</code><code> </code><code>syscall</code><code> </code><code>nx</code><code> </code><code>pdpe1gb</code><code>
</code><code>rdtscp</code><code> </code><code>lm</code><code> </code><code>constant_tsc</code><code> </code><code>art</code><code> </code><code>arch_perfmon</code><code> </code><code>pebs</code><code> </code><code>bts</code><code> </code><code>rep_good</code><code> </code><code>nopl</code><code> </code><code>xtopology</code><code>
</code><code>tsc_reliable</code><code> </code><code>nonstop_tsc</code><code> </code><code>cpuid</code><code> </code><code>aperfmperf</code><code> </code><code>tsc_known_freq</code><code> </code><code>pni</code><code> </code><code>pclmulqdq</code><code> </code><code>dtes64</code><code>
</code><code>ds_cpl</code><code> </code><code>vmx</code><code> </code><code>tm2</code><code> </code><code>ssse3</code><code> </code><code>sdbg</code><code> </code><code>cx16</code><code> </code><code>xtpr</code><code> </code><code>pdcm</code><code> </code><code>sse4_1</code><code> </code><code>sse4_2</code><code> </code><code>x2apic</code><code> </code><code>movbe</code><code> </code><code>popcnt</code><code> </code><a class="co" id="co_advanced_topics_CO4-2" href="#callout_advanced_topics_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>tsc_deadline_timer</code><code> </code><code>aes</code><code> </code><code>xsave</code><code> </code><code>rdrand</code><code> </code><code>lahf_lm</code><code> </code><code>3dnowprefetch</code><code> </code><code>cpuid_fault</code><code> </code><code>cat_l2</code><code>
</code><code>ibrs</code><code> </code><code>ibpb</code><code> </code><code>stibp</code><code> </code><code>tpr_shadow</code><code> </code><code>vnmi</code><code> </code><code>flexpriority</code><code> </code><code>ept</code><code> </code><code>vpid</code><code> </code><code>ept_ad</code><code> </code><code>fsgsbase</code><code> </code><code>tsc_adjust</code><code>
</code><code>smep</code><code> </code><code>erms</code><code> </code><code>mpx</code><code> </code><code>rdt_a</code><code> </code><code>rdseed</code><code> </code><code>smap</code><code> </code><code>clflushopt</code><code> </code><code>intel_pt</code><code> </code><code>sha_ni</code><code> </code><code>xsaveopt</code><code> </code><code>xsavec</code><code>
</code><code>xgetbv1</code><code> </code><code>xsaves</code><code> </code><code>dtherm</code><code> </code><code>ida</code><code> </code><code>arat</code><code> </code><code>pln</code><code> </code><code>pts</code><code> </code><code>md_clear</code><code> </code><code>arch_capabilities</code><code>
</code><code>...</code><code>

</code><code>$</code><code> </code><code>lsmod</code><code> </code><code class="p">|</code><code> </code><code>grep</code><code> </code><code>kvm</code><code> </code><a class="co" id="co_advanced_topics_CO4-3" href="#callout_advanced_topics_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>

</code><code>kvm_intel</code><code>             </code><code class="m">253952</code><code>  </code><code class="m">0</code><code> </code><a class="co" id="co_advanced_topics_CO4-4" href="#callout_advanced_topics_CO4-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>kvm</code><code>                   </code><code class="m">659456</code><code>  </code><code class="m">1</code><code> </code><code>kvm_intel</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_advanced_topics_CO4-1" href="#co_advanced_topics_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Search for <code>svm</code> or <code>vmx</code> in the CPU information (note that it reports on a per-CPU
basis, so if you have eight cores, you would see this <code>flags</code> block
repeated eight times).</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO4-2" href="#co_advanced_topics_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>We see <code>vmx</code> is listed, so we’re good concerning hardware-assisted

<span class="keep-together">virtualization.</span></p></dd>
<dt><a class="co" id="callout_advanced_topics_CO4-3" href="#co_advanced_topics_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Here we check if the KVM kernel modules are available.</p></dd>
<dt><a class="co" id="callout_advanced_topics_CO4-4" href="#co_advanced_topics_CO4-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>This tells us that we have the <code>kvm_intel</code> kernel module loaded, so we’re
all set concerning KVM usage.</p></dd>
</dl>

<p>One modern way to manage KVMs is with Firecracker.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Firecracker"><div class="sect2" id="firecracker">
<h2>Firecracker</h2>

<p><a data-type="indexterm" data-primary="Firecracker" id="idm45805425268336"/><a data-type="indexterm" data-primary="virtual machines (VMs)" data-secondary="Firecracker" id="idm45805425267632"/><a href="https://oreil.ly/UpNPK">Firecracker</a>
is a VMM that can manage KVM instances. It is written
in Rust and was developed at Amazon Web Services primarily for serverless offerings,
such as AWS Lambda and AWS Fargate.</p>

<p class="pagebreak-after">Firecracker is <a href="https://oreil.ly/6D8Wk">designed</a>
to safely run multitenant workloads on the same physical machine. The
<a data-type="indexterm" data-primary="microVMs" id="idm45805425264624"/>Firecracker VMM manages so-called <em>microVMs</em> that expose an HTTP API to the
host, allowing you to launch, query, and stop the microVMs. It emulates network
interfaces by using
<a href="https://oreil.ly/ojWvm">TUN/TAP devices</a>
on the host, and block devices are backed by files on the host, supporting Virtio
devices.</p>

<p><a data-type="indexterm" data-primary="seccomp" id="idm45805425262320"/><a data-type="indexterm" data-primary="security" data-secondary="Firecracker and" id="idm45805425261616"/>From a security perspective, in addition to the virtualization
discussed so far, Firecracker by default uses seccomp filters (see <a data-type="xref" href="ch04.xhtml#seccomp">“seccomp Profiles”</a>)
to limit the host system calls it can use. cgroups can also be used.
From an observability point of view, you can gather logs and metrics from Firecracker,
via named pipes.<a data-type="indexterm" data-startref="ix_ch09-asciidoc1" id="idm45805425259744"/></p>

<p>With that we move on to modern Linux distributions that focus on immutability and
leverage containers.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Modern Linux Distros"><div class="sect1" id="idm45805425547936">
<h1>Modern Linux Distros</h1>

<p><a data-type="indexterm" data-primary="Linux (generally)" data-secondary="distributions" id="ix_ch09-asciidoc2"/><a data-type="indexterm" data-primary="modern distros" id="ix_ch09-asciidoc3"/>The most prominent traditional Linux distributions include the following:</p>

<ul>
<li>
<p>The Red Hat family (RHEL, Fedora, and CentOS/Rocky)</p>
</li>
<li>
<p>The Debian-based family (Ubuntu, Mint, Kali, Parrot OS, elementary OS, etc.)</p>
</li>
<li>
<p>The SUSE family (openSUSE and Enterprise)</p>
</li>
<li>
<p>Gentoo</p>
</li>
<li>
<p>Arch Linux</p>
</li>
</ul>

<p>These are all perfectly fine distros. Depending on your needs and preferences,
you can choose from being fully in control and taking care of everything yourself
(from installation to patching) to having a fully managed offering where the distro
takes care of most of the tasks.</p>

<p>With the rise of containers, as discussed in <a data-type="xref" href="ch06.xhtml#containers">“Containers”</a>, the role of the
host operating system has changed. In the context of containers, traditional
package managers (see <a data-type="xref" href="ch06.xhtml#package-managers">“Packages and Package Managers”</a>) play a different role: most base
container images tend to be built from particular Linux distros, and dependencies
are met within the containers with <em>.deb</em> or <em>.rpm</em> packages, while the
container images package up all the application-level dependencies on top of them.</p>

<p>Further, making incremental changes to a system turns out to be a big challenge.
This is especially true when you need to do it at scale, such as when you need
to administrate a fleet of machines. Hence, for modern distros, the focus is
increasingly on immutability. The idea is that any change in the configuration
or code (think: a patch that fixes a security issue or a new feature) causes
the creation of a new artifact, such as a container image that gets launched
(in contrast to changing the running system).</p>

<p class="pagebreak-after">When I say “modern Linux distros,” I mean distros that are container-centric, with
immutability and auto-upgrading (pioneered by Chrome) front and center.
Let’s have a look at some examples of modern distros.</p>








<section data-type="sect2" class="less_space" data-pdf-bookmark="Red Hat Enterprise Linux CoreOS"><div class="sect2" id="idm45805425469712">
<h2>Red Hat Enterprise Linux CoreOS</h2>

<p><a data-type="indexterm" data-primary="CoreOS" id="idm45805425468272"/><a data-type="indexterm" data-primary="modern distros" data-secondary="CoreOS" id="idm45805425467568"/><a data-type="indexterm" data-primary="Red Hat Enterprise Linux CoreOS" id="idm45805425466624"/>In 2013, a young start-up called CoreOS
made <a href="https://oreil.ly/XjqPV">CoreOS Linux (later renamed
Container Linux)</a> available. Its main features included a  dual-partition scheme
for system updates and the lack of a package manager. In other words, all
apps would run as containers natively. In the ecosystem, a number of
tools were developed that are still in use (such as <code>etcd</code>; think: a distributed
version of the <em>/etc</em> directory for configuration tasks).</p>

<p>After Red Hat acquired CoreOS (the company), it announced the intention to
merge the CoreOS Linux with Red Hat’s own Project Atomic (that had similar
goals). This merger led to
<a href="https://oreil.ly/38kzX">Red Hat Enterprise Linux CoreOS (RHCOS)</a>,
which is not meant to be used on its own but in the context of the Red Hat
Kubernetes distribution called OpenShift Container Platform.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Flatcar Container Linux"><div class="sect2" id="idm45805425462512">
<h2>Flatcar Container Linux</h2>

<p><a data-type="indexterm" data-primary="Flatcar Container Linux" id="idm45805425461344"/><a data-type="indexterm" data-primary="modern distros" data-secondary="Flatcar" id="idm45805425460640"/>A little bit after Red Hat announced its plans around Container Linux,
a German startup called Kinvolk GmbH (now part of Microsoft) announced that
it would fork and continue to develop Container Linux under the new brand name
<a href="https://oreil.ly/rNJrt">Flatcar Container Linux</a>.</p>

<p>Flatcar describes itself as a container-native, lightweight operating system
with use cases in container orchestrators such as Kubernetes and IoT/edge computing.
It continues the CoreOS tradition of auto-upgrades (optional with its own
update manager, <a href="https://oreil.ly/Qepv6">Nebraska</a>) and has a powerful yet simple-to-use provisioning utility called
<a href="https://oreil.ly/4vEQv">Ignition</a>
that enables you to have fine-grained control over boot devices (also used by
RHCOS for that purpose). Further, there is no package manager; everything is
running in containers. You can manage the life cycle of the containerized apps
with <code>systemctl</code> on a single machine or more typically with Kubernetes.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Bottlerocket"><div class="sect2" id="idm45805425455904">
<h2>Bottlerocket</h2>

<p><a data-type="indexterm" data-primary="Bottlerocket" id="idm45805425454704"/><a data-type="indexterm" data-primary="modern distros" data-secondary="Bottlerocket" id="idm45805425454000"/><a href="https://oreil.ly/fIKrQ">Bottlerocket</a> is a
Linux-based operating system developed by AWS and meant for
<a href="https://oreil.ly/5Eaxd">hosting containers</a>.
Written in Rust, it is used in a number of their offerings, such as Amazon EKS
and Amazon ECS.</p>

<p>Akin to Flatcar and CoreOS, instead of a package manager, Bottlerocket uses an
OCI image-based model for app upgrades and rollbacks. Bottlerocket uses a
(by and large) read-only, integrity-checked filesystem based on
<a href="https://oreil.ly/xicaW">dm-verity</a>.
To gain access (via SSH, although discouraged) and control Bottlerocket, it runs a so-called
<a href="https://oreil.ly/KB6eX">control container</a>,
in a separate <code>containerd</code> instance.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="RancherOS"><div class="sect2" id="idm45805425448752">
<h2>RancherOS</h2>

<p><a data-type="indexterm" data-primary="modern distros" data-secondary="RancherOS" id="idm45805425447520"/><a data-type="indexterm" data-primary="RancherOS" id="idm45805425446544"/><a href="https://oreil.ly/73UxM">RancherOS</a> is a Linux distro where everything is
a container managed by Docker. Sponsored by Rancher (now SUSE), it is optimized
for container workloads as in their Kubernetes distro. It runs two Docker
instances: the system Docker, which runs as the first process, and the user Docker,
which is used to create application containers. RancherOS has a small footprint, which
makes it really great to use in the context of embedded systems and edge
computing.<a data-type="indexterm" data-startref="ix_ch09-asciidoc3" id="idm45805425445216"/><a data-type="indexterm" data-startref="ix_ch09-asciidoc2" id="idm45805425444512"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Selected Security Topics"><div class="sect1" id="idm45805425483280">
<h1>Selected Security Topics</h1>

<p><a data-type="indexterm" data-primary="security" data-seealso="access control" id="ix_ch09-asciidoc4"/>In <a data-type="xref" href="ch04.xhtml#access-control">Chapter 4</a>, we discussed a number of access control mechanisms.
We discussed <em>authentication</em> (<em>authn</em>, for short), which verifies the identity
of a user and is a precondition for any sort of <em>authorization</em> (<em>authz</em>, for short).
In this section, we briefly discuss two widely used authn tools that you
should be aware of.</p>








<section data-type="sect2" data-pdf-bookmark="Kerberos"><div class="sect2" id="kerberos">
<h2>Kerberos</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="Kerberos" id="idm45805425436464"/><a data-type="indexterm" data-primary="Kerberos" id="idm45805425435488"/><a data-type="indexterm" data-primary="security" data-secondary="Kerberos" id="idm45805425434816"/><a href="https://kerberos.org">Kerberos</a> is an authn suite developed by the
Massachusetts Institute of Technology in the 1980s. Today, it’s
formally specified in <a href="https://oreil.ly/7woDK">RFC 4120</a>
and related IETF documents. The core idea of Kerberos is that we’re usually
dealing with insecure networks, but we want a secure way for clients and
services to prove their identity to one another.</p>

<p>Conceptually, the Kerberos authn process, shown in <a data-type="xref" href="#fig-kerberos">Figure 9-2</a>, works as
follows:</p>

<figure><div id="fig-kerberos" class="figure">
<img src="Images/lmlx_0902.png" alt="lmlx 0902" width="600" height="286"/>
<h6><span class="label">Figure 9-2. </span>Kerberos protocol concept</h6>
</div></figure>
<ol>
<li>
<p>A client (for example, a program on your laptop) sends a request to a Kerberos
component called the Key Distribution Center (KDC), asking for credentials for a
given service, such as printing or a directory.</p>
</li>
<li>
<p>The KDC responds with the requested credentials—that is, a ticket for the
service and a temporary encryption key (session key).</p>
</li>
<li>
<p class="pagebreak-before less_space">The client transmits the ticket (which contains the client’s identity and a
copy of the session key) to the service.</p>
</li>
<li>
<p>The session key, shared by the client and service, is used to authenticate the
client and may optionally be used to authenticate the service.</p>
</li>

</ol>

<p>There are also challenges with Kerberos, such as the central role that the KDC
plays (a single point of failure) and its strict time requirements (it requires
clock synchronization between the client and the server via NTP). Overall,
while not simple to operate and administrate, Kerberos is widely used and
supported in the enterprise and cloud providers.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Pluggable Authentication Modules"><div class="sect2" id="pam">
<h2>Pluggable Authentication Modules</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="PAM" id="idm45805425421920"/><a data-type="indexterm" data-primary="PAM (Pluggable Authentication Modules)" id="idm45805425420944"/><a data-type="indexterm" data-primary="Pluggable Authentication Modules (PAM)" id="idm45805425420208"/><a data-type="indexterm" data-primary="security" data-secondary="PAM" id="idm45805425419520"/>Historically, a program would manage the user authentication process itself.
With <a href="http://www.linux-pam.org">pluggable authentication modules (PAM)</a>, a flexible
way to develop programs that are independent of a concrete authentication
scheme has arrived in Linux (PAM has been around since the end of the 1990s in the
wider UNIX ecosystem). PAM uses a modular architecture, providing developers a
powerful library to interface with it. It also allows system administrators to plug in
different modules, such as the following:</p>
<dl>
<dt><a href="https://oreil.ly/NCs0A"><code>pam_localuser</code></a></dt>
<dd>
<p>Requires that a user is listed in <em>/etc/passwd</em></p>
</dd>
<dt><a href="https://oreil.ly/PkGt9"><code>pam_keyinit</code></a></dt>
<dd>
<p>For
 session keyrings</p>
</dd>
<dt><a href="https://oreil.ly/YinOv"><code>pam_krb5</code></a></dt>
<dd>
<p>For Kerberos 5 password-based
 checks</p>
</dd>
</dl>

<p>With that, we’ve reached the end of the advanced security topics<a data-type="indexterm" data-startref="ix_ch09-asciidoc4" id="idm45805425410960"/> and now turn
to more aspirational topics.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Other Modern and Future Offerings"><div class="sect1" id="idm45805425245840">
<h1>Other Modern and Future Offerings</h1>

<p>In this section, we look at exciting Linux offerings, including new ways
to set up Linux and ways to work with Linux in new environments. In the
server world (be it an on-premises data center or the public cloud),
Linux is already the de facto standard, and Linux is under the hood in many
mobile devices.</p>

<p>What the topics here in this section have in common is that at
the time of writing, they have not yet entered the mainstream. However, if you’re curious about what
future developments might look like or where there’s still high growth potential
for Linux, read on.</p>








<section data-type="sect2" data-pdf-bookmark="NixOS"><div class="sect2" id="idm45805425243664">
<h2>NixOS</h2>

<p><a data-type="indexterm" data-primary="NixOS" id="idm45805425242320"/><a href="https://nixos.org">NixOS</a> is a source-based Linux distro, taking a functional approach
to package management and system configuration as well as rollbacks for upgrades.
I call this a “functional approach” because the artifacts are based on immutability.</p>

<p>The <a href="https://oreil.ly/Km84W">Nix package manager</a> builds the entire operating
system, from the kernel to system packages and apps. Nix offers multiuser
package management and even allows you to install and use multiple versions of the
same package.</p>

<p>Unlike most other Linux distros, NixOS does not follow the Linux Standard Base
filesystem layout as discussed in <a data-type="xref" href="ch05.xhtml#common-fs-layouts">“Common Filesystem Layouts”</a> (with system programs
located in <em>/usr/bin</em>, <em>/usr/lib</em>, and so on, and the configuration usually
located in <em>/etc</em>).</p>

<p>There are a number of interesting ideas in NixOS and its ecosystem, making it
especially relevant for CI pipelines. Even if you don’t want to go all in,
you can, for example, use the Nix package manager standalone (outside of NixOS).</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Linux on the Desktop"><div class="sect2" id="idm45805425236112">
<h2>Linux on the Desktop</h2>

<p><a data-type="indexterm" data-primary="desktop, Linux on" id="idm45805425234736"/>While the viability of
<a href="https://oreil.ly/eBPYT">Linux on the desktop</a>
is subject to ongoing discussions, there is without doubt plenty of choice
concerning desktop-friendly distros and with them a selection of
<a href="https://oreil.ly/qylKC">window managers</a>.</p>

<p>In good UNIX tradition, the Graphical User Interface (GUI) part is separated
from the rest of the operating system. Usually, an
<a href="https://oreil.ly/bTcHy">X window manager</a>
takes care of the GUI responsibilities (from window management to styling and
rendering) with the help of a <a href="https://oreil.ly/hl5gv">display manager</a>.</p>

<p>On top of the window manager, implementing a desktop experience (such as icons, widgets, and
toolbars), sit the <a href="https://oreil.ly/y1VIr">desktop
environments</a>, such as KDE or MATE.</p>

<p>There are many beginner-friendly desktop Linux distros available nowadays,
making it easy to switch from Windows or macOS. The same is true for a range
of open source applications, from office apps (writing docs or working with
spreadsheets, such as LibreOffice) to drawing and image editing (Gimp),
to all major web browsers, games, media players, and utilities, to development
environments.</p>

<p class="pagebreak-before">The catalyst for Linux on the desktop might in fact come from a rather
unexpected direction: with <a href="https://oreil.ly/tGgaf">Windows 11
allowing you to run graphical Linux apps</a> out of the box, this might change the
incentives and uptake for good. Time will tell.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Linux on Embedded Systems"><div class="sect2" id="idm45805425227424">
<h2>Linux on Embedded Systems</h2>

<p><a data-type="indexterm" data-primary="embedded systems, Linux on" id="idm45805425226320"/><a href="https://oreil.ly/mFKVR">Linux on embedded systems</a>
is a wide field, with implementations ranging from cars to networking equipment (such as routers), to smart
home devices (for example fridges) and media devices/smart TVs.</p>

<p><a data-type="indexterm" data-primary="Raspberry Pi (RPI)" id="idm45805425224688"/><a data-type="indexterm" data-primary="RPI (Raspberry Pi)" id="idm45805425223984"/>One particularly interesting generic platform you can acquire for little money
is a <a href="https://www.raspberrypi.org">Raspberry Pi (RPI)</a>. It comes with its own
Linux distro called Raspberry Pi OS (a Debian-based system) and lets you install
this and other Linux distros simply via a microSD card. The RPI has a number
of General Purpose Input/Outputs (GPIOs), making it straightforward to use
external sensors and circuits via a breadboard. You can experiment with, and
learn electronics and program the hardware with, for example, Python.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Linux in Cloud IDE"><div class="sect2" id="idm45805425222112">
<h2>Linux in Cloud IDE</h2>

<p><a data-type="indexterm" data-primary="Cloud IDEs" id="idm45805425220912"/>In recent years, the viability of cloud-based development environments
has made enormous progress to a point where now (commercial) offerings exist
that combine an IDE (usually Visual Studio Code), Git, and a range of
programming languages in a Linux environment. All you as a developer need is
a web browser and network access, and you can edit, test, and run code “in the cloud.”</p>

<p>Two notable examples of Cloud IDEs, at the time of writing, are
<a href="https://www.gitpod.io">Gitpod</a>, which is available either as a managed offering
or as an open source to host yourself, and
<a href="https://oreil.ly/bWNDT">Codespaces</a>, which is deeply integrated
into GitHub.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45805425217952">
<h1>Conclusion</h1>

<p class="pagebreak-after">This chapter covered advanced topics and refined your knowledge of basic techniques and
tooling. If you want to enable IPC, you can use signals and named pipes.
For isolating workloads, you can use VMs, especially modern variants such
as Firecracker. We also discussed modern Linux distributions:
if you plan to run containers (Docker), you may want to consider
these container-centric distros that enforce immutability. We then moved on to
selected security topics, specially Kerberos and PAM for flexible and/or
large-scale authentication. Finally, we reviewed not-yet-mainstream Linux
solutions such as Linux on the desktop and how you can get started with
Linux on embedded systems, such as the Raspberry Pi, for local experimentation
or development.</p>

<p>Some further reading for this chapter:</p>
<dl>
<dt>IPC</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/C2iwX">“An Introduction to Linux IPC”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/cbi1Z">“Inter-process Communication in Linux: Using Pipes and Message Queues”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/FUvoo">“The Linux Kernel Implementation of Pipes and FIFOs”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/IwiyP">“Socat Cheatsheet”</a></p>
</li>
</ul>
</dd>
<dt>VMs</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/vJ9Uf">“What Is a Virtual Machine?” (VMware)</a></p>
</li>
<li>
<p><a href="https://oreil.ly/wJEG1">“What Is a Virtual Machine (VM)?” (Red Hat/IBM)</a></p>
</li>
<li>
<p><a href="https://oreil.ly/cTH8b">“How to Create and Manage KVM Virtual Machines from CLI”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/XLVwj">“KVM” via Debian Wiki</a></p>
</li>
<li>
<p><a href="https://oreil.ly/wDCrH">QEMU machine emulator and virtualizer website</a></p>
</li>
<li>
<p><a href="https://oreil.ly/yIOxz">Firecracker website</a></p>
</li>
</ul>
</dd>
<dt>Modern distros</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/Z8ZNC">“Containers and Clustering”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/T89ed">“Immutability &amp; Loose Coupling: A Match Made in Heaven”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/hZN1b">“Tutorial: Install Flatcar Container Linux on Remote Bare Metal Servers”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/gTav0">List of image-based Linux distributions and associated tooling</a></p>
</li>
<li>
<p><a href="https://oreil.ly/Bfj7l">“Security Features of Bottlerocket, an Open Source Linux-Based Operating <span class="keep-together">System”</span></a></p>
</li>
<li>
<p><a href="https://oreil.ly/61t6G">“RancherOS: A Simpler Linux for Docker Lovers”</a></p>
</li>
</ul>
</dd>
<dt class="pagebreak-before less_space">Selected security</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/rSPKm">“Kerberos: The Network Authentication Protocol”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/Pn9fL">“PAM Tutorial”</a></p>
</li>
</ul>
</dd>
<dt>Other modern and future offerings</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/LryXW">“How X Window Managers Work, and How to Write One”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/qY62s">“Purely Functional Linux with NixOS”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/8YALG">“NixOS: Purely Functional System Configuration Management”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/wnHxa">“What Is a Raspberry Pi?”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/cnAsx">“Kubernetes on Raspberry Pi 4b with 64-bit OS from Scratch”</a></p>
</li>
</ul>
</dd>
</dl>

<p>We’ve reached the end of the book. I hope this is the start of your own Linux
journey. Thanks for staying with me, and if you have feedback, I’m always
interested to hear from you, either via Twitter or via good old email:
<em>modern-linux@pm.me</em>.</p>
</div></section>







</div></section></div></body></html>