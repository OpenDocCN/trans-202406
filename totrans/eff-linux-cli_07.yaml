- en: Chapter 5\. Expanding Your Toolbox
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux systems come with thousands of command-line programs. Experienced users
    typically rely on a smaller subset—a toolbox of sorts—that they return to again
    and again. [Chapter 1](ch01.xhtml#ch_combining_commands) added six highly useful
    commands to your toolbox, and now I’ll hand you about a dozen more. I’ll describe
    each command briefly and show you some example uses. (To see all available options,
    view a command’s manpage.) I’ll also introduce two powerful commands that are
    harder to learn but well worth the effort, called `awk` and `sed`. Overall, the
    commands in this chapter serve four common, practical needs for pipelines and
    other complex commands:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Producing text
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Printing dates, times, sequences of numbers and letters, file paths, repeated
    strings, and other text to jumpstart your pipelines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Isolating text
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Extracting any part of a text file with a combination of `grep`, `cut`, `head`,
    `tail`, and one handy feature of `awk`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Combining text
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Combining files from top to bottom with `cat` and `tac`, or side by side with
    `echo` and `paste`. You can also interleave files with `paste` and `diff`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Transforming text
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Converting text into other text using simple commands such as `tr` and `rev`,
    or more powerful commands such as `awk` and `sed`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is a quick overview. Later chapters show the commands in action.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Producing Text
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every pipeline begins with a simple command that prints to stdout. Sometimes
    it’s a command like `grep` or `cut` that pulls selected data from a file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'or even `cat`, which is convenient for piping the full contents of multiple
    files to other commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Other times, the initial text in a pipeline comes from other sources. You already
    know one such command, `ls`, which prints file and directory names and associated
    information. Let’s take a look at some other text-producing commands and techniques:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '`date`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Prints dates and times in various formats
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`seq`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Prints a sequence of numbers
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Brace expansion
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: A shell feature that prints a sequence of numbers or characters
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`find`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Prints file paths
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '`yes`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Prints the same line repeatedly
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The date Command
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `date` command prints the current date and/or time in various formats:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To control the output format, provide an argument that begins with a plus sign
    (`+`) followed by any text. The text may contain special expressions that begin
    with a percent sign (`%`), such as `%Y` for the current four-digit year and `%H`
    for the current hour on a 24-hour clock. A full list of expressions is on the
    manpage for `date`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The seq Command
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `seq` command prints a sequence of numbers in a range. Provide two arguments,
    the low and high values of the range, and `seq` prints the whole range:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you provide three arguments, the first and third define the range, and the
    middle number is the increment:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use a negative increment such as `-1` to produce a descending sequence:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'or a decimal increment to produce floating-point numbers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By default, values are separated by a newline character, but you can change
    the separator with the `-s` option followed by any string:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，值由换行符分隔，但您可以使用 `-s` 选项后跟任意字符串来更改分隔符：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The option `-w` makes all values the same width (in characters) by adding leading
    zeros as needed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-w` 选项使所有值具有相同的宽度（以字符为单位），如有必要添加前导零：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`seq` can produce numbers in many other formats (see the manpage), but my examples
    represent the most common uses.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq` 可以生成许多其他格式的数字（请参阅手册页），但我的示例代表了最常见的用法。'
- en: Brace Expansion (A Shell Feature)
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大括号扩展（一种Shell特性）
- en: 'The shell provides its own way to print a sequence of numbers, known as *brace
    expansion*. Start with a left curly brace, add two integers separated by two dots,
    and end with a right curly brace:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: shell 提供了一种自己的打印数字序列的方式，称为 *大括号扩展*。从左大括号开始，添加两个用两个点分隔的整数，以右大括号结束：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'More generally, the shell expression `{`*x*`..`*y*`..`*z*`}` generates the
    values *x* through *y*, incrementing by *z*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，shell 表达式 `{`*x*`..`*y*`..`*z*`}` 生成从 *x* 到 *y* 的值，以 *z* 递增：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Curly Braces Versus Square Brackets
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大括号与方括号的区别
- en: 'Square brackets are a pattern-matching operator for filenames ([Chapter 2](ch02.xhtml#ch_shell)).
    Curly brace expansion, on the other hand, does not depend on filenames in any
    way. It just evaluates to a list of strings. You can use brace expansion to *print*
    filenames, but no pattern matching occurs:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号是用于文件名的模式匹配运算符（[第2章](ch02.xhtml#ch_shell)）。另一方面，大括号扩展不依赖于文件名。它只是评估为一个字符串列表。您可以使用大括号扩展来*打印*文件名，但不会进行模式匹配：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Brace expansion also can produce sequences of letters, which `seq` cannot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号扩展还可以生成字母序列，而 `seq` 不能实现：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Brace expansion always produces output on a single line separated by space
    characters. Change this by piping the output to other commands, such as `tr` (see
    [“The tr Command”](#section_tr)):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号扩展总是在单行上生成以空格字符分隔的输出。通过将输出传输到其他命令，如 `tr`（参见[“tr命令”](#section_tr)），可以改变这一点：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create an alias that prints the *n*th letter of the English alphabet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个别名，用于打印英文字母表的第 *n* 个字母：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The find Command
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: find 命令
- en: 'The `find` command lists files in a directory recursively, descending into
    subdirectories and printing full paths.^([1](ch05.xhtml#idm46586641130912)) Results
    are not alphabetical (pipe the output to `sort` if needed):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令递归列出目录中的文件，进入子目录并打印完整路径。^([1](ch05.xhtml#idm46586641130912)) 结果不是按字母顺序的（如果需要，将输出管道传输到
    `sort`）：'
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`find` has numerous options that you can combine. Here are a few highly useful
    ones. Limit the output only to files or directories with the option `-type`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 具有许多可以组合的选项。以下是一些非常有用的选项。仅限制输出为文件或目录的 `-type` 选项：'
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Limit the output to names that match a filename pattern with the option `-name`.
    Quote or escape the pattern so the shell doesn’t evaluate it first:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `-name` 选项将输出限制为与文件名模式匹配的名称。引用或转义模式，以防止shell首先对其进行评估：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Make the name-matching case insensitive with the option `-iname`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-iname` 选项使名称匹配不区分大小写：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`find` can also execute a Linux command for *each file path* in the output,
    using `-exec`. The syntax is a bit wonky:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 还可以使用 `-exec` 在输出中的*每个文件路径*上执行Linux命令。语法有些奇怪：'
- en: Construct a `find` command and omit `-print`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个 `find` 命令并省略 `-print`。
- en: Append `-exec` followed by the command to execute. Use the expression `{}` to
    indicate where the file path should appear in the command.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `-exec` 后面添加要执行的命令。使用表达式 `{}` 指示文件路径应该出现在命令中的位置。
- en: End with a quoted or escaped semicolon, such as `";"` or `\;`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以引号或转义分号结束，例如 `";"` 或 `\;`。
- en: 'Here’s a toy example to print an `@` symbol on either side of the file path:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个玩具示例，打印文件路径两侧的 `@` 符号：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A more practical example performs a long listing (`ls -l`) for all *.conf*
    files in */etc* and its subdirectories:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际的例子是对 */etc* 及其子目录中所有 *.conf* 文件执行长列表（`ls -l`）：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`find -exec` works well for mass deletions of files throughout a directory
    hierarchy (but be careful!). Let’s delete files with names ending in a tilde (`~`)
    within the directory *$HOME/tmp* and its subdirectories. For safety, first run
    the command `echo rm` to see which files would be deleted, then remove `echo`
    to delete for real:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`find -exec` 非常适合于整个目录结构中的大量文件删除（但要小心！）。让我们删除目录 *$HOME/tmp* 及其子目录中以波浪符（`~`）结尾的文件。为了安全起见，首先运行命令
    `echo rm` 查看将要删除的文件，然后删除 `echo` 以实际删除：'
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The yes Command
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`yes` 命令'
- en: 'The `yes` command prints the same string over and over until terminated:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`yes` 命令打印相同的字符串，直到终止：'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What’s the use of this curious behavior? `yes` can supply input to interactive
    programs so they can run unattended. For example, the program `fsck`, which checks
    a Linux filesystem for errors, may prompt the user to continue and wait for a
    response of `y` or `n`. The output of the `yes` command, when piped to `fsck`,
    responds to every prompt on your behalf, so you can walk away and let `fsck` run
    to completion.^([2](ch05.xhtml#idm46586641069200))
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种奇特行为有什么用处？`yes`可以为交互式程序提供输入，使其无人值守运行。例如，程序`fsck`检查Linux文件系统错误时，可能会提示用户继续并等待`y`或`n`的响应。将`yes`命令的输出通过管道传递给`fsck`，它将代表您回答每个提示，因此您可以离开让`fsck`完成运行。^([2](ch05.xhtml#idm46586641069200))
- en: 'The main use of `yes` for our purposes is printing a string a specific number
    of times by piping `yes` to `head` (you’ll see a practical example in [“Generating
    Test Files”](ch08.xhtml#section_generate_test)):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，`yes`的主要用途是通过将`yes`管道传递给`head`来多次打印一个字符串（您将在[“生成测试文件”](ch08.xhtml#section_generate_test)中看到一个实际示例）：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Isolating Text
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离文本
- en: 'When you need just part of a file, the simplest commands to combine and run
    are `grep`, `cut`, `head`, and `tail`. You’ve already seen the first three in
    [Chapter 1](ch01.xhtml#ch_combining_commands): `grep` prints lines that match
    a string, `cut` prints columns from a file, and `head` prints the first lines
    of a file. A new command, `tail`, is the opposite of `head` and prints the last
    lines of a file. [Figure 5-1](#fig_slicers) depicts these four commands working
    together.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只需要文件的一部分时，最简单的组合和运行命令是`grep`、`cut`、`head`和`tail`。你已经在[第1章](ch01.xhtml#ch_combining_commands)中看到了前三者的使用：`grep`打印匹配字符串的行，`cut`打印文件的列，`head`打印文件的前几行。新命令`tail`则是`head`的相反，打印文件的最后几行。[图5-1](#fig_slicers)展示了这四个命令如何一起工作。
- en: '![head, grep, tail, and cut operating on a file](Images/elcl_0501.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![操作文件的head、grep、tail和cut](Images/elcl_0501.png)'
- en: Figure 5-1\. `head`, `grep`, and `tail` extract lines, and `cut` extracts columns.
    In this example, `grep` matches lines containing the string “blandit.”
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1\. `head`、`grep`和`tail`提取行，`cut`提取列。在这个例子中，`grep`匹配包含字符串“blandit”的行。
- en: In this section, I dive more deeply into `grep`, which does a lot more than
    match plain strings, and explain `tail` more formally. I also preview one feature
    of the command `awk` for extracting columns in a way that `cut` cannot. These
    five commands in combination can isolate pretty much any text using a single pipeline.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我更深入地探讨了`grep`，它不仅仅匹配普通字符串，还解释了更正式的`tail`用法。我还预览了用于提取列的`awk`命令的一个功能，这是`cut`无法做到的。这五个命令的组合可以使用单一管道隔离几乎任何文本。
- en: 'grep: A Deeper Look'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: grep：深入探讨
- en: 'You’ve already seen `grep` print lines from a file that match a given string:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到`grep`从文件中打印出匹配给定字符串的行：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`grep` also has some highly useful options. Use the `-w` option to match whole
    words only:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`还有一些非常有用的选项。使用`-w`选项仅匹配完整单词：'
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use the `-i` option to ignore the case of letters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-i`选项忽略大小写：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use the `-l` option to print only the names of the files that contain matching
    lines, but not the matching lines themselves:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-l`选项仅打印包含匹配行的文件名，而不包括匹配行本身：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The real power of `grep`, however, appears when you move beyond matching simple
    strings to matching patterns, called *regular expressions*.^([3](ch05.xhtml#idm46586641019488))
    The syntax is different from filename patterns; a partial description is in [Table 5-1](#table_regex).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`grep`的真正威力体现在超越匹配简单字符串，而是匹配称为*正则表达式*的模式时。^([3](ch05.xhtml#idm46586641019488))
    语法与文件名模式不同；部分描述在[表5-1](#table_regex)中。
- en: Table 5-1\. Some regular expression syntax shared by `grep`, `awk`, and `sed`​^([a](ch05.xhtml#idm46586641014224))
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-1\. `grep`、`awk`和`sed`共享的一些正则表达式语法​^([a](ch05.xhtml#idm46586641014224))
- en: '| To match this: | Use this syntax: | Example |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 匹配此内容： | 使用此语法： | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Beginning of a line | `^` | `^a` = Line beginning with `a` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 行的开头 | `^` | `^a` = 以`a`开头的行 |'
- en: '| End of a line | `$` | `!$` = Line ending with an exclamation point |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 行尾 | `$` | `!$` = 以感叹号结尾的行 |'
- en: '| Any single character (except newline) | `.` | `…` = Any three consecutive
    characters |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 任意单个字符（换行符除外） | `.` | `…` = 任意三个连续字符 |'
- en: '| A literal caret, dollar sign, or any other special character *`c`* | `\`*c*
    | `\$` = A literal dollar sign |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 字面上的插入符号、美元符号或任何其他特殊字符 *`c`* | `\`*c* | `\$` = 字面上的美元符号 |'
- en: '| Zero or more occurrences of expression *E* | *`E`*`*` | `_*` = Zero or more
    underscores |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 *E* 的零个或多个出现 | *`E`*`*` | `_*` = 零个或多个下划线 |'
- en: '| Any single character in a set | `[`*`characters`*`]` | `[aeiouAEIOU]` = Any
    vowel |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 集合中的任意单个字符 | `[`*`characters`*`]` | `[aeiouAEIOU]` = 任意元音 |'
- en: '| Any single character *not* in a set | `[^`*`characters`*`]` | `[^aeiouAEIOU]`
    = Any nonvowel |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 不在集合中的任意单个字符 | `[^`*`characters`*`]` | `[^aeiouAEIOU]` = 任意非元音 |'
- en: '| Any character in a given range between *`c`[1]* and *`c`[2]* | `[`*`c`[1]*`-`*`c`[2]*`]`
    | `[0-9]` = Any digit |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 在给定范围内的任意字符 | `[`*`c`[1]*`-`*`c`[2]*`]` | `[0-9]` = 任意数字 |'
- en: '| Any character *not* in a given range between *`c`[1]* and *`c`[2]* | `[^`*`c`[1]*`-`*`c`[2]*`]`
    | `[^0-9]` = Any nondigit |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 不在给定范围内的任意字符 | `[^`*`c`[1]*`-`*`c`[2]*`]` | `[^0-9]` = 任意非数字 |'
- en: '| Either of two expressions *`E`[1]* or *`E`[2]* | *`E`[1]*`\&#124;`*`E`[2]*
       for grep and sed | `one\&#124;two` = Either `one` or `two` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 两个表达式*`E`[1]*或*`E`[2]*中的任意一个 | *`E`[1]*`\&#124;`*`E`[2]*    用于grep和sed |
    `one\&#124;two` = 要么是`one`要么是`two` |'
- en: '| *`E`[1]*`&#124;`*`E`[2]*    for awk | `one&#124;two` = Either `one` or `two`
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| *`E`[1]*`\&#124;`*`E`[2]*    用于awk | `one\&#124;two` = 要么是`one`要么是`two` |'
- en: '| Grouping expression *`E`* for precedence | `\(`*`E`*`\)`    for grep and
    sed ^([b](ch05.xhtml#idm46586640940032)) | `\(one\&#124;two\)*` = Zero or more
    occurrences of `one` or `two` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 分组表达式*`E`*用于优先级 | `\(`*`E`*`\)`    用于grep和sed ^([b](ch05.xhtml#idm46586640940032))
    | `\(`one\&#124;two`\)*` = 零个或多个`one`或`two` |'
- en: '| `(`*`E`*`)`    for awk | `(one&#124;two)*` = Zero or more occurrences of
    `one` or `two` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `(one\&#124;two)*`    用于awk | `(one\&#124;two)*` = 零个或多个`one`或`two` |'
- en: '| ^([a](ch05.xhtml#idm46586641014224-marker)) The three commands also differ
    in their treatment of regular expressions; [Table 5-1](#table_regex) presents
    a partial list.^([b](ch05.xhtml#idm46586640940032-marker)) For `sed`, this syntax
    does more than grouping; see [“Matching subexpressions with sed”](#section_sed_subexpressions).
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch05.xhtml#idm46586641014224-marker)) 这三个命令在处理正则表达式时也有所不同；[表 5-1](#table_regex)展示了部分列表。^([b](ch05.xhtml#idm46586640940032-marker))
    对于`sed`，此语法不仅仅是分组；详见[“在sed中匹配子表达式”](#section_sed_subexpressions)。 |'
- en: 'Here are some example `grep` commands with regular expressions. Match all lines
    that begin with a capital letter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些带有正则表达式的示例`grep`命令。匹配所有以大写字母开头的行：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Match all nonblank lines (i.e., match blank lines and use `-v` to omit them):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配所有非空行（即匹配空行并使用`-v`排除它们）：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Match all lines that contain either *cookie* or *cake*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配包含*cookie*或*cake*的所有行：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Match all lines at least five characters long:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配至少五个字符长的所有行：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Match all lines in which a less-than symbol appears somewhere before a greater-than
    symbol, such as lines of HTML code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配所有包含小于号在大于号之前的行，例如HTML代码行：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Regular expressions are great, but sometimes they get in the way. Suppose you
    want to search for the two lines in the *frost* file that contain a `w` followed
    by a period. The following command produces the wrong results, because a period
    is a regular expression meaning “any character”:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式很强大，但有时候它们会妨碍你。假设你想要搜索*frost*文件中包含`w`后跟句点的两行。以下命令会产生错误结果，因为句点是正则表达式中的特殊字符，表示“任意字符”：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To work around this problem, you can escape the special character:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，可以转义特殊字符：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'but this solution becomes cumbersome if you have many special characters to
    escape. Fortunately, you can force `grep` to forget about regular expressions
    and search for every character literally in the input by using the `-F` (“fixed”)
    option; or, for an alternative with equivalent results, run `fgrep` instead of
    `grep`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果要转义许多特殊字符，这种解决方案将变得繁琐。幸运的是，你可以强制`grep`忘记正则表达式，并在输入中按字面意义搜索每个字符，方法是使用`-F`（“固定”）选项；或者，为了获得等效结果，可以使用`fgrep`代替`grep`：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`grep` has many other options; I’ll present just one more that solves a common
    problem. Use the `-f` option (lowercase; don’t confuse it with `-F`) to match
    against a set of strings rather than a single string. As a practical example,
    let’s list all shells found in the file */etc/passwd*, which I introduced in [“Command
    #5: sort”](ch01.xhtml#section_sort). As you may recall, each line in */etc/passwd*
    contains information about a user, organized as colon-separated fields. The final
    field on each line is the program launched when the user logs in. This program
    is often but not always a shell:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`还有许多其他选项；我将只介绍解决常见问题的一个。使用`-f`选项（小写；不要与`-F`混淆）来匹配一组字符串而不是单个字符串。作为实际示例，让我们列出文件*/etc/passwd*中找到的所有shell，这是我在[“命令#5：排序”](ch01.xhtml#section_sort)中介绍过的。如你所记得的那样，*/etc/passwd*中的每行包含有关用户的信息，以冒号分隔的字段组织。每行的最后一个字段是用户登录时启动的程序。这个程序通常但并非总是一个shell：'
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'How can you tell if a program is a shell? Well, the file */etc/shells* lists
    all valid login shells on a Linux system:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, you can list all valid shells in */etc/passwd* by extracting the seventh
    field with `cut`, eliminating duplicates with `sort -u`, and checking the results
    against */etc/shells* with `grep -f`. I also add the `-F` option to be cautious,
    so all lines in */etc/shells* are taken literally, even if they contain special
    characters:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The tail Command
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `tail` command prints the last lines of a file—10 lines by default. It’s
    a partner to the `head` command. Suppose you have a file named *alphabet* containing
    26 lines, one per letter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Print the last three lines with `tail`. The option `-n` sets the number of
    lines to be printed, just as it does for `head`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you precede the number with a plus sign (`+`), printing begins at that line
    number and proceeds to the end of the file. The following command begins at the
    25th line of the file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Combine `tail` and `head` to print any range of lines from a file. To print
    the fourth line alone, for example, extract the first four lines and isolate the
    last one:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In general, to print lines *M* through *N*, extract the first *N* lines with
    `head`, then isolate the last *N-M+1* lines with `tail`. Print lines six through
    eight of the *alphabet* file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`head` and `tail` both support a simpler syntax to specify a number of lines
    without `-n`. This syntax is ancient, undocumented, and deprecated but will probably
    remain supported forever:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The awk {print} Command
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command `awk` is a general-purpose text processor with hundreds of uses.
    Let’s preview one small feature, `print`, that extracts columns from a file in
    ways that `cut` cannot. Consider the system file */etc/hosts*, which includes
    IP addresses and hostnames separated by any amount of whitespace:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Suppose you want to isolate hostnames by printing the second word on each line.
    The challenge is that each hostname is preceded by an arbitrary amount of whitespace.
    `cut` needs its columns either lined up neatly by column number (`-c`) or separated
    by a single consistent character (`-f`). You need a command to print the second
    word on each line, which `awk` provides with ease:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`awk` refers to any column by a dollar sign followed by the column number:
    for example, `$7` for the seventh column. If the column number has more than one
    digit, surround the number with parentheses: for example, `$(25)`. To refer to
    the final field, use `$NF` (“number of fields”). To refer to the entire line,
    use `$0`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '`awk` does not print whitespace between values by default. If you want whitespace,
    separate the values with commas:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`awk`’s `print` statement is great for processing the output of commands that
    strays outside tidy columns. An example is `df`, which prints the amount of free
    and used disk space on a Linux system:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The column locations may vary depending on the length of the `Filesystem` paths,
    the disk sizes, and the options you pass to `df`, so you can’t reliably extract
    values with `cut`. With `awk`, however, you can easily isolate (say) the fourth
    value on each line, representing available disk space:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'and even remove the first line (the header) at the same time with a little
    `awk` magic, printing only line numbers greater than 1:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you encounter input separated by something other than space characters,
    `awk` can change its field separator to any regular expression with the `-F` option:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You’ll learn more details about `awk` in [“awk essentials”](#section_awk).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Combining Text
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You already know several commands that combine text from different files. The
    first is `cat`, which prints the contents of multiple files to stdout. It’s a
    joiner of files top-to-bottom. That’s where its name comes from—it con*cat*enates
    files:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The second command you’ve seen for combining text is `echo`, the shell builtin
    that prints whatever arguments you give it, separated by a single space character.
    It combines strings side by side:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s examine some more commands that combine text:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '`tac`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: A bottom-to-top combiner of text files
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`paste`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: A side-by-side combiner of text files
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '`diff`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: A command that interleaves text from two files by printing their differences
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The tac Command
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tac` command reverses a file line by line. Its name is *cat* spelled backward.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Notice I concatenated three files before reversing the text. If I instead provide
    multiple files to `tac` as arguments, it reverses the lines of each file in turn,
    producing different output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`tac` is great for processing data that is already in chronological order but
    not reversible with the `sort -r` command. A typical case is reversing a web-server
    log file to process its lines from newest to oldest:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The lines are in chronological order with timestamps, but they aren’t in alphabetical
    or numeric order, so the `sort -r` command isn’t helpful. The `tac` command can
    reverse these lines without needing to consider the timestamps.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The paste Command
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `paste` command combines files side by side in columns separated by a single
    tab character. It’s a partner to the `cut` command, which extracts columns from
    a tab-separated file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Change the separator to another character, such as a comma, with the option
    `-d` (meaning “delimiter”):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Transpose the output, producing pasted rows instead of pasted columns, with
    the `-s` option:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`paste` also interleaves data from two or more files if you change the separator
    to a newline character (`\n`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The diff Command
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`diff` compares two files line by line and prints a terse report about their
    differences:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The notation `1c1` represents a change or difference between the files. It means
    that line 1 in the first file differs from line 1 in the second file. This notation
    is followed by the relevant line from *file1*, a three-dash separator (`---`),
    and the relevant line from *file2*. The leading symbol `<` always indicates a
    line from the first file, and `>` indicates a line from the second file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `1c1` 表示文件之间的变化或差异。它表示第一个文件中的第一行与第二个文件中的第一行不同。此符号后跟来自 *file1* 的相关行，一个三个破折号分隔符
    (`---`)，以及来自 *file2* 的相关行。前导符号 `<` 总是表示第一个文件的行，而 `>` 表示第二个文件的行。
- en: The notation `2a3` represents an addition. It means that *file2* has a third
    line not present after the second line of *file1*. This notation is followed by
    the extra line from *file2*, “Have a nice day.”
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `2a3` 表示添加。它表示 *file2* 在第二行之后有一个第三行。此符号后跟来自 *file2* 的额外行，“祝您今天愉快。”
- en: '`diff` output may contain other notation and can take other forms. This short
    explanation is enough for our main purpose, however, which is to use `diff` as
    a text processor that interleaves lines from two files. Many users don’t think
    of `diff` this way, but it’s great for forming pipelines to solve certain kinds
    of problems. For example, you can isolate the differing lines with `grep` and
    `cut`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff` 输出可能包含其他符号，并且可以采用其他形式。然而，对于我们的主要目的而言，这个简短的解释已经足够，即将 `diff` 作为一个交错两个文件行的文本处理器使用。许多用户并不将
    `diff` 看作这样的工具，但它非常适合形成管道以解决某些类型的问题。例如，您可以使用 `grep` 和 `cut` 隔离不同的行：'
- en: '[PRE63]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You’ll see practical examples in [“Technique #4: Process Substitution”](ch07.xhtml#section_process_substitution)
    and [“Checking Matched Pairs of Files”](ch08.xhtml#section_matched_pairs).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 [“技巧＃4：过程替换”](ch07.xhtml#section_process_substitution) 和 [“检查匹配的文件对”](ch08.xhtml#section_matched_pairs)
    中看到实际示例。
- en: Transforming Text
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换文本
- en: '[Chapter 1](ch01.xhtml#ch_combining_commands) introduced several commands that
    read text from stdin and transform it into something else on stdout. `wc` prints
    a count of lines, words, and characters; `sort` arranges lines into alphabetical
    or numeric order; and `uniq` consolidates duplicate lines. Let’s discuss several
    more commands that transform their input:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.xhtml#ch_combining_commands) 介绍了几个从 stdin 读取文本并将其转换为 stdout 中其他内容的命令。`wc`
    打印行数、单词数和字符数；`sort` 按字母或数字顺序排列行；`uniq` 合并重复行。让我们讨论另外几个将其输入转换的命令：'
- en: '`tr`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`'
- en: Translates characters into other characters
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符转换为其他字符
- en: '`rev`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`rev`'
- en: Reverses characters on a line
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 反转行中的字符
- en: '`awk` and `sed`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 和 `sed`'
- en: General-purpose transformers
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通用转换器
- en: The tr Command
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tr 命令
- en: '`tr` translates one set of characters into another. I showed you one example
    in [Chapter 2](ch02.xhtml#ch_shell) of translating colons into newline characters
    to print the shell’s `PATH`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr` 将一个字符集转换为另一个字符集。在 [第2章](ch02.xhtml#ch_shell) 中，我展示了一个将冒号转换为换行符以打印 shell
    的 `PATH` 的示例：'
- en: '[PRE64]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`tr` takes two sets of characters as arguments, and it translates members of
    the first set into the corresponding members of the second. Common uses are converting
    text to uppercase or lowercase:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr` 接受两组字符作为参数，并将第一组的成员转换为第二组的对应成员。常见用途是将文本转换为大写或小写：'
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'converting spaces into newlines:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将空格转换为换行符：
- en: '[PRE66]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'and deleting whitespace with the `-d` (delete) option:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用 `-d`（删除）选项删除空白：
- en: '[PRE67]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The rev Command
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: rev 命令
- en: The `rev` command reverses the characters of each line of input:^([4](ch05.xhtml#idm46586640664208))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: rev 命令反转每行输入的字符：^([4](ch05.xhtml#idm46586640664208))
- en: '[PRE68]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Beyond the obvious entertainment value, `rev` is handy for extracting tricky
    information from files. Suppose you have a file of celebrity names:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 除了明显的娱乐价值外，`rev` 对于从文件中提取棘手信息非常有用。假设您有一个名人姓名文件：
- en: '[PRE69]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: and you want to extract the final word on each line (Curtis, Deschanel, Coleman,
    Rihanna). This would be easy with `cut -f` if each line had the same number of
    fields, but the number varies. With `rev`, you can reverse all the lines, cut
    the *first* field, and reverse again to achieve your goal:^([5](ch05.xhtml#idm46586640655616))
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从每行提取最后一个单词（Curtis、Deschanel、Coleman、Rihanna）。如果每行具有相同数量的字段，则使用 `cut -f`
    很容易实现，但字段数量会有所变化。使用 `rev`，您可以反转所有行，剪切*第一个*字段，然后再次反转以实现您的目标：^([5](ch05.xhtml#idm46586640655616))
- en: '[PRE70]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The awk and sed Commands
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: awk 和 sed 命令
- en: '`awk` and `sed` are general-purpose “supercommands” for processing text. They
    can do most everything that the other commands in this chapter do, but with more
    cryptic-looking syntax. As a simple example, they can print the first 10 lines
    of a file like `head` does:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'They can also do things that our other commands cannot, like replace or swap
    strings:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`awk` and `sed` are harder to learn than the other commands I’ve covered, because
    each of them has a miniature programming language built in. They have so many
    capabilities that whole books have been written on them.^([6](ch05.xhtml#idm46586640635552))
    I highly recommend spending quality time learning both commands (or at least one
    of them). To begin your journey, I cover basic principles of each command and
    demonstrate some common uses. I also recommend several online tutorials to learn
    more about these powerful, crucial commands.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t worry about memorizing every feature of `awk` or `sed`. Success with
    these commands really means:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the *kinds* of transformations they make possible, so you can
    think, “Ah! This is a job for `awk` (or `sed`)!” and apply them in your time of
    need
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to read their manpages and to find complete solutions on [Stack Exchange](https://oreil.ly/0948M)
    and other online resources
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: awk essentials
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`awk` transforms lines of text from files (or stdin) into any other text, using
    a sequence of instructions called an *awk program*.^([7](ch05.xhtml#idm46586640622768))
    The more skilled you become in writing awk programs, the more flexibly you can
    manipulate text. You can supply the awk program on the command line:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can also store one or more awk programs in files and refer to them with
    the `-f` option, and the programs run in sequence:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'An awk program includes one or more *actions*, such as calculating values or
    printing text, that run when an input line matches a *pattern*. Each instruction
    in the program has the form:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Typical patterns include:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The word `BEGIN`
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Its action runs just once, before `awk` processes any input.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The word `END`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Its action runs just once, after `awk` has processed all the input.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression (see [Table 5-1](#table_regex)) surrounded by forward slashes
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: An example is `/^[A-Z]/` to match lines that begin with a capital letter.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Other expressions specific to `awk`
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: For example, to check whether the third field on an input line (`$3`) begins
    with a capital letter, a pattern would be `$3~/^[A-Z]/`. Another example is `FNR>5`,
    which tells `awk` to skip the first five lines of input.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'An action with no pattern runs for every line of input. (Several awk programs
    in [“The awk {print} Command”](#section_awk_preview) were of this type.) As an
    example, `awk` elegantly solves the “print the celebrity’s last name” problem
    from [“The rev Command”](#section_rev) by directly printing the final word from
    each line:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When supplying an awk program on the command line, enclose it in quotes to prevent
    the shell from evaluating `awk`’s special characters. Use single or double quotes
    as needed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上提供一个`awk`程序时，用引号括起来以防止shell评估`awk`的特殊字符。根据需要使用单引号或双引号。
- en: 'A pattern with no action runs the default action `{print}`, which just prints
    any matching input lines unchanged:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何操作的模式运行默认操作`{print}`，只是打印任何匹配的输入行，不做任何更改：
- en: '[PRE77]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'For a fuller demonstration, process the tab-separated file *animals.txt* from
    [Example 1-1](ch01.xhtml#example_animals.txt) to produce a tidy bibliography,
    converting lines from this format:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更充分地演示，处理来自[示例 1-1](ch01.xhtml#example_animals.txt)的制表符分隔文件*animals.txt*，以生成整洁的参考书目，将行从这种格式转换为：
- en: '[PRE78]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'to this format:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个格式：
- en: '[PRE79]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This feat requires rearranging three fields and adding some characters like
    parentheses and double quotes. The following awk program does the trick, employing
    the option `-F` to change the input separator from spaces to tabs (`\t`):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要重新排列三个字段，并添加一些字符如括号和双引号。以下`awk`程序可以做到这一点，使用选项`-F`将输入分隔符从空格更改为制表符(`\t`)：
- en: '[PRE80]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add a regular expression to process only the “horse” book:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个正则表达式来处理只有“horse”书籍：
- en: '[PRE81]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Or process only books from 2010 or later, by testing whether field `$3` matches
    `^201`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 或者仅处理2010年或之后的书籍，通过测试字段`$3`是否匹配`^201`：
- en: '[PRE82]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, add a `BEGIN` instruction to print a friendly heading, some dashes
    for indenting, and an `END` instruction to direct the reader to further information:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个`BEGIN`指令打印友好的标题，一些短划线作为缩进，和一个`END`指令引导读者进一步了解信息：
- en: '[PRE83]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`awk` does much more than print—it can also perform calculations, like summing
    the numbers 1 to 100:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`不仅可以打印，它还可以执行计算，比如对1到100的数字求和：'
- en: '[PRE84]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: To learn `awk` beyond what can be covered in a few book pages, take an `awk`
    tutorial at [tutorialspoint.com/awk](https://www.tutorialspoint.com/awk/) or [riptutorial.com/awk](https://riptutorial.com/awk)
    or search the web for “awk tutorial.” You’ll be glad you did.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`awk`超出几页书可以覆盖的内容，可以在[tutorialspoint.com/awk](https://www.tutorialspoint.com/awk/)或[riptutorial.com/awk](https://riptutorial.com/awk)上参加`awk`教程，或者搜索“awk教程”。你会感到高兴的。
- en: Improving the duplicate file detector
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进重复文件检测器
- en: 'In [“Detecting Duplicate Files”](ch01.xhtml#sec_duplicate_files), you constructed
    a pipeline that detects and counts duplicate JPEG files by checksum, but it was
    not powerful enough to print the filenames:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“检测重复文件”](ch01.xhtml#sec_duplicate_files)中，您构建了一个通过检验检验和检测和计数重复JPEG文件的管道，但它不足以打印文件名：
- en: '[PRE85]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now that you know `awk`, you have the tools to print the filenames as well.
    Let’s construct a new command that reads each line of `md5sum` output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`awk`，你可以打印文件名。让我们构建一个新命令，读取`md5sum`输出的每一行：
- en: '[PRE86]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: and not only counts occurrences of each checksum but also stores the filenames
    for printing. You’ll need two additional `awk` features called *arrays* and *loops*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅计算每个检验和的出现次数，还存储文件名以供打印。您将需要两个名为*数组*和*循环*的附加`awk`功能。
- en: An *array* is a variable that holds a collection of values. If the array is
    named `A` and holds seven values, then the values could be accessed as `A[1]`,
    `A[2]`, `A[3]`, up to `A[7]`. The values 1 through 7 are called the *keys* of
    the array, and `A[1]` through `A[7]` are called the array’s *elements*. You can
    create any keys you want, however. If you’d rather access the seven elements of
    your array using the names of Disney characters, go ahead and name them `A["Doc"]`,
    `A["Grumpy"]`, `A["Bashful"]`, all the way to `A["Dopey"]`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*数组*是一个保存值集合的变量。如果数组命名为`A`并保存了七个值，则可以访问值`A[1]`、`A[2]`、`A[3]`，一直到`A[7]`。1到7的值称为数组的*键*，而`A[1]`到`A[7]`称为数组的*元素*。你可以创建任何你想要的键。如果你更愿意使用迪士尼角色的名字访问你的数组的七个元素，那就这样命名它们`A["Doc"]`、`A["Grumpy"]`、`A["Bashful"]`，一直到`A["Dopey"]`。
- en: 'To count duplicate images, create an array called `counts` with one element
    for each checksum. Each array key is a checksum, and the associated element holds
    the number of times that checksum occurs in the input. For example, the array
    element `counts["f6464ed766daca87ba407aede21c8fcc"]` could have value 3\. The
    following awk script examines each line of `md5sum` output, isolates the checksum
    (`$1`), and uses it as a key for the `counts` array. The operator `++` increments
    an element by 1 each time `awk` encounters its associated checksum:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'So far, the awk script produces no output—it just counts each checksum and
    exits. To print the counts, you need a second `awk` feature called a `for` loop.
    A `for` loop steps through an array, key by key, and processes each element in
    sequence, using this syntax:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'For example, print each array element by its key:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Place this loop in the `END` instruction so it runs after all the counts are
    calculated.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, add the checksums to the output. Each array key is a checksum, so just
    print the key after the count:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To collect and print filenames, use a second array, `names`, also with checksums
    as its keys. As `awk` processes each line of output, append the filename (`$2`)
    to the corresponding element of the `names` array, along with a space as a separator.
    In the `END` loop, after printing the checksum (`key`), print a colon and the
    collected filenames for that checksum:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Lines that begin with 1 represent checksums that occur only once, so they are
    not duplicates. Pipe the output to `grep -v` to remove these lines, then sort
    the results numerically, high to low, with `sort -nr` and you have your desired
    output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: sed essentials
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`sed`, like `awk`, transforms text from files (or stdin) into any other text,
    using a sequence of instructions called a *sed script*.^([8](ch05.xhtml#idm46586640479648))
    sed scripts are pretty cryptic on first glance. An example is `s/Windows/Linux/g`,
    which means to replace every occurrence of the string `Windows` with `Linux`.
    The word *script* here does not mean a file (like a shell script) but a string.^([9](ch05.xhtml#idm46586640476576))
    Invoke `sed` with a single script on the command line:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'or use the `-e` option to supply multiple scripts that process the input in
    sequence:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You can also store sed scripts in files and refer to them with the `-f` option,
    and they run in sequence:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'As with `awk`, the utility of `sed` depends on your skill in creating sed scripts.
    The most common type of script is a substitution script that replaces strings
    with other strings. The syntax is:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'where *`regexp`* is a regular expression to match against each input line (see
    [Table 5-1](#table_regex)), and *`replacement`* is a string to replace the matched
    text. As a simple example, change one word into another:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When supplying a sed script on the command line, enclose it in quotes to prevent
    the shell from evaluating `sed`’s special characters. Use single or double quotes
    as needed.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '`sed` easily solves the “print the celebrity’s last name” problem from [“The
    rev Command”](#section_rev) with a regular expression. Just match all characters
    (`.*`) up to the last space and replace them with nothing:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`可以通过正则表达式轻松解决来自[“rev命令”](#section_rev)的“打印名人姓氏”的问题。只需匹配所有字符（`.*`）直到最后一个空格，并将它们替换为空：'
- en: '[PRE99]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Substitution and Slashes
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换和斜杠
- en: 'The forward slashes in a substitution may be replaced by any other convenient
    character. This is helpful when a regular expression itself includes forward slashes
    (which would otherwise need escaping). These three sed scripts are equivalent:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 替换中的斜杠可以用任何其他方便的字符替换。当正则表达式本身包含斜杠时（否则需要转义），这将非常有帮助。这三个`sed`脚本是等效的：
- en: '[PRE100]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You may follow a substitution with several options to affect its behavior.
    The option `i` makes matches case insensitive:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在替换之后跟随几个选项以影响其行为。选项`i`使匹配不区分大小写：
- en: '[PRE101]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The option `g` (“global”) replaces all occurrences of the regular expression
    instead of just the first one:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`g`（“全局”）替换所有匹配正则表达式的实例，而不仅仅是第一个：
- en: '[PRE102]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Another common type of sed script is a deletion script. It removes lines by
    their line number:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的`sed`脚本类型是删除脚本。它根据它们的行号删除行：
- en: '[PRE103]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'or lines that match a regular expression:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 或者匹配正则表达式的行：
- en: '[PRE104]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Matching subexpressions with sed
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sed匹配子表达式
- en: 'Suppose you have some filenames:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些文件名：
- en: '[PRE105]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'and want to produce new names, *image1.jpg*, *image2.jpg*, and *image3.jpg*.
    `sed` can split the filenames into parts and rearrange them via a feature called
    *subexpressions*. First, create a regular expression that matches the filenames:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 并且想要生成新的名称，*image1.jpg*，*image2.jpg*和*image3.jpg*。`sed`可以将文件名拆分为部分并通过*子表达式*重新排列它们。首先，创建一个匹配文件名的正则表达式：
- en: '[PRE106]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You want to move the final digit earlier in the filename, so isolate that digit
    by surrounding it with the symbols `\(` and `\)`. This defines a subexpression—a
    designated part of a regular expression:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将最终数字移动到文件名的前面，因此用符号`\(`和`\)`将该数字孤立出来。这定义了一个子表达式——正则表达式的指定部分：
- en: '[PRE107]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`sed` can refer to subexpressions by number and manipulate them. You created
    only one subexpression, so its name is `\1`. A second subexpression would be `\2`,
    and so on, up to a maximum of `\9`. Your new filenames would have the form `image\1.jpg`.
    Therefore, your sed script would be:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`可以按编号引用子表达式并操作它们。您只创建了一个子表达式，所以它的名称是`\1`。第二个子表达式将是`\2`，依此类推，最多可以到`\9`。您的新文件名将具有形式`image\1.jpg`。因此，您的sed脚本将是：'
- en: '[PRE108]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'To make things more complicated, suppose the filenames had more variation,
    consisting of lowercase words:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加复杂，假设文件名有更多变化，由小写单词组成：
- en: '[PRE109]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Create three subexpressions to capture the base filename, extension, and final
    digit:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 创建三个子表达式以捕获基本文件名、扩展名和最终数字：
- en: '[PRE110]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Connect them with escaped dots (`\.`) to form this regular expression:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 用转义点（`\.`）将它们连接起来形成这个正则表达式：
- en: '[PRE111]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Represent the newly transformed filenames to `sed` as `\1\3.\2`, and the final
    substitution with `sed` becomes:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 将新转换后的文件名表示为`\1\3.\2`，最终与`sed`的替换变成：
- en: '[PRE112]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This command does not rename files—it just prints the new names. The section
    [“Inserting a Filename into a Sequence”](ch08.xhtml#section_insert_filename_sequence)
    shows a similar example that performs the renaming as well.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令不会重命名文件——它只是打印新名称。章节[“在序列中插入文件名”](ch08.xhtml#section_insert_filename_sequence)展示了一个类似的示例，它还执行了重命名操作。
- en: To learn `sed` beyond what can be covered in a few book pages, take a `sed`
    tutorial at [tutorialspoint.com/sed](https://www.tutorialspoint.com/sed) or [grymoire.com/Unix/Sed.html](https://www.grymoire.com/Unix/Sed.html)
    or search the web for “sed tutorial.”
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入学习`sed`，超出了几页书籍的内容，可以在[tutorialspoint.com/sed](https://www.tutorialspoint.com/sed)或[grymoire.com/Unix/Sed.html](https://www.grymoire.com/Unix/Sed.html)上参加`sed`教程，或在网络上搜索“sed教程”。
- en: Toward an Even Larger Toolbox
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 朝着一个更大的工具箱前进
- en: Most Linux systems come with thousands of command-line programs, and most of
    them have numerous options that change their behavior. You’re not likely to learn
    and remember them all. So, in a moment of need, how do you locate a new program—or
    tailor a program that you already know—to accomplish your goals?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux系统都附带成千上万个命令行程序，它们中的大多数都有许多选项可以改变其行为。您不太可能学习并记住它们全部。因此，在需要时，如何找到一个新程序或调整您已经了解的程序以实现您的目标？
- en: 'Your first (obvious) step is a web search engine. For example, if you need
    a command that limits the width of lines in a text file, wrapping any lines that
    are too long, search the web for (say) “Linux command wrap lines” and you’ll be
    pointed to the `fold` command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一（显而易见的）步骤是使用网络搜索引擎。例如，如果您需要一个命令来限制文本文件中行的宽度，自动换行任何太长的行，请搜索“Linux 命令 wrap
    lines”，您将会找到 `fold` 命令：
- en: '[PRE113]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'To discover commands that are already installed on your Linux system, run the
    command `man -k` (or equivalently, `apropos`). Given a word, `man -k` searches
    for that word in the brief descriptions at the top of manpages:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现已安装在您的 Linux 系统上的命令，运行命令 `man -k`（或者等价地，`apropos`）。给定一个单词，`man -k` 在 man
    手册顶部的简短描述中搜索该单词：
- en: '[PRE114]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '`man -k` accepts `awk`-style regular expressions in search strings (see [Table 5-1](#table_regex)):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`man -k` 接受 `awk` 风格的正则表达式作为搜索字符串（参见 [表 5-1](#table_regex)）：'
- en: '[PRE115]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'A command that’s not installed on your system might still be installable through
    your system’s package manager. A package manager is software for installing Linux
    programs that are supported for your system. Some popular package managers include
    `apt`, `dnf`, `emerge`, `pacman`, `rpm`, `yum`, and `zypper`. Use the `man` command
    to figure out which package manager is installed on your system and learn how
    to search for uninstalled packages. Often it’s a two-command sequence: one command
    to copy the latest data about available packages (“metadata”) from the internet
    onto your system, and another to search the metadata. For example, for Ubuntu
    or Debian Linux-based systems, the commands are:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上未安装的命令可能仍然可以通过系统的软件包管理器安装。软件包管理器是用于安装适用于您系统的 Linux 程序的软件。一些流行的软件包管理器包括
    `apt`、`dnf`、`emerge`、`pacman`、`rpm`、`yum` 和 `zypper`。使用 `man` 命令来确定您系统上安装了哪个软件包管理器，并了解如何搜索未安装的软件包。通常是一个两条命令的序列：一条命令将来自互联网的最新可用软件包数据（“元数据”）复制到您的系统上，另一条命令用于搜索元数据。例如，对于基于
    Ubuntu 或 Debian 的 Linux 系统，命令如下：
- en: '[PRE116]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'If, after much searching, you cannot locate or construct an appropriate command
    to meet your needs, consider asking for help in an online forum. A great starting
    point for asking effective questions is Stack Overflow’s [“How Do I Ask a Good
    Question?” help page](https://oreil.ly/J0jho). In general, present your questions
    in a way that is respectful of other people’s time, and experts will be more inclined
    to answer. That means making your question short and to the point, including any
    error messages or other output word for word, and explaining what you have tried
    so far on your own. Spend quality time to ask a quality question: you’ll not only
    increase your chances of a helpful answer, but also, if the forum is public and
    searchable, a clear question and answer may aid others who have a similar problem.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果长时间搜索后仍无法找到或构建一个满足您需求的适当命令，请考虑在在线论坛上寻求帮助。提问的一个很好的起点是 Stack Overflow 的 [“如何提出一个好问题？”帮助页面](https://oreil.ly/J0jho)。总的来说，请尊重他人的时间来提问问题，专家们将更倾向于回答。这意味着让您的问题简短明了，包括任何错误消息或其他输出文字，并解释您自己已经尝试了什么。花时间质问质答：这不仅会增加获得有帮助答案的机会，而且如果论坛是公开可搜索的，清晰的问题和答案可能会帮助其他有类似问题的人。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You’ve now grown beyond the pint-sized toolbox from [Chapter 1](ch01.xhtml#ch_combining_commands)
    and are ready to tackle more challenging business problems at the command line.
    The coming chapters are filled with practical examples of using your new commands
    in all kinds of situations.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '您现在已经超越了 [第 1 章](ch01.xhtml#ch_combining_commands) 中的迷你工具箱，并准备在命令行中解决更具挑战性的业务问题。接下来的章节中充满了在各种情况下使用新命令的实际示例。  '
- en: ^([1](ch05.xhtml#idm46586641130912-marker)) The related command `ls -R` produces
    output in a format that’s less convenient for pipelines.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#idm46586641130912-marker)) 相关命令 `ls -R` 生成的输出格式不太适合用于管道操作。
- en: ^([2](ch05.xhtml#idm46586641069200-marker)) Nowadays, some implementations of
    `fsck` have options `-y` and `-n` to respond yes or no, respectively, to every
    prompt, so the `yes` command is unnecessary here.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.xhtml#idm46586641069200-marker)) 现在，一些 `fsck` 的实现具有选项 `-y` 和 `-n`，分别对每个提示回答是或否，因此此处不需要
    `yes` 命令。
- en: ^([3](ch05.xhtml#idm46586641019488-marker)) The name *grep* is short for “get
    regular expression and print.”
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.xhtml#idm46586641019488-marker)) *grep* 的名称缩写为 “get regular expression
    and print”。
- en: '^([4](ch05.xhtml#idm46586640664208-marker)) Quiz: what does the pipeline `rev
    myfile | tac | rev | tac` do?'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.xhtml#idm46586640664208-marker)) 测验：管道 `rev myfile | tac | rev |
    tac` 做什么？
- en: ^([5](ch05.xhtml#idm46586640655616-marker)) You’ll see simpler solutions with
    `awk` and `sed` shortly, but this double-`rev` trick is handy to know.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch05.xhtml#idm46586640655616-marker)) 不久你将看到使用 `awk` 和 `sed` 的简单解决方案，但这种双`rev`技巧很实用。
- en: ^([6](ch05.xhtml#idm46586640635552-marker)) Including the book [*sed & awk*](https://oreil.ly/FjtTm)
    from O’Reilly.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch05.xhtml#idm46586640635552-marker)) 包括 O'Reilly 出版的书籍 [*sed & awk*](https://oreil.ly/FjtTm)。
- en: ^([7](ch05.xhtml#idm46586640622768-marker)) The name *awk* is an acronym for
    Aho, Weinberger, and Kernighan, the program’s creators.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch05.xhtml#idm46586640622768-marker)) *awk* 的名字是由程序的创作者 Aho、Weinberger
    和 Kernighan 的首字母组成的缩写。
- en: ^([8](ch05.xhtml#idm46586640479648-marker)) The name *sed* is short for “stream
    editor,” because it edits a stream of text.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch05.xhtml#idm46586640479648-marker)) *sed* 的名字缩写来自于“流编辑器（stream editor）”，因为它编辑文本流。
- en: ^([9](ch05.xhtml#idm46586640476576-marker)) If you’re familiar with the editors
    `vi`, `vim`, `ex`, or `ed`, sed script syntax may look familiar.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch05.xhtml#idm46586640476576-marker)) 如果你熟悉编辑器 `vi`、`vim`、`ex` 或者 `ed`，那么
    `sed` 脚本语法可能看起来很熟悉。
