- en: Chapter 5\. Expanding Your Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux systems come with thousands of command-line programs. Experienced users
    typically rely on a smaller subset—a toolbox of sorts—that they return to again
    and again. [Chapter 1](ch01.xhtml#ch_combining_commands) added six highly useful
    commands to your toolbox, and now I’ll hand you about a dozen more. I’ll describe
    each command briefly and show you some example uses. (To see all available options,
    view a command’s manpage.) I’ll also introduce two powerful commands that are
    harder to learn but well worth the effort, called `awk` and `sed`. Overall, the
    commands in this chapter serve four common, practical needs for pipelines and
    other complex commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Producing text
  prefs: []
  type: TYPE_NORMAL
- en: Printing dates, times, sequences of numbers and letters, file paths, repeated
    strings, and other text to jumpstart your pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating text
  prefs: []
  type: TYPE_NORMAL
- en: Extracting any part of a text file with a combination of `grep`, `cut`, `head`,
    `tail`, and one handy feature of `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: Combining text
  prefs: []
  type: TYPE_NORMAL
- en: Combining files from top to bottom with `cat` and `tac`, or side by side with
    `echo` and `paste`. You can also interleave files with `paste` and `diff`.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming text
  prefs: []
  type: TYPE_NORMAL
- en: Converting text into other text using simple commands such as `tr` and `rev`,
    or more powerful commands such as `awk` and `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is a quick overview. Later chapters show the commands in action.
  prefs: []
  type: TYPE_NORMAL
- en: Producing Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every pipeline begins with a simple command that prints to stdout. Sometimes
    it’s a command like `grep` or `cut` that pulls selected data from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'or even `cat`, which is convenient for piping the full contents of multiple
    files to other commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Other times, the initial text in a pipeline comes from other sources. You already
    know one such command, `ls`, which prints file and directory names and associated
    information. Let’s take a look at some other text-producing commands and techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '`date`'
  prefs: []
  type: TYPE_NORMAL
- en: Prints dates and times in various formats
  prefs: []
  type: TYPE_NORMAL
- en: '`seq`'
  prefs: []
  type: TYPE_NORMAL
- en: Prints a sequence of numbers
  prefs: []
  type: TYPE_NORMAL
- en: Brace expansion
  prefs: []
  type: TYPE_NORMAL
- en: A shell feature that prints a sequence of numbers or characters
  prefs: []
  type: TYPE_NORMAL
- en: '`find`'
  prefs: []
  type: TYPE_NORMAL
- en: Prints file paths
  prefs: []
  type: TYPE_NORMAL
- en: '`yes`'
  prefs: []
  type: TYPE_NORMAL
- en: Prints the same line repeatedly
  prefs: []
  type: TYPE_NORMAL
- en: The date Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `date` command prints the current date and/or time in various formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To control the output format, provide an argument that begins with a plus sign
    (`+`) followed by any text. The text may contain special expressions that begin
    with a percent sign (`%`), such as `%Y` for the current four-digit year and `%H`
    for the current hour on a 24-hour clock. A full list of expressions is on the
    manpage for `date`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The seq Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `seq` command prints a sequence of numbers in a range. Provide two arguments,
    the low and high values of the range, and `seq` prints the whole range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you provide three arguments, the first and third define the range, and the
    middle number is the increment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a negative increment such as `-1` to produce a descending sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'or a decimal increment to produce floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, values are separated by a newline character, but you can change
    the separator with the `-s` option followed by any string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The option `-w` makes all values the same width (in characters) by adding leading
    zeros as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`seq` can produce numbers in many other formats (see the manpage), but my examples
    represent the most common uses.'
  prefs: []
  type: TYPE_NORMAL
- en: Brace Expansion (A Shell Feature)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The shell provides its own way to print a sequence of numbers, known as *brace
    expansion*. Start with a left curly brace, add two integers separated by two dots,
    and end with a right curly brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, the shell expression `{`*x*`..`*y*`..`*z*`}` generates the
    values *x* through *y*, incrementing by *z*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Curly Braces Versus Square Brackets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Square brackets are a pattern-matching operator for filenames ([Chapter 2](ch02.xhtml#ch_shell)).
    Curly brace expansion, on the other hand, does not depend on filenames in any
    way. It just evaluates to a list of strings. You can use brace expansion to *print*
    filenames, but no pattern matching occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Brace expansion also can produce sequences of letters, which `seq` cannot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Brace expansion always produces output on a single line separated by space
    characters. Change this by piping the output to other commands, such as `tr` (see
    [“The tr Command”](#section_tr)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an alias that prints the *n*th letter of the English alphabet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The find Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `find` command lists files in a directory recursively, descending into
    subdirectories and printing full paths.^([1](ch05.xhtml#idm46586641130912)) Results
    are not alphabetical (pipe the output to `sort` if needed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`find` has numerous options that you can combine. Here are a few highly useful
    ones. Limit the output only to files or directories with the option `-type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Limit the output to names that match a filename pattern with the option `-name`.
    Quote or escape the pattern so the shell doesn’t evaluate it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the name-matching case insensitive with the option `-iname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`find` can also execute a Linux command for *each file path* in the output,
    using `-exec`. The syntax is a bit wonky:'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a `find` command and omit `-print`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append `-exec` followed by the command to execute. Use the expression `{}` to
    indicate where the file path should appear in the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End with a quoted or escaped semicolon, such as `";"` or `\;`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s a toy example to print an `@` symbol on either side of the file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A more practical example performs a long listing (`ls -l`) for all *.conf*
    files in */etc* and its subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`find -exec` works well for mass deletions of files throughout a directory
    hierarchy (but be careful!). Let’s delete files with names ending in a tilde (`~`)
    within the directory *$HOME/tmp* and its subdirectories. For safety, first run
    the command `echo rm` to see which files would be deleted, then remove `echo`
    to delete for real:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The yes Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `yes` command prints the same string over and over until terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What’s the use of this curious behavior? `yes` can supply input to interactive
    programs so they can run unattended. For example, the program `fsck`, which checks
    a Linux filesystem for errors, may prompt the user to continue and wait for a
    response of `y` or `n`. The output of the `yes` command, when piped to `fsck`,
    responds to every prompt on your behalf, so you can walk away and let `fsck` run
    to completion.^([2](ch05.xhtml#idm46586641069200))
  prefs: []
  type: TYPE_NORMAL
- en: 'The main use of `yes` for our purposes is printing a string a specific number
    of times by piping `yes` to `head` (you’ll see a practical example in [“Generating
    Test Files”](ch08.xhtml#section_generate_test)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Isolating Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need just part of a file, the simplest commands to combine and run
    are `grep`, `cut`, `head`, and `tail`. You’ve already seen the first three in
    [Chapter 1](ch01.xhtml#ch_combining_commands): `grep` prints lines that match
    a string, `cut` prints columns from a file, and `head` prints the first lines
    of a file. A new command, `tail`, is the opposite of `head` and prints the last
    lines of a file. [Figure 5-1](#fig_slicers) depicts these four commands working
    together.'
  prefs: []
  type: TYPE_NORMAL
- en: '![head, grep, tail, and cut operating on a file](Images/elcl_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. `head`, `grep`, and `tail` extract lines, and `cut` extracts columns.
    In this example, `grep` matches lines containing the string “blandit.”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, I dive more deeply into `grep`, which does a lot more than
    match plain strings, and explain `tail` more formally. I also preview one feature
    of the command `awk` for extracting columns in a way that `cut` cannot. These
    five commands in combination can isolate pretty much any text using a single pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'grep: A Deeper Look'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve already seen `grep` print lines from a file that match a given string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`grep` also has some highly useful options. Use the `-w` option to match whole
    words only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-i` option to ignore the case of letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-l` option to print only the names of the files that contain matching
    lines, but not the matching lines themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The real power of `grep`, however, appears when you move beyond matching simple
    strings to matching patterns, called *regular expressions*.^([3](ch05.xhtml#idm46586641019488))
    The syntax is different from filename patterns; a partial description is in [Table 5-1](#table_regex).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Some regular expression syntax shared by `grep`, `awk`, and `sed`​^([a](ch05.xhtml#idm46586641014224))
  prefs: []
  type: TYPE_NORMAL
- en: '| To match this: | Use this syntax: | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Beginning of a line | `^` | `^a` = Line beginning with `a` |'
  prefs: []
  type: TYPE_TB
- en: '| End of a line | `$` | `!$` = Line ending with an exclamation point |'
  prefs: []
  type: TYPE_TB
- en: '| Any single character (except newline) | `.` | `…` = Any three consecutive
    characters |'
  prefs: []
  type: TYPE_TB
- en: '| A literal caret, dollar sign, or any other special character *`c`* | `\`*c*
    | `\$` = A literal dollar sign |'
  prefs: []
  type: TYPE_TB
- en: '| Zero or more occurrences of expression *E* | *`E`*`*` | `_*` = Zero or more
    underscores |'
  prefs: []
  type: TYPE_TB
- en: '| Any single character in a set | `[`*`characters`*`]` | `[aeiouAEIOU]` = Any
    vowel |'
  prefs: []
  type: TYPE_TB
- en: '| Any single character *not* in a set | `[^`*`characters`*`]` | `[^aeiouAEIOU]`
    = Any nonvowel |'
  prefs: []
  type: TYPE_TB
- en: '| Any character in a given range between *`c`[1]* and *`c`[2]* | `[`*`c`[1]*`-`*`c`[2]*`]`
    | `[0-9]` = Any digit |'
  prefs: []
  type: TYPE_TB
- en: '| Any character *not* in a given range between *`c`[1]* and *`c`[2]* | `[^`*`c`[1]*`-`*`c`[2]*`]`
    | `[^0-9]` = Any nondigit |'
  prefs: []
  type: TYPE_TB
- en: '| Either of two expressions *`E`[1]* or *`E`[2]* | *`E`[1]*`\&#124;`*`E`[2]*
       for grep and sed | `one\&#124;two` = Either `one` or `two` |'
  prefs: []
  type: TYPE_TB
- en: '| *`E`[1]*`&#124;`*`E`[2]*    for awk | `one&#124;two` = Either `one` or `two`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Grouping expression *`E`* for precedence | `\(`*`E`*`\)`    for grep and
    sed ^([b](ch05.xhtml#idm46586640940032)) | `\(one\&#124;two\)*` = Zero or more
    occurrences of `one` or `two` |'
  prefs: []
  type: TYPE_TB
- en: '| `(`*`E`*`)`    for awk | `(one&#124;two)*` = Zero or more occurrences of
    `one` or `two` |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch05.xhtml#idm46586641014224-marker)) The three commands also differ
    in their treatment of regular expressions; [Table 5-1](#table_regex) presents
    a partial list.^([b](ch05.xhtml#idm46586640940032-marker)) For `sed`, this syntax
    does more than grouping; see [“Matching subexpressions with sed”](#section_sed_subexpressions).
    |'
  prefs: []
  type: TYPE_TB
- en: 'Here are some example `grep` commands with regular expressions. Match all lines
    that begin with a capital letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Match all nonblank lines (i.e., match blank lines and use `-v` to omit them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Match all lines that contain either *cookie* or *cake*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Match all lines at least five characters long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Match all lines in which a less-than symbol appears somewhere before a greater-than
    symbol, such as lines of HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Regular expressions are great, but sometimes they get in the way. Suppose you
    want to search for the two lines in the *frost* file that contain a `w` followed
    by a period. The following command produces the wrong results, because a period
    is a regular expression meaning “any character”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To work around this problem, you can escape the special character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'but this solution becomes cumbersome if you have many special characters to
    escape. Fortunately, you can force `grep` to forget about regular expressions
    and search for every character literally in the input by using the `-F` (“fixed”)
    option; or, for an alternative with equivalent results, run `fgrep` instead of
    `grep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`grep` has many other options; I’ll present just one more that solves a common
    problem. Use the `-f` option (lowercase; don’t confuse it with `-F`) to match
    against a set of strings rather than a single string. As a practical example,
    let’s list all shells found in the file */etc/passwd*, which I introduced in [“Command
    #5: sort”](ch01.xhtml#section_sort). As you may recall, each line in */etc/passwd*
    contains information about a user, organized as colon-separated fields. The final
    field on each line is the program launched when the user logs in. This program
    is often but not always a shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'How can you tell if a program is a shell? Well, the file */etc/shells* lists
    all valid login shells on a Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you can list all valid shells in */etc/passwd* by extracting the seventh
    field with `cut`, eliminating duplicates with `sort -u`, and checking the results
    against */etc/shells* with `grep -f`. I also add the `-F` option to be cautious,
    so all lines in */etc/shells* are taken literally, even if they contain special
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The tail Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `tail` command prints the last lines of a file—10 lines by default. It’s
    a partner to the `head` command. Suppose you have a file named *alphabet* containing
    26 lines, one per letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the last three lines with `tail`. The option `-n` sets the number of
    lines to be printed, just as it does for `head`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you precede the number with a plus sign (`+`), printing begins at that line
    number and proceeds to the end of the file. The following command begins at the
    25th line of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine `tail` and `head` to print any range of lines from a file. To print
    the fourth line alone, for example, extract the first four lines and isolate the
    last one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, to print lines *M* through *N*, extract the first *N* lines with
    `head`, then isolate the last *N-M+1* lines with `tail`. Print lines six through
    eight of the *alphabet* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`head` and `tail` both support a simpler syntax to specify a number of lines
    without `-n`. This syntax is ancient, undocumented, and deprecated but will probably
    remain supported forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The awk {print} Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command `awk` is a general-purpose text processor with hundreds of uses.
    Let’s preview one small feature, `print`, that extracts columns from a file in
    ways that `cut` cannot. Consider the system file */etc/hosts*, which includes
    IP addresses and hostnames separated by any amount of whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to isolate hostnames by printing the second word on each line.
    The challenge is that each hostname is preceded by an arbitrary amount of whitespace.
    `cut` needs its columns either lined up neatly by column number (`-c`) or separated
    by a single consistent character (`-f`). You need a command to print the second
    word on each line, which `awk` provides with ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`awk` refers to any column by a dollar sign followed by the column number:
    for example, `$7` for the seventh column. If the column number has more than one
    digit, surround the number with parentheses: for example, `$(25)`. To refer to
    the final field, use `$NF` (“number of fields”). To refer to the entire line,
    use `$0`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`awk` does not print whitespace between values by default. If you want whitespace,
    separate the values with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`awk`’s `print` statement is great for processing the output of commands that
    strays outside tidy columns. An example is `df`, which prints the amount of free
    and used disk space on a Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The column locations may vary depending on the length of the `Filesystem` paths,
    the disk sizes, and the options you pass to `df`, so you can’t reliably extract
    values with `cut`. With `awk`, however, you can easily isolate (say) the fourth
    value on each line, representing available disk space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'and even remove the first line (the header) at the same time with a little
    `awk` magic, printing only line numbers greater than 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you encounter input separated by something other than space characters,
    `awk` can change its field separator to any regular expression with the `-F` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You’ll learn more details about `awk` in [“awk essentials”](#section_awk).
  prefs: []
  type: TYPE_NORMAL
- en: Combining Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You already know several commands that combine text from different files. The
    first is `cat`, which prints the contents of multiple files to stdout. It’s a
    joiner of files top-to-bottom. That’s where its name comes from—it con*cat*enates
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command you’ve seen for combining text is `echo`, the shell builtin
    that prints whatever arguments you give it, separated by a single space character.
    It combines strings side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine some more commands that combine text:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tac`'
  prefs: []
  type: TYPE_NORMAL
- en: A bottom-to-top combiner of text files
  prefs: []
  type: TYPE_NORMAL
- en: '`paste`'
  prefs: []
  type: TYPE_NORMAL
- en: A side-by-side combiner of text files
  prefs: []
  type: TYPE_NORMAL
- en: '`diff`'
  prefs: []
  type: TYPE_NORMAL
- en: A command that interleaves text from two files by printing their differences
  prefs: []
  type: TYPE_NORMAL
- en: The tac Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tac` command reverses a file line by line. Its name is *cat* spelled backward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice I concatenated three files before reversing the text. If I instead provide
    multiple files to `tac` as arguments, it reverses the lines of each file in turn,
    producing different output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`tac` is great for processing data that is already in chronological order but
    not reversible with the `sort -r` command. A typical case is reversing a web-server
    log file to process its lines from newest to oldest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The lines are in chronological order with timestamps, but they aren’t in alphabetical
    or numeric order, so the `sort -r` command isn’t helpful. The `tac` command can
    reverse these lines without needing to consider the timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: The paste Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `paste` command combines files side by side in columns separated by a single
    tab character. It’s a partner to the `cut` command, which extracts columns from
    a tab-separated file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the separator to another character, such as a comma, with the option
    `-d` (meaning “delimiter”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Transpose the output, producing pasted rows instead of pasted columns, with
    the `-s` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`paste` also interleaves data from two or more files if you change the separator
    to a newline character (`\n`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The diff Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`diff` compares two files line by line and prints a terse report about their
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The notation `1c1` represents a change or difference between the files. It means
    that line 1 in the first file differs from line 1 in the second file. This notation
    is followed by the relevant line from *file1*, a three-dash separator (`---`),
    and the relevant line from *file2*. The leading symbol `<` always indicates a
    line from the first file, and `>` indicates a line from the second file.
  prefs: []
  type: TYPE_NORMAL
- en: The notation `2a3` represents an addition. It means that *file2* has a third
    line not present after the second line of *file1*. This notation is followed by
    the extra line from *file2*, “Have a nice day.”
  prefs: []
  type: TYPE_NORMAL
- en: '`diff` output may contain other notation and can take other forms. This short
    explanation is enough for our main purpose, however, which is to use `diff` as
    a text processor that interleaves lines from two files. Many users don’t think
    of `diff` this way, but it’s great for forming pipelines to solve certain kinds
    of problems. For example, you can isolate the differing lines with `grep` and
    `cut`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see practical examples in [“Technique #4: Process Substitution”](ch07.xhtml#section_process_substitution)
    and [“Checking Matched Pairs of Files”](ch08.xhtml#section_matched_pairs).'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.xhtml#ch_combining_commands) introduced several commands that
    read text from stdin and transform it into something else on stdout. `wc` prints
    a count of lines, words, and characters; `sort` arranges lines into alphabetical
    or numeric order; and `uniq` consolidates duplicate lines. Let’s discuss several
    more commands that transform their input:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tr`'
  prefs: []
  type: TYPE_NORMAL
- en: Translates characters into other characters
  prefs: []
  type: TYPE_NORMAL
- en: '`rev`'
  prefs: []
  type: TYPE_NORMAL
- en: Reverses characters on a line
  prefs: []
  type: TYPE_NORMAL
- en: '`awk` and `sed`'
  prefs: []
  type: TYPE_NORMAL
- en: General-purpose transformers
  prefs: []
  type: TYPE_NORMAL
- en: The tr Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tr` translates one set of characters into another. I showed you one example
    in [Chapter 2](ch02.xhtml#ch_shell) of translating colons into newline characters
    to print the shell’s `PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`tr` takes two sets of characters as arguments, and it translates members of
    the first set into the corresponding members of the second. Common uses are converting
    text to uppercase or lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'converting spaces into newlines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'and deleting whitespace with the `-d` (delete) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The rev Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `rev` command reverses the characters of each line of input:^([4](ch05.xhtml#idm46586640664208))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Beyond the obvious entertainment value, `rev` is handy for extracting tricky
    information from files. Suppose you have a file of celebrity names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: and you want to extract the final word on each line (Curtis, Deschanel, Coleman,
    Rihanna). This would be easy with `cut -f` if each line had the same number of
    fields, but the number varies. With `rev`, you can reverse all the lines, cut
    the *first* field, and reverse again to achieve your goal:^([5](ch05.xhtml#idm46586640655616))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The awk and sed Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`awk` and `sed` are general-purpose “supercommands” for processing text. They
    can do most everything that the other commands in this chapter do, but with more
    cryptic-looking syntax. As a simple example, they can print the first 10 lines
    of a file like `head` does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also do things that our other commands cannot, like replace or swap
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`awk` and `sed` are harder to learn than the other commands I’ve covered, because
    each of them has a miniature programming language built in. They have so many
    capabilities that whole books have been written on them.^([6](ch05.xhtml#idm46586640635552))
    I highly recommend spending quality time learning both commands (or at least one
    of them). To begin your journey, I cover basic principles of each command and
    demonstrate some common uses. I also recommend several online tutorials to learn
    more about these powerful, crucial commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t worry about memorizing every feature of `awk` or `sed`. Success with
    these commands really means:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the *kinds* of transformations they make possible, so you can
    think, “Ah! This is a job for `awk` (or `sed`)!” and apply them in your time of
    need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to read their manpages and to find complete solutions on [Stack Exchange](https://oreil.ly/0948M)
    and other online resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: awk essentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`awk` transforms lines of text from files (or stdin) into any other text, using
    a sequence of instructions called an *awk program*.^([7](ch05.xhtml#idm46586640622768))
    The more skilled you become in writing awk programs, the more flexibly you can
    manipulate text. You can supply the awk program on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also store one or more awk programs in files and refer to them with
    the `-f` option, and the programs run in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'An awk program includes one or more *actions*, such as calculating values or
    printing text, that run when an input line matches a *pattern*. Each instruction
    in the program has the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Typical patterns include:'
  prefs: []
  type: TYPE_NORMAL
- en: The word `BEGIN`
  prefs: []
  type: TYPE_NORMAL
- en: Its action runs just once, before `awk` processes any input.
  prefs: []
  type: TYPE_NORMAL
- en: The word `END`
  prefs: []
  type: TYPE_NORMAL
- en: Its action runs just once, after `awk` has processed all the input.
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression (see [Table 5-1](#table_regex)) surrounded by forward slashes
  prefs: []
  type: TYPE_NORMAL
- en: An example is `/^[A-Z]/` to match lines that begin with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: Other expressions specific to `awk`
  prefs: []
  type: TYPE_NORMAL
- en: For example, to check whether the third field on an input line (`$3`) begins
    with a capital letter, a pattern would be `$3~/^[A-Z]/`. Another example is `FNR>5`,
    which tells `awk` to skip the first five lines of input.
  prefs: []
  type: TYPE_NORMAL
- en: 'An action with no pattern runs for every line of input. (Several awk programs
    in [“The awk {print} Command”](#section_awk_preview) were of this type.) As an
    example, `awk` elegantly solves the “print the celebrity’s last name” problem
    from [“The rev Command”](#section_rev) by directly printing the final word from
    each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When supplying an awk program on the command line, enclose it in quotes to prevent
    the shell from evaluating `awk`’s special characters. Use single or double quotes
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pattern with no action runs the default action `{print}`, which just prints
    any matching input lines unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'For a fuller demonstration, process the tab-separated file *animals.txt* from
    [Example 1-1](ch01.xhtml#example_animals.txt) to produce a tidy bibliography,
    converting lines from this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'to this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This feat requires rearranging three fields and adding some characters like
    parentheses and double quotes. The following awk program does the trick, employing
    the option `-F` to change the input separator from spaces to tabs (`\t`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a regular expression to process only the “horse” book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Or process only books from 2010 or later, by testing whether field `$3` matches
    `^201`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a `BEGIN` instruction to print a friendly heading, some dashes
    for indenting, and an `END` instruction to direct the reader to further information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`awk` does much more than print—it can also perform calculations, like summing
    the numbers 1 to 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: To learn `awk` beyond what can be covered in a few book pages, take an `awk`
    tutorial at [tutorialspoint.com/awk](https://www.tutorialspoint.com/awk/) or [riptutorial.com/awk](https://riptutorial.com/awk)
    or search the web for “awk tutorial.” You’ll be glad you did.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the duplicate file detector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [“Detecting Duplicate Files”](ch01.xhtml#sec_duplicate_files), you constructed
    a pipeline that detects and counts duplicate JPEG files by checksum, but it was
    not powerful enough to print the filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you know `awk`, you have the tools to print the filenames as well.
    Let’s construct a new command that reads each line of `md5sum` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: and not only counts occurrences of each checksum but also stores the filenames
    for printing. You’ll need two additional `awk` features called *arrays* and *loops*.
  prefs: []
  type: TYPE_NORMAL
- en: An *array* is a variable that holds a collection of values. If the array is
    named `A` and holds seven values, then the values could be accessed as `A[1]`,
    `A[2]`, `A[3]`, up to `A[7]`. The values 1 through 7 are called the *keys* of
    the array, and `A[1]` through `A[7]` are called the array’s *elements*. You can
    create any keys you want, however. If you’d rather access the seven elements of
    your array using the names of Disney characters, go ahead and name them `A["Doc"]`,
    `A["Grumpy"]`, `A["Bashful"]`, all the way to `A["Dopey"]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To count duplicate images, create an array called `counts` with one element
    for each checksum. Each array key is a checksum, and the associated element holds
    the number of times that checksum occurs in the input. For example, the array
    element `counts["f6464ed766daca87ba407aede21c8fcc"]` could have value 3\. The
    following awk script examines each line of `md5sum` output, isolates the checksum
    (`$1`), and uses it as a key for the `counts` array. The operator `++` increments
    an element by 1 each time `awk` encounters its associated checksum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the awk script produces no output—it just counts each checksum and
    exits. To print the counts, you need a second `awk` feature called a `for` loop.
    A `for` loop steps through an array, key by key, and processes each element in
    sequence, using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, print each array element by its key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Place this loop in the `END` instruction so it runs after all the counts are
    calculated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the checksums to the output. Each array key is a checksum, so just
    print the key after the count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'To collect and print filenames, use a second array, `names`, also with checksums
    as its keys. As `awk` processes each line of output, append the filename (`$2`)
    to the corresponding element of the `names` array, along with a space as a separator.
    In the `END` loop, after printing the checksum (`key`), print a colon and the
    collected filenames for that checksum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines that begin with 1 represent checksums that occur only once, so they are
    not duplicates. Pipe the output to `grep -v` to remove these lines, then sort
    the results numerically, high to low, with `sort -nr` and you have your desired
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: sed essentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`sed`, like `awk`, transforms text from files (or stdin) into any other text,
    using a sequence of instructions called a *sed script*.^([8](ch05.xhtml#idm46586640479648))
    sed scripts are pretty cryptic on first glance. An example is `s/Windows/Linux/g`,
    which means to replace every occurrence of the string `Windows` with `Linux`.
    The word *script* here does not mean a file (like a shell script) but a string.^([9](ch05.xhtml#idm46586640476576))
    Invoke `sed` with a single script on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'or use the `-e` option to supply multiple scripts that process the input in
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also store sed scripts in files and refer to them with the `-f` option,
    and they run in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `awk`, the utility of `sed` depends on your skill in creating sed scripts.
    The most common type of script is a substitution script that replaces strings
    with other strings. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'where *`regexp`* is a regular expression to match against each input line (see
    [Table 5-1](#table_regex)), and *`replacement`* is a string to replace the matched
    text. As a simple example, change one word into another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When supplying a sed script on the command line, enclose it in quotes to prevent
    the shell from evaluating `sed`’s special characters. Use single or double quotes
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '`sed` easily solves the “print the celebrity’s last name” problem from [“The
    rev Command”](#section_rev) with a regular expression. Just match all characters
    (`.*`) up to the last space and replace them with nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Substitution and Slashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The forward slashes in a substitution may be replaced by any other convenient
    character. This is helpful when a regular expression itself includes forward slashes
    (which would otherwise need escaping). These three sed scripts are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'You may follow a substitution with several options to affect its behavior.
    The option `i` makes matches case insensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The option `g` (“global”) replaces all occurrences of the regular expression
    instead of just the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common type of sed script is a deletion script. It removes lines by
    their line number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'or lines that match a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Matching subexpressions with sed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose you have some filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'and want to produce new names, *image1.jpg*, *image2.jpg*, and *image3.jpg*.
    `sed` can split the filenames into parts and rearrange them via a feature called
    *subexpressions*. First, create a regular expression that matches the filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'You want to move the final digit earlier in the filename, so isolate that digit
    by surrounding it with the symbols `\(` and `\)`. This defines a subexpression—a
    designated part of a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '`sed` can refer to subexpressions by number and manipulate them. You created
    only one subexpression, so its name is `\1`. A second subexpression would be `\2`,
    and so on, up to a maximum of `\9`. Your new filenames would have the form `image\1.jpg`.
    Therefore, your sed script would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'To make things more complicated, suppose the filenames had more variation,
    consisting of lowercase words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three subexpressions to capture the base filename, extension, and final
    digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect them with escaped dots (`\.`) to form this regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Represent the newly transformed filenames to `sed` as `\1\3.\2`, and the final
    substitution with `sed` becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This command does not rename files—it just prints the new names. The section
    [“Inserting a Filename into a Sequence”](ch08.xhtml#section_insert_filename_sequence)
    shows a similar example that performs the renaming as well.
  prefs: []
  type: TYPE_NORMAL
- en: To learn `sed` beyond what can be covered in a few book pages, take a `sed`
    tutorial at [tutorialspoint.com/sed](https://www.tutorialspoint.com/sed) or [grymoire.com/Unix/Sed.html](https://www.grymoire.com/Unix/Sed.html)
    or search the web for “sed tutorial.”
  prefs: []
  type: TYPE_NORMAL
- en: Toward an Even Larger Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Linux systems come with thousands of command-line programs, and most of
    them have numerous options that change their behavior. You’re not likely to learn
    and remember them all. So, in a moment of need, how do you locate a new program—or
    tailor a program that you already know—to accomplish your goals?
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first (obvious) step is a web search engine. For example, if you need
    a command that limits the width of lines in a text file, wrapping any lines that
    are too long, search the web for (say) “Linux command wrap lines” and you’ll be
    pointed to the `fold` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'To discover commands that are already installed on your Linux system, run the
    command `man -k` (or equivalently, `apropos`). Given a word, `man -k` searches
    for that word in the brief descriptions at the top of manpages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '`man -k` accepts `awk`-style regular expressions in search strings (see [Table 5-1](#table_regex)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'A command that’s not installed on your system might still be installable through
    your system’s package manager. A package manager is software for installing Linux
    programs that are supported for your system. Some popular package managers include
    `apt`, `dnf`, `emerge`, `pacman`, `rpm`, `yum`, and `zypper`. Use the `man` command
    to figure out which package manager is installed on your system and learn how
    to search for uninstalled packages. Often it’s a two-command sequence: one command
    to copy the latest data about available packages (“metadata”) from the internet
    onto your system, and another to search the metadata. For example, for Ubuntu
    or Debian Linux-based systems, the commands are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'If, after much searching, you cannot locate or construct an appropriate command
    to meet your needs, consider asking for help in an online forum. A great starting
    point for asking effective questions is Stack Overflow’s [“How Do I Ask a Good
    Question?” help page](https://oreil.ly/J0jho). In general, present your questions
    in a way that is respectful of other people’s time, and experts will be more inclined
    to answer. That means making your question short and to the point, including any
    error messages or other output word for word, and explaining what you have tried
    so far on your own. Spend quality time to ask a quality question: you’ll not only
    increase your chances of a helpful answer, but also, if the forum is public and
    searchable, a clear question and answer may aid others who have a similar problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve now grown beyond the pint-sized toolbox from [Chapter 1](ch01.xhtml#ch_combining_commands)
    and are ready to tackle more challenging business problems at the command line.
    The coming chapters are filled with practical examples of using your new commands
    in all kinds of situations.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.xhtml#idm46586641130912-marker)) The related command `ls -R` produces
    output in a format that’s less convenient for pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.xhtml#idm46586641069200-marker)) Nowadays, some implementations of
    `fsck` have options `-y` and `-n` to respond yes or no, respectively, to every
    prompt, so the `yes` command is unnecessary here.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch05.xhtml#idm46586641019488-marker)) The name *grep* is short for “get
    regular expression and print.”
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch05.xhtml#idm46586640664208-marker)) Quiz: what does the pipeline `rev
    myfile | tac | rev | tac` do?'
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch05.xhtml#idm46586640655616-marker)) You’ll see simpler solutions with
    `awk` and `sed` shortly, but this double-`rev` trick is handy to know.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch05.xhtml#idm46586640635552-marker)) Including the book [*sed & awk*](https://oreil.ly/FjtTm)
    from O’Reilly.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch05.xhtml#idm46586640622768-marker)) The name *awk* is an acronym for
    Aho, Weinberger, and Kernighan, the program’s creators.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch05.xhtml#idm46586640479648-marker)) The name *sed* is short for “stream
    editor,” because it edits a stream of text.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch05.xhtml#idm46586640476576-marker)) If you’re familiar with the editors
    `vi`, `vim`, `ex`, or `ed`, sed script syntax may look familiar.
  prefs: []
  type: TYPE_NORMAL
