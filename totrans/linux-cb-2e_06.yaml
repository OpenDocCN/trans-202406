- en: Chapter 6\. Managing Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux provides strong basic controls for access to files and directories with
    configurable privileges. Every file and directory has three levels of ownership,
    including user, group, and other; and multiple levels of access, including read,
    write, and execute. You can protect your personal files and control who has access
    to them, and the root user can manage access to commands, scripts, shared files,
    and system files.
  prefs: []
  type: TYPE_NORMAL
- en: Even when you are using stronger access control tools—tools such as SELinux
    or AppArmor—it is still important to get the fundamentals right.
  prefs: []
  type: TYPE_NORMAL
- en: On a Linux system, both human users and system services have user accounts.
    Some system services need user accounts to control privileges, just like human
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every file has three types of ownership: owner, group, and other (sometimes
    *other* is expressed as *world*). The owner is a single user, the group owner
    is a single group, and other is everyone else who has access to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every file has six permission modes—read, write, and executable—and three special
    modes: the *sticky bit*, *setuid*, and *setgid*.'
  prefs: []
  type: TYPE_NORMAL
- en: File permissions control which users can create, read, edit, or delete a file,
    and which users can execute a command. The special modes control who can move,
    delete, or rename a file, and who can execute a command with elevated privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Directory permissions control which users can edit or enter a directory and
    who can read, edit, add, or remove files from a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the fundamental Linux security principle: use the minimum necessary
    privileges to get the job done.'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anyone who can read a file can copy it.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot prevent the root user, or *sudo* users with sufficient privileges,
    from accessing your files.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions and ownership are functions of filesystems and can be bypassed by
    reading a storage device from another Linux instance, such as booting up a live
    Linux from removable media to access the host system, or removing the hard drive
    and connecting it to a different machine. You only need root privileges on the
    system that you mount the storage device on, and do not need to know anything
    about the original file owners and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: On a Linux system the root user, also called the superuser, reigns supreme.
    Root can do almost anything, including editing and deleting other users’ files,
    entering any directory, and running any command. Normal, or unprivileged, users
    may temporarily assume root powers with the *sudo* or *su* commands (see Recipes
    [5.17](ch05.xhtml#rec-su) and [5.18](ch05.xhtml#rec-sudo)).
  prefs: []
  type: TYPE_NORMAL
- en: Every user has a unique identification (UID), and belongs to at least one group
    (see [Recipe 5.1](ch05.xhtml#rec-uid-gid)). Every user in a group shares the permissions
    of that group.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what all of this looks like, take a look at */etc*, which contains system
    configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The command output shows the directory’s *mode*, or set of permissions, in two
    forms, *755:drwxr-xr-x*. *755* is octal notation, and *drwxr-xr-x* is symbolic
    notation. These are two different ways of expressing the same mode, which in this
    example is unrestricted privileges for the directory owner, and group and other
    may only enter the directory. File modes are discussed in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*root:root* is the owner and group. Files and directories can have different
    owners and groups; for example, */etc/cups* is owned by *root:lp*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn about the special modes: the *sticky bit*, *setuid*,
    and *setgid*. The setuid and setgid modes elevate user and group permissions to
    the same level as the file owner. These are used only in special cases, and used
    very carefully because privilege escalation is a potential security risk. The
    sticky bit prevents anyone but the file owner, or anyone with root privileges,
    from deleting, renaming, or moving files they do not own in a directory, such
    as */tmp*.'
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to set ownership and modes, create and delete files and directories,
    configure default privileges, transfer file ownership to a different user or group,
    and copy, move, and rename files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Using sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the examples in this recipe use the dollar sign command prompt, $, which
    indicates an unprivileged user. Depending on your own file permissions, you may
    need *sudo* for some operations.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Creating Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to organize your files by placing them in directories.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *mkdir* command to create directories. The following example creates
    a new subdirectory in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a subdirectory two levels down inside the current directory, and its
    parent directories, with the *-p* (parent) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new top-level directory, which is relative to root, /. You need root
    privileges to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set permissions when you create a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Files are created by applications, such as word processors and image editors,
    and special commands like *touch*. The *touch* command creates a new empty file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See [Recipe 6.2](#rec-touch-yes) to learn how to use *touch* to quickly create
    batches of files for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are having trouble visualizing file trees, and how all directories are
    relative to /, try the *tree* command. Root, /, is at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You have probably noticed that this is upside down. In the real world, trees
    branch from the root, but the *tree* command displays the directory tree branching
    downward. There is a reason for this: we read screens from the top down.'
  prefs: []
  type: TYPE_NORMAL
- en: This example lists only the top-level directories under root. *-L 2* shows second-level
    directories, *-L 3* goes to three levels, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 6.2](#rec-touch-yes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 mkdir*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 touch*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 yes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 tree*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.2 Quickly Creating a Batch of Files for Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create batches of files to use for testing file permissions, and
    for any testing that needs a lot of files in a hurry.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *touch* command. The following example creates a single new empty file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create 100 new empty files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates 100 new files named *file00*, *file01*, *file02*, and so on. You
    may give them file extensions and name them anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the numbers first in the filename for easy ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A fast way to populate the files with content is to use the *yes* command.
    The following example creates a 500 MB file filled with the repeated line “This
    is a test file”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a batch of 100 files with 1 MB of content in each file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The new files look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may customize this command in a number of ways: filenames, file sizes,
    numbering, and the text for *yes*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples in the recipe pad the numbers in the filenames with leading zeroes
    so they will order correctly. Most graphical file managers handle ordering numbered
    filenames correctly, but the default for *ls* is lexicographic order. The following
    example demonstrates this with a 1- to 3-digit numbering range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Lexicographic ordering treats the filenames as text strings instead of integers
    and characters, and compares each number and letter individually, from left to
    right. Lexicographic ordering doesn’t know that 10 is smaller than 100, only that
    101 follows 100, 102 follows 101, and 10t follows 109 because letters follow numbers,
    so the *t* follows the *9*.
  prefs: []
  type: TYPE_NORMAL
- en: You can use leading zeroes to make all the numbers the same number of characters,
    or list your files with *ls -v*. This treats the numbers in filenames as integers
    and not characters, so they are listed in correct numerical order.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 ls*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 touch*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 yes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.3 Working with Relative and Absolute Filepaths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to understand the difference between relative and absolute filepaths,
    and how to find where you are in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Absolute filepaths always start at the root, */*, such as */boot* and */etc*.
    Relative filepaths are relative to your current directory and do not have a leading
    slash. Suppose you are in your home directory and it contains the following subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the absolute path to *Audiobooks* is */home/madmax/Audiobooks*,
    and the relative path is *Audiobooks*. Use the *cd* command to enter this directory
    with either the absolute path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the relative path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The directory you are in is the current working directory, *cwd*. Confirm your
    *cwd* with the *pwd* (print working directory) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Absolute and relative filepaths are a common source of confusion. Remember that
    when the filepath begins with a slash (/), it is an absolute path. When there
    is no leading slash, it is relative to your current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Some applications and commands require relative paths; for example, *rsync*
    *include* and *exclude* lists use filepaths that are relative to the directories
    being copied.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 pwd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 7](Images/ch07.html#cha-backup-recovery)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.4 Deleting Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You had fun creating a bunch of files and directories, and now you want to get
    rid of them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *rm* (remove) command with caution, because *rm* will happily delete
    everything you tell it to, so be sure you tell it the right files or directories
    to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete a single file, with verbose output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the *-i* flag to prompt for confirmation first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the *-r* (recursive) flag to delete a directory and all of its files and
    subdirectories. Combining *-r* with *-i* will prompt you for confirmation before
    each deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you are confident you don’t need to be prompted for every deletion, omit
    the *-i* option.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example deletes only the *jan* subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This example deletes the *rehearsals* directory and all of its files and subdirectories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Use wildcards to match file names to delete, for example by file extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or by files named with the same text strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If *rm* refuses to delete a file or directory, and you are certain you want
    to delete it, add the *-f* (force) option.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*rm -rf /* will erase your entire root filesystem (if you have root privileges).
    Some folks think it is a funny prank to tell newbies to do this. It is not funny.
    It is fun to run it on a test machine, or on a virtual machine, and observe how
    long the system keeps running because processes in memory are still running, even
    though the filesystem is erased from disk.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 rm*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.5 Copying, Moving, and Renaming Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have directories, and you have files. You want to move files into the directories,
    change filenames, and make copies.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *cp* command for copying, and the *mv* command for moving or renaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example copies two files from the current working directory into the *~/songs2*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The Tilde Represents Your Home Directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tilde is short for your home directory, so in the example, *~/songs2* is
    the same as */home/duchess/songs2/*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy a directory and all of its contents with the *-r* (recursive) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The recursive example only copies the directory and its files. Use the *--parents*
    option to preserve parent directories. The following example copies *songs1* and
    its contents, and preserves the filepath *duchess/music/songs2/*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The other contents of *duchess* and *music* are not copied, only *songs2* and
    its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the *mv* command to move and rename files. This example moves two files
    to another directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example moves a directory into another directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some useful *cp* options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*-a, --archive* preserves all the file attributes, such as mode, ownership,
    and timestamps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-i, --interactive* prompts before overwriting destination files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-u, --update* overwrites an existing destination file only if the source file
    is newer. This saves time when you’re recopying a batch of files, and some of
    the copies are unchanged. (*rsync* is better for efficient file transfers by copying
    only changes, see [Chapter 7](Images/ch07.html#cha-backup-recovery).)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*mv* has some useful options:'
  prefs: []
  type: TYPE_NORMAL
- en: '*-i, --interactive* prompts before overwriting destination files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-n, --no-clobber* prevents overwriting destination files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-u, --update* moves your files only when they are newer than the destination
    files, or when they are moved for the first time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 cp*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 mv*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.6 Setting File Permissions with chmod’s Octal Notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know that the *chmod* (change mode) command supports both octal and symbolic
    notation, and you want to use octal notation to manage file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following examples show how to set different permissions on files using
    octal notation. The first example grants read-write access to the owner of the
    *file.txt* file, and excludes all access for group and world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The file owner can read, edit, and delete the file, while other users can do
    nothing with it, not even read it, though they can see it listed in a file manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a file world readable and writeable, allowing everyone to do whatever
    they want to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, *file.txt* is changed to read-write for the file owner
    and read-only for group and world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A common permission set is to give the owner and group the same permissions,
    such as read-write, and to exclude other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Commands and scripts require the executable bit to be set. This example makes
    the *backup.sh* script executable and read-write for the owner, executable and
    readable for group, and inaccessible to other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Octal notation has four fields, but you probably will use the last three fields
    the most often, and the first field rarely. The first field is reserved for the
    special modes (see [Recipe 6.8](#rec-sticky-octal)).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Octal notation uses integers 0-7\. [Table 6-1](#table-octal-notation) shows
    the relationship between owners and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Octal fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Owner | Group | Other |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Read | 4 | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Write | 2 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Execute | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| No permission | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: A file or directory has one user owner, and one group owner. *Other* is everyone
    else. A directory or executable that is unrestricted to everyone is mode 0777,
    and an unrestricted file is mode 0666.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re not familiar with Linux file permissions, it might help to see them
    in another view, like in [Table 6-2](#permission-description).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2\. Linux file permissions
  prefs: []
  type: TYPE_NORMAL
- en: '| Permission | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *7* | Read, write, execute. Directories differ from files because all directories
    require the executable bit set. You can assign a directory any permissions, just
    like a file, but without the executable bit no one can enter the directory (with
    the *cd* command or in a file manager). Scripts and binary commands must have
    the executable bit set, or they will be treated as ordinary files. |'
  prefs: []
  type: TYPE_TB
- en: '| *6* | Read and write. |'
  prefs: []
  type: TYPE_TB
- en: '| *5* | Read and execute. This is a common permission for commands. |'
  prefs: []
  type: TYPE_TB
- en: '| *4* | Read. |'
  prefs: []
  type: TYPE_TB
- en: '| *3* | Write and execute. |'
  prefs: []
  type: TYPE_TB
- en: '| *2* | Write. |'
  prefs: []
  type: TYPE_TB
- en: '| *1* | Execute. |'
  prefs: []
  type: TYPE_TB
- en: '| *0* | No permission. |'
  prefs: []
  type: TYPE_TB
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 6.8](#rec-sticky-octal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.7 Setting Directory Permissions with chmod’s Octal Notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know that permissions are managed a little differently on directories, and
    you want to manage them with chmod’s octal notation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Directories must have the executable bit set. This might sound a little strange,
    but it is necessary for entering the directory with the *cd* command or with a
    file manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples creates a shared directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This example makes */shared* read-write for the owner and read-only for everyone
    else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The owner has unrestricted privileges to the directory. Group and world may
    enter the directory and read files, but not edit or add files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example applies the same permissions to the existing contents of the directory,
    using the *-R* (recursive) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example restricts the directory and its existing contents to the directory
    owner. Files and directories inside the directory may have different owners and
    permissions, but are still inaccessible to group and world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A common permission set is to give the owner and group the same permissions,
    such as read-write-execute, and to exclude other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a lot of power with groups and directories to control file access.
    Set up groups according to function, for example various teams could each have
    their own exclusive shared directories. Most shops don’t need super-fine-grained
    control and default to more sharing rather than less. Whatever your needs are,
    the old *chmod* command is still the fundamental tool for controlling file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.8 Using the Special Modes for Special Use Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to set some permissions not supported by the traditional user-group-other
    set of permissions, such as allowing unprivileged users to run a command that
    requires elevated permissions, protecting files in a directory shared by multiple
    users, or enforcing certain file permissions in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The special modes are *sticky bit*, *setuid*, and *setgid* (see [Table 6-3](#table-all-modes-octal)).
    The sticky bit is applied to directories that contain files owned by multiple
    users, to prevent users from moving, renaming, or deleting files they do not own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*setuid* is applied to executable files, to elevate any user running the command
    to the same permissions as the owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply *setgid* to a directory, so that all newly created files in the directory
    are assigned to the same group as the directory’s group owner. This is a nice
    trick for enforcing correct ownership in a shared directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*setgid* may also be applied to files, changing the effective group of the
    user to the same group as the file owner.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*setgid* and *setuid* have the potential to create security holes for an intruder
    or an untrustworthy user. It is a best practice to use them only when you can’t
    think of a safer way to accomplish what you want to do, such as using group assignments
    or *sudo*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*setuid* is useful for executable files.'
  prefs: []
  type: TYPE_NORMAL
- en: '*setgid* is useful for directories and files.'
  prefs: []
  type: TYPE_NORMAL
- en: The sticky bit is only for directories. [Table 6-3](#table-all-modes-octal)
    shows the relationship of permissions to owners.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-3\. Octal fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Special modes | Owner | Group | World |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Read |  | 4 | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Write |  | 2 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Execute |  | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| setuid | 4 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| setgid | 2 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Sticky bit | 1 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| No permission | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: The special mode values may be combined (see [Table 6-4](#table-special-values-octal)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-4\. Sticky bit/setgid/setuid values
  prefs: []
  type: TYPE_NORMAL
- en: '| Option name | Octal value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No option set | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Sticky bit set | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| setgid | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Sticky bit and setgid | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| setuid | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Sticky bit and setuid | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| setgid and setuid | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| Sticky bit, setgid, and setuid | 7 |'
  prefs: []
  type: TYPE_TB
- en: 'A more descriptive name for the sticky bit is *restricted deletion bit*. This
    bit prevents unprivileged users from removing or renaming a file in a directory,
    unless they own the file. You can see this on your */tmp* directory, which is
    world readable and writeable, and contains files owned by multiple users. Using
    the sticky bit prevents users from moving, renaming, or deleting files they do
    not own, even if they have write privileges on some files they do not own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The sticky bit is the 1 in 1777.
  prefs: []
  type: TYPE_NORMAL
- en: '*setgid* means set group user identification, and *setuid* is set user identification.
    These are used to elevate the permissions of an unprivileged user to the same
    as the user or group owner. This is how unprivileged users can use the *passwd*
    command to change their own passwords, even though only root has write permissions
    on */etc/passwd*, and everyone else has only read and execute permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In */etc/passwd* the 4 in 4755 is *setuid*, which means all users have root
    powers when they run the command, though their powers are limited to changing
    their own passwords.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.9 Removing the Special Modes in Octal Notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to remove the special modes from a file or directory.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Removing a special mode is a little different from setting it because you need
    to use an extra leading zero, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Or replace the leading zeroes with a leading equals sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.10 Setting File Permissions with chmod’s Symbolic Notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know that the *chmod* (change mode) command supports both octal and symbolic
    notation, and you want to use symbolic notation to manage file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symbolic notation is more complex than octal notation and behaves differently
    according to which operator you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three operators: +, -, and =. You can change permissions for everyone
    with the *a* flag, or individually with *u* for the file owner, *g* for the group,
    and *-o* for other, which is everyone else:'
  prefs: []
  type: TYPE_NORMAL
- en: '*+* adds to existing permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*-* subtracts from existing permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*=* adds new permissions, and removes any permission bits not listed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose that *file.txt* is owner read-write, group read, and other read, or
    *-rw-r--r--*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You want to change it to *-rw-rw-rw-*. Add write permissions to group and other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You could also use *a=rw*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example the owner of *file.txt* changes it from world readable
    and writeable to only the file owner can edit it, and group and world can only
    read it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A common permission set is to give the owner and group the same permissions,
    such as read-write, and to exclude other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Commands and scripts require the executable bit to be set. This example adds
    the executable bit to the existing permissions for the file owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The **`=`** operator is useful for overwriting existing permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to using *chmod*’s symbolic notation reliably is to always be explicit
    and to be mindful of the existing permissions. Add and subtract from existing
    permissions (except with the = operator, which overwrites), and specify *u*, *g*,
    *o*, or *-a*.
  prefs: []
  type: TYPE_NORMAL
- en: '*symbolic* notation is designed to be mnemonic, *r* for read, *w* for write,
    and *x* for execute ([Table 6-5](#table-symbolic-notation-permissions)).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-5\. Symbolic notation permissions
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| r | read |'
  prefs: []
  type: TYPE_TB
- en: '| w | write |'
  prefs: []
  type: TYPE_TB
- en: '| x | execute |'
  prefs: []
  type: TYPE_TB
- en: The notation for users and groups is also mnemonic ([Table 6-6](#table-symbolic-notation-owners)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-6\. Symbolic notation owners
  prefs: []
  type: TYPE_NORMAL
- en: '| Owner | Notation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| user | u |'
  prefs: []
  type: TYPE_TB
- en: '| group | g |'
  prefs: []
  type: TYPE_TB
- en: '| other | o |'
  prefs: []
  type: TYPE_TB
- en: '| all | a |'
  prefs: []
  type: TYPE_TB
- en: Just like octal notation, symbolic notation also supports the special modes
    (see [Recipe 6.11](#rec-sticky-symbolic)).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 10 values in symbolic notation, and unset values (which mean no permissions)
    are represented by a dash, like this example for Duchess’s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In *drwxr-xr-x*, the *d* indicates that this is a directory. There is no comparable
    value in octal notation.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining nine values are divided into three triads, and the three values
    in each triad represent read, write, and execute.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.11 Setting the Special Modes with chmod’s Symbolic Notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to set special modes with *chmod*’s symbolic notation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The special modes include the *sticky bit*, *setuid*, and *setgid*. These are
    all set in the executable fields. (See the end of the Discussion in [Recipe 6.10](#rec-chmod-symbolic)
    if you are not sure what the executable fields are.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The sticky bit is applied to directories that contain files owned by multiple
    users to prevent nonowners from moving, renaming, or deleting the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply *setgid* to a directory to set all newly created files in the directory
    to the same group as the directory. This is a nice trick for enforcing correct
    ownership in a shared directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply *setuid* to an executable file to allow nonroot users to run the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '*setuid* and *setgid* have the potential to open security holes; see the Discussion
    to learn more.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*setuid* is useful for executable files.'
  prefs: []
  type: TYPE_NORMAL
- en: '*setgid* is useful for directories and files.'
  prefs: []
  type: TYPE_NORMAL
- en: The sticky bit is only for directories.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-7](#table-all-modes-symbolic) shows the relationship between owners
    and modes.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-7\. All symbolic modes
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | User | Group | Other |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Read | r | r | r |'
  prefs: []
  type: TYPE_TB
- en: '| Write | w | w | w |'
  prefs: []
  type: TYPE_TB
- en: '| Execute | x | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| setuid | s |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| setgid |  | s |  |'
  prefs: []
  type: TYPE_TB
- en: '| Sticky bit |  |  | t |'
  prefs: []
  type: TYPE_TB
- en: 'A more descriptive name for the sticky bit is *restricted deletion bit*. This
    prevents users from removing or renaming a file in a directory unless they own
    the file. You can see this on your */tmp* directory, which is world readable and
    writeable, and contains files for multiple users. Using the sticky bit prevents
    users from moving, renaming, or deleting files they do not own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*setgid* means set group identification, and *setuid* is set user identification.
    These are used to elevate the permissions of an unprivileged user to the same
    as the file owner. This is how unprivileged users can use the *passwd* command
    to change their own passwords, even though only root has write permissions on
    */etc/passwd*, and everyone else has only read and execute permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '*rws* in the user fields means read, write, and execute for all users, with
    the same permissions as the file owner.'
  prefs: []
  type: TYPE_NORMAL
- en: '*setgid* and *setuid* have the potential to create security holes. It is a
    best practice to use them only when you can’t devise a safer way to accomplish
    what you want to do, such as using group assignments or *sudo*.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.12 Setting Permissions in Batches with chmod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to set permissions on more than one file at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*chmod* supports operating on lists of files. You can also use the *find* command
    and shell wildcards to select the files you want to change.'
  prefs: []
  type: TYPE_NORMAL
- en: You May Need sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you see “Permission denied” messages, use *sudo*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example takes a space-delimited list of files and makes them
    all read-only for everyone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Set permissions for a directory and its contents, including subdirectories,
    with the *-R* (recursive) flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You may use wildcards to select files; for example, to make all *.txt* files
    in the current directory readable and writable to the owner, and to make group
    and other readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a wildcard to select all filenames that start with the same string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This example makes all files in the current directory read-write for the owner
    and group, without changing permissions on the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change the mode of all files belonging to a particular user. You may
    name the user with either their numeric ID or username. This example starts at
    the root of the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need root privileges to search for files in all directories.
  prefs: []
  type: TYPE_NORMAL
- en: The dot (*find .*) tells *find* to start its search in the current directory.
    You can start your search in any directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*-type* limits the results to files, and not directories.'
  prefs: []
  type: TYPE_NORMAL
- en: '*-user* looks for files owned by the specified user.'
  prefs: []
  type: TYPE_NORMAL
- en: '*-exec chmod -v 660 {} \;* is a fabulous little incantation that takes the
    results of the *find* search and runs the *chmod -v 660* command on the results.
    You can use this for pretty much any command that you want to apply to the results
    of a *find* search.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 find*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.13 Setting File and Directory Ownership with chown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to change ownership on a file or directory.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *chown* (change owner) command to change file ownership. The basic
    command syntax is *chown user:group filename*. You may change only the owner,
    *chown user: filename*, or only the group, *chown :group filename*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the owner requires root privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the group owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Change both the user and group owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need root privileges to make changes to files you do not own and to transfer
    file ownership to another user. You can change group file ownership without root
    privileges when you belong to both the original group and the new group.
  prefs: []
  type: TYPE_NORMAL
- en: The colon is optional when you change only the owner and required when you change
    the group.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chown*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.14 Changing Ownership on Batches of Files with chown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to change ownership of directories and their contents, or just the
    contents of directories, a list of files, or change ownership of files from one
    user to another.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*chown* supports operating on lists of files. You can also use the *find* command
    and shell wildcards to list the files you want to change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the owner of several files at once with *chown*, use a space-delimited
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Change files with a certain file extension in the current directory to a new
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Give all of a user’s files in a directory to another user, using their numeric
    UIDs or usernames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the -find_ command to traverse the entire filesystem, or any directory
    and its subdirectories, to give all of a user’s files to another user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transferring ownership of all of a user’s files to another user, or to a different
    group, is useful for cleaning up after users who no longer have accounts on the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chown*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.15 Setting Default Permissions with umask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to understand why files are created with a certain set of default permissions,
    and how to configure the defaults yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The umask (user file-creation mode mask) controls this behavior. To see what
    yours is, run the *umask* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it looks it in symbolic notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This sets your default permissions to 0775 for directories and 0664 for files,
    because the umask “masks” the hardcoded default permissions of 0777 and 0666\.
    Or you can think of it as subtraction, 0777 - 0002 = 0775.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change your umask temporarily for the duration of your current session,
    set it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Set the umask permanently by inserting the line *umask 0022*, or whatever value
    you want, in your *~/.bashrc* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the default umask for all of your users in */etc/login.defs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 6-8](#table-common-umask) shows some common umask values.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*umask* is a Bash shell built-in, and not an executable program stored in */bin*,
    */usr/bin*, or any of the other *bin* (binary) directories.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-8](#table-common-umask) lists some commonly used umask values.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-8\. Common umask values
  prefs: []
  type: TYPE_NORMAL
- en: '| umask | Directories | Files |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0002 | 0775 | 0664 |'
  prefs: []
  type: TYPE_TB
- en: '| 0022 | 0755 | 0644 |'
  prefs: []
  type: TYPE_TB
- en: '| 0007 | 0770 | 0660 |'
  prefs: []
  type: TYPE_TB
- en: '| 0077 | 0700 | 0600 |'
  prefs: []
  type: TYPE_TB
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the Shell Builtin Commands section of *man 1 bash* to learn more about *umask*
    and other Bash built-in commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.16 Creating Shortcuts (Soft and Hard Links) to Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create shortcuts or links to files.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of links in Linux: soft links and hard links. Soft links
    are for files and directories. Hard links are only for files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the *ln* (link) command to create soft and hard links. The following example
    creates a soft link to an external directory, */files/userstuff*, in Mad Max’s
    home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '*/files/userstuff* is the target, and *stuff* is the destination, or soft link
    name. You can name your soft links anything you want, and move and delete them
    without affecting their targets. When you open a soft link, it behaves the same
    way as opening the target.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hard links are copies of files. The default for the *ln* command is to create
    hard links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Soft links are for files and directories, while hard links are only for files.
  prefs: []
  type: TYPE_NORMAL
- en: Soft links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Soft links are more commonly called *symlinks*, short for symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: Symlinks point to files and directories. When the target of a symlink is deleted,
    renamed, or moved, the symlink is broken. If you create a new file with the same
    name as the deleted file, the symlink is restored, even if the content is different.
  prefs: []
  type: TYPE_NORMAL
- en: Symlinks can cross filesystems. You can even create symlinks to files or directories
    that are not permanently available, like USB storage devices or network file shares.
  prefs: []
  type: TYPE_NORMAL
- en: Symlinks are not updated when the target changes (renamed, moved, or deleted).
    You need to create a new symlink and delete the old one.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t manage permissions or ownership on symlinks because only the permissions
    on the target matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Symlinks look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '*File: stuff → /files/userstuff* shows the target that the symlink points to.'
  prefs: []
  type: TYPE_NORMAL
- en: The third line identifies this as a symbolic link.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *l* in *Access: lrwxrwxrwx* identifies this as a symlink.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a symlink looks like in a file listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Hard links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Files are uniquely identified by *inodes*, and inodes are what hard links point
    to, rather than filenames. The *ls* command shows inodes with the *-i* option.
    The inode in this example is 1353, and it is the same for the three hard links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This is because all three inodes point to the same block of data.
  prefs: []
  type: TYPE_NORMAL
- en: Hard links always work because they point directly to inodes. Files with multiple
    hard links can be moved, renamed, and edited, and all hard links remain in sync
    because they all point to the same data block.
  prefs: []
  type: TYPE_NORMAL
- en: Every file on a Linux system starts with a hard link. When you create a hard
    link, you are creating a new filename for an existing data block.
  prefs: []
  type: TYPE_NORMAL
- en: Hard links cannot cross filesystems, but exist only inside a single filesystem.
    For example, if you have */* and */home* on separate partitions, you cannot make
    hard links in */home* for files in */*.
  prefs: []
  type: TYPE_NORMAL
- en: You can make as many hard links to a file as you like, and the disk space occupied
    by the data they point to is always the same, regardless of how many hard links
    it has.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast hard links with making file copies: every copy uses more disk space,
    each copy is independent, and copies can go anywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A file is not completely deleted until all hard links are deleted. You can
    see this with *ls*. The following example shows another view of our example inode
    with three hard links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the File, Size, and Links to a symlink. A hard link is a regular file,
    and note Links: 3\. This shows there are three hard links to the same data. When
    you delete a file with more than one hard link, it is not deleted until you delete
    all of them. Locate all related hard links with the *find* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Symlinks are used a lot in Linux, hard links not so much. Some backup applications
    use inodes for deduplication. In olden times, when filesystems were much smaller,
    running out of inodes was not uncommon. In this case hard links were preferable,
    because symlinks each have their own inodes, but hard links share inodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how many inodes a filesystem has with the *du* command, and how
    many are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: With 1% in use, I’m not running out of inodes anytime soon.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: man 1 ls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.17 Hiding Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to hide some files and directories so that nobody can see them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To hide files so nobody can see them, put them on a storage device only you
    have access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce clutter in your file manager, use *dot files* to ignore files. You
    already have these. Look for a setting like “Show hidden files” in your graphical
    file manager, or use the *-a* option for *ls*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Prefixing any file with a dot makes it a hidden file, though it is really not
    hidden, but ignored until you want to see it. This is used mainly in users’ home
    directories to reduce clutter by not displaying configuration files. These are
    normal files you can edit, delete, or whatever you want.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note the single and double dots at the top of the file list. The single dot
    represents the current directory, and the double dot represents the parent directory.
    Try it with the *cd* command. The first example stays in the current directory,
    the second example changes to the parent directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Run *cd* with no options to return to your home directory, or *cd -* to return
    to the last directory you were in.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the Shell Builtin Commands section of *man 1 bash* to learn more about *cd*
    and other Bash built-in commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
