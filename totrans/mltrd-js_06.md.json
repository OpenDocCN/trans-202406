["```\n# Firefox v88\nUncaught TypeError: invalid array type for the operation\n\n# Chrome v90 / Node.js v16\nUncaught TypeError: [object Int8Array] is not an int32 or BigInt64 typed array.\n```", "```\nstatus = Atomics.wait(typedArray, index, value, timeout = Infinity)\n```", "```\n# Firefox\nUncaught TypeError: waiting is not allowed on this thread\n\n# Chrome v90\nUncaught TypeError: Atomics.wait cannot be called in this context\n```", "```\nawaken = Atomics.notify(typedArray, index, count = Infinity)\n```", "```\npromise = Atomics.waitAsync(typedArray, index, value, timeout = Infinity)\n```", "```\n<html>\n  <head>\n    <title>Shared Memory for Coordination</title>\n    <script src=\"main.js\"></script>\n  </head>\n</html>\n```", "```\nif (!crossOriginIsolated) throw new Error('Cannot use SharedArrayBuffer');\n\nconst buffer = new SharedArrayBuffer(4);\nconst view = new Int32Array(buffer);\n\nfor (let i = 0; i < 4; i++) { ![1](Images/1.png)\n  const worker = new Worker('worker.js');\n  worker.postMessage({buffer, name: i});\n}\n\nsetTimeout(() => {\n  Atomics.notify(view, 0, 3); ![2](Images/2.png)\n}, 500); ![3](Images/3.png)\n```", "```\nself.onmessage = ({data: {buffer, name}}) => {\n  const view = new Int32Array(buffer);\n  console.log(`Worker ${name} started`);\n  const result = Atomics.wait(view, 0, 0, 1000); ![1](Images/1.png)\n  console.log(`Worker ${name} awoken with ${result}`);\n};\n```", "```\n$ npx MultithreadedJSBook/serve .\n```", "```\nif (!crossOriginIsolated) throw new Error('Cannot use SharedArrayBuffer');\n\nconst buffer = new SharedArrayBuffer(4);\nconst view = new Int32Array(buffer);\nconst now = Date.now();\nlet count = 4;\n\nfor (let i = 0; i < 4; i++) { ![1](Images/1.png)\n  const worker = new Worker('worker.js');\n  worker.postMessage({buffer, name: i}); ![2](Images/2.png)\n  worker.onmessage = () => {\n    console.log(`Ready; id=${i}, count=${--count}, time=${Date.now() - now}ms`);\n    if (count === 0) { ![3](Images/3.png)\n      Atomics.notify(view, 0);\n    }\n  };\n}\n```", "```\nself.onmessage = ({data: {buffer, name}}) => {\n  postMessage('ready'); ![1](Images/1.png)\n  const view = new Int32Array(buffer);\n  console.log(`Worker ${name} started`);\n  const result = Atomics.wait(view, 0, 0); ![2](Images/2.png)\n  console.log(`Worker ${name} awoken with ${result}`);\n};\n```", "```\nclass Grid {\n  constructor(size, buffer, paint = () => {}) {\n    const sizeSquared = size * size;\n    this.buffer = buffer;\n    this.size = size;\n    this.cells = new Uint8Array(this.buffer, 0, sizeSquared);\n    this.nextCells = new Uint8Array(this.buffer, sizeSquared, sizeSquared);\n    this.paint = paint;\n  }\n```", "```\n  getCell(x, y) {\n    const size = this.size;\n    const sizeM1 = size - 1;\n    x = x < 0 ? sizeM1 : x > sizeM1 ? 0 : x;\n    y = y < 0 ? sizeM1 : y > sizeM1 ? 0 : y;\n    return this.cells[size * x + y];\n  }\n```", "```\n  static NEIGHBORS = [ ![1](Images/1.png)\n    [-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]\n  ];\n\n  iterate(minX, minY, maxX, maxY) { ![2](Images/2.png)\n    const size = this.size;\n\n    for (let x = minX; x < maxX; x++) {\n      for (let y = minY; y < maxY; y++) {\n        const cell = this.cells[size * x + y];\n        let alive = 0;\n        for (const [i, j] of Grid.NEIGHBORS) {\n          alive += this.getCell(x + i, y + j);\n        }\n        const newCell = alive === 3 || (cell && alive === 2) ? 1 : 0;\n        this.nextCells[size * x + y] = newCell;\n        this.paint(newCell, x, y);\n      }\n    }\n\n    const cells = this.nextCells;\n    this.nextCells = this.cells;\n    this.cells = cells;\n  }\n}\n```", "```\nconst BLACK = 0xFF000000; ![1](Images/1.png)\nconst WHITE = 0xFFFFFFFF;\nconst SIZE = 1000;\n\nconst iterationCounter = document.getElementById('iteration'); ![2](Images/2.png)\nconst gridCanvas = document.getElementById('gridcanvas');\ngridCanvas.height = SIZE;\ngridCanvas.width = SIZE;\nconst ctx = gridCanvas.getContext('2d');\nconst data = ctx.createImageData(SIZE, SIZE); ![3](Images/3.png)\nconst buf = new Uint32Array(data.data.buffer);\n\nfunction paint(cell, x, y) { ![4](Images/4.png)\n  buf[SIZE * x + y] = cell ? BLACK : WHITE;\n}\n\nconst grid = new Grid(SIZE, new ArrayBuffer(2 * SIZE * SIZE), paint); ![5](Images/5.png)\nfor (let x = 0; x < SIZE; x++) { ![6](Images/6.png)\n  for (let y = 0; y < SIZE; y++) {\n    const cell = Math.random() < 0.5 ? 0 : 1;\n    grid.cells[SIZE * x + y] = cell;\n    paint(cell, x, y);\n  }\n}\n\nctx.putImageData(data, 0, 0); ![7](Images/7.png)\n```", "```\nlet iteration = 0;\nfunction iterate(...args) {\n  grid.iterate(...args);\n  ctx.putImageData(data, 0, 0);\n  iterationCounter.innerHTML = ++iteration;\n  window.requestAnimationFrame(() => iterate(...args));\n}\n\niterate(0, 0, SIZE, SIZE);\n```", "```\n<h3>Iteration: <span id=\"iteration\">0</span></h3>\n<canvas id=\"gridcanvas\"></canvas>\n<script src=\"gol.js\"></script>\n```", "```\nconst BLACK = 0xFF000000;\nconst WHITE = 0xFFFFFFFF;\nconst SIZE = 1000;\nconst THREADS = 5; // must be a divisor of SIZE\n\nconst imageOffset = 2 * SIZE * SIZE\nconst syncOffset = imageOffset + 4 * SIZE * SIZE;\n\nconst isMainThread = !!self.window;\n```", "```\nif (isMainThread) {\n  const gridCanvas = document.getElementById('gridcanvas');\n  gridCanvas.height = SIZE;\n  gridCanvas.width = SIZE;\n  const ctx = gridCanvas.getContext('2d');\n  const iterationCounter = document.getElementById('iteration');\n\n  const sharedMemory = new SharedArrayBuffer( ![1](Images/1.png)\n    syncOffset + // data + imageData\n    THREADS * 4 // synchronization\n  );\n  const imageData = new ImageData(SIZE, SIZE);\n  const cells = new Uint8Array(sharedMemory, 0, imageOffset);\n  const sharedImageBuf = new Uint32Array(sharedMemory, imageOffset);\n  const sharedImageBuf8 =\n    new Uint8ClampedArray(sharedMemory, imageOffset, 4 * SIZE * SIZE);\n\n  for (let x = 0; x < SIZE; x++) {\n    for (let y = 0; y < SIZE; y++) {\n      // 50% chance of cell being alive\n      const cell = Math.random() < 0.5 ? 0 : 1;\n      cells[SIZE * x + y] = cell;\n      sharedImageBuf[SIZE * x + y] = cell ? BLACK : WHITE;\n    }\n  }\n\n  imageData.data.set(sharedImageBuf8);\n  ctx.putImageData(imageData, 0, 0);\n```", "```\n  const chunkSize = SIZE / THREADS;\n  for (let i = 0; i < THREADS; i++) {\n    const worker = new Worker('thread-gol.js', { name: `gol-worker-${i}` });\n    worker.postMessage({\n      range: [0, chunkSize * i, SIZE, chunkSize * (i + 1)],\n      sharedMemory,\n      i\n    });\n  }\n\n  const coordWorker = new Worker('thread-gol.js', { name: 'gol-coordination' });\n  coordWorker.postMessage({ coord: true, sharedMemory });\n\n  let iteration = 0;\n  coordWorker.addEventListener('message', () => {\n    imageData.data.set(sharedImageBuf8);\n    ctx.putImageData(imageData, 0, 0);\n    iterationCounter.innerHTML = ++iteration;\n    window.requestAnimationFrame(() => coordWorker.postMessage({}));\n  });\n```", "```\n} else {\n  let sharedMemory;\n  let sync;\n  let sharedImageBuf;\n  let cells;\n  let nextCells;\n\n  self.addEventListener('message', initListener);\n\n  function initListener(msg) {\n    const opts = msg.data;\n    sharedMemory = opts.sharedMemory;\n    sync = new Int32Array(sharedMemory, syncOffset);\n    self.removeEventListener('message', initListener);\n    if (opts.coord) {\n      self.addEventListener('message', runCoord);\n      cells = new Uint8Array(sharedMemory);\n      nextCells = new Uint8Array(sharedMemory, SIZE * SIZE);\n      sharedImageBuf = new Uint32Array(sharedMemory, imageOffset);\n      runCoord();\n    } else {\n      runWorker(opts);\n    }\n  }\n```", "```\n  function runWorker({ range, i }) {\n    const grid = new Grid(SIZE, sharedMemory);\n    while (true) {\n      Atomics.wait(sync, i, 0);\n      grid.iterate(...range);\n      Atomics.store(sync, i, 0);\n      Atomics.notify(sync, i);\n    }\n  }\n```", "```\n  function runCoord() {\n    for (let i = 0; i < THREADS; i++) {\n      Atomics.store(sync, i, 1);\n      Atomics.notify(sync, i);\n    }\n    for (let i = 0; i < THREADS; i++) {\n      Atomics.wait(sync, i, 1);\n    }\n    const oldCells = cells;\n    cells = nextCells;\n    nextCells = oldCells;\n    for (let x = 0; x < SIZE; x++) {\n      for (let y = 0; y < SIZE; y++) {\n        sharedImageBuf[SIZE * x + y] = cells[SIZE * x + y] ? BLACK : WHITE;\n      }\n    }\n    self.postMessage({});\n  }\n}\n```", "```\n$ npx MultithreadedJSBook/serve .\n```", "```\n#!/usr/bin/env node \nconst http = require('http');\n\nconst view = new Int32Array(new SharedArrayBuffer(4));\nsetInterval(() => Atomics.wait(view, 0, 0, 1900), 2000); ![1](Images/1.png)\n\nconst server = http.createServer((req, res) => {\n  res.end('Hello World');\n});\n\nserver.listen(1337, (err, addr) => {\n  if (err) throw err;\n  console.log('http://localhost:1337/');\n});\n```", "```\n$ node main.js\n```", "```\n$ time curl http://localhost:1337\n```"]