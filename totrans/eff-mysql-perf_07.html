<html><head></head><body><section data-pdf-bookmark="Chapter 7. Replication Lag" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch07">&#13;
<h1><span class="label">Chapter 7. </span>Replication Lag</h1>&#13;
&#13;
&#13;
<p><em>Replication lag</em> <a data-primary="replication lag" data-type="indexterm" id="replication-lag1"/>is the delay between the time when a write occurs on a source MySQL instance and the time when that write is applied on a replica MySQL instance.&#13;
Replication lag is inherent to all database servers because replication across a network incurs network latency.</p>&#13;
&#13;
<p>I’m glad that, as an engineer using MySQL, you don’t have to set up, configure, and maintain a MySQL replication topology because MySQL replication has become complex.&#13;
Instead, this chapter investigates replication lag with respect to performance: what it is, why it happens, what risk it poses, and what you can do about it.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45829103665984">&#13;
<h5>Simple Replication Won the Internet</h5>&#13;
<p>Simple replication is one reason that MySQL became the most popular open source relational database server in the world.&#13;
In the early 2000s, the internet was reemerging from the dot-com bubble of the ’90s and online companies were growing fast.&#13;
Since replication is required for high availability and also used to scale out reads, simple replication in early versions of MySQL (v3.23 through v5.5) helped it win the internet in those heedless days.&#13;
Early versions of MySQL used single-threaded <em>statement-based replication</em> (SBR): the source MySQL instance would log the SQL statements that it executed—yes, the actual SQL statements—and replica instances <a data-primary="statement-based replication (SBR)" data-type="indexterm" id="idm45829103663504"/>would simply re-execute those SQL statements.&#13;
Replication doesn’t get simpler than that.&#13;
Yes, it worked, and yes, it had problems and gotchas.&#13;
But sometimes the simplest solution really is the best.&#13;
Now, more than 20 years later, MySQL replication is complex, but it still supports statement-based replication.</p>&#13;
</div></aside>&#13;
&#13;
<p>Technically, yes, replication decreases performance, but you don’t want to run MySQL without it.&#13;
It’s not hyperbole to say that replication prevents businesses from failing—from data loss so catastrophic that, if replication did not prevent it, the company would go out of business.&#13;
MySQL runs everywhere from hospitals to banks, and replication keeps invaluable data safe despite inevitable failures.&#13;
Although replication decreases performance and lag is a risk, these costs are cancelled by the overwhelming benefits of replication.</p>&#13;
&#13;
<p>This chapter investigates replication lag.&#13;
There are six major sections.&#13;
The first introduces basic MySQL replication terminology and traces the technical origins of replication lag—why it happens despite fast databases and networks.&#13;
The second discusses the main causes of replication lag.&#13;
The third explains the risk of replication lag: data loss.&#13;
The fourth provides a conservative configuration for enabling a multithreaded replica, which dramatically reduces lag.&#13;
The fifth looks at monitoring replication lag with high precision.&#13;
The sixth explains why replication lag is slow to recover.<a data-primary="replication lag" data-startref="replication-lag1" data-type="indexterm" id="idm45829103660208"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Foundation" data-type="sect1"><div class="sect1" id="repl-foundation">&#13;
<h1>Foundation</h1>&#13;
&#13;
<p>MySQL has <a data-primary="replication lag" data-secondary="foundation" data-type="indexterm" id="replication-lag-foundation"/>two types of replication:</p>&#13;
<dl>&#13;
<dt>Source to replica</dt>&#13;
<dd>&#13;
<p><em>Source to replica replication</em> is the fundamental type of replication that MySQL has used for more than 20 years.&#13;
Its venerable status means that <a href="https://oreil.ly/A8fTn"><em>MySQL replication</em></a> implies source to replica replication.&#13;
MySQL replication is old, but make no mistake: it’s fast, reliable, and still widely used today.</p>&#13;
</dd>&#13;
<dt>Group Replication</dt>&#13;
<dd>&#13;
<p><a href="https://oreil.ly/TASM9"><em>Group Replication</em></a> is <a data-primary="Group Replication" data-type="indexterm" id="idm45829103650672"/>the new type of replication that MySQL has supported as of MySQL 5.7.17 (released December 12, 2016).&#13;
Group Replication creates a MySQL cluster of primary and secondary instances that use a group consensus protocol to synchronize (replicate) data changes and manage group membership.&#13;
That’s a long way of saying that Group Replication is MySQL clustering, and it is the future of MySQL replication and high availability.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>This chapter covers only traditional MySQL replication: source to replica.&#13;
Group Replication is the future, but I defer coverage to the future because, at the time of this writing, neither I nor any DBAs that I know have significant experience operating Group Replication at scale.&#13;
Moreover, another innovation built on top of Group Replication is becoming the standard: <a href="https://oreil.ly/BFqu9">InnoDB Cluster</a>.</p>&#13;
&#13;
<p>Additionally, <a href="https://oreil.ly/fWNfb">Percona XtraDB Cluster</a> and <a href="https://oreil.ly/LMhEC">MariaDB Galera Cluster</a> are database cluster solutions similar to MySQL Group Replication in purpose but different in implementation.&#13;
I defer coverage of these solutions, too, but keep them in mind if you’re running a Percona <a data-primary="Percona Server" data-secondary="replication" data-type="indexterm" id="idm45829103645584"/>or MariaDB distribution of MySQL and looking for a database cluster solution.</p>&#13;
&#13;
<p>MySQL source to replica replication is ubiquitous.&#13;
Although the inner workings of replication are beyond the scope of this book, understanding the foundation illuminates the causes of replication lag, the risk that it poses, and how to reduce both.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Replication terminology <a data-primary="replication terminology changes" data-type="indexterm" id="idm45829103642768"/>changed as of MySQL 8.0.22 and 8.0.26–released in 2020 and 2021, respectively.&#13;
For a summary of the changes, see <a href="https://oreil.ly/wrzfU">“MySQL Terminology Updates”</a>.&#13;
I use the current terminology, metrics, variables, and commands in this book.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Source to Replica" data-type="sect2"><div class="sect2" id="repl-source-to-replica">&#13;
<h2>Source to Replica</h2>&#13;
&#13;
<p><a data-type="xref" href="#repl-foundation-img">Figure 7-1</a> <a data-primary="source to replica replication" data-type="indexterm" id="source-to-replica-replication"/>illustrates the foundation of MySQL source to replica replication.</p>&#13;
&#13;
<figure><div class="figure" id="repl-foundation-img">&#13;
<img alt="emsp 0701" src="assets/emsp_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>Foundation of MySQL source to replica replication</h6>&#13;
</div></figure>&#13;
&#13;
<p>A <em>source MySQL instance</em> (or <em>source</em> for short) is any MySQL server to which clients (the application) write data.&#13;
MySQL replication supports multiple writable sources, but this is rare due to the difficulty of handling write conflicts.&#13;
Consequently, a single writable source is the norm.</p>&#13;
&#13;
<p>A <em>replica MySQL instance</em> (or <em>replica</em> for short) is any MySQL server that replicates data changes from a source.&#13;
<em>Data changes</em> are modifications to rows, indexes, schemas, and so forth.&#13;
Replicas should always be read-only to avoid split-brain (see <a data-type="xref" href="ch09.html#split-brain">“Split-Brain Is the Greatest Risk”</a>).&#13;
Usually, a replica replicates from a single source, but <a href="https://oreil.ly/GeaVQ">multisource replication</a> is an option.</p>&#13;
&#13;
<p>Arrows in <a data-type="xref" href="#repl-foundation-img">Figure 7-1</a> represent the flow of data changes from the source to a replica:</p>&#13;
<ol>&#13;
<li>&#13;
<p>During transaction commit, data changes are written to <em>binary logs</em> (or <em>binlogs</em> for short) on the source: on-disk files that record data changes in <em>binary log events</em> (see <a data-type="xref" href="#repl-binlog-events">“Binary Log Events”</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>An <em>I/O thread</em> on the replica dumps (reads) binary log events from the source binary logs. (A <em>binlog dump thread</em> on the source is dedicated to this purpose.)</p>&#13;
</li>&#13;
<li>&#13;
<p>The I/O thread on the replica writes the binary log events to <em>relay logs</em> on the replica: on-disk files that are a local copy of the source binary logs.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <em>SQL thread</em> (or <em>applier thread</em>) reads binary log events from the relay log.</p>&#13;
</li>&#13;
<li>&#13;
<p>The SQL thread applies the binary log events to the replica data.</p>&#13;
</li>&#13;
<li>&#13;
<p>The replica writes the data changes (applied by the SQL thread) to its binary logs.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>By default, MySQL replication is asynchronous: on the source, the transaction completes after step 1 and the remaining steps happen asynchronously.&#13;
MySQL supports semisynchronous replication: on the source, the transaction completes after step 3.&#13;
That is not a typo: MySQL semisynchronous replication commits after step 3; it does <em>not</em> wait for step 4 or 5.&#13;
<a data-type="xref" href="#repl-semi-sync">“Semisynchronous Replication”</a> goes into more detail.</p>&#13;
&#13;
<p>Replicas are not required to write binary logs (step 6), but it’s standard practice for high availability because it allows a replica to become the source.&#13;
This is how a database <em>failover</em> works: when the source dies or is taken down for maintenance, a replica is promoted to become the new source.&#13;
Let’s call the instances <em>old source</em> and <em>new source</em>.&#13;
Eventually, a DBA will restore the old source (or clone a new instance to replace it) and make it replicate from the new source.&#13;
In the old source, the previously idle I/O thread, relay logs, and SQL threads (shaded darkly in <a data-type="xref" href="#repl-foundation-img">Figure 7-1</a>) start working.&#13;
(The I/O thread in the old source will connect to the new source, which activates its previously idle binlog dump thread.)&#13;
From the new source binary logs, the old source replicates writes that it missed while it was offline.&#13;
While doing so, the old source reports replication lag, but this is a special case addressed in <a data-type="xref" href="#repl-failures">“Post-Failure Rebuild”</a>.&#13;
That’s failover in a nutshell; but of course, it’s more complex in practice.<a data-primary="source to replica replication" data-startref="source-to-replica-replication" data-type="indexterm" id="idm45829103611168"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Binary Log Events" data-type="sect2"><div class="sect2" id="repl-binlog-events">&#13;
<h2>Binary Log Events</h2>&#13;
&#13;
<p>Binary log events <a data-primary="binary log events" data-type="indexterm" id="binary-log-events"/>are a low-level detail that you probably won’t encounter (even DBAs don’t often mess around in binary logs), but they are a direct result of transactions executed by the application.&#13;
Therefore, it’s important to understand what the application is trying to flush through the plumbing of replication.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The following presumes row-based replication (RBR), which is the default <a href="https://oreil.ly/rtKm0"><code>binlog_format</code></a> as of MySQL 5.7.7.</p>&#13;
</div>&#13;
&#13;
<p>Replication focuses on transactions and binary log events, not individual writes, because data changes are committed to binary logs during transaction commit, at which point writes have already completed.&#13;
At a high level, the focus is transactions because they are meaningful to the application.&#13;
At a low level, the focus is binary log events because they are meaningful to replication.&#13;
Transactions are logically represented and delineated in binary logs as events, which is how multithread replicas can apply them in parallel—more on this in <a data-type="xref" href="#repl-mtr">“Reducing Lag: Multithreaded Replication”</a>.&#13;
To illustrate, let’s use a simple transaction:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
UPDATE t1 SET c='val' WHERE id=1 LIMIT 1;&#13;
DELETE FROM t2 LIMIT 3;&#13;
COMMIT;</pre>&#13;
&#13;
<p>The table schemas and data do not matter.&#13;
What’s important is that the <code>UPDATE</code> changes one row in table <code>t1</code>, and the <code>DELETE</code> deletes three rows from table <code>t2</code>.&#13;
<a data-type="xref" href="#repl-binlog-events-img">Figure 7-2</a> illustrates how that transaction is committed in a binary log.</p>&#13;
&#13;
<p>Four contiguous events constitute the transaction:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An event for <code>BEGIN</code></p>&#13;
</li>&#13;
<li>&#13;
<p>An event for the <code>UPDATE</code> statement with one row image</p>&#13;
</li>&#13;
<li>&#13;
<p>An event for the <code>DELETE</code> statement with three row images</p>&#13;
</li>&#13;
<li>&#13;
<p>An event for <code>COMMIT</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>At this low level, SQL statements essentially disappear and replication is a stream of events and row images (for events that modify rows).&#13;
A <em>row image</em> is a binary snapshot of a row before and after modification.&#13;
This is an important detail because a single SQL statement can generate countless row images, which yields a large transaction that might cause lag as it flows through replication.</p>&#13;
&#13;
<figure><div class="figure" id="repl-binlog-events-img">&#13;
<img alt="emsp 0702" src="assets/emsp_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>Binary log events for a transaction</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s stop here because we’re a little deeper into MySQL internals than we should be for this book.&#13;
Although brief, this introduction to binary log events makes the following sections more intelligible because now you know what’s flowing through the plumbing of replication and why the foci are transactions and binary log events.<a data-primary="binary log events" data-startref="binary-log-events" data-type="indexterm" id="idm45829103589152"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Replication Lag" data-type="sect2"><div class="sect2" id="repl-lag">&#13;
<h2>Replication Lag</h2>&#13;
&#13;
<p>Referring <a data-primary="replication lag" data-type="indexterm" id="replication-lag2"/>back to <a data-type="xref" href="#repl-foundation-img">Figure 7-1</a>, replication lag occurs when applying changes on a replica (step 5) is slower than committing changes on the source (step 1).&#13;
The steps in between are rarely a problem (when the network is working properly) because MySQL binary logs, the MySQL network protocol, and typical networks are very fast and efficient.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><em>Apply changes</em> is short for <em>apply transactions</em> or <em>apply events</em>, depending on the context.</p>&#13;
</div>&#13;
&#13;
<p>The I/O thread on a replica can write binary log events to its relay logs at a high rate because this is a relatively easy process: read from network, write sequentially to disk.&#13;
But a SQL thread has a much more difficult and time-consuming process: applying the changes.&#13;
Consequently, the I/O thread outpaces the SQL thread, and replication lag looks like <a data-type="xref" href="#repl-lag-img">Figure 7-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="repl-lag-img">&#13;
<img alt="emsp 0703" src="assets/emsp_0703.png"/>&#13;
<h6><span class="label">Figure 7-3. </span>MySQL replication lag</h6>&#13;
</div></figure>&#13;
&#13;
<p>Strictly speaking, a single SQL thread does not cause replication lag, it’s only the limiting factor.&#13;
The cause, in this case, is high transaction throughput on the source, which is a good problem if the application is busy, but a problem nonetheless.&#13;
More on causes in the next section.&#13;
The solution is more SQL threads, which is covered later in <a data-type="xref" href="#repl-mtr">“Reducing Lag: Multithreaded Replication”</a>.</p>&#13;
&#13;
<p>Semisynchronous replication does not solve or preclude replication lag.&#13;
When semisynchronous replication is enabled, for each transaction, MySQL waits for a replica to acknowledge that it has written the binary log events for the transaction to its relay logs—step 3 in <a data-type="xref" href="#repl-foundation-img">Figure 7-1</a>.&#13;
On a local network, replication lag as depicted in <a data-type="xref" href="#repl-lag-img">Figure 7-3</a> can still occur.&#13;
If semisynchronous reduces replication lag, it’s only a side-effect of network latency throttling transaction throughput on the source.&#13;
<a data-type="xref" href="#repl-semi-sync">“Semisynchronous Replication”</a> goes into more detail.</p>&#13;
&#13;
<p>Lag is inherent to replication, but make no mistake: MySQL replication is very fast.&#13;
A single SQL thread can easily handle thousands of transactions per second.&#13;
The first reason is simple: replicas do not execute the full workload that the source executes.&#13;
Notably, replicas do not execute reads (presuming replicas aren’t used to serve reads).&#13;
The second reason requires a few lines to explain.&#13;
As noted in <a data-type="xref" href="#repl-binlog-events">“Binary Log Events”</a>, this chapter presumes row-based replication (RBR).&#13;
Consequently, replicas do not execute SQL statements: they apply binary log events.&#13;
That saves replicas a lot of time because they’re given the end result—data changes—and told where to apply them.&#13;
That can be significantly faster than finding the matching rows to update, which is what the source had to do.&#13;
As a result of these two reasons, replicas can be nearly idle even while the source is very busy.&#13;
Nevertheless, three causes can overwhelm replication.<a data-primary="replication lag" data-secondary="foundation" data-startref="replication-lag-foundation" data-type="indexterm" id="idm45829103571056"/><a data-primary="replication lag" data-startref="replication-lag2" data-type="indexterm" id="idm45829103569824"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Causes" data-type="sect1"><div class="sect1" id="repl-causes">&#13;
<h1>Causes</h1>&#13;
&#13;
<p>Replication lag <a data-primary="replication lag" data-secondary="causes" data-type="indexterm" id="replication-lag-causes"/>has three main causes: transaction throughput, post-failure rebuilds, and network issues.&#13;
A section for each follows.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transaction Throughput" data-type="sect2"><div class="sect2" id="repl-tps">&#13;
<h2>Transaction Throughput</h2>&#13;
&#13;
<p>Transaction throughput <a data-primary="transaction throughput" data-type="indexterm" id="idm45829103563792"/>causes replication lag when the rate on the source is greater than the rate at which SQL (applier) threads on the replica can apply changes.&#13;
When this happens because the application is legitimately busy, it’s usually not feasible to reduce the rate on the source.&#13;
Instead, the solution is to increase the rate on the replica by running more SQL (applier) threads.&#13;
Focus on improving replica performance by tuning multithreaded replication, as outlined in <a data-type="xref" href="#repl-mtr">“Reducing Lag: Multithreaded Replication”</a>.</p>&#13;
&#13;
<p>Large transactions—ones that modify an inordinate number of rows—have a greater impact on replicas than the source.&#13;
On the source, a large transaction that takes two seconds to execute, for example, most likely does not block other transactions because it runs (and commits) in parallel.&#13;
But on a single-threaded replica, that large transactions blocks all other transactions for two seconds (or however long it takes to execute on the replica—it might be less due to less contention).&#13;
On a multithreaded replica, other transactions continue to execute, but that large transaction still blocks one thread for two seconds.&#13;
The solution is smaller transactions.&#13;
More on this in <a data-type="xref" href="ch08.html#trx-size">“Large Transactions (Transaction Size)”</a>.</p>&#13;
&#13;
<p>Transaction throughput is not always driven by the application: backfilling, deleting, and archiving data are common operations that can cause massive replication lag if they don’t control the batch size, as forewarned in <a data-type="xref" href="ch03.html#batch-size">“Batch Size”</a>.&#13;
In addition to proper batch size, these operations should monitor replication lag and slow down when replicas begin to lag.&#13;
It’s better for an operation to take one day than to lag a replica by one second.&#13;
<a data-type="xref" href="#repl-risk">“Risk: Data Loss”</a> explains why.</p>&#13;
&#13;
<p>At some point, transaction throughput will exceed the capacity of a single MySQL instance—source or replica.&#13;
To increase transaction throughput, you must scale out by sharding the database (see <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Post-Failure Rebuild" data-type="sect2"><div class="sect2" id="repl-failures">&#13;
<h2>Post-Failure Rebuild</h2>&#13;
&#13;
<p>When MySQL <a data-primary="post-failure rebuild" data-type="indexterm" id="idm45829103553824"/>or hardware fails, the instance is fixed and put back into the replication topology.&#13;
Or a new instance is cloned from an existing instance and takes the place of the failed instance.&#13;
Either way, the replication topology is rebuilt to restore high availability.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Replicas are used for several purposes, but this chapter discusses only replicas used for high availability.</p>&#13;
</div>&#13;
&#13;
<p>The fixed (or new) instance will take minutes, hours, or days to <em>catch up</em>: to replicate all the binary log events that it missed while it was offline.&#13;
Technically, this is replication lag, but in practice you can ignore it until the fixed instance has caught up.&#13;
Once caught up, any lag is legitimate.</p>&#13;
&#13;
<p>Since failure is inevitable and catching up takes time, the only solution is to be aware that the replication lag is due to a post-failure rebuild and wait.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Network Issues" data-type="sect2"><div class="sect2" id="repl-network-issues">&#13;
<h2>Network Issues</h2>&#13;
&#13;
<p><em>Network issues</em> <a data-primary="network issues" data-type="indexterm" id="idm45829103547696"/>cause replication lag by delaying the transfer of binary log events from source to replica—step 2 in <a data-type="xref" href="#repl-foundation-img">Figure 7-1</a>.&#13;
Technically, the network—not replication—is lagging, but quibbling about semantics doesn’t change the end result: the replica is <em>behind the source</em>—a long way of saying <em>lagged</em>.&#13;
In this case, you must enlist network engineers to fix the root cause: the network.</p>&#13;
&#13;
<p>The risk caused by a network issue is mitigated by communication and teamwork: talk with the network engineers to ensure that they know what’s at stake for the database when there’s a network issue—it’s quite possible they don’t know because they’re not DBAs or engineers using MySQL.<a data-primary="replication lag" data-secondary="causes" data-startref="replication-lag-causes" data-type="indexterm" id="idm45829103544224"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Risk: Data Loss" data-type="sect1"><div class="sect1" id="repl-risk">&#13;
<h1>Risk: Data Loss</h1>&#13;
&#13;
<p><em>Replication lag is data loss</em>.</p>&#13;
&#13;
<p>This <a data-primary="replication lag" data-secondary="data loss risk" data-type="indexterm" id="data-loss-risk"/>is true by default for MySQL because the default is asynchronous replication.&#13;
Fortunately, semisynchronous replication is an option that will not lose any committed transactions.&#13;
Let’s first examine the risk with asynchronous replication, then it will be clear how semisynchronous replication mitigates the risk.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As noted in <a data-type="xref" href="#repl-foundation">“Foundation”</a>, I defer Group Replication to the future.&#13;
Moreover, the synchronicity of Group Replication requires careful explanation.<sup><a data-type="noteref" href="ch07.html#idm45829103536576" id="idm45829103536576-marker">1</a></sup></p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Asynchronous Replication" data-type="sect2"><div class="sect2" id="repl-async">&#13;
<h2>Asynchronous Replication</h2>&#13;
&#13;
<p><a data-type="xref" href="#repl-crash">Figure 7-4</a> shows <a data-primary="asynchronous replication" data-type="indexterm" id="asynchronous-replication"/>the point in time at which the source crashed.</p>&#13;
&#13;
<figure><div class="figure" id="repl-crash">&#13;
<img alt="emsp 0704" src="assets/emsp_0704.png"/>&#13;
<h6><span class="label">Figure 7-4. </span>Crash on MySQL source with asynchronous replication</h6>&#13;
</div></figure>&#13;
&#13;
<p>Before crashing, the source committed five transactions to its binary logs.&#13;
But when it crashed, the replica I/O thread had only fetched the first three transactions.&#13;
Whether or not the last two transactions are lost depends on two factors: the cause of the crash, and whether a DBA must failover.</p>&#13;
&#13;
<p>If MySQL is the cause of the crash (most likely due to a bug), then it will automatically restart, perform crash recovery, and resume normal operations.&#13;
(By default, replicas automatically reconnect and resume replication, too.)&#13;
And since MySQL is truly durable when properly configured, the committed transactions 4 and 5 are not lost.&#13;
There’s just one problem: crash recovery can take several minutes <em>or hours</em> to complete—it depends on several factors outside the scope of this book.&#13;
If you can wait, crash recovery is the ideal solution because no committed transactions are lost.</p>&#13;
&#13;
<p>If hardware or operating system is the cause of the crash, or if the crashed MySQL instance cannot be recovered quickly enough for any reason, then a DBA will failover—promote a replica to the source—and transactions 4 and 5 are lost.&#13;
This is not an ideal solution, but it’s standard practice because the alternative is worse: a long outage (downtime) while recovering the crashed MySQL instance, which requires exacting data forensics that could take hours or days.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>No data is lost when DBAs failover for maintenance (operations).&#13;
And since nothing has failed, some DBAs call this <em>successover</em>.</p>&#13;
</div>&#13;
&#13;
<p>This example is not contrived to prove the point that <em>replication lag is data loss</em>; it’s inevitable with asynchronous replication because all hardware and software (including MySQL) fails eventually.</p>&#13;
&#13;
<p>The only mitigation is a strict adherence to minimizing replication lag.&#13;
Do not, for example, disregard 10 seconds of replication as “not too far behind.” Instead, treat it as “we’re at risk of losing the last 10 seconds of customer data.”&#13;
The odds are in your favor that MySQL or the hardware won’t fail at the worst possible moment—when the replica is lagging—but let me relate a cautionary tale about hardware failure.</p>&#13;
&#13;
<p>One week when I was on-call, I received an alert around 9 a.m.&#13;
That’s not too early; I was already done with my first cup of coffee.&#13;
One alert quickly turned into thousands.&#13;
Database servers everywhere—in multiple, geographically distributed data centers—were failing.&#13;
It was so bad that I immediately knew: the problem was not hardware or MySQL, because the odds of that many simultaneous but unrelated failures was infinitesimal.&#13;
Long story short, one of the most experienced engineers in the company had not had his coffee that morning.&#13;
He had written and run a custom script that went terribly awry.&#13;
The script didn’t simply reboot servers at random, it turned them off.&#13;
(In data centers, server power is programmatically controlled through a backplane called Intelligent Platform Management Interface.)&#13;
Killing power is akin to hardware failure.</p>&#13;
&#13;
<p>The moral of that story is: failure can be caused by human error.&#13;
Be prepared.</p>&#13;
&#13;
<p>Asynchronous replication is not a best practice because virtually unmitigated data loss is antithetical to the purpose of a persistent data store.&#13;
Countless companies around the world have been successful with asynchronous replication for more than 20 years.&#13;
(But “common practice” doesn’t necessarily mean “best practice.”)&#13;
If you run asynchronous replication, MySQL DBAs and experts will not scoff as long as the following three conditions are true:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You monitor replication lag with a heartbeat (see <a data-type="xref" href="#repl-monitoring">“Monitoring”</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>You are alerted any time (not just during business hours) when replication lag is too high.</p>&#13;
</li>&#13;
<li>&#13;
<p>You treat replication lag as data loss and fix it immediately.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Many successful companies use asynchronous MySQL replication, but there’s a higher standard to strive for: semisynchronous replication.<a data-primary="asynchronous replication" data-startref="asynchronous-replication" data-type="indexterm" id="idm45829103514400"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Semisynchronous Replication" data-type="sect2"><div class="sect2" id="repl-semi-sync">&#13;
<h2>Semisynchronous Replication</h2>&#13;
&#13;
<p>When semisynchronous <a data-primary="semisynchronous replication" data-type="indexterm" id="semisynchronous-replication"/>(or <em>semisync</em>) replication is enabled, the source waits for at least one replica to acknowledge each transaction.&#13;
<em>Acknowledge</em> means that the replica has written the binary log events for the transaction to its relay logs.&#13;
Therefore, the transaction is safely on disk on the replica, but the replica hasn’t applied it yet.&#13;
(Consequently, replication lag still occurs with semisync replication, as mentioned in <a data-type="xref" href="#repl-lag">“Replication Lag”</a>.)&#13;
Acknowledgment when received, not when applied, is why it’s called <em>semi</em>synchronous, not fully synchronous.</p>&#13;
&#13;
<p>Let’s replay the source crash from <a data-type="xref" href="#repl-async">“Asynchronous Replication”</a>, but now with semisynchronous replication enabled.&#13;
<a data-type="xref" href="#repl-crash-semi">Figure 7-5</a> shows the point in time at which the source crashed.</p>&#13;
&#13;
<figure><div class="figure" id="repl-crash-semi">&#13;
<img alt="emsp 0705" src="assets/emsp_0705.png"/>&#13;
<h6><span class="label">Figure 7-5. </span>Crash on MySQL source with semisynchronous replication</h6>&#13;
</div></figure>&#13;
&#13;
<p>With semisynchronous replication, every committed transaction is guaranteed to have replicated to at least one replica.&#13;
<em>Committed transaction</em> in this context means that the <code>COMMIT</code> statement executed by the client has returned—the transaction is complete from the client’s point of view.&#13;
That’s the usual, high-level understanding of a committed transaction, but down in the plumbing of replication, the technical details differ.&#13;
The following four steps are an extreme simplification of how a transaction commits when binary logging and semisynchronous replication are enabled:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Prepare transaction commit</p>&#13;
</li>&#13;
<li>&#13;
<p>Flush data changes to binary log</p>&#13;
</li>&#13;
<li>&#13;
<p>Wait for acknowledgment from at least one replica</p>&#13;
</li>&#13;
<li>&#13;
<p>Commit transaction</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>An InnoDB transaction commit is a two-phase commit.&#13;
In between the two phases (steps 1 and 4), data changes are written and flushed to the binary logs, and MySQL waits for at least one replica to acknowledge the transaction.<sup><a data-type="noteref" href="ch07.html#idm45829103496928" id="idm45829103496928-marker">2</a></sup></p>&#13;
&#13;
<p>In <a data-type="xref" href="#repl-crash-semi">Figure 7-5</a>, the dashed outline of the fourth transaction indicates that at least one replica has <em>not</em> acknowledged it.&#13;
The source crashed after step 2, so the transaction is in the binary logs, but the commit did not complete.&#13;
The client <code>COMMIT</code> statement will return an error (not from MySQL because it has crashed; it will probably receive a network error).</p>&#13;
&#13;
<p>Whether or not the fourth transaction is lost depends on the same two factors as before (<a data-type="xref" href="#repl-async">“Asynchronous Replication”</a>): the cause of the crash, and whether a DBA must failover.&#13;
The important difference is that only one uncommitted transaction per connection can be lost when semisynchronous replication is enabled.&#13;
Since the transaction did not complete and the client received an error, the potential loss of the uncommitted transaction is less worrisome.&#13;
The keyword is <em>less</em> worrisome: there are edge cases that mean you cannot simply disregard the lost transaction.&#13;
For example, what if a replica acknowledges the transaction but the source crashes before it receives the acknowledgment?&#13;
The answer would descend further into replication plumbing than we need to go.&#13;
The point is: semisynchronous replication guarantees that all committed transactions have replicated to at least one replica, and only one uncommitted transaction per connection can be lost on failure.</p>&#13;
&#13;
<p>The fundamental purpose of a persistent data store is to persist data, not lose it.&#13;
So why isn’t semisynchronous the default for MySQL?&#13;
It’s complicated.</p>&#13;
&#13;
<p>There are successful companies that operate MySQL at scale using semisynchronous replication.&#13;
One notable company is GitHub, the former employer of renowned MySQL expert Shlomi Noach <a data-primary="Noach, Shlomi" data-type="indexterm" id="idm45829103489072"/>who wrote a blog post about their use of semisynchronous replication: <a href="https://oreil.ly/6mLug">“MySQL High Availability at GitHub”</a>.</p>&#13;
&#13;
<p>Semisynchronous replication <em>reduces</em> availability—that’s not a typo.&#13;
Although it safeguards transactions, that safeguard means that the current transaction for every connection might stall, timeout, or fail on <code>COMMIT</code>.&#13;
By contrast, <code>COMMIT</code> with asynchronous replication is essentially instant and guaranteed as long as the storage on the source is working.</p>&#13;
&#13;
<p>By default, semisynchronous replication reverts to asynchronous when there are not enough replicas or the source times out waiting for an acknowledgment.&#13;
This can be effectively disabled by configuration, but the best practice is to allow it because the alternative is worse: a complete outage (the application cannot write to the source).</p>&#13;
&#13;
<p>Performance with semisynchronous replication requires that the source and replicas are on a fast, local network because network latency implicitly throttles transaction throughput on the source.&#13;
Whether or not this is an issue depends on the local network where you run MySQL.&#13;
A local network should have submillisecond latency, but that must be verified and monitored, else transaction throughput will suffer the whims of network latency.</p>&#13;
&#13;
<p>Whereas asynchronous replication works without any special configuration, semisynchronous requires specific configuration and tuning.&#13;
Neither is burdensome for a DBA, but they are careful work nevertheless.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>I think semisynchronous replication is the best practice because data loss is never acceptable—full stop.&#13;
I advise you to learn more about semisync replication, test and verify it on your network, and use it if possible.&#13;
Start by reading <a href="https://oreil.ly/JnxUJ">“Semisynchronous Replication”</a> in the MySQL manual.&#13;
Or, if you want to be truly prepared for the future, look into <a href="https://oreil.ly/5ZWHQ">Group Replication</a> and <a href="https://oreil.ly/JrrYd">InnoDB Cluster</a>: the future of MySQL replication and high availability.&#13;
Although semisynchronous replication and Group Replication elicit debate among MySQL experts, one point garners universal agreement: preventing data loss is a virtue.<a data-primary="replication lag" data-secondary="data loss risk" data-startref="data-loss-risk" data-type="indexterm" id="idm45829103479408"/><a data-primary="semisynchronous replication" data-startref="semisynchronous-replication" data-type="indexterm" id="idm45829103478160"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reducing Lag: Multithreaded Replication" data-type="sect1"><div class="sect1" id="repl-mtr">&#13;
<h1>Reducing Lag: Multithreaded Replication</h1>&#13;
&#13;
<p>By default, MySQL <a data-primary="replication lag" data-secondary="multithreaded replication" data-type="indexterm" id="multithreaded-replication_index1"/><a data-primary="multithreaded replication" data-type="indexterm" id="multithreaded-replication_index2"/>replication is asynchronous <em>and</em> single-threaded: one SQL thread on the replica.&#13;
Even semisynchronous replication is single-threaded by default.&#13;
The single SQL thread does not cause replication lag—<a data-type="xref" href="#repl-causes">“Causes”</a> are the three main causes—but it is the limiting factor.&#13;
The solution is <em>multithreaded replication</em> (or <em>parallel replication</em>): multiple SQL threads applying transactions in parallel.&#13;
On a multithreaded replica, the SQL threads are <a data-primary="applier threads" data-type="indexterm" id="idm45829103470304"/>called <em>applier threads</em>.<sup><a data-type="noteref" href="ch07.html#idm45829103468976" id="idm45829103468976-marker">3</a></sup>&#13;
You can still call them SQL threads if you want—the terms are synonymous—but the MySQL manual uses <em>applier</em> in the context of multithreaded replication.</p>&#13;
&#13;
<p>The solution is simple for us as engineers using MySQL, but it’s not simple for MySQL.&#13;
As you can imagine, transactions cannot be applied in random order: there might be dependencies among transactions.&#13;
For example, if one transaction inserts a new row, and second transaction updates that row, obviously the second transaction must run after the first.&#13;
<em>Transaction dependency tracking</em> <a data-primary="transaction dependency tracking" data-type="indexterm" id="idm45829103465616"/>is the art and science (and magic) of determining which transactions—from a serialized record (the binary logs)⁠—can be applied in parallel.&#13;
It’s both fascinating and impressive, but it’s beyond the scope of this book, so I encourage you to watch the video <a href="https://oreil.ly/Q8aJv">“MySQL Parallel Replication (LOGICAL_CLOCK): all the 5.7 (and some of the 8.0) details”</a> by renowned MySQL expert Jean-François Gagné<a data-primary="Jean-François Gangé" data-type="indexterm" id="idm45829103463600"/>.</p>&#13;
&#13;
<p>Strictly speaking, one system variable enables multithreaded replication, but I suspect that you are not going to be surprised when I tell you: it’s more complicated in practice.&#13;
Configuring MySQL replication is beyond the scope of this book, but multithreaded replication is too important not to give you a <em>conservative starting point</em>.&#13;
A conservative starting point means that the following configuration might not yield the full performance of multithreaded replication.&#13;
Consequently, you (or DBAs) must tune multithreaded replication—as in <a data-type="xref" href="ch02.html#mysql-tuning">“MySQL Tuning”</a>—to maximize its potential while at the same time taking into account the various ramifications of parallel replication.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The rest of this section is nontrivial MySQL configuration that should only be done by an engineer with experience configuring MySQL in high performance, high availability environments.&#13;
The system variables in <a data-type="xref" href="#mtr-sysvars">Table 7-1</a> will <em>not</em> affect data integrity or durability in any way, but they will affect performance on source and replica instances.&#13;
Be aware that:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Replication affects high availability.</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/xYtq3">Global transaction identifiers</a> and <a href="https://oreil.ly/wAOMO"><code>log-replica-updates</code></a> must be enabled.</p>&#13;
</li>&#13;
<li>&#13;
<p>Configuring MySQL requires elevated MySQL privileges.</p>&#13;
</li>&#13;
<li>&#13;
<p>System variables change between MySQL versions and <span class="keep-together">distributions</span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>MariaDB uses different system variables: see <a href="https://oreil.ly/F5n6J">“Parallel Replication”</a> in the MariaDB documentation.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Be very careful when configuring MySQL, and thoroughly read the relevant sections of the manual for your version and distribution of MySQL.</p>&#13;
</div>&#13;
&#13;
<p><a data-type="xref" href="#mtr-sysvars">Table 7-1</a> lists three system variables as a conservative starting point for enabling and configuring multithreaded replication.&#13;
Variable names changed as of MySQL 8.0.26, so the table lists old and new variable names, followed by a recommended value.&#13;
I do not recommend using multithreaded replication in MySQL older than 5.7.22 because certain replication features from 8.0 were backported into this version.</p>&#13;
<table class="pagebreak-before less_space" id="mtr-sysvars">&#13;
	<caption><span class="label">Table 7-1. </span>System variables to enable multithreaded replication</caption>&#13;
	<thead>&#13;
    <tr>&#13;
	  <th>MySQL 5.7.22 through 8.0.25</th>&#13;
      <th>MySQL 8.0.26 and newer</th>&#13;
      <th>Value</th>&#13;
    </tr>&#13;
	</thead>&#13;
	<tbody>&#13;
  <tr>&#13;
    <td><a href="https://oreil.ly/82SBV"><code>slave_parallel_workers</code></a></td>&#13;
    <td><a href="https://oreil.ly/kFqAz"><code>replica_parallel_workers</code></a></td>&#13;
    <td><code>4</code></td>&#13;
  </tr>&#13;
  <tr>&#13;
    <td><a href="https://oreil.ly/s5NOE"><code>slave_parallel_type</code></a></td>&#13;
    <td><a href="https://oreil.ly/mIft5"><code>replica_parallel_type</code></a></td>&#13;
    <td><code>LOGI⁠CAL_CLOCK</code></td>&#13;
  </tr>&#13;
  <tr>&#13;
    <td><a href="https://oreil.ly/oKRSy"><code>slave_preserve_com⁠mit_order</code></a></td>&#13;
    <td><a href="https://oreil.ly/QGBB1"><code>replica_preserve_commit_order</code></a></td>&#13;
    <td><code>1</code></td>&#13;
  </tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Set all three variables on all MySQL instances in the replication topology that are used for high availability (that can be promoted to source).</p>&#13;
&#13;
<p>Setting <code>replica_parallel_workers</code> greater than zero is the one system variable that enables multithreaded replication.&#13;
Four applier threads is a good start; you must tune to find the optimized number of applier threads for your workload and hardware.&#13;
But, like a magic spell, it must be invoked with <code>replica_parallel_type</code> to conjure the full performance of multithreaded replication.&#13;
Even as of MySQL 8.0.26, the default for <code>replica_parallel_type</code> is <code>DATABASE</code>, which only applies transactions&#13;
in parallel for different databases—effectively, only one applier thread per database.&#13;
This is historical: it was the first type of parallelization.&#13;
But today, the best practice is <code>rep⁠lica_parallel_type = LOGICAL_CLOCK</code> because it has no drawbacks when <code>rep⁠lica_preserve_commit_order</code> is enabled, and it provides better parallelization because it applies transactions in parallel regardless of database.</p>&#13;
&#13;
<p><code>replica_preserve_commit_order</code> is disabled by default, but I do not think that is a best practice because it allows a multithreaded replica to <em>commit out of order</em>: commit transactions in a different order than they were committed on the source.&#13;
For example, transactions 1, 2, 3 committed in that order on the source might commit in order 3, 1, 2 on the replica.&#13;
Multithreaded replication only commits out of order when safe (when there are no ordered dependencies among transactions), and table data is (eventually) the same, but committing out of order has consequences that you and especially the DBAs managing MySQL must understand and handle.&#13;
<a href="https://oreil.ly/Bf04z">“Replication and Transaction Inconsistencies”</a> in the MySQL manual documents the consequences.&#13;
When <code>replica_preserve_commit_order</code> is enabled, transactions are still applied in parallel, but some transactions might wait for earlier transactions to commit first—this is how commit order is preserved.&#13;
Although <code>replica_preserve_commit_order</code> reduces the effectiveness of parallelization, it’s the best practice until you and the DBAs verify that its consequences are acceptable and handled.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Multithreaded replication works the same for Group Replication.</p>&#13;
</div>&#13;
&#13;
<p>Since <a data-type="xref" href="#mtr-sysvars">Table 7-1</a> is a conservative starting point for enabling multithreaded replication, it does not enable the latest transaction dependency tracking: <code>WRITESET</code>.&#13;
MySQL transaction dependency tracking is determined by the system variable <a href="https://oreil.ly/5SMUG"><span class="keep-together"><code>binlog_transaction_dependency_tracking</code></span></a>.&#13;
The default is <code>COMMIT_ORDER</code>, but the latest is <code>WRITESET</code>.&#13;
Benchmarks show that <code>WRITESET</code> achieves greater parallelization than <code>COMMIT_ORDER</code>.&#13;
At the time of this writing, <code>WRITESET</code> is less than four years old: it was introduced in MySQL 8.0 which became GA on April 19, 2018.&#13;
As a matter of technology, you should use <code>WRITESET</code> because it achieves better performance on multithread replicas.&#13;
But as a matter of policy, it’s up to you (or your DBA) to decide when a feature has matured enough to be used in production.&#13;
To use <code>WRITESET</code> on MySQL 5.7, you must enable system variable <a href="https://oreil.ly/3lKGX"><code>trans​ac⁠tion_write_set_extraction</code></a>.&#13;
On MySQL 8.0 this system variable is enabled by default but deprecated as of MySQL 8.0.26.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Create a new replica to test and tune multithreaded replica.&#13;
A new replica poses little to no risk since it does not serve the application or high availability.</p>&#13;
</div>&#13;
&#13;
<p>There’s one more system variable that you should experiment with: <a href="https://oreil.ly/YMXoI"><code>bin⁠log_​group_commit_sync_delay</code></a>.&#13;
By default, this variable is disabled (zero) because, as its name suggests, it adds an artificial delay to group commit.&#13;
Delays are usually bad for performance, but group commit delay is a rare exception—sometimes.&#13;
On the source, transactions are committed to a binary log in groups, which is an internal optimization aptly named <em>group commit</em>.&#13;
Adding a delay to group commit creates larger groups: more transactions committed per group.&#13;
Multithreaded replication does not depend on group commit, but it can benefit from larger group commits because more transactions at once helps transaction dependency tracking find more opportunities for parallelization.&#13;
To experiment with <code>binlog_group_commit_sync_delay</code>, start with a value of <code>10000</code>: the unit is microseconds, so that’s 10 milliseconds.&#13;
This will increase transaction commit response time by 10 milliseconds on the source, but it should also increase transaction throughput on the replica.&#13;
Tuning group commit size with respect to multithreaded replica applier transaction throughput is not easy due to a lack of MySQL metrics.&#13;
If you go this route, read <a href="https://oreil.ly/QG4E1">“A Metric for Tuning Parallel Replication in MySQL 5.7”</a> by renowned MySQL expert Jean-François Gagné<a data-primary="Jean-François Gangé" data-type="indexterm" id="idm45829103410432"/>.</p>&#13;
&#13;
<p>Multithreaded replication is a best practice, but it requires nontrivial MySQL configuration and possibly tuning to achieve maximum performance.&#13;
Benchmarks and real-world results vary, but multithreaded replication can more than double transaction throughput on replicas.&#13;
For performance gains like that, it’s well worth the effort.&#13;
But most importantly: multithreaded replication significantly reduces replication lag, which is critical when using asynchronous replication.<a data-primary="multithreaded replication" data-startref="multithreaded-replication_index2" data-type="indexterm" id="idm45829103408800"/><a data-primary="replication lag" data-secondary="multithreaded replication" data-startref="multithreaded-replication_index2" data-type="indexterm" id="idm45829103407760"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Monitoring" data-type="sect1"><div class="sect1" id="repl-monitoring">&#13;
<h1>Monitoring</h1>&#13;
&#13;
<p>The <a data-primary="replication lag" data-secondary="monitoring" data-type="indexterm" id="replication-lag-monitoring"/><a data-primary="Seconds_Behind_Source" data-type="indexterm" id="Seconds_Behind_Source"/>best practice for monitoring replication lag is to use a purpose-built tool.&#13;
But first, let’s examine the infamous MySQL metric for replication lag: <code>Sec​onds_​Behind_Source</code>, as reported by <code>SHOW REPLICA STATUS</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Before MySQL 8.0.22, the replica lag metric and command were <code>Sec​onds_​Behind_Master</code> and <code>SHOW SLAVE STATUS</code>, respectively.&#13;
As of MySQL 8.0.22, the metric and command are <code>Sec​onds_​Behind_Source</code> and <code>SHOW REPLICA STATUS</code>.&#13;
I use the current metric and command in this book.</p>&#13;
</div>&#13;
&#13;
<p><code>Seconds_Behind_Source</code> equals the current time on the replica minus the timestamp of the binary log event that the SQL thread is executing.<sup><a data-type="noteref" href="ch07.html#idm45829103397152" id="idm45829103397152-marker">4</a></sup>&#13;
If the current time on the replica is <code>T = 100</code> and the SQL thread is executing a binary log event with timestamp <code>T = 80</code>, then <code>Seconds_Behind_Source = 20</code>.&#13;
When everything is working (replication lag notwithstanding), <code>Seconds_Behind_Source</code> is relatively accurate, but it’s notorious for three problems:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The first problem occurs when everything is not working.&#13;
Since <code>Seconds_​Behind_Source</code> relies solely on binary log event timestamps, it does not figuratively see (or care about) any issues before the binary log events arrive.&#13;
If the source or network has a problem that causes binary log events not to arrive, or to arrive slowly, then the SQL thread applies all binary log events and <code>Seconds_Behind_Source</code> reports zero lag because, from the SQL thread point of view, that is technically correct: zero events, zero lag.&#13;
But from our point of view, we know that’s wrong: not only is there replication lag, there’s an issue before the replica, too.</p>&#13;
</li>&#13;
<li>&#13;
<p>The second problem is that <code>Seconds_Behind_Source</code> is notorious for flapping between zero and a nonzero value.&#13;
For example, one moment <code>Seconds_Behind_Source</code> reports 500 seconds of lag, the next moment it reports zero lag, and a moment later it reports 500 seconds of lag again.&#13;
This problem is related to the first problem: when events trickle into the relay logs because of an issue before the replica, the SQL thread oscillates noticeably between working (applying the latest event) and waiting (for the next event). That causes <code>Seconds_Behind_Source</code> to flap between a value (SQL thread is working) and zero (SQL thread is waiting).</p>&#13;
</li>&#13;
<li>&#13;
<p>The third problem is that <code>Seconds_Behind_Source</code> does not precisely answer the question that engineers really want to know: <em>when will the replica catch up?</em>&#13;
When will replica lag be effectively zero because it’s applying the latest transactions from the source?&#13;
Presuming everything is working (replication lag notwithstanding), the value of <code>Seconds_Behind_Source</code> only indicates how long ago the current event being applied was executed on the source; it does <em>not</em> precisely indicate how long until the replica catches up to the source.&#13;
The reason is that replicas apply transactions at a different rate than the source.</p>&#13;
&#13;
<p>For example, suppose that 10 transactions execute concurrently on the source, and each transaction takes 1 second.&#13;
The total execution time is 1 second and the rate is 10 TPS because the transactions executed concurrently on the source.&#13;
On a single-threaded replica, which applies each transaction serially, the worst-case total execution time and rate <em>could be</em> 10 seconds and 1 TPS, respectively.&#13;
I emphasize <em>could be</em> because it’s also possible that the replica applies all 10 transactions significantly faster because the replica isn’t burdened with the full workload and it doesn’t execute SQL statements (it applies binary log events).&#13;
This could happen if the 1 second execution time per transaction on the source was due to a terrible <code>WHERE</code> clause that accessed a million rows but only matched and updated a single row.&#13;
The lucky replica updates that single row in almost no time.&#13;
On a multithreaded replica (see <a data-type="xref" href="#repl-mtr">“Reducing Lag: Multithreaded Replication”</a>), the total execution time and rate vary based on at least two factors: the number of applier threads and whether the transactions can be applied in parallel.&#13;
Either way, the point is: replicas apply transactions at a different rate than the source, and since there’s no way to know the difference, <code>Seconds_Behind_Source</code> cannot—and does not—precisely indicate when a replica will catch up.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Despite these problems, <code>Seconds_Behind_Source</code> provides value: it’s a ballpark estimate of how long until the replica catches up to the source: seconds, minutes, hours, days?&#13;
More on recovery time in the next section.</p>&#13;
&#13;
<p>MySQL 8.0 introduced significantly better visibility into MySQL replication, including replication lag.&#13;
There’s just one catch: it provides primitives, not ready-to-use metrics like <code>Seconds_Behind_Source</code>.&#13;
If you’re using MySQL 8.0, talk with your DBA about <a href="https://oreil.ly/xDKOd">Performance Schema replication tables</a> that expose a new wealth of information about MySQL replication.&#13;
Otherwise, the best practice for monitoring replication lag is to use a purpose-built tool.&#13;
Instead of relying on binary log event timestamps, tools use their own timestamps.&#13;
A tool writes timestamps at regular intervals to a table, then reports replication lag as the difference of the current time on a replica minus the latest timestamp in the table.&#13;
Fundamentally, the approach is similar to how MySQL calculates <code>Seconds_Behind_Source</code>, but there are three important differences when using a tool:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A tool writes timestamps at regular intervals, which means that it’s not susceptible to the first problem of <code>Seconds_Behind_Source</code>.&#13;
If there’s any issue before the binary log events arrive, replication lag from a tool will immediately begin to increase because its timestamp (written to a table) stops incrementing.</p>&#13;
</li>&#13;
<li>&#13;
<p>A tool precludes the second problem of <code>Seconds_Behind_Source</code>: replication lag from a tool does not flap; it can only be (effectively) zero if its timestamp is (effectively) equal to the current time.</p>&#13;
</li>&#13;
<li>&#13;
<p>A tool can measure replication lag and write timestamps at subsecond intervals (every 200 milliseconds, for example).&#13;
A single second of replication lag is too much for high performance applications—or any application when using asynchronous replication.</p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The de facto tool for monitoring MySQL replication is <a href="https://oreil.ly/sTvro"><code>pt-heartbeat</code></a>.&#13;
(Timestamps written by replication lag monitoring tools are called <em>heartbeats</em>.)&#13;
This venerable tool has seen more than a decade of use and success because it’s simple and effective.&#13;
Use it to start monitoring replication lag, or use it to learn how to write your own tool.<a data-primary="replication lag" data-secondary="monitoring" data-startref="replication-lag-monitoring" data-type="indexterm" id="idm45829103369584"/><a data-primary="Seconds_Behind_Source" data-startref="Seconds_Behind_Source" data-type="indexterm" id="idm45829103368272"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Recovery Time" data-type="sect1"><div class="sect1" id="repl-recovery">&#13;
<h1>Recovery Time</h1>&#13;
&#13;
<p>When a <a data-primary="replication lag" data-secondary="recovery time" data-type="indexterm" id="replication-lag-recovery-time"/>replica has a significant amount of lag, the most pressing question is often “When will it recover?”&#13;
When will the replica catch up to the source so that it’s executing (applying) the latest transactions?&#13;
There’s no precise answer.&#13;
But replication lag always recovers after the cause is fixed.&#13;
I return to this notion at the end of the section.&#13;
Until then, there’s one more characteristic of replication lag to understand.</p>&#13;
&#13;
<p>Another common and important characteristic of replication lag is the inflection point between increasing lag and when the replica begins to recover (decreasing lag).&#13;
In <a data-type="xref" href="#repl-lag-graph">Figure 7-6</a>, the inflection point is marked by the dotted line at time 75.</p>&#13;
&#13;
<p>When replication lag begins, the situation looks increasingly dire as lag increases.&#13;
But this is normal.&#13;
Presuming the replica isn’t broken, the SQL threads are working hard, but the cause has not been fixed yet, so the backlog of binary log events continues to increase.&#13;
As long as the cause persists, replication lag will increase.&#13;
But again: this is normal.&#13;
Very soon after the cause is fixed, the proverbial tide will turn, creating an inflection point in the graph of replication lag, as shown in <a data-type="xref" href="#repl-lag-graph">Figure 7-6</a> at time 75.&#13;
The replica is still lagged, but it’s applying binary log events faster than the I/O thread is dumping them into the relay logs.&#13;
Post–inflection point, replica lag usually decreases with noticeable and satisfying haste.</p>&#13;
&#13;
<figure><div class="figure" id="repl-lag-graph">&#13;
<img alt="emsp 0706" src="assets/emsp_0706.png"/>&#13;
<h6><span class="label">Figure 7-6. </span>Inflection point in graph of replication lag</h6>&#13;
</div></figure>&#13;
&#13;
<p>Recovery time is not very meaningful before the inflection point because, in theory, if the cause is never fixed, then the replica will never recover.&#13;
When replication lag is increasing steadily (pre–inflection point), don’t be distracted by the value; instead, focus on fixing the cause.&#13;
Lag will increase until the cause is fixed.</p>&#13;
&#13;
<p>Recovery time is more meaningful after the inflection point and it’s usually faster than <code>Seconds_Behind_Source</code> or the value reported by tools.&#13;
As explained in <a data-type="xref" href="#repl-monitoring">“Monitoring”</a>, despite replication lag, a single SQL thread is very fast because the replica doesn’t have to execute the full workload that besets the source.&#13;
As a result, replicas often apply transactions faster than the source, which is how replicas eventually catch up.</p>&#13;
&#13;
<p>In my experience, if replication lag is measured in days, it often recovers in hours (post–inflection point)—perhaps many hours, but hours nevertheless.&#13;
Likewise, several hours of lag often recovers in a few hours, and several minutes of lag often recovers before you can finish a cup of coffee.</p>&#13;
&#13;
<p>Returning to the notions that there’s no precise answer and lag always recovers, the end result is that a precise recovery time is not as useful or meaningful as it first seems.&#13;
Even if you could know the exact time that a replica will recover, you cannot do anything but wait.&#13;
MySQL replication is remarkably dogged.&#13;
As long as the replica doesn’t break, MySQL <em>will</em> recover—it always does.&#13;
Fix the cause as quickly as possible, wait for the inflection point, then replication lag indicates a worst case recovery time: MySQL usually recovers more quickly because SQL threads are fast.<a data-primary="replication lag" data-secondary="recovery time" data-startref="replication-lag-recovery-time" data-type="indexterm" id="idm45829103352976"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="ch07-summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter <a data-primary="replication lag" data-type="indexterm" id="replication-lag3"/>investigated MySQL replication lag.&#13;
Replication is the foundation of MySQL high availability, and replication lag is data loss.&#13;
The main takeaways are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>MySQL has three types of replication: asynchronous, semisynchronous, and Group Replication.</p>&#13;
</li>&#13;
<li>&#13;
<p>Asynchronous (async) replication is the default.</p>&#13;
</li>&#13;
<li>&#13;
<p>Asynchronous replication can lose numerous transactions on failure.</p>&#13;
</li>&#13;
<li>&#13;
<p>Semisynchronous (semisync) replication does not lose any committed transactions on failure, only one uncommitted transaction per client connection.</p>&#13;
</li>&#13;
<li>&#13;
<p>Group Replication is the future of MySQL replication and high availability (but not covered in this chapter or book): it turns MySQL instances into a cluster.</p>&#13;
</li>&#13;
<li>&#13;
<p>The foundation of MySQL async and semisync replication is sending transactions, encoded as binary log events, from a source to a replica.</p>&#13;
</li>&#13;
<li>&#13;
<p>Semisync replication makes a transaction commit on the source wait for at least one replica to acknowledge receiving and saving (not applying) the transaction.</p>&#13;
</li>&#13;
<li>&#13;
<p>A replica has an I/O thread that fetches binary log events from the source and stores them in local relay logs.</p>&#13;
</li>&#13;
<li>&#13;
<p>A replica has, by default, one SQL thread that executes binary log events from the local relay logs.</p>&#13;
</li>&#13;
<li>&#13;
<p>Multithreaded replication can be enabled to run multiple SQL threads (applier threads).</p>&#13;
</li>&#13;
<li>&#13;
<p>Replication lag has three main causes: (high) transaction throughput on the source, a MySQL instance catching up after failure and rebuild, or network issues.</p>&#13;
</li>&#13;
<li>&#13;
<p>SQL (applier) threads are the limiting factor in replication lag: more SQL threads reduce lag by applying transaction in parallel.</p>&#13;
</li>&#13;
<li>&#13;
<p>Semisync replication can incur replication lag.</p>&#13;
</li>&#13;
<li>&#13;
<p>Replication lag is data loss, especially with asynchronous replication.</p>&#13;
</li>&#13;
<li>&#13;
<p>Enabling multithreaded replication is the best way to reduce replication lag.</p>&#13;
</li>&#13;
<li>&#13;
<p>The MySQL metric for replication lag, <code>Seconds_Behind_Source</code>, can be misleading; avoid relying on it.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use a purpose-built tool to measure and report MySQL replication lag at subsecond intervals.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<ul class="pagebreak-before less_space">&#13;
<li>&#13;
<p>Recovery time from replication lag is imprecise and difficult to calculate.</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL will recover, eventually—it always does once the cause is fixed.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The next chapter examines MySQL transactions.<a data-primary="replication lag" data-startref="replication-lag3" data-type="indexterm" id="idm45829103327936"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Practice: Monitor Subsecond Lag" data-type="sect1"><div class="sect1" id="idm45829103326832">&#13;
<h1>Practice: Monitor Subsecond Lag</h1>&#13;
&#13;
<p>The goal of this practice is to monitor subsecond replication lag <a data-primary="replication lag" data-secondary="subsecond" data-type="indexterm" id="replication-lag-subsecond_index1"/><a data-primary="subsecond replication lag" data-type="indexterm" id="replication-lag-subsecond_index2"/>and determine: is your replica lagging beyond the 1-second resolution that <code>Seconds_Behind_Source</code> can report?&#13;
For example, is your replica lagging by 800 milliseconds (which is far greater than network latency)?&#13;
A tool is needed to monitor subsecond lag: <a href="https://oreil.ly/sTvro"><code>pt⁠-⁠heart⁠beat</code></a>.</p>&#13;
&#13;
<p>To complete this practice, you need:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A compute instance to run <code>pt-heartbeat</code> that can connect to the source and a replica</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL <code>SUPER</code> or <code>GRANT OPTION</code> privileges to create a user; or ask your DBA to create the user</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL <code>CREATE</code> privileges to create a database; or ask your DBA to create the database</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Every MySQL configuration and environment is different, so adapt the following example as needed.</p>&#13;
<ol>&#13;
<li>&#13;
<p>Create a database for <code>pt-heartbeat</code> to use:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">CREATE</code> <code class="k">DATABASE</code> <code class="n">IF</code> <code class="k">NOT</code> <code class="k">EXISTS</code> <code class="o">`</code><code class="n">percona</code><code class="o">`</code><code class="p">;</code></pre>&#13;
&#13;
<p>You can use a different database name; I just chose <code>percona</code> as an example.&#13;
If you change the database name, be sure to change it in the following commands.</p>&#13;
</li>&#13;
<li>&#13;
<p>Create a MySQL user for <code>pt-heartbeat</code> and grant it the privileges that it needs:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">CREATE</code> <code class="k">USER</code> <code class="s1">'pt-heartbeat'</code><code class="o">@</code><code class="s1">'%'</code> <code class="n">IDENTIFIED</code> <code class="k">BY</code> <code class="s1">'percona'</code><code class="p">;</code>&#13;
<code class="k">GRANT</code> <code class="k">CREATE</code><code class="p">,</code> <code class="k">INSERT</code><code class="p">,</code> <code class="k">UPDATE</code><code class="p">,</code> <code class="k">DELETE</code><code class="p">,</code> <code class="k">SELECT</code> <code class="k">ON</code> <code class="o">`</code><code class="n">percona</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">heartbeat</code><code class="o">`</code>&#13;
  <code class="k">TO</code> <code class="s1">'pt-heartbeat'</code><code class="o">@</code><code class="s1">'%'</code><code class="p">;</code>&#13;
<code class="k">GRANT</code> <code class="n">REPLICATION</code> <code class="n">CLIENT</code> <code class="k">ON</code> <code class="o">*</code><code class="p">.</code><code class="o">*</code> <code class="k">TO</code> <code class="s1">'pt-heartbeat'</code><code class="o">@</code><code class="s1">'%'</code><code class="p">;</code></pre>&#13;
&#13;
<p>You can use a different MySQL username and password; I just chose <code>pt-heartbeat</code> and <code>percona</code> (respectively) as an example.&#13;
You should definitely change the password if running this in production.&#13;
(The password is set by the <code>IDENTIFIED BY</code> clause.)</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
<ol class="pagebreak-before less_space" start="3">&#13;
<li>&#13;
<p>Run <code>pt-heartbeat</code> in update-mode to write heartbeats to a table in the <code>percona</code> database:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">pt-heartbeat         <code class="se">\</code>&#13;
  --create-table     <code class="se">\</code>&#13;
  --database percona <code class="se">\</code>&#13;
  --interval 0.2     <code class="se">\</code>&#13;
  --update           <code class="se">\</code>&#13;
  <code class="nv">h</code><code class="o">=</code>SOURCE_ADDR,u<code class="o">=</code>pt-heartbeat,p<code class="o">=</code>percona</pre>&#13;
&#13;
<p>A quick breakdown of those command-line arguments:</p>&#13;
<dl>&#13;
<dt><code>--create-table</code></dt>&#13;
<dd>&#13;
<p>Automatically create the <code>heartbeat</code> table in the specified database, if needed.&#13;
The first <code>GRANT</code> statement allows the <code>pt-heartbeat</code> user to <code>CREATE</code> the table.&#13;
If not using this option, read the <code>pt-heartbeat</code> documentation to learn how to create the <code>heartbeat</code> table manually.</p>&#13;
</dd>&#13;
<dt><code>--database</code></dt>&#13;
<dd>&#13;
<p>Specify the database to use.&#13;
<code>pt-heartbeat</code> requires this option.</p>&#13;
</dd>&#13;
<dt><code>--interval</code></dt>&#13;
<dd>&#13;
<p>Write heartbeats every 200 milliseconds.&#13;
This option determines the maximum resolution of <code>pt-heartbeat</code>, which is the smallest amount of lag that it can detect.&#13;
The default is 1.0 second, which is not subsecond.&#13;
The maximum resolution is 0.01 seconds (10 milliseconds).&#13;
Therefore, 0.2 seconds is a little conservative, so experiment with lower values (high resolution).</p>&#13;
</dd>&#13;
<dt><code>--update</code></dt>&#13;
<dd>&#13;
<p>Write heartbeats to <code>heartbeat</code> table in <code>--database</code> every <code>--interval</code> <span class="keep-together">seconds</span>.</p>&#13;
</dd>&#13;
<dt><code>h=SOURCE_ADDR,u=pt-heartbeat,p=percona</code></dt>&#13;
<dd>&#13;
<p>The data source name (DSN) to connect to MySQL.&#13;
The <code>h</code> specifies the hostname.&#13;
Change <code>SOURCE_ADDR</code> to the hostname of the source instance.&#13;
The <code>u</code> specifies the username.&#13;
The <code>p</code> specifies the password.</p>&#13;
&#13;
<p>Read the <a href="https://oreil.ly/sTvro"><code>pt-heartbeat</code> documentation</a> for further details on command-line options and the DSN.</p>&#13;
&#13;
<p>If the command is successful when run, it prints nothing and runs silently.&#13;
Else, it prints an error and exits.</p>&#13;
</dd>&#13;
</dl>&#13;
</li>&#13;
&#13;
</ol>&#13;
<ol class="pagebreak-before less_space" start="4">&#13;
<li>&#13;
<p>Run <code>pt-heartbeat</code> again but in monitor mode to print replication lag:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">pt-heartbeat         <code class="se">\</code>&#13;
  --database percona <code class="se">\</code>&#13;
  --interval 0.5     <code class="se">\</code>&#13;
  --monitor          <code class="se">\</code>&#13;
  <code class="nv">h</code><code class="o">=</code>REPLICA_ADDR,u<code class="o">=</code>pt-heartbeat,p<code class="o">=</code>percona</pre>&#13;
&#13;
<p>Change <code>REPLICA_ADDR</code> in the DSN to the hostname of a replica instance.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>In monitor mode, <code>--interval</code> is how often to check and print replication lag.&#13;
The update mode instance of <code>pt-heartbeat</code> is writing heartbeats every 0.2 seconds (200 milliseconds), but the monitor mode instance of <code>pt-heartbeat</code> checks and prints replication lag a little more slowly (every 0.5 seconds) for easy reading.</p>&#13;
&#13;
<p>If the command in step four is successful when run, it prints lines like:</p>&#13;
&#13;
<pre data-type="programlisting">0.00s [  0.00s,  0.00s,  0.00s ]&#13;
0.20s [  0.00s,  0.00s,  0.00s ]&#13;
0.70s [  0.01s,  0.00s,  0.00s ]&#13;
0.00s [  0.01s,  0.00s,  0.00s ]</pre>&#13;
&#13;
<p>The first field is the current replication lag.&#13;
The three fields between the brackets are moving averages for the last 1, 5, and 15 minutes of replication lag.</p>&#13;
&#13;
<p>In this example, the first line shows zero lag.&#13;
Then I intentionally lagged my replica for 1.1 seconds.&#13;
Consequently, the second line shows 200 milliseconds of replication lag, which is the maximum resolution because the update-mode instance of <code>pt-heartbeat</code> is running with <code>--interval 0.2</code>.&#13;
Half a second later (due to the monitor-mode instance of <code>pt-heartbeat</code> running with <code>--interval 0.5</code>), the tool reports 0.7 seconds (700 milliseconds) of replication lag on the third line.&#13;
But then my fake 1.1 seconds of lag ends, so the last (fourth) line correctly reports zero lag.</p>&#13;
&#13;
<p>This example is contrived, but it demonstrates how <code>pt-heartbeat</code> can monitor and report subsecond replication lag.&#13;
Try it on your network—the tool is safe to use.<a data-primary="replication lag" data-secondary="subsecond" data-startref="replication-lag-subsecond_index1" data-type="indexterm" id="idm45829101543888"/><a data-primary="subsecond replication lag" data-startref="replication-lag-subsecond_index2" data-type="indexterm" id="idm45829099634240"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45829103536576"><sup><a href="ch07.html#idm45829103536576-marker">1</a></sup> <a href="https://oreil.ly/Gv6GR">“MySQL Group Replication…Synchronous or Asynchronous Replication?”</a> by renowned MySQL expert Frédéric Descamps <a data-primary="Descamps, Frédéric" data-type="indexterm" id="idm45829103535328"/>explains the synchronicity of Group Replication.</p><p data-type="footnote" id="idm45829103496928"><sup><a href="ch07.html#idm45829103496928-marker">2</a></sup> I presume <a href="https://oreil.ly/lbfwm"><code>sync_binlog</code> = 1</a>.</p><p data-type="footnote" id="idm45829103468976"><sup><a href="ch07.html#idm45829103468976-marker">3</a></sup> In the MySQL manual, the full term is <em>applier worker thread</em>, but I think <em>worker</em> is redundant since every thread is a worker of some type.</p><p data-type="footnote" id="idm45829103397152"><sup><a href="ch07.html#idm45829103397152-marker">4</a></sup> Technically, it’s the event timestamp plus its execution time. Also, the clock skew between source and replica is subtracted from <code>Seconds_Behind_Source</code> when it’s reported by <code>SHOW REPLICA STATUS</code>.</p></div></div></section></body></html>