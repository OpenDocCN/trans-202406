<html><head></head><body><section data-pdf-bookmark="Chapter 2. Indexes and Indexing" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch02">&#13;
<h1><span class="label">Chapter 2. </span>Indexes and Indexing</h1>&#13;
&#13;
&#13;
<p>Many <a data-primary="indexes" data-type="indexterm" id="indexes"/>factors determine MySQL performance, but indexes are special because performance cannot be achieved without them.&#13;
You can remove other factors—queries, schemas, data, and so on—and still achieve performance, but removing indexes limits performance to brute force: relying on the speed and capacity of hardware.&#13;
If this book were titled <em>Brute Force MySQL Performance</em>, the contents would be as long as the title: “Buy better, faster hardware.”&#13;
You laugh, but just a few days ago I met with a team of developers who had been improving performance in the cloud by purchasing faster hardware until stratospheric costs compelled them to ask, “How else can we improve performance?”</p>&#13;
&#13;
<p>MySQL leverages <a data-primary="leverage (indexes)" data-type="indexterm" id="leverage-indexes-ch2"/>hardware, optimizations, and indexes to achieve performance when accessing data.&#13;
Hardware is an obvious leverage because MySQL runs on hardware: the faster the hardware, the better the performance.&#13;
Less obvious and perhaps more surprising is that hardware provides the <em>least</em> leverage.&#13;
I explain why in a moment.&#13;
<em>Optimizations</em> refer to the numerous techniques, algorithms, and data structures that enable MySQL to utilize hardware efficiently.&#13;
Optimizations bring the power of hardware into focus.&#13;
And focus is the difference between a light bulb and a laser.&#13;
Consequently, optimizations provide more leverage than hardware.&#13;
If databases were small, hardware and optimizations would be sufficient.&#13;
But increasing data size <span class="keep-together"><em>deleverages</em></span> the benefits of hardware and optimizations.&#13;
Without indexes, performance is severely limited.</p>&#13;
&#13;
<p>To illustrate these points, think of MySQL as a fulcrum <a data-primary="fulcrum, MySQL as a" data-type="indexterm" id="fulcrum-MySQL-as-a-ch2"/>that leverages hardware, optimizations, and indexes to figuratively lift data, as shown in <a data-type="xref" href="#no-indexes">Figure 2-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="no-indexes">&#13;
<img alt="emsp 0201" src="assets/emsp_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>MySQL performance without indexes</h6>&#13;
</div></figure>&#13;
&#13;
<p>Without indexes (on the right side), MySQL achieves limited performance with relatively small data.&#13;
But add indexes to the balance, as shown in <a data-type="xref" href="#good-indexes">Figure 2-2</a>, and MySQL achieves high performance with large data.</p>&#13;
&#13;
<figure><div class="figure" id="good-indexes">&#13;
<img alt="emsp 0202" src="assets/emsp_0202.png"/>&#13;
<h6><span class="label">Figure 2-2. </span>MySQL performance with indexes</h6>&#13;
</div></figure>&#13;
&#13;
<p>Indexes provide the most <em>and the best</em> leverage.&#13;
They are required for any nontrivial amount of data.&#13;
MySQL performance requires proper indexes and indexing, both of which this chapter teaches in detail.</p>&#13;
&#13;
<p>Several years ago, I designed and implemented an application that stores a lot of data. Originally, I estimated the largest table not to exceed a million rows. But there was a bug in the data archiving code that allowed the table to reach one <em>billion</em> rows. For years, nobody noticed because response time was always great. Why? Good indexes.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>It’s commonly said that MySQL uses only one index per table, but that’s not entirely true.&#13;
The index merge optimization, for example, can use two indexes.&#13;
In this book, however, I focus on the normal case: one query, one table, one index.</p>&#13;
</div>&#13;
&#13;
<p>This chapter teaches MySQL indexes and indexing.&#13;
There are five major sections.&#13;
The first argues why you should not be distracted by hardware or MySQL tuning.&#13;
It’s a necessary digression in order to fully understand why hardware and MySQL tuning are not efficient solutions for improving MySQL performance.&#13;
The second is a visual introduction to MySQL indexes: what they are and how they work.&#13;
The third teaches indexing—applying indexes for maximum leverage—by thinking like MySQL.&#13;
The fourth covers common reasons why indexes lose effectiveness (leverage).&#13;
The fifth is a brief overview of MySQL table join algorithms because effective joins rely on effective indexes.<a data-primary="indexes" data-startref="indexes" data-type="indexterm" id="idm45829114841456"/><a data-primary="leverage (indexes)" data-startref="leverage-indexes-ch2" data-type="indexterm" id="idm45829114840480"/><a data-primary="fulcrum, MySQL as a" data-startref="fulcrum-MySQL-as-a-ch2" data-type="indexterm" id="idm45829114839536"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Red Herrings of Performance" data-type="sect1"><div class="sect1" id="red-herrings">&#13;
<h1>Red Herrings of Performance</h1>&#13;
&#13;
<p><em>Red herring</em> <a data-primary="indexes" data-secondary="red herrings of performance" data-type="indexterm" id="red-herrings-of-performance"/>is an idiom that refers to a distraction from a goal. When tracking down solutions to improve MySQL performance, two red herrings commonly distract engineers: faster hardware and MySQL tuning.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Better, Faster Hardware!" data-type="sect2"><div class="sect2" id="better-faster-hardware">&#13;
<h2>Better, Faster Hardware!</h2>&#13;
&#13;
<p>When MySQL performance <a data-primary="hardware upgrade" data-type="indexterm" id="hardware-upgrade-ch2"/>isn’t acceptable, do <em>not</em> begin by scaling up (using better, faster hardware) to “see if that helps.” It probably will help if you scale up significantly, but you learn nothing because it only proves what you already know: computers run faster on faster hardware. Better, faster hardware is a red herring of performance because you miss learning the real causes of, and solutions to, slow performance.</p>&#13;
&#13;
<p>There are two reasonable exceptions. First, if the hardware is blatantly insufficient, then scale up to reasonable hardware. For example, using 1 GB of memory with 500 GB of data is blatantly insufficient. Upgrading to 32 GB or 64 GB of memory is reasonable. By contrast, upgrading to 384 GB of memory is sure to help but is unreasonable. Second, if the application is experiencing <em>hyper-growth</em> (a massive increase in users, usage, and data) and scaling up is a stopgap solution to keep the application running, then do it. Keeping the application running is always reasonable.</p>&#13;
&#13;
<p>Otherwise, scaling up to improve MySQL performance happens <em>last</em>. Experts agree: <em>first</em> optimize queries, data, access patterns, and the application. If all those optimizations do not yield sufficient performance, then scale up. Scaling up happens last for the following reasons.</p>&#13;
&#13;
<p class="pagebreak-before">You don’t learn anything by scaling up, you simply clobber the problem with faster hardware. Since you’re an engineer, not a cave-dwelling protohuman, you <em>solve</em> problems by learning and understanding—you don’t clobber them. Admittedly, learning and understanding is more difficult and time-consuming, but it’s far more effective and sustainable, which leads to the next reason.</p>&#13;
&#13;
<p>Scaling up is not a sustainable approach. Upgrading physical hardware is nontrivial. Some upgrades are relatively quick and easy, but it depends on many factors outside the scope of this book. Sufficient to say, however, that you will drive yourself or the hardware engineers crazy if you frequently change hardware. Crazy engineers are not sustainable. Moreover, companies often use the same hardware for several years because the purchasing process is long and complicated. As a result, easy hardware scalability is one allure of the cloud. In the cloud, you can scale up (or down) CPU cores, memory, and storage in a few minutes. But this ease is <em>significantly</em> more expensive than physical hardware. Cloud costs can increase exponentially. The cost of Amazon RDS, for example, doubles from one instance size to the next—double the hardware, double the price. Exponentially increasing costs are not sustainable.</p>&#13;
&#13;
<p>Generally speaking, MySQL can fully utilize all the hardware that it’s given. (There are limits, which I address in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>.) The real question is: can the application fully utilize MySQL? The presumptive answer is yes, but it’s not guaranteed. Faster hardware helps MySQL but it does not change how the application uses MySQL. For example, increasing memory might not improve performance if the application causes table scans. Scaling up is only effective at increasing performance when the application workload can scale up, too. Not all workloads can scale up.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><em>Workload</em> is <a data-primary="workload" data-type="indexterm" id="idm45829114821312"/>the combination of queries, data, and access patterns.</p>&#13;
</div>&#13;
&#13;
<p>But let’s imagine that you successfully scale up the workload to fully utilize MySQL on the fastest hardware available.&#13;
What happens as the application continues to grow, and its workload continues to increase?&#13;
This reminds me of a Zen proverb: “When you reach the top of the mountain, keep climbing.”&#13;
While I do encourage you to meditate on that, it presents a less enlightening dilemma for your application.&#13;
With nowhere else to go, the only option is doing what should have been done first: optimize queries, data, access patterns, and the <a data-primary="hardware upgrade" data-startref="hardware-upgrade-ch2" data-type="indexterm" id="idm45829114819376"/>application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="MySQL Tuning" data-type="sect2"><div class="sect2" id="mysql-tuning">&#13;
<h2>MySQL Tuning</h2>&#13;
&#13;
<p>In the television series <em>Star Trek</em>, engineers are able to modify the ship to increase power to engines, weapons, shields, sensors, transporters, tractor beams—everything. MySQL is more difficult to operate than a starship because no such modifications are possible. But that does not stop engineers from trying.</p>&#13;
&#13;
<p>First, let’s clarify three terms.</p>&#13;
<dl>&#13;
<dt>Tuning</dt>&#13;
<dd>&#13;
<p>Tuning <a data-primary="tuning MySQL" data-type="indexterm" id="idm45829114813120"/>is adjusting MySQL system variables for research and development (R&amp;D). It’s laboratory work with specific goals and criteria. Benchmarking is common: adjusting system variables to measure the effect on performance. The blog post <a href="https://oreil.ly/CGvrU">“MySQL Challenge: 100k Connections”</a> by renowned MySQL expert Vadim Tkachenko <a data-primary="Tkachenko, Vadim" data-type="indexterm" id="idm45829114811344"/>is an example of extreme tuning. Since tuning is R&amp;D, the results are not expected to be generally applicable; rather, the goal is to expand our collective knowledge and understanding of MySQL, especially with respect to its current limits. Tuning influences future MySQL development and best practices.</p>&#13;
</dd>&#13;
<dt>Configuring</dt>&#13;
<dd>&#13;
<p>Configuring <a data-primary="configuring MySQL" data-type="indexterm" id="idm45829114808944"/>is setting system variables to values that are appropriate for the hardware and environment. The goal is a reasonable configuration with respect to a few default values that need to be changed. Configuring MySQL is usually done when the MySQL instance is provisioned or when hardware changes. It’s also necessary to reconfigure when data size increases by an order of magnitude, for example from 10 GB to 100 GB. Configuring influences how MySQL runs in general.</p>&#13;
</dd>&#13;
<dt>Optimizing</dt>&#13;
<dd>&#13;
<p>Optimizing <a data-primary="query" data-secondary="optimization" data-type="indexterm" id="idm45829114806320"/>is improving MySQL performance by reducing the workload or making it more efficient—usually the latter since application usage tends to increase. The goal is faster response time and more capacity with the existing hardware. Optimizing influences MySQL and application performance.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>You will undoubtedly encounter these terms in MySQL literature, videos, conferences, and so forth. The descriptions are more important than the terms. If, for example, you read a blog post that uses <em>optimizing</em> but describes what is defined here as <em>tuning</em>, then it’s tuning as defined here.</p>&#13;
&#13;
<p>The distinction of these terms is important because engineers do all three, but only optimizing (as defined here) is an efficient use of your time.<sup><a data-type="noteref" href="ch02.html#idm45829114802704" id="idm45829114802704-marker">1</a></sup></p>&#13;
&#13;
<p>MySQL tuning is a red herring of performance for two reasons. First, it’s often not done as a controlled laboratory experiment, which makes the results dubious. In totality, MySQL performance is complex; experiments must be carefully controlled. Second, results are unlikely to have a significant effect on performance because MySQL is already highly optimized. Tuning MySQL is akin to squeezing blood from a turnip.</p>&#13;
&#13;
<p>Going back to the first paragraph of this section, I realize that we all admire Lieutenant Commander Geordi La Forge, the Chief Engineer in <em>Star Trek: The Next Generation</em>. When the captain calls for more power, we feel obligated to make it so by applying arcane server parameters. Or, on Earth, when the application needs more power, we want to save the day by applying an ingenious reconfiguration of MySQL that boosts throughput and concurrency by 50%. Good work, La Forge! Unfortunately, MySQL 8.0 introduced automatic configuration by enabling <a href="https://oreil.ly/niPGL"><code>innodb_dedicated_server</code></a>. Since MySQL 5.7 will be end-of-life (EOL) soon after this book is published, let’s keep looking to and building the future. Good work nevertheless, La Forge.</p>&#13;
&#13;
<p>Optimizing is all you need to do because tuning is a red herring and configuration is automatic as of MySQL 8.0. This book is all about optimizing.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="MySQL Indexes: A Visual Introduction" data-type="sect1"><div class="sect1" id="intro-to-indexes">&#13;
<h1>MySQL Indexes: A Visual Introduction</h1>&#13;
&#13;
<p>Indexes are the key to performance and, if you recall <a data-type="xref" href="ch01.html#direct-query-optimization">“Direct Query Optimization”</a>, changes to queries and indexes solve <em>a lot</em> of performance problems.&#13;
The journey of query optimization requires a solid understanding of MySQL indexes, and that’s what this section presents—in detail with copious illustrations.</p>&#13;
&#13;
<p>Although this section is detailed and relatively long, I call it an <em>introduction</em> because there is more to learn.&#13;
But this section is the key that unlocks the treasure chest of MySQL query optimizations.</p>&#13;
&#13;
<p>The following nine sections apply only to standard indexes on InnoDB tables—the type of index created by a simple <code>PRIMARY KEY</code> or <code>[UNIQUE] INDEX</code> table definition.&#13;
MySQL supports other specialized index types, but I don’t cover them in this book because standard indexes are the basis of performance.</p>&#13;
&#13;
<p>Before we dive into the details of MySQL indexes, I begin with a revelation about InnoDB tables that will change the way you see not only indexes but most of MySQL performance.<a data-primary="indexes" data-secondary="red herrings of performance" data-startref="red-herrings-of-performance" data-type="indexterm" id="idm45829114791648"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="InnoDB Tables Are Indexes" data-type="sect2"><div class="sect2" id="tables-are-indexes">&#13;
<h2>InnoDB Tables Are Indexes</h2>&#13;
&#13;
<p><a data-type="xref" href="#elem">Example 2-1</a> is the structure of <a data-primary="InnoDB" data-secondary="tables" data-type="indexterm" id="InnoDB-tables"/>table <code>elem</code> (short for <em>elements</em>) and the 10 rows that it contains.&#13;
All examples in this chapter refer to table <code>elem</code>—with <a data-primary="table elem" data-type="indexterm" id="table-elem-ch2"/>one clearly noted exception—so take a moment to study it.</p>&#13;
<div data-type="example" id="elem">&#13;
<h5><span class="label">Example 2-1. </span>Table <code>elem</code></h5>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="o">`</code><code class="n">elem</code><code class="o">`</code> <code class="p">(</code>&#13;
  <code class="o">`</code><code class="n">id</code><code class="o">`</code> <code class="nb">int</code> <code class="n">unsigned</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>&#13;
  <code class="o">`</code><code class="n">a</code><code class="o">`</code> <code class="nb">char</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>&#13;
  <code class="o">`</code><code class="n">b</code><code class="o">`</code> <code class="nb">char</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>&#13;
  <code class="o">`</code><code class="k">c</code><code class="o">`</code> <code class="nb">char</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>&#13;
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="o">`</code><code class="n">id</code><code class="o">`</code><code class="p">),</code>&#13;
  <code class="k">KEY</code> <code class="o">`</code><code class="n">idx_a_b</code><code class="o">`</code> <code class="p">(</code><code class="o">`</code><code class="n">a</code><code class="o">`</code><code class="p">,</code><code class="o">`</code><code class="n">b</code><code class="o">`</code><code class="p">)</code>&#13;
<code class="p">)</code> <code class="n">ENGINE</code><code class="o">=</code><code class="n">InnoDB</code><code class="p">;</code>&#13;
&#13;
<code class="o">+</code><code class="c1">----+------+------+------+</code>&#13;
<code class="o">|</code> <code class="n">id</code> <code class="o">|</code> <code class="n">a</code>    <code class="o">|</code> <code class="n">b</code>    <code class="o">|</code> <code class="k">c</code>    <code class="o">|</code>&#13;
<code class="o">+</code><code class="c1">----+------+------+------+</code>&#13;
<code class="o">|</code>  <code class="mi">1</code> <code class="o">|</code> <code class="n">Ag</code>   <code class="o">|</code> <code class="n">B</code>    <code class="o">|</code> <code class="k">C</code>    <code class="o">|</code>&#13;
<code class="o">|</code>  <code class="mi">2</code> <code class="o">|</code> <code class="n">Au</code>   <code class="o">|</code> <code class="n">Be</code>   <code class="o">|</code> <code class="n">Co</code>   <code class="o">|</code>&#13;
<code class="o">|</code>  <code class="mi">3</code> <code class="o">|</code> <code class="n">Al</code>   <code class="o">|</code> <code class="n">Br</code>   <code class="o">|</code> <code class="n">Cr</code>   <code class="o">|</code>&#13;
<code class="o">|</code>  <code class="mi">4</code> <code class="o">|</code> <code class="n">Ar</code>   <code class="o">|</code> <code class="n">Br</code>   <code class="o">|</code> <code class="n">Cd</code>   <code class="o">|</code>&#13;
<code class="o">|</code>  <code class="mi">5</code> <code class="o">|</code> <code class="n">Ar</code>   <code class="o">|</code> <code class="n">Br</code>   <code class="o">|</code> <code class="k">C</code>    <code class="o">|</code>&#13;
<code class="o">|</code>  <code class="mi">6</code> <code class="o">|</code> <code class="n">Ag</code>   <code class="o">|</code> <code class="n">B</code>    <code class="o">|</code> <code class="n">Co</code>   <code class="o">|</code>&#13;
<code class="o">|</code>  <code class="mi">7</code> <code class="o">|</code> <code class="k">At</code>   <code class="o">|</code> <code class="n">Bi</code>   <code class="o">|</code> <code class="n">Ce</code>   <code class="o">|</code>&#13;
<code class="o">|</code>  <code class="mi">8</code> <code class="o">|</code> <code class="n">Al</code>   <code class="o">|</code> <code class="n">B</code>    <code class="o">|</code> <code class="k">C</code>    <code class="o">|</code>&#13;
<code class="o">|</code>  <code class="mi">9</code> <code class="o">|</code> <code class="n">Al</code>   <code class="o">|</code> <code class="n">B</code>    <code class="o">|</code> <code class="n">Cd</code>   <code class="o">|</code>&#13;
<code class="o">|</code> <code class="mi">10</code> <code class="o">|</code> <code class="n">Ar</code>   <code class="o">|</code> <code class="n">B</code>    <code class="o">|</code> <code class="n">Cd</code>   <code class="o">|</code>&#13;
<code class="o">+</code><code class="c1">----+------+------+------+</code></pre></div>&#13;
&#13;
<p>Table <code>elem</code> has two indexes: the primary key on column <code>id</code> and a nonunique secondary index on columns <code>a, b</code>.&#13;
The value for column <code>id</code> is a monotonically increasing integer.&#13;
The values for columns <code>a</code>, <code>b</code>, and <code>c</code> are atomic symbols corresponding to the column name letter: “Ag” (silver) for column <code>a</code>, “B” (boron) for column <code>b</code>, and so on.&#13;
The row values are random and meaningless; it’s just a simple table used for examples.</p>&#13;
&#13;
<p><a data-type="xref" href="#idx-table">Figure 2-3</a> shows a typical view of table <code>elem</code>—just the first four rows for brevity.</p>&#13;
&#13;
<figure><div class="figure" id="idx-table">&#13;
<img alt="emsp 0203" src="assets/emsp_0203.png"/>&#13;
<h6><span class="label">Figure 2-3. </span>Table <code>elem</code>: visual model</h6>&#13;
</div></figure>&#13;
&#13;
<p>Nothing special about table <code>elem</code>, right?&#13;
It’s so simple, one might say it’s elementary.&#13;
But what if I told you that it’s not really a table, it’s an index?&#13;
Get the “F” (fluorine) out of here!&#13;
<a data-type="xref" href="#idx-table-pk">Figure 2-4</a> shows the true structure of table <code>elem</code> as an InnoDB table.</p>&#13;
&#13;
<figure><div class="figure" id="idx-table-pk">&#13;
<img alt="emsp 0204" src="assets/emsp_0204.png"/>&#13;
<h6><span class="label">Figure 2-4. </span>Table <code>elem</code>: InnoDB B-tree index</h6>&#13;
</div></figure>&#13;
&#13;
<p>InnoDB tables are B-tree indexes <a data-primary="B-tree index (InnoDB table)" data-primary-sortas="Btree index (InnoDB table)" data-type="indexterm" id="B-tree-index-InnoDB-table-ch2"/>organized by the primary key.&#13;
Rows are index records stored in leaf nodes of the index structure.&#13;
Each index record has metadata (denoted by “…”) used for row locking, transaction isolation, and so on.</p>&#13;
&#13;
<p><a data-type="xref" href="#idx-table-pk">Figure 2-4</a> is a highly simplified depiction of the B-tree index that is table<a data-primary="table elem" data-startref="table-elem-ch2" data-type="indexterm" id="idm45829114504752"/> <code>elem</code>.&#13;
Four index records (at bottom) correspond to the first four rows.&#13;
Primary key column values (<code>1</code>, <code>2</code>, <code>3</code>, and <code>4</code>) are shown at the top of each index record.&#13;
Other column values (“Ag,” “B,” “C,” and so forth) are shown below the metadata for each index record.</p>&#13;
&#13;
<p>You don’t need to know the technical details of InnoDB B-tree indexes to understand or achieve remarkable MySQL performance.&#13;
Only two points are important:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Primary key lookups are extremely fast and efficient</p>&#13;
</li>&#13;
<li>&#13;
<p>The primary key is pivotal to MySQL performance</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The first point is true because B-tree indexes are inherently fast and efficient, which is one reason why many database servers use them.&#13;
The second point becomes increasingly clear in the coming sections—and chapters.</p>&#13;
&#13;
<p>To learn about the fascinating world of database internals, including indexes, read <a href="https://oreil.ly/TDsCc"><em>Database Internals</em></a> by Alex Petrov (O’Reilly, 2019).&#13;
For a deep dive into InnoDB internals, including its B-tree implementation, cancel all your meetings and check out the website of renowned MySQL expert <a href="https://oreil.ly/9sH9m">Jeremy Cole</a><a data-primary="Jeremy Cole" data-type="indexterm" id="idm45829114495856"/>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>An InnoDB primary key is a clustered index.&#13;
The MySQL manual occasionally refers to the primary key as <em>the clustered index</em>.</p>&#13;
</div>&#13;
&#13;
<p>Indexes provide the most and the best leverage because the table <em>is</em> an index.&#13;
The primary key is pivotal to performance.&#13;
This is especially true because secondary indexes include primary key values.&#13;
<a data-type="xref" href="#idx-secondary">Figure 2-5</a> shows the secondary index on columns <code>a, b</code>.</p>&#13;
&#13;
<figure><div class="figure" id="idx-secondary">&#13;
<img alt="emsp 0205" src="assets/emsp_0205.png"/>&#13;
<h6><span class="label">Figure 2-5. </span>Secondary index on columns a, b</h6>&#13;
</div></figure>&#13;
&#13;
<p>Secondary indexes are B-tree indexes, too, but leaf nodes store primary key values.&#13;
When MySQL uses a secondary index to find a row, it does a second lookup on the primary key to read the full row.&#13;
Let’s put the two together and walk through a secondary index lookup for query <code>SELECT * FROM elem WHERE a='Au' AND b='Be'</code>:</p>&#13;
&#13;
<figure><div class="figure" id="idx-2nd-lookup-1">&#13;
<img alt="emsp 0206" src="assets/emsp_0206.png"/>&#13;
<h6><span class="label">Figure 2-6. </span>Secondary index lookup for value “Au, Be”</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before less_space"><a data-type="xref" href="#idx-2nd-lookup-1">Figure 2-6</a> shows the secondary index (columns <code>a, b</code>) on top and the primary key (column <code>id</code>) on bottom. Six callouts (numbered circles) show the lookup for value “Au, Be” using the secondary index:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Index lookups begin at the root node; branch right to an internal node for value “Au, Be.”</p>&#13;
</li>&#13;
<li>&#13;
<p>At an internal node, branch right to the leaf node for value “Au, Be.”</p>&#13;
</li>&#13;
<li>&#13;
<p>Leaf node for secondary index value “Au, Be” contains the corresponding primary key value: 2.</p>&#13;
</li>&#13;
<li>&#13;
<p>Begin primary key lookup at the root node; branch left to an internal node for value 2.</p>&#13;
</li>&#13;
<li>&#13;
<p>At an internal node, branch right to the leaf node for value 2.</p>&#13;
</li>&#13;
<li>&#13;
<p>Leaf node for primary key value 2 contains the full row matching “Au, Be.”</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A table has only one primary key. All other indexes are secondary indexes.</p>&#13;
</div>&#13;
&#13;
<p>This section is short but incredibly important because the correct model provides the foundation for understanding indexes <em>and more</em>.&#13;
For example, if you think back to <a data-type="xref" href="ch01.html#Lock-time">“Lock time”</a>, you might see it in a new light since rows are actually leaf nodes in the primary key.&#13;
Knowing that an InnoDB table is its primary key is akin to knowing that heliocentrism, not geocentrism, is the correct model of the solar system.&#13;
In the world of MySQL, everything revolves around the primary key.<a data-primary="InnoDB" data-secondary="tables" data-startref="InnoDB-tables" data-type="indexterm" id="idm45829114474272"/><a data-primary="B-tree index (InnoDB table)" data-primary-sortas="Btree index (InnoDB table)" data-startref="B-tree-index-InnoDB-table-ch2" data-type="indexterm" id="idm45829114473056"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Table Access Methods" data-type="sect2"><div class="sect2" id="table-access-methods">&#13;
<h2>Table Access Methods</h2>&#13;
&#13;
<p>Using <a data-primary="indexes" data-secondary="table access methods" data-type="indexterm" id="table-access-methods_index1"/><a data-primary="table access methods" data-type="indexterm" id="table-access-methods_index2"/>an index to look up rows is one of three table access methods. Since tables are indexes, an <em>index lookup</em> is the best and most common access method. But sometimes, depending on the query, an index lookup is not possible and the only recourse is an <em>index scan</em> or a <em>table scan</em>—the other access methods. Knowing which access method MySQL uses for a query is imperative because performance requires an index lookup. Avoid index scans and table scans. <a data-type="xref" href="#EXPLAIN">“EXPLAIN: Query Execution Plan”</a> shows how to see the access method. But first, let’s clarify and visualize each one.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The MySQL manual uses the terms <em>access method</em>, <em>access type</em>, and <em>join type</em>.&#13;
And <code>EXPLAIN</code> uses a field called <code>type</code> or <code>access_type</code> to refer to those terms.&#13;
In MySQL, the terms are closely related but used equivocally.</p>&#13;
&#13;
<p>In this book, for precision and consistency I use only two terms: <em>access method</em> and <em>access type</em>.&#13;
There are three access methods: index lookup, index scan, and table scan.&#13;
For an index lookup, there are several access types: <code>ref</code>, <code>eq_ref</code>, <code>range,</code> and so forth.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Index lookup" data-type="sect3"><div class="sect3" id="index-lookup">&#13;
<h3>Index lookup</h3>&#13;
&#13;
<p>An index lookup <a data-primary="index lookup" data-type="indexterm" id="idm45829114456912"/>finds specific rows—or ranges of rows—by leveraging the ordered structure and algorithmic access of an index. This is the fastest access method because it’s precisely what indexes are designed for: fast and efficient access to large amounts of data. Consequently, index lookups are essential for direct query optimization. Performance requires that practically every query uses an index lookup for every table. There are several access types for an index lookup that I cover in forthcoming sections such as <a data-type="xref" href="#idx-where">“WHERE”</a>.</p>&#13;
&#13;
<p><a data-type="xref" href="#idx-2nd-lookup-1">Figure 2-6</a> in the previous section shows an index lookup using a secondary index.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Index scan" data-type="sect3"><div class="sect3" id="index-scan">&#13;
<h3>Index scan</h3>&#13;
&#13;
<p>When an index lookup <a data-primary="index scan" data-type="indexterm" id="index-scan_index1"/>is not possible, MySQL must use brute force to find rows: read all rows and filter out non-matching ones. Before MySQL resorts to reading every row using the primary key, it tries to read rows using a secondary index. This is called an index scan.</p>&#13;
&#13;
<p>There are two types of index scan.&#13;
The first is a <em>full</em> index scan, meaning <a data-primary="full index scan" data-type="indexterm" id="full-index-scan-ch2"/>MySQL reads all rows in index order.&#13;
Reading all rows is usually terrible for performance, but reading them in index order can avoid sorting rows when the index order matches the query <code>ORDER BY</code>.</p>&#13;
&#13;
<p><a data-type="xref" href="#idx-index-scan">Figure 2-7</a> shows a full index scan for query <code>SELECT * FROM elem FORCE INDEX (a) ORDER BY a, b</code>.&#13;
The <code>FORCE INDEX</code> clause is required because, since table <code>elem</code> is tiny, it’s more efficient for MySQL to scan the primary key and sort the rows rather than scan the secondary index and fetch the rows in order.&#13;
(Sometimes bad queries make good examples.)</p>&#13;
&#13;
<p><a data-type="xref" href="#idx-index-scan">Figure 2-7</a> has eight callouts (numbered circles) that show the order of row access:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Read first value of secondary index (SI): “Ag, B.”</p>&#13;
</li>&#13;
<li>&#13;
<p>Look up corresponding row in primary key (PK).</p>&#13;
</li>&#13;
<li>&#13;
<p>Read second value of SI: “Al, Br.”</p>&#13;
</li>&#13;
<li>&#13;
<p>Look up corresponding row in PK.</p>&#13;
</li>&#13;
<li>&#13;
<p>Read third value of SI: “Ar, Br.”</p>&#13;
</li>&#13;
<li>&#13;
<p>Look up corresponding row in PK.</p>&#13;
</li>&#13;
<li>&#13;
<p>Read fourth value of SI: “Au, Be.”</p>&#13;
</li>&#13;
<li>&#13;
<p>Look up corresponding row in PK.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<figure><div class="figure" id="idx-index-scan">&#13;
<img alt="emsp 0207" src="assets/emsp_0207.png"/>&#13;
<h6><span class="label">Figure 2-7. </span>Full index scan on secondary index</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">There is a subtle but important detail in <a data-type="xref" href="#idx-index-scan">Figure 2-7</a>: scanning the secondary index in order might be sequential reads, but the primary key lookups are almost certainly random reads. Accessing rows in index order does not guarantee sequential reads; more than likely, it incurs random reads.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Sequential access (reads and writes) is faster than random access.<a data-primary="full index scan" data-startref="full-index-scan-ch2" data-type="indexterm" id="idm45829114431040"/></p>&#13;
</div>&#13;
&#13;
<p>The second type of index scan is an <em>index-only scan</em>: <a data-primary="index-only scan" data-type="indexterm" id="idm45829114429008"/>MySQL reads column values (not full rows) from the index. This requires a covering index, which is covered later (pun intended) in <a data-type="xref" href="#idx-covering-index">“Covering Indexes”</a>. It should be faster than a full index scan because it doesn’t require primary key lookups to read full rows; it only reads column values from the secondary index, which is why it requires a covering index.</p>&#13;
&#13;
<p>Don’t optimize for an index scan unless the only alternative is a full table scan.&#13;
Otherwise, avoid index scans.<a data-primary="index scan" data-startref="index-scan_index1" data-type="indexterm" id="idm45829114426464"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Table scan" data-type="sect3"><div class="sect3" id="table-scan">&#13;
<h3>Table scan</h3>&#13;
&#13;
<p>A (full) table scan <a data-primary="table scan" data-type="indexterm" id="table-scan_index1"/>reads <em>all</em> rows in primary key order. When MySQL cannot do an index lookup or an index scan, a table scan is the only option. This is usually terrible for performance, but it’s also usually easy to fix because MySQL is adept at using indexes and has many index-based optimizations. Essentially every query with a <code>WHERE</code>, <code>GROUP BY</code>, or <code>ORDER BY</code> clause can use an index—even if just an index scan—because those clauses use columns and columns can be indexed. Consequently, there are nearly zero reasons for an unfixable table scan.</p>&#13;
&#13;
<p><a data-type="xref" href="#idx-full-table-scan">Figure 2-8</a> shows a full table scan: reading <em>all</em> rows in primary key order. It has four callouts that show the order of row access.&#13;
Table <code>elem</code> is tiny and only four rows are shown here, but imagine MySQL slogging through thousands or millions of rows in a real table.</p>&#13;
&#13;
<p>The general advice and best practice is to avoid table scans.&#13;
But for a complete and balanced discussion, there are two cases when a table scan might be acceptable or (surprisingly) better:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>When the table is tiny and infrequently accessed</p>&#13;
</li>&#13;
<li>&#13;
<p>When the table selectivity is very low (see <a data-type="xref" href="#extreme-selectivity">“Extreme Selectivity”</a>)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="idx-full-table-scan">&#13;
<img alt="emsp 0208" src="assets/emsp_0208.png"/>&#13;
<h6><span class="label">Figure 2-8. </span>Full table scan</h6>&#13;
</div></figure>&#13;
&#13;
<p>But don’t take any table scan for granted: they’re usually bad for performance.&#13;
In very rare cases, MySQL can incorrectly choose a table scan when an index lookup is possible, as explained in <a data-type="xref" href="#its-a-trap">“It’s a Trap! (When MySQL Chooses Another Index)”</a>.<a data-primary="table access methods" data-startref="table-access-methods_index2" data-type="indexterm" id="idm45829114410816"/><a data-primary="indexes" data-secondary="table access methods" data-startref="table-access-methods_index1" data-type="indexterm" id="idm45829114409776"/><a data-primary="table scan" data-startref="table-scan_index1" data-type="indexterm" id="idm45829114408544"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Leftmost Prefix Requirement" data-type="sect2"><div class="sect2" id="LPR">&#13;
<h2>Leftmost Prefix Requirement</h2>&#13;
&#13;
<p>To use an index, <a data-primary="indexes" data-secondary="leftmost prefix requirement" data-type="indexterm" id="leftmost-prefix-requirement_index1"/><a data-primary="leftmost prefix requirement" data-type="indexterm" id="leftmost-prefix-requirement_index2"/>a query must use a <em>leftmost prefix</em> of the index: one or more index columns starting with the leftmost index column as specified by the index definition.&#13;
A leftmost prefix is required because the underlying index structure is ordered by the index column order, and it can only be traversed (searched) in that order.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Use <a href="https://oreil.ly/cwQZy"><code>SHOW CREATE TABLE</code></a> or <a href="https://oreil.ly/5wBhH"><code>SHOW INDEX</code></a> to see index definitions.</p>&#13;
</div>&#13;
&#13;
<p><a data-type="xref" href="#idx-lpr">Figure 2-9</a> shows an index on columns <code>a, b, c</code> and a <code>WHERE</code> clause using each leftmost prefix: column <code>a</code>; columns <code>a, b</code>; and columns <code>a, b, c</code>.</p>&#13;
&#13;
<figure><div class="figure" id="idx-lpr">&#13;
<img alt="emsp 0209" src="assets/emsp_0209.png"/>&#13;
<h6><span class="label">Figure 2-9. </span>Leftmost prefixes of a three-column index</h6>&#13;
</div></figure>&#13;
&#13;
<p>The top <code>WHERE</code> clause in <a data-type="xref" href="#idx-lpr">Figure 2-9</a> uses column <code>a</code>, which is the leftmost column of the index.&#13;
The middle <code>WHERE</code> clause uses columns <code>a</code> and <code>b</code> that, together, form a leftmost prefix of the index.&#13;
And the bottom <code>WHERE</code> clause uses the entire index: all three columns.&#13;
It’s ideal to use all columns of an index, but it’s not required; only a leftmost prefix is required.&#13;
Index columns can be used in other SQL clauses, as illustrated by many examples in the following sections.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>To use an index, a query must use a <em>leftmost prefix</em> of the index.</p>&#13;
</div>&#13;
&#13;
<p>The leftmost prefix requirement has two logical consequences:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Indexes <code>(a, b)</code> and <code>(b, a)</code> are different indexes.&#13;
They index the same columns but in a different order, which results in different leftmost prefixes.&#13;
However, a query that uses both columns (for example, <code>WHERE a = 'Au' AND b = 'Be'</code>) can use either index, but that does not mean the indexes are equivalent in terms of performance.&#13;
MySQL will choose the better of the two by calculating many factors.</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL can most likely use index <code>(a, b, c)</code> in place of indexes <code>(a)</code> and <code>(a, b)</code> because the latter two are leftmost prefixes of the first. In this case, indexes <code>(a)</code> and <code>(a, b)</code> are duplicates and can be dropped. Use <a href="https://oreil.ly/EqtfV">pt-duplicate-key-checker</a> to find and report duplicate indexes.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Lurking at the end (rightmost) of every secondary index is the primary key.&#13;
For table <code>elem</code> (<a data-type="xref" href="#elem">Example 2-1</a>), the secondary index is effectively <code>(a, b, id)</code>, but the rightmost <code>id</code> is hidden.&#13;
MySQL doesn’t show the primary key appended to secondary indexes; you have to imagine it.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The primary key is appended to every secondary index: <code>(S, P)</code> where <code>S</code> are secondary index columns and <code>P</code> are primary key <span class="keep-together">columns</span>.</p>&#13;
</div>&#13;
&#13;
<p>In MySQL lingo we say, “The primary key is appended to secondary indexes” even though it’s not literally appended.&#13;
(You can literally append it by creating index <code>(a, b, id)</code>, but don’t do that.)&#13;
“Appended to” really means that secondary index leaf nodes contain primary key values, as shown earlier in <a data-type="xref" href="#idx-secondary">Figure 2-5</a>.&#13;
This is important because it increases the size of every secondary index: primary key values are duplicated in secondary indexes.&#13;
Larger indexes require more memory, which means fewer indexes can fit in memory.&#13;
Keep the size of the primary key small and the number of secondary indexes reasonable.&#13;
Just the other day, my colleagues were helping a team whose database has 693 GB of secondary indexes on 397 GB of data (primary key).</p>&#13;
&#13;
<p>The leftmost prefix requirement is a blessing and a restriction. The restriction is relatively easy to work around with additional secondary indexes, but wait until you read <a data-type="xref" href="#idx-too-many">“Excessive, Duplicate, and Unused”</a>. Joining tables is a particular challenge given the restriction, but I address it in <a data-type="xref" href="#idx-join-tables">“Join Tables”</a>. I encourage you to see the leftmost prefix requirement as a blessing. Query optimization with respect to indexing is not trivial, but the leftmost prefix requirement is a simple and familiar starting point on the journey.<a data-primary="leftmost prefix requirement" data-startref="leftmost-prefix-requirement_index1" data-type="indexterm" id="idm45829114369920"/><a data-primary="indexes" data-secondary="leftmost prefix requirement" data-startref="leftmost-prefix-requirement_index2" data-type="indexterm" id="idm45829114368896"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="EXPLAIN: Query Execution Plan" data-type="sect2"><div class="sect2" id="EXPLAIN">&#13;
<h2>EXPLAIN: Query Execution Plan</h2>&#13;
&#13;
<p>The MySQL <a href="https://oreil.ly/M99Gp"><code>EXPLAIN</code></a> <a data-primary="indexes" data-secondary="EXPLAIN: query execution plan" data-type="indexterm" id="EXPLAIN-query-execution-plan"/><a data-primary="EXPLAIN: query execution plan" data-type="indexterm" id="idm45829114363408"/>command shows a <em>query execution plan</em> (or, <em>EXPLAIN plan</em>) that describes how MySQL plans to execute the query: table join order, table access method, index usage, and other important details.</p>&#13;
&#13;
<p><code>EXPLAIN</code> output is vast and varied. Moreover, it’s completely dependent on the query. Changing a single character in a query can significantly change its EXPLAIN plan. For example, <code>WHERE id = 1</code> verses <code>WHERE id &gt; 1</code> yields a significantly different EXPLAIN plan. And to complicate the matter further, <code>EXPLAIN</code> continues to evolve.&#13;
<a href="https://oreil.ly/IMCOJ">“EXPLAIN Output Format”</a> in the MySQL manual is required reading—even for experts. Fortunately for the sake of our sanity, the fundamentals have remained the same for decades.</p>&#13;
&#13;
<p>To illustrate index usage, the next five sections explain queries for each case that MySQL can use an index:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Find matching rows: <a data-type="xref" href="#idx-where">“WHERE”</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Group rows: <a data-type="xref" href="#idx-group-by">“GROUP BY”</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Sort rows: <a data-type="xref" href="#idx-order-by">“ORDER BY”</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Avoid reading rows: <a data-type="xref" href="#idx-covering-index">“Covering Indexes”</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Join tables: <a data-type="xref" href="#idx-join-tables">“Join Tables”</a></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are other specific cases like <code>MIN()</code> and <code>MAX()</code>, but these five cases are the bread and butter of index usage.</p>&#13;
&#13;
<p>But first I need to set the stage by reviewing the meaning of the <code>EXPLAIN</code> output fields shown in <a data-type="xref" href="#explain-output">Example 2-2</a>.</p>&#13;
<div data-type="example" id="explain-output">&#13;
<h5><span class="label">Example 2-2. </span><code>EXPLAIN</code> output (traditional format)</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT * FROM elem WHERE id = 1\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: const&#13;
possible_keys: PRIMARY&#13;
          key: PRIMARY&#13;
      key_len: 4&#13;
          ref: const&#13;
         rows: 1&#13;
     filtered: 100.00&#13;
        Extra: NULL</pre></div>&#13;
&#13;
<p>For this introduction, we ignore fields <code>id</code>, <code>select_type</code>, <code>partitions</code>, <code>key_len</code>, and <code>filtered</code>; but the examples include them to habituate you to the output. The remaining seven fields convey a wealth of information that constitutes the query execution plan:</p>&#13;
<dl>&#13;
<dt><code>table</code></dt>&#13;
<dd>&#13;
<p>The <code>table</code> field <a data-primary="table field" data-type="indexterm" id="idm45829114338496"/>is the table name (or alias) or subquery reference. Tables are listed in the join order determined by MySQL, not the order they appear in the query. The top table is the first table, and the bottom table is the last table.</p>&#13;
</dd>&#13;
<dt><code>type</code></dt>&#13;
<dd>&#13;
<p>They <code>type</code> field <a data-primary="type field" data-type="indexterm" id="idm45829114335152"/>is the table access method or index lookup access type—see the first note in <a data-type="xref" href="#table-access-methods">“Table Access Methods”</a> for clarification.&#13;
<code>ALL</code> means a full table scan (see <a data-type="xref" href="#table-scan">“Table scan”</a>).&#13;
<code>index</code> means an index scan (see <a data-type="xref" href="#index-scan">“Index scan”</a>).&#13;
Any other value—<code>const</code>, <code>ref</code>, <code>range</code>, and so on—is an access type for an index lookup (see <a data-type="xref" href="#index-lookup">“Index lookup”</a>).</p>&#13;
</dd>&#13;
<dt><code>possible_keys</code></dt>&#13;
<dd>&#13;
<p>The <code>possible_keys</code> <a data-primary="possible keys field" data-type="indexterm" id="idm45829114327216"/>field lists indexes that MySQL could use because the query uses a leftmost prefix. If an index is not listed in this field, then the leftmost prefix requirement is not met.</p>&#13;
</dd>&#13;
<dt><code>key</code></dt>&#13;
<dd>&#13;
<p>The <code>key</code> field <a data-primary="key field" data-type="indexterm" id="idm45829114324080"/>is the name of the index that MySQL will use, or <code>NULL</code> if no index can be used.&#13;
MySQL chooses the best index based on many factors, some of which are indicated in the <code>Extra</code> field.&#13;
It’s a safe bet that MySQL will use this index when executing the query (<code>EXPLAIN</code> does not execute the query), but see <a data-type="xref" href="#its-a-trap">“It’s a Trap! (When MySQL Chooses Another Index)”</a>.</p>&#13;
</dd>&#13;
<dt><code>ref</code></dt>&#13;
<dd>&#13;
<p>The <code>ref</code> field <a data-primary="ref field" data-type="indexterm" id="idm45829114319120"/>lists the source of values used to look up rows in the index (the <code>key</code> field).</p>&#13;
&#13;
<p>For single-table queries or the first table in a join, <code>ref</code> is often <code>const</code>, which refers to a constant condition on one or more index columns.&#13;
A <em>constant condition</em> is equality (<code>=</code> or <code>&lt;=&gt;</code> [NULL-safe equal]) to a literal value.&#13;
For example, <code>a = 'Au'</code> is a constant condition that equals only one value.</p>&#13;
&#13;
<p>For queries that join multiple tables, <code>ref</code> is a column reference from the preceding table in the join order.&#13;
MySQL joins the current table (the <code>table</code> field) using the index to look up rows that match values from column <code>ref</code> in the preceding table.&#13;
<a data-type="xref" href="#idx-join-tables">“Join Tables”</a> shows this in action.</p>&#13;
</dd>&#13;
<dt><code>rows</code></dt>&#13;
<dd>&#13;
<p>The <code>rows</code> field <a data-primary="rows field" data-type="indexterm" id="idm45829114309840"/>is the estimated number of rows that MySQL will examine to find matching rows.&#13;
MySQL uses index statistics to estimate rows, so expect the real number—<a data-type="xref" href="ch01.html#Rows-examined">“Rows examined”</a>—to be close but different.</p>&#13;
</dd>&#13;
<dt><code>Extra</code></dt>&#13;
<dd>&#13;
<p>The <code>Extra</code> field <a data-primary="extra field" data-type="indexterm" id="idm45829114306096"/>provides additional information about the query execution plan. This field is important because it indicates query optimizations that MySQL can apply, if any.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>All <code>EXPLAIN</code> output in this book is <em>traditional format</em>: tabular output (<code>EXPLAIN query;</code>) or list output (<code>EXPLAIN query\G</code>).&#13;
Other formats are <em>JSON</em> (<code>EXPLAIN FORMAT=JSON query</code>) and, as of MySQL 8.0.16, <em>tree</em> (<code>EXPLAIN FORMAT=TREE query</code>).&#13;
JSON and tree formats are completely different than traditional format, but all formats convey the query execution plan.</p>&#13;
</div>&#13;
&#13;
<p>Don’t expect to glean much information from those fields without context: tables, indexes, data, and a query.&#13;
In the following sections, all illustrations refer to table <code>elem</code> (<a data-type="xref" href="#elem">Example 2-1</a>), its two indexes, and its ten rows.<a data-primary="indexes" data-secondary="EXPLAIN: query execution plan" data-type="indexterm" id="idm45829114298224"/><a data-primary="EXPLAIN: query execution plan" data-type="indexterm" id="idm45829114297216"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="WHERE" data-type="sect2"><div class="sect2" id="idx-where">&#13;
<h2>WHERE</h2>&#13;
&#13;
<p>MySQL <a data-primary="indexes" data-secondary="WHERE" data-type="indexterm" id="WHERE_index1"/><a data-primary="WHERE" data-type="indexterm" id="WHERE_index2"/>can use an index to find rows that match table conditions in a <code>WHERE</code> clause.&#13;
I’m careful to say that MySQL <em>can</em> use an index, not that MySQL <em>will</em> use an index, because index usage depends on several factors, primarily: table conditions, indexes, and the  leftmost prefix requirement (see <a data-type="xref" href="#LPR">“Leftmost Prefix Requirement”</a>).&#13;
(There are other factors, like index statistics and optimizer costs, but they’re beyond the scope of this book.)</p>&#13;
&#13;
<p>A <em>table condition</em> <a data-primary="table condition" data-type="indexterm" id="idm45829114288400"/>is a column and its value (if any) that matches, groups, aggregates, or orders rows.&#13;
(For brevity, I use the term <em>condition</em> when it’s unambiguous.)&#13;
In a <code>WHERE</code> clause, table conditions are also called <em>predicates</em>.<a data-primary="predicates" data-type="indexterm" id="idm45829114286128"/></p>&#13;
&#13;
<p><a data-type="xref" href="#idx-where-pk">Figure 2-10</a> shows the primary key on column <code>id</code> and a <code>WHERE</code> clause with a single condition: <code>id = 1</code>.</p>&#13;
&#13;
<figure><div class="figure" id="idx-where-pk">&#13;
<img alt="emsp 0210" src="assets/emsp_0210.png"/>&#13;
<h6><span class="label">Figure 2-10. </span><code>WHERE</code>: primary key lookup</h6>&#13;
</div></figure>&#13;
&#13;
<p>A solid box delineates a table condition and an index column (also called an <em>index part</em>) that MySQL can use because the former (table condition) is a leftmost prefix of the latter (index).&#13;
An arrow points from the table condition to the index column that it uses.&#13;
Later, we’ll see examples of table conditions and index columns that MySQL cannot use.</p>&#13;
&#13;
<p class="pagebreak-before">In <a data-type="xref" href="#idx-where-pk">Figure 2-10</a>, MySQL can find rows that match condition <code>id = 1</code> using primary key column <code>id</code>.&#13;
<a data-type="xref" href="#ex-idx-where-pk">Example 2-3</a> is the EXPLAIN plan for the full query.</p>&#13;
<div data-type="example" id="ex-idx-where-pk">&#13;
<h5><span class="label">Example 2-3. </span>EXPLAIN plan for primary key lookup</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT * FROM elem WHERE id = 1\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: const&#13;
possible_keys: PRIMARY&#13;
          key: PRIMARY&#13;
      key_len: 4&#13;
          ref: const&#13;
         rows: 1&#13;
     filtered: 100.00&#13;
        Extra: NULL</pre></div>&#13;
&#13;
<p>In <a data-type="xref" href="#ex-idx-where-pk">Example 2-3</a>, <code>key: PRIMARY</code> confirms that MySQL will use the primary key—an index lookup. Correspondingly, the access type (the <code>type</code> field) is not <code>ALL</code> (table scan) or <code>index</code> (index scan), which is expected given a simple primary key lookup. The secondary index is not listed in the <code>possible_keys</code> field because MySQL cannot use it for this query: column <code>id</code> is not a leftmost prefix of the secondary index on columns <code>a, b</code>.</p>&#13;
&#13;
<p>Access type <code>const</code> is a special case that occurs only when there are constant conditions (<code>ref: const</code>) on all index columns of the primary key or a unique secondary index.&#13;
The result is a <em>constant row</em>.<a data-primary="constant row" data-type="indexterm" id="idm45829114267360"/>&#13;
This is a little too in-depth for an introduction, but since we’re here, let’s keep learning.&#13;
Given the table data (<a data-type="xref" href="#elem">Example 2-1</a>) and the fact that column <code>id</code> is the primary key, the row identified by <code>id = 1</code> can be treated as constant because, when the query is executed, <code>id = 1</code> can match only one row (or no row).&#13;
MySQL reads that one row and treats its values as constant, which is great for response time: <code>const</code> access is extremely fast.</p>&#13;
&#13;
<p><code>Extra: NULL</code> is somewhat rare because real queries are more complex than these examples.&#13;
But here, <code>Extra: NULL</code> means that MySQL does not need to match rows.&#13;
Why?&#13;
Because the constant row can match only one row (or no row).&#13;
But matching rows is the norm, so let’s see a more realistic example by changing the table conditions to <code>id &gt; 3 AND id &lt; 6 AND c = 'Cd'</code>, as shown in <a data-type="xref" href="#idx-where-pk-range">Figure 2-11</a> and the corresponding EXPLAIN plan in <a data-type="xref" href="#ex-idx-where-pk-5">Example 2-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="idx-where-pk-range">&#13;
<img alt="emsp 0211" src="assets/emsp_0211.png"/>&#13;
<h6><span class="label">Figure 2-11. </span><code>WHERE</code>: range access using primary key</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="ex-idx-where-pk-5">&#13;
<h5><span class="label">Example 2-4. </span>EXPLAIN plan for range access using primary key</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT * FROM elem WHERE id &gt; 3 AND id &lt; 6 AND c = 'Cd'\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
&gt;        type: range&#13;
possible_keys: PRIMARY&#13;
          key: PRIMARY&#13;
      key_len: 4&#13;
&gt;         ref: NULL&#13;
&gt;        rows: 2&#13;
     filtered: 10.00&#13;
&gt;       Extra: Using where</pre></div>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To highlight EXPLAIN plan changes, I prepend <code>&gt;</code> characters to the pertinent fields that changed.&#13;
These highlights are not part of <code>EXPLAIN</code>.</p>&#13;
</div>&#13;
&#13;
<p>By changing the table conditions to <code>id &gt; 3 AND id &lt; 6 AND c = 'Cd'</code>, the EXPLAIN plan changes from <a data-type="xref" href="#ex-idx-where-pk">Example 2-3</a> to <a data-type="xref" href="#ex-idx-where-pk-5">Example 2-4</a>, which is more realistic for a single-table query.&#13;
The query still uses the primary key (<code>key: PRIMARY</code>), but the access type changes to a <em>range scan</em> (<code>type: range</code>): <a data-primary="range scan" data-type="indexterm" id="idm45829114248944"/>using an index to read rows between a range of values.&#13;
In this case, MySQL uses the primary key to read rows where the value of column <code>id</code> is between 3 and 6.&#13;
The <code>ref</code> field is <code>NULL</code> because the conditions on column <code>id</code> are not constant (and this is a single-table query, so there’s no preceding table to reference).&#13;
The condition <code>c = 'Cd'</code> is constant, but it’s not used for the index lookup (the range scan), so <code>ref</code> does not apply.&#13;
MySQL estimates that it will examine two rows in the range (<code>rows: 2</code>).&#13;
That’s correct for this trivial example, but remember: <code>rows</code> is an estimate.</p>&#13;
&#13;
<p>“Using where” in the <code>Extra</code> field is so common that it’s expected.&#13;
It means that MySQL will find <em>matching rows</em> <a data-primary="matching rows" data-type="indexterm" id="idm45829114242992"/>using the <code>WHERE</code> conditions: for each row read, a row matches if all <code>WHERE</code> conditions are true.&#13;
Since the conditions on column <code>id</code> define the range, it’s really just the condition on column <code>c</code> that MySQL will use to match rows in the range.&#13;
Glancing back at <a data-type="xref" href="#elem">Example 2-1</a>, one row matches all the <code>WHERE</code> conditions:</p>&#13;
&#13;
<pre data-type="programlisting">+----+------+------+------+&#13;
| id | a    | b    | c    |&#13;
+----+------+------+------+&#13;
|  4 | Ar   | Br   | Cd   |&#13;
+----+------+------+------+</pre>&#13;
&#13;
<p>The row with <code>id = 5</code> is in the range, so MySQL examines the row, but its column <code>c</code> value (“Cd”) does not match the <code>WHERE</code> clause, so MySQL does not return the row.</p>&#13;
&#13;
<p>To illustrate other query execution plans, let’s use both leftmost prefixes of the secondary index, as shown in <a data-type="xref" href="#idx-where-sec">Figure 2-12</a> and the corresponding EXPLAIN plans in <a data-type="xref" href="#ex-idx-where-sec">Example 2-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="idx-where-sec">&#13;
<img alt="emsp 0212" src="assets/emsp_0212.png"/>&#13;
<h6><span class="label">Figure 2-12. </span><code>WHERE</code>: secondary index lookups</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="ex-idx-where-sec">&#13;
<h5><span class="label">Example 2-5. </span>EXPLAIN plans for secondary index lookups</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT * FROM elem WHERE a = 'Au'\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
&gt;        type: ref&#13;
possible_keys: idx_a_b&#13;
&gt;         key: idx_a_b&#13;
      key_len: 3&#13;
          ref: const&#13;
         rows: 1&#13;
     filtered: 100.00&#13;
        Extra: NULL&#13;
&#13;
&#13;
EXPLAIN SELECT * FROM elem WHERE a = 'Au' AND b = 'Be'\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
&gt;        type: ref&#13;
possible_keys: idx_a_b&#13;
&gt;         key: idx_a_b&#13;
      key_len: 6&#13;
          ref: const,const&#13;
         rows: 1&#13;
     filtered: 100.00&#13;
        Extra: NULL</pre></div>&#13;
&#13;
<p>For each EXPLAIN plan in <a data-type="xref" href="#ex-idx-where-sec">Example 2-5</a>, <code>key: idx_a_b</code> confirms that MySQL uses the secondary index because the conditions meet the leftmost prefix requirement. The first <code>WHERE</code> clause uses only the first index part: column <code>a</code>. The second <code>WHERE</code> clause uses both index parts: columns <code>a</code> and <code>b</code>. Using only column <code>b</code> would not meet the leftmost prefix requirement—I show this in a moment.</p>&#13;
&#13;
<p>What’s new and important from previous EXPLAIN plans is the access type: <code>ref</code>.&#13;
In simplest terms, the <code>ref</code> access type is an equality (<code>=</code> or <code>&lt;=&gt;</code>) lookup on a leftmost prefix of the index (the <code>key</code> field).&#13;
Like any index lookup, <code>ref</code> access is very fast as long as the estimated number of rows to examine (the <code>rows</code> field) is reasonable.</p>&#13;
&#13;
<p>Although the conditions are constant, the <code>const</code> access type is not possible because the index (<code>key: idx_a_b</code>) is nonunique, so the lookup can match more than one row.&#13;
And even though MySQL estimates that each <code>WHERE</code> clause will examine only one row (<code>rows: 1</code>), that could change when the query is executed.</p>&#13;
&#13;
<p><code>Extra: NULL</code> occurs again because MySQL can find matching rows using only the index since there are no conditions on non-indexed columns—so let’s add one.&#13;
<a data-type="xref" href="#idx-where-sec-c">Figure 2-13</a> shows a <code>WHERE</code> clause with conditions on columns <code>a</code> and <code>c</code>, and <a data-type="xref" href="#ex-idx-where-sec-c">Example 2-6</a> is the corresponding EXPLAIN plan.</p>&#13;
&#13;
<figure><div class="figure" id="idx-where-sec-c">&#13;
<img alt="emsp 0213" src="assets/emsp_0213.png"/>&#13;
<h6><span class="label">Figure 2-13. </span><code>WHERE</code>: index lookup and non-indexed column</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="ex-idx-where-sec-c">&#13;
<h5><span class="label">Example 2-6. </span>EXPLAIN plan for index lookup and non-indexed column</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT * FROM elem WHERE a = 'Al' AND c = 'Co'\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: ref&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 3&#13;
          ref: const&#13;
&gt;        rows: 3&#13;
     filtered: 10.00&#13;
&gt;       Extra: Using where</pre></div>&#13;
&#13;
<p>In <a data-type="xref" href="#idx-where-sec-c">Figure 2-13</a>, there is no box around condition <code>c = 'Co'</code> because the index does not cover column <code>c</code>. MySQL still uses the secondary index (<code>key: idx_a_b</code>), but the condition on column <code>c</code> prevents MySQL from matching rows using only the index. Instead, MySQL uses the index to look up and read rows for the condition on column <code>a</code>, then it matches rows for the condition on column <code>c</code> (<code>Extra: Using where</code>).</p>&#13;
&#13;
<p>Glancing back at <a data-type="xref" href="#elem">Example 2-1</a> again, you’ll notice that zero rows match this <code>WHERE</code> clause, but <code>EXPLAIN</code> reports <code>rows: 3</code>. Why? The index lookup on column <code>a</code> matches three rows where <code>a = 'Al'</code> is true: row <code>id</code> values 3, 8, and 9. But none of these rows also matches <code>c = 'Co'</code>. The query examines three rows but matches zero rows.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><code>EXPLAIN</code> output <code>rows</code> is an estimate of the number of rows that MySQL will examine when it executes the query, not the number of rows that will match all table conditions.</p>&#13;
</div>&#13;
&#13;
<p>As a final example of indexes, <code>WHERE</code>, and <code>EXPLAIN</code>, let’s <em>not</em> meet the leftmost prefix requirement, as shown in <a data-type="xref" href="#idx-where-sec-b">Figure 2-14</a> and <a data-type="xref" href="#ex-idx-where-sec-b">Example 2-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="idx-where-sec-b">&#13;
<img alt="emsp 0214" src="assets/emsp_0214.png"/>&#13;
<h6><span class="label">Figure 2-14. </span><code>WHERE</code> without leftmost prefix</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="ex-idx-where-sec-b">&#13;
<h5><span class="label">Example 2-7. </span>EXPLAIN plan for <code>WHERE</code> without leftmost prefix</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT * FROM elem WHERE b = 'Be'\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
&gt;        type: ALL&#13;
possible_keys: NULL&#13;
&gt;         key: NULL&#13;
      key_len: NULL&#13;
          ref: NULL&#13;
         rows: 10&#13;
     filtered: 10.00&#13;
        Extra: Using where</pre></div>&#13;
&#13;
<p>A dotted box outline (and lack of arrow) delineates a table condition and an index column that MySQL cannot use because they do not meet the leftmost prefix <span class="keep-together">requirement</span>.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#idx-where-sec-b">Figure 2-14</a>, there is no condition on column <code>a</code>, therefore the index cannot be used for the condition on column <code>b</code>. The EXPLAIN plan (<a data-type="xref" href="#ex-idx-where-sec-b">Example 2-7</a>) confirms this: <span class="keep-together">possible_keys: NULL</span> and <code>key: NULL</code>. Without an index, MySQL is forced to do a full table scan: <code>type: ALL</code>. Likewise, <code>rows: 10</code> reflects the total number of rows, and <code>Extra: Using where</code> reflects that MySQL reads and then filters rows not matching <span class="keep-together"><code>b = 'Be'</code></span>.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-idx-where-sec-b">Example 2-7</a> is an example of the worst possible EXPLAIN plan. Whenever you see <code>type: ALL</code>, <code>possible_keys: NULL</code>, or <code>key: NULL</code>, stop what you’re doing and analyze the query.</p>&#13;
&#13;
<p>As simple as these examples have been, they represent the fundamentals of <code>EXPLAIN</code> with respect to indexes and <code>WHERE</code> clauses.&#13;
Real queries have more indexes and <code>WHERE</code> conditions, but the fundamentals don’t change.<a data-primary="indexes" data-secondary="WHERE" data-startref="WHERE_index1" data-type="indexterm" id="idm45829114177312"/><a data-primary="WHERE" data-startref="WHERE_index2" data-type="indexterm" id="idm45829114176064"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="GROUP BY" data-type="sect2"><div class="sect2" id="idx-group-by">&#13;
<h2>GROUP BY</h2>&#13;
&#13;
<p>MySQL can use an <a data-primary="indexes" data-secondary="GROUP BY" data-type="indexterm" id="GROUP_BY_index1"/><a data-primary="GROUP BY" data-type="indexterm" id="GROUP_BY_index2"/>index to optimize <code>GROUP BY</code> because values are implicitly grouped by index order.&#13;
For the secondary index <code>idx_a_b</code> (on columns <code>a, b</code>), there are five distinct groups of column <code>a</code> values, as shown in <a data-type="xref" href="#a-col-groups">Example 2-8</a>.</p>&#13;
<div data-type="example" id="a-col-groups">&#13;
<h5><span class="label">Example 2-8. </span>Distinct groups of column <code>a</code> values</h5>&#13;
&#13;
<pre data-type="programlisting">SELECT a, b FROM elem ORDER BY a, b;&#13;
&#13;
+------+------+&#13;
| a    | b    |&#13;
+------+------+&#13;
| Ag   | B    | -- Ag group&#13;
| Ag   | B    |&#13;
&#13;
| Al   | B    | -- Al group&#13;
| Al   | B    |&#13;
| Al   | Br   |&#13;
&#13;
| Ar   | B    | -- Ar group&#13;
| Ar   | Br   |&#13;
| Ar   | Br   |&#13;
&#13;
| At   | Bi   | -- At group&#13;
&#13;
| Au   | Be   | -- Au group&#13;
+------+------+</pre></div>&#13;
&#13;
<p>I separated the groups in <a data-type="xref" href="#a-col-groups">Example 2-8</a> with blank lines and annotated the first row in each group.&#13;
A query with <code>GROUP BY a</code> can use index <code>idx_a_b</code> because column <code>a</code> is a leftmost prefix and the index is implicitly grouped by column <code>a</code> values.&#13;
<a data-type="xref" href="#ex-idx-group-by-a">Example 2-9</a> is a representative EXPLAIN plan for the simplest type of <code>GROUP BY</code> optimization.</p>&#13;
<div data-type="example" id="ex-idx-group-by-a">&#13;
<h5><span class="label">Example 2-9. </span>EXPLAIN plan for <code>GROUP BY a</code></h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT a, COUNT(*) FROM elem GROUP BY a\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
&gt;        type: index&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 6&#13;
          ref: NULL&#13;
         rows: 10&#13;
     filtered: 100.00&#13;
&gt;       Extra: Using index</pre></div>&#13;
&#13;
<p><code>key: idx_a_b</code> confirms that MySQL uses the index to optimize the <code>GROUP BY</code>.&#13;
Since the index is ordered, MySQL is assured that each new value for column <code>a</code> is a new group.&#13;
For example, after reading the last “Ag” value, the index order assures that no more “Ag” values will be read, so the “Ag” group is complete.</p>&#13;
&#13;
<p>“Using index” in the <code>Extra</code> field indicates that MySQL is reading column <code>a</code> values only from the index; it’s not reading full rows from the primary key.&#13;
I cover this optimization in <a data-type="xref" href="#idx-covering-index">“Covering Indexes”</a>.</p>&#13;
&#13;
<p>This query uses an index, but not for an index lookup: <code>type: index</code> denotes an index scan (see <a data-type="xref" href="#index-scan">“Index scan”</a>).&#13;
And since there’s no <code>WHERE</code> clause to filter rows, MySQL reads all rows.&#13;
If you add a <code>WHERE</code> clause, MySQL can still use the index for the <code>GROUP BY</code>, but the leftmost prefix requirement still applies.&#13;
In this case, the query is using the leftmost index part (column <code>a</code>), so the <code>WHERE</code> condition must be on column <code>a</code> or <code>b</code> to meet the leftmost prefix requirement.&#13;
Let’s first add a <code>WHERE</code> condition on column <code>a</code>, as shown in <a data-type="xref" href="#idx-group-by-a-where">Figure 2-15</a> and <a data-type="xref" href="#ex-idx-group-by-a-where">Example 2-10</a>.</p>&#13;
&#13;
<figure><div class="figure" id="idx-group-by-a-where">&#13;
<img alt="emsp 0215" src="assets/emsp_0215.png"/>&#13;
<h6><span class="label">Figure 2-15. </span><code>GROUP BY</code> and <code>WHERE</code> on same index column</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="ex-idx-group-by-a-where">&#13;
<h5><span class="label">Example 2-10. </span>EXPLAIN plan for <code>GROUP BY</code> and <code>WHERE</code> on same index column</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT a, COUNT(a) FROM elem WHERE a != 'Ar' GROUP BY a\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
&gt;        type: range&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 3&#13;
          ref: NULL&#13;
         rows: 7&#13;
     filtered: 100.00&#13;
&gt;       Extra: Using where; Using index</pre></div>&#13;
&#13;
<p>“Using where” in the <code>Extra</code> field refers to <code>WHERE a != 'Ar'</code>. The interesting change is <code>type: range</code>. The range access type works with the not-equal operator (<code>!=</code> or <code>&lt;&gt;</code>). You can think of it like <code>WHERE a &lt; 'Ar' AND a &gt; 'Ar'</code>, as shown in <a data-type="xref" href="#idx-order-by-not-ar">Figure 2-16</a>.</p>&#13;
&#13;
<p>A condition on column <code>b</code> in the <code>WHERE</code> clause can still use the index because the conditions, regardless of being in different SQL clauses, meet the leftmost prefix requirement. <a data-type="xref" href="#idx-group-by-a-where-b">Figure 2-17</a> shows this, and <a data-type="xref" href="#ex-idx-group-by-a-where-b">Example 2-11</a> shows the EXPLAIN plan.</p>&#13;
&#13;
<figure><div class="figure" id="idx-order-by-not-ar">&#13;
<img alt="emsp 0216" src="assets/emsp_0216.png"/>&#13;
<h6><span class="label">Figure 2-16. </span>Range for not-equal</h6>&#13;
</div></figure>&#13;
&#13;
<figure><div class="figure" id="idx-group-by-a-where-b">&#13;
<img alt="emsp 0217" src="assets/emsp_0217.png"/>&#13;
<h6><span class="label">Figure 2-17. </span><code>GROUP BY</code> and <code>WHERE</code> on different index columns</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="ex-idx-group-by-a-where-b">&#13;
<h5><span class="label">Example 2-11. </span>EXPLAIN plan for <code>GROUP BY</code> and <code>WHERE</code> on different index columns</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT a, b FROM elem WHERE b = 'B' GROUP BY a\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: range&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 6&#13;
          ref: NULL&#13;
         rows: 6&#13;
     filtered: 100.00&#13;
&gt;       Extra: Using where; Using index for group-by</pre></div>&#13;
&#13;
<p>The query in <a data-type="xref" href="#ex-idx-group-by-a-where-b">Example 2-11</a> has two important details: an equality condition on column <code>b</code> in the <code>WHERE</code> clause, and selecting columns <code>a</code> and <code>b</code> in the <code>SELECT</code> clause. These details enable the special “Using index for group-by” optimization revealed in the <code>Extra</code> field. If, for example, the equality (<code>=</code>) is changed to not-equal (<code>!=</code>), the query optimization is lost. When it comes to query optimizations like this, details are critical. You must read the MySQL manual to learn and apply the details. <a href="https://oreil.ly/ZknLf">“GROUP BY Optimization”</a> in the MySQL manual elaborates.</p>&#13;
&#13;
<p>The final <code>GROUP BY</code> example in <a data-type="xref" href="#idx-group-by-b">Figure 2-18</a> and <a data-type="xref" href="#ex-idx-group-by-b">Example 2-12</a> might surprise you.</p>&#13;
&#13;
<figure><div class="figure" id="idx-group-by-b">&#13;
<img alt="emsp 0218" src="assets/emsp_0218.png"/>&#13;
<h6><span class="label">Figure 2-18. </span><code>GROUP BY</code> without leftmost prefix</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="ex-idx-group-by-b">&#13;
<h5><span class="label">Example 2-12. </span>EXPLAIN plan for <code>GROUP BY</code> without leftmost prefix</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT b, COUNT(*) FROM elem GROUP BY b\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
&gt;        type: index&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 6&#13;
          ref: NULL&#13;
         rows: 10&#13;
     filtered: 100.00&#13;
&gt;       Extra: Using index; Using temporary</pre></div>&#13;
&#13;
<p>Notice <code>key: idx_a_b</code>: MySQL uses the index despite the query having no condition on column <code>a</code>. What happened to the leftmost prefix requirement? It’s being met because MySQL is scanning the index (<code>type: index</code>) on column <code>a</code>. You can imagine a condition on column <code>a</code> that’s always true, like <code>a = a</code>.</p>&#13;
&#13;
<p>Would MySQL still index scan on column <code>a</code> for <code>GROUP BY c</code>? No, it would not; it would do a full table scan. <a data-type="xref" href="#idx-group-by-b">Figure 2-18</a> works because the index has column <code>b</code> values; it does not have column <code>c</code> values.</p>&#13;
&#13;
<p>“Using temporary” in the <code>Extra</code> field is a side effect of not having a strict set of leftmost prefix conditions. As MySQL reads column <code>a</code> values from the index, it collects column <code>b</code> values in a temporary table (in memory). After reading all column <code>a</code> values, it table scans the temporary table to group and aggregate for <code>COUNT(*)</code>.</p>&#13;
&#13;
<p>There is a lot more to learn about <code>GROUP BY</code> with respect to indexes and query optimizations, but these examples are the fundamentals. Unlike <code>WHERE</code> clauses, <code>GROUP BY</code> clauses tend to be simpler. The challenge is creating an index to optimize <code>GROUP BY</code> plus other SQL clauses. MySQL has the same challenge when formulating the query execution plan, so it might not optimize <code>GROUP BY</code> even when possible. MySQL almost always chooses the best query execution plan, but if you want to experiment with different ones, read <a href="https://oreil.ly/mbBof">“Index Hints”</a> in the MySQL manual.<a data-primary="indexes" data-secondary="GROUP BY" data-startref="GROUP_BY_index1" data-type="indexterm" id="idm45829114097888"/><a data-primary="GROUP BY" data-startref="GROUP_BY_index2" data-type="indexterm" id="idm45829114096608"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ORDER BY" data-type="sect2"><div class="sect2" id="idx-order-by">&#13;
<h2>ORDER BY</h2>&#13;
&#13;
<p>Unsurprisingly, <a data-primary="indexes" data-secondary="ORDER BY" data-type="indexterm" id="ORDER_BY_index1"/><a data-primary="ORDER BY" data-type="indexterm" id="ORDER_BY_index2"/>MySQL can use an ordered index to optimize <code>ORDER BY</code>.&#13;
This optimization avoids sorting rows, which takes a little more time, by accessing rows in order.&#13;
Without this optimization, MySQL reads all matching rows, sorts them, then returns the sorted result set.&#13;
When MySQL sorts rows, it prints “Using filesort” in the <code>Extra</code> field of the EXPLAIN plan.&#13;
<em>Filesort</em> means <em>sort rows</em>.&#13;
It’s a historical (and now misleading) term but still the prevalent term in MySQL lingo.</p>&#13;
&#13;
<p>Filesort is a consternation for engineers because it has a reputation for being slow.&#13;
Sorting rows is extra work, so it does not improve response time, but it’s usually not the root cause of slow response time.&#13;
At the end of this section, I use <code>EXPLAIN</code> <span class="keep-together"><code>ANALYZE</code></span>, which is new as of MySQL 8.0.18, to measure the real-time penalty of filesort.&#13;
(Spoiler: sorting rows is very fast.)&#13;
But first, let’s examine how to use indexes to optimize <code>ORDER BY</code>.</p>&#13;
&#13;
<p>There are three ways to use an index to optimize <code>ORDER BY</code>.&#13;
The first and simplest way is using a leftmost prefix of an index for the <code>ORDER BY</code> clause.&#13;
For table <code>elem</code>, that means:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>ORDER BY id</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>ORDER BY a</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>ORDER BY a, b</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The second way is to hold a leftmost part of the index constant and order by the next index columns. For example, holding column <code>a</code> constant and ordering by column <code>b</code>, as shown in <a data-type="xref" href="#idx-order-by-b-where-a">Figure 2-19</a> with corresponding EXPLAIN plan in <a data-type="xref" href="#ex-idx-order-by-b-where-a">Example 2-13</a>.</p>&#13;
&#13;
<figure><div class="figure" id="idx-order-by-b-where-a">&#13;
<img alt="emsp 0219" src="assets/emsp_0219.png"/>&#13;
<h6><span class="label">Figure 2-19. </span><code>ORDER BY</code> and <code>WHERE</code> on different index columns</h6>&#13;
</div></figure>&#13;
<div data-type="example" id="ex-idx-order-by-b-where-a">&#13;
<h5><span class="label">Example 2-13. </span>EXPLAIN plan for <code>ORDER BY</code> and <code>WHERE</code> on different index columns</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT a, b FROM elem WHERE a = 'Ar' ORDER BY b\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: ref&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 3&#13;
          ref: const&#13;
         rows: 3&#13;
     filtered: 100.00&#13;
        Extra: Using index</pre></div>&#13;
&#13;
<p><code>WHERE a = 'Ar' ORDER BY b</code> can use index <code>(a, b)</code> because the <code>WHERE</code> condition on the first index part (column <code>a</code>) is constant, so MySQL jumps to <code>a = 'Ar'</code> in the index and, from there, reads column <code>b</code> values in order. <a data-type="xref" href="#res-idx-order-by-b-where-a">Example 2-14</a> is the result set, and although it’s nothing fancy, it shows that column <code>a</code> is constant (value “Ar”) and column <code>b</code> is sorted.</p>&#13;
<div data-type="example" id="res-idx-order-by-b-where-a">&#13;
<h5><span class="label">Example 2-14. </span>Result set of <code>WHERE a = 'Ar' ORDER BY b</code></h5>&#13;
&#13;
<pre data-type="programlisting">+------+------+&#13;
| a    | b    |&#13;
+------+------+&#13;
| Ar   | B    |&#13;
| Ar   | Br   |&#13;
| Ar   | Br   |&#13;
+------+------+</pre></div>&#13;
&#13;
<p>If table <code>elem</code> had an index on columns <code>a, b, c</code>, a query like <code>WHERE a = 'Au' AND b = 'Be' ORDER BY c</code> could use the index because the conditions on columns <code>a</code> and <code>b</code> hold the leftmost part of the index.</p>&#13;
&#13;
<p>The third way is a special case of the second.&#13;
Before showing the figure that explains it, see if you can determine why the query in <a data-type="xref" href="#ex-idx-order-by-pk">Example 2-15</a> does <em>not</em> cause a filesort (why “Using filesort” is not reported in the <code>Extra</code> field).</p>&#13;
<div data-type="example" id="ex-idx-order-by-pk">&#13;
<h5><span class="label">Example 2-15. </span>EXPLAIN plan for <code>ORDER BY id</code></h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT * FROM elem WHERE a = 'Al' AND b = 'B' ORDER BY id\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: ref&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 16&#13;
          ref: const,const&#13;
         rows: 2&#13;
     filtered: 100.00&#13;
&gt;       Extra: Using index condition</pre></div>&#13;
&#13;
<p>It’s understandable that the query uses index <code>idx_a_b</code> because the <code>WHERE</code> conditions are a leftmost prefix, but shouldn’t <code>ORDER BY id</code> cause a filesort?&#13;
<a data-type="xref" href="#idx-order-by-pk">Figure 2-20</a> reveals the answer.</p>&#13;
&#13;
<figure><div class="figure" id="idx-order-by-pk">&#13;
<img alt="emsp 0220" src="assets/emsp_0220.png"/>&#13;
<h6><span class="label">Figure 2-20. </span><code>ORDER BY</code> using primary key appended to secondary index</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#LPR">“Leftmost Prefix Requirement”</a> has a paragraph that begins with, “Lurking at the end (rightmost) of every secondary index is the primary key.” That’s what’s happening in <a data-type="xref" href="#idx-order-by-pk">Figure 2-20</a>: the dark box around index column <code>id</code> reveals the “hidden” primary key appended to the secondary index. This <code>ORDER BY</code> optimization might not seem useful with a little table like <code>elem</code>, but with real tables it can be very useful—worth remembering.</p>&#13;
&#13;
<p>To prove that the “hidden” primary key allows the <code>ORDER BY</code> to avoid a filesort, let’s remove the condition on column <code>b</code> to invalidate the optimization, as shown in <a data-type="xref" href="#idx-order-by-pk-not">Figure 2-21</a> and followed by the resulting EXPLAIN plan in <a data-type="xref" href="#ex-idx-order-by-pk-not">Example 2-16</a>.</p>&#13;
&#13;
<figure><div class="figure" id="idx-order-by-pk-not">&#13;
<img alt="emsp 0221" src="assets/emsp_0221.png"/>&#13;
<h6><span class="label">Figure 2-21. </span><code>ORDER BY</code> without leftmost prefix</h6>&#13;
</div></figure>&#13;
<div class="pagebreak-before less_space" data-type="example" id="ex-idx-order-by-pk-not">&#13;
<h5><span class="label">Example 2-16. </span>EXPLAIN plan for <code>ORDER BY</code> without leftmost prefix</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT * FROM elem WHERE a = 'Al' ORDER BY id\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: ref&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 8&#13;
          ref: const&#13;
         rows: 3&#13;
     filtered: 100.00&#13;
&gt;       Extra: Using index condition; Using filesort</pre></div>&#13;
&#13;
<p>By removing the condition on column <code>b</code>, there’s no longer a leftmost prefix on the secondary index that allows MySQL to use the “hidden” primary key to optimize <code>ORDER BY</code>.&#13;
Therefore, for this particular query, “Using filesort” appears in the <code>Extra</code> field.</p>&#13;
&#13;
<p>The new optimization is “Using index condition,” which is called index condition pushdown.&#13;
<em>Index condition pushdown</em> <a data-primary="index condition pushdown" data-type="indexterm" id="idm45829114036944"/>means the storage engine uses an index to matches rows for <code>WHERE</code> conditions.&#13;
Normally, storage engines only read and write rows, and MySQL handles the logic of matching rows.&#13;
This is a clean separation of concerns (which is a virtue for software design), but it’s inefficient when rows don’t match: both MySQL and the storage engine waste time reading non-matching rows.&#13;
For the query in <a data-type="xref" href="#ex-idx-order-by-pk-not">Example 2-16</a>, index condition pushdown means the storage engine (InnoDB) uses index <code>idx_a_b</code> to match condition <code>a = 'Al'</code>.&#13;
Index condition pushdown helps improve response time, but don’t exert yourself trying to optimize for it because MySQL uses it automatically when possible.&#13;
To learn more, read <a href="https://oreil.ly/L3Nzm">“Index Condition Pushdown Optimization”</a> in the MySQL manual.</p>&#13;
&#13;
<p>There’s an important detail that affects all <code>ORDER BY</code> optimizations: index order is ascending by default, and <code>ORDER BY col</code> implies ascending: <code>ORDER BY col ASC</code>.&#13;
Optimizing <code>ORDER BY</code> works in only one direction for all columns: <code>ASC</code> (ascending) or <code>DESC</code> (descending).&#13;
Consequently, <code>ORDER BY a, b DESC</code> does not work because column <code>a</code> is an implicit <code>ASC</code> sort, which is different than <code>b DESC</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>MySQL 8.0 supports <a href="https://oreil.ly/FDTsN">descending indexes</a>.</p>&#13;
</div>&#13;
&#13;
<p>What is the real time penalty of filesort?<a data-primary="EXPLAIN ANALYZE" data-type="indexterm" id="EXPLAIN_ANALYZE"/>&#13;
Prior to MySQL 8.0.18, it was neither measured nor reported.&#13;
But as of MySQL 8.0.18, <a href="https://oreil.ly/DFPiF"><code>EXPLAIN ANALYZE</code></a> measures and reports it.&#13;
For only <a data-type="xref" href="#ex-2-17">Example 2-17</a>, I must use a different table.</p>&#13;
<div data-type="example" id="ex-2-17">&#13;
<h5><span class="label">Example 2-17. </span>Sysbench table <code>sbtest</code></h5>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="o">`</code><code class="n">sbtest1</code><code class="o">`</code> <code class="p">(</code>&#13;
  <code class="o">`</code><code class="n">id</code><code class="o">`</code> <code class="nb">int</code> <code class="k">NOT</code> <code class="k">NULL</code> <code class="n">AUTO_INCREMENT</code><code class="p">,</code>&#13;
  <code class="o">`</code><code class="n">k</code><code class="o">`</code> <code class="nb">int</code> <code class="k">NOT</code> <code class="k">NULL</code> <code class="k">DEFAULT</code> <code class="s1">'0'</code><code class="p">,</code>&#13;
  <code class="o">`</code><code class="k">c</code><code class="o">`</code> <code class="nb">char</code><code class="p">(</code><code class="mi">120</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code> <code class="k">DEFAULT</code> <code class="s1">''</code><code class="p">,</code>&#13;
  <code class="o">`</code><code class="k">pad</code><code class="o">`</code> <code class="nb">char</code><code class="p">(</code><code class="mi">60</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code> <code class="k">DEFAULT</code> <code class="s1">''</code><code class="p">,</code>&#13;
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="o">`</code><code class="n">id</code><code class="o">`</code><code class="p">),</code>&#13;
  <code class="k">KEY</code> <code class="o">`</code><code class="n">k_1</code><code class="o">`</code> <code class="p">(</code><code class="o">`</code><code class="n">k</code><code class="o">`</code><code class="p">)</code>&#13;
<code class="p">)</code> <code class="n">ENGINE</code><code class="o">=</code><code class="n">InnoDB</code><code class="p">;</code></pre></div>&#13;
&#13;
<p>That’s a standard <a href="https://oreil.ly/XAYX2"><code>sysbench</code> table</a>; I loaded it with one million rows.&#13;
Let’s use a random, meaningless query with a large result set and <code>ORDER BY</code>:</p>&#13;
&#13;
<pre data-type="programlisting">SELECT c FROM sbtest1 WHERE k &lt; 450000 ORDER BY id;&#13;
-- Output omitted&#13;
68439 rows in set (1.15 sec)</pre>&#13;
&#13;
<p>The query takes 1.15 seconds to sort and return a little over 68,000 rows.&#13;
But it’s not a bad query; check out its EXPLAIN plan:</p>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT c FROM sbtest1 WHERE k &lt; 450000 ORDER BY id\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: sbtest1&#13;
   partitions: NULL&#13;
         type: range&#13;
possible_keys: k_1&#13;
          key: k_1&#13;
      key_len: 4&#13;
          ref: NULL&#13;
         rows: 133168&#13;
     filtered: 100.00&#13;
        Extra: Using index condition; Using MRR; Using filesort</pre>&#13;
&#13;
<p>The only new information in that EXPLAIN plan is “Using MRR” in the <code>Extra</code> field, which refers to the <a href="https://oreil.ly/QX1wJ">“Multi-Range Read Optimization”</a>.&#13;
Otherwise, that EXPLAIN plan reports information already covered in this chapter.</p>&#13;
&#13;
<p class="pagebreak-before">Does filesort make this query slow?&#13;
<code>EXPLAIN ANALYZE</code> reveals the answer, albeit cryptically:</p>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN ANALYZE SELECT c FROM sbtest1 WHERE k &lt; 450000 ORDER BY id\G&#13;
&#13;
*************************** 1. row ***************************&#13;
1 -&gt; Sort: sbtest1.id  (cost=83975.47 rows=133168)&#13;
2    (actual time=1221.170..1229.306 rows=68439 loops=1)&#13;
3    -&gt; Index range scan on sbtest1 using k_1, with index condition: (k&lt;450000)&#13;
4       (cost=83975.47 rows=133168) (actual time=40.916..1174.981 rows=68439)</pre>&#13;
&#13;
<p>The real output of <code>EXPLAIN ANALYZE</code> is wider, but I wrapped and numbered the lines for print legibility and reference.&#13;
<code>EXPLAIN ANALYZE</code> output is dense and requires practice to grok; for now, let’s go straight to the point—or as straight as possible since the output does not read sequentially.&#13;
On line 4, <code>1174.981</code> (milliseconds) means the index range scan (line 3) took 1.17 seconds (rounded).&#13;
On line 2, <code>1221.170..1229.306</code> means the filesort (line 1) <em>started</em> after 1,221 milliseconds and ended after 1,229 milliseconds, which means the filesort took 8 milliseconds.&#13;
Total execution time is 1.23 seconds: 95% reading rows and less than 1% sorting rows.&#13;
The remaining 4%—roughly 49 milliseconds—is spent in other stages: preparing, statistics, logging, cleaning up, and so forth.</p>&#13;
&#13;
<p>The answer is no: filesort does <em>not</em> make this query slow.&#13;
The problem is data access: 68,439 rows is not a small result set.&#13;
Sorting 68,439 values is practically zero work for a CPU that does <em>billions</em> of operations per second.&#13;
But reading 68,439 rows is appreciable work for a relational database that must traverse indexes, manage transactions, etc.&#13;
To optimize a query like this, focus on <a data-type="xref" href="ch03.html#data-access">“Data Access”</a>.</p>&#13;
&#13;
<p>One last question to address: why does filesort have a reputation for being slow?&#13;
Because MySQL uses temporary files on disk when sorting data exceeds the <a href="https://oreil.ly/x5mbN"><code>sort_buffer_size</code></a>, and hard drives are orders of magnitude slower than memory.&#13;
This was especially true decades ago when spinning disks were the norm; but today, SSD is the norm, and storage in general is quite fast.&#13;
Filesort might be an issue for a query at high throughput (QPS), but use <code>EXPLAIN ANALYZE</code> to measure and verify.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p><code>EXPLAIN ANALYZE</code> executes the query. To be safe, use <code>EXPLAIN</code> <span class="keep-together"><code>ANALYZE</code></span> on a read-only replica, not the source.</p>&#13;
</div>&#13;
&#13;
<p>Now back to table <code>elem</code> (<a data-type="xref" href="#elem">Example 2-1</a>) and the next case for which MySQL can use an index: covering indexes.<a data-primary="indexes" data-secondary="ORDER BY" data-startref="ORDER_BY_index1" data-type="indexterm" id="idm45829113891504"/><a data-primary="ORDER BY" data-startref="ORDER_BY_index2" data-type="indexterm" id="idm45829113890288"/><a data-primary="EXPLAIN ANALYZE" data-type="indexterm" id="idm45829113889344"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Covering Indexes" data-type="sect2"><div class="sect2" id="idx-covering-index">&#13;
<h2>Covering Indexes</h2>&#13;
&#13;
<p>A <em>covering index</em> <a data-primary="indexes" data-secondary="covering indexes" data-type="indexterm" id="idm45829113886768"/><a data-primary="covering indexes" data-type="indexterm" id="idm45829113885760"/>includes all columns referenced in a query.&#13;
<a data-type="xref" href="#idx-covering">Figure 2-22</a> shows a covering index for a <code>SELECT</code> statement.</p>&#13;
&#13;
<figure><div class="figure" id="idx-covering">&#13;
<img alt="emsp 0222" src="assets/emsp_0222.png"/>&#13;
<h6><span class="label">Figure 2-22. </span>Covering indexes</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>WHERE</code> conditions on columns <code>a</code> and <code>b</code> point to the corresponding index columns as usual, but these index columns also point back to the corresponding columns in the <code>SELECT</code> clause to signify that the values for these columns are read from the index.</p>&#13;
&#13;
<p>Normally, MySQL reads full rows from the primary key (recall <a data-type="xref" href="#tables-are-indexes">“InnoDB Tables Are Indexes”</a>).&#13;
But with a covering index, MySQL can read only column values from the index.&#13;
This is most helpful with secondary indexes because it avoids the primary key lookup.</p>&#13;
&#13;
<p>MySQL uses the covering index optimization automtically, and <code>EXPLAIN</code> reports it as “Using index” in the <code>Extra</code> field.&#13;
“Using index for group-by” is a similar optimization specific to <code>GROUP BY</code> and <code>DISTINCT</code>, as demonstrated in <a data-type="xref" href="#idx-group-by">“GROUP BY”</a>.&#13;
But “Using index condition” and “Using index for skip scan” are completely different and unrelated optimizations.</p>&#13;
&#13;
<p>An index scan (<code>type: index</code>) plus a covering index (<code>Extra: Using index</code>) is an index-only scan (see <a data-type="xref" href="#index-scan">“Index scan”</a>). There are two examples in <a data-type="xref" href="#idx-group-by">“GROUP BY”</a>: <a data-type="xref" href="#ex-idx-group-by-a">Example 2-9</a> and <a data-type="xref" href="#ex-idx-group-by-b">Example 2-12</a>.</p>&#13;
&#13;
<p>Covering indexes are glamorous but rarely practical because realistic queries have too many columns, conditions, and clauses for one index to cover. Do not spend time trying to create covering indexes. When designing or analyzing simple queries that use very few columns, take a moment to see if a covering index might work. If it does, then congratulations. If not, that’s okay; no one expects covering indexes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Join Tables" data-type="sect2"><div class="sect2" id="idx-join-tables">&#13;
<h2>Join Tables</h2>&#13;
&#13;
<p>MySQL uses an index to join tables, <a data-primary="indexes" data-secondary="join tables" data-type="indexterm" id="indexes-join-tables-ch2"/><a data-primary="join tables, indexing for" data-type="indexterm" id="join-tables-indexing-for-ch2"/>and this usage is fundamentally the same as using an index for anything else. The main difference is the source of values used in join conditions for each table.&#13;
This becomes more clear when visualized, but first we need a second table to join.&#13;
<a data-type="xref" href="#elem-names-table">Example 2-18</a> shows the structure of table <code>elem_names</code> and the 14 rows that it contains.</p>&#13;
<div class="pagebreak-before less_space" data-type="example" id="elem-names-table">&#13;
<h5><span class="label">Example 2-18. </span>Table <code>elem_names</code></h5>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="o">`</code><code class="n">elem_names</code><code class="o">`</code> <code class="p">(</code>&#13;
  <code class="o">`</code><code class="n">symbol</code><code class="o">`</code> <code class="nb">char</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>&#13;
  <code class="o">`</code><code class="n">name</code><code class="o">`</code> <code class="nb">varchar</code><code class="p">(</code><code class="mi">16</code><code class="p">)</code> <code class="k">DEFAULT</code> <code class="k">NULL</code><code class="p">,</code>&#13;
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="o">`</code><code class="n">symbol</code><code class="o">`</code><code class="p">)</code>&#13;
<code class="p">)</code> <code class="n">ENGINE</code><code class="o">=</code><code class="n">InnoDB</code><code class="p">;</code>&#13;
&#13;
<code class="o">+</code><code class="c1">--------+-----------+</code>&#13;
<code class="o">|</code> <code class="n">symbol</code> <code class="o">|</code> <code class="n">name</code>      <code class="o">|</code>&#13;
<code class="o">+</code><code class="c1">--------+-----------+</code>&#13;
<code class="o">|</code> <code class="n">Ag</code>     <code class="o">|</code> <code class="n">Silver</code>    <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Al</code>     <code class="o">|</code> <code class="n">Aluminum</code>  <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Ar</code>     <code class="o">|</code> <code class="n">Argon</code>     <code class="o">|</code>&#13;
<code class="o">|</code> <code class="k">At</code>     <code class="o">|</code> <code class="n">Astatine</code>  <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Au</code>     <code class="o">|</code> <code class="n">Gold</code>      <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">B</code>      <code class="o">|</code> <code class="n">Boron</code>     <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Be</code>     <code class="o">|</code> <code class="n">Beryllium</code> <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Bi</code>     <code class="o">|</code> <code class="n">Bismuth</code>   <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Br</code>     <code class="o">|</code> <code class="n">Bromine</code>   <code class="o">|</code>&#13;
<code class="o">|</code> <code class="k">C</code>      <code class="o">|</code> <code class="n">Carbon</code>    <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Cd</code>     <code class="o">|</code> <code class="n">Cadmium</code>   <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Ce</code>     <code class="o">|</code> <code class="n">Cerium</code>    <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Co</code>     <code class="o">|</code> <code class="n">Cobalt</code>    <code class="o">|</code>&#13;
<code class="o">|</code> <code class="n">Cr</code>     <code class="o">|</code> <code class="n">Chromium</code>  <code class="o">|</code>&#13;
<code class="o">+</code><code class="c1">--------+-----------+</code></pre></div>&#13;
&#13;
<p>Table <code>elem_name</code> has one index: the primary key on column <code>symbol</code>.&#13;
The values in column <code>symbol</code> match the values in table <code>elem</code> columns <code>a</code>, <code>b</code>, and <code>c</code>.&#13;
Therefore, we can join tables <code>elem</code> and <code>elem_names</code> on these columns.</p>&#13;
&#13;
<p><a data-type="xref" href="#idx-join-1">Figure 2-23</a> shows a <code>SELECT</code> statement that joins tables <code>elem</code> and <code>elem_names</code>, and a visual representation of the conditions and indexes for each table.</p>&#13;
&#13;
<p>In previous figures, there’s only one index and SQL clause pair because there’s only one table. But <a data-type="xref" href="#idx-join-1">Figure 2-23</a> has two pairs—one for each table—delineated by large rightward-pointing chevrons with the table name commented in each: <code>/* elem */</code> and <span class="keep-together"><code>/* elem_names */</code></span>. Like <code>EXPLAIN</code>, these figures list tables in join order: top to bottom. Table <code>elem</code> (at top) is the first table in the join order and table <code>elem_names</code> (at bottom) is the second table.</p>&#13;
&#13;
<figure><div class="figure" id="idx-join-1">&#13;
<img alt="emsp 0223" src="assets/emsp_0223.png"/>&#13;
<h6><span class="label">Figure 2-23. </span>Join table on primary key lookup</h6>&#13;
</div></figure>&#13;
&#13;
<p>Index usage on table <code>elem</code> is nothing new or special: MySQL uses the index for the condition <code>a IN (</code>…<code>)</code>.&#13;
So far, so good.</p>&#13;
&#13;
<p>Index usage on table <code>elem_names</code>, which is joined to the preceding table, is fundamentally the same with two minor differences. First, the <code>WHERE</code> clause is a rewrite of the <code>JOIN</code>…<code>ON</code> clause—more on this later. Second, values for the condition on column <code>symbol</code> come from the preceding table: <code>elem</code>. To represent this, an arrow points from the preceding table to a column reference in angle brackets: <code>&lt;elem.a&gt;</code>.&#13;
On join, MySQL looks up rows in table <code>elem_names</code> using column <code>a</code> values from matching rows in table <code>elem</code> for the join condition on column <code>symbol</code>.&#13;
In MySQL vernacular we’d say, “<code>symbol</code> is equal to column <code>a</code> from table <code>elem</code>.”&#13;
Given a value from the preceding table, the primary key lookup on column <code>symbol</code> is nothing new or special: if a row matches, it’s returned and joined with the row from the preceding table.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-idx-join-1">Example 2-19</a> shows the EXPLAIN plan for the <code>SELECT</code> statement in <a data-type="xref" href="#idx-join-1">Figure 2-23</a>.</p>&#13;
<div class="pagebreak-before less_space" data-type="example" id="ex-idx-join-1">&#13;
<h5><span class="label">Example 2-19. </span>EXPLAIN plan for join table on primary key lookup</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT name&#13;
        FROM elem JOIN elem_names ON (elem.a = elem_names.symbol)&#13;
        WHERE a IN ('Ag', 'Au', 'At')\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: range&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 3&#13;
          ref: NULL&#13;
         rows: 4&#13;
     filtered: 100.00&#13;
        Extra: Using where; Using index&#13;
*************************** 2. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem_names&#13;
   partitions: NULL&#13;
&gt;        type: eq_ref&#13;
possible_keys: PRIMARY&#13;
          key: PRIMARY&#13;
      key_len: 2&#13;
&gt;         ref: test.elem.a&#13;
         rows: 1&#13;
     filtered: 100.00&#13;
        Extra: NULL</pre></div>&#13;
&#13;
<p>On a per-table basis, the EXPLAIN plan in <a data-type="xref" href="#ex-idx-join-1">Example 2-19</a> is nothing new, but the join reveals two new details in the second table, <code>elem_names</code>.&#13;
The first is access type <code>eq_ref</code>: a single-row lookup using the primary key or a unique not-null secondary index.&#13;
(In this context, <em>not-null</em> means all secondary index columns are defined as <code>NOT NULL</code>.)&#13;
More on the <code>eq_ref</code> access type in the next paragraph.&#13;
The second is <code>ref: test.elem.a</code>, which you can read as “reference column <code>elem.a</code>”.&#13;
(The database name is <code>test</code>, hence the <code>test.</code> prefix.)&#13;
To join table <code>elem_names</code>, values from reference column <code>elem.a</code> are used to look up rows by primary key (<code>key: PRIMARY</code>), which covers the join column: <code>symbol</code>.&#13;
This corresponds to the <code>JOIN</code> condition: <code>ON (elem.a = elem_names.symbol)</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>On a per-table basis, a join does not change how indexes are used.&#13;
The main difference is that values for the join condition come from the preceding table.</p>&#13;
</div>&#13;
&#13;
<p>MySQL can join a table using any access method (see <a data-type="xref" href="#table-access-methods">“Table Access Methods”</a>), but an index lookup using the <code>eq_ref</code> access type is the best and fastest because it matches only one row.&#13;
The <code>eq_ref</code> access type has two requirements: a primary key or unique not-null secondary index <em>and</em> equality conditions on all index columns.&#13;
Together, these requirements guarantee that an <code>eq_ref</code> lookup matches <em>at most</em> one row.&#13;
If both requirements are not met, then MySQL will probably use a <code>ref</code> index lookup, which is essentially the same but matches any number of rows.</p>&#13;
&#13;
<p>Going back to <a data-type="xref" href="#idx-join-1">Figure 2-23</a>, how did I know to rewrite the <code>JOIN</code>…<code>ON</code> clause to a <code>WHERE</code> clause for table <code>elem_names</code>? If you <code>SHOW WARNINGS</code> immediately after <code>EXPLAIN</code>, MySQL prints how it rewrites the query.&#13;
This is the abridged output of <code>SHOW</code> <span class="keep-together"><code>WARNINGS</code></span>:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="cm">/* select#1 */</code> <code class="k">select</code>&#13;
  <code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem_names</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">name</code><code class="o">`</code> <code class="k">AS</code> <code class="o">`</code><code class="n">name</code><code class="o">`</code>&#13;
<code class="k">from</code>&#13;
       <code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem</code><code class="o">`</code>&#13;
  <code class="k">join</code> <code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem_names</code><code class="o">`</code>&#13;
<code class="k">where</code>&#13;
      <code class="p">((</code><code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem_names</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">symbol</code><code class="o">`</code> <code class="o">=</code> <code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">a</code><code class="o">`</code><code class="p">)</code>&#13;
  <code class="k">and</code> <code class="p">(</code><code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">a</code><code class="o">`</code> <code class="k">in</code> <code class="p">(</code><code class="s1">'Ag'</code><code class="p">,</code><code class="s1">'Au'</code><code class="p">,</code><code class="s1">'At'</code><code class="p">)))</code></pre>&#13;
&#13;
<p>Now you can see that <code>/* elem_names */ WHERE symbol = &lt;elem.a&gt;</code> in <a data-type="xref" href="#idx-join-1">Figure 2-23</a> is correct.</p>&#13;
&#13;
<p>Sometimes, running <code>SHOW WARNINGS</code> <a data-primary="SHOW WARNINGS" data-type="indexterm" id="idm45829113213504"/>immediately after <code>EXPLAIN</code> to see how MySQL rewrites a query is necessary to understand the table join order and indexes that MySQL chose.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Rewritten SQL statements shown by <code>SHOW WARNINGS</code> are not intended to be valid. They’re only intended to show how MySQL interprets and rewrites the SQL statement. Do not execute them.</p>&#13;
</div>&#13;
&#13;
<p>Table join order is critical because MySQL joins tables in the best order possible, <em>not</em> the order tables are written in the query. You must use <code>EXPLAIN</code> to see the table join order. <code>EXPLAIN</code> prints tables in the join order from top (first table) to bottom (last table). The default join algorithm, <em>nested-loop join</em>, follows the join order. I outline join algorithms at the end of this chapter: <a data-type="xref" href="#table-join-algos">“Table Join Algorithms”</a>.</p>&#13;
&#13;
<p>Never guess or presume the table join order because small changes to a query can yield a significantly different table join order or query execution plan.&#13;
To demonstrate, the <code>SELECT</code> statement in <a data-type="xref" href="#idx-join-2">Figure 2-24</a> is nearly identically to the <code>SELECT</code> statement in <a data-type="xref" href="#idx-join-1">Figure 2-23</a> with one tiny difference—can you spot it?</p>&#13;
&#13;
<figure><div class="figure" id="idx-join-2">&#13;
<img alt="emsp 0224" src="assets/emsp_0224.png"/>&#13;
<h6><span class="label">Figure 2-24. </span>Join table on secondary index lookup</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here’s a hint: <em>it’s neither gold nor silver</em>.&#13;
The tiny difference yields a significantly different query execution plan, as shown in <a data-type="xref" href="#ex-idx-join-2">Example 2-20</a>.</p>&#13;
<div data-type="example" id="ex-idx-join-2">&#13;
<h5><span class="label">Example 2-20. </span>EXPLAIN plan for join table on secondary index lookup</h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT name&#13;
        FROM elem JOIN elem_names ON (elem.a = elem_names.symbol)&#13;
        WHERE a IN ('Ag', 'Au')\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem_names&#13;
   partitions: NULL&#13;
         type: range&#13;
possible_keys: PRIMARY&#13;
          key: PRIMARY&#13;
      key_len: 2&#13;
          ref: NULL&#13;
         rows: 2&#13;
     filtered: 100.00&#13;
        Extra: Using where&#13;
*************************** 2. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: ref&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 3&#13;
          ref: test.elem_names.symbol&#13;
         rows: 2&#13;
     filtered: 100.00&#13;
        Extra: Using index</pre></div>&#13;
&#13;
<p>Syntactically, the <code>SELECT</code> statements in Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#idx-join-1">2-23</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#idx-join-2">2-24</a> are identical, but the execution plans (Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#ex-idx-join-1">2-19</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#ex-idx-join-2">2-20</a>) are significantly different. What changed? In <a data-type="xref" href="#idx-join-2">Figure 2-24</a>, a single value was removed from the <code>IN()</code> list: “At.” This is a great example of how a seemingly innocuous change can trigger something in the MySQL query execution planner and voilà: a totally new and different EXPLAIN plan. Let’s examine <a data-type="xref" href="#ex-idx-join-2">Example 2-20</a> table by table.</p>&#13;
&#13;
<p>The first table is <code>elem_names</code>, which is different than how the query is written: <code>elem JOIN elem_names</code>. MySQL determines the table join order, not the <code>JOIN</code> clause.<sup><a data-type="noteref" href="ch02.html#idm45829113186976" id="idm45829113186976-marker">2</a></sup> The <code>type</code> and <code>key</code> fields indicate a range scan on the primary key, but where are the values coming from? The <code>ref</code> field is <code>NULL</code>, and there are no <code>WHERE</code> conditions on this table. MySQL must have rewritten the query; this is the abridged output of <code>SHOW WARNINGS</code>:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="cm">/* select#1 */</code> <code class="k">select</code>&#13;
  <code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem_names</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">name</code><code class="o">`</code> <code class="k">AS</code> <code class="o">`</code><code class="n">name</code><code class="o">`</code>&#13;
<code class="k">from</code>&#13;
  <code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem</code><code class="o">`</code> <code class="k">join</code> <code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem_names</code><code class="o">`</code>&#13;
<code class="k">where</code>&#13;
      <code class="p">((</code><code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">a</code><code class="o">`</code> <code class="o">=</code> <code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem_names</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">symbol</code><code class="o">`</code><code class="p">)</code>&#13;
  <code class="k">and</code> <code class="p">(</code><code class="o">`</code><code class="n">test</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">elem_names</code><code class="o">`</code><code class="p">.</code><code class="o">`</code><code class="n">symbol</code><code class="o">`</code> <code class="k">in</code> <code class="p">(</code><code class="s1">'Ag'</code><code class="p">,</code><code class="s1">'Au'</code><code class="p">)))</code></pre>&#13;
&#13;
<p>Yes, there it is on the last line: MySQL rewrites the query to use the <code>IN()</code> list as the values for <code>elem_names.symbol</code>s instead of <code>elem.a</code> as originally written in the query.&#13;
Now you can see (or imagine) that index usage on table <code>elem_names.symbol</code>s is a range scan to look up two values: “Ag” and “Au.”&#13;
Using the primary key, that will be an extremely fast index lookup and match only two rows that MySQL will use to join the second table.</p>&#13;
&#13;
<p>The second table is <code>elem</code>, and the EXPLAIN plan is familiar: using index <code>idx_a_b</code> to look up index values (not rows, because <code>Extra: Using index</code>) matching the condition on column <code>a</code>. The values for that condition come from matching rows in the preceding table, as indicated by <code>ref: test.elem_names.symbol</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>MySQL joins tables in the best order possible, <em>not</em> the order that tables are written in the query.</p>&#13;
</div>&#13;
&#13;
<p>Although MySQL can change the join order and rewrite the query, index usage for a join is fundamentally the same—on a per-table basis—as everything previously demonstrated and explained in this chapter. Use <code>EXPLAIN</code> and <code>SHOW WARNINGS</code>, and consider the execution plan table by table, from top to bottom.</p>&#13;
&#13;
<p>MySQL can join tables without an index. This is called a <em>full join</em> <a data-primary="full join" data-type="indexterm" id="full-join"/>and it’s the single worst thing a query can do. A table scan on a single-table query is bad, but a full join is worse because the table scan on the joined table does not happen once, it happens for every matching row from the preceding table. <a data-type="xref" href="#ex-idx-join-full">Example 2-21</a> shows a full join on the second table.</p>&#13;
<div data-type="example" id="ex-idx-join-full">&#13;
<h5><span class="label">Example 2-21. </span>EXPLAIN plan for full <code>JOIN</code></h5>&#13;
&#13;
<pre data-type="programlisting">EXPLAIN SELECT name&#13;
        FROM elem STRAIGHT_JOIN elem_names IGNORE INDEX (PRIMARY)&#13;
          ON (elem.a = elem_names.symbol)\G&#13;
&#13;
*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem&#13;
   partitions: NULL&#13;
         type: index&#13;
possible_keys: idx_a_b&#13;
          key: idx_a_b&#13;
      key_len: 6&#13;
          ref: NULL&#13;
         rows: 10&#13;
     filtered: 100.00&#13;
        Extra: Using index&#13;
*************************** 2. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: elem_names&#13;
   partitions: NULL&#13;
         type: ALL&#13;
possible_keys: NULL&#13;
          key: NULL&#13;
      key_len: NULL&#13;
          ref: NULL&#13;
         rows: 14&#13;
     filtered: 7.14&#13;
        Extra: Using where; Using join buffer (hash join)</pre></div>&#13;
&#13;
<p>Normally, MySQL would not choose this query execution plan, which is why I had to force it with <code>STRAIGHT_JOIN</code> and <code>IGNORE INDEX (PRIMARY)</code>.&#13;
An index-only scan on the first table (<code>elem</code>) yields all ten rows.<sup><a data-type="noteref" href="ch02.html#idm45829113052112" id="idm45829113052112-marker">3</a></sup>&#13;
For each row, MySQL joins the second table (<code>elem_names</code>) by doing a full table scan (<code>type: ALL</code>) to find matching rows.&#13;
Since this is a joined table (not the first table in the join order), the table scan counts as a full join.&#13;
A full join is the single worst thing a query can do because it happens <em>for each row</em> from the preceding table: ten full table scans on table <code>elem_names</code>.&#13;
Whenever you see <code>type: ALL</code> for a joined table, stop everything you’re doing and fix it.&#13;
There’s a query metric for full joins: <a data-type="xref" href="ch01.html#Select-full-join">“Select full join”</a>.</p>&#13;
&#13;
<p>“Using join buffer (hash join)” in the <code>Extra</code> field refers to the hash join algorithm, which is new as of MySQL 8.0.18.&#13;
I outline it (and other join algorithms) at the end of this chapter: <a data-type="xref" href="#table-join-algos">“Table Join Algorithms”</a>.&#13;
Looking ahead, the one-line explanation is: hash join builds an in-memory hash table of values and uses that to lookup rows rather than doing repeated table scans.&#13;
Hash join is a huge performance improvement.&#13;
Regardless, avoiding full joins remains the best practice.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Prior to MySQL 8.0, the query in <a data-type="xref" href="#ex-idx-join-full">Example 2-21</a> reports “Using join buffer (Block Nested Loop)” in the <code>Extra</code> field because it uses a different join algorithm: block nested-loop.&#13;
<a data-type="xref" href="#table-join-algos">“Table Join Algorithms”</a> outlines this join algorithm.</p>&#13;
</div>&#13;
&#13;
<p>At first glance, joining tables appears to be a categorically different type of index usage, but it’s not.&#13;
A join involves more tables and indexes, but on a per-table basis, index usage and requirements are the same.&#13;
Even the leftmost prefix requirement is the same.&#13;
The main difference is that, for joined tables, values for join conditions come from the preceding table.</p>&#13;
&#13;
<p>It’s been a long read since the first example in <a data-type="xref" href="#idx-where">“WHERE”</a>.&#13;
Now you’ve seen many full-context examples of indexes, queries, and EXPLAIN plans that cover the technical details and mechanics of MySQL indexes.&#13;
This information is the foundation of direct query optimization on which the next section builds.<a data-primary="indexes" data-secondary="join tables" data-startref="indexes-join-tables-ch2" data-type="indexterm" id="idm45829113039488"/><a data-primary="join tables, indexing for" data-startref="join-tables-indexing-for-ch2" data-type="indexterm" id="idm45829113038272"/><a data-primary="full join" data-startref="full-join" data-type="indexterm" id="idm45829113037248"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Indexing: How to Think Like MySQL" data-type="sect1"><div class="sect1" id="think-like-mysql">&#13;
<h1>Indexing: How to Think Like MySQL</h1>&#13;
&#13;
<p>Indexes <a data-primary="indexing" data-type="indexterm" id="idm45829113034656"/>and indexing are different topics.&#13;
The previous section introduced indexes: standard B-tree indexes on InnoDB tables for <code>WHERE</code>, <code>GROUP BY</code>, <code>ORDER BY</code>, covering indexes, and table joins.&#13;
This section introduces <em>indexing</em>: applying indexes for maximum leverage.&#13;
You cannot simply index every column to effect amazing performance.&#13;
If it were that easy, there would be no DBAs.&#13;
For maximum leverage, you have to index the columns that allow MySQL to access the least number of rows when executing a query.&#13;
To state it metaphorically: maximum leverage is an index that tells MySQL exactly where to find the needle in the haystack.</p>&#13;
&#13;
<p>In my experience, engineers struggle with indexing because they conflate how they think about a query with how MySQL “thinks” about a query.&#13;
As engineers, we think about a query in the context of the application: what part of the application executes the query, why (the business logic), and the correct result set.&#13;
But MySQL does not know or care about any of that.&#13;
MySQL thinks about a much smaller, simpler context: indexes and table conditions.&#13;
Under the hood, MySQL is considerably more complex, but part of its indeterminable charm is how well it hides that complexity.</p>&#13;
&#13;
<p>How do we know that MySQL thinks about indexes and table conditions?&#13;
<code>EXPLAIN</code>.&#13;
And what is the primary information that <code>EXPLAIN</code> reports?&#13;
Tables (in join order), table access methods, indexes, and <code>Extra</code> information related to the access of those tables with those indexes.</p>&#13;
&#13;
<p>Thinking like MySQL make indexing easier because it’s a deterministic machine—algorithms and heuristics.&#13;
Human thought is entangled with superfluous details.&#13;
Clear your mind and get ready to think like a machine.&#13;
The next four sections walk through a simple, four-step process.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Know the Query" data-type="sect2"><div class="sect2" id="know-the-query">&#13;
<h2>Know the Query</h2>&#13;
&#13;
<p>The first step <a data-primary="indexing" data-secondary="know the query" data-type="indexterm" id="indexing-know-the-query-ch2"/><a data-primary="query" data-secondary="indexing" data-type="indexterm" id="query-indexing-ch2"/>toward thinking like MySQL is to know basic information about the query that you’re optimizing.&#13;
Start by gathering the following metadata for each table:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>SHOW CREATE TABLE</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>SHOW TABLE STATUS</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>SHOW INDEXES</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If the query is already running in production, then get its query report (see <a data-type="xref" href="ch01.html#query-report">“Query report”</a>) and familiarize yourself with the current values.</p>&#13;
&#13;
<p>Then answer the following questions:</p>&#13;
<dl class="pagebreak-before less_space">&#13;
<dt>Query</dt>&#13;
<dd>&#13;
<ul>&#13;
  <li>How many rows should the query access?</li>&#13;
  <li>How many rows should the query return?</li>&#13;
  <li>Which columns are selected (returned)?</li>&#13;
  <li>What are the <code>GROUP BY</code>, <code>ORDER BY,</code> and <code>LIMIT</code> clauses (if any)?</li>&#13;
  <li>Are there subqueries? (If yes, repeat the process for each.)</li>&#13;
</ul>&#13;
</dd>&#13;
&#13;
<dt>Table access (per-table)</dt>&#13;
<dd>&#13;
<ul>&#13;
  <li>What are the table conditions?</li>&#13;
  <li>Which index should the query use?</li>&#13;
  <li>What other indexes could the query use?</li>&#13;
  <li>What is the cardinality of each index?</li>&#13;
  <li>How large is the table—data size and row count?</li>&#13;
</ul>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Those <a data-primary="table access" data-type="indexterm" id="idm45829113008160"/>questions help you mentally parse the query because that’s what MySQL does: parse the query.&#13;
This is especially helpful for seeing complex queries in simpler terms: tables, table conditions, indexes, and SQL clauses.</p>&#13;
&#13;
<p>This information helps you piece together a puzzle that, once complete, reveals query response time.&#13;
To improve response time, you’ll need to change some pieces.&#13;
But before doing that, the next step is to assemble the current pieces with the help of <code>EXPLAIN</code>.<a data-primary="indexing" data-secondary="know the query" data-startref="indexing-know-the-query-ch2" data-type="indexterm" id="idm45829113005984"/><a data-primary="query" data-secondary="indexing" data-startref="query-indexing-ch2" data-type="indexterm" id="idm45829113004688"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understand with EXPLAIN" data-type="sect2"><div class="sect2" id="idm45829113003344">&#13;
<h2>Understand with EXPLAIN</h2>&#13;
&#13;
<p>The second step is to understand <a data-primary="indexing" data-secondary="understanding with EXPLAIN" data-type="indexterm" id="indexing-understanding-with-EXPLAIN-ch2"/><a data-primary="EXPLAIN" data-type="indexterm" id="EXPLAIN-ch2"/>the current query execution plan reported by <code>EXPLAIN</code>.&#13;
Consider each table and its conditions with respect to its indexes, starting with the index that MySQL chose: the <code>key</code> field in the <code>EXPLAIN</code> output.&#13;
Look at the table conditions to see how they meet the leftmost prefix requirement for this index.&#13;
If the <code>possible_keys</code> field lists other indexes, think about how MySQL would access rows using those indexes—always with the leftmost prefix requirement in mind.&#13;
If the <code>Extra</code> field has information (it usually does), then refer to <a href="https://oreil.ly/GDF0g">“EXPLAIN Output”</a> in the MySQL manual to learn what it means.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Always <code>EXPLAIN</code> the query.&#13;
Make this a habit because direct query optimization is not possible without <code>EXPLAIN</code>.</p>&#13;
</div>&#13;
&#13;
<p>The query and its response time are a puzzle, but you have all the pieces: execution plan, table conditions, table structures, table sizes, index cardinalities, and query metrics.&#13;
Keep connecting the pieces until the puzzle is complete—until you can see the query working as MySQL explains it.&#13;
There is always a reason for the query execution plan.<sup><a data-type="noteref" href="ch02.html#idm45829112993152" id="idm45829112993152-marker">4</a></sup>&#13;
Sometimes MySQL is very clever and uses a nonobvious query optimization, usually mentioned in the <code>Extra</code> field.&#13;
If you encounter one for a <code>SELECT</code> statement, <a href="https://oreil.ly/Bl4Ja">“Optimizing SELECT Statements”</a> in the MySQL manual will elucidate it.</p>&#13;
&#13;
<p>If you get stuck, there are three increasing levels of support:</p>&#13;
<ol>&#13;
<li>&#13;
<p>As of MySQL 8.0.16, <code>EXPLAIN FORMAT=TREE</code> prints a more precise and descriptive query execution plan in tree-like output.&#13;
It’s a completely different output than the traditional format, so you’ll need to learn how to interpret it, but it’s worth the effort.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use <a href="https://oreil.ly/Ump3C">optimizer tracing</a> to report an extremely detailed query execution plan with costs, considerations, and reasons.&#13;
This is a very advanced feature with a high learning curve, so if you’re pressed for time, you might prefer the third option.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ask your DBA or hire an expert.<a data-primary="indexing" data-secondary="understanding with EXPLAIN" data-startref="indexing-understanding-with-EXPLAIN-ch2" data-type="indexterm" id="idm45829112985776"/><a data-primary="EXPLAIN" data-startref="EXPLAIN-ch2" data-type="indexterm" id="idm45829112984448"/></p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimize the Query" data-type="sect2"><div class="sect2" id="idm45829112983120">&#13;
<h2>Optimize the Query</h2>&#13;
&#13;
<p>The third step is direct query optimization: <a data-primary="indexing" data-secondary="direct query optimization" data-type="indexterm" id="direct-query-optimization2_index1"/><a data-primary="direct query optimization" data-type="indexterm" id="direct-query-optimization2_index2"/>change the query, its indexes, or both.&#13;
This is where all the fun happens, and there’s no risk yet because these changes are made in development or staging, <em>not</em> production.&#13;
Be certain that your development or staging environment has data that is representative of production because data size and distribution affect how MySQL chooses indexes.</p>&#13;
&#13;
<p>At first, it might seem like the query cannot be modified because it fetches the correct rows, so the query is written correctly.&#13;
A query “is what it is,” right?&#13;
Not always; the same <em>result</em> can be achieved with different <em>methods</em>. A query has a result—literally, a result set—and a method of obtaining that result.&#13;
These two are closely related but independent.&#13;
Knowing that is tremendously helpful when considering how to modify a query.&#13;
Start by clarifying the intended result of the query.&#13;
A clear result allows you to explore new ways of writing the query that achieve the same result.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>There can be multiple ways to write a query that execute differently but return the same result.</p>&#13;
</div>&#13;
&#13;
<p>For example, some time ago I was helping an engineer optimize a slow query.&#13;
His question to me was technical—something about <code>GROUP BY</code> and indexes—but I asked him, “What does the query <em>do</em>? What’s it supposed to return?”&#13;
He said, “Oh! It returns the maximum value for a group.”&#13;
After clarifying the intended result of the query, I realized that he didn’t need the maximum group value, he simply needed the maximum value.&#13;
Consequently, the query was completely rewritten to use the <code>ORDER BY col DESC LIMIT 1</code> optimization.</p>&#13;
&#13;
<p>When a query is extremely simple, like <code>SELECT col FROM tbl WHERE id = 1</code>, there might truly be no way to rewrite it.&#13;
But the simpler the query, the less likely it needs to be rewritten.&#13;
If a simple query is slow, the solution is likely a change to indexes rather than the query.&#13;
(And if index changes don’t solve the problem, then the journey continues: <em>indirect</em> query optimization, addressed in  Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03">3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04">4</a>.)</p>&#13;
&#13;
<p>Adding or modifying a index is a trade-off between access methods and query-specific optimizations.&#13;
For example, do you trade an <code>ORDER BY</code> optimization for a range scan?&#13;
Don’t get stuck trying to weigh the trade-offs; MySQL does that for you.<sup><a data-type="noteref" href="ch02.html#idm45829112967856" id="idm45829112967856-marker">5</a></sup>&#13;
Your job is simple: add or alter an index that you think will provide MySQL greater leverage, then use <code>EXPLAIN</code> to see if MySQL agrees by using the new index.&#13;
Repeat until you and MySQL agree on the most optimized way to write, index, and execute the query.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Do not modify indexes in production until you have thoroughly verified the changes in staging.<a data-primary="indexing" data-secondary="direct query optimization" data-startref="direct-query-optimization2_index1" data-type="indexterm" id="idm45829112965168"/><a data-primary="direct query optimization" data-startref="direct-query-optimization2_index2" data-type="indexterm" id="idm45829112963840"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploy and Verify" data-type="sect2"><div class="sect2" id="idm45829112962608">&#13;
<h2>Deploy and Verify</h2>&#13;
&#13;
<p>The last step is to deploy <a data-primary="indexing" data-secondary="deploying and verifying changes" data-type="indexterm" id="deploying-and-verifying-changes"/>the changes and verify that they improve response time.&#13;
But first: know how to roll back the deployment—and be ready to do so—in case the changes have unintended side effects.&#13;
This happens for many reasons; two examples are: queries running in production that use the index but were not running in staging, or production data that is significantly different than staging data.&#13;
It’s most likely going to be fine, but be prepared for <em>not fine</em>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Always know how to—and be ready to—roll back a deployment to production.</p>&#13;
</div>&#13;
&#13;
<p>After deploying, verify the changes with query metrics and MySQL server metrics.&#13;
If the query optimization has significant impact, MySQL server metrics will reflect it.&#13;
(<a data-type="xref" href="ch06.html#ch06">Chapter 6</a> elaborates on MySQL server metrics.)&#13;
It’s awesome when this happens, but don’t be surprised or discouraged if it doesn’t because the most important change is query response time—recall <a data-type="xref" href="ch01.html#north-star">“North Star”</a>.</p>&#13;
&#13;
<p>Wait five to ten minutes (preferably longer), then check response time in the query profile and query report.&#13;
(See <a data-type="xref" href="ch01.html#query-profile">“Query profile”</a> and <a data-type="xref" href="ch01.html#query-report">“Query report”</a>.)&#13;
If response time improved, then congratulations: you are doing and accomplishing what MySQL experts do; with this skill, you can achieve remarkable MySQL performance.&#13;
If response time did not improve, don’t worry and don’t give up: even MySQL experts encounter queries that require elbow grease.&#13;
Repeat the process, and consider enlisting another engineer because some queries require heavy lifting.&#13;
If you’re certain the query cannot be further optimized, then it’s time for the second part of the journey: indirect query optimization.&#13;
<a data-type="xref" href="ch03.html#ch03">Chapter 3</a> addresses changes to data, and <a data-type="xref" href="ch04.html#ch04">Chapter 4</a> addresses changes to the application.<a data-primary="indexing" data-secondary="deploying and verifying changes" data-startref="deploying-and-verifying-changes" data-type="indexterm" id="idm45829112950800"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="It Was a Good Index Until…" data-type="sect1"><div class="sect1" id="idm45829113867792">&#13;
<h1>It Was a Good Index Until…</h1>&#13;
&#13;
<p>If <em>nothing</em> changes, <a data-primary="indexes" data-secondary="reasons for decreased performance" data-type="indexterm" id="reasons-for-decreased-performance"/>a good index will stay a good index until the end of time. (But if truly nothing changes, would time ever end?) Realistically, something will change, render a good index bad, and decrease performance. Following are common causes of this regrettable (but avoidable and correctable) decline.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Queries Changed" data-type="sect2"><div class="sect2" id="idx-queries-changed">&#13;
<h2>Queries Changed</h2>&#13;
&#13;
<p>When queries change—and they often do—the leftmost prefix requirement can be lost. The worst case is when there are no other indexes that MySQL can use, so it reverts to brute force: a full table scan. But tables often have many indexes, and MySQL is determined to use an index, so the more likely case is that query response time becomes noticeably poor because the other indexes aren’t as good as the original index. A query analysis and EXPLAIN plan quickly reveal this case. Presuming the query changes were necessary, which is a safe presumption, the solution is to re-index for the new variation of the query.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Excessive, Duplicate, and Unused" data-type="sect2"><div class="sect2" id="idx-too-many">&#13;
<h2>Excessive, Duplicate, and Unused</h2>&#13;
&#13;
<p>Indexes are necessary for performance, but sometimes engineers go overboard with them, which results in too many indexes, duplicate indexes (<em>dupes</em>), and unused indexes.</p>&#13;
&#13;
<p>How many indexes is too many?&#13;
One more than is necessary.&#13;
An overabundance of indexes creates two problems.&#13;
The first was mentioned in <a data-type="xref" href="#LPR">“Leftmost Prefix Requirement”</a>: increased index size.&#13;
More indexes use more RAM which, <span class="keep-together">ironically</span>, decreases the RAM available for each index.&#13;
The second problem is a decrease in write performance because, when MySQL writes data, it must check, update, and potentially reorganize (the internal B-tree structure of) every index.&#13;
An inordinate number of indexes can severely degrade write performance.</p>&#13;
&#13;
<p>When you create a duplicate index, <a data-primary="duplicate indexes" data-type="indexterm" id="idm45829112937840"/>the <code>ALTER</code> statement used to create it generates a warning, but you have to <code>SHOW WARNINGS</code> to see it.&#13;
To find existing duplicate indexes, use <a href="https://oreil.ly/avm4L">pt-duplicate-key-checker</a>: it safely finds and reports duplicate indexes.</p>&#13;
&#13;
<p>Unused indexes <a data-primary="unused indexes" data-type="indexterm" id="idm45829112934912"/>are even trickier to identify because, for example, what if the index is only used once a week by a long-running analytics query?&#13;
That edge case aside, execute this query to list unused indexes:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">sys</code><code class="p">.</code><code class="n">schema_unused_indexes</code>&#13;
<code class="k">WHERE</code> <code class="n">object_schema</code> <code class="k">NOT</code> <code class="k">IN</code> <code class="p">(</code><code class="s1">'performance_schema'</code><code class="p">);</code></pre>&#13;
&#13;
<p>That query uses the <a href="https://oreil.ly/xxsL3">MySQL sys Schema</a>, <a data-primary="sys Schema" data-type="indexterm" id="idm45829112923168"/>which is a collection of ready-made views that return all sorts of information.&#13;
The view <code>sys.schema_unused_indexes</code> queries Performance Schema and Information Schema tables to determine which indexes have not been used since MySQL started.&#13;
(Execute <code>SHOW CREATE VIEW sys.schema_unused_indexes</code> to see how this view works.)&#13;
The Performance Schema must be enabled; if it is not already enabled, talk with your DBA (or whoever manages MySQL) because enabling it requires restarting MySQL.</p>&#13;
&#13;
<p>Be careful when dropping an index.&#13;
As of MySQL 8.0, use <a href="https://oreil.ly/Wx1xT">invisible indexes</a> to verify that an index is not used or needed before dropping it: make the index invisible, wait and verify that performance is not affected, then drop the index.&#13;
Invisible indexes are fantastic for this purpose because, when a mistake is made, making an index visible is nearly instantaneous, whereas re-adding an index can take minutes (or hours) on large tables, which feels like an eternity if the mistake causes an application outage.&#13;
Before MySQL 8.0, caution is the only solution: talk with your team, search the application code, and use your knowledge of the application to carefully and thoroughly verify that the index is not used or needed.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Be careful when dropping (removing) indexes.&#13;
If a dropped index was used by a query and MySQL cannot use another index, the query will revert to a full table scan.&#13;
If a dropped index affects several queries, which is not uncommon, it can cause a ripple effect of performance degradation that leads to an application outage.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Extreme Selectivity" data-type="sect2"><div class="sect2" id="extreme-selectivity">&#13;
<h2>Extreme Selectivity</h2>&#13;
&#13;
<p><em>Cardinality</em> <a data-primary="extreme selectivity" data-type="indexterm" id="extreme-selectivity_index1"/><a data-primary="cardinality" data-type="indexterm" id="cardinality"/>is the number of unique values in an index. An index on values <code>a, a, b, b</code> has a cardinality of 2: <code>a</code> and <code>b</code> are the two unique values. Use <a href="https://oreil.ly/8hiGi"><code>SHOW INDEX</code></a> to see index cardinality.</p>&#13;
&#13;
<p><em>Selectivity</em> is <a data-primary="selectivity" data-type="indexterm" id="idm45829112883920"/>cardinality divided by the number of rows in the table. Using the same example, <code>a, a, b, b</code>, where each value is one row, the index selectivity is 2 / 4 = 0.5. Selectivity ranges from 0 to 1, where 1 is a unique index: a value for every row. MySQL doesn’t show index selectivity; you have to calculate it manually using <code>SHOW INDEX</code> for cardinality and <code>SHOW TABLE STATUS</code> for the number of rows.</p>&#13;
&#13;
<p>An index with extremely low selectivity provides little leverage because each unique value could match a large number of rows. A classic example is an index on a column with only two possible values: yes or no, true or false, coffee or tea, on so on. If the table has 100,000 rows, then selectivity is practically zero: 2 / 100,000 = 0.00002. It’s an index, but not a good one because each value could match many rows. How many? Flip the division: 100,000 rows / 2 unique values = 50,000 rows per value. If MySQL were to use this index (which is unlikely), a single index lookup could match 50,000 rows. That presumes values are evenly distributed, but what if 99,999 rows have value <code>coffee</code> and only 1 row has value <code>tea</code>? Then the index works great for tea but terribly for coffee.</p>&#13;
&#13;
<p>If a query uses an index with extremely low selectivity, see if you can create a better, more selective index; or, consider rewriting the query to use a more selective index; or, think about altering the schema to organize the data better with respect to access patterns—more on this in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>.</p>&#13;
&#13;
<p>An index with extremely high selectivity might be over-leveraged. As the selectivity of a nonunique secondary index approaches 1, it begins to raise the question of whether or not the index should be unique or—even better—if the query can be rewritten to use the primary key. Such an index doesn’t hurt performance, but it’s worth exploring alternatives.</p>&#13;
&#13;
<p>If there are many secondary indexes with extremely high selectivity, it likely indicates access patterns that view or search the whole table by different criteria or dimensions (presuming the indexes are used and not duplicates).&#13;
For example: imagine a table with product inventory that the application searches by many different criteria, each requiring an index to meet the leftmost prefix requirement.&#13;
In this case, <a href="https://www.elastic.co">Elasticsearch</a> might serve the access patterns better than MySQL.<a data-primary="cardinality" data-startref="cardinality" data-type="indexterm" id="idm45829112875680"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="It’s a Trap! (When MySQL Chooses Another Index)" data-type="sect2"><div class="sect2" id="its-a-trap">&#13;
<h2>It’s a Trap! (When MySQL Chooses Another Index)</h2>&#13;
&#13;
<p>In very rare cases, MySQL chooses the wrong index. This is rare enough that it should be your last suspicion if MySQL is using an index but query response time is inexplicably slow. There are several reasons this can occur. A common reason is that, when updating a large number of rows, the number is just shy of triggering an automatic update of the index “stats.” Since index statistics<a data-primary="index statistics" data-type="indexterm" id="idm45829112872384"/> are one of many factors that influence which index MySQL chooses, index statistics that have diverged significantly from reality can cause MySQL to choose the wrong index. To be clear: the index itself is never inaccurate; it’s only the index <em>statistics</em> that are inaccurate.</p>&#13;
&#13;
<p>Index statistics are estimates about how values are distributed in the index. MySQL does random dives into the index to sample pages. (A <em>page</em> is a 16 KB unit of logical storage. Almost everything is stored in pages.) If index values are evenly distributed, then a few random dives accurately represent the whole index.</p>&#13;
&#13;
<p>MySQL updates index statistics for a table when:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The table is first opened</p>&#13;
</li>&#13;
<li>&#13;
<p><code>ANALYZE TABLE</code> is run</p>&#13;
</li>&#13;
<li>&#13;
<p>1/16th of the table has been modified since the last update</p>&#13;
</li>&#13;
<li>&#13;
<p><code>innodb_stats_on_metadata</code> is enabled and one of the following occurs:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>SHOW INDEX</code> or <code>SHOW TABLE STATUS</code> is run</p>&#13;
</li>&#13;
<li>&#13;
<p><code>INFORMATION_SCHEMA.TABLES</code> or <code>INFORMATION_SCHEMA.STATISTICS</code> is queried</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Running <code>ANALYZE TABLE</code> is safe and usually very fast, but be careful on a busy server: it requires a flush lock (except in Percona Server) that can block all queries accessing the table.<a data-primary="indexes" data-secondary="reasons for decreased performance" data-startref="reasons-for-decreased-performance" data-type="indexterm" id="idm45829112859840"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Table Join Algorithms" data-type="sect1"><div class="sect1" id="table-join-algos">&#13;
<h1>Table Join Algorithms</h1>&#13;
&#13;
<p>A brief overview of MySQL table join algorithms <a data-primary="join algorithms" data-type="indexterm" id="join-algorithms-ch2"/><a data-primary="indexes" data-secondary="table join algorithms" data-type="indexterm" id="table-join-algorithms_index1"/><a data-primary="table join algorithms" data-type="indexterm" id="table-join-algorithms_index2"/>helps you think about indexes and indexing when analyzing and optimizing <code>JOIN</code>.&#13;
The default table join algorithm is called <em>nested-loop join</em> (NLJ), <a data-primary="nested-loop join" data-type="indexterm" id="idm45829112852128"/>and it operates like nested <code>foreach</code> loops in code.&#13;
For example, suppose that a query joins three tables with a <code>JOIN</code> clause like:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">FROM</code>&#13;
  <code class="n">t1</code> <code class="k">JOIN</code> <code class="n">t2</code> <code class="k">ON</code> <code class="n">t1</code><code class="p">.</code><code class="n">A</code> <code class="o">=</code> <code class="n">t2</code><code class="p">.</code><code class="n">B</code>&#13;
     <code class="k">JOIN</code> <code class="n">t3</code> <code class="k">ON</code> <code class="n">t2</code><code class="p">.</code><code class="n">B</code> <code class="o">=</code> <code class="n">t3</code><code class="p">.</code><code class="k">C</code></pre>&#13;
&#13;
<p>And suppose that <code>EXPLAIN</code> reports the join order as <code>t1</code>, <code>t2</code>, and <code>t3</code>.&#13;
The nested-loop join algorithm works like the pseudocode in <a data-type="xref" href="#NLJ">Example 2-22</a>.</p>&#13;
<div data-type="example" id="NLJ">&#13;
<h5><span class="label">Example 2-22. </span>NLJ algorithm</h5>&#13;
&#13;
<pre data-type="programlisting">func find_rows(table, index, conditions) []rows {&#13;
    // Return array of rows in table matching conditions,&#13;
    // using index for lookup or table scan if NULL&#13;
}&#13;
&#13;
foreach find_rows(t1, some_index, "WHERE ...") {&#13;
    foreach find_rows(t2, index_on_B, "WHERE B = &lt;t1.A&gt;") {&#13;
        return find_rows(t3, NULL, "WHERE C = &lt;t2.B&gt;")&#13;
    }&#13;
}</pre></div>&#13;
&#13;
<p>Using the NLJ algorithm, MySQL begins by using <code>some_index</code> to find matching rows in the outermost table: <code>t1</code>.&#13;
For each matching row in table <code>t1</code>, MySQL joins table <code>t2</code> by using an index on the join column, <code>index_on_B</code>, to lookup rows matching <code>t1.A</code>.&#13;
For each matching row in table <code>t2</code>, MySQL joins table <code>t3</code> using the same process, but—just for fun—let’s say there’s no index on the join column, <code>t3.C</code>: the result is a full join.&#13;
(Recall <a data-type="xref" href="ch01.html#Select-full-join">“Select full join”</a> and <a data-type="xref" href="#ex-idx-join-full">Example 2-21</a>.)</p>&#13;
&#13;
<p>When no more rows in <code>t3</code> match the join column value from table <code>t2</code>, the next matching row from <code>t2</code> is used.&#13;
When no more rows in <code>t2</code> match the join column value from table <code>t1</code>, the next matching row from <code>t1</code> is used.&#13;
When no more rows in <code>t1</code> match, the query completes.</p>&#13;
&#13;
<p>The nested-loop join algorithm is simple and effective, but there’s one problem: the innermost table is accessed very frequently, and the full join makes that access very slow.&#13;
In this example, table <code>t3</code> is accessed for every matching row in <code>t1</code> multiplied by every matching row in <code>t2</code>.&#13;
If both <code>t1</code> and <code>t2</code> have 10 matching rows, then <code>t3</code> is accessed 100 times.&#13;
The <em>block nested-loop</em> <a data-primary="block nested-loop" data-type="indexterm" id="idm45829112783024"/>join algorithm addresses this problem.&#13;
Join column values from matching rows in <code>t1</code> and <code>t2</code> are saved in a <em>join buffer</em>.&#13;
(The join buffer size is set by system variable <a href="https://oreil.ly/r1NeH"><code>join_buffer_size</code></a>.)&#13;
When the join buffer <a data-primary="join buffer" data-type="indexterm" id="idm45829112780032"/>is full, MySQL scans <code>t3</code> and joins each <code>t3</code> row that matches join column values in the join buffer.&#13;
Although the join buffer is accessed many times (for each <code>t3</code> row), it’s fast because it’s in memory—significantly faster than 100 table scans required for the NLJ algorithm.</p>&#13;
&#13;
<p>As of MySQL 8.0.20, the hash join algorithm replaces the block nested-loop join algorithm.<sup><a data-type="noteref" href="ch02.html#idm45829112777456" id="idm45829112777456-marker">6</a></sup>&#13;
<em>Hash join</em> creates an in-memory hash table of join tables, like table <code>t3</code> in this example.&#13;
MySQL uses the hash table to look up rows in the join table, which is extremely fast because a hash table lookup is a constant time operation.&#13;
For details, read <a href="https://oreil.ly/uS0s3">“Hash Join Optimization”</a> in the MySQL manual.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><code>EXPLAIN</code> indicates a hash join by printing “Using join buffer (hash join)” in the <code>Extra</code> field.</p>&#13;
</div>&#13;
&#13;
<p>There are more details and nuances to MySQL joins, but this brief overview helps you to think about joins like MySQL: one table at a time and one index per table.<a data-primary="indexes" data-secondary="table join algorithms" data-startref="table-join-algorithms_index1" data-type="indexterm" id="idm45829112772592"/><a data-primary="table join algorithms" data-startref="table-join-algorithms_index2" data-type="indexterm" id="idm45829112771280"/><a data-primary="join algorithms" data-startref="join-algorithms-ch2" data-type="indexterm" id="idm45829112770320"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="ch02-summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter taught indexes and indexing with MySQL.&#13;
The key takeaway points are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Indexes provide the most and the best leverage for MySQL performance.</p>&#13;
</li>&#13;
<li>&#13;
<p>Do not scale up hardware to improve performance until exhausting other options.</p>&#13;
</li>&#13;
<li>&#13;
<p>Tuning MySQL is not necessary to improve performance with a reasonable configuration.</p>&#13;
</li>&#13;
<li>&#13;
<p>An InnoDB table is a B-tree index organized by the primary key.</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL accesses a table by index lookup, index scan, or full table scan—index lookup is the best access method.</p>&#13;
</li>&#13;
<li>&#13;
<p>To use an index, a query must use a leftmost prefix of the index—the <em>leftmost prefix requirement</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL uses an index to find rows matching <code>WHERE</code>, group rows for <code>GROUP BY</code>, sort rows for <code>ORDER BY</code>, avoid reading rows (covering index), and join tables.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>EXPLAIN</code> prints a <em>query execution plan</em> (or <em>EXPLAIN plan</em>) that details how MySQL executes a query.</p>&#13;
</li>&#13;
<li>&#13;
<p>Indexing requires thinking like MySQL to understand the query execution plan.</p>&#13;
</li>&#13;
<li>&#13;
<p>Good indexes can lose effectiveness for a variety of reasons.</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL uses three algorithms to join tables: NLJ, block nested-loop, and hash join.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The next chapter begins to address indirect query optimization with respect to data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Practice: Find Duplicate Indexes" data-type="sect1"><div class="sect1" id="ch02-ai">&#13;
<h1>Practice: Find Duplicate Indexes</h1>&#13;
&#13;
<p>The goal of this practice <a data-primary="duplicate indexes" data-type="indexterm" id="idm45829112751376"/>is to identify duplicate indexes using <a href="https://oreil.ly/Oxvjr">pt-duplicate-key-checker</a>: a command-line tool that prints duplicate indexes.</p>&#13;
&#13;
<p>The practice is simple but useful: download and run <code>pt-duplicate-key-checker</code>.&#13;
By default, it checks all tables and prints a report for each duplicate index, such as the following:</p>&#13;
&#13;
<pre data-type="programlisting"># ####################################################################&#13;
# db_name.table_name&#13;
# ####################################################################&#13;
&#13;
# idx_a is a left-prefix of idx_a_b&#13;
# Key definitions:&#13;
#   KEY `idx_a` (`a`),&#13;
#   KEY `idx_a_b` (`a`,`b`)&#13;
# Column types:&#13;
#         `a` int(11) default null&#13;
#         `b` int(11) default null&#13;
# To remove this duplicate index, execute:&#13;
ALTER TABLE `db_name`.`table_name` DROP INDEX `idx_a`;</pre>&#13;
&#13;
<p>For each index and its duplicate, the report includes:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A reason: why one index duplicates the other</p>&#13;
</li>&#13;
<li>&#13;
<p>Both index definitions</p>&#13;
</li>&#13;
<li>&#13;
<p>Column definitions that the indexes cover</p>&#13;
</li>&#13;
<li>&#13;
<p>An <code>ALTER TABLE</code> statement to drop the duplicate index</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>pt-duplicate-key-checker is mature and well tested, but always think carefully before dropping an index—especially in production.</p>&#13;
&#13;
<p>Like <a data-type="xref" href="ch01.html#ch01-ai">“Practice: Identify Slow Queries”</a>, this practice is simple—but you would be surprised how many engineers never check for duplicate indexes.&#13;
Checking for and removing duplicate indexes is practicing MySQL performance like an expert.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45829114802704"><sup><a href="ch02.html#idm45829114802704-marker">1</a></sup> Unless you’re Vadim Tkachenko, in which case: please keep tuning.</p><p data-type="footnote" id="idm45829113186976"><sup><a href="ch02.html#idm45829113186976-marker">2</a></sup> Unless <code>STRAIGHT_JOIN</code> is used, but don’t use this. Let the MySQL query optimizer choose the join order for the best query execution plan.</p><p data-type="footnote" id="idm45829113052112"><sup><a href="ch02.html#idm45829113052112-marker">3</a></sup> Strictly speaking, the index-only scan on table <code>elem</code> yields ten values, not rows, because full rows are not needed: only column <code>a</code> values are needed.</p><p data-type="footnote" id="idm45829112993152"><sup><a href="ch02.html#idm45829112993152-marker">4</a></sup> Extremely rare query optimizer bugs notwithstanding.</p><p data-type="footnote" id="idm45829112967856"><sup><a href="ch02.html#idm45829112967856-marker">5</a></sup> Try to outsmart MySQL if you’re bored, but don’t expect to win. It has seen attack ships on fire off the shoulder of Orion. It watched C-beams glitter in the dark near the Tannhäuser Gate.</p><p data-type="footnote" id="idm45829112777456"><sup><a href="ch02.html#idm45829112777456-marker">6</a></sup> Hash join exists as of MySQL 8.0.18 but replaces block nested-loop as of MySQL 8.0.20.</p></div></div></section></body></html>