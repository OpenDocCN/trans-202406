["```\napiVersion: restaurant.programming-kubernetes.info/v1alpha1\nkind: Pizza\nmetadata:\n  name: margherita\nspec:\n  toppings:\n  - mozzarella\n  - tomato\n```", "```\napiVersion: restaurant.programming-kubernetes.info/v1beta1\nkind: Pizza\nmetadata:\n  name: margherita\nspec:\n  toppings:\n  - name: mozzarella\n    quantity: 1\n  - name: tomato\n    quantity: 1\n```", "```\napiVersion: apiextensions.k8s.io/v1beta1\nkind: CustomResourceDefinition\nmetadata:\n  name: pizzas.restaurant.programming-kubernetes.info\nspec:\n  group: restaurant.programming-kubernetes.info\n  names:\n    kind: Pizza\n    listKind: PizzaList\n    plural: pizzas\n    singular: pizza\n  scope: Namespaced\n  version: v1alpha1\n  versions:\n  - name: v1alpha1\n    served: true\n    storage: true\n    schema: ...\n  - name: v1beta1\n    served: true\n    storage: false\n    schema: ...\n```", "```\napiVersion: restaurant.programming-kubernetes.info/v1alpha1\nkind: Pizza\nmetadata:\n  name: margherita\nspec:\n  toppings:\n  - mozzarella\n  - tomato\n```", "```\n$ kubectl create -f pizza-crd.yaml\n$ kubectl create -f margherita-pizza.yaml\n```", "```\n$ kubectl get pizza margherita -o yaml\napiVersion: restaurant.programming-kubernetes.info/v1beta1\nkind: Pizza\nmetadata:\n  creationTimestamp: \"2019-04-14T11:39:20Z\"\n  generation: 1\n  name: margherita\n  namespace: pizza-apiserver\n  resourceVersion: \"47959\"\n  selfLink: /apis/restaurant.programming-kubernetes.info/v1beta1/namespaces/pizza-apiserver/\n  pizzas/margherita\n  uid: f18427f0-5ea9-11e9-8219-124e4d2dc074\nspec:\n  toppings:\n  - mozzarella\n  - tomato\n```", "```\ntype ConversionReview struct {\n    metav1.TypeMeta `json:\",inline\"`\n    Request *ConversionRequest\n    Response *ConversionResponse\n}\n```", "```\ntype ConversionRequest struct {\n    ...\n\n    // `desiredAPIVersion` is the version to convert given objects to.\n    // For example, \"myapi.example.com/v1.\"\n    DesiredAPIVersion string\n\n    // `objects` is the list of CR objects to be converted.\n    Objects []runtime.RawExtension\n}\n```", "```\ntype ConversionResponse struct {\n    ...\n\n    // `convertedObjects` is the list of converted versions of `request.objects`\n    // if the `result` is successful otherwise empty. The webhook is expected to\n    // set apiVersion of these objects to the ConversionRequest.desiredAPIVersion.\n    // The list must also have the same size as input list with the same objects\n    // in the same order (i.e. equal UIDs and object meta).\n    ConvertedObjects []runtime.RawExtension\n\n    // `result` contains the result of conversion with extra details if the\n    // conversion failed. `result.status` determines if the conversion failed\n    // or succeeded. The `result.status` field is required and represents the\n    // success or failure of the conversion. A successful conversion must set\n    // `result.status` to `Success`. A failed conversion must set `result.status`\n    // to `Failure` and provide more details in `result.message` and return http\n    // status 200\\. The `result.message` will be used to construct an error\n    // message for the end user.\n    Result metav1.Status\n}\n```", "```\nfunc NewDefaultOptions() *Options {\n    o := &Options{\n        *options.NewSecureServingOptions(),\n    }\n    o.SecureServing.ServerCert.PairName = \"pizza-crd-webhook\"\n    return o\n}\n\ntype Options struct {\n    SecureServing options.SecureServingOptions\n}\n\ntype Config struct {\n    SecureServing *server.SecureServingInfo\n}\n\nfunc (o *Options) AddFlags(fs *pflag.FlagSet) {\n    o.SecureServing.AddFlags(fs)\n}\n\nfunc (o *Options) Config() (*Config, error) {\n    err := o.SecureServing.MaybeDefaultWithSelfSignedCerts(\"0.0.0.0\", nil, nil)\n    if err != nil {\n        return nil, err\n    }\n\n    c := &Config{}\n\n    if err := o.SecureServing.ApplyTo(&c.SecureServing); err != nil {\n        return nil, err\n    }\n\n    return c, nil\n}\n```", "```\nopt := NewDefaultOptions()\nfs := pflag.NewFlagSet(\"pizza-crd-webhook\", pflag.ExitOnError)\nglobalflag.AddGlobalFlags(fs, \"pizza-crd-webhook\")\nopt.AddFlags(fs)\nif err := fs.Parse(os.Args); err != nil {\n    panic(err)\n}\n\n// create runtime config\ncfg, err := opt.Config()\nif err != nil {\n    panic(err)\n}\n\nstopCh := server.SetupSignalHandler()\n\n...\n\n// run server\nrestaurantInformers.Start(stopCh)\nif doneCh, err := cfg.SecureServing.Serve(\n    handlers.LoggingHandler(os.Stdout, mux),\n    time.Second * 30, stopCh,\n); err != nil {\n    panic(err)\n} else {\n    <-doneCh\n}\n```", "```\n// register handlers\nrestaurantInformers := restaurantinformers.NewSharedInformerFactory(\n    clientset, time.Minute * 5,\n)\nmux := http.NewServeMux()\nmux.Handle(\"/convert/v1beta1/pizza\", http.HandlerFunc(conversion.Serve))\nmux.Handle(\"/admit/v1beta1/pizza\", http.HandlerFunc(admission.ServePizzaAdmit))\nmux.Handle(\"/validate/v1beta1/pizza\",\n    http.HandlerFunc(admission.ServePizzaValidation(restaurantInformers)))\nrestaurantInformers.Start(stopCh)\n```", "```\nfunc Serve(w http.ResponseWriter, req *http.Request) {\n    // read body\n    body, err := ioutil.ReadAll(req.Body)\n    if err != nil {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf(\"failed to read body: %v\", err))\n        return\n    }\n\n    // decode body as conversion review\n    gv := apiextensionsv1beta1.SchemeGroupVersion\n    reviewGVK := gv.WithKind(\"ConversionReview\")\n    obj, gvk, err := codecs.UniversalDeserializer().Decode(body, &reviewGVK,\n        &apiextensionsv1beta1.ConversionReview{})\n    if err != nil {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf(\"failed to decode body: %v\", err))\n        return\n    }\n    review, ok := obj.(*apiextensionsv1beta1.ConversionReview)\n    if !ok {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf(\"unexpected GroupVersionKind: %s\", gvk))\n        return\n    }\n    if review.Request == nil {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf(\"unexpected nil request\"))\n        return\n    }\n\n    ...\n}\n```", "```\nimport (\n    apiextensionsv1beta1 \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1\"\n    \"github.com/programming-kubernetes/pizza-crd/pkg/apis/restaurant/install\"\n    ...\n)\n\nvar (\n    scheme = runtime.NewScheme()\n    codecs = serializer.NewCodecFactory(scheme)\n)\n\nfunc init() {\n    utilruntime.Must(apiextensionsv1beta1.AddToScheme(scheme))\n    install.Install(scheme)\n}\n```", "```\ntype RawExtension struct {\n    // Raw is the underlying serialization of this object.\n    Raw []byte `protobuf:\"bytes,1,opt,name=raw\"`\n    // Object can hold a representation of this extension - useful for working\n    // with versioned structs.\n    Object Object `json:\"-\"`\n}\n```", "```\n// convert objects\nreview.Response = &apiextensionsv1beta1.ConversionResponse{\n    UID: review.Request.UID,\n    Result:  metav1.Status{\n        Status: metav1.StatusSuccess,\n    },\n}\nvar objs []runtime.Object\nfor _, in := range review.Request.Objects {\n    if in.Object == nil {\n        var err error\n        in.Object, _, err = codecs.UniversalDeserializer().Decode(\n            in.Raw, nil, nil,\n        )\n        if err != nil {\n            review.Response.Result = metav1.Status{\n                Message: err.Error(),\n                Status:  metav1.StatusFailure,\n            }\n            break\n        }\n    }\n\n    obj, err := convert(in.Object, review.Request.DesiredAPIVersion)\n    if err != nil {\n        review.Response.Result = metav1.Status{\n            Message: err.Error(),\n            Status:  metav1.StatusFailure,\n        }\n        break\n    }\n    objs = append(objs, obj)\n}\n```", "```\nif review.Response.Result.Status == metav1.StatusSuccess {\n    for _, obj = range objs {\n        review.Response.ConvertedObjects =\n          append(review.Response.ConvertedObjects,\n            runtime.RawExtension{Object: obj},\n          )\n    }\n}\n\n// write negotiated response\nresponsewriters.WriteObject(\n    http.StatusOK, gvk.GroupVersion(), codecs, review, w, req,\n)\n```", "```\nfunc convert(in runtime.Object, apiVersion string) (runtime.Object, error) {\n    switch in := in.(type) {\n    case *v1alpha1.Pizza:\n        if apiVersion != v1beta1.SchemeGroupVersion.String() {\n            return nil, fmt.Errorf(\"cannot convert %s to %s\",\n              v1alpha1.SchemeGroupVersion, apiVersion)\n        }\n        klog.V(2).Infof(\"Converting %s/%s from %s to %s\", in.Namespace, in.Name,\n            v1alpha1.SchemeGroupVersion, apiVersion)\n\n        out := &v1beta1.Pizza{\n            TypeMeta: in.TypeMeta,\n            ObjectMeta: in.ObjectMeta,\n            Status: v1beta1.PizzaStatus{\n                Cost: in.Status.Cost,\n            },\n        }\n        out.TypeMeta.APIVersion = apiVersion\n\n        idx := map[string]int{}\n        for _, top := range in.Spec.Toppings {\n            if i, duplicate := idx[top]; duplicate {\n                out.Spec.Toppings[i].Quantity++\n                continue\n            }\n            idx[top] = len(out.Spec.Toppings)\n            out.Spec.Toppings = append(out.Spec.Toppings, v1beta1.PizzaTopping{\n                Name: top,\n                Quantity: 1,\n            })\n        }\n\n        return out, nil\n\n    case *v1beta1.Pizza:\n        if apiVersion != v1alpha1.SchemeGroupVersion.String() {\n            return nil, fmt.Errorf(\"cannot convert %s to %s\",\n              v1beta1.SchemeGroupVersion, apiVersion)\n        }\n        klog.V(2).Infof(\"Converting %s/%s from %s to %s\",\n          in.Namespace, in.Name, v1alpha1.SchemeGroupVersion, apiVersion)\n\n        out := &v1alpha1.Pizza{\n            TypeMeta: in.TypeMeta,\n            ObjectMeta: in.ObjectMeta,\n            Status: v1alpha1.PizzaStatus{\n                Cost: in.Status.Cost,\n            },\n        }\n        out.TypeMeta.APIVersion = apiVersion\n\n        for i := range in.Spec.Toppings {\n            for j := 0; j < in.Spec.Toppings[i].Quantity; j++ {\n                out.Spec.Toppings = append(\n                  out.Spec.Toppings, in.Spec.Toppings[i].Name)\n            }\n        }\n\n        return out, nil\n\n    default:\n    }\n    klog.V(2).Infof(\"Unknown type %T\", in)\n    return nil, fmt.Errorf(\"unknown type %T\", in)\n}\n```", "```\napiVersion: apiextensions.k8s.io/v1beta1\nkind: CustomResourceDefinition\nmetadata:\n  name: pizzas.restaurant.programming-kubernetes.info\nspec:\n  ...\n  conversion:\n    strategy: Webhook\n    webhookClientConfig:\n      caBundle: *`BASE64-CA-BUNDLE`*\n      service:\n        namespace: pizza-crd\n        name: webhook\n        path: /convert/v1beta1/pizza\n\n```", "```\nkind: Cluster\napiVersion: kind.sigs.k8s.io/v1alpha3\nkubeadmConfigPatchesJson6902:\n- group: kubeadm.k8s.io\n  version: v1beta1\n  kind: ClusterConfiguration\n  patch: |\n    - op: add\n      path: /apiServer/extraArgs\n      value: {}\n    - op: add\n      path: /apiServer/extraArgs/feature-gates\n      value: CustomResourceWebhookConversion=true\n```", "```\n$ kind create cluster --image kindest/node-images:v1.14.1 --config kind-config.yaml\n$ export KUBECONFIG=\"$(kind get kubeconfig-path --name=\"kind\")\"\n```", "```\n$ cd pizza-crd\n$ cd manifest/deployment\n$ make\n$ kubectl create -f ns.yaml\n$ kubectl create -f pizza-crd.yaml\n$ kubectl create -f topping-crd.yaml\n$ kubectl create -f sa.yaml\n$ kubectl create -f rbac.yaml\n$ kubectl create -f rbac-bind.yaml\n$ kubectl create -f service.yaml\n$ kubectl create -f serving-cert-secret.yaml\n$ kubectl create -f deployment.yaml\n```", "```\n$ cat  ../examples/margherita-pizza.yaml\napiVersion: restaurant.programming-kubernetes.info/v1alpha1\nkind: Pizza\nmetadata:\n  name: margherita\nspec:\n  toppings:\n  - mozzarella\n  - tomato\n$ kubectl create ../examples/margherita-pizza.yaml\npizza.restaurant.programming-kubernetes.info/margherita created\n```", "```\n$ kubectl get pizzas.v1alpha1.restaurant.programming-kubernetes.info \\\n    margherita -o yaml\napiVersion: restaurant.programming-kubernetes.info/v1alpha1\nkind: Pizza\nmetadata:\n  creationTimestamp: \"2019-04-14T21:41:39Z\"\n  generation: 1\n  name: margherita\n  namespace: pizza-crd\n  resourceVersion: \"18296\"\n  pizzas/margherita\n  uid: 15c1c06a-5efe-11e9-9230-0242f24ba99c\nspec:\n  toppings:\n  - mozzarella\n  - tomato\nstatus: {}\n```", "```\n$ kubectl get pizzas.v1beta1.restaurant.programming-kubernetes.info \\\n    margherita -o yaml\napiVersion: restaurant.programming-kubernetes.info/v1beta1\nkind: Pizza\nmetadata:\n  creationTimestamp: \"2019-04-14T21:41:39Z\"\n  generation: 1\n  name: margherita\n  namespace: pizza-crd\n  resourceVersion: \"18296\"\n  pizzas/margherita\n  uid: 15c1c06a-5efe-11e9-9230-0242f24ba99c\nspec:\n  toppings:\n  - name: mozzarella\n    quantity: 1\n  - name: tomato\n    quantity: 1\nstatus: {}\n```", "```\nI0414 21:46:28.639707       1 convert.go:35] Converting pizza-crd/margherita\n  from restaurant.programming-kubernetes.info/v1alpha1\n  to restaurant.programming-kubernetes.info/v1beta1\n10.32.0.1 - - [14/Apr/2019:21:46:28 +0000]\n  \"POST /convert/v1beta1/pizza?timeout=30s HTTP/2.0\" 200 968\n```", "```\n---\n// AdmissionReview describes an admission review request/response.\ntype AdmissionReview struct {\n    metav1.TypeMeta `json:\",inline\"`\n    // Request describes the attributes for the admission request.\n    // +optional\n    Request *AdmissionRequest `json:\"request,omitempty\"`\n    // Response describes the attributes for the admission response.\n    // +optional\n    Response *AdmissionResponse `json:\"response,omitempty\"`\n}\n---\n```", "```\n// AdmissionRequest describes the admission.Attributes for the admission request.\ntype AdmissionRequest struct {\n    // UID is an identifier for the individual request/response. It allows us to\n    // distinguish instances of requests which are otherwise identical (parallel\n    // requests, requests when earlier requests did not modify etc). The UID is\n    // meant to track the round trip (request/response) between the KAS and the\n    // WebHook, not the user request. It is suitable for correlating log entries\n    // between the webhook and apiserver, for either auditing or debugging.\n    UID types.UID `json:\"uid\"`\n    // Kind is the type of object being manipulated.  For example: Pod\n    Kind metav1.GroupVersionKind `json:\"kind\"`\n    // Resource is the name of the resource being requested.  This is not the\n    // kind.  For example: pods\n    Resource metav1.GroupVersionResource `json:\"resource\"`\n    // SubResource is the name of the subresource being requested.  This is a\n    // different resource, scoped to the parent resource, but it may have a\n    // different kind. For instance, /pods has the resource \"pods\" and the kind\n    // \"Pod\", while /pods/foo/status has the resource \"pods\", the sub resource\n    // \"status\", and the kind \"Pod\" (because status operates on pods). The\n    // binding resource for a pod though may be /pods/foo/binding, which has\n    // resource \"pods\", subresource \"binding\", and kind \"Binding\".\n    // +optional\n    SubResource string `json:\"subResource,omitempty\"`\n    // Name is the name of the object as presented in the request.  On a CREATE\n    // operation, the client may omit name and rely on the server to generate\n    // the name.  If that is the case, this method will return the empty string.\n    // +optional\n    Name string `json:\"name,omitempty\"`\n    // Namespace is the namespace associated with the request (if any).\n    // +optional\n    Namespace string `json:\"namespace,omitempty\"`\n    // Operation is the operation being performed\n    Operation Operation `json:\"operation\"`\n    // UserInfo is information about the requesting user\n    UserInfo authenticationv1.UserInfo `json:\"userInfo\"`\n    // Object is the object from the incoming request prior to default values\n    // being applied\n    // +optional\n    Object runtime.RawExtension `json:\"object,omitempty\"`\n    // OldObject is the existing object. Only populated for UPDATE requests.\n    // +optional\n    OldObject runtime.RawExtension `json:\"oldObject,omitempty\"`\n    // DryRun indicates that modifications will definitely not be persisted\n    // for this request.\n    // Defaults to false.\n    // +optional\n    DryRun *bool `json:\"dryRun,omitempty\"`\n}\n```", "```\napiVersion: admissionregistration.k8s.io/v1beta1\nkind: MutatingWebhookConfiguration\nmetadata:\n  name: restaurant.programming-kubernetes.info\nwebhooks:\n- name: restaurant.programming-kubernetes.info\n  failurePolicy: Fail\n  sideEffects: None\n  admissionReviewVersions:\n  - v1beta1\n  rules:\n  - apiGroups:\n    - \"restaurant.programming-kubernetes.info\"\n    apiVersions:\n    - v1alpha1\n    - v1beta1\n    operations:\n    - CREATE\n    - UPDATE\n    resources:\n    - pizzas\n  clientConfig:\n    service:\n      namespace: pizza-crd\n      name: webhook\n      path: /admit/v1beta1/pizza\n    caBundle: *`CA-BUNDLE`*\n\n```", "```\nmux.Handle(\"/admit/v1beta1/pizza\", http.HandlerFunc(admission.ServePizzaAdmit))\nmux.Handle(\"/validate/v1beta1/pizza\", http.HandlerFunc(\nadmission.ServePizzaValidation(restaurantInformers)))\n```", "```\nfunc ServePizzaAdmit(w http.ResponseWriter, req *http.Request) {\n    // read body\n    body, err := ioutil.ReadAll(req.Body)\n    if err != nil {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf(\"failed to read body: %v\", err))\n        return\n    }\n\n    // decode body as admission review\n    reviewGVK := admissionv1beta1.SchemeGroupVersion.WithKind(\"AdmissionReview\")\n    decoder := codecs.UniversalDeserializer()\n    into := &admissionv1beta1.AdmissionReview{}\n    obj, gvk, err := decoder.Decode(body, &reviewGVK, into)\n    if err != nil {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf(\"failed to decode body: %v\", err))\n        return\n    }\n    review, ok := obj.(*admissionv1beta1.AdmissionReview)\n    if !ok {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf(\"unexpected GroupVersionKind: %s\", gvk))\n        return\n    }\n    if review.Request == nil {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf(\"unexpected nil request\"))\n        return\n    }\n\n    ...\n}\n```", "```\nfunc ServePizzaValidation(informers restaurantinformers.SharedInformerFactory)\n    func (http.ResponseWriter, *http.Request)\n{\n    toppingInformer := informers.Restaurant().V1alpha1().Toppings().Informer()\n    toppingLister := informers.Restaurant().V1alpha1().Toppings().Lister()\n\n    return func(w http.ResponseWriter, req *http.Request) {\n        if !toppingInformer.HasSynced() {\n            responsewriters.InternalError(w, req,\n              fmt.Errorf(\"informers not ready\"))\n            return\n        }\n\n        // read body\n        body, err := ioutil.ReadAll(req.Body)\n        if err != nil {\n            responsewriters.InternalError(w, req,\n              fmt.Errorf(\"failed to read body: %v\", err))\n            return\n        }\n\n        // decode body as admission review\n        gv := admissionv1beta1.SchemeGroupVersion\n        reviewGVK := gv.WithKind(\"AdmissionReview\")\n        obj, gvk, err := codecs.UniversalDeserializer().Decode(body, &reviewGVK,\n            &admissionv1beta1.AdmissionReview{})\n        if err != nil {\n            responsewriters.InternalError(w, req,\n              fmt.Errorf(\"failed to decode body: %v\", err))\n            return\n        }\n        review, ok := obj.(*admissionv1beta1.AdmissionReview)\n        if !ok {\n            responsewriters.InternalError(w, req,\n              fmt.Errorf(\"unexpected GroupVersionKind: %s\", gvk))\n            return\n        }\n        if review.Request == nil {\n            responsewriters.InternalError(w, req,\n              fmt.Errorf(\"unexpected nil request\"))\n            return\n        }\n\n        ...\n    }\n}\n```", "```\nvar (\n    scheme = runtime.NewScheme()\n    codecs = serializer.NewCodecFactory(scheme)\n)\n\nfunc init() {\n    utilruntime.Must(admissionv1beta1.AddToScheme(scheme))\n    install.Install(scheme)\n}\n```", "```\n// decode object\nif review.Request.Object.Object == nil {\n    var err error\n    review.Request.Object.Object, _, err =\n      codecs.UniversalDeserializer().Decode(review.Request.Object.Raw, nil, nil)\n    if err != nil {\n        review.Response.Result = &metav1.Status{\n            Message: err.Error(),\n            Status:  metav1.StatusFailure,\n        }\n        responsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),\n          codecs, review, w, req)\n        return\n    }\n}\n```", "```\norig := review.Request.Object.Raw\nvar bs []byte\nswitch pizza := review.Request.Object.Object.(type) {\ncase *v1alpha1.Pizza:\n    // default toppings\n    if len(pizza.Spec.Toppings) == 0 {\n        pizza.Spec.Toppings = []string{\"tomato\", \"mozzarella\", \"salami\"}\n    }\n    bs, err = json.Marshal(pizza)\n    if err != nil {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf\"unexpected encoding error: %v\", err))\n        return\n    }\n\ncase *v1beta1.Pizza:\n    // default toppings\n    if len(pizza.Spec.Toppings) == 0 {\n        pizza.Spec.Toppings = []v1beta1.PizzaTopping{\n            {\"tomato\", 1},\n            {\"mozzarella\", 1},\n            {\"salami\", 1},\n        }\n    }\n    bs, err = json.Marshal(pizza)\n    if err != nil {\n        responsewriters.InternalError(w, req,\n          fmt.Errorf(\"unexpected encoding error: %v\", err))\n        return\n    }\n\ndefault:\n    review.Response.Result = &metav1.Status{\n        Message: fmt.Sprintf(\"unexpected type %T\", review.Request.Object.Object),\n        Status:  metav1.StatusFailure,\n    }\n    responsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),\n      codecs, review, w, req)\n    return\n}\n```", "```\n// compare original and defaulted version\nops, err := jsonpatch.CreatePatch(orig, bs)\nif err != nil {\n    responsewriters.InternalError(w, req,\n        fmt.Errorf(\"unexpected diff error: %v\", err))\n    return\n}\nreview.Response.Patch, err = json.Marshal(ops)\nif err != nil {\n    responsewriters.InternalError(w, req,\n    fmt.Errorf(\"unexpected patch encoding error: %v\", err))\n    return\n}\ntyp := admissionv1beta1.PatchTypeJSONPatch\nreview.Response.PatchType = &typ\nreview.Response.Allowed = true\n```", "```\nresponsewriters.WriteObject(\n    http.StatusOK, gvk.GroupVersion(), codecs, review, w, req,\n)\n```", "```\nswitch pizza := review.Request.Object.Object.(type) {\ncase *v1alpha1.Pizza:\n    for _, topping := range pizza.Spec.Toppings {\n        _, err := toppingLister.Get(topping)\n        if err != nil && !errors.IsNotFound(err) {\n            responsewriters.InternalError(w, req,\n              fmt.Errorf(\"failed to lookup topping %q: %v\", topping, err))\n            return\n        } else if errors.IsNotFound(err) {\n            review.Response.Result = &metav1.Status{\n                Message: fmt.Sprintf(\"topping %q not known\", topping),\n                Status:  metav1.StatusFailure,\n            }\n            responsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),\n              codecs, review, w, req)\n            return\n        }\n    }\n    review.Response.Allowed = true\ncase *v1beta1.Pizza:\n    for _, topping := range pizza.Spec.Toppings {\n        _, err := toppingLister.Get(topping.Name)\n        if err != nil && !errors.IsNotFound(err) {\n            responsewriters.InternalError(w, req,\n              fmt.Errorf(\"failed to lookup topping %q: %v\", topping, err))\n            return\n        } else if errors.IsNotFound(err) {\n            review.Response.Result = &metav1.Status{\n                Message: fmt.Sprintf(\"topping %q not known\", topping),\n                Status:  metav1.StatusFailure,\n            }\n            responsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),\n              codecs, review, w, req)\n            return\n        }\n    }\n    review.Response.Allowed = true\ndefault:\n    review.Response.Result = &metav1.Status{\n        Message: fmt.Sprintf(\"unexpected type %T\", review.Request.Object.Object),\n        Status:  metav1.StatusFailure,\n    }\n}\nresponsewriters.WriteObject(http.StatusOK, gvk.GroupVersion(),\n      codecs, review, w, req)\n```", "```\n$ kubectl create -f validatingadmissionregistration.yaml\n$ kubectl create -f mutatingadmissionregistration.yaml\n```", "```\n$ kubectl create -f ../examples/margherita-pizza.yaml\nError from server: error when creating \"../examples/margherita-pizza.yaml\":\n  admission webhook \"restaurant.programming-kubernetes.info\" denied the request:\n    topping \"tomato\" not known\n```", "```\nI0414 22:45:46.873541       1 pizzamutation.go:115] Defaulting pizza-crd/ in\n  version admission.k8s.io/v1beta1, Kind=AdmissionReview\n10.32.0.1 - - [14/Apr/2019:22:45:46 +0000]\n  \"POST /admit/v1beta1/pizza?timeout=30s HTTP/2.0\" 200 871\n10.32.0.1 - - [14/Apr/2019:22:45:46 +0000]\n  \"POST /validate/v1beta1/pizza?timeout=30s HTTP/2.0\" 200 956\n```", "```\n$ kubectl create -f ../examples/topping-tomato.yaml\n$ kubectl create -f ../examples/topping-salami.yaml\n$ kubectl create -f ../examples/topping-mozzarella.yaml\n$ kubectl create -f ../examples/margherita-pizza.yaml\npizza.restaurant.programming-kubernetes.info/margherita created\n```", "```\napiVersion: restaurant.programming-kubernetes.info/v1alpha1\nkind: Pizza\nmetadata:\n  name: salami\nspec:\n```", "```\n$ kubectl create -f ../examples/empty-pizza.yaml\npizza.restaurant.programming-kubernetes.info/salami created\n$ kubectl get pizza salami -o yaml\napiVersion: restaurant.programming-kubernetes.info/v1beta1\nkind: Pizza\nmetadata:\n  creationTimestamp: \"2019-04-14T22:49:40Z\"\n  generation: 1\n  name: salami\n  namespace: pizza-crd\n  resourceVersion: \"23227\"\n  uid: 962e2dda-5f07-11e9-9230-0242f24ba99c\nspec:\n  toppings:\n  - name: tomato\n    quantity: 1\n  - name: mozzarella\n    quantity: 1\n  - name: salami\n    quantity: 1\nstatus: {}\n```", "```\nproperties:\n  foo:\n    pattern: \"abc\"\n  metadata:\n    type: object\n    properties:\n      name:\n        type: string\n        pattern: \"^a\"\n      finalizers:\n        type: array\n        items:\n          type: string\n          pattern: \"my-finalizer\"\nanyOf:\n- properties:\n    bar:\n      type: integer\n      minimum: 42\n  required: [\"bar\"]\n  description: \"foo bar object\"\n```", "```\ntype: object\ndescription: \"foo bar object\"\nproperties:\n  foo:\n    type: string\n    pattern: \"abc\"\n  bar:\n    type: integer\n  metadata:\n    type: object\n    properties:\n      name:\n        type: string\n        pattern: \"^a\"\nanyOf:\n- properties:\n    bar:\n      minimum: 42\n  required: [\"bar\"]\n```", "```\napiVersion: apiextensions.k8s.io/v1beta1\nkind: CustomResourceDefinition\nmetadata:\n  name: ats.cnat.programming-kubernetes.info\nspec:\n  ...\n  preserveUnknownFields: false\n```", "```\napiVersion: cnat.programming-kubernetes.info/v1alpha1\nkind: At\nmetadata:\n  name: example-at\nspec:\n  schedule: \"2019-07-03T02:00:00Z\"\n  command: echo \"Hello, world!\"\n  someGarbage: 42\n```", "```\napiVersion: cnat.programming-kubernetes.info/v1alpha1\nkind: At\nmetadata:\n  name: example-at\nspec:\n  schedule: \"2019-07-03T02:00:00Z\"\n  command: echo \"Hello, world!\"\n```", "```\ntype: object\nproperties:\n  json:\n    x-kubernetes-preserve-unknown-fields: true\n```", "```\ntype: object\nproperties:\n  json:\n    x-kubernetes-preserve-unknown-fields: true\n    type: object\n    description: this is arbitrary JSON\n```", "```\ntype: object\nproperties:\n  json:\n    x-kubernetes-preserve-unknown-fields: true\n    type: object\n    properties:\n      spec:\n        type: object\n        properties:\n          foo:\n            type: string\n          bar:\n            type: string\n```", "```\njson:\n  spec:\n    foo: abc\n    bar: def\n    something: x\n  status:\n    something: x\n```", "```\njson:\n  spec:\n    foo: abc\n    bar: def\n  status:\n    something: x\n```", "```\ntype: object\nproperties:\n  intorstr:\n    type: object\n    x-kubernetes-int-or-string: true\n  embedded:\n    x-kubernetes-embedded-object: true\n    x-kubernetes-preserve-unknown-fields: true\n```", "```\ntype: object\nproperties:\n  apiVersion:\n    type: string\n  kind:\n    type: string\n  metadata:\n    type: object\n  spec:\n    type: object\n    properties:\n      schedule:\n        type: string\n        pattern: \"^\\d{4}-([0]\\d|1[0-2])-([0-2]\\d|3[01])...\"\n      command:\n        type: string\n      image:\n        type: string\n        default: \"busybox\"\n    required:\n    - schedule\n    - command\n  status:\n    type: object\n    properties:\n      phase:\n        type: string\nrequired:\n- metadata\n- apiVersion\n- kind\n- spec\n```", "```\napiVersion: cnat.programming-kubernetes.info/v1alpha1\nkind: At\nmetadata:\n  name: example-at\nspec:\n  schedule: \"2019-07-03T02:00:00Z\"\n  command: echo \"hello world!\"\n```", "```\napiVersion: cnat.programming-kubernetes.info/v1alpha1\nkind: At\nmetadata:\n  name: example-at\nspec:\n  schedule: \"2019-07-03T02:00:00Z\"\n  command: echo \"hello world!\"\n  image: busybox\n```"]