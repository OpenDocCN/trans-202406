<html><head></head><body><section data-pdf-bookmark="Chapter 8. Volumes and Configuration Data" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_volumes_config">&#13;
<h1><span class="label">Chapter 8. </span>Volumes and Configuration Data</h1>&#13;
&#13;
&#13;
<p>A <em>volume</em> in Kubernetes is a directory accessible to all containers running in a pod, with the additional guarantee that the data is preserved across restarts of individual containers.<a data-primary="volumes" data-secondary="about" data-type="indexterm" id="id918"/><a data-primary="nodes" data-secondary="node-local ephemeral volumes" data-type="indexterm" id="id919"/><a data-primary="networked volumes" data-type="indexterm" id="id920"/><a data-primary="cloud provider-specific volumes" data-type="indexterm" id="id921"/><a data-primary="special-purpose volumes" data-type="indexterm" id="id922"/></p>&#13;
&#13;
<p>We can distinguish between a few types of volumes:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Node-local</em> ephemeral volumes, such as <code>emptyDir</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Generic <em>networked</em> volumes,  such as <code>nfs</code> or <code>cephfs</code></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Cloud provider–specific</em> volumes,  such as <code>AWS EBS</code> or <code>AWS EFS</code></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Special-purpose</em> volumes, such as <code>secret</code> or <code>configMap</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Which volume type you choose depends entirely on your use case. For example, for a temporary scratch space, an <code>emptyDir</code> would be fine, but when you need to make sure your data survives node failures, you’ll want to look into more resilient alternatives or cloud provider–specific solutions.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.1 Exchanging Data Between Containers via a &#10;Local Volume" data-type="sect1"><div class="sect1" id="data_exchange_local_volume">&#13;
<h1>8.1 Exchanging Data Between Containers via a &#13;
<span class="keep-together">Local Volume</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id227">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You have two or more containers running in a pod and want to be able to exchange data via filesystem operations.<a data-primary="containers" data-secondary="exchanging data between, using volumes" data-type="indexterm" id="ix_cntnrexch"/><a data-primary="volumes" data-secondary="exchanging data between containers via" data-type="indexterm" id="ix_volexcg"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id70">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a local volume of type <code>emptyDir</code>.</p>&#13;
&#13;
<p>The<a data-primary="manifests" data-secondary="exchangedata.yaml example" data-type="indexterm" id="id923"/> starting point is the following pod manifest, <em>exchangedata.yaml</em>, which has two containers (<code>c1</code> and <code>c2</code>) that each mount the local volume <code>xchange</code> into their filesystem, using different mount points:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">sharevol</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">c1</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ubuntu:20.04</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"bin/bash"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"-c"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sleep</code><code class="nv"> </code><code class="s">10000"</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">xchange</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/tmp/xchange"</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">c2</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ubuntu:20.04</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"bin/bash"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"-c"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sleep</code><code class="nv"> </code><code class="s">10000"</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">xchange</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/tmp/data"</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">xchange</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/></pre>&#13;
&#13;
<p>Now you can launch the pod, <code>exec</code> into it, create <a data-primary="kubectl" data-secondary="exec command" data-type="indexterm" id="id924"/><a data-primary="exec command (kubectl)" data-type="indexterm" id="id925"/>data from one container, and read it out from the other one:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f exchangedata.yaml</strong>&#13;
pod/sharevol created&#13;
&#13;
$ <strong>kubectl exec sharevol -c c1 -i -t -- bash</strong>&#13;
[root@sharevol /]# mount | grep xchange&#13;
/dev/vda1 on /tmp/xchange type ext4 (rw,relatime)&#13;
[root@sharevol /]# echo 'some data' &gt; /tmp/xchange/data&#13;
[root@sharevol /]# exit&#13;
&#13;
$ <strong>kubectl exec sharevol -c c2 -i -t -- bash</strong>&#13;
[root@sharevol /]# mount | grep /tmp/data&#13;
/dev/vda1 on /tmp/data type ext4 (rw,relatime)&#13;
[root@sharevol /]# cat /tmp/data/data&#13;
some data&#13;
[root@sharevol /]# exit&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id71">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>A local volume is backed by the node on which the pod and its containers are running.<a data-primary="nodes" data-secondary="volumes and" data-type="indexterm" id="id926"/> If the node goes down or you have to carry out maintenance on it (see <a data-type="xref" href="ch12.html#drain_nodes">Recipe 12.9</a>), then the local volume is gone and all the data is lost.</p>&#13;
&#13;
<p>There <a data-primary="persistent volumes" data-type="indexterm" id="id927"/>are some use cases where local volumes are fine—​for example, for some scratch space or when the canonical state is obtained from somewhere else, such as an S3 bucket—​but in general you’ll want to use a persistent volume or one backed by networked storage (see <a data-type="xref" href="#pv_minikube">Recipe 8.4</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id928">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes documentation on <a href="https://oreil.ly/82P1u">volumes</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.2 Passing an API Access Key to a Pod Using a Secret" data-type="sect1"><div class="sect1" id="special_volumes">&#13;
<h1>8.2 Passing an API Access Key to a Pod Using a Secret</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id228">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>As an admin, you want to provide your developers with an API access key in a secure way; that is, without sharing it in clear text in your Kubernetes manifests.<a data-primary="containers" data-secondary="exchanging data between, using volumes" data-startref="ix_cntnrexch" data-type="indexterm" id="id929"/><a data-primary="volumes" data-secondary="exchanging data between containers via" data-startref="ix_volexcg" data-type="indexterm" id="id930"/><a data-primary="APIs" data-secondary="passing API access key to a pod using a secret" data-type="indexterm" id="ix_APIkey"/><a data-primary="secrets" data-secondary="passing API access key to a pod using a secret" data-type="indexterm" id="ix_scrtAPIkey"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id229">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a local volume of type <a href="https://oreil.ly/bX6ER"><code>secret</code></a>.</p>&#13;
&#13;
<p>Let’s say you want to give your developers access to an external service that is accessible via the passphrase <code>open sesame</code>.</p>&#13;
&#13;
<p>First, create a text file called <em>passphrase</em> that holds the passphrase:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>echo -n "open sesame" &gt; ./passphrase</strong>&#13;
</pre>&#13;
&#13;
<p>Next, create the <a href="https://oreil.ly/cCddB">secret</a>, using the <em>passphrase</em> file:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create secret generic pp --from-file=./passphrase</strong>&#13;
secret/pp created&#13;
&#13;
$ <strong>kubectl describe secrets/pp</strong>&#13;
Name:           pp&#13;
Namespace:      default&#13;
Labels:         &lt;none&gt;&#13;
Annotations:    &lt;none&gt;&#13;
&#13;
Type:   Opaque&#13;
&#13;
Data&#13;
====&#13;
passphrase:     11 bytes&#13;
</pre>&#13;
&#13;
<p>From an admin point of view, you’re all set now, and it’s time for your developers to consume the secret. So let’s switch hats and assume you’re a developer and want to use the passphrase from within a pod.</p>&#13;
&#13;
<p>You would consume the secret, for example, by mounting it as a volume into your pod and then reading it out as a normal file.<a data-primary="pods" data-secondary="mounting secret as volume in" data-type="indexterm" id="id931"/> Create and save the following manifest, called <em>ppconsumer.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ppconsumer</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shell</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.36</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sh"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"-c"</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"mount</code><code class="nv"> </code><code class="s">|</code><code class="nv"> </code><code class="s">grep</code><code class="nv"> </code><code class="s">access</code><code class="nv">  </code><code class="s">&amp;&amp;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">3600"</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">passphrase</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/tmp/access"</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">passphrase</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">secret</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pp</code><code class="w"/></pre>&#13;
&#13;
<p>Now launch the pod and take a look at its logs, where you would expect to see the <code>ppconsumer</code> secret file mounted as <em>/tmp/access/passphrase</em>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f ppconsumer.yaml</strong>&#13;
pod/ppconsumer created&#13;
&#13;
$ <strong>kubectl logs ppconsumer</strong>&#13;
tmpfs on /tmp/access type tmpfs (ro,relatime,size=7937656k)&#13;
</pre>&#13;
&#13;
<p>To access the passphrase from within the running container, simply read out the <em>passphrase</em> file in <em>/tmp/access</em>, like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl exec ppconsumer -i -t -- sh</strong>&#13;
&#13;
/ # cat /tmp/access/passphrase&#13;
open sesame&#13;
/ # exit&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id72">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Secrets exist in the context of a namespace, so you need to take that into account when setting them up and/or consuming them.<a data-primary="namespaces" data-secondary="secrets in" data-type="indexterm" id="id932"/></p>&#13;
&#13;
<p>You can access a secret from a container running in a <a data-primary="containers" data-secondary="accessing a secret from container running in a pod" data-type="indexterm" id="id933"/>pod via one of the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A volume (as shown in the Solution, where the content is stored in a <code>tmpfs</code> volume)</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Edsr5">Using the secret as an environment variable</a></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Also, note that the size of a secret is limited to 1 MiB.<a data-primary="environment variables" data-secondary="using secrets as" data-type="indexterm" id="id934"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><code>kubectl create secret</code> deals with three types of secrets, and depending on your use case, you might want to choose different <a data-primary="docker-registry type (secrets)" data-type="indexterm" id="id935"/><a data-primary="generic type (secrets)" data-type="indexterm" id="id936"/><a data-primary="kubectl" data-secondary="create secret command" data-type="indexterm" id="id937"/>ones:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>docker-registry</code> type is for use with a Docker  &#13;
<span class="keep-together">registry.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>generic</code> type is what we used in the Solution; it creates a secret from a local file, directory, or literal value (you need to base64-encode it yourself).<a data-primary="tls type secrets" data-type="indexterm" id="id938"/></p>&#13;
</li>&#13;
<li>&#13;
<p>With <code>tls</code> you can create, for example, a secure SSL  &#13;
<span class="keep-together">certificate</span> for ingress.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
<p><code>kubectl describe</code> doesn’t show the content of the secret in plain text. This avoids “over-the-shoulder” password grabs. <a data-primary="encryption" data-secondary="secrets and" data-type="indexterm" id="id939"/>You can, however, easily decode it manually since it’s not encrypted, only base64-encoded:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get secret pp -o yaml | \&#13;
    grep passphrase | \&#13;
    cut -d":" -f 2 | \&#13;
    awk '{$1=$1};1' | \&#13;
    base64 --decode</strong>&#13;
open sesame&#13;
</pre>&#13;
&#13;
<p>In this command, the first line retrieves a YAML representation of the secret, and the second line with the <code>grep</code> pulls out the line <code> passphrase: b3BlbiBzZXNhbWU=</code> (note the leading whitespace here). <a data-primary="grep command" data-type="indexterm" id="id940"/><a data-primary="cut command" data-type="indexterm" id="id941"/><a data-primary="awk command" data-type="indexterm" id="id942"/>Then, the <code>cut</code> extracts the content of the passphrase, and the <code>awk</code> command gets rid of the leading whitespace. Finally, the <code>base64</code> command turns it into the original data again.<a data-primary="base64 command" data-type="indexterm" id="id943"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You have the option to encrypt secrets at<a data-primary="encryption" data-secondary="encrypting secrets at rest" data-type="indexterm" id="id944"/> rest by using the <code class="keep-together">--encryption-provider-config</code> option when launching the <code>kube-apiserver</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id945">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes documentation on <a href="https://oreil.ly/cCddB">secrets</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Kubernetes documentation on <a href="https://oreil.ly/kAmrN">encrypting confidential data at rest</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.3 Providing Configuration Data to an Application" data-type="sect1"><div class="sect1" id="configmaps">&#13;
<h1>8.3 Providing Configuration Data to an Application</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id230">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to provide configuration data to an application without storing it in the container image or hardcoding it into the pod specification.<a data-primary="secrets" data-secondary="passing API access key to a pod using a secret" data-startref="ix_scrtAPIkey" data-type="indexterm" id="id946"/><a data-primary="APIs" data-secondary="passing API access key to a pod using a secret" data-startref="ix_APIkey" data-type="indexterm" id="id947"/><a data-primary="config maps" data-secondary="using to provide configuration data to application" data-type="indexterm" id="ix_cfgmp"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id231">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a config map. These are first-class Kubernetes resources with which you can provide configuration data to a pod via environment variables or a file.<a data-primary="environment variables" data-secondary="passing configuration data via" data-type="indexterm" id="id948"/><a data-primary="resources" data-secondary="config maps" data-type="indexterm" id="id949"/></p>&#13;
&#13;
<p>Let’s say you want to create a configuration with the key <code>siseversion</code> and the value <code>0.9</code>. It’s as simple as this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create configmap nginxconfig \&#13;
    --from-literal=nginxgreeting="hello from nginx"</strong>&#13;
configmap/nginxconfig created&#13;
</pre>&#13;
&#13;
<p>Now you can use<a data-primary="deployments" data-secondary="using config map in" data-type="indexterm" id="id950"/> the config map in a deployment—​say, in a manifest file with the following contents:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.25.2</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NGINX_GREETING</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginxconfig</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginxgreeting</code><code class="w"/></pre>&#13;
&#13;
<p>Save this YAML manifest as <em>nginxpod.yaml</em> and then use <code>kubectl</code> to create the pod:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f nginxpod.yaml</strong>&#13;
pod/nginx created&#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">You can then list the pod’s container environment variables with the following &#13;
<span class="keep-together">command:</span></p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl exec nginx -- printenv</strong>&#13;
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#13;
HOSTNAME=nginx&#13;
NGINX_GREETING=hello from nginx&#13;
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443&#13;
...&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id232">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>We’ve just shown how to pass in the configuration as an environment variable. However, you can also mount it into the pod as a file, using a volume.<a data-primary="volumes" data-secondary="mounting config file on" data-type="indexterm" id="id951"/></p>&#13;
&#13;
<p>Suppose you have the following config file, <em>example.cfg</em>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">debug:<code class="w"> </code><code class="nb">true</code><code class="w"/>&#13;
home:<code class="w"> </code>~/abc<code class="w"/></pre>&#13;
&#13;
<p>You can create a config map that holds the config file, as follows:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create configmap configfile --from-file=example.cfg</strong>&#13;
configmap/configfile created&#13;
</pre>&#13;
&#13;
<p>Now you can use the config map just as you would any other volume. <a data-primary="config maps" data-secondary="creating from a file and mounting on volume" data-type="indexterm" id="id952"/>The following is the manifest file for a pod named <code>oreilly</code>; it uses the <code>busybox</code> image and just sleeps for 3,600 seconds. In the <code>volumes</code> section, there is a volume named <code>oreilly</code> that uses the config map <code>configfile</code> we just created. This volume is then mounted at the path <code>/oreilly</code> inside the container. Hence, the file will be accessible within the pod:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">oreilly</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.36</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">sleep</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"3600"</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/oreilly</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">oreilly</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">oreilly</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">configMap</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">configfile</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">After creating the pod, you can verify that the <em>example.cfg</em> file is indeed inside it:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl exec -ti oreilly -- ls -l oreilly</strong>&#13;
total 0&#13;
lrwxrwxrwx   1 root   root   18 Mar 31 09:39 example.cfg -&gt; ..data/example.cfg&#13;
&#13;
$ <strong>kubectl exec -ti oreilly -- cat oreilly/example.cfg</strong>&#13;
debug: true&#13;
home: ~/abc&#13;
</pre>&#13;
&#13;
<p>For a complete example of how to create a config map from a file, see <a data-type="xref" href="ch11.html#prom_minikube">Recipe 11.7</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id953">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/R1FgU">“Configure a Pod to Use a ConfigMap”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.4 Using a Persistent Volume with Minikube" data-type="sect1"><div class="sect1" id="pv_minikube">&#13;
<h1>8.4 Using a Persistent Volume with Minikube</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id233">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You don’t want to lose data on a disk your container uses—​that is, you want to make sure it survives a restart of the hosting pod.<a data-primary="config maps" data-secondary="using to provide configuration data to application" data-startref="ix_cfgmp" data-type="indexterm" id="id954"/><a data-primary="Minikube" data-secondary="using a persistent volume with" data-type="indexterm" id="ix_MiniKpervol"/><a data-primary="persistent volumes" data-secondary="using with Minikube" data-type="indexterm" id="ix_persvol"/><a data-primary="volumes" data-secondary="using persistent volume with Minikube" data-type="indexterm" id="ix_volpers"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id73">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a persistent volume (PV). In the case of Minikube, you can create a PV of type <code>hostPath</code> and mount it just like a normal volume into the container’s filesystem.<a data-primary="hostPath type" data-type="indexterm" id="id955"/><a data-primary="PVs" data-see="persistent volumes" data-type="indexterm" id="id956"/></p>&#13;
&#13;
<p>First, define the PV <code>hostpathpv</code> in a manifest called <em>hostpath-pv.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolume</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hostpathpv</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">local</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">manual</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">capacity</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1Gi</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">hostPath</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="s">"/tmp/pvdata"</code><code class="w"/></pre>&#13;
&#13;
<p>Before you can create the PV, however, you need to prepare the directory <em>/tmp/pvdata</em> on the node—​that is, the Minikube instance itself. You can get into the node where the Kubernetes cluster is running using <code>minikube ssh</code>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>minikube ssh</strong>&#13;
&#13;
$ <strong>mkdir /tmp/pvdata &amp;&amp; \&#13;
    echo 'I am content served from a delicious persistent volume' &gt; \&#13;
    /tmp/pvdata/index.html</strong>&#13;
&#13;
$ <strong>cat /tmp/pvdata/index.html</strong>&#13;
I am content served from a delicious persistent volume&#13;
&#13;
$ <strong>exit</strong>&#13;
</pre>&#13;
&#13;
<p>Now that you’ve prepared the directory on the node, you can create the PV from the manifest file <em>hostpath-pv.yaml</em>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f hostpath-pv.yaml</strong>&#13;
persistentvolume/hostpathpv created&#13;
&#13;
$ <strong>kubectl get pv</strong>&#13;
NAME        CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      ...   ...   ...&#13;
hostpathpv  1Gi        RWO           Retain          Available   ...   ...   ...&#13;
&#13;
$ <strong>kubectl describe pv/hostpathpv</strong>&#13;
Name:            hostpathpv&#13;
Labels:          type=local&#13;
Annotations:     &lt;none&gt;&#13;
Finalizers:      [kubernetes.io/pv-protection]&#13;
StorageClass:    manual&#13;
Status:          Available&#13;
Claim:&#13;
Reclaim Policy:  Retain&#13;
Access Modes:    RWO&#13;
VolumeMode:      Filesystem&#13;
Capacity:        1Gi&#13;
Node Affinity:   &lt;none&gt;&#13;
Message:&#13;
Source:&#13;
    Type:          HostPath (bare host directory volume)&#13;
    Path:          /tmp/pvdata&#13;
    HostPathType:&#13;
Events:            &lt;none&gt;&#13;
</pre>&#13;
&#13;
<p>Up to this point, you would carry out these steps in an admin role. You would define PVs and make them available to developers on the Kubernetes cluster.</p>&#13;
&#13;
<p>Now you’re in a position to use the PV in a pod, from a developer’s perspective. This is done via a <em>persistent volume claim</em> (PVC), so called because, well, you literally claim a PV that fulfills certain characteristics, such as size or storage class.<a data-primary="persistent volume claim (PVC)" data-type="indexterm" id="id957"/><a data-primary="PVC" data-see="persistent volume claim" data-type="indexterm" id="id958"/></p>&#13;
&#13;
<p>Create a manifest file called <em>pvc.yaml</em> that defines a PVC, asking <a data-primary="manifests" data-secondary="defining persistent volume claim" data-type="indexterm" id="id959"/>for 200 MB of space:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolumeClaim</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mypvc</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">manual</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">200Mi</code><code class="w"/></pre>&#13;
&#13;
<p>Next, launch the PVC and verify its state:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f pvc.yaml</strong>&#13;
persistentvolumeclaim/mypvc created&#13;
&#13;
$ <strong>kubectl get pv</strong>&#13;
NAME        CAPACITY  ACCESSMODES  ...  STATUS  CLAIM          STORAGECLASS&#13;
hostpathpv  1Gi       RWO          ...  Bound   default/mypvc  manual&#13;
</pre>&#13;
&#13;
<p>Note that the status of the PV <code>hostpathpv</code> has changed from <code>Available</code> to <code>Bound</code>.</p>&#13;
&#13;
<p>Finally, it’s time to consume the data from the PV in a container, this time via a deployment that mounts it in the filesystem.<a data-primary="containers" data-secondary="consuming data from persistent volume in" data-type="indexterm" id="id960"/> So, create a file called <em>nginx-using-pv.yaml</em> with the following contents:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx-with-pv</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webserver</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.25.2</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/usr/share/nginx/html"</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webservercontent</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webservercontent</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">persistentVolumeClaim</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">claimName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mypvc</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">And launch the deployment, like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f nginx-using-pv.yaml</strong>&#13;
deployment.apps/nginx-with-pv created&#13;
&#13;
$ <strong>kubectl get pvc</strong>&#13;
NAME   STATUS  VOLUME      CAPACITY  ACCESSMODES  STORAGECLASS  AGE&#13;
mypvc  Bound   hostpathpv  1Gi       RWO          manual        12m&#13;
</pre>&#13;
&#13;
<p>As you can see, the <a data-primary="services" data-secondary="creating service to verify arrival of persistent volume data" data-type="indexterm" id="id961"/><a data-primary="ingress" data-secondary="Ingress object" data-type="indexterm" id="id962"/>PV is in use via the PVC you created earlier.</p>&#13;
&#13;
<p>To verify that the data actually has arrived, you could now create a service (see <a data-type="xref" href="ch05.html#simple_service">Recipe 5.1</a>) along with an <code>Ingress</code> object (see <a data-type="xref" href="ch05.html#ingress">Recipe 5.5</a>) and then access it like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl -k -s https://192.168.99.100/web</strong>&#13;
I am content served from a delicious persistent volume&#13;
</pre>&#13;
&#13;
<p>Well done! You’ve (as an admin) provisioned a persistent volume and (as a developer) claimed it via a persistent volume claim and used it from a deployment in a pod by mounting it into the container filesystem.<a data-primary="Amazon Web Services" data-see="AWS" data-type="indexterm" id="id963"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id74">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In the Solution, we used a persistent volume of type <code>hostPath</code>. <a data-primary="hostPath type" data-type="indexterm" id="id964"/>In a production setting, you would not want to use this but rather ask your cluster administrator nicely to provision a networked volume backed by NFS or an Amazon Elastic Block Store (EBS) volume to make sure your data sticks around and survives single-node failures.<a data-primary="AWS (Amazon Web Services)" data-secondary="Elastic Block Store (EBS) volumes" data-type="indexterm" id="id965"/><a data-primary="NFS, networked volume backed by" data-type="indexterm" id="id966"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember that PVs are cluster-wide resources; that is, they are not namespaced. However, PVCs are namespaced. You can claim PVs from specific namespaces using namespaced PVCs.<a data-primary="namespaces" data-secondary="persistent volumes and persistent volume claims" data-type="indexterm" id="id967"/><a data-primary="clusters" data-secondary="persistent volumes as cluster-wide resources" data-type="indexterm" id="id968"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id969">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes <a href="https://oreil.ly/IMCId">persistent volumes documentation</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/sNDkp">“Configure a Pod to Use a PersistentVolume for Storage”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.5 Understanding Data Persistency on Minikube" data-type="sect1"><div class="sect1" id="pvc_minikube">&#13;
<h1>8.5 Understanding Data Persistency on Minikube</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id75">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to use Minikube to deploy a stateful application in Kubernetes.<a data-primary="volumes" data-secondary="using persistent volume with Minikube" data-startref="ix_volpers" data-type="indexterm" id="id970"/><a data-primary="persistent volumes" data-secondary="using with Minikube" data-startref="ix_persvol" data-type="indexterm" id="id971"/><a data-primary="Minikube" data-secondary="using a persistent volume with" data-startref="ix_MiniKpervol" data-type="indexterm" id="id972"/> Specifically, you would like to deploy a MySQL database.<a data-primary="persistence, data persistence on Minikube" data-type="indexterm" id="ix_persMini"/><a data-primary="Minikube" data-secondary="data persistency on" data-type="indexterm" id="ix_MiniKdapers"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id76">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a <code>PersistentVolumeClaim</code> object (see <a data-type="xref" href="#pv_minikube">Recipe 8.4</a>) in your pod definition and/or the template for your database.<a data-primary="persistent volume claim (PVC)" data-secondary="PersistentVolumeClaim object, using in pod definition or database template" data-type="indexterm" id="id973"/></p>&#13;
&#13;
<p>First you need to make a request for a specific amount of storage. The following <em>data.yaml</em> manifest makes a request for 1 GB of storage:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolumeClaim</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">data</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1Gi</code><code class="w"/></pre>&#13;
&#13;
<p>On Minikube, create this PVC and immediately see how a persistent volume is created to match<a data-primary="persistent volumes" data-secondary="created on Minikube to match persistent volume claim" data-type="indexterm" id="id974"/> this claim:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f data.yaml</strong>&#13;
persistentvolumeclaim/data created&#13;
&#13;
$ <strong>kubectl get pvc</strong>&#13;
NAME  STATUS  VOLUME                                    CAPACITY ...  ...  ...&#13;
data  Bound   pvc-da58c85c-e29a-11e7-ac0b-080027fcc0e7  1Gi      ...  ...  ...&#13;
&#13;
$ <strong>kubectl get pv</strong>&#13;
NAME                                      CAPACITY  ...  ...  ...  ...  ...&#13;
pvc-da58c85c-e29a-11e7-ac0b-080027fcc0e7  1Gi       ...  ...  ...  ...  ...&#13;
</pre>&#13;
&#13;
<p>You are now ready to use this claim in your pod. In the <code>volumes</code> section of the pod manifest, define a volume by name with a PVC type and a reference to the PVC you just created.<a data-primary="volumeMounts field" data-type="indexterm" id="id975"/><a data-primary="MySQL" data-secondary="mounting persistent volume for in container" data-type="indexterm" id="id976"/></p>&#13;
&#13;
<p>In the <code>volumeMounts</code> field, you’ll mount this volume at a specific path inside your container. For MySQL, you mount it at <code>/var/lib/mysql</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql:8.1.0</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/lib/mysql</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">data</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MYSQL_ROOT_PASSWORD</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">root</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">data</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">persistentVolumeClaim</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">claimName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">data</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id77">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Minikube is configured out of the box with a default storage class that defines a default persistent volume provisioner.<a data-primary="storage classes" data-type="indexterm" id="id977"/> This means that when a persistent volume claim is created, Kubernetes will dynamically create a matching persistent volume to fill that claim.</p>&#13;
&#13;
<p>This is what happened in the Solution. When you created the persistent volume claim called <code>data</code>, Kubernetes automatically created a persistent volume to match that claim. If you look a bit deeper at the default storage class on Minikube, you will see the provisioner type:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get storageclass</strong>&#13;
NAME                 PROVISIONER                ...&#13;
standard (default)   k8s.io/minikube-hostpath   ...&#13;
&#13;
$ <strong>kubectl get storageclass standard -o yaml</strong>&#13;
apiVersion: storage.k8s.io/v1&#13;
kind: StorageClass&#13;
...&#13;
provisioner: k8s.io/minikube-hostpath&#13;
reclaimPolicy: Delete&#13;
</pre>&#13;
&#13;
<p>This specific storage class is using a storage provisioner that creates persistent volumes of type <code>hostPath</code>. You can see this by looking at the manifest of the PV that got created to match the claim you created previously:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get pv</strong>&#13;
NAME                                       CAPACITY   ... CLAIM         ...&#13;
pvc-da58c85c-e29a-11e7-ac0b-080027fcc0e7   1Gi        ... default/data  ...&#13;
&#13;
$ <strong>kubectl get pv pvc-da58c85c-e29a-11e7-ac0b-080027fcc0e7 -o yaml</strong>&#13;
apiVersion: v1&#13;
kind: PersistentVolume&#13;
...&#13;
  hostPath:&#13;
    path: /tmp/hostpath-provisioner/default/data&#13;
    type: ""&#13;
...&#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">To verify that the host volume created holds the database <code>data</code>, you can connect to Minikube and list the files in the directory:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>minikube ssh</strong>&#13;
&#13;
$ <strong>ls -l /tmp/hostpath-provisioner/default/data</strong>&#13;
total 99688&#13;
...&#13;
drwxr-x--- 2 999 docker     4096 Mar 31 11:11  mysql&#13;
-rw-r----- 1 999 docker 31457280 Mar 31 11:11  mysql.ibd&#13;
lrwxrwxrwx 1 999 docker       27 Mar 31 11:11  mysql.sock -&gt; /var/run/mysqld/...&#13;
drwxr-x--- 2 999 docker     4096 Mar 31 11:11  performance_schema&#13;
-rw------- 1 999 docker     1680 Mar 31 11:11  private_key.pem&#13;
-rw-r--r-- 1 999 docker      452 Mar 31 11:11  public_key.pem&#13;
...&#13;
</pre>&#13;
&#13;
<p>Indeed, you now have data persistence. If the pod dies (or you delete it), your data will still be available.</p>&#13;
&#13;
<p>In general, storage classes allow the cluster administrator to define the various types of storage they might provide. <a data-primary="storage classes" data-secondary="uses by administrators and developers" data-type="indexterm" id="id978"/>For the developers, this abstracts the type of storage and lets them use PVCs without having to worry about the storage provider itself.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id979">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/8CRZI">Kubernetes persistent volume claim documentation</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/32-fw">Kubernetes storage class documentation</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.6 Storing Encrypted Secrets in Version Control" data-type="sect1"><div class="sect1" id="sealedsecrets">&#13;
<h1>8.6 Storing Encrypted Secrets in Version Control</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id78">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to store all your Kubernetes manifests in version control and safely share them (even publicly), including secrets.<a data-primary="encryption" data-secondary="storing encrypted secrets in version control" data-type="indexterm" id="ix_encrscrt"/><a data-primary="Minikube" data-secondary="data persistency on" data-startref="ix_MiniKdapers" data-type="indexterm" id="id980"/><a data-primary="persistence, data persistence on Minikube" data-startref="ix_persMini" data-type="indexterm" id="id981"/><a data-primary="secrets" data-secondary="encrypted, storing in version control" data-type="indexterm" id="ix_scrtencr"/><a data-primary="version control, storing encrypted secrets in" data-type="indexterm" id="ix_verctrl"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id79">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <a href="https://oreil.ly/r-83j">sealed-secrets</a>. Sealed-secrets<a data-primary="sealed-secrets" data-type="indexterm" id="ix_sealscrt"/> is a Kubernetes controller that decrypts one-way encrypted secrets and creates in-cluster <code>Secret</code> objects (see <a data-type="xref" href="#special_volumes">Recipe 8.2</a>).</p>&#13;
&#13;
<p>To get started, install the <code>v0.23.1</code> release of the sealed-secrets controller from the <a href="https://oreil.ly/UgMpf">release page</a>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/&#13;
releases/download/v0.23.1/controller.yaml</strong>&#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">The result will be that you have a <a data-primary="kube-system namespace" data-type="indexterm" id="id982"/>new custom resource and a new pod running in the <code>kube-system</code> namespace:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get customresourcedefinitions</strong>&#13;
NAME                        CREATED AT&#13;
sealedsecrets.bitnami.com   2023-01-18T09:23:33Z&#13;
&#13;
$ <strong>kubectl get pods -n kube-system  -l name=sealed-secrets-controller</strong>&#13;
NAME                                         READY   STATUS    RESTARTS   AGE&#13;
sealed-secrets-controller-7ff6f47d47-dd76s   1/1     Running   0          2m22s&#13;
</pre>&#13;
&#13;
<p>Next, download the corresponding release of the <code>kubeseal</code> binary from the <a href="https://oreil.ly/UgMpf">release page</a>. <a data-primary="kubeseal" data-type="indexterm" id="id983"/>This tool will allow you to encrypt your secrets.</p>&#13;
&#13;
<p>For example, on macOS (amd64), do the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>wget https://github.com/bitnami-labs/sealed-secrets/releases/download/&#13;
v0.23.1/kubeseal-0.23.1-darwin-amd64.tar.gz</strong>&#13;
&#13;
$ <strong>tar xf kubeseal-0.23.1-darwin-amd64.tar.gz</strong>&#13;
&#13;
$ <strong>sudo install -m 755 kubeseal /usr/local/bin/kubeseal</strong>&#13;
&#13;
$ <strong>kubeseal --version</strong>&#13;
kubeseal version: 0.23.1&#13;
</pre>&#13;
&#13;
<p>You are now ready to start using sealed-secrets. First, generate a generic secret manifest:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create secret generic oreilly --from-literal=password=root -o json \&#13;
    --dry-run=client &gt; secret.json</strong>&#13;
&#13;
$ <strong>cat secret.json</strong>&#13;
{&#13;
    "kind": "Secret",&#13;
    "apiVersion": "v1",&#13;
    "metadata": {&#13;
        "name": "oreilly",&#13;
        "creationTimestamp": null&#13;
    },&#13;
    "data": {&#13;
        "password": "cm9vdA=="&#13;
    }&#13;
}&#13;
</pre>&#13;
&#13;
<p>Then use the <code>kubeseal</code> command to generate the new custom <code>SealedSecret</code> object:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubeseal &lt; secret.json &gt; sealedsecret.json</strong>&#13;
&#13;
$ <strong>cat sealedsecret.json</strong>&#13;
{&#13;
  "kind": "SealedSecret",&#13;
  "apiVersion": "bitnami.com/v1alpha1",&#13;
  "metadata": {&#13;
    "name": "oreilly",&#13;
    "namespace": "default",&#13;
    "creationTimestamp": null&#13;
  },&#13;
  "spec": {&#13;
    "template": {&#13;
      "metadata": {&#13;
        "name": "oreilly",&#13;
        "namespace": "default",&#13;
        "creationTimestamp": null&#13;
      }&#13;
    },&#13;
    "encryptedData": {&#13;
      "password": "AgCyN4kBwl/eLt7aaaCDDNlFDp5s93QaQZZ/mm5BJ6SK1WoKyZ45hz..."&#13;
    }&#13;
  }&#13;
}&#13;
</pre>&#13;
&#13;
<p>Create the <code>SealedSecret</code> object using the <a data-primary="sealed-secrets" data-secondary="creating SealedSecret object" data-type="indexterm" id="id984"/>following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f sealedsecret.json</strong>&#13;
sealedsecret.bitnami.com/oreilly created&#13;
</pre>&#13;
&#13;
<p>You can now store <em>sealedsecret.json</em> safely in version control.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id80">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Once you create the <code>SealedSecret</code> object, the controller will detect it, decrypt it, and generate the corresponding secret.</p>&#13;
&#13;
<p>Your sensitive information is encrypted into a <code>SealedSecret</code> object, which is a custom resource (see <a data-type="xref" href="ch15.html#writing_crd">Recipe 15.4</a>). The <code>SealedSecret</code> is safe to store under version control and share, even publicly. Once a <code>SealedSecret</code> is created on the Kubernetes API server, only the private key stored in the sealed-secret controller can decrypt it and create the corresponding <code>Secret</code> object (which is only base64-encoded). <a data-primary="secrets" data-secondary="Secret object corresponding to SealedSecret" data-type="indexterm" id="id985"/>Nobody else, including the original author, can decrypt the original <code>Secret</code> from the <code>Se⁠al⁠ed​Se⁠cr⁠et</code>.</p>&#13;
&#13;
<p>While users cannot decrypt the original <code>Secret</code> from the <code>SealedSecret</code>, they may be able to access the unsealed <code>Secret</code> from the cluster. You should configure RBAC to forbid low-privilege users from reading <code>Secret</code> objects from namespaces that they have restricted access to.<a data-primary="RBAC (role-based access control)" data-secondary="configuring to forbid low-privilege users from reading Secret objects" data-type="indexterm" id="id986"/><a data-primary="secrets" data-secondary="RBAC access control to forbid low-privilege users reading Secret objects" data-type="indexterm" id="id987"/></p>&#13;
&#13;
<p>You can list the <code>SealedSecret</code> objects in the current namespace <a data-primary="sealed-secrets" data-startref="ix_sealscrt" data-type="indexterm" id="id988"/><a data-primary="encryption" data-secondary="storing encrypted secrets in version control" data-startref="ix_encrscrt" data-type="indexterm" id="id989"/><a data-primary="version control, storing encrypted secrets in" data-startref="ix_verctrl" data-type="indexterm" id="id990"/><a data-primary="secrets" data-secondary="encrypted, storing in version control" data-startref="ix_scrtencr" data-type="indexterm" id="id991"/>using the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get sealedsecret</strong>&#13;
NAME      AGE&#13;
oreilly   14s&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id992">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/SKVWq">The sealed-secrets project on GitHub</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Angus Lees’s article <a href="https://oreil.ly/Ie3nB">“Sealed Secrets: Protecting Your Passwords Before They Reach Kubernetes”</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>