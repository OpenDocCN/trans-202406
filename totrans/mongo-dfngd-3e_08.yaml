- en: Chapter 6\. Special Index and Collection Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the special collections and index types MongoDB has available,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: Capped collections for queue-like data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TTL indexes for caches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full-text indexes for simple string searching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geospatial indexes for 2D and spherical geometries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GridFS for storing large files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geospatial Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB has two types of geospatial indexes: `2dsphere` and `2d`. `2dsphere`
    indexes work with spherical geometries that model the surface of the earth based
    on the WGS84 datum. This datum models the surface of the earth as an oblate spheroid,
    meaning that there is some flattening at the poles. Distance calculations using
    `2sphere` indexes, therefore, take the shape of the earth into account and provide
    a more accurate treatment of distance between, for example, two cities, than do
    `2d` indexes. Use `2d` indexes for points stored on a two-dimensional plane.'
  prefs: []
  type: TYPE_NORMAL
- en: '`2dsphere` allows you to specify geometries for points, lines, and polygons
    in the [GeoJSON format](http://www.geojson.org/). A point is given by a two-element
    array, representing [*`longitude`*, *`latitude`*]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A line is given by an array of points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A polygon is specified the same way a line is (an array of points), but with
    a different `"type"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The field that we are naming, `"loc"` in this example, can be called anything,
    but the field names in the embedded object are specified by GeoJSON and cannot
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a geospatial index using the `"2dsphere"` type with `` `createIndex`
    ``:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To create a `2dsphere` index, pass a document to `createIndex` that specifies
    the field containing geometries you want to index for the collection in question
    and specify `"2dsphere"` as the value.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Geospatial Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three types of geospatial queries that you can perform: intersection,
    within, and nearness. You specify what you’re looking for as a GeoJSON object
    that looks like ``{"$geometry" : *`geoJsonDesc`*}``.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can find documents that intersect the query’s location using
    the `"$geoIntersects"` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This would find all point-, line-, and polygon-containing documents that had
    a point in the East Village in New York City.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `"$geoWithin"` to query for things that are completely contained
    in an area (for instance, “What restaurants are in the East Village?”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unlike our first query, this will not return things that merely pass through
    the East Village (such as streets) or partially overlap it (such as a polygon
    describing Manhattan).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can query for nearby locations with `"$near"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `"$near"` is the only geospatial operator that implies a sort: results
    from `"$near"` are always returned in order of distance, from closest to farthest.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Geospatial Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB’s geospatial indexing allows you to efficiently execute spatial queries
    on a collection that contains geospatial shapes and points. To showcase the capabilities
    of geospatial features and compare different approaches, we will go through the
    process of writing queries for a simple geospatial application. We’ll go a little
    deeper into a few concepts central to geospatial indexes and then demonstrate
    their use with `"$geoWithin"`, `"$geoIntersects"`, and `"$geoNear"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we are designing a mobile application to help users find restaurants
    in New York City. The application must:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the neighborhood the user is currently in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the number of restaurants in that neighborhood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find restaurants within a specified distance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use a `2dsphere` index to query on this spherical geometry data.
  prefs: []
  type: TYPE_NORMAL
- en: 2D versus spherical geometry in queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Geospatial queries can use either spherical or 2D (flat) geometries, depending
    on both the query and the type of index in use. [Table 6-1](#table0601) shows
    what kind of geometry each geospatial operator uses.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Query types and geometries in MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: '| Query type | Geometry type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$near` (GeoJSON point, `2dsphere` index) | Spherical |'
  prefs: []
  type: TYPE_TB
- en: '| `$near` (legacy coordinates, `2d` index) | Flat |'
  prefs: []
  type: TYPE_TB
- en: '| `$geoNear` (GeoJSON point, `2dsphere` index) | Spherical |'
  prefs: []
  type: TYPE_TB
- en: '| `$geoNear` (legacy coordinates, `2d` index) | Flat |'
  prefs: []
  type: TYPE_TB
- en: '| `$nearSphere` (GeoJSON point, `2dsphere` index) | Spherical |'
  prefs: []
  type: TYPE_TB
- en: '| `$nearSphere` (legacy coordinates, `2d` index)^([a](ch06.xhtml#idm45882368776472))
    | Spherical |'
  prefs: []
  type: TYPE_TB
- en: '| `$geoWithin : { $geometry: ... }` | Spherical |'
  prefs: []
  type: TYPE_TB
- en: '| `$geoWithin: { $box: ... }` | Flat |'
  prefs: []
  type: TYPE_TB
- en: '| `$geoWithin: { $polygon: ... }` | Flat |'
  prefs: []
  type: TYPE_TB
- en: '| `$geoWithin : { $center: ... }` | Flat |'
  prefs: []
  type: TYPE_TB
- en: '| `$geoWithin : { $centerSphere: ... }` | Spherical |'
  prefs: []
  type: TYPE_TB
- en: '| `$geoIntersects` | Spherical |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch06.xhtml#idm45882368776472-marker)) Use GeoJSON points instead. |'
  prefs: []
  type: TYPE_TB
- en: Note also that `2d` indexes support both flat geometries and distance-only calculations
    on spheres (i.e., using `$nearSphere`). However, queries using spherical geometries
    will be more performant and accurate with a `2dsphere` index.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the `$geoNear` operator is an aggregation operator. The aggregation
    framework is discussed in [Chapter 7](ch07.xhtml#chapter_d1e6036). In addition
    to the `$near` query operation, the `$geoNear` aggregation operator and the special
    command `geoNear` enable us to query for nearby locations. Keep in mind that the
    `$near` query operator will not work on collections that are distributed using
    sharding, MongoDB’s scaling solution (see [Chapter 15](ch15.xhtml#chapter-shard-config)).
  prefs: []
  type: TYPE_NORMAL
- en: The `geoNear` command and the `$geoNear` aggregation operator require that a
    collection have at most one `2dsphere` index and at most one `2d` index, whereas
    geospatial query operators (e.g., `$near` and `$geoWithin`) permit collections
    to have multiple geospatial indexes.
  prefs: []
  type: TYPE_NORMAL
- en: The geospatial index restriction for the `geoNear` command and the `$geoNear`
    aggregation operator exists because neither the `geoNear` command nor the `$geoNear`
    syntax includes the location field. As such, index selection among multiple `2d`
    indexes or `2dsphere` indexes is ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: No such restriction applies for geospatial query operators; these operators
    take a location field, eliminating the ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Distortion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spherical geometry will appear distorted when visualized on a map due to the
    nature of projecting a three-dimensional sphere, such as the earth, onto a flat
    plane.
  prefs: []
  type: TYPE_NORMAL
- en: For example, take the specification of the spherical square defined by the longitude,
    latitude points (0,0), (80,0), (80,80), and (0,80). [Figure 6-1](#fig0601) depicts
    the area covered by this region.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mdb3_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. The spherical square defined by the points (0,0), (80,0), (80,
    80), and (0,80)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Searching for restaurants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we will work with [neighborhood](https://oreil.ly/rpGna) and
    [restaurant](https://oreil.ly/JXYd-) datasets based in New York City. You can
    download the example datasets from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import the datasets into our database using the `mongoimport` tool as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a `2dsphere` index on each collection using the `createIndex`
    command in the [*mongo* shell](https://oreil.ly/NMUhn):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Exploring the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can get a sense for the schema used for documents in these collections with
    a couple of quick queries in the *mongo* shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The neighborhood document in the previous code corresponds to the area of New
    York City shown in [Figure 6-2](#fig0602).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mdb3_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. The Hell’s Kitchen (Clinton) neighborhood of New York City
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The bakery corresponds to the location shown in [Figure 6-3](#fig0603).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mdb3_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. The Little Pie Company at 424 West 43rd Street
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finding the current neighborhood
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming the user’s mobile device can give a reasonably accurate location user,
    it is simple to find the user’s current neighborhood with `$geoIntersects`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the user is located at −73.93414657 longitude and 40.82302903 latitude.
    To find the current neighborhood (Hell’s Kitchen), we can specify a point using
    the special `$geometry` field in GeoJSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This query will return the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finding all restaurants in the neighborhood
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also query to find all restaurants contained in a given neighborhood.
    To do so, we can execute the following in the *mongo* shell to find the neighborhood
    containing the user, and then count the restaurants within that neighborhood.
    For example, to find all the restaurants in the Hell’s Kitchen neighborhood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This query will tell you that there are 127 restaurants in the requested neighborhood
    that have the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finding restaurants within a distance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find restaurants within a specified distance of a point, you can use either
    `"$geoWithin"` with `"$centerSphere"` to return results in unsorted order, or
    `"$nearSphere"` with `"$maxDistance"` if you need results sorted by distance.
  prefs: []
  type: TYPE_NORMAL
- en: To find restaurants within a circular region, use `"$geoWithin"` with `"$centerSphere"`.
    `"$centerSphere"` is a MongoDB-specific syntax to denote a circular region by
    specifying the center and the radius in radians. `"$geoWithin"` does not return
    the documents in any specific order, so it might return the furthest documents
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will find all restaurants within five miles of the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`"$centerSphere"`’s second argument accepts the radius in radians. The query
    converts the distance to radians by dividing by the approximate equatorial radius
    of the earth, 3963.2 miles.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications can use `"$centerSphere"` without having a geospatial index. However,
    geospatial indexes support much faster queries than the unindexed equivalents.
    Both `2dsphere` and `2d` geospatial indexes support `"$centerSphere"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also use `"$nearSphere"` and specify a `"$maxDistance"` term in meters.
    This will return all restaurants within five miles of the user in sorted order
    from nearest to farthest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Compound Geospatial Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with other types of indexes, you can combine geospatial indexes with other
    fields to optimize more complex queries. A possible query mentioned earlier was:
    “What restaurants are in Hell’s Kitchen?” Using only a geospatial index, we could
    narrow the field to everything in Hell’s Kitchen, but narrowing it down to only
    “restaurants” or “pizza” would require another field in the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can quickly find a pizza place in Hell’s Kitchen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can have the “vanilla” index field either before or after the `"2dsphere"`
    field, depending on whether we’d like to filter by the vanilla field or the location
    first. Choose whichever is more selective (i.e., will filter out more results
    as the first index term).
  prefs: []
  type: TYPE_NORMAL
- en: 2d Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For nonspherical maps (videogame maps, time series data, etc.) you can use
    a `"2d"` index instead of `"2dsphere"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`2d` indexes assume a perfectly flat surface, instead of a sphere. Thus, `2d`
    indexes should not be used with spheres unless you don’t mind massive distortion
    around the poles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Documents should use a two-element array for their `"2d"` indexed field. The
    elements in this array should reflect the longitude and lattitude coordinates,
    respectively. A sample document might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not use a `2d` index if you plan to store GeoJSON data—they can only index
    points. You can store an array of points, but it will be stored as exactly that:
    an array of points, not a line. This is an important distinction for `"$geoWithin"`
    queries, in particular. If you store a street as an array of points, the document
    will match `"$geoWithin"` if one of those points is within the given shape. However,
    the line created by those points might not be wholly contained in the shape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `2d` indexes assume that your values are going to range from −180
    to 180\. If you are expecting larger or smaller bounds, you can specify what the
    minimum and maximum values will be as options to `createIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will create a spatial index calibrated for a 2,000 × 2,000 square.
  prefs: []
  type: TYPE_NORMAL
- en: '`2d` indexes support the `"$geoWithin"`, `"$nearSphere"`, and `"$near"` query
    selectors. Use `"$geoWithin"` to query for points within a shape defined on a
    flat surface. `"$geoWithin"` can query for all points within a rectangle, polygon,
    circle, or sphere; it uses the `"$geometry"` operator to specify the GeoJSON object.
    Returning to our grid indexed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'the following queries for documents within a rectangle defined by [10, 10]
    at the bottom-left corner and by [100, 100] at the top-right corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`$box` takes a two-element array: the first element specifies the coordinates
    of the lower-left corner and the second element the upper right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To query for documents that are within the circle centered on [−17 , 20.5]
    and with a radius of 25 we can issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following query returns all documents with coordinates that exist within
    the polygon defined by [0, 0], [3, 6], and [6 , 0]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You specify a polygon as an array of points. The final point in the list will
    be “connected to” the first point to form the polygon. This example would locate
    all documents containing points within the given triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB also supports rudimentary spherical queries on flat `2d` indexes for
    legacy reasons. In general, spherical calculations should use a 2dsphere index,
    as described in [“2D versus spherical geometry in queries”](#twod_vs_sgq). However,
    to query for legacy coordinate pairs within a sphere, use `"$geoWithin"` with
    the “`$centerSphere”` operator. Specify an array that contains:'
  prefs: []
  type: TYPE_NORMAL
- en: The grid coordinates of the circle’s center point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The circle’s radius measured in radians
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To query for nearby points, use `"$near"`. Proximity queries return the documents
    with coordinate pairs closest to the defined point and sort the results by distance.
    This finds all of the documents in the *hyrule* collection in order by distance
    from the point (20, 21):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A default limit of 100 documents is applied if no limit is specified. If you
    don’t need that many results, you should set a limit to conserve server resources.
    For example, the following code returns the 10 documents nearest to (20, 21):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Indexes for Full Text Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`text` indexes in MongoDB support full-text search requirements. This type
    of `text` index should not be confused with the MongoDB Atlas Full-Text Search
    Indexes, which utilize Apache Lucene for additional text search capabilities when
    compared to MongoDB text indexes. Use a `text` index if your application needs
    to enable users to submit keyword queries that should match titles, descriptions,
    and text in other fields within a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we’ve queried for strings using exact matches and regular
    expressions, but these techniques have some limitations. Searching a large block
    of text for a regular expression is slow, and it’s tough to take morphology (e.g.,
    that “entry” should match “entries”) and other challenges presented by human language
    into account. `text` indexes give you the ability to search text quickly and provide
    support for common search engine requirements such as language-appropriate tokenization,
    stop words, and stemming.
  prefs: []
  type: TYPE_NORMAL
- en: '`text` indexes require a number of keys proportional to the words in the fields
    being indexed. As a consequence, creating a `text` index can consume a large amount
    of system resources. You should create such an index at a time when it will not
    negatively impact the performance of your application for users or build the index
    in the background, if possible. To ensure good performance, as with all indexes,
    you should also take care that any `text` index you create fits in RAM. See [Chapter 19](ch19.xhtml#chapter-data-admin)
    for more information on creating indexes with minimal impact on your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Writes to a collection require that all indexes are updated. If you are using
    text search, strings will be tokenized and stemmed and the index updated in, potentially,
    many places. For this reason, writes involving `text` indexes are usually more
    expensive than writes to single-field, compound, or even multikey indexes. Thus,
    you will tend to see poorer write performance on `text`-indexed collections than
    on others. They will also slow down data movement if you are sharding: all text
    must be reindexed when it is migrated to a new shard.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Text Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we have a collection of Wikipedia articles that we want to index. To
    run a search over the text, we first need to create a `text` index. The following
    call to `createIndex` will create the index based on the terms in both the `"title"`
    and `"body"` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not like a “normal” compound index where there is an ordering on the
    keys. By default, each field is given equal consideration in a `text` index. You
    can control the relative importance MongoDB attaches to each field by specifying
    weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This would weight the `"title"` field at a ratio of 3:2 in comparison to the
    `"body"` field.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot change field weights after index creation (without dropping the index
    and recreating it), so you may want to play with weights on a sample dataset before
    creating the index on your production data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some collections, you may not know which fields a document will contain.
    You can create a full-text index on all string fields in a document by creating
    an index on `"$**"`—this not only indexes all top-level string fields, but also
    searches embedded documents and arrays for string fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Text Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `"$text"` query operator to perform text searches on a collection with
    a `text` index. `"$text"` will tokenize the search string using whitespace and
    most punctuation as delimiters, and perform a logical OR of all such tokens in
    the search string. For example, you could use the following query to find all
    articles containing any of the terms “impact,” “crater,” or “lunar.” Note that
    because our index is based on terms in both the title and body of an article,
    this query will match documents in which those terms are found in either field.
    For the purposes of this example, we will project the title so that we can fit
    more results on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the results with our initial query are not terribly relevant.
    As with all technologies, it’s important to have a good grasp of how `text` indexes
    work in MongoDB in order to use them effectively. In this case, there are two
    problems with the way we’ve issued the query. The first is that our query is pretty
    broad, given that MongoDB issues the query using a logical OR of “impact,” “crater,”
    and “lunar.” The second problem is that, by default, a text search does not sort
    the results by relevance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can begin to address the problem of the query itself by using a phrase in
    our query. You can search for exact phrases by wrapping them in double quotes.
    For example, the following will find all documents containing the phrase “impact
    crater.” Possibly surprising is that MongoDB will issue this query as “impact
    crater” AND “lunar”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure the semantics of this are clear, let’s look at an expanded example.
    For the following query, MongoDB will issue the query as “impact crater” AND (“lunar”
    OR “meteor”). MongoDB performs a logical AND of the phrase with the individual
    terms in the search string and a logical OR of the individual terms with one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to issue a logical AND between individual terms in a query, treat
    each term as a phrase by wrapping it in quotes. The following query will return
    documents containing “impact crater” AND “lunar” AND “meteor”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a better understanding of using phrases and logical ANDs in
    your queries, let’s return to the problem of the results not being sorted by relevance.
    While the preceding results are certainly relevant, this is mostly due to the
    fairly strict query we’ve issued. We can do better by sorting for relevance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Text queries cause some metadata to be associated with each query result. The
    metadata is not displayed in the query results unless we explicitly project it
    using the `$meta` operator. So, in addition to the title, we will project the
    relevance score calculated for each document. The relevance score is stored in
    the metadata field named `"textScore"`. For this example, we’ll return to our
    query of “impact crater” AND “lunar”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can see the relevance score projected with the title for each result.
    Note that they are not sorted. To sort the results in order of relevance score,
    we must add a call to `sort`, again using `$meta` to specify the `"textScore"`
    field value. Note that we must use the same field name in our sort as we used
    in our projection. In this case, we used the field name `"score"` for the relevance
    score value displayed in our search results. As you can see, the results are now
    sorted in decreasing order of relevance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Text search is also available in the aggregation pipeline. We discuss the aggregation
    pipeline in [Chapter 7](ch07.xhtml#chapter_d1e6036).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Full-Text Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a couple of ways to optimize full-text searches. If you can first
    narrow your search results by other criteria, you can create a compound index
    with a prefix of those criteria and then the full-text fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is referred to as *partitioning* the full-text index, as it breaks it into
    several smaller trees based on `"date"` (in this example). This makes full-text
    searches for a specific date or date range much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a postfix of other criteria to cover queries with the index.
    For example, if we were only returning the `"author"` and `"post"` fields, we
    could create a compound index on both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These prefix and postfix forms can be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Searching in Other Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a document is inserted (or the index is first created), MongoDB looks at
    the index’s fields and stems each word, reducing it to an essential unit. However,
    different languages stem words in different ways, so you must specify what language
    the index or document is in. `text` indexes allow a `"default_language"` option
    to be specified, which defaults to `"english"` but can be set to a number of other
    languages (see the [online documentation](https://oreil.ly/eUt0Z) for an up-to-date
    list).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to create a French-language index, we could say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then French would be used for stemming, unless otherwise specified. You can,
    on a per-document basis, specify another stemming language by having a `"language"`
    field that describes the document’s language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Capped Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “Normal” collections in MongoDB are created dynamically and automatically grow
    in size to fit additional data. MongoDB also supports a different type of collection,
    called a *capped collection*, which is created in advance and is fixed in size
    (see [Figure 6-4](#figure_d1e7559)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mdb3_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. New documents are inserted at the end of the queue
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Having fixed-size collections brings up an interesting question: what happens
    when we try to insert into a capped collection that is already full? The answer
    is that capped collections behave like circular queues: if we’re out of space,
    the oldest document will be deleted, and the new one will take its place (see
    [Figure 6-5](#figure_d1e7572)). This means that capped collections automatically
    age out the oldest documents as new documents are inserted.'
  prefs: []
  type: TYPE_NORMAL
- en: Certain operations are not allowed on capped collections. Documents cannot be
    removed or deleted (aside from the automatic age-out described earlier), and updates
    that would cause documents to grow in size are disallowed. By preventing these
    two operations, we guarantee that documents in a capped collection are stored
    in insertion order and that there is no need to maintain a free list for space
    from removed documents.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mdb3_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. When the queue is full, the oldest element will be replaced by
    the newest
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Capped collections have a different access pattern than most MongoDB collections:
    data is written sequentially over a fixed section of disk. This makes them tend
    to perform writes quickly on spinning disks, especially if they can be given their
    own disk (so as not to be “interrupted” by other collections’ random writes).'
  prefs: []
  type: TYPE_NORMAL
- en: In general, MongoDB TTL indexes are recommended over capped collections because
    they perform better with the WiredTiger storage engine. TTL indexes expire and
    remove data from normal collections based on the value of a date-typed field and
    a TTL value for the index. These are covered in more depth later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Capped collections cannot be sharded. If an update or a replacement operation
    changes the document size in a capped collection, the operation will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Capped collections tend to be useful for logging, although they lack flexibility:
    you cannot control when data ages out, other than setting a size when you create
    the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Capped Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike normal collections, capped collections must be explicitly created before
    they are used. To create a capped collection, use the `create` command. From the
    shell, this can be done using `createCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The previous command creates a capped collection, *my_collection*, that has
    a fixed size of 100,000 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '`createCollection` can also specify a limit on the number of documents in a
    capped collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You could use this to keep, say, the latest 10 news articles or limit a user
    to 1,000 documents.
  prefs: []
  type: TYPE_NORMAL
- en: Once a capped collection has been created, it cannot be changed (it must be
    dropped and recreated if you wish to change its properties). Thus, you should
    think carefully about the size of a large collection before creating it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When limiting the number of documents in a capped collection, you must specify
    a size limit as well. Age-out will be based on whichever limit is reached first:
    it can neither hold more than `"max"` documents nor take up more than `"size"`
    space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option for creating a capped collection is to convert an existing regular
    collection into a capped collection. This can be done using the `convertToCapped`
    command—in the following example, we convert the *test* collection to a capped
    collection of 10,000 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There is no way to “uncap” a capped collection (other than dropping it).
  prefs: []
  type: TYPE_NORMAL
- en: Tailable Cursors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tailable cursors are a special type of cursor that are not closed when their
    results are exhausted. They were inspired by the `tail -f` command and, similar
    to that command, will continue fetching output for as long as possible. Because
    the cursors do not die when they run out of results, they can continue to fetch
    new results as documents are added to the collection. Tailable cursors can be
    used only on capped collections, since insert order is not tracked for normal
    collections. For the vast majority of uses, change streams, covered in [Chapter 16](ch16.xhtml#chapter-shardkey),
    are recommended over tailable cursors as they offer vastly more control and configuration
    plus they work with normal collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tailable cursors are often used for processing documents as they are inserted
    onto a “work queue” (the capped collection). Because tailable cursors will time
    out after 10 minutes of no results, it is important to include logic to requery
    the collection if they die. The *mongo* shell does not allow you to use tailable
    cursors, but using one in PHP looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The cursor will process results or wait for more results to arrive until it
    times out or someone kills the query operation.
  prefs: []
  type: TYPE_NORMAL
- en: Time-To-Live Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the previous section, capped collections give you limited control
    over when their contents are overwritten. If you need a more flexible age-out
    system, TTL indexes allow you to set a timeout for each document. When a document
    reaches a preconfigured age, it will be deleted. This type of index is useful
    for caching use cases such as session storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a TTL index by specifying the `"expireAfterSeconds"` option
    in the second argument to `createIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This creates a TTL index on the `"lastUpdated"` field. If a document’s `"lastUpdated"`
    field exists and is a date, the document will be removed once the server time
    is `"expireAfterSeconds"` seconds ahead of the document’s time.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent an active session from being removed, you can update the `"lastUpdated"`
    field to the current time whenever there is activity. Once `"lastUpdated"` is
    24 hours old, the document will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB sweeps the TTL index once per minute, so you should not depend on to-the-second
    granularity. You can change the `"expireAfterSeconds"` using the `collMod` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You can have multiple TTL indexes on a given collection. They cannot be compound
    indexes but can be used like “normal” indexes for the purposes of sorting and
    query optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Files with GridFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GridFS is a mechanism for storing large binary files in MongoDB. There are
    several reasons why you might consider using GridFS for file storage:'
  prefs: []
  type: TYPE_NORMAL
- en: Using GridFS can simplify your stack. If you’re already using MongoDB, you might
    be able to use GridFS instead of a separate tool for file storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GridFS will leverage any existing replication or autosharding that you’ve set
    up for MongoDB, so getting failover and scale-out for file storage is easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GridFS can alleviate some of the issues that certain filesystems can exhibit
    when being used to store user uploads. For example, GridFS does not have issues
    with storing large numbers of files in the same directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some downsides, too:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance is slower. Accessing files from MongoDB will not be as fast as going
    directly through the filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can only modify documents by deleting them and resaving the whole thing.
    MongoDB stores files as multiple documents, so it cannot lock all of the chunks
    in a file at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GridFS is generally best when you have large files you’ll be accessing in a
    sequential fashion that won’t be changing much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting Started with GridFS: mongofiles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to try out GridFS is by using the *mongofiles* utility. *mongofiles*
    is included with all MongoDB distributions and can be used to upload, download,
    list, search for, or delete files in GridFS.
  prefs: []
  type: TYPE_NORMAL
- en: As with any of the other command-line tools, run `mongofiles --help` to see
    the options available for *mongofiles*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following session shows how to use *mongofiles* to upload a file from the
    filesystem to GridFS, list all of the files in GridFS, and download a file that
    we’ve previously uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we perform three basic operations using *mongofiles*:
    `put`, `list`, and `get`. The `put` operation takes a file in the filesystem and
    adds it to GridFS. `list` will list any files that have been added to GridFS.
    `get` does the inverse of `put`: it takes a file from GridFS and writes it to
    the filesystem. *mongofiles* also supports two other operations: `search` for
    finding files in GridFS by filename and `delete` for removing a file from GridFS.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with GridFS from the MongoDB Drivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the client libraries have GridFS APIs. For example, with PyMongo (the Python
    driver for MongoDB) you can perform the same series of operations (this assumes
    Python 3 and a locally running *mongod* on port 27017) as we did with *mongofiles*
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The API for working with GridFS from PyMongo is very similar to that of *mongofiles*:
    you can easily perform the basic `put`, `get`, and `list` operations. Almost all
    the MongoDB drivers follow this basic pattern for working with GridFS, while often
    exposing more advanced functionality as well. For driver-specific information
    on GridFS, please check out the documentation for the specific driver you’re using.'
  prefs: []
  type: TYPE_NORMAL
- en: Under the Hood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GridFS is a lightweight specification for storing files that is built on top
    of normal MongoDB documents. The MongoDB server actually does almost nothing to
    “special-case” the handling of GridFS requests; all the work is handled by the
    client-side drivers and tools.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind GridFS is that we can store large files by splitting them
    up into *chunks* and storing each chunk as a separate document. Because MongoDB
    supports storing binary data in documents, we can keep the storage overhead for
    chunks to a minimum. In addition to storing each chunk of a file, we store a single
    document that groups the chunks together and contains metadata about the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chunks for GridFS are stored in their own collection. By default chunks
    will use the collection *fs.chunks*, but this can be overridden. Within the chunks
    collection the structure of the individual documents is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Like any other MongoDB document, a chunk has its own unique `"_id"`. In addition,
    it has a couple of other keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"files_id"`'
  prefs: []
  type: TYPE_NORMAL
- en: The `"_id"` of the file document that contains the metadata for the file this
    chunk is from
  prefs: []
  type: TYPE_NORMAL
- en: '`"n"`'
  prefs: []
  type: TYPE_NORMAL
- en: The chunk’s position in the file, relative to the other chunks
  prefs: []
  type: TYPE_NORMAL
- en: '`"data"`'
  prefs: []
  type: TYPE_NORMAL
- en: The bytes in this chunk of the file
  prefs: []
  type: TYPE_NORMAL
- en: 'The metadata for each file is stored in a separate collection, which defaults
    to *fs.files*. Each document in the files collection represents a single file
    in GridFS and can contain any custom metadata that should be associated with that
    file. In addition to any user-defined keys, there are a couple of keys that are
    mandated by the GridFS specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"_id"`'
  prefs: []
  type: TYPE_NORMAL
- en: A unique ID for the file—this is what will be stored in each chunk as the value
    for the `"files_id"` key.
  prefs: []
  type: TYPE_NORMAL
- en: '`"length"`'
  prefs: []
  type: TYPE_NORMAL
- en: The total number of bytes making up the content of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '`"chunkSize"`'
  prefs: []
  type: TYPE_NORMAL
- en: The size of each chunk comprising the file, in bytes. The default is 255 KB,
    but this can be adjusted if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '`"uploadDate"`'
  prefs: []
  type: TYPE_NORMAL
- en: A timestamp representing when this file was stored in GridFS.
  prefs: []
  type: TYPE_NORMAL
- en: '`"md5"`'
  prefs: []
  type: TYPE_NORMAL
- en: An MD5 checksum of this file’s contents, generated on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Of all the required keys, perhaps the most interesting (or least self-explanatory)
    is `"md5"`. The value for `"md5"` is generated by the MongoDB server using the
    `filemd5` command, which computes the MD5 checksum of the uploaded chunks. This
    means that users can check the value of the `"md5"` key to ensure that a file
    was uploaded correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, you are not limited to the required fields in *fs.files*:
    feel free to keep any other file metadata in this collection as well. You might
    want to keep information such as download count, MIME type, or user rating with
    a file’s metadata.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you understand the underlying GridFS specification, it becomes trivial
    to implement features that the driver you’re using might not provide helpers for.
    For example, you can use the `distinct` command to get a list of unique filenames
    stored in GridFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This allows your application a great deal of flexibility in loading and collecting
    information about files. We’ll change direction slightly in the next chapter,
    as we introduce the aggregation framework. It offers a range of data analytic
    tools to process the data in your database.
  prefs: []
  type: TYPE_NORMAL
