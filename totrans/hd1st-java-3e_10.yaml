- en: 'Chapter 8\. Serious Polymorphism: Interfaces and Abstract Classes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0199-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Inheritance is just the beginning.** To exploit polymorphism, we need interfaces
    (and not the GUI kind). We need to go beyond simple inheritance to a level of
    flexibility and extensibility you can get only by designing and coding to interface
    specifications. Some of the coolest parts of Java wouldn’t even be possible without
    interfaces, so even if you don’t design with them yourself, you still have to
    use them. But you’ll *want* to design with them. You’ll *need* to design with
    them. ***You’ll*** wonder how you ever lived without them. What’s an interface?
    It’s a 100% abstract class. What’s an abstract class? It’s a class that can’t
    be instantiated. What’s that good for? You’ll see in just a few moments. But if
    you think about the end of the previous chapter, and how we used polymorphic arguments
    so that a single Vet method could take Animal subclasses of all types, well, that
    was just scratching the surface. Interfaces are the ***poly*** in polymorphism.
    The ***ab*** in abstract. The ***caffeine*** in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Did we forget about something when we designed this?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0200-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The class structure isn’t too bad. We’ve designed it so that duplicate code
    is kept to a minimum, and we’ve overridden the methods that we think should have
    subclass-specific implementations. We’ve made it nice and flexible from a polymorphic
    perspective, because we can design Animal-using programs with Animal arguments
    (and array declarations) so that any Animal subtype—***including those we never
    imagined at the time we wrote our code***—can be passed in and used at runtime.
    We’ve put the common protocol for all Animals (the four methods that we want the
    world to know all Animals have) in the Animal superclass, and we’re ready to start
    making new Lions and Tigers and Hippos.
  prefs: []
  type: TYPE_NORMAL
- en: '**We know we can say:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0201-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**And we know we can say:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0201-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**But here’s where it gets weird:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0201-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**What does a new Animal() object *look* like?**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0202-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**What are the instance variable values?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Some classes just should *not* be instantiated!**'
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to create a Wolf object or a Hippo object or a Tiger object,
    but what exactly *is* an Animal object? What shape is it? What color, size, number
    of legs...
  prefs: []
  type: TYPE_NORMAL
- en: Trying to create an object of type Animal is like **a nightmare Star Trek™ transporter
    accident.** The one where somewhere in the beam-me-up process something bad happened
    to the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we deal with this? We *need* an Animal class, for inheritance and
    polymorphism. But we want programmers to instantiate only the less abstract *subclasses*
    of class Animal, not Animal itself. We want Tiger objects and Lion objects, ***not
    Animal objects.***
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there’s a simple way to prevent a class from ever being instantiated.
    In other words, to stop anyone from saying “`**new**`” on that type. By marking
    the class as `**abstract**`, the compiler will stop any code, anywhere, from ever
    creating an instance of that type.
  prefs: []
  type: TYPE_NORMAL
- en: You can still use that abstract type as a reference type. In fact, that’s a
    big part of why you have that abstract class in the first place (to use it as
    a polymorphic argument or return type, or to make a polymorphic array).
  prefs: []
  type: TYPE_NORMAL
- en: When you’re designing your class inheritance structure, you have to decide which
    classes are *abstract* and which are *concrete*. Concrete classes are those that
    are specific enough to be instantiated. A *concrete* class just means that it’s
    OK to make objects of that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making a class abstract is easy—put the keyword `**abstract**` before the class
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The compiler won’t let you instantiate an abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abstract class means that nobody can ever make a new instance of that class.
    You can still use that abstract class as a declared reference type, for the purpose
    of polymorphism, but you don’t have to worry about somebody making objects of
    that type. The compiler *guarantees* it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0203-01.png)![image](Images/f0203-02.png)'
  prefs: []
  type: TYPE_IMG
- en: An **abstract class** has virtually* no use, no value, no purpose in life, unless
    it is ***extended.***
  prefs: []
  type: TYPE_NORMAL
- en: With an abstract class, it’s the **instances of a *subclass*** of your abstract
    class that’s doing the work at runtime
  prefs: []
  type: TYPE_NORMAL
- en: '*There is an exception to this—an abstract class can have static members (see
    [Chapter 10](ch10.xhtml#numbers_matter_numbers_and_statics)).'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract vs. Concrete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0204-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A class that’s not abstract is called a *concrete* class. In the Animal inheritance
    tree, if we make Animal, Canine, and Feline abstract, that leaves Hippo, Wolf,
    Dog, Tiger, Lion, and Cat as the concrete subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Flip through the Java API and you’ll find a lot of abstract classes, especially
    in the GUI library. What does a GUI Component look like? The Component class is
    the superclass of GUI-related classes for things like buttons, text areas, scrollbars,
    dialog boxes, you name it. You don’t make an instance of a generic *Component*
    and put it on the screen; you make a JButton. In other words, you instantiate
    only a *concrete subclass* of Component, but never Component itself.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0205-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Besides classes, you can mark *methods* abstract, too. An abstract class means
    the class must be *extended*; an abstract method means the method must be *overridden*.
    You might decide that some (or all) behaviors in an abstract class don’t make
    any sense unless they’re implemented by a more specific subclass. In other words,
    you can’t think of any generic method implementation that could possibly be useful
    for subclasses. What would a generic eat() method look like?
  prefs: []
  type: TYPE_NORMAL
- en: '**An abstract method has no body!**'
  prefs: []
  type: TYPE_NORMAL
- en: Because you’ve already decided there isn’t any code that would make sense in
    the abstract method, you won’t put in a method body. So no curly braces— just
    end the declaration with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0205-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**If you declare an abstract *method*, you MUST mark the *class* abstract as
    well. You can’t have an abstract method in a non-abstract class.**'
  prefs: []
  type: TYPE_NORMAL
- en: If you put even a single abstract method in a class, you have to make the class
    abstract. But you *can* mix both abstract and non-abstract methods in the abstract
    class.
  prefs: []
  type: TYPE_NORMAL
- en: You MUST implement all abstract methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0206-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Implementing* an abstract method is just like *overriding* a method.**'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract methods don’t have a body; they exist solely for polymorphism. That
    means the first concrete class in the inheritance tree must implement *all* abstract
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, pass the buck by being abstract yourself. If both Animal and
    Canine are abstract, for example, and both have abstract methods, class Canine
    does not have to implement the abstract methods from Animal. But as soon as we
    get to the first concrete subclass, like Dog, that subclass must implement *all*
    of the abstract methods from both Animal and Canine.
  prefs: []
  type: TYPE_NORMAL
- en: But remember that an abstract class can have both abstract and *non*-abstract
    methods, so Canine, for example, could implement an abstract method from Animal,
    so that Dog didn’t have to. But if Canine says nothing about the abstract methods
    from Animal, Dog has to implement all of Animal’s abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: When we say “you must implement the abstract method,” that means you *must provide
    a body.* That means you must create a non-abstract method in your class with the
    same method signature (name and arguments) and a return type that is compatible
    with the declared return type of the abstract method. What you put *in* that method
    is up to you. All Java cares about is that the method is *there*, in your concrete
    subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s say that we want to write our *own* kind of list class, one that will
    hold Dog objects, but pretend for a moment that we don’t know about the ArrayList
    class. For the first pass, we’ll give it just an add() method. We’ll use a simple
    Dog array (Dog[]) to keep the added Dog objects, and give it a length of 5\. When
    we reach the limit of 5 Dog objects, you can still call the add() method, but
    it won’t do anything. If we’re *not* at the limit, the add() method puts the Dog
    in the array at the next available index position and then increments that next
    available index (nextIndex).
  prefs: []
  type: TYPE_NORMAL
- en: '**Building our own Dog-specific list**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(Perhaps the world’s worst attempt at making our own ArrayList kind of class,
    from scratch.)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0208-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Uh-oh, now we need to keep Cats, too
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a few options here:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Make a separate class, MyCatList, to hold Cat objects. Pretty clunky.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Make a single class, DogAndCatList, that keeps two different arrays as
    instance variables and has two different add() methods: addCat(Cat c) and addDog(Dog
    d). Another clunky solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Make a heterogeneous AnimalList class that takes *any* kind of Animal subclass
    (since we know that if the spec changed to add Cats, sooner or later we’ll have
    some *other* kind of animal added as well). We like this option best, so let’s
    change our class to make it more generic, to take Animals instead of just Dogs.
    We’ve highlighted the key changes (the logic is the same, of course, but the type
    has changed from Dog to Animal everywhere in the code).
  prefs: []
  type: TYPE_NORMAL
- en: '**Building our own Animal-specific list**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0209-01.png)![image](Images/f0209-02.png)'
  prefs: []
  type: TYPE_IMG
- en: What about non-Animals? Why not make a class generic enough to take anything?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0210-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You know where this is heading. We want to change the type of the array, along
    with the add() method argument, to something *above* Animal. Something even *more*
    generic, *more* abstract than Animal. But how can we do it? We don’t *have* a
    superclass for Animal.
  prefs: []
  type: TYPE_NORMAL
- en: Then again, maybe we do...
  prefs: []
  type: TYPE_NORMAL
- en: '**Every class in Java extends class Object.**'
  prefs: []
  type: TYPE_NORMAL
- en: Class Object is the mother of all classes; it’s the superclass of *everything.*
  prefs: []
  type: TYPE_NORMAL
- en: Even if you take advantage of polymorphism, you still have to create a class
    with methods that take and return *your* polymorphic type. Without a common superclass
    for everything in Java, there’d be no way for the developers of Java to create
    classes with methods that could take *your* custom types...*types they never knew
    about when they wrote the library class.*
  prefs: []
  type: TYPE_NORMAL
- en: 'So you were making subclasses of class Object from the very beginning and you
    didn’t even know it. ***Every class you write extends Object,*** without your
    ever having to say it. But you can think of it as though a class you write looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But wait a minute, Dog *already* extends something, *Canine*. That’s OK. The
    compiler will make *Canine* extend Object instead. Except *Canine* extends Animal.
    No problem, then the compiler will just make *Animal* extend Object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Any class that doesn’t *explicitly* extend another class, *implicitly* extends
    Object.**'
  prefs: []
  type: TYPE_NORMAL
- en: So, since Dog extends Canine, it doesn’t *directly* extend Object (although
    it does extend it indirectly), and the same is true for Canine, but Animal *does*
    directly extend Object.
  prefs: []
  type: TYPE_NORMAL
- en: So what’s in this ultra-super-megaclass Object?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0211-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If you were Java, what behavior would you want *every* object to have? Hmmmm...let’s
    see...how about a method that lets you find out if one object is equal to another
    object? What about a method that can tell you the actual class type of that object?
    Maybe a method that gives you a hashcode for the object, so you can use the object
    in hashtables (we’ll talk about Java’s hashtables later). Oh, here’s a good one—a
    method that prints out a String message for that object.
  prefs: []
  type: TYPE_NORMAL
- en: And what do you know? As if by magic, class Object does indeed have methods
    for those four things. That’s not all, though, but these are the ones we really
    care about.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **equals(Object o)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0211-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/2.png) **getClass()**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0211-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/3.png) **hashCode()**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0211-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/4.png) **toString()**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0211-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Using polymorphic references of type Object has a price...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you run off and start using type Object for all your ultra-flexible argument
    and return types, you need to consider a little issue of using type Object as
    a reference. And keep in mind that we’re not talking about making instances of
    type Object; we’re talking about making instances of some other type, but using
    a reference of type Object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you put an object into an ArrayList**<Dog>**, it goes in as a Dog and
    comes out as a Dog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0213-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But what happens when you declare it as ArrayList**<Object>**? If you want
    to make an ArrayList that will literally take any kind of Object, you declare
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0213-02.png)'
  prefs: []
  type: TYPE_IMG
- en: But what happens when you try to get the Dog object and assign it to a Dog reference?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0213-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Everything comes out of an ArrayList<Object> as a reference of type Object,
    regardless of what the actual object is or what the reference type was when you
    added the object to the list.***'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0213-04.png)'
  prefs: []
  type: TYPE_IMG
- en: When a Dog won’t act like a Dog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with having everything treated polymorphically as an Object is that
    the objects *appear* to lose (but not permanently) their true essence. *The Dog
    appears to lose its dogness*. Let’s see what happens when we pass a Dog to a method
    that returns a reference to the same Dog object, but declares the return type
    as type Object rather than Dog.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0214-01.png)![image](Images/f0214-02.png)![image](Images/f0214-03.png)![image](Images/f0214-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Objects don’t bark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0215-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So now we know that when an object is referenced by a variable declared as
    type Object, it can’t be assigned to a variable declared with the actual object’s
    type. And we know that this can happen when a return type or argument is declared
    as type Object, as would be the case, for example, when the object is put into
    an ArrayList of type Object using ArrayList<Object>. But what are the implications
    of this? Is it a problem to have to use an Object reference variable to refer
    to a Dog object? Let’s try to call Dog methods on our Dog-That-Compiler-Thinks-Is-An-Object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0215-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The compiler decides whether you can call a method based on the *reference*
    type, not the actual object type.**'
  prefs: []
  type: TYPE_NORMAL
- en: Even if you *know* the object is capable (“...but it really *is* a Dog, honest...”),
    the compiler sees it only as a generic Object. For all the compiler knows, you
    put a Button object out there. Or a Microwave object. Or some other thing that
    really doesn’t know how to bark.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler checks the class of the *reference* type—not the *object* type—to
    see if you can call a method using that reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0215-03.png)![image](Images/f0216-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Get in touch with your inner Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object contains *everything* it inherits from each of its superclasses. That
    means *every* object—regardless of its actual class type—is *also* an instance
    of class Object. That means any object in Java can be treated not just as a Dog,
    Button, or Snowboard, but also as an Object. When you say `**new Snowboard()**`,
    you get a single object on the heap—a Snowboard object—but that Snowboard wraps
    itself around an inner core representing the Object (capital “O”) portion of itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0216-02.png)![image](Images/f0216-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Polymorphism* means “many forms.”'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**You can treat a Snowboard as a Snowboard or as an Object.**'
  prefs: []
  type: TYPE_NORMAL
- en: If a reference is like a remote control, the remote control takes on more and
    more buttons as you move down the inheritance tree. A remote control (reference)
    of type Object has only a few buttons— the buttons for the exposed methods of
    class Object. But a remote control of type Snowboard includes all the buttons
    from class Object, plus any new buttons (for new methods) of class Snowboard.
    The more specific the class, the more buttons it may have.
  prefs: []
  type: TYPE_NORMAL
- en: Of course that’s not always true; a subclass might not add any new methods,
    but simply override the methods of its superclass. The key point is that even
    if the object is of type Snowboard, an Object *reference* to the Snowboard *object*
    can’t see the Snowboardspecific methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0217-02.png)![image](Images/f0218-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Casting an object reference back to its *real* type.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0218-03.png)![image](Images/f0218-02.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s really still a Dog *object*, but if you want to call Dogspecific methods,
    you need a *reference* declared as type Dog. If you’re *sure** the object is really
    a Dog, you can make a new Dog reference to it by copying the Object reference,
    and forcing that copy to go into a Dog reference variable, using a cast (Dog).
    You can use the new *Dog* reference to call *Dog* methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0218-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '*If you’re *not* sure it’s a Dog, you can use the `instanceof` operator to
    check. Because if you’re wrong when you do the cast, you’ll get a ClassCastException
    at runtime and come to a grinding halt.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**So now you’ve seen how much Java cares about the methods in the class of
    the reference variable.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**You can call a method on an object only if the class of the reference variable
    has that method.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Think of the public methods in your class as your contract, your promise
    to the outside world about the things you can do.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0219-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When you write a class, you almost always *expose* some of the methods to code
    outside the class. To *expose* a method means you make a method *accessible*,
    usually by marking it public.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine this scenario: you’re writing code for a small business accounting
    program. A custom application for Simon’s Surf Shop. The good re-user that you
    are, you found an Account class that appears to meet your needs perfectly, according
    to its documentation, anyway. Each account instance represents an individual customer’s
    account with the store. So there you are minding your own business invoking the
    *credit()* and *debit()* methods on an Account object when you realize you need
    to get a balance on an account. No problem—there’s a *getBalance()* method that
    should do nicely.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0219-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Except...when you invoke the *getBalance()* method, the whole thing blows up
    at runtime. Forget the documentation, the class does not have that method. Yikes!
  prefs: []
  type: TYPE_NORMAL
- en: But that won’t happen to you, because every time you use the dot operator on
    a reference (a.doStuff()), the compiler looks at the *reference* type (the type
    “a” was declared to be) and checks that class to guarantee the class has the method,
    and that the method does indeed take the argument you’re passing and return the
    kind of value you’re expecting to get back.
  prefs: []
  type: TYPE_NORMAL
- en: '**Just remember that the compiler checks the class of the *reference* variable,
    not the class of the actual *object* at the other end of the reference.**'
  prefs: []
  type: TYPE_NORMAL
- en: What if you need to change the contract?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, pretend you’re a Dog. Your Dog class isn’t the *only* contract that defines
    who you are. Remember, you inherit accessible (which usually means *public*) methods
    from all of your superclasses.
  prefs: []
  type: TYPE_NORMAL
- en: True, your Dog class defines a contract.
  prefs: []
  type: TYPE_NORMAL
- en: But not *all* of your contract.
  prefs: []
  type: TYPE_NORMAL
- en: '**Everything in class *Canine* is part of your contract.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Everything in class *Animal* is part of your contract.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Everything in class *Object* is part of your contract.**'
  prefs: []
  type: TYPE_NORMAL
- en: According to the IS-A test, you *are* each of those things—Canine, Animal, and
    Object.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the person who designed your class had in mind the Animal simulation
    program, and now he wants to use you (class Dog) for a Science Fair Tutorial on
    Animal objects.
  prefs: []
  type: TYPE_NORMAL
- en: That’s OK, you’re probably reusable for that.
  prefs: []
  type: TYPE_NORMAL
- en: But what if later he wants to use you for a PetShop program? *You don’t have
    any **Pet** behaviors.* A Pet needs methods like *beFriendly()* and *play()*.
  prefs: []
  type: TYPE_NORMAL
- en: OK, now pretend you’re the Dog class programmer. No problem, right? Just add
    some more methods to the Dog class. You won’t be breaking anyone else’s code by
    *adding* methods, since you aren’t touching the *existing* methods that someone
    else’s code might be calling on Dog objects.
  prefs: []
  type: TYPE_NORMAL
- en: Can you see any drawbacks to that approach (adding Pet methods to the Dog class)?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore some design options for reusing some of our existing classes in
    a PetShop program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the next few pages, we’re going to walk through some possibilities. We’re
    not yet worried about whether Java can actually *do* what we come up with. We’ll
    cross that bridge once we have a good idea of some of the trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: '**So what we REALLY need is:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/enter.png) A way to have pet behavior in **just** the pet
    classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/enter.png) A way to guarantee that all pet classes have all
    of the same methods defined (same name, same arguments, same return types, no
    missing methods, etc.), without having to cross your fingers and hope all the
    programmers get it right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/enter.png) A way to take advantage of polymorphism so that
    all pets can have their pet methods called, without having to use arguments, return
    types, and arrays for each and every pet class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It looks like we need TWO superclasses at the top.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0224-01.png)'
  prefs: []
  type: TYPE_IMG
- en: There’s just one problem with the “two superclasses” approach...
  prefs: []
  type: TYPE_NORMAL
- en: '**It’s called “multiple inheritance,” and it can be a Really Bad Thing.**'
  prefs: []
  type: TYPE_NORMAL
- en: That is, if it were possible to do in Java.
  prefs: []
  type: TYPE_NORMAL
- en: But it isn’t, because multiple inheritance has a problem known as The Deadly
    Diamond of Death.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deadly Diamond of Death**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0225-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A language that allows the Deadly Diamond of Death can lead to some ugly complexities,
    because you have to have special rules to deal with the potential ambiguities.
    And extra rules means extra work for you both in *learning* those rules and watching
    out for those “special cases.” Java is supposed to be *simple* , with consistent
    rules that don’t blow up under some scenarios. So Java (unlike C++) protects you
    from having to think about the Deadly Diamond of Death. But that brings us back
    to the original problem! *How do we handle the Animal/Pet thing?*
  prefs: []
  type: TYPE_NORMAL
- en: Interface to the rescue!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java gives you a solution. An *interface* . Not a *GUI* interface, not the generic
    use of the *word* interface as in, “That’s the public interface for the Button
    class API,” but the Java *keyword* `interface`.
  prefs: []
  type: TYPE_NORMAL
- en: A Java interface solves your multiple inheritance problem by giving you much
    of the polymorphic *benefits* of multiple inheritance without the pain and suffering
    from the Deadly Diamond of Death (DDD).
  prefs: []
  type: TYPE_NORMAL
- en: 'The way in which interfaces side-step the DDD is surprisingly simple: ***make
    all the methods abstract!*** That way, the subclass ***must*** implement the methods
    (remember, abstract methods *must* be implemented by the first concrete subclass),
    so at runtime the JVM isn’t confused about *which* of the two inherited versions
    it’s supposed to call.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0226-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A Java interface is like a 100% pure abstract class.**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All methods in an interface are abstract, so any class that IS-A Pet MUST implement
    (i.e., override) the methods of Pet.
  prefs: []
  type: TYPE_NORMAL
- en: '**To DEFINE an interface:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0226-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**To IMPLEMENT an interface:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0226-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Making and implementing the Pet interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0227-01.png)![image](Images/f0227-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Classes from *different* inheritance trees can implement the same interface.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0228-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When you use a *class* as a polymorphic type (like an array of type Animal or
    a method that takes a Canine argument), the objects you can stick in that type
    must be from the same inheritance tree. But not just anywhere in the inheritance
    tree; the objects must be from a class that is a subclass of the polymorphic type.
    An argument of type Canine can accept a Wolf and a Dog, but not a Cat or a Hippo.
  prefs: []
  type: TYPE_NORMAL
- en: But when you use an ***interface*** as a polymorphic type (like an array of
    Pets), the objects can be from *anywhere* in the inheritance tree. The only requirement
    is that the objects are from a class that *implements* the interface. Allowing
    classes in different inheritance trees to implement a common interface is crucial
    in the Java API. Do you want an object to be able to save its state to a file?
    Implement the Serializable interface. Do you need objects to run their methods
    in a separate thread of execution? Implement Runnable. You get the idea. You’ll
    learn more about Serializable and Runnable in later chapters, but for now, remember
    that classes from *any* place in the inheritance tree might need to implement
    those interfaces. Nearly *any* class might want to be saveable or runnable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Better still, a class can implement *multiple* interfaces!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Dog object IS-A Canine, and IS-A Animal, and IS-A Object, all through inheritance.
    But a Dog IS-A Pet through interface implementation, and the Dog might implement
    other interfaces as well. You could say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0229-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**How do you know whether to make a class, a subclass, an *abstract* class,
    or an interface?**'
  prefs: []
  type: TYPE_NORMAL
- en: Make a class that doesn’t extend anything (other than Object) when your new
    class doesn’t pass the IS-A test for any other type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a subclass (in other words, *extend* a class) only when you need to make
    a ***more specific*** version of a class and need to override or add new behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an abstract class when you want to define a ***template*** for a group of
    subclasses, and you have at least *some* implementation code that all subclasses
    could use. Make the class abstract when you want to guarantee that nobody can
    make objects of that type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an interface when you want to define a ***role*** that other classes can
    play, regardless of where those classes are in the inheritance tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking the superclass version of a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0418-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Here’s your chance to demonstrate your artistic abilities. On the left you’ll
    find sets of class and interface declarations. Your job is to draw the associated
    class diagrams on the right. We did the first one for you. Use a dashed line for
    “implements” and a solid line for “extends.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0232-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr1.png) **Answers in [“What’s the Picture ?”](#whatapostrophes_the_picture_question_mar).**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0418-01.png)'
  prefs: []
  type: TYPE_IMG
- en: On the left you’ll find sets of class diagrams. Your job is to turn these into
    valid Java declarations. We did number 1 for you (and it was a tough one).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0233-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr1.png) **Answers in [“What’s the Declaration?”](#whatapostrophes_the_declaration_question).**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0234-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0234-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the code and output. You **may** use the same snippet more than
    once, and you won’t need to use all the snippets. Your ***goal*** is to make a
    set of classes that will compile and run and produce the output listed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0234-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr1.png) **Answers in [“Pool Puzzle”](#pool_puzzle_left_parenthesis_from_page_2).**'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0418-01.png)'
  prefs: []
  type: TYPE_IMG
- en: What’s the Picture ?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Exercise”](#exercise-id000013))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0235-01.png)'
  prefs: []
  type: TYPE_IMG
- en: What’s the Declaration?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [Figure ](#id00110001))
  prefs: []
  type: TYPE_NORMAL
- en: '**2.** public abstract class Top { }'
  prefs: []
  type: TYPE_NORMAL
- en: public class Tip extends Top { }
  prefs: []
  type: TYPE_NORMAL
- en: '**3.** public abstract class Fee { }'
  prefs: []
  type: TYPE_NORMAL
- en: public abstract class Fi extends Fee { }
  prefs: []
  type: TYPE_NORMAL
- en: '**4.** public interface Foo { }'
  prefs: []
  type: TYPE_NORMAL
- en: public class Bar implements Foo { }
  prefs: []
  type: TYPE_NORMAL
- en: public class Baz extends Bar { }
  prefs: []
  type: TYPE_NORMAL
- en: '**5.** public interface Zeta { }'
  prefs: []
  type: TYPE_NORMAL
- en: public class Alpha implements Zeta { }
  prefs: []
  type: TYPE_NORMAL
- en: public interface Beta { }
  prefs: []
  type: TYPE_NORMAL
- en: public class Delta extends Alpha implements Beta { }
  prefs: []
  type: TYPE_NORMAL
- en: '**key**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0235-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Pool Puzzle”](#pool_puzzle-id00004))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0236-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0236-03.png)'
  prefs: []
  type: TYPE_IMG
