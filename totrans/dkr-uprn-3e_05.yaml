- en: Chapter 4\. Working with Docker Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。使用 Docker 镜像
- en: Every Linux container is based on an image. Images are the underlying definition
    of what gets reconstituted into a running container, much like a virtual disk
    becomes a VM when you start it up. Docker or [Open Container Initiative (OCI)](https://opencontainers.org)
    images provide the basis for everything that you will ever deploy and run with
    Docker. To launch a container, you must either download a public image or create
    your own. You can think of the image as a single asset that primarily represents
    the filesystem for the container. However, in reality, every image consists of
    one or more linked filesystem layers that generally have a direct one-to-one mapping
    to each build step used to create that image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Linux 容器都基于一个镜像。镜像是被重新组合成运行容器的基本定义，就像启动虚拟磁盘时会形成一个虚拟机一样。Docker 或者 [开放容器倡议（OCI）](https://opencontainers.org)
    的镜像提供了你将使用 Docker 部署和运行的所有内容的基础。要启动一个容器，你必须下载一个公共镜像或者创建自己的镜像。你可以将镜像视为一个主要表示容器文件系统的单个资产。然而，实际上，每个镜像由一个或多个链接的文件系统层组成，这些层通常直接一对一地映射到创建该镜像所使用的每个构建步骤。
- en: 'Because images are built up from individual layers, they put special demands
    on the Linux kernel, which must provide the drivers that Docker needs to run the
    storage backend. For image management, Docker relies heavily on this storage backend,
    which communicates with the underlying Linux filesystem to build and manage the
    multiple layers that combine into a single usable image. The primary storage backends
    that are supported include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因为镜像是从单独的层构建起来的，它们对 Linux 内核提出了特殊要求，这需要提供 Docker 运行存储后端所需的驱动程序。对于镜像管理，Docker
    在很大程度上依赖于这个存储后端，它与底层的 Linux 文件系统通信，以构建和管理组合成一个可用镜像的多个层。支持的主要存储后端包括以下内容：
- en: '[Overlay2](https://oreil.ly/r4JHY)^([1](ch04.html#idm46803155693712))'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Overlay2](https://oreil.ly/r4JHY)^([1](ch04.html#idm46803155693712))'
- en: '[B-Tree File System (Btrfs)](https://btrfs.wiki.kernel.org/index.php/Main_Page)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[B-Tree 文件系统（Btrfs）](https://btrfs.wiki.kernel.org/index.php/Main_Page)'
- en: '[Device Mapper](https://www.sourceware.org/dm)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Device Mapper](https://www.sourceware.org/dm)'
- en: 'Each storage backend provides a fast copy-on-write (CoW) system for image management.
    We discuss the specifics of various backends in [Chapter 11](ch11.html#advanced_topics).
    For now, we’ll use the default backend and explore how images work, since they
    make up the basis for almost everything else that you will do with Docker, including
    the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个存储后端都为镜像管理提供了快速的写时复制（CoW）系统。我们将在 [第 11 章](ch11.html#advanced_topics) 中讨论各种后端的具体情况。目前，我们将使用默认后端并探索镜像的工作原理，因为它们几乎构成了你在
    Docker 中做的所有其他工作的基础，包括以下内容：
- en: Building images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Uploading (pushing) images to an image registry
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将镜像上传（推送）到镜像注册表
- en: Downloading (pulling) images from an image registry
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从镜像注册表下载（拉取）镜像
- en: Creating and running containers from an image
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从镜像创建和运行容器
- en: Anatomy of a Dockerfile
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile 的解剖
- en: To create a custom Docker image with the default tools, you will need to become
    familiar with the *Dockerfile*. This file describes all the steps that are required
    to create an image and is usually contained within the root directory of the source
    code repository for your application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用默认工具创建自定义 Docker 镜像，你需要熟悉 *Dockerfile*。这个文件描述了创建镜像所需的所有步骤，通常包含在应用程序源代码库的根目录中。
- en: 'A typical *Dockerfile* might look something like the one shown here, which
    creates a container for a Node.js-based application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 *Dockerfile* 可能看起来像这里显示的这个，它创建了一个基于 Node.js 的应用程序容器：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Dissecting this *Dockerfile* will provide some initial exposure to a number
    of the possible instructions for controlling how an image is assembled. Each line
    in a *Dockerfile* creates a new image layer that is stored by Docker. This layer
    contains all of the changes that are a result of that command being issued. This
    means that when you build new images, Docker will only need to build layers that
    deviate from previous builds: you can reuse all the layers that haven’t changed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 解剖这个 *Dockerfile* 将提供对控制如何组装镜像的多个可能指令的初步了解。*Dockerfile* 中的每一行都会创建一个由 Docker
    存储的新镜像层。这个层包含因发出该命令而产生的所有更改。这意味着当你构建新镜像时，Docker 只需构建与之前构建不同的层：你可以重用所有未更改的层。
- en: 'Although you could build a Node instance from a plain, base Linux image, you
    can also explore [Docker Hub](https://registry.hub.docker.com) for official images
    for Node. The Node.js community maintains a series of [Docker images](https://registry.hub.docker.com/_/node)
    and tags that allow you to quickly determine what versions are available. If you
    want to lock the image to a specific point release of Node, you could point it
    at something like `node:18.13.0`. The following base image will provide you with
    an Ubuntu Linux image running Node 11.11.x:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以从一个普通的基础Linux镜像构建一个Node实例，但您也可以在[Docker Hub](https://registry.hub.docker.com)上探索官方的Node镜像。Node.js社区维护了一系列[Docker镜像](https://registry.hub.docker.com/_/node)和标签，让您可以快速确定可用的版本。如果您想将镜像锁定到Node的特定点发布版本，您可以指向类似`node:18.13.0`的内容。以下基础镜像将为您提供一个运行Node
    11.11.x的Ubuntu Linux镜像：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ARG` parameter provides a way for you to set variables and their default
    values, which are only available during the image build process:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG`参数提供了一种方式，让您设置变量及其默认值，这些值仅在镜像构建过程中可用：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Applying labels to images and containers allows you to add metadata via key/value
    pairs that can later be used to search for and identify Docker images and containers.
    You can see the labels applied to any image using the `docker image inspect` command.
    For the maintainer label, we are leveraging the value of the `email` build argument
    that was defined in the previous line of the *Dockerfile*. This means that this
    label can be changed anytime we build this image:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为镜像和容器应用标签允许您通过键/值对添加元数据，以便以后用于搜索和识别Docker镜像和容器。您可以使用`docker image inspect`命令查看应用于任何镜像的标签。对于维护者标签，我们正在利用在*Dockerfile*的前一行中定义的`email`构建参数的值。这意味着每当我们构建此镜像时，此标签都可以更改：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By default, Docker runs all processes as `root` within the container, but you
    can use the `USER` instruction to change this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker在容器内以`root`身份运行所有进程，但您可以使用`USER`指令来更改这一点：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Caution
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Even though containers provide some isolation from the underlying operating
    system, they still run on the host kernel. Due to potential security risks, production
    containers should almost always be run in the context of an unprivileged user.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器在一定程度上提供了与底层操作系统的隔离，但它们仍在主机内核上运行。由于潜在的安全风险，生产容器几乎总是应以非特权用户的身份运行。
- en: 'Unlike the `ARG` instruction, the `ENV` instruction allows you to set shell
    variables that can be used by your running application for configuration, in addition
    to being available during the build process. The `ENV` and `ARG` instructions
    can be used to simplify the *Dockerfile* and help keep it DRYer (Don’t Repeat
    Yourself):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ARG`指令不同，`ENV`指令允许您设置shell变量，这些变量可以被您运行的应用程序用于配置，同时也可在构建过程中使用。`ENV`和`ARG`指令可用于简化*Dockerfile*并帮助保持DRY（不要重复自己）：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following code, you’ll use a collection of `RUN` instructions to start
    and create the required file structure that you need, and install some required
    software dependencies:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，您将使用一系列`RUN`指令来启动和创建所需的文件结构，并安装一些必需的软件依赖：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Warning
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While we’re demonstrating it here for simplicity, it is not recommended that
    you run commands like `apt-get -y update` or `dnf -y update` in your application’s
    *Dockerfile*. This is because it requires crawling the repository index each time
    you run a build, which means that your build is not guaranteed to be repeatable
    since package versions might change between builds. Instead, consider basing your
    application image on another image that already has these updates applied to it
    and where the versions are in a known state. It will be faster and more repeatable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里为了简单起见演示，但不建议在应用程序的*Dockerfile*中运行类似`apt-get -y update`或`dnf -y update`这样的命令。这是因为每次运行构建时都需要爬取存储库索引，这意味着您的构建不能保证重复性，因为软件包版本可能在构建之间发生变化。相反，考虑基于已应用这些更新并且版本处于已知状态的另一个镜像构建您的应用程序镜像。这样会更快速和更可重复。
- en: 'The `COPY` instruction is used to copy files from the local filesystem into
    your image. Most often this will include your application code and any required
    support files. Because `COPY` copies the files into the image, you no longer need
    access to the local filesystem to access them once the image is built. You’ll
    also start to use the build variables you defined in the previous section to save
    you a bit of work and help protect you from typos:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 指令用于将文件从本地文件系统复制到镜像中。最常见的情况是将应用程序代码和任何所需的支持文件包括在内。由于 `COPY` 将文件复制到镜像中，一旦构建完成，您就不再需要访问本地文件系统来访问这些文件。您还将开始使用您在上一节中定义的构建变量，以节省一些工作并帮助您避免打字错误：'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that every instruction creates a new Docker image layer, so it often
    makes sense to combine a few logically grouped commands onto a single line. It
    is even possible to use the `COPY` instruction in combination with the `RUN` instruction
    to copy a complex script to your image and then execute that script with only
    two commands in the *Dockerfile*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令都会创建一个新的 Docker 镜像层，因此通常将一些逻辑上分组的命令组合成一行是有意义的。甚至可以在 *Dockerfile* 中仅使用两个命令结合
    `COPY` 指令和 `RUN` 指令将复杂脚本复制到镜像中并执行该脚本。
- en: 'With the `WORKDIR` instruction, you change the working directory in the image
    for the remaining build instructions and the default process that launches with
    any resulting containers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `WORKDIR` 指令，您可以更改镜像中的工作目录，以便为其余的构建指令和默认进程启动设置任何生成的容器：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Caution
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The order of commands in a *Dockerfile* can have a very significant impact on
    ongoing build times. You should try to order commands so that things that change
    between every single build are closer to the bottom. This means that adding your
    code and similar steps should be held off until the end. When you rebuild an image,
    every single layer after the first introduced change will need to be rebuilt.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockerfile* 中的命令顺序对持续构建时间有很大影响。您应该尝试将每次构建都会改变的事物放在靠近底部的位置。这意味着添加您的代码和类似步骤应该推迟到最后。当您重建镜像时，每个引入变更的第一个层之后的所有层都需要重新构建。'
- en: 'And finally, you end with the `CMD` instruction, which defines the command
    that launches the process that you want to run within the container:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `CMD` 指令定义启动容器内所需运行的进程的命令：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Though not a hard-and-fast rule, it is generally considered a best practice
    to try to run only a single process within a container. The core idea is that
    a container should provide a single function so that it remains easy to horizontally
    scale individual functions within your architecture. In the example, you are using
    `supervisord` as a process manager to help improve the resiliency of the node
    application within the container and ensure that it stays running. This can also
    be useful for troubleshooting your application during development so that you
    can restart your service without restarting the whole container.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有硬性规定，但通常认为在容器内只运行单个进程是最佳实践。核心思想是容器应提供单一功能，以便轻松地在体系结构中水平扩展各个功能。在示例中，您正在使用
    `supervisord` 作为进程管理器来提高容器内的节点应用程序的可靠性，并确保其保持运行状态。这在开发过程中也很有用，因此您可以重新启动服务而不必重新启动整个容器。
- en: You could also achieve a similar effect by using the `--init` command-line argument
    to `docker container run`, which we discuss in [“Controlling Processes”](ch07.html#controlling_processes).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在 `docker container run` 命令行参数中使用 `--init` 命令达到类似效果，我们在 [“控制进程”](ch07.html#controlling_processes)
    中进行了讨论。
- en: Building an Image
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: To build your first image, go ahead and clone a Git repo that contains an example
    application called *docker-node-hello*, as shown here:^([2](ch04.html#idm46803155211200))
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建您的第一个镜像，请继续克隆包含名为 *docker-node-hello* 的示例应用程序的 Git 存储库，如下所示：^([2](ch04.html#idm46803155211200))
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Git is frequently installed on Linux and macOS systems, but if you do not already
    have Git available, you can download a simple installer from [*git-scm.com*](https://git-scm.com/downloads).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Git 经常安装在 Linux 和 macOS 系统上，但如果您尚未安装 Git，可以从 [*git-scm.com*](https://git-scm.com/downloads)
    下载一个简单的安装程序。
- en: The `--config core.autocrlf=input` option we use helps ensure that the line
    endings are not accidentally altered from the Linux standard that is expected.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的 `--config core.autocrlf=input` 选项有助于确保行尾不会意外地从预期的 Linux 标准更改。
- en: 'This will download a working *Dockerfile* and related source code files into
    a directory called *docker-node-hello*. If you look at the contents while ignoring
    the Git repo directory, you should see the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载一个名为*docker-node-hello*的目录中的工作*Dockerfile*和相关的源代码文件。 如果您忽略 Git 仓库目录查看内容，您应该会看到以下内容：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s review the most relevant files in the repo.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下仓库中最相关的文件。
- en: The *Dockerfile* should be the same as the one you just reviewed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockerfile* 应该与您刚刚审查过的文件相同。'
- en: 'The *.dockerignore* file allows you to define files and directories that you
    do not want to upload to the Docker host when you are building the image. In this
    instance, the *.dockerignore* file contains the following line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*.dockerignore*文件允许您定义在构建镜像时不想上传到 Docker 主机的文件和目录。 在这个例子中，*.dockerignore*文件包含以下内容：'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This instructs `docker image build` to exclude the *.git* directory, which contains
    the whole source code repository, from the build. The rest of the files reflect
    the current state of your source code on the checked-out branch. You don’t need
    the contents of the *.git* directory to build the Docker image, and since it can
    grow quite large over time, you don’t want to waste time copying it every time
    you do a build. *package.json* defines the Node.js application and lists any dependencies
    that it relies on. *index.js* is the main source code for the application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令指示`docker image build`排除了包含整个源代码库的*.git*目录。 其余文件反映了当前检出分支上源代码的当前状态。 您不需要*.git*目录的内容来构建
    Docker 镜像，而且由于随着时间的推移它可能会变得很大，您不希望每次构建时都浪费时间复制它。 *package.json*定义了 Node.js 应用程序并列出了它所依赖的任何依赖项。
    *index.js*是应用程序的主要源代码。
- en: The *supervisord* directory contains the configuration files for `supervisord`
    that you will use to start and monitor the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*supervisord*目录包含用于启动和监视应用程序的`supervisord`的配置文件。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Using [`supervisord`](http://supervisord.org) in this example to monitor the
    application is overkill, but it is intended to provide a bit of insight into some
    of the techniques you can use in a container to provide more control over your
    application and its running state.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中使用[`supervisord`](http://supervisord.org)来监视应用程序可能有些过度，但它旨在为您提供一些有关在容器中使用一些技术来更好地控制应用程序及其运行状态的洞察。
- en: As we discussed in [Chapter 3](ch03.html#installing_docker), you will need to
    have your Docker server running and your client properly set up to communicate
    with it before you can build a Docker image. Assuming that this is all working,
    you should be able to initiate a new build by running the upcoming command, which
    will build and tag an image based on the files in the current directory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 3 章](ch03.html#installing_docker)中讨论的那样，您需要确保 Docker 服务器正在运行，并且客户端已正确设置以与其进行通信，然后才能构建
    Docker 镜像。 假设一切正常运行，您应该能够通过运行即将提供的命令启动一个新的构建，该命令将基于当前目录中的文件构建并标记一个镜像。
- en: Each step identified in the following output maps directly to a line in the
    *Dockerfile*, and each step creates a new image layer based on the previous step.
    The first build that you run will take a few minutes because you have to download
    the base node image. Subsequent builds should be much faster unless a new version
    of our base image tag has been released.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出中标识的每个步骤直接映射到*Dockerfile*中的一行，并且每个步骤都基于前一个步骤创建一个新的镜像层。 第一次构建将需要几分钟，因为您需要下载基础的
    node 镜像。 除非发布了我们基础镜像标签的新版本，否则后续构建应该会快得多。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The output that follows is from the new BuildKit included in Docker. If you
    see significantly different output, then you are likely still using the older
    image building code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出来自 Docker 中包含的新 BuildKit。 如果您看到明显不同的输出，则您可能仍在使用旧的镜像构建代码。
- en: You can enable BuildKit in your environment by setting the `DOCKER_BUILDKIT`
    environment variable to `1`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`DOCKER_BUILDKIT`环境变量设置为`1`来在您的环境中启用 BuildKit。
- en: You can find more details on the [Docker website](https://docs.docker.com/build/buildkit).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Docker 网站](https://docs.docker.com/build/buildkit)上找到更多详细信息。
- en: At the end of the `build` command, you will notice a period. This refers to
    the build context, which tells Docker what files it should upload to the server
    so that it can build our image. In many cases, you will simply see a `.` at the
    end of a `build` command, since a single period represents the current directory.
    This build context is what the *.dockerignore* file is filtering so that we don’t
    upload more than we need.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `build` 命令的末尾，你会注意到一个句点。这是指构建上下文，告诉 Docker 应该上传哪些文件到服务器，以便它可以构建我们的镜像。在许多情况下，你将只看到
    `build` 命令的末尾有一个 `.`，因为一个句点代表当前目录。这个构建上下文就是 *.dockerignore* 文件正在过滤的内容，以便我们不会上传更多不必要的文件。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Docker assumes that the *Dockerfile* is in the current directory, but if it
    is not, you can point directly to it using the `-f` argument.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 假设 *Dockerfile* 在当前目录中，但如果不在，可以直接使用 `-f` 参数指向它。
- en: 'Let’s run the build:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来运行构建：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: To improve the speed of builds, Docker will use a local cache when it thinks
    it is safe. This can sometimes lead to unexpected issues because it doesn’t always
    notice that something changed in a lower layer. In the preceding output, you will
    notice lines like `⇒ [2/8] RUN apt-get -y update`. If instead you see `⇒ CACHED
    [2/8] RUN apt-get -y update`, you know that Docker decided to use the cache. You
    can disable the cache for a build by using the `--no-cache` argument to the `docker
    image build` command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高构建速度，当 Docker 认为安全时会使用本地缓存。这有时可能会导致意外问题，因为它并不总是注意到某些更低层发生了变化。在前面的输出中，你会注意到像
    `⇒ [2/8] RUN apt-get -y update` 这样的行。如果你看到 `⇒ CACHED [2/8] RUN apt-get -y update`，你就知道
    Docker 决定使用缓存。你可以通过在 `docker image build` 命令中使用 `--no-cache` 参数来禁用构建时的缓存。
- en: If you are building your Docker images on a system that is used for other simultaneous
    processes, you can limit the resources available to your builds by using many
    of the same cgroup methods that we will discuss in [Chapter 5](ch05.html#docker_containers).
    You can find detailed documentation on the `docker image build` arguments in the
    [official documentation](https://docs.docker.com/engine/reference/commandline/image_build).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个同时用于其他进程的系统上构建你的 Docker 镜像，可以通过使用我们将在[第五章](ch05.html#docker_containers)中讨论的许多相同的
    cgroup 方法来限制你的构建可用资源。你可以在[官方文档](https://docs.docker.com/engine/reference/commandline/image_build)中找到关于
    `docker image build` 参数的详细文档。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Using `docker image build` is functionally the same as using `docker build`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker image build` 在功能上与使用 `docker build` 是相同的。
- en: If you have any issues getting a build to work correctly, you may want to skip
    ahead and read the sections [“Multistage builds”](#multi_stage) and [“Troubleshooting
    Broken Builds”](#broken_builds) in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在正确运行构建时遇到任何问题，你可能需要跳过并阅读本章中的 [“多阶段构建”](#multi_stage) 和 [“故障排除破损构建”](#broken_builds)
    部分。
- en: Running Your Image
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的镜像
- en: 'Once you have successfully built the image, you can run it on your Docker host
    with the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功构建了镜像，你可以使用以下命令在你的 Docker 主机上运行它：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command tells Docker to create a running container in the background from
    the image with the `example/docker-node-hello:latest` tag, and then map port 8080
    in the container to port 8080 on the Docker host. If everything goes as expected,
    the new Node.js application should be running in a container on the host. You
    can verify this by running `docker container ls`. To see the running application
    in action, you will need to open up a web browser and point it at port 8080 on
    the Docker host. You can usually determine the Docker host IP address by examining
    the entry from `docker context list` that is marked with an asterisk or checking
    the value of the `DOCKER_HOST` environment variable if it happens to be set. If
    the `DOCKER ENDPOINT` is set to a Unix socket, then the IP address is most likely
    `127.0.0.1`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令告诉 Docker 从带有 `example/docker-node-hello:latest` 标签的镜像中在后台创建一个运行中的容器，并将容器中的端口
    8080 映射到 Docker 主机的端口 8080。如果一切顺利，新的 Node.js 应用程序应该在主机上的容器中运行。你可以通过运行 `docker
    container ls` 来验证这一点。要查看运行中的应用程序，请打开一个网页浏览器并指向 Docker 主机上的端口 8080。通常可以通过检查带有星号标记的
    `docker context list` 条目或检查 `DOCKER_HOST` 环境变量的值来确定 Docker 主机的 IP 地址。如果 `DOCKER
    ENDPOINT` 设置为 Unix 套接字，则 IP 地址很可能是 `127.0.0.1`：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Get the IP address and enter something like *[*http://127.0.0.1:8080/*](http://127.0.0.1:8080/)*
    (or your remote Docker address if it’s different than that) into your web browser
    address bar, or use a command-line tool like `curl`. You should see the following
    text:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 获取IP地址，并输入类似[*http://127.0.0.1:8080/*](http://127.0.0.1:8080/)（或者如果它与此不同，则输入您的远程Docker地址）到您的网络浏览器地址栏，或者使用类似`curl`的命令行工具。您应该看到以下文本：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Build Arguments
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建参数
- en: 'If you inspect the image that we built, you will be able to see that the maintainer
    label was set to `anna@example.com`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查我们构建的镜像，你将看到`maintainer`标签被设置为`anna@example.com`：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we wanted to change the `maintainer` label, we could simply rerun the build
    and provide a new value for the `email` `ARG` via the `--build-arg` command-line
    argument, like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更改`maintainer`标签，我们可以简单地重新运行构建，并通过`--build-arg`命令行参数提供`email` `ARG`的新值，就像这样：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After the build has finished, we can check the results by reinspecting the
    new image:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以通过重新检查新镜像来检查结果：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ARG` and `ENV` instructions can help make *Dockerfile*s very flexible while
    also avoiding a lot of repeated values that can be hard to keep up to date.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG`和`ENV`指令可以帮助使*Dockerfile*非常灵活，同时避免许多难以保持更新的重复值。'
- en: Environment Variables as Configuration
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为配置的环境变量
- en: 'If you read the *index.js* file, you will notice that part of the file refers
    to the variable `$WHO`, which the application uses to determine who the application
    is going to say Hello to:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读*index.js*文件，你会注意到文件的一部分引用了变量`$WHO`，该应用程序用于确定要向谁说Hello：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s quickly cover how you can configure this application by passing in environment
    variables when you start it. First, you need to stop the existing container using
    two commands. The first command will provide you with the container ID, which
    you will need to use in the second command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速介绍如何在启动应用程序时通过传递环境变量来配置此应用程序。首先，你需要使用两个命令停止现有容器。第一个命令将为你提供容器ID，你需要在第二个命令中使用它：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can format the output of `docker container ls` by using a [Go template](https://developer.hashicorp.com/nomad/tutorials/templates/go-template-syntax)
    so that you see only the information that you care about. In the preceding example,
    you might decide to run something like `docker container ls --format "table {{.ID}}\t{{.Image}}\t{{.Status}}"`
    to limit the output to the three fields you care about. Additionally, running
    `docker container ls --quiet` with no format options will limit the output to
    only the container ID.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用[Go模板](https://developer.hashicorp.com/nomad/tutorials/templates/go-template-syntax)格式化`docker
    container ls`的输出，以便只看到你关心的信息。在上述示例中，你可能决定运行类似`docker container ls --format "table
    {{.ID}}\t{{.Image}}\t{{.Status}}"`来限制输出到你关心的三个字段。此外，运行`docker container ls --quiet`且没有格式选项将仅限制输出到容器ID。
- en: 'And then, using the container ID from the previous output, you can stop the
    running container by typing the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用前面输出的容器ID，您可以输入以下命令来停止运行的容器：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Using `docker container ls` is functionally equivalent to using `docker container
    list`, `docker container ps`, or `docker ps`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker container ls`功能上等同于使用`docker container list`、`docker container ps`或`docker
    ps`。
- en: Using `docker container stop` is also functionally equivalent to using `docker
    stop`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker container stop`也等同于使用`docker stop`。
- en: 'You can then restart the container after adding a single instance of the `--env`
    argument to the previous `docker container run` command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述`docker container run`命令中添加单个`--env`参数后，你可以重新启动容器：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you reload your web browser, you should see that the text on the web page
    now reads as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新加载你的网络浏览器，你应该看到网页上的文本现在如下所示：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You could shorten the preceding `docker` command to the following if you wanted:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望，你可以将前述的`docker`命令简化为以下命令：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can go ahead and stop this container now, by using `docker container stop`
    and passing in the correct container ID.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`docker container stop`并传递正确的容器ID来停止此容器。
- en: Custom Base Images
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义基础镜像
- en: Base images are the lowest-level images that other Docker images will build
    upon. Most often, these are based on minimal installs of Linux distributions like
    Ubuntu, Fedora, or Alpine Linux, but they can also be much smaller, containing
    a single statically compiled binary. For most people, using the official base
    images for their favorite distribution or tool is a great option.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基础镜像是其他Docker镜像将构建在其上的最底层镜像。通常情况下，这些基础镜像基于像Ubuntu、Fedora或Alpine Linux这样的Linux发行版的最小安装，但它们也可以小得多，只包含单个静态编译的二进制文件。对于大多数人来说，使用他们喜欢的发行版或工具的官方基础镜像是一个很好的选择。
- en: However, there are times when it is preferable to build your own base images
    rather than use an image created by someone else. One reason to do this is to
    maintain a consistent OS image across all your deployment methods for hardware,
    VMs, and containers. Another is to get the image size down substantially. There
    is no need to ship around an entire Ubuntu distribution, for example, if your
    application is a statically built C or Go application. You might find that you
    only need the tools you regularly use for debugging, and some other shell commands
    and binaries. Making the effort to build such an image could pay off in better
    deployment times and easier application distribution.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有时候构建自己的基础镜像而不是使用他人创建的镜像更可取。其中一个原因是为了在硬件、虚拟机和容器的所有部署方法中保持一致的操作系统镜像。另一个原因是大幅减小镜像大小。例如，如果你的应用程序是一个静态构建的C或Go应用程序，那就没有必要传输整个Ubuntu发行版了。你可能发现你只需要用于调试的工具和其他一些Shell命令和二进制文件。努力构建这样的镜像可能会带来更好的部署时间和更容易的应用程序分发。
- en: A common middle ground between these two approaches is to build images using
    Alpine Linux, which is designed to be very small and is popular as a basis for
    Docker images. To keep the distribution size very small, Alpine Linux is based
    on the modern, lightweight [musl standard library](https://musl.libc.org), instead
    of the more traditional [GNU C Library (glibc)](https://www.gnu.org/software/libc).
    In general, this is not a big issue, since many packages support *musl*, but it
    is something to be aware of. It has the largest impact on Java-based applications
    and DNS resolution. It’s widely used in production, however, because of its diminutive
    image size. Alpine Linux is highly optimized for space, which is the reason that
    it ships with */bin/sh* instead of */bin/bash*, by default. However, you can also
    install *glibc and bash* in Alpine Linux if you need it, and this is often done
    in the case of JVM containers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种方法之间的常见折衷方案是使用Alpine Linux构建镜像，该系统设计非常小巧，并且作为Docker镜像的基础非常受欢迎。为了保持发行版的小巧，Alpine
    Linux基于现代轻量级的[musl标准库](https://musl.libc.org)，而不是传统的[GNU C库（glibc）](https://www.gnu.org/software/libc)。总体而言，这并不是一个大问题，因为许多软件包支持*musl*，但这也需要注意。对基于Java的应用程序和DNS解析影响最大。然而，由于其小巧的镜像大小，Alpine
    Linux在生产中被广泛使用。Alpine Linux经过高度优化，其原因在于它默认只包含*/bin/sh*而不是*/bin/bash*。但是，如果需要的话，你也可以在Alpine
    Linux中安装*glibc和bash*，这在JVM容器的情况下经常会这样做。
- en: In the official Docker documentation, there is some good information about how
    you can build base images on the various [Linux distributions](https://dockr.ly/2N1FZcU).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方的Docker文档中，有一些关于如何在各种[Linux发行版](https://dockr.ly/2N1FZcU)上构建基础镜像的良好信息。
- en: Storing Images
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储图像
- en: Now that you have created a Docker image that you’re happy with, you’ll want
    to store it somewhere so that it can be easily accessed by any Docker host that
    you want to deploy it to. This is also the normal hand-off point between building
    images and storing them somewhere for future deployment. You don’t normally build
    the images on a production server and then run them. This process was described
    when we talked about handoff between teams for application deployment. Ordinarily,
    deployment is the process of pulling an image from a repository and running it
    on one or more Linux servers. There are a few ways you can go about storing your
    images into a central repository for easy retrieval.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个令你满意的Docker镜像，你会希望把它存储在某个地方，以便任何你想要部署它的Docker主机都能轻松访问它。这也是构建镜像和将其存储在某处以便未来部署的正常交接点。通常情况下，你不会在生产服务器上构建镜像然后运行它们。这个过程在我们讨论应用程序部署团队之间的交接时有描述过。通常情况下，部署是从存储库中拉取镜像并在一个或多个Linux服务器上运行它的过程。有几种方法可以将您的镜像存储到一个中央存储库中以便轻松检索。
- en: Public Registries
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共注册表
- en: Docker provides an [image registry](https://registry.hub.docker.com) for public
    images that the community wants to share. These include official images for Linux
    distributions, ready-to-go WordPress containers, and much more.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 为公共镜像提供了一个 [镜像注册表](https://registry.hub.docker.com)，社区希望共享的。这些包括用于 Linux
    发行版的官方镜像、即用型的 WordPress 容器等。
- en: If you have images that can be published on the internet, the best place for
    them is a public registry, like [Docker Hub](https://hub.docker.com). However,
    there are other options. When the core Docker tools were first gaining popularity,
    Docker Hub did not exist. To fill this obvious void in the community, [Quay.io](https://quay.io)
    was created. Since then, Quay.io has gone through a few acquisitions and is now
    owned by Red Hat. Cloud vendors like Google and SaaS companies like GitHub also
    have their own registry offerings. Here we’ll talk about just the two of them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有可以在互联网上发布的镜像，最佳位置是公共注册表，比如 [Docker Hub](https://hub.docker.com)。但是也有其他选择。在核心
    Docker 工具首次获得流行之时，Docker Hub 并不存在。为填补社区中的这个明显空白，创建了 [Quay.io](https://quay.io)。此后，Quay.io
    经历了几次收购，现在由 Red Hat 拥有。谷歌等云供应商和GitHub等SaaS公司也有自己的注册表服务。这里我们将仅讨论其中的两个。
- en: Both Docker Hub and Quay.io provide centralized Docker image registries that
    can be accessed from anywhere on the internet, and provide a method to store private
    images in addition to public ones. Both have nice user interfaces and the ability
    to separate team access permissions and manage users. Both also offer reasonable
    commercial options for private SaaS hosting of your images, much in the same way
    that GitHub sells private registries on its systems. This is probably the right
    first step if you’re getting serious about Docker but are not yet shipping enough
    code to need an internally hosted solution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 和 Quay.io 都提供了集中式的 Docker 镜像注册表，可以从互联网的任何地方访问，并提供了存储私有镜像的方法，除了公共镜像。两者都有友好的用户界面，并具有分离团队访问权限和管理用户的能力。它们也都为私有
    SaaS 托管提供了合理的商业选项，类似于 GitHub 在其系统上销售私有注册表。如果您对 Docker 感兴趣，但还没有发布足够的代码以需要内部托管解决方案，这可能是正确的第一步。
- en: For companies that use Docker heavily, one of the biggest downsides to these
    registries is that they are not local to the network on which the application
    is being deployed. This means that every layer of every deployment might need
    to be dragged across the internet to deploy an application. Internet latencies
    have a very real impact on software deployments, and outages that affect these
    registries could have a very detrimental impact on a company’s ability to deploy
    smoothly and on schedule. This is mitigated by good image design, where you make
    thin layers that are easy to move around the internet.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大量使用 Docker 的公司来说，这些注册表的最大缺点之一是它们不在部署应用程序的网络内部。这意味着每个部署的每个层可能需要通过互联网拉取。互联网的延迟对软件部署有着非常实际的影响，影响这些注册表的故障可能会对公司的顺利部署能力产生非常不利的影响。通过良好的图像设计可以减轻这种影响，其中您制作的每一层都很薄，便于在互联网上移动。
- en: Private Registries
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有注册表
- en: The other option that many companies consider is to host some type of Docker
    image registry internally, which can interact with the Docker client to support
    pushing, pulling, and searching images. The open source [Distribution](https://github.com/distribution/distribution)
    project provides the basic functionality that most other registries build upon.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司考虑的另一种选择是内部托管某种类型的 Docker 镜像注册表，它可以与 Docker 客户端交互，支持推送、拉取和搜索镜像。开源项目 [Distribution](https://github.com/distribution/distribution)
    提供了大多数其他注册表构建在其上的基本功能。
- en: Other strong contenders in the private registry space include [Harbor](https://goharbor.io)
    and [Red Hat Quay](https://www.redhat.com/en/technologies/cloud-computing/quay).
    In addition to the basic Docker registry functionality, these products have solid
    GUI interfaces and many additional features, like image verification.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在私有注册表领域的其他强大竞争者包括 [Harbor](https://goharbor.io) 和 [Red Hat Quay](https://www.redhat.com/en/technologies/cloud-computing/quay)。除了基本的
    Docker 注册表功能外，这些产品还具有坚实的 GUI 界面和许多附加功能，如图像验证。
- en: Authenticating to a Registry
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证到注册表
- en: Communicating with a registry that stores container images is a part of daily
    life with Docker. For many registries, this means you’ll need to authenticate
    to gain access to images. But Docker also tries to make it easy to automate things
    so it can store your login information and use it on your behalf when you request
    things like pulling down a private image. By default, Docker assumes the registry
    will be Docker Hub, the public repository hosted by Docker, Inc.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与存储容器镜像的注册表进行通信是使用Docker的日常生活的一部分。对于许多注册表来说，这意味着您需要进行身份验证才能访问镜像。但Docker还尝试使自动化变得更容易，以便在您请求像下载私有镜像这样的事物时，它可以存储您的登录信息并代表您使用。默认情况下，Docker假设注册表将是由Docker，Inc.托管的公共存储库Docker
    Hub。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Although a bit more advanced, it is worth noting that you can also configure
    the Docker daemon to use a [custom registry mirror](https://oreil.ly/16Kns)^([3](ch04.html#idm46803154385056))
    or a [pull-through image cache](https://oreil.ly/2Am1f).^([4](ch04.html#idm46803154382192))
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有点更高级，但值得注意的是，您还可以配置Docker守护程序以使用[自定义注册表镜像](https://oreil.ly/16Kns)^([3](ch04.html#idm46803154385056))或[拉取通过镜像缓存](https://oreil.ly/2Am1f).^([4](ch04.html#idm46803154382192))
- en: Creating a Docker Hub account
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个Docker Hub帐户
- en: For these examples, you will create an account on Docker Hub. You don’t need
    an account to download publicly shared images, but you will need to be logged
    in to avoid rate limits and upload any containers that you build.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些示例，您将在Docker Hub上创建一个帐户。您不需要帐户来下载公开共享的镜像，但为了避免速率限制并上传任何构建的容器，您需要登录。
- en: To create your account, use a web browser of your choice to navigate to [Docker
    Hub](https://hub.docker.com).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建您的帐户，请使用您选择的Web浏览器导航到[Docker Hub](https://hub.docker.com)。
- en: From there, you can log in via an existing account or create a new login based
    on your email address. When you create your account, Docker Hub sends a verification
    email to the address that you provided during sign-up. You should immediately
    log in to your email account and click the verification link inside the email
    to finish the validation process.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以通过现有帐户登录或根据您的电子邮件地址创建新的登录。在创建帐户时，Docker Hub会向您在注册时提供的地址发送验证电子邮件。您应立即登录您的电子邮件帐户，并点击邮件中的验证链接以完成验证过程。
- en: At this point, you have created a public registry to which you can upload new
    images. The [Account Settings](https://hub.docker.com/settings/default-privacy)
    option under your profile picture has a `Default Privacy` section that allows
    you to change your registry default visibility to `private` if that is what you
    need.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经创建了一个公共注册表，可以向其上传新镜像。在您的个人资料图片下的[帐户设置](https://hub.docker.com/settings/default-privacy)选项中有一个`默认隐私`部分，允许您将您的注册表默认可见性更改为`私有`，如果这是您需要的。
- en: Warning
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: For much better security, you should create and log in to Docker Hub with a
    [limited-privilege personal access token](https://docs.docker.com/go/access-tokens).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的安全性，您应该使用[有限权限个人访问令牌](https://docs.docker.com/go/access-tokens)创建并登录到Docker
    Hub。
- en: Logging in to a registry
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录到注册表
- en: 'Now let’s log in to the Docker Hub registry using our account:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们的帐户登录到Docker Hub注册表：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The command `docker login` is functionally the same command as `docker login
    docker.io`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`docker login`功能上等同于`docker login docker.io`。
- en: 'When you get `Login Succeeded` back from the server, you know you’re ready
    to pull images from the registry. But what happened behind the scenes? It turns
    out that Docker has written a dotfile for you in your home directory to cache
    this information. The permissions are set to 0600 as a security precaution against
    other users reading your credentials. You can inspect the file with something
    like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从服务器获得`登录成功`时，您就知道您可以从注册表中拉取镜像了。但是幕后发生了什么？事实证明，Docker已经在您的主目录中为您写了一个点文件来缓存此信息。权限设置为0600，以防其他用户读取您的凭据。您可以使用类似以下的内容检查文件：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On Linux you will see something like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，您将看到类似于这样的东西：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Docker is constantly evolving and has added support for many OS native secret
    management systems like the macOS Keychain or Windows Credential Manager. So,
    your *config.json* file might look significantly different than the example. There
    is also a set of [credentials managers](https://github.com/docker/docker-credential-helpers)
    for different platforms that can make your life easier here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Docker不断发展，并且已经添加了对许多操作系统本地秘密管理系统的支持，例如macOS Keychain或Windows Credential Manager。因此，您的*config.json*文件可能与示例大不相同。还有一组不同平台的[凭证管理器](https://github.com/docker/docker-credential-helpers)，可以在这里为您简化生活。
- en: Warning
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `auth` value in the Docker client config file is only base64 encoded. It
    is *not* encrypted. This is typically only a significant issue on multiuser Linux
    systems, because there isn’t a default system-wide credential manager that just
    works, and other privileged users on the system can likely read your Docker client
    config file and access those secrets. It is possible to configure `gpg` pr `pass`
    to encrypt these files on Linux.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 客户端配置文件中的 `auth` 值仅经过 base64 编码。它 *不* 加密。这通常只在多用户 Linux 系统上是一个重要问题，因为没有一个默认的系统范围的凭据管理器可以正常工作，系统上的其他特权用户很可能可以读取你的
    Docker 客户端配置文件并访问这些秘密。在 Linux 上可以配置 `gpg` 或 `pass` 来加密这些文件。
- en: 'Here you can see that the *${HOME}/.docker/config.json* file contains `docker.io`
    credentials for the user `someuser@example.com` in JSON. This configuration file
    supports storing credentials for multiple registries. In this case, you just have
    one entry, for Docker Hub, but you could have more if you needed it. From now
    on, when the registry needs authentication, Docker will look in *${HOME}/.docker/config.json*
    to see if you have credentials stored for this hostname. If so, it will supply
    them. You will notice that one value is completely lacking here: a timestamp.
    These credentials are cached forever or until you tell Docker to remove them,
    whichever comes first.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 *${HOME}/.docker/config.json* 文件中以 JSON 格式包含 `docker.io` 凭据的用户 `someuser@example.com`。此配置文件支持存储多个注册表的凭据。在这种情况下，你只有一个条目，用于
    Docker Hub，但如果需要的话，你可以有更多条目。从现在开始，当注册表需要认证时，Docker 将查看 *${HOME}/.docker/config.json*，看看你是否为此主机名存储了凭据。如果是，它将提供这些凭据。你会注意到这里完全缺少一个值：时间戳。这些凭据将永久缓存，或者直到你告诉
    Docker 将它们删除为止。
- en: 'As with logging in, you can also log out of a registry if you no longer want
    to cache the credentials:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与登录类似，如果你不再希望缓存凭据，也可以注销注册表：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here you have removed the cached credentials and they are no longer stored
    by Docker. Some versions of Docker may even remove this file if it is empty. If
    you were trying to log in to something other than the Docker Hub registry, you
    could supply the hostname on the command line:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已经移除了缓存的凭据，它们不再被 Docker 存储。某些版本的 Docker 可能会在文件为空时甚至删除此文件。如果你尝试登录到除 Docker
    Hub 注册表之外的其他地方，你可以在命令行上提供主机名：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This would then add another auth entry into your *${HOME}/.docker/config.json*
    file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的 *${HOME}/.docker/config.json* 文件中添加另一个 auth 条目。
- en: Pushing images into a repository
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推送镜像到仓库
- en: 'The first step required to push your image is to ensure that you are logged
    in to the Docker repository you intend to use. For this example, we will focus
    on Docker Hub, so ensure that you are logged in to Docker Hub with your preferred
    credentials:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 推送镜像所需的第一步是确保你已登录到打算使用的 Docker 仓库。在本例中，我们将专注于 Docker Hub，因此请确保你已使用首选凭据登录到 Docker
    Hub：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once you are logged in, you can upload an image. Earlier, you used the command
    `docker image build -t example/docker-node-hello:latest .` to build the `docker-node-hello`
    image.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你登录，你就可以上传一个镜像。之前，你使用命令 `docker image build -t example/docker-node-hello:latest
    .` 来构建 `docker-node-hello` 镜像。
- en: In reality, the Docker client, and for compatibility reasons, many other container
    tools, actually interpret `example/docker-node-hello:latest` as `docker.io/example/docker-node-hello:latest`.
    Here, `docker.io` signifies the image registry hostname, and `example/docker-node-hello`
    is the repository inside the registry that contains the images in question.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Docker 客户端，以及出于兼容性原因，许多其他容器工具，实际上将 `example/docker-node-hello:latest` 解释为
    `docker.io/example/docker-node-hello:latest`。这里，`docker.io` 表示镜像注册表主机名，而 `example/docker-node-hello`
    是注册表内包含相关镜像的仓库。
- en: When you are building an image locally, the registry and repository name can
    be anything that you want. However, when you are going to upload your image to
    a real registry, you need that to match the login.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本地构建镜像时，注册表和仓库名称可以是任何你想要的。然而，当你要将你的镜像上传到真实的注册表时，你需要与登录匹配。
- en: 'You can easily edit the tags on the image that you already created by running
    the following command and replacing `${<myuser>}` with your Docker Hub username:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令并将 `${<myuser>}` 替换为你的 Docker Hub 用户名，轻松编辑已创建的镜像的标签：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you need to rebuild the image with the new naming convention or simply want
    to give it a try, you can accomplish this by running the following command in
    the *docker-node-hello* working directory that was generated when you performed
    the Git checkout earlier in the chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用新的命名约定重建镜像或只是想试试，你可以在*docker-node-hello*工作目录中运行以下命令，该目录是在本章早期执行Git检出时生成的。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For the following examples, you will need to replace `${<myuser>}` in all the
    examples with the user that you created in Docker Hub. If you are using a different
    registry, you will also need to replace `docker.io` with the hostname of the registry
    you are using.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的示例，你需要在所有示例中用你在Docker Hub创建的用户替换`${<myuser>}`。如果你使用不同的注册表，你还需要用你使用的注册表的主机名替换`docker.io`。
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On the first build, this will take a little time. If you rebuild the image,
    you may find that it is very fast. This is because most, if not all, of the layers
    already exist on your Docker server from the previous build. We can quickly verify
    that our image is indeed on the server by running `docker image ls ${<myuser>}/docker-node-hello`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次构建时会花费一些时间。如果重新构建镜像，可能会发现速度非常快。这是因为大多数，如果不是所有层已经存在于你的Docker服务器中，来自前一个构建。我们可以通过运行`docker
    image ls ${<myuser>}/docker-node-hello`快速验证我们的镜像确实在服务器上：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'It is possible to format the output of `docker image ls` to make it more concise
    by using the `--format` argument, like this: `docker image ls --format="table
    {{.ID}}\t{{.Repository}}"`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`docker image ls --format="table {{.ID}}\t{{.Repository}}"`这样的格式化输出`docker
    image ls`来使输出更加简洁。
- en: 'At this point you can upload the image to the Docker repository by using the
    `docker image push` command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以使用`docker image push`命令将镜像上传到Docker仓库：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If this image was uploaded to a public repository, anyone in the world can now
    easily download it by running the `docker image pull` command.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此镜像已上传到公共仓库，则任何人都可以通过运行`docker image pull`命令轻松下载它。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you uploaded the image to a private repository, then users must log in with
    credentials that have access to those repositories using the `docker login` command
    before they will be able to pull the image down to their local system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将镜像上传到私有仓库，则用户必须使用`docker login`命令登录具有访问权限的凭据，然后才能将镜像拉取到他们的本地系统中。
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Exploring images in Docker Hub
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索Docker Hub中的镜像
- en: In addition to simply using the [Docker Hub website](https://hub.docker.com)
    to explore what images are available, you can also use the `docker search` command
    to find images that might be useful.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单地使用[Docker Hub网站](https://hub.docker.com)浏览可用的镜像外，你还可以使用`docker search`命令找到可能有用的镜像。
- en: 'Running `docker search node` will return a list of images that contain the
    word `node` in either the image name or the description:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker search node`将返回一个包含名称或描述中包含`node`关键词的镜像列表：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `OFFICIAL` header tells you that the image is one of the [official curated
    images](https://docs.docker.com/docker-hub/official_images) on Docker Hub. This
    typically means that the image is maintained by the company or official development
    community that oversees that application. `AUTOMATED` denotes that the image is
    automatically built and uploaded by a CI/CD process triggered via commits to the
    underlying source code repository. Official images are always automated.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`OFFICIAL`标头告诉你该镜像是[Docker Hub上的官方精选镜像](https://docs.docker.com/docker-hub/official_images)之一。通常意味着该镜像由维护该应用程序的公司或官方开发社区维护。`AUTOMATED`表示该镜像是通过CI/CD流程自动构建和上传的，通过提交到底层源代码仓库触发。官方镜像始终是自动化的。'
- en: Running a Private Registry
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行私有注册表
- en: In keeping with the spirit of the open source community, Docker encourages the
    community to share Docker images via Docker Hub by default. There are times, however,
    when this is not a viable option due to commercial, legal, image retention, or
    reliability concerns.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 符合开源社区精神，Docker鼓励社区通过Docker Hub默认分享Docker镜像。然而，由于商业、法律、镜像保留或可靠性问题，有时这不是可行的选择。
- en: In these cases, it makes sense to host an internal private registry. Setting
    up a basic registry is not difficult, but for production use, you should take
    the time to familiarize yourself with all the available configuration options
    for [the open source Docker Registry (Distribution)](https://docs.docker.com/registry).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，建立内部私有注册表是有意义的。设置基本注册表并不难，但是对于生产使用，您应该花时间熟悉[开源 Docker Registry（分发）](https://docs.docker.com/registry)的所有可用配置选项。
- en: For this example, we are going to create a very simple secure registry using
    SSL and HTTP basic auth.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我们将使用 SSL 和 HTTP 基本认证创建一个非常简单的安全注册表。
- en: First, let’s create a few directories and files on our Docker server. If you
    are using a VM or cloud instance to run your Docker server, then you will need
    to SSH to that server for the next few commands. If you are using Docker Desktop
    or Community Edition, then you should be able to run these on your local system.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的 Docker 服务器上创建几个目录和文件。如果您使用虚拟机或云实例来运行 Docker 服务器，则需要 SSH 到该服务器执行接下来的命令。如果您使用
    Docker Desktop 或 Community Edition，则应该能够在本地系统上运行这些命令。
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Windows users may need to download additional tools, like `htppaswd`, or alter
    the non-Docker commands to accomplish the same tasks on your local system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户可能需要下载额外的工具，例如 `htppaswd`，或者修改非 Docker 命令以在本地系统上完成相同的任务。
- en: 'First let’s clone a Git repository that contains the basic files required to
    set up a simple, authenticated Docker registry:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们克隆一个包含设置简单认证 Docker 注册表所需基本文件的 Git 仓库：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once you have the files locally, you can change directories and examine the
    files that you just downloaded:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件下载到本地，您可以切换目录并查看刚刚下载的文件：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The *Dockerfile* simply takes the upstream registry image from Docker Hub and
    copies some local configuration and support files into a new image.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockerfile* 简单地从 Docker Hub 的上游注册表镜像中获取，并将一些本地配置和支持文件复制到新镜像中。'
- en: For testing, you can use some of the included sample files, but *do not* use
    these in production.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试时，您可以使用一些包含的示例文件，但是请*不要*在生产环境中使用这些文件。
- en: 'If your Docker server is available via `localhost` (127.0.0.1), then you can
    use these files unmodified by simply copying each of them like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Docker 服务器通过 `localhost` (127.0.0.1) 可用，则可以通过简单复制每个文件来使用这些文件而无需修改，如下所示：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If, however, your Docker server is on a remote IP address, then you will need
    to do a little additional work.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您的 Docker 服务器位于远程 IP 地址上，则需要做一些额外的工作。
- en: 'First, copy *config.yaml.sample* to *config.yaml*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 *config.yaml.sample* 复制到 *config.yaml*：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then edit *config.yaml* and replace `127.0.0.1` with the IP address of your
    Docker server so that:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编辑 *config.yaml* 并将 `127.0.0.1` 替换为您的 Docker 服务器的 IP 地址，以便：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'becomes something like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 变成类似这样：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is easy to create a registry using a fully qualified domain name (FQDN),
    like `my-registry.example.com`, but for this example, working with IP addresses
    is easier because no DNS is required.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全合格的域名（FQDN）如 `my-registry.example.com` 创建注册表非常容易，但是为了本示例，使用 IP 地址更加简单，因为不需要
    DNS。
- en: Next, you need to create an SSL keypair for your registry’s IP address.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要为注册表的 IP 地址创建 SSL 密钥对。
- en: 'One way to do this is with the following OpenSSL command. Note that you will
    need to set the IP address in this portion of the command, `/CN=172.17.42.10`,
    to match your Docker server’s IP address:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用以下 OpenSSL 命令。请注意，您需要在命令的这一部分 `/CN=172.17.42.10` 中设置 IP 地址，以匹配您的 Docker
    服务器的 IP 地址：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, you can either use the example `htpasswd` file by copying it:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过复制使用示例 `htpasswd` 文件：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'or you can create your own username and password pair for authentication by
    using a command like the following, replacing `${<username>}` and `${<password>}`
    with your preferred values:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以通过使用以下命令创建自己的用户名和密码对进行身份验证，替换 `${<username>}` 和 `${<password>}` 为您首选的值：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you look at the directory listing again, it should now look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次查看目录列表，现在应该是这样的：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If any of these files are missing, review the previous steps to ensure that
    you did not miss one, before moving on.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少任何这些文件，请回顾前面的步骤，确保您没有遗漏任何一个文件，然后继续。
- en: 'If everything looks correct, then you should be ready to build and run the
    registry:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切看起来正确，那么您应该准备构建和运行注册表：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you see errors like “docker: Error response from daemon: Conflict. The container
    name “/registry” is already in use,” then you need to either change the preceding
    container name or remove the existing container with that name. You can remove
    the container by running `docker container rm registry`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你看到类似“docker: Error response from daemon: Conflict. The container name “/registry”
    is already in use.”的错误，那么你需要更改前面的容器名称或删除具有该名称的现有容器。你可以通过运行 `docker container rm
    registry` 来删除容器。'
- en: Testing the private registry
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试私有仓库
- en: Now that the registry is running, you can test it. The very first thing that
    you need to do is authenticate against it. You will need to make sure that the
    IP address in the `docker login` matches the IP address of your Docker server
    that is running the registry.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在仓库正在运行，你可以进行测试。你需要做的第一件事就是对其进行身份验证。你需要确保 `docker login` 中的 IP 地址与运行仓库的 Docker
    服务器的 IP 地址匹配。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`myuser` is the default username, and `myuser-pw!` is the default password.
    If you generated your own `htpasswd`, then these will be whatever you choose.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`myuser` 是默认用户名，`myuser-pw!` 是默认密码。如果你生成了自己的 `htpasswd`，那么这些将是你选择的任何内容。'
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Warning
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This registry container has an embedded SSL key and is not using any external
    storage, which means that it contains a secret, and when you delete the running
    container, all your images will also be deleted. This is by design.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个仓库容器有一个嵌入式 SSL 密钥，并且没有使用任何外部存储，这意味着它包含一个秘密，当你删除运行中的容器时，所有你的镜像也将被删除。这是设计上的考虑。
- en: In production, you will want to have your containers pull secrets from a secrets
    management system and use some type of redundant external storage, like an object
    store. If you want to keep your development registry images between containers,
    you could add something like `--mount type=bind,source=/tmp/registry-data,target=/var/lib/registry`
    to your `docker container run` command to store the registry data on the Docker
    server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你将希望让你的容器从一个秘密管理系统中拉取秘密，并使用某种类型的冗余外部存储，比如对象存储。如果你想在容器之间保留开发仓库镜像，你可以在
    `docker container run` 命令中添加类似 `--mount type=bind,source=/tmp/registry-data,target=/var/lib/registry`
    的内容，将仓库数据存储在 Docker 服务器上。
- en: Now, let’s see if you can push the image you just built into your local private
    registry.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你是否可以将刚刚构建的镜像推送到你的本地私有仓库。
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In all of these commands, ensure that you use the correct IP address for your
    registry.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些命令中，请确保使用正确的 IP 地址来访问你的仓库。
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can then try to pull the same image from your repository:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以尝试从你的仓库中拉取相同的镜像：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: It’s worth keeping in mind that both Docker Hub and Docker Distribution expose
    an API endpoint that you can query for useful information. You can find out more
    information about the API via the [official documentation](https://github.com/distribution/distribution/blob/main/docs/spec/api.md).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Docker Hub 和 Docker Distribution 都暴露了一个可供查询有用信息的 API 端点。你可以通过 [官方文档](https://github.com/distribution/distribution/blob/main/docs/spec/api.md)
    了解更多关于 API 的信息。
- en: 'If you have not encountered any errors, then you have a working registry for
    development and can build on this foundation to create a production registry.
    At this point, you may want to stop the registry for the time being. You can easily
    accomplish this by running the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有遇到任何错误，那么你已经拥有一个可用于开发的仓库，并可以在此基础上构建生产仓库。此时，你可能希望暂时停止仓库。你可以通过运行以下命令轻松实现：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Tip
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As you become comfortable with Docker Distribution, you may also want to consider
    exploring the Cloud Native Computing Foundation (CNCF) open source project, called
    [Harbor](https://goharbor.io), which extends the Docker Distribution with a lot
    of security and reliability-focused features.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对 Docker Distribution 的熟悉程度增加，你可能还想考虑探索云原生计算基金会（CNCF）的开源项目 [Harbor](https://goharbor.io)，它通过许多安全和可靠性功能扩展了
    Docker Distribution。
- en: Optimizing Images
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化镜像
- en: After you have spent a little bit of time working with Docker, you will quickly
    notice that keeping your image sizes small and your build times fast can be very
    beneficial in decreasing the time required to build and deploy new versions of
    your software into production. In this section, we will talk a bit about some
    of the considerations you should always keep in mind when designing your images
    and a few techniques that can help you achieve these goals.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你花费一点时间使用 Docker 后，你很快会注意到，保持镜像大小小和构建时间快可以极大地减少构建和部署新软件版本所需的时间。在本节中，我们将讨论设计镜像时应始终牢记的一些考虑因素，以及一些可以帮助你实现这些目标的技术。
- en: Keeping Images Small
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持镜像小巧
- en: In most modern businesses, downloading a single 1 GB file from a remote location
    on the internet is not something that people often worry about. It is so easy
    to find software on the internet that people will often rely on simply re-downloading
    it if they need it again, instead of keeping a local copy for the future. This
    may often be acceptable when you truly need a single copy of this software on
    a single server, but it can quickly become a scaling problem when you need the
    same software on 100+ nodes and you deploy new releases multiple times a day.
    Downloading these large files can quickly cause network congestion and slower
    deployment cycles that have a real impact on the production environment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代企业中，从互联网上的远程位置下载一个 1 GB 的单个文件并不是人们经常担心的事情。在互联网上找到软件非常容易，人们通常会依赖重新下载它，而不是为未来保留本地副本。当你确实需要在单个服务器上的单个副本时，这可能是可以接受的，但当你需要在
    100+ 节点上安装相同的软件并且每天部署新版本时，它很快会成为一个扩展性问题。下载这些大文件可能会迅速导致网络拥塞和更慢的部署周期，这对生产环境有真正的影响。
- en: For convenience, a large number of Linux containers inherit from a base image
    that contains a minimal Linux distribution. Although this is an easy starting
    place, it isn’t required. Containers only need to contain the files that are required
    to run the application on the host kernel, and nothing else. The best way to explain
    this is to explore a very minimal container.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，许多 Linux 容器继承自一个包含最小 Linux 发行版的基础镜像。尽管这是一个简单的起点，但并非必需。容器只需要包含在主机内核上运行应用程序所需的文件，而不需要其他内容。最好的解释方法是探索一个非常精简的容器。
- en: Go is a compiled programming language that can easily generate statically compiled
    binary files. For this example, we are going to use a very small web application
    written in Go that can be found on [GitHub](https://github.com/spkane/scratch-helloworld).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种编译型编程语言，可以轻松生成静态编译的二进制文件。在这个例子中，我们将使用一款非常小的用 Go 编写的网络应用程序，可以在 [GitHub](https://github.com/spkane/scratch-helloworld)
    找到。
- en: 'Let’s go ahead and try out the application so that you can see what it does.
    Run the following command, and then open up a web browser and point it to your
    Docker host on port 8080 (e.g., *http://127.0.0.1:8080* for Docker Desktop and
    Community Edition):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试试这个应用程序，看看它的作用。运行以下命令，然后打开一个 Web 浏览器，将其指向你的 Docker 主机的 8080 端口（例如，*http://127.0.0.1:8080*
    适用于 Docker Desktop 和 Community Edition）：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If all goes well, you should see the following message in your web browser:
    “Hello World from Go in minimal Linux container.” Now let’s take a look at what
    files this container comprises. It would be fair to assume that at a minimum it
    will include a working Linux environment and all the files required to compile
    Go programs, but you will soon see that this is not the case.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该在 Web 浏览器中看到以下消息：“Hello World from Go in minimal Linux container.”
    现在让我们来看看这个容器包含哪些文件。可以合理地假设，至少包括一个工作中的 Linux 环境和编译 Go 程序所需的所有文件，但你很快会发现情况并非如此。
- en: 'While the container is still running, execute the following command to determine
    what the container ID is. The following command returns the information for the
    last container that you created:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器仍在运行时，执行以下命令来确定容器的 ID 是什么。以下命令返回你创建的最后一个容器的信息：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can then use the container ID that you obtained from running the previous
    command to export the files in the container into a tarball, which can be easily
    examined:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用之前运行命令获取的容器 ID 来将容器中的文件导出为一个 tarball，这样可以很容易地进行检查：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Using the `tar` command, you can now examine the contents of your container
    at the time of the export:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tar` 命令，你现在可以查看导出时容器的内容：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first thing you might notice here is that there are almost no files in this
    container, and almost all of them are zero bytes in length. All of the files that
    have a zero length are required to exist in every Linux container and are automatically
    [bind-mounted](https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount)
    from the host into the container when it is first created. All of these files,
    except for *.dockerenv*, are critical files that the kernel needs to do its job
    properly. The only file in this container that has any actual size and is related
    to our application is the statically compiled `helloworld` binary.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这个容器里几乎没有文件，几乎所有文件的大小都是零字节。所有长度为零的文件都需要存在于每个 Linux 容器中，并在首次创建容器时自动从主机进行
    [绑定挂载](https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount) 到容器中。除了
    *.dockerenv* 之外的所有这些文件都是内核需要正常工作的关键文件。在这个容器中唯一具有实际大小并与我们的应用程序相关的文件是静态编译的 `helloworld`
    二进制文件。
- en: The takeaway from this exercise is that your containers are only required to
    contain exactly what they need to run on the underlying kernel. Everything else
    is unnecessary. Because it is often useful for troubleshooting to have access
    to a working shell in your container, people will often compromise and build their
    images from a very lightweight Linux distribution like Alpine Linux.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这次练习的要点是，你的容器只需要包含在底层内核上运行所需的内容。其他都是不必要的。由于在故障排除时通常需要访问容器中的工作 shell，人们经常会妥协并使用像
    Alpine Linux 这样非常轻量的 Linux 发行版构建他们的镜像。
- en: Tip
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you find yourself exploring image files a lot, you might want to take a look
    at the tool [dive](https://github.com/wagoodman/dive), which provides a nice CLI
    interface for understanding what an image contains.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己经常探索镜像文件，你可能想看看工具 [dive](https://github.com/wagoodman/dive)，它提供了一个良好的
    CLI 接口来理解一个镜像包含的内容。
- en: To dive into this a little deeper, let’s look at that same container again so
    that we can dig into the underlying filesystem and compare it with the popular
    `alpine` base image.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地探讨一下，让我们再次看看同一个容器，以便我们可以深入研究底层文件系统，并将其与流行的 `alpine` 基础镜像进行比较。
- en: Although we could easily poke around in the `alpine` image by simply running
    `docker container run -ti alpine:latest /bin/sh`, we cannot do this with the `spkane/scratch-helloworld`
    image, because it does not contain a shell or SSH. This means that we can’t use
    `ssh`, `nsenter`, or `docker container exec` to examine it, though there is an
    advanced trick discussed in [“Debugging Shell-less Containers”](ch11.html#shellless).
    Earlier, we took advantage of the `docker container export` command to create
    a *.tar* file that contained a copy of all the files in the container, but this
    time around we are going to examine the container’s filesystem by connecting directly
    to the Docker server and then looking into the container’s filesystem itself.
    To do this, we need to find out where the image files reside on the server’s disk.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以简单地通过运行 `docker container run -ti alpine:latest /bin/sh` 来探索 `alpine`
    镜像，但我们无法对 `spkane/scratch-helloworld` 镜像进行此操作，因为它不包含 shell 或 SSH。这意味着我们无法使用 `ssh`、`nsenter`
    或 `docker container exec` 来检查它，尽管在 [“调试无 Shell 容器”](ch11.html#shellless) 中讨论了一个高级技巧。此前，我们利用了
    `docker container export` 命令创建了一个 *.tar* 文件，其中包含容器中所有文件的副本，但这一次我们将通过直接连接到 Docker
    服务器并查看容器的文件系统来检查容器的文件系统。为此，我们需要找出镜像文件在服务器磁盘上的位置。
- en: 'To determine where on the server our files are actually being stored, run `docker
    image inspect` on the `alpine:latest` image:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定服务器上实际存储我们文件的位置，请在 `alpine:latest` 镜像上运行 `docker image inspect`：
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And then on the `spkane/scratch-helloworld:latest` image:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `spkane/scratch-helloworld:latest` 镜像上：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this particular example, we are going to use Docker Desktop running on macOS,
    but this general approach will work on most Docker servers. However, you can access
    your Docker server via whatever method is easiest.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们将使用运行在 macOS 上的 Docker Desktop，但这种一般方法也适用于大多数 Docker 服务器。但是，你可以通过最简单的方法访问你的
    Docker 服务器。
- en: 'Since we are using Docker Desktop, we need to use our `nsenter` trick to enter
    the SSH-less VM and explore the filesystem:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 Docker Desktop，我们需要使用我们的 `nsenter` 技巧进入无 SSH 的虚拟机并探索文件系统：
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Inside the VM, we should now be able to explore the various directories listed
    in the `GraphDriver` section of the `docker image inspect` commands.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机中，我们现在应该能够探索 `docker image inspect` 命令的 `GraphDriver` 部分中列出的各种目录。
- en: 'In this example, if we look at the first entry for the `alpine` image, we will
    see that it is labeled `MergedDir` and lists the folder */var/lib/docker/overlay2/ea86408b2b15d33ee27d78ff44f82104705286221f055ba1331b58673f4b313a/merged*.
    If we list that directory, we will get an error, but from listing the parent directory,
    we quickly discover that we actually want to look at the *diff* directory:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果我们查看`alpine`镜像的第一个条目，我们会看到它标记为`MergedDir`并列出了文件夹*/var/lib/docker/overlay2/ea86408b2b15d33ee27d78ff44f82104705286221f055ba1331b58673f4b313a/merged*。如果我们列出那个目录，会得到一个错误，但从列出父目录开始，我们很快发现我们实际上想要查看*diff*目录：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, `alpine` happens to be a very small base image, weighing in at only 4.5
    MB, and it is ideal for building containers on top of it. However, we can see
    that there is still a lot of stuff in this container before we have started to
    build anything from it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`alpine`碰巧是一个非常小的基础镜像，仅有4.5 MB，非常适合在其上构建容器。但是，在我们开始构建任何内容之前，我们可以看到这个容器中仍然有很多内容。
- en: 'Now, let’s take a look at the files in the `spkane/scratch-helloworld` image.
    In this case, we want to look at the first directory from the `LowerDir` entry
    of the `docker image inspect` output, which you’ll notice also ends in a directory
    called *diff*:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`spkane/scratch-helloworld`镜像中的文件。在这种情况下，我们要查看`docker image inspect`输出中`LowerDir`条目的第一个目录，你还会注意到这个目录也以名为*diff*的目录结尾：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You’ll notice that there is only a single file in this directory, and it is
    3.4 MB. This `helloworld` binary is the only file shipped in this container and
    is smaller than the starting size of the `alpine` image before any application
    files have been added to it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到该目录中只有一个文件，大小为3.4 MB。这个`helloworld`二进制文件是此容器中唯一的文件，并且比`alpine`镜像的起始大小小，这还没有添加任何应用程序文件。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to run the `helloworld` application from that directory on your
    Docker server because it does not require any other files. You really don’t want
    to do this on anything but a development box, but it can help drive the point
    home about how useful these types of statically compiled applications can be.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Docker服务器上的该目录中运行`helloworld`应用程序，因为它不需要任何其他文件。但除了开发环境外，你真的不想这样做，但它可以帮助强调这类静态编译应用程序的实用性。
- en: Multistage builds
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多阶段构建
- en: 'There is a way you can constrain containers to an even smaller size in many
    cases: multistage builds. This is how we recommend that you build most production
    containers. You don’t have to worry as much about bringing in extra resources
    to build your application, and you can still run a lean production container.
    Multistage containers also encourage doing builds inside Docker, which is a great
    pattern for repeatability in your build system.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，有一种方法可以将容器限制在更小的大小范围内：多阶段构建。这是我们建议您构建大多数生产容器的方式。您无需过多担心引入额外的资源来构建应用程序，并且仍然可以运行一个精简的生产容器。多阶段容器还鼓励在Docker内部进行构建，这是构建系统中重复性的一个很好的模式。
- en: As the original author of [the `scratch-helloworld` application has written](https://medium.com/@adriaandejonge/simplify-the-smallest-possible-docker-image-62c0e0d342ef),
    the release of multistage build support in Docker itself has made the process
    of creating small containers much easier than it used to be. In the past, to do
    the same thing that multistage delivers for nearly free, you were required to
    build one image that compiled your code, extract the resulting binary, and then
    build a second image without all the build dependencies that you would then inject
    that binary into. This was often difficult to set up and did not always work out
    of the box with standard deployment pipelines.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[scratch-helloworld应用程序的原始作者所写](https://medium.com/@adriaandejonge/simplify-the-smallest-possible-docker-image-62c0e0d342ef)，Docker本身对多阶段构建支持的发布使得创建小容器的过程比过去更容易。过去，要做多阶段提供几乎免费的同样事情，你需要构建一个编译代码的镜像，提取生成的二进制文件，然后构建第二个镜像，而不包含所有构建依赖项，然后将该二进制文件注入其中。这通常很难设置，并且在标准部署流水线中不总是能正常工作。
- en: 'Today, you can now achieve similar results using a *Dockerfile* as simple as
    this one:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，你可以使用一个如下简单的*Dockerfile*来实现类似的结果：
- en: '[PRE65]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first thing you’ll notice about this *Dockerfile* is that it looks a lot
    like two *Dockerfile*s that have been combined into one. Indeed this is the case,
    but there is more to it. The `FROM` command has been extended so that you can
    name the image during the build phase. In this example, the first line, which
    reads `FROM docker.io/golang as builder`, means that you want to base your build
    on the `golang` image and will be referring to this build image/stage as `builder`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件你会注意到的关于这个*Dockerfile*的事情是它看起来很像两个*Dockerfile*合并在一起。实际上确实如此，但还有更多。`FROM`命令已经扩展，以便你可以在构建阶段命名镜像。在这个例子中，第一行是`FROM
    docker.io/golang as builder`，意味着你想要基于`golang`镜像进行构建，并在构建图像/阶段中引用它为`builder`。
- en: On the fourth line, you’ll see another `FROM` line, which was not allowed before
    the introduction of multistage builds. This `FROM` line uses a special image name,
    called `scratch`, that tells Docker to start from an empty image, which includes
    no additional files. The next line, which reads `COPY --from=builder /go/bin/scratch-helloworld
    /helloworld`, allows you to copy the binary that you built in the *builder* image
    directly into the current image. This will ensure that you end up with the smallest
    container possible.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行，你会看到另一个`FROM`行，这在多阶段构建引入之前是不允许的。这个`FROM`行使用一个特殊的镜像名称`scratch`，告诉Docker从一个空镜像开始，其中不包含任何附加文件。接下来的一行，即`COPY
    --from=builder /go/bin/scratch-helloworld /helloworld`，允许你直接将在*builder*镜像中构建的二进制文件复制到当前镜像中。这将确保你最终得到尽可能小的容器。
- en: The `EXPOSE 8080` line is documentation that is intended to inform users which
    port(s) and protocols (TCP is the default protocol) the service listens on.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE 8080`行是文档，旨在通知用户服务监听的端口(s)和协议（TCP是默认协议）。'
- en: 'Let’s try to build this and see what happens. First, create a directory where
    you can work, and then, using your favorite text editor, paste the content from
    the preceding example into a file called *Dockerfile*:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建并查看结果。首先，创建一个工作目录，然后使用你喜欢的文本编辑器，将前面示例中的内容粘贴到名为*Dockerfile*的文件中：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Tip
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can download a copy of this *Dockerfile* from [GitHub](https://oreil.ly/C1TSz).^([5](ch04.html#idm46803152409712))
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[GitHub](https://oreil.ly/C1TSz)下载此*Dockerfile*的副本。^([5](ch04.html#idm46803152409712))
- en: 'We can now start the multistage build:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始多阶段构建：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You’ll notice that the output looks like most other builds and still ends by
    reporting the successful creation of our final, very minimal image.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到输出看起来像大多数其他构建，并最终报告成功创建了我们的最终极简镜像。
- en: Warning
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you are compiling binaries on your local system that use shared libraries,
    you need to be careful to ensure that the correct versions of those shared libraries
    are also available to the process inside the container.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在本地系统上编译使用共享库的二进制文件，你需要小心确保这些共享库的正确版本也对容器内的进程可用。
- en: You are not limited to two stages, and in fact, none of the stages need to even
    be related to one another. They will be run in order. You could, for example,
    have a stage based on the public Go image that builds your underlying Go application
    to serve an API, and another stage based on the Angular container to build your
    frontend web UI. The final stage could then combine outputs from both.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你不限于两个阶段，实际上，这些阶段不需要彼此相关。它们将按顺序运行。例如，你可以基于公共Go镜像创建一个阶段，构建你的基础Go应用程序以提供API，还可以基于Angular容器创建另一个阶段，构建你的前端Web
    UI。最终阶段可以组合来自两者的输出。
- en: Tip
  id: totrans-302
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As you start to build more complex images, you may find that being limited to
    a single build context is challenging. The `docker-buildx` plug-in, which we discuss
    near the end of this chapter, is capable of supporting [multiple build contexts](https://www.docker.com/blog/dockerfiles-now-support-multiple-build-contexts),
    which can be used to support some very advanced workflows.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建更复杂的镜像时，你可能会发现仅限于单个构建上下文是有挑战性的。我们在本章末讨论的`docker-buildx`插件能够支持[多个构建上下文](https://www.docker.com/blog/dockerfiles-now-support-multiple-build-contexts)，可以支持一些非常先进的工作流程。
- en: Layers Are Additive
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次是累加的
- en: Something that is not apparent until you dig much deeper into how images are
    built is that the filesystem layers that make up your images are strictly additive
    by design. Although you can shadow/mask files in previous layers, you cannot delete
    those files. In practice, this means that you cannot make your image smaller by
    simply deleting files that were generated in earlier steps.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 直到深入挖掘镜像构建方式的更多细节之前，可能不明显的一点是构成您镜像的文件系统层是严格累加的设计。虽然您可以在先前的层中遮蔽/掩盖文件，但不能删除这些文件。实际上，这意味着您不能通过简单地删除在较早步骤中生成的文件来减小镜像的大小。
- en: Note
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you enable experimental features on your Docker server, it is possible to
    squash a bunch of layers into a single layer using `docker image build --squash`.
    This will cause all of the files that were deleted in the intermediate layers
    to actually disappear from the final image and can therefore recover a lot of
    wasted space, but it also means that the whole layer must be downloaded by every
    system that requires it, even when only a single line of source code was updated,
    so there are real trade-offs to using this approach.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您的Docker服务器上启用了实验性功能，可以使用`docker image build --squash`将一堆层压缩成单个层。这将导致所有在中间层中删除的文件实际上从最终镜像中消失，并且因此可以恢复大量浪费的空间，但这也意味着每个需要该层的系统都必须下载整个层，即使只更新了一行源代码，因此在使用这种方法时存在实际的权衡。
- en: 'The easiest way to explain the additive nature of image layers is by using
    some practical examples. In a new directory, [download](https://github.com/bluewhalebook/docker-up-and-running-3rd-edition/blob/main/chapter_04/additive)
    or create the following file, which will generate an image that launches the Apache
    web server running on Fedora Linux:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 解释镜像层次累加性质最简单的方法是使用一些实际的例子。在一个新目录中，[下载](https://github.com/bluewhalebook/docker-up-and-running-3rd-edition/blob/main/chapter_04/additive)或创建以下文件，这将生成一个在Fedora
    Linux上运行Apache Web服务器的镜像：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'and then build it like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像这样构建它：
- en: '[PRE69]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let’s go ahead and tag the resulting image so that you can easily refer to
    it in subsequent commands:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续标记生成的镜像，这样您就可以在后续命令中轻松引用它：
- en: '[PRE70]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now let’s take a look at our image with the `docker image history` command.
    This command will give us some insight into the filesystem layers and build steps
    that our image uses:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用`docker image history`命令来查看我们的镜像。这个命令将为我们提供有关文件系统层和构建步骤的一些见解：
- en: '[PRE71]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You’ll notice that three of the layers added no size to our final image, but
    two of them increase the size a great deal. The layer that is 163 MB makes sense,
    as this is the base Fedora image that includes a minimal Linux distribution; however,
    the 273 MB layer is surprising. The Apache web server shouldn’t be nearly that
    large, so what’s going on here, exactly?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到三个层未增加我们最终镜像的大小，但两个层大大增加了大小。163 MB的层次是有道理的，因为这是包含最小Linux发行版的基本Fedora镜像；然而，273
    MB的层次令人惊讶。Apache Web服务器不应该那么大，到底发生了什么？
- en: 'If you have experience with package managers like `apk`, `apt`, `dnf`, or `yum`,
    then you may know that most of these tools rely heavily on a large cache that
    includes details about all the packages that are available for installation on
    the platform in question. This cache uses up a huge amount of space and is completely
    useless once you have installed the packages you need. The most obvious next step
    is to simply delete the cache. On Fedora systems, you could do this by editing
    your *Dockerfile* so that it looks like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有使用`apk`、`apt`、`dnf`或`yum`等包管理器的经验，那么您可能知道大多数工具都严重依赖于一个包含平台上所有可安装软件包详细信息的大缓存。这个缓存占用了大量空间，并且在安装完您需要的软件包后就完全没有用了。最明显的下一步是简单地删除缓存。在Fedora系统上，您可以通过编辑您的*Dockerfile*来实现这一点，使其看起来像这样：
- en: '[PRE72]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'and then building, tagging, and examining the resulting image:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后构建、标记和检查生成的镜像：
- en: '[PRE73]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If you look carefully at the output from the `docker image history` command,
    you’ll notice that you have created a new layer that adds `71.8kB` to the image,
    but you have not decreased the size of the problematic layer at all. What is happening,
    exactly?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细观察`docker image history`命令的输出，您会注意到已创建了一个新层，将`71.8kB`添加到镜像中，但并未减少问题层的大小。到底发生了什么？
- en: The important thing to understand is that image layers are strictly *additive*
    in nature. Once a layer is created, nothing can be removed from it. This means
    that you cannot make earlier layers in an image smaller by deleting files in subsequent
    layers. When you delete or edit files in subsequent layers, you’re simply masking
    the older version with the modified or removed version in the new layer. This
    means that the only way you can make a layer smaller is by removing files before
    you save the layer.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解图像层的严格*增量*性质。一旦创建了一个层，就无法从中删除任何内容。这意味着您不能通过删除后续层中的文件来缩小图像中的较早层。当您删除或编辑后续层中的文件时，您只是用新层中的修改或移除版本掩盖了旧版本。这意味着您可以通过在保存层之前删除文件来使层变小的唯一方法。
- en: The most common way to deal with this is by stringing commands together on a
    single *Dockerfile* line. You can do this very easily by taking advantage of the
    `&&` operator. This operator acts as a Boolean `AND` statement and basically translates
    into English as “and if the previous command ran successfully, run this command.”
    In addition to this, you can take advantage of the `\` operator, which is used
    to indicate that a command continues after the newline. This can help improve
    the readability of long commands.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的最常见方法是将命令串联在一个单独的*Dockerfile*行上。您可以通过利用`&&`运算符来轻松做到这一点。此运算符充当布尔`AND`语句，并且基本上可以翻译为“如果前一个命令成功运行，则运行此命令”。除此之外，您还可以利用`\`运算符，该运算符用于指示命令在换行后继续。这可以提高长命令的可读性。
- en: 'With this knowledge in hand, you can rewrite the *Dockerfile* like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，你可以像这样重写*Dockerfile*：
- en: '[PRE74]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now you can rebuild the image and see how this change has impacted the size
    of the layer that includes the `http` daemon:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以重新构建图像，看看这种更改如何影响包含`http`守护程序的层的大小：
- en: '[PRE75]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the first two examples, the layer in question was 273 MB in size, but now
    that you have removed many unnecessary files that were added to that layer, you
    can shrink the layer down to 44.8 MB. This is a very large saving of space, especially
    when you consider how many servers might be pulling the image down during any
    given deployment.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个示例中，涉及的层大小为273 MB，但现在您已删除了许多不必要的文件，这些文件被添加到该层中，因此可以将该层缩小至44.8 MB。这是非常大的空间节省，特别是考虑到在任何给定部署期间可能有多少服务器在下载镜像。
- en: Utilizing the Layer Cache
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用层缓存
- en: The final building technique that we will cover here is related to keeping build
    times as fast as possible. One of the important goals of the DevOps movement is
    to keep feedback loops as tight as possible. This means that it is important to
    try to ensure that problems are discovered and reported as quickly as possible
    so that they can be fixed when people are still completely focused on the code
    in question and haven’t moved on to other unrelated tasks.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里介绍的最终构建技术与尽可能保持构建时间快速相关。DevOps运动的一个重要目标是尽可能保持反馈循环紧凑。这意味着重要的是尽快发现和报告问题，以便在人们仍然完全专注于相关代码而未转向其他无关任务时进行修复。
- en: During any standard build process, Docker uses a layer cache to try to avoid
    rebuilding any image layers that it has already built and that do not contain
    any noticeable changes. Because of this cache, the order in which you do things
    inside your *Dockerfile* can have a dramatic impact on how long your builds take
    on average.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何标准构建过程中，Docker使用层缓存来尝试避免重建它已经构建的任何图像层，而这些层不包含任何显著的更改。由于这个缓存，您在*Dockerfile*中执行操作的顺序可能会对平均构建时间产生显著影响。
- en: For starters, let’s take the *Dockerfile* from the previous example and customize
    it just a bit so that it looks like this.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从之前的示例中获取*Dockerfile*，稍作定制，使其看起来像这样。
- en: Tip
  id: totrans-333
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Along with the other examples, you can also find these files on [GitHub](https://github.com/bluewhalebook/docker-up-and-running-3rd-edition/blob/main/chapter_04/cache).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他示例，您还可以在[GitHub](https://github.com/bluewhalebook/docker-up-and-running-3rd-edition/blob/main/chapter_04/cache)上找到这些文件。
- en: '[PRE76]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, in the same directory, let’s also create a new file called *index.html*
    that looks like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个目录中，让我们还创建一个名为*index.html*的新文件，其内容如下：
- en: '[PRE77]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'For the first test, let’s time the build without using the Docker cache at
    all, by using the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次测试，让我们通过使用以下命令，在完全不使用Docker缓存的情况下计时构建：
- en: '[PRE78]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Tip
  id: totrans-340
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Windows users should be able to run this command in a WSL2 session or use the
    PowerShell [`Measure-Command`](https://oreil.ly/MQQY_)^([6](ch04.html#idm46803151763616))
    function to replace the Unix `time` command used in these examples.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户应该能够在 WSL2 会话中运行此命令，或者使用 PowerShell [`Measure-Command`](https://oreil.ly/MQQY_)^([6](ch04.html#idm46803151763616))
    函数替换这些示例中使用的 Unix `time` 命令。
- en: 'The output from the `time` command tells us that the build without the cache
    took about a minute and 21 seconds and only pulled the base image from the layer
    cache. If you rebuild the image immediately afterward and allow Docker to use
    the cache, you will see that the build is very fast:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `time` 命令的输出可以看出，没有使用缓存的构建大约花了 1 分钟 21 秒，只从层缓存中获取了基础镜像。如果立即之后重新构建镜像并允许 Docker
    使用缓存，你会发现构建速度非常快：
- en: '[PRE79]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Since none of the layers changed, and the cache could be fully leveraged for
    all four build steps, the build took only a fraction of a second to complete.
    Now, let’s make a small improvement to the *index.html* file so that it looks
    like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有任何层发生更改，并且可以完全利用所有四个构建步骤的缓存，构建只需不到一秒钟即可完成。现在，让我们对 *index.html* 文件进行小改进，使其看起来像这样：
- en: '[PRE80]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'and then let’s time the rebuild again:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们再次计算重建时间：
- en: '[PRE81]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If you look at the output carefully, you will see that the cache was used for
    most of the build. It wasn’t until step `4/4`, when Docker needed to copy *index.html*,
    that the cache was invalidated and the layers had to be re-created. Because the
    cache could be used for most of the build, the build still did not exceed a second.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看输出，你会发现大部分构建都使用了缓存。直到第 `4/4` 步，当 Docker 需要复制 *index.html* 时，缓存才会失效，需要重新创建层。因为大部分构建可以使用缓存，所以构建仍然没有超过一秒钟。
- en: 'But what would happen if you changed the order of the commands in the *Dockerfile*
    so that they looked like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你改变 *Dockerfile* 中命令的顺序，使其看起来像这样，会发生什么：
- en: '[PRE82]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let’s quickly time another test build without the cache to get a baseline:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速计时另一个不使用缓存的测试构建，以获得一个基准：
- en: '[PRE83]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In this case, the build took 51 seconds to complete: since we used the `--no-cache`
    argument, we know that nothing was pulled from the layer cache, except for the
    base image. The difference in time from the very first test is entirely due to
    fluctuating network speeds and has nothing to do with the changes that you have
    made to the *Dockerfile*.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，构建过程需要 51 秒才能完成：因为我们使用了 `--no-cache` 参数，我们知道除了基础镜像外，没有从层缓存中获取任何内容。从第一次测试开始到现在的时间差完全是由于网络速度波动引起的，与你对
    *Dockerfile* 所做的更改无关。
- en: 'Now, let’s edit *index.html* again, like so:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次编辑 *index.html*，如下所示：
- en: '[PRE84]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And now, let’s time the image rebuild while using the cache:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在使用缓存的情况下再次计时镜像重建：
- en: '[PRE85]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The first time that you rebuilt the image, after editing the *index.html* file,
    it took only .456 seconds, but this time it took 43.695 seconds, almost exactly
    as long as it took to build the whole image without using the cache at all.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次编辑 *index.html* 文件后重新构建镜像时，仅花费了 0.456 秒，但这次花费了 43.695 秒，几乎与完全不使用缓存构建整个镜像的时间相同。
- en: 'This is because you have modified the *Dockerfile* so that the *index.html*
    file is copied into the image very early in the process. The problem with doing
    it this way is that the *index.html* file changes frequently and will often invalidate
    the cache. The other issue is that it is unnecessarily placed before a very time-consuming
    step in our *Dockerfile*: installing the Apache web server.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为你修改了 *Dockerfile*，使得 *index.html* 文件在构建过程中很早就被复制到镜像中。这样做的问题是 *index.html*
    文件经常更改，并且通常会使缓存失效。另一个问题是它不必要地放在我们 *Dockerfile* 中一个非常耗时的步骤之前：安装 Apache Web 服务器。
- en: The important lesson to take away from all of this is that order matters, and
    in general, you should always try to order your *Dockerfile* so that the most
    stable and time-consuming portions of your build process happen first and your
    code is added as late in the process as possible.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些中获得的重要教训是顺序很重要，一般来说，你应该尽量将 *Dockerfile* 的最稳定和耗时的部分放在最前面，并尽可能晚地添加你的代码。
- en: For projects that require you to install dependencies based on your code using
    tools like `npm` and `bundle`, it is also a good idea to do some research about
    optimizing your Docker builds for those platforms. This often includes locking
    down your dependency versions and storing them along with your code so that they
    do not need to be downloaded for each and every build.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要使用像`npm`和`bundle`等工具根据您的代码安装依赖项的项目，建议您对优化这些平台上的Docker构建进行一些研究。这通常包括锁定依赖版本并将它们与代码一起存储，以便不需要在每次构建时重新下载它们。
- en: Directory Caching
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录缓存
- en: One of the many features that BuildKit adds to the image-building experience
    is directory caching. Directory caching is an incredibly useful tool for speeding
    up build times without saving a lot of files that are unnecessary for the runtime
    into your image. In essence, it allows you to save the contents of a directory
    inside your image in a special layer that can be bind-mounted at build time and
    then unmounted before the image snapshot is made. This is often used to handle
    directories where tools like Linux software installers (`apt`, `apk`, `dnf`, etc.),
    and language dependency managers (`npm`, `bundler`, `pip`, etc.), download their
    databases and archive files.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: BuildKit为镜像构建体验增加的众多功能之一是目录缓存。目录缓存是一个极其有用的工具，可以加快构建时间，同时避免将对运行时不必要的大量文件保存到您的映像中。本质上，它允许您将目录内容保存在映像内的一个特殊层中，在构建时可以将其绑定挂载，然后在生成映像快照之前卸载。通常用于处理诸如Linux软件安装程序（`apt`、`apk`、`dnf`等）和语言依赖管理器（`npm`、`bundler`、`pip`等）下载其数据库和归档文件的目录。
- en: Tip
  id: totrans-364
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: If you are unfamiliar with bind mounts and what they are, you can find a [bind
    mount overview](https://docs.docker.com/storage/bind-mounts) in the Docker documentation.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉绑定挂载及其用途，可以在Docker文档中找到[绑定挂载概述](https://docs.docker.com/storage/bind-mounts)。
- en: 'To make use of directory caching, you must have BuildKit enabled. In most circumstances,
    this should already be the case, but you can force it from the client side, by
    setting the environment variable `DOCKER_BUILDKIT=` to `1`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用目录缓存，您必须启用BuildKit。在大多数情况下，这应该已经实现了，但是您可以通过设置环境变量`DOCKER_BUILDKIT=`为`1`来强制从客户端进行操作：
- en: '[PRE86]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let’s explore directory caching by checking out the following git repository
    and seeing how utilizing directory caching can significantly improve consecutive
    builds while still keeping the resulting image sizes smaller:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检出以下git仓库来探索目录缓存，并看看如何利用目录缓存可以显著改善连续构建的效率，同时保持生成的映像大小更小：
- en: '[PRE87]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This codebase has a very generic *Dockerfile* checked into the repo. Let’s
    go ahead and see how long it takes to build this image, with and without the layer
    cache, and let’s also examine how large the resulting image is:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码库有一个非常通用的*Dockerfile*提交到仓库中。让我们继续看看构建此映像所需的时间，以及是否使用层缓存，还要检查生成的映像大小：
- en: '[PRE89]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: From this output, we can see that this image takes just under 29 seconds to
    build without the layer cache and just under 2 seconds to build when it can fully
    utilize the layer cache. The resulting image size is 293 MB in total.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 从此输出中，我们可以看到，如果完全利用层缓存，则构建此映像仅需不到2秒，而不使用层缓存则需要将近29秒。生成的映像总大小为293 MB。
- en: Tip
  id: totrans-374
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: BuildKit finally has support for [modifying or completely disabling the colors
    used for the output](https://github.com/moby/buildkit#color-output-controls).
    This is particularly nice for anyone who uses a dark background in their terminal.
    You can configure these colors by setting something like `export BUILDKIT_` `COLORS=run=green:warning=yellow:error=red:cancel=cyan`
    in your environment, or you can completely disable the colors by setting `export
    NO_COLOR=true`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: BuildKit最终支持[修改或完全禁用输出中使用的颜色](https://github.com/moby/buildkit#color-output-controls)。对于那些在终端中使用黑色背景的用户来说，这尤其方便。您可以通过设置类似于`export
    BUILDKIT_COLORS=run=green:warning=yellow:error=red:cancel=cyan`这样的方式来配置这些颜色，或者通过设置`export
    NO_COLOR=true`来完全禁用颜色。
- en: Note that the BuildKit version used in various `docker` components and third-party
    tools is still being updated, so it might not work yet in every situation.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，各种`docker`组件和第三方工具中使用的BuildKit版本仍在更新中，因此在每种情况下可能尚不起作用。
- en: 'If you want to test the build, go ahead and run it:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试构建，请运行它：
- en: '[PRE90]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This will launch a [terminal-based open source version of the Mastermind game](https://github.com/philshem/open-mastermind).
    There are on-screen directions for the game, and as a fallback, you can always
    exit by typing Ctrl-C.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个基于终端的开源版本的猜数字游戏（Mastermind）。屏幕上有游戏的说明，如果需要，您可以随时通过键入 Ctrl-C 退出。
- en: Since this is a Python application, it uses the *requirements.txt* file to list
    all of the libraries that the application requires, and then the `pip` application
    is used in the *Dockerfile* to install these dependencies.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 Python 应用程序，它使用 *requirements.txt* 文件列出应用程序所需的所有库，然后在 *Dockerfile* 中使用
    `pip` 应用程序安装这些依赖项。
- en: Note
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We are installing some unnecessary dependencies simply to make the benefits
    of directory caching more obvious.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装了一些不必要的依赖项，只是为了更明显地展示目录缓存的好处。
- en: 'Go ahead and open up the *requirements.txt* file and add a line that reads
    `log-symbols`, so that it looks like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 请打开 *requirements.txt* 文件并添加一行，内容为 `log-symbols`，使其看起来像这样：
- en: '[PRE91]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let’s rerun the build now:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新运行构建：
- en: '[PRE92]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If you look at the full output for step `5/6`, you will notice that all the
    dependencies are downloaded again, even though `pip` would normally have most
    of those dependencies cached in */root/.cache*. This inefficiency results from
    the builder seeing that we have made a change that impacts this layer and therefore
    completely re-creates the layer, so we lose that cache, even though we had it
    stored in the image layer.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看第 `5/6` 步的完整输出，您会注意到所有依赖项都再次下载，尽管 `pip` 通常会将大多数依赖项缓存在 */root/.cache* 中。这种低效是由于构建器看到我们已经做出了影响此层的更改，因此完全重新创建了该层，因此我们失去了该缓存，尽管我们已将其存储在图像层中。
- en: 'Let’s go ahead and improve this situation. To do this, we need to leverage
    the [BuildKit directory cache](https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/reference.md#run---mounttypecache),
    and to do that we need to make a few changes to the *Dockerfile* so that it looks
    like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续改善这种情况。为此，我们需要利用 [BuildKit 目录缓存](https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/reference.md#run---mounttypecache)，并且我们需要对
    *Dockerfile* 进行一些更改，使其看起来像这样：
- en: '[PRE93]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'There are two important changes in there. First, we added the following line:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 其中有两个重要的更改。首先，我们添加了以下行：
- en: '[PRE94]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This tells Docker that we are going to use a newer version of the [*Dockerfile*
    frontend](https://hub.docker.com/r/docker/dockerfile), which provides us with
    access to BuildKit’s new features.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Docker 我们将使用一个更新版本的 [*Dockerfile* 前端](https://hub.docker.com/r/docker/dockerfile)，这为我们提供了访问
    BuildKit 的新特性。
- en: 'Then we edited the `RUN` line to look like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们编辑了 `RUN` 行，使其看起来像这样：
- en: '[PRE95]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This line tells BuildKit to mount a caching layer into the container at */root/.cache*
    for the duration of this one build step. This will accomplish two goals for us.
    It will remove the contents of that directory from the resulting image, and it
    will also be remounted and available to `pip` in consecutive builds.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 此行告诉 BuildKit 在本次构建步骤中将一个缓存层挂载到容器的 */root/.cache* 中。这将为我们达成两个目标。它将从生成的图像中删除该目录的内容，并且在连续的构建中，它也将被重新挂载并可供
    `pip` 使用。
- en: 'Let’s go ahead and do a full rebuild of the image with these changes, to generate
    the initial cache directory contents. If you follow the output, you will see that
    `pip` downloads all the dependencies, exactly as before:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用这些更改对图像进行完整重建，以生成初始缓存目录内容。如果您跟随输出，您将看到 `pip` 下载了所有依赖项，正如以前一样：
- en: '[PRE96]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'So, now let’s open up the *requirements.txt* file and add a line that reads
    `py-events`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开 *requirements.txt* 文件并添加一行，内容为 `py-events`：
- en: '[PRE97]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This is where the changes pay off. When we rebuild the image now, we will see
    that `py-events` and its dependencies are the only things that are downloaded;
    everything else uses the existing cache from our previous build, which has been
    mounted into the image for this build step:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是更改的收益所在。现在，当我们重新构建图像时，我们将看到只有 `py-events` 及其依赖项被下载；其他所有内容都使用了我们上一个构建的现有缓存，这些缓存已经被挂载到本次构建步骤的图像中：
- en: '[PRE98]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The build time has shrunk since there is no longer a need to re-download everything
    each time, and the image size is also 32 MB smaller, even though we have added
    new dependencies to the image. This is simply because the cache directory is no
    longer stored directly in the image that contains the application.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不再需要每次重新下载所有内容，构建时间已经缩短，而且图像大小也减小了 32 MB，尽管我们已向图像添加了新的依赖项。这仅仅是因为缓存目录不再直接存储在包含应用程序的图像中。
- en: BuildKit and the new *Dockerfile* frontends bring a lot of very useful features
    to the image-building process that you will want to be aware of. We highly recommend
    that you take the time to read through [the reference guide](https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/reference.md)
    and become acquainted with all the available capabilities.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: BuildKit和新的*Dockerfile*前端为镜像构建过程带来了许多非常有用的功能，您会希望了解这些功能。我们强烈建议您花时间阅读[参考指南](https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/reference.md)，并熟悉所有可用的功能。
- en: Troubleshooting Broken Builds
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除断裂构建
- en: 'We normally expect builds to just work, especially when we’ve scripted them,
    but in the real world things go wrong. Let’s spend a little bit of time discussing
    what you can do to troubleshoot a Docker build that is failing. In this section,
    we will explore two options: one that works with the pre-BuildKit approach to
    image building and one that works with BuildKit.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们期望构建工作正常，特别是当我们已经将其脚本化时，但在现实世界中，事情可能会出错。让我们花点时间讨论一下您可以做些什么来排查Docker构建失败的问题。在本节中，我们将探讨两个选项：一个适用于使用传统构建方法的镜像构建，另一个适用于BuildKit。
- en: 'For this demonstration, we are going to reuse the `docker-hello-node` repo
    from earlier in the chapter. If required, you can clone it again, like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将重复使用本章早期的`docker-hello-node`仓库。如果需要，您可以再次克隆它，就像这样：
- en: '[PRE99]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Debugging Pre-BuildKit Images
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试传统构建方法的镜像
- en: 'We need a patient for the next set of exercises, so let’s create a failing
    build. To do that, edit the *Dockerfile* so that the line that reads:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个病人进行接下来的一系列练习，因此让我们创建一个失败的构建。为此，请编辑*Dockerfile*，使其读取：
- en: '[PRE100]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'now reads:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在读取：
- en: '[PRE101]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Warning
  id: totrans-413
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'If you are using PowerShell on Windows, you will likely need to set the environment
    variable that disables BuildKit before running the following `docker image build`
    command, and then reset it afterward:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上使用PowerShell，则在运行以下`docker image build`命令之前，可能需要设置禁用BuildKit的环境变量，并在之后重新设置：
- en: '[PRE102]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'If you try to build the image now, you should get the following error:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试构建镜像，应该会收到以下错误：
- en: '[PRE103]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'So, how can we troubleshoot this, especially if we are not developing on a
    Linux system? The real trick here is to remember that almost all Docker images
    are layered on top of other Docker images and that you can start a container from
    any image. Although the meaning is not obvious on the surface, if you look at
    the output for `Step 6`, you will see this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何进行排查，特别是如果我们不是在Linux系统上开发的情况下？这里真正的技巧是记住几乎所有Docker镜像都是基于其他Docker镜像构建的，您可以从任何镜像启动容器。虽然这一层面的含义并不明显，但如果您查看`Step
    6`的输出，您将看到：
- en: '[PRE104]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The first line that reads `Running in e903367eaeb8` is telling you that the
    build process has started a new container, based on the image created in `Step
    5`. The next line, which reads `Removing intermediate container e903367eaeb8`,
    is telling you that Docker is now removing the container after having altered
    it based on the instruction in `Step 6`. In this case, it was simply adding a
    default environment variable via `ENV SCPATH /etc/supervisor/conf.d`. The final
    line, which reads `--→ 2a236efc3f06`, is the one we really care about because
    this is giving us the image ID for the image that was generated by `Step 6`. You
    need this to troubleshoot the build because it is the image from the last successful
    step in the build.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行读取的`Running in e903367eaeb8`告诉您构建过程已经启动了一个新的容器，基于`Step 5`中创建的镜像。接下来的一行读取`Removing
    intermediate container e903367eaeb8`告诉您Docker现在正在移除容器，在`Step 6`的指令基础上修改了它。在这种情况下，它仅仅通过`ENV
    SCPATH /etc/supervisor/conf.d`添加了一个默认的环境变量。最后一行读取的`--→ 2a236efc3f06`是我们真正关心的，因为这给出了由`Step
    6`生成的镜像ID。您需要此ID来排查构建问题，因为它是构建中最后一个成功步骤生成的镜像。
- en: With this information, it is possible to run an interactive container so that
    you can try to determine why your build is not working properly. Remember that
    every container image is based on the image layers below it. One of the great
    benefits of this is that we can just run the lower layer as a container itself,
    using a shell to look around!
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，可以运行一个交互式容器，这样您可以尝试确定为何您的构建无法正常工作。请记住，每个容器镜像都基于其下面的镜像层。其中一个巨大的好处是，我们可以直接将较低的层作为一个容器本身运行，使用shell来查看周围的情况！
- en: '[PRE105]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'From inside the container, you can now run any commands that you might need
    to determine what is causing your build to fail and what you need to do to fix
    your *Dockerfile*:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器内部，您现在可以运行任何您可能需要执行的命令，以确定导致构建失败的原因及您需要执行的操作以修复您的*Dockerfile*：
- en: '[PRE106]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Once the root cause has been determined, the *Dockerfile* can be fixed, so
    that `RUN apt-get -y update-all` now reads `RUN apt-get -y update`, and then rebuilding
    the image should result in success:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了根本原因，*Dockerfile*可以修复，这样`RUN apt-get -y update-all`现在读作`RUN apt-get -y
    update`，然后重新构建镜像应该会成功：
- en: '[PRE107]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Debugging BuildKit Images
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试BuildKit镜像
- en: When using BuildKit, we have to take a slightly different approach to get access
    to the point where the build fails, because none of the intermediate build layers
    are exported from the build container to the Docker daemon.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用BuildKit时，我们必须采用稍微不同的方法来获取构建失败点的访问权限，因为构建容器中的任何中间构建层都不会导出到Docker守护程序。
- en: The options for debugging BuildKit will almost certainly evolve as we move forward,
    but let’s take a look at one approach that works now.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 调试BuildKit的选项随着我们的前进几乎肯定会发生变化，但让我们看看现在有效的一种方法。
- en: 'Assuming that the *Dockerfile* has been reverted to its original state, let’s
    change the line that reads:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*Dockerfile*已经恢复到原始状态，让我们修改读取的那一行：
- en: '[PRE108]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'so that it now reads:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它应该是：
- en: '[PRE109]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: and then attempt to build the image.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试构建镜像。
- en: Tip
  id: totrans-435
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that you have BuildKit enabled!
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已启用BuildKit！
- en: '[PRE110]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We see an error as we expected, but how are we going to get access to that layer
    so that we can troubleshoot this?
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们预期的那样看到错误，但我们如何获取访问权限以便进行故障排除？
- en: One approach that works is to leverage multistage builds and the `--target`
    argument of `docker image build`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的一种方法是利用多阶段构建和`docker image build`的`--target`参数。
- en: 'Let’s start by modifying the *Dockerfile* in two places. Change this line:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从两个地方修改*Dockerfile*。更改这一行：
- en: '[PRE111]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'so that it now reads:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它应该是：
- en: '[PRE112]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'and then immediately before the line that causes the error, we are going to
    add a new `FROM` line:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在导致错误的那一行之前立即添加一个新的`FROM`行：
- en: '[PRE113]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: By doing this, we are creating a multistage build, where the first stage contains
    all of the steps that we know are working and the second stage starts with our
    problematic step.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们正在创建一个多阶段构建，其中第一阶段包含我们知道正在工作的所有步骤，第二阶段从我们的有问题的步骤开始。
- en: 'If we try to rebuild this using the same command as before, it will still fail:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用与之前相同的命令重新构建它，它仍然会失败：
- en: '[PRE114]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'So, instead of doing that, let’s tell Docker that we only want to build the
    first image in our multistage *Dockerfile*:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其这样做，让我们告诉Docker我们只想在我们的多阶段*Dockerfile*中构建第一个镜像：
- en: '[PRE115]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now, we can create a container from this image and do whatever testing we require:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从这个镜像创建一个容器，并进行我们需要的任何测试：
- en: '[PRE116]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: And then once we understand what is wrong with the *Dockerfile*, we can revert
    our debugging changes and fix the `npm` line so that the whole build works as
    expected.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 然后一旦我们理解了*Dockerfile*有什么问题，我们可以恢复我们的调试更改，并修复`npm`行，以便整个构建按预期工作。
- en: Multiarchitecture Builds
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多架构构建
- en: Since the launch of Docker, the *AMD64/X86_64* architecture has been the primary
    platform that most containers have targeted. However, this has started to change
    significantly. More and more developers are using systems based on ARM64/AArch64,
    and cloud companies are starting to make ARM-based VMs available through their
    platforms, due to the lower computing costs associated with the ARM platform.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Docker发布以来，*AMD64/X86_64*架构一直是大多数容器所针对的主要平台。然而，这种情况已经开始显著改变。越来越多的开发人员正在使用基于ARM64/AArch64的系统，云公司也开始通过其平台提供基于ARM的VM，这是因为ARM平台具有更低的计算成本。
- en: This can cause some interesting challenges for anyone who needs to build and
    maintain images that will target multiple architectures. How can you maintain
    a single, streamlined codebase and pipeline while still supporting all of these
    different targets?
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会对需要构建和维护面向多个架构的镜像的任何人造成一些有趣的挑战。在支持所有这些不同目标的同时，如何保持单一，简化的代码库和流水线？
- en: 'Luckily, Docker has released a plug-in for the `docker` CLI, called `buildx`,
    which can help make this process pretty straightforward. In many cases, `docker-buildx`
    will already be installed on your system, and you can verify this like so:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker已经发布了一个名为`buildx`的`docker` CLI插件，可以帮助简化这个过程。在许多情况下，`docker-buildx`已经安装在您的系统上，您可以像这样验证：
- en: '[PRE117]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Tip
  id: totrans-459
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to install the plug-in, you can follow [the directions from the
    GitHub repo](https://github.com/docker/buildx#installing).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要安装插件，可以按照从[Github仓库的说明](https://github.com/docker/buildx#installing)进行操作。
- en: 'By default, `docker-buildx` will leverage [QEMU-based virtualization](https://www.qemu.org)
    and [`binfmt_misc`](https://docs.kernel.org/admin-guide/binfmt-misc.html) to support
    architectures that differ from the underlying system. This may already be set
    up on your Linux system, but just in case, it is a good idea to run the following
    command when you are first setting up a new Docker server, just to ensure that
    the QEMU files are properly registered and up to date:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`docker-buildx`将利用[基于QEMU的虚拟化](https://www.qemu.org)和[`binfmt_misc`](https://docs.kernel.org/admin-guide/binfmt-misc.html)来支持与基础系统不同的架构。这可能已经在您的Linux系统上设置好了，但以防万一，建议在首次设置新的Docker服务器时运行以下命令，以确保QEMU文件已正确注册并更新到最新状态：
- en: '[PRE118]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Unlike the original embedded Docker build functionality, which ran directly
    on the server, BuildKit can utilize a build container when it builds images, which
    means that there is a lot of functional flexibility that can be delivered with
    that build container. In the next step, we are going to create a default `buildx`
    container called `builder`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始嵌入式Docker构建功能不同，BuildKit在构建镜像时可以利用一个构建容器，这意味着可以提供许多功能灵活性。在下一步中，我们将创建一个名为`builder`的默认`buildx`容器。
- en: Tip
  id: totrans-464
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you have an existing `buildx` container by this name, you can either remove
    it by running `docker buildx rm builder` or you can change the name in the upcoming
    `docker buildx create` command.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经存在名为此名称的`buildx`容器，您可以通过运行`docker buildx rm builder`来删除它，或者您可以在即将到来的`docker
    buildx create`命令中更改名称。
- en: 'With the next two commands, we are going to create the build container, set
    it as the default, and then start it up:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下面的两个命令，我们将创建构建容器，并将其设置为默认值，然后启动它：
- en: '[PRE119]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'For this example, let’s go ahead and download the `wordchain` Git repository,
    which contains a useful tool that can generate random and deterministic word sequences
    to help with dynamic naming needs:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们继续下载包含一个有用工具的`wordchain` Git存储库，该工具可以生成随机和确定性的单词序列，以帮助动态命名需求：
- en: '[PRE120]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Let’s go ahead and take a look at the included *Dockerfile*. You’ll notice
    that it is a pretty normal multistage *Dockerfile* and does not have anything
    special in it related to the platform architecture:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看附带的*Dockerfile*。您会注意到它是一个相当正常的多阶段*Dockerfile*，并且没有任何与平台架构相关的特殊内容：
- en: '[PRE121]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: In the first step, we are going to build our statically compiled Go binary,
    and then in the second step, we are going to package it up into a small deployment
    image.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们将构建我们的静态编译的Go二进制文件，然后在第二步中，我们将把它打包成一个小的部署镜像。
- en: Note
  id: totrans-473
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `ENTRYPOINT` instruction in the *Dockerfile* is an advanced instruction
    that allows you to separate the default process that is run by the container (`ENTRYPOINT`)
    from the command-line arguments that are passed to that process (`CMD`). When
    `ENTRYPOINT` is missing from the *Dockerfile*, the `CMD` instruction is expected
    to contain both the process and all the required command-line arguments.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockerfile*中的`ENTRYPOINT`指令是一个高级指令，允许您将容器运行的默认进程（`ENTRYPOINT`）与传递给该进程的命令行参数（`CMD`）分开。当*Dockerfile*中缺少`ENTRYPOINT`时，预期`CMD`指令将包含进程及其所有必需的命令行参数。'
- en: 'We can go ahead and build this image and side-load it into our local Docker
    server by running the following command:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续构建此镜像，并通过运行以下命令将其侧加载到我们的本地Docker服务器中：
- en: '[PRE122]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We can quickly test out the image by running the following commands:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令快速测试该镜像：
- en: '[PRE123]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: As long as you got some random word pairs back with the first two commands,
    then everything is working as expected.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您在第一个两个命令中收到了一些随机单词对返回的结果，那么一切都按预期运行。
- en: Now, to build this image for multiple architectures, we need to simply add the
    `--platform` argument to our build.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要为多个架构构建此镜像，只需在我们的构建中添加`--platform`参数即可。
- en: Note
  id: totrans-481
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Typically we would also replace `--load` with `--push`, which would push all
    the resulting images to the tagged repository, but in this case, we need to simply
    remove `--load`, because the Docker server cannot load images for multiple platforms
    at the moment, and we do not have a repository set up to push these images to.
    If we did have a repository and we tagged the images correctly, then we could
    very easily build and push all the resulting images in one step, with a command
    like this:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们会将 `--load` 替换为 `--push`，这样会将所有生成的镜像推送到标记的仓库。但在这种情况下，我们只需简单地移除 `--load`，因为
    Docker 服务器目前无法加载多个平台的镜像，并且我们也没有设置推送这些镜像的仓库。如果我们有一个仓库并正确标记了这些镜像，那么我们可以轻松地使用如下命令一步构建和推送所有生成的镜像：
- en: '`docker buildx build --platform linux/amd64,linux/arm64 --tag docker.io/spkane/wordchain:latest
    --push .`'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker buildx build --platform linux/amd64,linux/arm64 --tag docker.io/spkane/wordchain:latest
    --push .`'
- en: 'You can build this image for both the linux/amd64 and the linux/arm64 platforms
    like this:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样为 linux/amd64 和 linux/arm64 平台构建此镜像：
- en: '[PRE124]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Note
  id: totrans-486
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Due to the emulation that is required when building images for nonnative architectures,
    you may notice that some steps take much longer than normal. This is to be expected
    due to the additional computational overhead from the emulation.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在为非本地架构构建镜像时，由于需要进行仿真，你可能会注意到某些步骤比正常情况下花费更多时间。这是可以预期的，因为额外的计算开销来自仿真过程。
- en: It is possible to set up Docker so that it will build each image on a worker
    with a matching architecture, which should speed things up significantly in many
    cases. You can find some information about this in this [Docker blog article](https://www.docker.com/blog/speed-up-building-with-docker-buildx-and-graviton2-ec2).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置 Docker，使其在具有匹配架构的工作节点上构建每个镜像，这在很多情况下可以显著加快构建速度。有关此内容的更多信息可以在这篇[Docker 博客文章](https://www.docker.com/blog/speed-up-building-with-docker-buildx-and-graviton2-ec2)中找到。
- en: In the output for the build, you will notice lines that start with something
    like `=> [linux/amd64 *]` or `=> [linux/arm64 *]`. Each of these lines represents
    the builder working on this build step for the stated platform. Many of these
    steps will run in parallel, and due to caching and other considerations, each
    build might progress at differing speeds.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建输出中，你会注意到以类似 `=> [linux/amd64 *]` 或 `=> [linux/arm64 *]` 开头的行。每行代表了构建步骤在指定平台上的工作状态。许多这样的步骤会并行运行，由于缓存和其他考虑因素，每个构建的进度可能会不同步。
- en: Since we did not add `--push` to our build, you will also notice that we received
    a warning at the end of the build. This is because the *docker-container* driver
    that the builder is using just left everything in the build cache, which means
    that we can’t run the resulting images; at this point, we can only feel confident
    that the build is working.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有在构建中添加 `--push`，所以你还会注意到在构建结束时收到了一个警告。这是因为构建器使用的 *docker-container* 驱动器只是将一切留在构建缓存中，这意味着我们不能运行生成的镜像；在这一点上，我们只能确信构建是有效的。
- en: Tip
  id: totrans-491
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There are a few [`build` arguments](https://docs.docker.com/engine/reference/builder/#automatic-platform-args-in-the-global-scope)
    that are automatically set by Docker that can be especially helpful to leverage
    inside your *Dockerfile* when you are doing multiarchitecture builds. As an example,
    `TARGETARCH` is frequently used to make sure that a given build step downloads
    the correct prebuilt binary for the current image’s platform.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些[`build` 参数](https://docs.docker.com/engine/reference/builder/#automatic-platform-args-in-the-global-scope)是
    Docker 自动设置的，特别是在进行多架构构建时，这些参数可以非常有帮助。例如，`TARGETARCH` 经常用于确保给定的构建步骤下载当前镜像平台的正确预构建二进制文件。
- en: 'So, when we upload this image to a repository, how does Docker know which image
    to use for the local platform? This information is provided to the Docker server
    through something called an *image manifest*. We can look at the manifest for
    *docker.io/spkane/workdchain* by running the following:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我们将这个镜像上传到仓库时，Docker 如何知道要使用哪个镜像来适配本地平台？这些信息通过称为 *镜像清单* 的东西提供给 Docker 服务器。我们可以通过以下命令查看
    *docker.io/spkane/workdchain* 的清单：
- en: '[PRE125]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: If you look through the output, you will see that there are blocks that identify
    the image that is required for every platform the image supports. This is accomplished
    via the individual [`digest`](https://github.com/opencontainers/image-spec/blob/main/descriptor.md#digests)
    entries that are then paired with a *platform* block. This manifest file is downloaded
    by the server when it requires an image, and then after referencing the manifest,
    the server will download the correct image for the local platform. This is why
    our *Dockerfile* works at all. Each `FROM` line lists a base image that we want
    to use, but it is the Docker server that utilizes this manifest file to determine
    exactly which image to download for each platform that the build is targeting.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看输出，您会看到每个平台支持的图像都需要识别的块。这通过单独的[`digest`](https://github.com/opencontainers/image-spec/blob/main/descriptor.md#digests)条目完成，然后与一个*platform*块配对。服务器在需要图像时下载此清单文件，然后引用清单后，服务器将为本地平台下载正确的图像。这就是我们的*Dockerfile*能够正常工作的原因。每个`FROM`行列出了我们要使用的基础图像，但是Docker服务器利用此清单文件来确定为构建所针对的每个平台下载哪个图像。
- en: Wrap-Up
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point, you should feel pretty comfortable with image creation for Docker
    and should have a solid understanding of many of the core tools and functionality
    you can leverage to streamline your build pipeline. In the next chapter, we will
    start to dig into how you can use your images to create containerized processes
    for your projects.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该对为Docker创建图像感到非常自在，并且应该对许多可以利用来简化构建流水线的核心工具和功能有了牢固的理解。在下一章中，我们将开始探讨如何使用您的图像为项目创建容器化进程。
- en: '^([1](ch04.html#idm46803155693712-marker)) Full URL: [*https://github.com/torvalds/linux/commit/e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c*](https://github.com/torvalds/linux/commit/e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '^([1](ch04.html#idm46803155693712-marker)) 完整网址: [*https://github.com/torvalds/linux/commit/e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c*](https://github.com/torvalds/linux/commit/e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c)'
- en: ^([2](ch04.html#idm46803155211200-marker)) This code was originally forked from
    [GitHub](https://github.com/enokd/docker-node-hello).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#idm46803155211200-marker)) 此代码最初是从[GitHub](https://github.com/enokd/docker-node-hello)分支出来的。
- en: '^([3](ch04.html#idm46803154385056-marker)) Full URL: [*https://docs.docker.com/registry/recipes/mirror/#configure-the-docker-daemon*](https://docs.docker.com/registry/recipes/mirror/#configure-the-docker-daemon)'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '^([3](ch04.html#idm46803154385056-marker)) 完整网址: [*https://docs.docker.com/registry/recipes/mirror/#configure-the-docker-daemon*](https://docs.docker.com/registry/recipes/mirror/#configure-the-docker-daemon)'
- en: '^([4](ch04.html#idm46803154382192-marker)) Full URL: [*https://docs.docker.com/registry/recipes/mirror/#run-a-registry-as-a-pull-through-cache*](https://docs.docker.com/registry/recipes/mirror/#run-a-registry-as-a-pull-through-cache)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '^([4](ch04.html#idm46803154382192-marker)) 完整网址: [*https://docs.docker.com/registry/recipes/mirror/#run-a-registry-as-a-pull-through-cache*](https://docs.docker.com/registry/recipes/mirror/#run-a-registry-as-a-pull-through-cache)'
- en: '^([5](ch04.html#idm46803152409712-marker)) Full URL: [*https://github.com/bluewhalebook/docker-up-and-running-3rd-edition/blob/main/chapter_04/multistage/Dockerfile*](https://github.com/bluewhalebook/docker-up-and-running-3rd-edition/blob/main/chapter_04/multistage/Dockerfile)'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '^([5](ch04.html#idm46803152409712-marker)) 完整网址: [*https://github.com/bluewhalebook/docker-up-and-running-3rd-edition/blob/main/chapter_04/multistage/Dockerfile*](https://github.com/bluewhalebook/docker-up-and-running-3rd-edition/blob/main/chapter_04/multistage/Dockerfile)'
- en: '^([6](ch04.html#idm46803151763616-marker)) Full URL: [*https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-7.3*](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-7.3)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '^([6](ch04.html#idm46803151763616-marker)) 完整网址: [*https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-7.3*](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-7.3)'
