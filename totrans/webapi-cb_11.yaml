- en: Chapter 11\. Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern browsers include a robust Internationalization API. This is a collection
    of APIs centered around language- or locale-specific tasks, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting dates and times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pluralization rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before this API was available, you might have had to reach for a third-party
    library like Moment.js (for dates and times) or Numeral.js (for numbers). However,
    today’s browsers support many of the same use cases, and you may not need these
    libraries in your app anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these APIs use the concept of a *locale*, which is usually a combination
    of a language and a region. For example, the locale for US English is `en-US`,
    and the locale for Canadian English is `en-CA`. You can use them with the default
    locale, which is the one being used by the browser, or you can specify a particular
    locale to format data appropriately for your desired region.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a new JavaScript date and time API in development called Temporal.
    At the time of writing, this is currently an ECMAScript proposal. It may become
    part of the language in the near future, but for the time being this book will
    cover the standard Date API.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting a Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to display a `Date` object in a format appropriate for the user’s locale.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `Intl.DateTimeFormat` to format the `Date` object to a string value. Create
    the format object with two arguments: the desired locale and an options object
    where you can specify the format style. For dates, the supported format styles
    are (examples shown in the `en-US` locale):'
  prefs: []
  type: TYPE_NORMAL
- en: '`short`: 10/16/23'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`medium`: Oct 16, 2023'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: October 16, 2023'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`full`: Monday, October 16, 2023'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the user’s current locale, you can check the `navigator.language` property
    (see [Example 11-1](#example11-1)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-1\. Formatting a date
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also include the time information from a `Date` object by specifying
    a `timeStyle` property in the options object along with `dateStyle` (see [Example 11-2](#example11-2)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-2\. Formatting a date and time
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Getting the Parts of a Formatted Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to split a formatted date into tokens. This is useful, for example,
    if you want to style different parts of the formatted date differently.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `formatToParts` method of `Intl.DateTimeFormat` to format the date and
    return an array of tokens (see [Example 11-3](#code_formatParts)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-3\. Getting the parts of a formatted date
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a short date of `10/1/23`, the `parts` object shown in [Example 11-3](#code_formatParts)
    looks like [Example 11-4](#example11-4).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-4\. The formatted date parts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Formatting a Relative Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to format the difference between a given date and today in an approximate,
    human-readable format. For example, you want a formatted string like “2 days ago”
    or “in 3 months.”
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `Intl.RelativeTimeFormat`. It has a `format` method that you call with a
    value offset, such as –2 (in the past) or 3 (in the future), and a unit such as
    “day,” “month,” etc. For example, calling `format(-2, *day*)` in the `en-US` locale
    results in the string “2 days ago.”
  prefs: []
  type: TYPE_NORMAL
- en: This is actually a two-step process. `Intl.RelativeTimeFormat` doesn’t directly
    calculate this between two dates. Rather, you need to first determine the offset
    and the unit to pass to the `format` method. The idea is to find the largest unit
    that differs between the two dates.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a helper function that returns an object containing the offset
    and unit, as shown in [Example 11-5](#example11-5).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-5\. Finding the offset and unit
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns an object with two properties: `offset` and `unit`, which
    you can pass to an `Intl.RelativeTimeFormat` (see [Example 11-6](#example11-6)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-6\. Formatting the relative date
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the expected output if you called this function with the given dates
    on October 7, 2023 (keep in mind that when creating `Date` objects in this way,
    the months start at 0, but the days start at 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'October 1, 2023: `getRelativeDate(new Date(2023, 9, 1))`: “6 days ago”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'May 2, 2023: `getRelativeDate(new Date(2023, 4, 2))`: “5 months ago”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'June 2, 2025: `getRelativeDate(new Date(2025, 5, 2))`: “in 2 years”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`getDateDifference` works by comparing the year, month, and day (in that order)
    of the given date with today’s date, until it finds one that doesn’t match. Then
    it returns the difference and the name of the unit, which are passed to the `Intl.RelativeTimeFormat`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `getRelativeDate` function doesn’t give an exact relative time in months,
    days, hours, minutes, and seconds. It gives an approximation of the magnitude
    of the time difference.
  prefs: []
  type: TYPE_NORMAL
- en: Consider comparing May 2, 2023 to October 7, 2023\. This is a difference of
    5 months and 5 days, but `getRelativeDate` only says “5 months ago” as an approximation.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to format a number with thousands separators and decimal places in
    a locale-specific way.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pass the number to an `Intl.NumberFormat`’s `format` method. This method returns
    a string containing the formatted number.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `Intl.NumberFormat` uses the default locale (assume that the default
    locale in [Example 11-7](#example11-7) is `en-US`).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-7\. Formatting a number in the default locale
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also specify a different locale to the `Intl.NumberFormat` constructor
    (see [Example 11-8](#example11-8)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-8\. Formatting a number in the `de-DE` locale
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Intl.NumberFormat` applies locale-specific formatting rules to format individual
    numbers. You can also use it to format a range of numbers by passing two values
    to `formatRange`, as shown in [Example 11-9](#example11-9).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-9\. Formatting a range of numbers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Rounding Decimal Places
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to take a fractional number, which can have many decimal places, and
    round it to a set number of decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `maximumFractionDigits` option to specify the number of digits after
    the decimal point. [Example 11-10](#example11-10) shows how to round numbers to
    up to two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-10\. Rounding a number
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Formatting a Price Range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given an array of prices, stored as numbers, you want to create a formatted
    price range that reflects the low and high prices in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Determine the minimum and maximum prices, then pass the `style: *currency*`
    option when creating an `Intl.NumberFormat`. Use this `Intl.NumberFormat` to create
    the range. You can also specify the currency to get the proper symbol in the output.
    Finally, call `formatRange` on the `Intl.NumberFormat` with the lower and upper
    price bounds (see [Example 11-11](#code_formatPrices)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-11\. Formatting a price range
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Math.max` and `Math.min` functions take multiple arguments, and they return
    the maximum or minimum from the whole set of those arguments. [Example 11-11](#code_formatPrices)
    uses the array spread syntax to pass all elements from the `prices` array to `Math.max`
    and `Math.min`.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Measurement Units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to format a number along with a measurement unit.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `unit` style when creating the `Intl.NumberFormat` object, and specify
    the target unit. [Example 11-12](#example11-12) shows how to format a number of
    gigabytes.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-12\. Formatting gigabytes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also customize the unit label, by specifying the `unitDisplay` option
    to the `NumberFormat`. Possible values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`short`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shows the abbreviated unit, separated with a space: `1,000 GB`'
  prefs: []
  type: TYPE_NORMAL
- en: '`narrow`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shows the abbreviated unit, with no space: `1,000GB`'
  prefs: []
  type: TYPE_NORMAL
- en: '`long`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shows the full unit name: `1,000 gigabytes`'
  prefs: []
  type: TYPE_NORMAL
- en: Applying Pluralization Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use the correct terminology when referring to different numbers
    of items. For example, consider a list of users. In English, you’d say “one user”
    (singular), but “three users” (plural). Other languages have more complex rules,
    and you want to make sure you cover these.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `Intl.PluralRules` to select the correct pluralized string.
  prefs: []
  type: TYPE_NORMAL
- en: First, construct an `Intl.PluralRules` object with the desired locale, and call
    its `select` method with the number of users (see [Example 11-13](#example11-13)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-13\. Determining the plural form
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `select` method returns a string depending on the plural form to be used
    and the specified locale. For the `en-US` locale, it returns either “one” (when
    the user count is one) or “other” (when the user count is not one). You can define
    messages using these values as a key, as shown in [Example 11-14](#code_pluralSolution).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-14\. A full plural rules solution
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This solution requires knowing the different forms ahead of time so you can
    define the correct messages.
  prefs: []
  type: TYPE_NORMAL
- en: '`Intl.PluralRules` also supports an `ordinal` mode, which works slightly differently.
    You can use this mode to format *ordinal* values like “1st,” “2nd,” “3rd,” etc.
    The formatting rules vary from language to language, and you can map them to suffixes
    that you apply to the numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with the `en-US` locale, an ordinal `Intl.PluralRules` returns
    values such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`one` for numbers ending in 1—“1st,” “21st,” etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`two` for numbers ending in 2—“2nd, 42nd,” etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`few` for numbers ending in 3—“3rd, “33rd,” etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`other` for other numbers—“5th,” “47th,” etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting Characters, Words, and Sentences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to calculate the character, word, and sentence count of a string using
    locale-specific rules.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `Intl.Segmenter` to split the string and count the occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a segmenter with grapheme (individual characters), word, or sentence
    granularity. The granularity determines the boundaries of the segments. Each segmenter
    can only have one granularity, so you need three segmenters (see [Example 11-15](#example11-15)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-15\. Getting the character, word, and sentence count of a string
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This API may not be supported by all browsers yet. See [CanIUse](https://oreil.ly/OL9G0)
    for the latest compatibility data.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you call `segment` on a segmenter with some text, it returns an iterable
    object containing all of the segments. There are several ways to get the length
    of items in this iterable, but this example uses the array spread syntax, which
    creates an array containing all of the items. Then you just need to get the length
    of each array.
  prefs: []
  type: TYPE_NORMAL
- en: You may have solved this problem in the past by using the `split` method of
    a string. For example, you could split on whitespace to get an array of words
    and get the word count. This approach may work in your language, but the advantage
    of using `Intl.Segmenter` is that it takes the given locale’s rules for breaking
    up words and sentences.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have an array of items that you want to display in a comma-separated list.
    For example, an array of users is shown as “user1, user2, and user3.”
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `Intl.ListFormat` to combine the items into a list using the rules of the
    given locale. [Example 11-16](#example11-16) uses an array of users, each of which
    has a `username` property.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-16\. Formatting a list of user objects
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Intl.ListFormat` adds words and punctuation as needed. For example, in the
    `en-US` locale, you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '1 user: “user1”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2 users: “user1 and user2”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3 users: “user1, user2, and user3”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s another example using the `de-DE` locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '1 user: “user1”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2 users: “user1 und user2”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3 users: “user1, user2 und user3”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice the use of “und” instead of “and,” and also notice in the third case
    that there’s no comma after user2 as there is in `en-US`. This is because German
    grammar does not use this comma (called the “Oxford comma”).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using `Intl.ListFormat` is much more robust than using an array’s
    `join` method to join its values with a comma. That method, of course, does not
    take locale-specific rules into account.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting an Array of Names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have an array of names that you want to sort using locale-specific sorting
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an `Intl.Collator` to provide the comparison logic, then use its `compare`
    function to pass to `Array.prototype.sort` (see [Example 11-17](#example11-17)).
    This function compares two strings. It returns a negative value if the first string
    comes before the second, zero if the strings are equal, or a positive value if
    the first string comes after the second.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-17\. Sorting an array of names with `Intl.Collator`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A `Collator` can return any negative or positive value, not just necessarily
    –1 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a concise way to sort an array of strings. Before `Intl.Collator`, you
    might have done something like [Example 11-18](#example11-18).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-18\. Sorting an array of strings directly
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This works fine, but one major difference is that you can’t specify which locale’s
    sorting rules to apply when comparing strings. Another benefit of `Intl.Collator`
    is its flexibility. You can fine-tune the logic it uses to compare strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the array `[1, 2, 20, 3]`. Using the default collator,
    this would be the sorted order since it’s using string comparison logic. You can
    pass the `numeric: true` option to `Intl.Collator`, and the sorted array then
    becomes `[1, 2, 3, 20]`.'
  prefs: []
  type: TYPE_NORMAL
