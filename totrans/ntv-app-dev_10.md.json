["```\nlet url = URL(string: \"https://www.oreilly.com\")!\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n    guard let data = data else { return }\n    let string = String(data: data, encoding: .utf8)!\n    print(string)\n}\ntask.resume()\n```", "```\nlet url = URL(string: \"https://www.oreilly.com\")!\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n\n    guard let response = response as? HTTPURLResponse, response.statusCode < 300 else {\n        print(\"A server error occured.\")\n        return\n    }\n\n    guard let data = data, let string = String(data: data, encoding: .utf8) else {\n        print(\"No data returned.\")\n        return\n    }\n\n    print(string)\n}\ntask.resume()\n```", "```\nlet data = \"text to send\".data(using: .utf8)\nlet url = URL(string: \"https://www.oreilly.com\")!\n\nvar urlRequest = URLRequest(url: url)\nurlRequest.httpMethod = \"POST\"\nurlRequest.httpBody = data\n\nlet task =\n  URLSession.shared.dataTask(with: urlRequest) { (data, response, error) in\n\t...\n}\ntask.resume()\n```", "```\nvar components = URLComponents()\ncomponents.queryItems = [\n    URLQueryItem(name: \"name\", value: \"O'Reilly\"),\n    URLQueryItem(name: \"isAwesome\", value: \"true\")\n]\n\nlet url = URL(string: \"https://www.oreilly.com\")!\n\nvar urlRequest = URLRequest(url: url)\nurlRequest.httpMethod = \"POST\"\nurlRequest.httpBody = components.query?.data(using: .utf8)\n\nlet task =\n  URLSession.shared.dataTask(with: urlRequest) { (data, response, error) in\n\t...\n}\ntask.resume()\n```", "```\nlet data = \"file data\".data(using: .utf8)!\n\nlet url = URL(string: \"http://www.example.com\")!\nvar request = URLRequest(url: url)\nrequest.httpMethod = \"POST\"\n\nlet task = URLSession.shared.uploadTask(with: request, from: data)\ntask.resume()\n```", "```\n...\n\nlet task =\n  URLSession.shared.uploadTask(with: request, from: data) { (data, response, error) in\n\n    // Handle any client errors with error\n\n    // Handle any server errors with response\n\n    // Use the data object returned\n}\n```", "```\n// Define an object to hold our data\nstruct Book: Codable {\n    let title: String\n    let isbn: String\n}\n\n// Populate our data\nlet book = Book(title: \"Native Application Development\", isbn: \"this ISBN\")\n\n// Encode that object as a raw Data object to use in our request\nlet data = try! JSONEncoder().encode(book)\n\n// Create the request\nlet url = URL(string: \"http://www.example.com\")!\nvar request = URLRequest(url: url)\nrequest.httpMethod = \"POST\"\nrequest.setValue(\"application/json\", forHTTPHeaderField: \"Content-Tye\")\n\n// Create and perform the task\nlet task =\n  URLSession.shared.uploadTask(with: request, from: data) { (data, response, error) in\n    // Handle client errors\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n\n    // Handle server errors\n    guard let response =\n      response as? HTTPURLResponse, response.statusCode < 300 else {\n        print(\"A server error occured.\")\n        return\n    }\n\n    // Check if data exists\n    guard let data = data else {\n        print(\"No data returned.\")\n        return\n    }\n\n    // Decode the JSON returned into a Book instance\n    do {\n        let book = try JSONDecoder().decode(Book.self, from: data)\n        print(\"The book's title is \\(book.title) and the ISBN is \\(book.isbn)\")\n    } catch {\n        print(\"Could not decode response to JSON\")\n    }\n}\ntask.resume()\n```", "```\n...\nrequest.setValue(\"application/json\", forHTTPHeaderField: \"Content-Tye\")\n```", "```\nlet url = URL(string: \"https://www.example.com/file.zip\")!\nlet task =\n  URLSession.shared.downloadTask(with: url) { (fileUrl, response, error) in\n    // Check for client errors\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n\n    // Check for server errors\n    guard let response =\n      response as? HTTPURLResponse, response.statusCode < 300 else {\n        print(\"A server error occured.\")\n        return\n    }\n\n    // Check for a downloaded file\n    guard let tempFileUrl = fileUrl else { return }\n    print(tempFileUrl.path)\n}\ntask.resume()\n```", "```\nclass NetworkClient: NSObject {\n    // ...\n}\nextension NetworkClient: URLSessionDownloadDelegate {\n    func urlSession(_ session: URLSession,\n                    downloadTask: URLSessionDownloadTask,\n                    didFinishDownloadingTo location: URL) {\n\n        // Check for a server error\n        guard let response =\n          downloadTask.response as? HTTPURLResponse, response.statusCode < 300 else {\n          return }\n\n        // Prints the temporary file location\n        print(location.path)\n    }\n\n    func urlSession(_ session: URLSession, task: URLSessionTask,\n      didCompleteWithError error: Error?) {\n        if let error = error {\n            print(error.localizedDescription)\n        }\n    }\n\n    func urlSession(_ session: URLSession,\n                    downloadTask: URLSessionDownloadTask,\n                    didWriteData bytesWritten: Int64,\n                    totalBytesWritten: Int64,\n                    totalBytesExpectedToWrite: Int64) {\n        let percent = (totalBytesWritten/totalBytesExpectedToWrite) * 100\n        print(percent)\n    }\n}\n\nlet url = URL(string: \"https://www.example.com/file.zip\")!\n\nlet client = NetworkClient()\nlet urlSession = URLSession(configuration: .default, delegate: client, delegateQueue: nil)\nlet task = urlSession.downloadTask(with: url)\ntask.resume()\n```", "```\n...\n\nlet urlSession =\n  URLSession(configuration: .default, delegate: client, delegateQueue: nil)\nlet task = urlSession.downloadTask(with: url)\ntask.resume()\n```", "```\nclass PauseableClient: NSObject {\n    let url = URL(string: \"https://www.example.com/file.zip\")!\n    var resumeData: Data?\n\n    func startDownload() -> URLSessionDownloadTask? {\n        let task = URLSession.shared.downloadTask(with: url)\n        task.resume()\n        return task\n    }\n\n    func pauseDownload(for task: URLSessionDownloadTask?) {\n        guard let task = task else { return }\n        task.cancel { (resumeData) in\n            self.resumeData = resumeData\n        }\n    }\n\n    func resumeDownload() -> URLSessionDownloadTask? {\n        guard let resumeData = resumeData else {\n            print(\"Download can't be resumed!\")\n            return nil\n        }\n\n        let task = URLSession.shared.downloadTask(withResumeData: resumeData)\n        task.resume()\n        return task\n    }\n\n}\n\nlet client = PauseableClient()\nvar task = client.startDownload()\nclient.pauseDownload(for: task)\ntask = client.resumeDownload()\n```"]