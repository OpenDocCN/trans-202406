["```\nclass Widget extends React.Component {\n  render() {\n    let ui;\n    // fun with this.props and this.state\n    return <div>{ui}</div>;\n  }\n}\n```", "```\nfunction Widget(props) {\n    let ui;\n    // fun with props but where's the state?\n    return <div>{ui}</div>;\n}\n```", "```\nfunction Excel(props) {\n  // implement me...\n}\n\nExcel.propTypes = {\n  headers: PropTypes.arrayOf(PropTypes.string),\n  initialData: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n};\n\nconst headers = ['Book', 'Author', 'Language', 'Published', 'Sales'];\n\nconst data = [\n  [\n    'A Tale of Two Cities', 'Charles Dickens', // ...\n  ],\n  // ...\n];\n\nReactDOM.render(\n  <Excel headers={headers} initialData={data} />,\n  document.getElementById('app'),\n);\n```", "```\nfunction Excel({headers, initialData}) {\n  return (\n    <table>\n      <thead>\n        <tr>\n          {headers.map((title, idx) => (\n            <th key={idx}>{title}</th>\n          ))}\n        </tr>\n      </thead>\n      <tbody>\n        {initialData.map((row, idx) => (\n          <tr key={idx}>\n            {row.map((cell, idx) => (\n              <td key={idx}>{cell}</td>\n            ))}\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n}\n```", "```\nthis.state = {\n  data: initialData;\n};\n```", "```\nthis.setState({\n  data: newData,\n});\n```", "```\nconst [data, setData] = React.useState(initialData);\n```", "```\nconst stateArray = React.useState(initialData);\nconst data = stateArray[0];\nconst setData = stateArray[1];\n```", "```\nsetData(newData);\n```", "```\nfunction Excel({headers, initialData}) {\n  const [data, setData] = React.useState(initialData);\n\n  return (\n    <table>\n      <thead>\n        <tr>\n          {headers.map((title, idx) => (\n            <th key={idx}>{title}</th>\n          ))}\n        </tr>\n      </thead>\n      <tbody>\n        {data.map((row, idx) => (\n          <tr key={idx}>\n            {row.map((cell, idx) => (\n              <td key={idx}>{cell}</td>\n            ))}\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n}\n```", "```\nfunction Excel({headers, initialData}) {\n  const [data, setData] = React.useState(initialData);\n  const [sorting, setSorting] = React.useState({\n    column: null,\n    descending: false,\n  });\n\n  // ....\n}\n```", "```\nfunction Excel({headers, initialData}) {\n\n  // ..\n\n  function sort(e) {\n    // implement me\n  }\n\n  return (\n    <table>\n      {/* ... */}\n    </table>\n  );\n}\n```", "```\nconst column = e.target.cellIndex;\nconst descending = sorting.column === column && !sorting.descending;\n```", "```\nconst dataCopy = clone(data);\n```", "```\nfunction clone(o) {\n  return JSON.parse(JSON.stringify(o));\n}\n```", "```\ndataCopy.sort((a, b) => {\n  if (a[column] === b[column]) {\n    return 0;\n  }\n  return descending\n    ? a[column] < b[column]\n      ? 1\n      : -1\n    : a[column] > b[column]\n      ? 1\n      : -1;\n});\n```", "```\nsetData(dataCopy);\nsetSorting({column, descending});\n```", "```\n<thead onClick={sort}>\n  <tr>\n    {headers.map((title, idx) => {\n      if (sorting.column === idx) {\n        title += sorting.descending ? ' \\u2191' : ' \\u2193';\n      }\n      return <th key={idx}>{title}</th>;\n    })}\n  </tr>\n</thead>\n```", "```\nconst [edit, setEdit] = useState(null);\n```", "```\n<tbody onDoubleClick={showEditor}>\n  {data.map((row, rowidx) => (\n    <tr key={rowidx} data-row={rowidx}>\n      {row.map((cell, columnidx) => {\n        if (\n          edit &&\n          edit.row === rowidx &&\n          edit.column === columnidx\n        ) {\n          cell = (\n            <form onSubmit={save}>\n              <input type=\"text\" defaultValue={cell} />\n            </form>\n          );\n        }\n        return <td key={columnidx}>{cell}</td>;\n      })}\n    </tr>\n  ))}\n</tbody>\n```", "```\nfunction showEditor(e) {\n  setEdit({\n    row: parseInt(e.target.parentNode.dataset.row, 10),\n    column: e.target.cellIndex,\n  });\n}\n```", "```\nfunction save(e) {\n  e.preventDefault();\n  const input = e.target.firstChild;\n  const dataCopy = clone(data);\n  dataCopy[edit.row][edit.column] = input.value;\n  setEdit(null);\n  setData(dataCopy);\n}\n```", "```\nconst [search, setSearch] = useState(false);\nconst [preSearchData, setPreSearchData] = useState(null);\n```", "```\ncomponentDidMount() {\n  document.addEventListener('keydown', this.keydownHandler);\n  fetch('https://www...')\n    .then(/*...*/)\n    .then((initialData) => {\n      /*...*/\n      this.setState({data});\n    });\n}\n\ncomponentWillUnmount() {\n  document.removeEventListener('keydown', this.keydownHandler);\n  clearInterval(this.replayID);\n}\n```", "```\nuseEffect(() => {\n  // logs only if `data` or `headers` have changed\n  console.log(Date.now());\n}, [data, headers]);\n\nuseEffect(() => {\n  // logs once, after initial render, like `componentDidMount()`\n  console.log(Date.now());\n}, []);\n\nuseEffect(() => {\n  // called on every re-render\n  console.log(Date.now());\n}, /* no dependencies here */);\n```", "```\nuseEffect(() => {\n  // logs once, after initial render, like `componentDidMount()`\n  console.log(Date.now());\n  return () => {\n    // log when the component will be removed form the DOM\n    // like `componentDidMount()`\n    console.log(Date.now());\n  };\n}, []);\n```", "```\nfunction Example() {\n  useEffect(() => {\n    console.log('Rendering <Example/>', Date.now());\n    return () => {\n      // log when the component will be removed form the DOM\n      // like `componentDidMount()`\n      console.log('Removing <Example/>', Date.now());\n    };\n  }, []);\n  return <p>I am an example child component.</p>;\n}\n\nfunction ExampleParent() {\n  const [visible, setVisible] = useState(false);\n  return (\n    <div>\n      <button onClick={() => setVisible(!visible)}>\n        Hello there, press me {visible ? 'again' : ''}\n      </button>\n      {visible ? <Example /> : null}\n    </div>\n  );\n}\n```", "```\nuseEffect(() => {\n  function keydownHandler() {\n    // do things\n  }\n  document.addEventListener('keydown', keydownHandler);\n  return () => {\n    document.removeEventListener('keydown', keydownHandler);\n  };\n}, []);\n```", "```\nfunction Example() {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // fetch() and then call setData()\n  });\n\n  useEffect(() => {\n    // event handlers\n  });\n\n  return <div>{data}</div>;\n}\n```", "```\nfunction Example({layout}) {\n  if (layout === null) {\n    return null;\n  }\n\n  if (layout) {\n    useLayoutEffect(() => {\n      const table = document.getElementsByTagName('table')[0];\n      console.log(table.offsetWidth);\n      table.width = '250px';\n    }, []);\n  } else {\n    useEffect(() => {\n      const table = document.getElementsByTagName('table')[0];\n      console.log(table.offsetWidth);\n      table.width = '250px';\n    }, []);\n  }\n\n  return (\n    <table>\n      <thead>\n        <tr>\n          <th>Random</th>\n        </tr>\n      </thead>\n      <tbody>\n        {Array.from(Array(10000)).map((_, idx) => (\n          <tr key={idx}>\n            <td width={Math.random() * 800}>{Math.random()}</td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n}\n\nfunction ExampleParent() {\n  const [layout, setLayout] = useState(null);\n  return (\n    <div>\n      <button onClick={() => setLayout(false)}>useEffect</button>{' '}\n      <button onClick={() => setLayout(true)}>useLayoutEffect</button>{' '}\n      <button onClick={() => setLayout(null)}>clear</button>\n      <Example layout={layout} />\n    </div>\n  );\n}\n```", "```\n// before\nfunction Excel({headers, initialData}) {\n  const [data, setData] = useState(initialData);\n  const [edit, setEdit] = useState(null);\n  // ... etc\n}\n\n// after\nfunction Excel({headers, initialData}) {\n  const [data, setData] = useLoggedState(initialData, true);\n  const [edit, setEdit] = useLoggedState(null);\n  // ... etc\n}\n```", "```\nfunction useLoggedState(initialValue, isData) {\n  // ...\n}\n```", "```\nlet dataLog = [];\nlet auxLog = [];\nlet isReplaying = false;\n```", "```\nfunction useLoggedState(initialValue, isData) {\n  const [state, setState] = useState(initialValue);\n\n  // fun here...\n\n  return [state, setState];\n}\n```", "```\nfunction useLoggedState(initialValue, isData) {\n  const [state, setState] = useState(initialValue);\n\n  useEffect(() => {\n    // todo\n  }, [state]);\n\n  return [state, setState];\n}\n```", "```\nuseEffect(() => {\n  if (isReplaying) {\n    return;\n  }\n  if (isData) {\n    dataLog.push([clone(state), setState]);\n  } else {\n    const idx = dataLog.length - 1;\n    if (!auxLog[idx]) {\n      auxLog[idx] = [];\n    }\n    auxLog[idx].push([state, setState]);\n  }\n}, [state]);\n```", "```\nfunction replay() {\n  isReplaying = true;\n  let idx = 0;\n  replayID = setInterval(() => {\n    const [data, fn] = dataLog[idx];\n    fn(data);\n    auxLog[idx] &&\n      auxLog[idx].forEach((log) => {\n        const [data, fn] = log;\n        fn(data);\n      });\n    idx++;\n    if (idx > dataLog.length - 1) {\n      isReplaying = false;\n      clearInterval(replayID);\n      return;\n    }\n  }, 1000);\n}\n```", "```\nuseEffect(() => {\n  function keydownHandler(e) {\n    if (e.altKey && e.shiftKey && e.keyCode === 82) {\n      // ALT+SHIFT+R(eplay)\n      replay();\n    }\n  }\n  document.addEventListener('keydown', keydownHandler);\n  return () => {\n    document.removeEventListener('keydown', keydownHandler);\n    clearInterval(replayID);\n    dataLog = [];\n    auxLog = [];\n  };\n}, []);\n```", "```\nfunction myReducer(oldState, action) {\n  const newState = {};\n  // do something with `oldState` and `action`\n  return newState;\n}\n```", "```\nfunction makeSense(mess, event) {\n  const order = {};\n  // do something with mess and event\n  return order;\n}\n```", "```\nconst [data, setData] = useState(initialData);\n```", "```\nconst [data, dispatch] = useReducer(myReducer, initialData);\n```", "```\nconst initialState = {data: [], color: 'black', background: 'white'};\n```", "```\nfunction RandomData() {\n  const [state, dispatch] = useReducer(myReducer, initialState);\n  // ...\n}\n```", "```\nreturn (\n  <div>\n    <div className=\"toolbar\">\n      <button onClick={() => dispatch({type: 'newdata'})}>\n        Get data\n      </button>{' '}\n      <button\n        onClick={() => dispatch({type: 'recolor', payload: {what: 'color'}})}>\n        Recolor text\n      </button>{' '}\n      <button\n        onClick={\n          () => dispatch({type: 'recolor', payload: {what: 'background'}})\n      }>\n        Recolor background\n      </button>\n    </div>\n    <table style={{color, background}}>\n      <tbody>\n        {data.map((row, idx) => (\n          <tr key={idx}>\n            {row.map((cell, idx) => (\n              <td key={idx}>{cell}</td>\n            ))}\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  </div>\n);\n```", "```\nfunction myReducer(oldState, action) {\n  const newState = clone(oldState);\n\n  if (action.type === 'recolor') {\n    newState[action.payload.what] =\n      `rgb(${rand(256)},${rand(256)},${rand(256)})`;\n  } else if (action.type === 'newdata') {\n    const data = [];\n    for (let i = 0; i < 10; i++) {\n      data[i] = [];\n      for (let j = 0; j < 10; j++) {\n        data[i][j] = rand(10000);\n      }\n    }\n    newState.data = data;\n  }\n  return newState;\n}\n\n// couple of helpers\nfunction clone(o) {\n  return JSON.parse(JSON.stringify(o));\n}\nfunction rand(max) {\n  return Math.floor(Math.random() * max);\n}\n```", "```\nfunction add(a, b) {\n  return a + b;\n}\n```", "```\nconst initialState = {data: [], color: 'black', background: 'white'};\n\nit('produces a 10x10 array', () => {\n  const {data} = myReducer(initialState, {type: 'newdata'});\n  expect(data.length).toEqual(10);\n  expect(data[0].length).toEqual(10);\n});\n```", "```\nconst [data, setData] = useState(initialData);\n// ...\nconst [edit, setEdit] = useState(null);\nconst [search, setSearch] = useState(false);\n```", "```\nconst [data, dispatch] = useReducer(reducer, initialData);\n// ...\nconst [edit, setEdit] = useState(null);\nconst [search, setSearch] = useState(false);\n```", "```\nfunction filter(e) {\n  const needle = e.target.value.toLowerCase();\n  if (!needle) {\n    setData(preSearchData);\n    return;\n  }\n  const idx = e.target.dataset.idx;\n  const searchdata = preSearchData.filter((row) => {\n    return row[idx].toString().toLowerCase().indexOf(needle) > -1;\n  });\n  setData(searchdata);\n}\n```", "```\nfunction filter(e) {\n  const needle = e.target.value;\n  const column = e.target.dataset.idx;\n  dispatch({\n    type: 'search',\n    payload: {needle, column},\n  });\n  setEdit(null);\n}\n```", "```\n// before\nfunction toggleSearch() {\n  if (search) {\n    setData(preSearchData);\n    setSearch(false);\n    setPreSearchData(null);\n  } else {\n    setPreSearchData(data);\n    setSearch(true);\n  }\n}\n\n// after\nfunction toggleSearch() {\n  if (!search) {\n    dispatch({type: 'startSearching'});\n  } else {\n    dispatch({type: 'doneSearching'});\n  }\n  setSearch(!search);\n}\n```", "```\nlet originalData = null;\n\nfunction reducer(data, action) {\n  if (action.type === 'sort') {\n    const {column, descending} = action.payload;\n    return clone(data).sort((a, b) => {\n      if (a[column] === b[column]) {\n        return 0;\n      }\n      return descending\n        ? a[column] < b[column]\n          ? 1\n          : -1\n        : a[column] > b[column]\n          ? 1\n          : -1;\n    });\n  }\n  if (action.type === 'save') {\n    data[action.payload.edit.row][action.payload.edit.column] =\n      action.payload.value;\n    return data;\n  }\n  if (action.type === 'startSearching') {\n    originalData = data;\n    return originalData;\n  }\n  if (action.type === 'doneSearching') {\n    return originalData;\n  }\n  if (action.type === 'search') {\n    return originalData.filter((row) => {\n      return (\n        row[action.payload.column]\n          .toString()\n          .toLowerCase()\n          .indexOf(action.payload.needle.toLowerCase()) > -1\n      );\n    });\n  }\n}\n```"]