<html><head></head><body><section data-pdf-bookmark="Chapter 2. Kubernetes API Basics" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_getting_started">&#13;
<h1><span class="label">Chapter 2. </span>Kubernetes API Basics</h1>&#13;
&#13;
&#13;
<p>In this chapter we walk you through the Kubernetes API basics. This includes a deep dive into the API server’s inner workings, the API itself, and how you can interact with the API from the command line. We will introduce you to Kubernetes API concepts such as resources and kinds, as well as grouping and versioning.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The API Server" data-type="sect1"><div class="sect1" id="api-server">&#13;
<h1>The API Server</h1>&#13;
&#13;
<p>Kubernetes<a data-primary="Kubernetes API" data-secondary="architecture and core responsibilities" data-type="indexterm" id="idm46336867764792"/> is made up of a bunch of nodes (machines in the cluster) with different roles, as shown in <a data-type="xref" href="#k8s-arch-overview">Figure 2-1</a>: the control plane on the master node(s) consists of the API server, controller manager, and scheduler. The API server is the central management entity and the only component that talks directly with the distributed storage component <code>etcd</code>.</p>&#13;
&#13;
<p>The API server has the following core responsibilities:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>To<a data-primary="kubectl" data-type="indexterm" id="idm46336867760632"/> serve the Kubernetes API. This API is used cluster-internally by the master components, the worker nodes, and your Kubernetes-native apps, as well as externally by clients such as <code>kubectl</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>To proxy cluster components, such as the Kubernetes dashboard, or to stream logs, service ports, or serve <code>kubectl exec</code> sessions.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Serving the API means:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Reading state: getting single objects, listing them, and streaming changes</p>&#13;
</li>&#13;
<li>&#13;
<p>Manipulating state: creating, updating, and deleting objects</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>State is persisted via <code>etcd</code>.</p>&#13;
&#13;
<figure><div class="figure" id="k8s-arch-overview">&#13;
<img alt="Kubernetes architecture overview" src="assets/prku_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>Kubernetes architecture overview</h6>&#13;
</div></figure>&#13;
&#13;
<p>The heart of Kubernetes is its API server. But how does the API server work? We’ll first treat the API server as a black box and take a closer look at its HTTP interface, then we’ll move on to the inner workings of the API server.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The HTTP Interface of the API Server" data-type="sect2"><div class="sect2" id="api-server-http-interface">&#13;
<h2>The HTTP Interface of the API Server</h2>&#13;
&#13;
<p>From<a data-primary="Kubernetes API" data-secondary="HTTP interface of" data-type="indexterm" id="idm46336867749288"/><a data-primary="HTTP interface" data-type="indexterm" id="idm46336867748280"/> a client’s perspective, the API server exposes a RESTful HTTP API with JSON or <a href="http://bit.ly/1HhFC5L"><em>protocol buffer</em></a> (<em>protobuf</em> for short) payload, which is used mainly for cluster-internal communication, for performance reasons.</p>&#13;
&#13;
<p>The API server HTTP interface handles HTTP requests to query and manipulate Kubernetes resources using the following <a href="https://mzl.la/2WX21hL">HTTP verbs</a> (or HTTP methods):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The HTTP <code>GET</code> verb is used for retrieving the data with a specific resource (such as a certain pod) or a collection or list of resources (for example, all pods in a namespace).</p>&#13;
</li>&#13;
<li>&#13;
<p>The HTTP <code>POST</code> verb is used for creating a resource, such as a service or a deployment.</p>&#13;
</li>&#13;
<li>&#13;
<p>The HTTP <code>PUT</code> verb is used for updating an existing resource—for example, changing the container image of a pod.</p>&#13;
</li>&#13;
<li>&#13;
<p>The HTTP <code>PATCH</code> verb is used for partial updates of existing resources. Read <a href="http://bit.ly/2Xpbi6I">“Use a JSON merge patch to update a Deployment”</a> in the Kubernetes documentation to learn more about the available strategies and implications here.</p>&#13;
</li>&#13;
<li>&#13;
<p>The HTTP <code>DELETE</code> verb is used for destroying a resource in a nonrecoverable manner.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If you look at, say, the Kubernetes <a href="http://bit.ly/2IVevBG">1.14 API reference</a>, you can see the different HTTP verbs in action. For example, to list pods in the current namespace with the CLI command equivalent of <code>kubectl -n</code> <code><em>THENAMESPACE</em></code> <code>get pods</code>, you would issue <code>GET /api/v1/namespaces/<em>THENAMESPACE</em>/pods</code> (see <a data-type="xref" href="#api-server-list-pods">Figure 2-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="api-server-list-pods">&#13;
<img alt="API server HTTP interface in action: listing pods in a given namespace" src="assets/prku_0202.png"/>&#13;
<h6><span class="label">Figure 2-2. </span>API server HTTP interface in action: listing pods in a given namespace</h6>&#13;
</div></figure>&#13;
&#13;
<p>For an introduction on how the API server HTTP interface is invoked from a Go program, see <a data-type="xref" href="ch03.html#client-go">“The Client Library”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="API Terminology" data-type="sect2"><div class="sect2" id="terminology">&#13;
<h2>API Terminology</h2>&#13;
&#13;
<p>Before<a data-primary="Kubernetes API" data-secondary="terminology" data-type="indexterm" id="KAPIterm02"/> we get into the API business, let’s first define the terms used in the context of the Kubernetes API server:</p>&#13;
<dl>&#13;
<dt>Kind</dt>&#13;
<dd>&#13;
<p>The<a data-primary="kinds" data-secondary="function of" data-type="indexterm" id="idm46336867723336"/> type of an entity. Each object has a field <code>Kind</code> (lowercase <code>kind</code> in JSON, capitalized <code>Kind</code> in Golang), which tells a client such as <code>kubectl</code> that it represents, for example, a pod. There<a data-primary="kinds" data-secondary="categories of" data-type="indexterm" id="idm46336867720504"/> are three categories of kinds:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Objects represent <em>a persistent entity in the system</em>—for example, <code>Pod</code> or <code>Endpoints</code>. Objects have names, and many of them live in namespaces.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lists are collections of one or more kinds of entities. Lists have a limited set of common metadata. Examples include <code>PodList</code>s or <code>NodeList</code>s. When you do a <strong><code>kubectl get pods</code></strong>, that’s exactly what you get.</p>&#13;
</li>&#13;
<li>&#13;
<p>Special-purpose kinds are used for specific actions on objects and for nonpersistent entities such as <code>/binding</code> or <code>/scale</code>. For discovery, Kubernetes uses <code>APIGroup</code> and <code>APIResource</code>; for error results, it uses <code>Status</code>.</p>&#13;
</li>&#13;
</ul>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In<a data-primary="Golang types" data-type="indexterm" id="idm46336867710168"/> Kubernetes programs, a kind directly corresponds with a Golang type. Thus, as Golang types, kinds are singular and begin with a capital letter.</p>&#13;
<dl>&#13;
<dt>API group</dt>&#13;
<dd>&#13;
<p>A<a data-primary="API groups" data-type="indexterm" id="idm46336867707672"/> collection of <code>Kind</code>s that are logically related. For example, all batch objects like <code>Job</code> or <code>ScheduledJob</code> are in the batch API group.</p>&#13;
</dd>&#13;
<dt>Version</dt>&#13;
<dd>&#13;
<p>Each<a data-primary="versions, in Kubernetes API" data-type="indexterm" id="idm46336867703912"/> API group can exist in multiple versions, and most of them do. For example, a group first appears as <code>v1alpha1</code> and is then promoted to <code>v1beta1</code> and finally graduates to <code>v1</code>. An object created in one version (e.g., <code>v1beta1</code>) can be retrieved in each of the supported versions. The API server does lossless<a data-primary="conversion" data-secondary="lossless" data-type="indexterm" id="idm46336867701176"/> conversion to return objects in the requested version. From the cluster user’s point of view, versions are just different representations of the same objects.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>There is no such thing as “one object is in <code>v1</code> in the cluster, and another object is in <code>v1beta1</code> in the cluster.” Instead, every object can be returned as a <code>v1</code> representation or in the <code>v1beta1</code> representation, as the cluster user desires.</p>&#13;
</div>&#13;
<dl>&#13;
<dt>Resource</dt>&#13;
<dd>&#13;
<p>A<a data-primary="resources" data-secondary="overview of" data-type="indexterm" id="idm46336867695224"/> usually lowercase, plural word (e.g., <code>pods</code>) identifying a set of HTTP endpoints (paths) exposing the CRUD (create, read, update, delete) semantics of a certain object type in the system. Common paths are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The root, such as <em>…/pods</em>, which lists all instances of that type</p>&#13;
</li>&#13;
<li>&#13;
<p>A path for individual named resources, such as <em>…/pods/nginx</em></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Typically, each of these endpoints returns and receives one kind (a <code>PodList</code> in the first case, and a <code>Pod</code> in the second). But in other situations (e.g., in case of errors), a <code>Status</code> kind object is returned.</p>&#13;
&#13;
<p>In addition to the main resource with full CRUD semantics, a resource can have further endpoints to perform specific actions (e.g., <em>…/pod/nginx/port-forward</em>, <em>…/pod/nginx/exec</em>, or <em>…/pod/nginx/logs</em>). We<a data-primary="subresources" data-type="indexterm" id="idm46336867686456"/><a data-primary="resources" data-secondary="subresources" data-type="indexterm" id="idm46336867685720"/> call these <em>subresources</em> (see <a data-type="xref" href="ch04.html#crd-subresources">“Subresources”</a>). These usually implement custom protocols instead of REST—for example, some kind of streaming connection via WebSockets or imperative APIs.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Resources<a data-primary="resources" data-secondary="resources versus kinds" data-type="indexterm" id="idm46336867682104"/><a data-primary="kinds" data-secondary="kinds versus resources" data-type="indexterm" id="idm46336867681096"/> and kinds are often mixed up. Note the clear distinction:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Resources correspond to HTTP paths.</p>&#13;
</li>&#13;
<li>&#13;
<p>Kinds are the types of objects returned by and received by these endpoints, as well as persisted into <code>etcd</code>.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
<p>Resources<a data-primary="GroupVersionResource (GVR)" data-type="indexterm" id="idm46336867676472"/><a data-primary="resources" data-secondary="GroupVersionResource (GVR)" data-type="indexterm" id="idm46336867675720"/> are always part of an API group and a version, collectively referred to as <em>GroupVersionResource</em> (or GVR). A GVR uniquely defines an HTTP path. A concrete path, for example, in the <code>default</code> namespace would be <em>/apis/batch/v1/namespaces/default/jobs</em>. <a data-type="xref" href="#gvr">Figure 2-3</a> shows an example GVR for a namespaced resource, a <code>Job</code>.</p>&#13;
&#13;
<figure><div class="figure" id="gvr">&#13;
<img alt="Kubernetes API—Group, Version, Resource (GVR)" src="assets/prku_0203.png"/>&#13;
<h6><span class="label">Figure 2-3. </span>Kubernetes API—GroupVersionResource (GVR)</h6>&#13;
</div></figure>&#13;
&#13;
<p>In contrast to the <code>jobs</code> GVR example, cluster-wide resources such as nodes or namespaces themselves do not have the <em>$NAMESPACE</em> part in the path. For example, a <code>nodes</code> GVR example might look as follows: <em>/api/v1/nodes</em>. Note that namespaces show up in other resources’ HTTP paths but are also a resource themselves, accessible at <em>/api/v1/namespaces</em>.</p>&#13;
&#13;
<p>Similarly<a data-primary="GroupVersionKind (GVK)" data-type="indexterm" id="idm46336867666824"/><a data-primary="kinds" data-secondary="GroupVersionKind (GVK)" data-type="indexterm" id="idm46336867666088"/> to GVRs, each kind lives in an API group, is versioned, and is identified via a <em>GroupVersionKind</em> (GVK).</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336867664504">&#13;
<h5>Cohabitation—Kinds Living in Multiple API Groups</h5>&#13;
<p>Kinds<a data-primary="kinds" data-secondary="living in multiple API groups" data-type="indexterm" id="idm46336867662888"/><a data-primary="cohabitation" data-type="indexterm" id="idm46336867661912"/> of the same name may coexist not only in different <em>versions</em>, but also in different API groups, simultaneously. For example, <code>Deployment</code> started as an alpha kind in the extensions group and was eventually promoted to a stable version in its own group, <code>apps.k8s.io</code>. We call this <em>cohabitation</em>. While not common in Kubernetes, there are a handful of them:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>Ingress</code>, <code>NetworkPolicy</code> in <code>extensions</code> and <code>networking.k8s.io</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Deployment</code>, <code>DaemonSet</code>, <code>ReplicaSet</code> in <code>extensions</code> and <code>apps</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Event</code> in the core group and <code>events.k8s.io</code></p>&#13;
</li>&#13;
</ul>&#13;
</div></aside>&#13;
&#13;
<p>GVKs and GVRs are related. GVKs are served under HTTP paths identified by GVRs. The process of mapping a GVK to a GVR is called<a data-primary="REST mapping" data-type="indexterm" id="idm46336867651240"/> REST mapping. We will see <code>RESTMappers</code> that implement REST mapping in Golang in <a data-type="xref" href="ch03.html#RESTMapping">“REST Mapping”</a>.</p>&#13;
&#13;
<p>From<a data-primary="resources" data-secondary="example Kubernetes API space" data-type="indexterm" id="idm46336867648488"/> a global point of view, the API resource space logically forms a tree with top-level nodes including <em>/api</em>, <em>/apis</em>, and some nonhierarchical endpoints such as <em>/healthz</em> or <em>/metrics</em>. An example rendering of this API space is shown in <a data-type="xref" href="#api-space-tree">Figure 2-4</a>. Note that the exact shape and paths depend on the Kubernetes version, with an increasing tendency to stabilize over the years.<a data-primary="" data-startref="KAPIterm02" data-type="indexterm" id="idm46336867644472"/></p>&#13;
&#13;
<figure><div class="figure" id="api-space-tree">&#13;
<img alt="An example Kubernetes API space" src="assets/prku_0204.png"/>&#13;
<h6><span class="label">Figure 2-4. </span>An example Kubernetes API space</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes API Versioning" data-type="sect2"><div class="sect2" id="kube-api-versioning">&#13;
<h2>Kubernetes API Versioning</h2>&#13;
&#13;
<p>For<a data-primary="Kubernetes API" data-secondary="API versioning" data-type="indexterm" id="idm46336867639976"/><a data-primary="Kubernetes" data-secondary="API versioning" data-type="indexterm" id="idm46336867638968"/><a data-primary="HTTP interface" data-type="indexterm" id="idm46336867638024"/> extensibility reasons, Kubernetes supports multiple API versions at different API paths, such as <em>/api/v1</em> or <em>/apis/extensions/v1beta1</em>. Different API versions imply different levels of stability and support:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Alpha</em> level (e.g., <code>v1alpha1</code>) is usually disabled by default; support for a feature may be dropped at any time without notice and should be used only in short-lived testing clusters.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Beta</em> level (e.g., <code>v2beta3</code>) is enabled by default, meaning that the code is well tested; however, the semantics of objects may change in incompatible ways in a subsequent beta or stable release.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Stable</em> (generally available, or GA) level (e.g., <code>v1</code>) will appear in released software for many subsequent versions.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s look at how the HTTP API space is constructed: at the top level we distinguish between the core group—that is, everything below <em>/api/v1</em>—and the named groups in paths of the form <em>/apis/$<code>NAME</code>/$</em><code><em>VERSION</em></code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The core group is located under <code>/api/v1</code> and not, as one would expect, under <em>/apis/core/v1</em>, for historic reasons. The core group existed before the concept of an API group was introduced.</p>&#13;
</div>&#13;
&#13;
<p>There is a third type of HTTP paths—ones that are not resource aligned—that the API server exposes: cluster-wide entities such as <em>/metrics</em>, <em>/logs</em>, or <em>/healthz</em>. In addition, the API server supports watches; that is, rather than polling resources at set intervals, you can add a <code>?watch=true</code> to certain requests and the API server changes into a <a href="http://bit.ly/2x5PnTl">watch modus</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Declarative State Management" data-type="sect2"><div class="sect2" id="declarative-state-management">&#13;
<h2>Declarative State Management</h2>&#13;
&#13;
<p>Most<a data-primary="Kubernetes API" data-secondary="declarative state management" data-type="indexterm" id="idm46336867620584"/><a data-primary="declarative state management" data-type="indexterm" id="idm46336867619560"/><a data-primary="state change" data-secondary="declarative state management" data-type="indexterm" id="idm46336867618872"/><a data-primary="specifications (specs)" data-type="indexterm" id="idm46336867617912"/><a data-primary="desired state" data-type="indexterm" id="idm46336867617240"/><a data-primary="status (observed state)" data-type="indexterm" id="idm46336867616568"/> API objects make a distinction between the specification of the <em>desired state</em> of the resource and the <em>status</em> of the object at the current time. A <em>specification</em>, or spec for short, is a complete description of the desired state of a resource and is typically persisted in stable storage, usually <code>etcd</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Why do we say “usually <code>etcd</code>“? Well, there are Kubernetes distros and offerings, such as <a href="https://k3s.io">k3s</a> or Microsoft’s AKS, that have replaced or are working on replacing <code>etcd</code> with something else. Thanks to the modular architecture of the Kubernetes control plane, this works just fine.</p>&#13;
</div>&#13;
&#13;
<p>Let’s talk a little more about spec (desired state) versus status (observed state) in the context of the API server.</p>&#13;
&#13;
<p>The spec describes your desired state for the resource, something you need to provide via a command-line tool such as <code>kubectl</code> or programmatically via your Go code. The status describes the observed or actual state of the resource and is managed by the control plane, either by core components such as the controller manager or by your own custom controller (see <a data-type="xref" href="ch01.html#ch_controllers-operators">“Controllers and Operators”</a>). For example, in a deployment you might specify that you want 20 replicas of the application to be running at all times. The deployment controller, part of the controller manager in the control plane, reads the deployment spec you provided and creates a replica set, which then takes care of managing the replicas: it creates the respective number of pods, which eventually<a data-primary="kubelet" data-type="indexterm" id="idm46336867607784"/> (via the <code>kubelet</code>) results in containers being launched on worker nodes. If any replica fails, the deployment controller would make this known to you in the status. This is what we call <em>declarative state management</em>—that is, declaring the desired state and letting Kubernetes take care of the rest.</p>&#13;
&#13;
<p>We will see declarative state management in action in the next section, as we start to explore the API from the command line.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using the API from the Command Line" data-type="sect1"><div class="sect1" id="api-cli">&#13;
<h1>Using the API from the Command Line</h1>&#13;
&#13;
<p>In<a data-primary="Kubernetes API" data-secondary="command line control" data-type="indexterm" id="KAPIcline02"/><a data-primary="command line interface (CLI)" data-type="indexterm" id="CLI02"/><a data-primary="kubectl" data-type="indexterm" id="idm46336867601496"/><a data-primary="curl" data-type="indexterm" id="idm46336867600824"/> this section we’ll be using <code>kubectl</code> and <code>curl</code> to demonstrate the use of the Kubernetes API. If you’re not familiar with these CLI tools, now is a good time to install them and try them out.</p>&#13;
&#13;
<p>For starters, let’s have a look at the desired and observed state of a resource. We<a data-primary="kube-dns" data-type="indexterm" id="idm46336867598616"/><a data-primary="kube-system" data-type="indexterm" id="idm46336867597912"/> will be using a control plane component that is likely available in every cluster, the CoreDNS plug-in (old Kubernetes versions were using <code>kube-dns</code> instead) in the <code>kube-system</code> namespace (this output is heavily edited to highlight the important parts):</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl -n kube-system get deploy/coredns -o<code class="o">=</code>yaml&#13;
apiVersion: apps/v1&#13;
kind: Deployment&#13;
metadata:&#13;
  name: coredns&#13;
  namespace: kube-system&#13;
  ...&#13;
spec:&#13;
  template:&#13;
    spec:&#13;
      containers:&#13;
      - name: coredns&#13;
        image: 602401143452.dkr.ecr.us-east-2.amazonaws.com/eks/coredns:v1.2.2&#13;
  ...&#13;
status:&#13;
  replicas: 2&#13;
  conditions:&#13;
  - <code class="nb">type</code>: Available&#13;
    status: <code class="s2">"True"</code>&#13;
    lastUpdateTime: <code class="s2">"2019-04-01T16:42:10Z"</code>&#13;
  ...</pre>&#13;
&#13;
<p>As you can see from this <code>kubectl</code> command, in the <code>spec</code> section of the deployment you’d define characteristics such as which container image to use and how many replicas you want to run in parallel, and in the <code>status</code> section you’d learn how many replicas at the current point in time are actually running.</p>&#13;
&#13;
<p>To carry out CLI-related operations, we will, for the remainder of this chapter, be using batch operations as the running example. Let’s start by executing the following command in a terminal:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl proxy --port<code class="o">=</code>8080&#13;
Starting to serve on 127.0.0.1:8080</pre>&#13;
&#13;
<p>This command proxies the Kubernetes API to our local machine and also takes care of the authentication and authorization bits. It allows us to directly issue requests via HTTP and receive JSON payloads in return. Let’s do that by launching a second terminal session where we query <code>v1</code>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>curl http://127.0.0.1:8080/apis/batch/v1&#13;
<code class="o">{</code>&#13;
  <code class="s2">"kind"</code>: <code class="s2">"APIResourceList"</code>,&#13;
  <code class="s2">"apiVersion"</code>: <code class="s2">"v1"</code>,&#13;
  <code class="s2">"groupVersion"</code>: <code class="s2">"batch/v1"</code>,&#13;
  <code class="s2">"resources"</code>: <code class="o">[</code>&#13;
    <code class="o">{</code>&#13;
      <code class="s2">"name"</code>: <code class="s2">"jobs"</code>,&#13;
      <code class="s2">"singularName"</code>: <code class="s2">""</code>,&#13;
      <code class="s2">"namespaced"</code>: <code class="nb">true</code>,&#13;
      <code class="s2">"kind"</code>: <code class="s2">"Job"</code>,&#13;
      <code class="s2">"verbs"</code>: <code class="o">[</code>&#13;
        <code class="s2">"create"</code>,&#13;
        <code class="s2">"delete"</code>,&#13;
        <code class="s2">"deletecollection"</code>,&#13;
        <code class="s2">"get"</code>,&#13;
        <code class="s2">"list"</code>,&#13;
        <code class="s2">"patch"</code>,&#13;
        <code class="s2">"update"</code>,&#13;
        <code class="s2">"watch"</code>&#13;
      <code class="o">]</code>,&#13;
      <code class="s2">"categories"</code>: <code class="o">[</code>&#13;
        <code class="s2">"all"</code>&#13;
      <code class="o">]</code>&#13;
    <code class="o">}</code>,&#13;
    <code class="o">{</code>&#13;
      <code class="s2">"name"</code>: <code class="s2">"jobs/status"</code>,&#13;
      <code class="s2">"singularName"</code>: <code class="s2">""</code>,&#13;
      <code class="s2">"namespaced"</code>: <code class="nb">true</code>,&#13;
      <code class="s2">"kind"</code>: <code class="s2">"Job"</code>,&#13;
      <code class="s2">"verbs"</code>: <code class="o">[</code>&#13;
        <code class="s2">"get"</code>,&#13;
        <code class="s2">"patch"</code>,&#13;
        <code class="s2">"update"</code>&#13;
      <code class="o">]</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">]</code>&#13;
<code class="o">}</code></pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You<a data-primary="kubectl proxy" data-type="indexterm" id="idm46336867572200"/><a data-primary="kubectl get --raw" data-type="indexterm" id="idm46336867406488"/> don’t have to use <code>curl</code> along with the <code>kubectl proxy</code> command to get direct HTTP API access to the Kubernetes API. You can instead use the <code>kubectl get --raw</code> command: for example, replace <code>curl http://127.0.0.1:8080/apis/batch/v1</code> with <code>kubectl get --raw /apis/batch/v1</code>.</p>&#13;
</div>&#13;
&#13;
<p>Compare this with the <code>v1beta1</code> version, noting that you can get a list of supported versions for the batch API group when looking at <em>http://127.0.0.1:8080/apis/batch</em> <code>v1beta1</code>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>curl http://127.0.0.1:8080/apis/batch/v1beta1&#13;
<code class="o">{</code>&#13;
  <code class="s2">"kind"</code>: <code class="s2">"APIResourceList"</code>,&#13;
  <code class="s2">"apiVersion"</code>: <code class="s2">"v1"</code>,&#13;
  <code class="s2">"groupVersion"</code>: <code class="s2">"batch/v1beta1"</code>,&#13;
  <code class="s2">"resources"</code>: <code class="o">[</code>&#13;
    <code class="o">{</code>&#13;
      <code class="s2">"name"</code>: <code class="s2">"cronjobs"</code>,&#13;
      <code class="s2">"singularName"</code>: <code class="s2">""</code>,&#13;
      <code class="s2">"namespaced"</code>: <code class="nb">true</code>,&#13;
      <code class="s2">"kind"</code>: <code class="s2">"CronJob"</code>,&#13;
      <code class="s2">"verbs"</code>: <code class="o">[</code>&#13;
        <code class="s2">"create"</code>,&#13;
        <code class="s2">"delete"</code>,&#13;
        <code class="s2">"deletecollection"</code>,&#13;
        <code class="s2">"get"</code>,&#13;
        <code class="s2">"list"</code>,&#13;
        <code class="s2">"patch"</code>,&#13;
        <code class="s2">"update"</code>,&#13;
        <code class="s2">"watch"</code>&#13;
      <code class="o">]</code>,&#13;
      <code class="s2">"shortNames"</code>: <code class="o">[</code>&#13;
        <code class="s2">"cj"</code>&#13;
      <code class="o">]</code>,&#13;
      <code class="s2">"categories"</code>: <code class="o">[</code>&#13;
        <code class="s2">"all"</code>&#13;
      <code class="o">]</code>&#13;
    <code class="o">}</code>,&#13;
    <code class="o">{</code>&#13;
      <code class="s2">"name"</code>: <code class="s2">"cronjobs/status"</code>,&#13;
      <code class="s2">"singularName"</code>: <code class="s2">""</code>,&#13;
      <code class="s2">"namespaced"</code>: <code class="nb">true</code>,&#13;
      <code class="s2">"kind"</code>: <code class="s2">"CronJob"</code>,&#13;
      <code class="s2">"verbs"</code>: <code class="o">[</code>&#13;
        <code class="s2">"get"</code>,&#13;
        <code class="s2">"patch"</code>,&#13;
        <code class="s2">"update"</code>&#13;
      <code class="o">]</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">]</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>As you can see, the <code>v1beta1</code> version also contains the <code>cronjobs</code> resource with the kind <code>CronJob</code>. At the time of this writing, cron jobs have not been promoted to <code>v1</code>.</p>&#13;
&#13;
<p>If<a data-primary="kubectl api-resources" data-type="indexterm" id="idm46336867308328"/> you want to get an idea of what API resources are supported in your cluster, including their kinds, whether or not they are namespaced, and their short names (primarily for <code>kubectl</code> on the command line), you can use the following command:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl api-resources&#13;
NAME                   SHORTNAMES APIGROUP NAMESPACED   KIND&#13;
bindings                                   <code class="nb">true         </code>Binding&#13;
componentstatuses      cs                  <code class="nb">false        </code>ComponentStatus&#13;
configmaps             cm                  <code class="nb">true         </code>ConfigMap&#13;
endpoints              ep                  <code class="nb">true         </code>Endpoints&#13;
events                 ev                  <code class="nb">true         </code>Event&#13;
limitranges            limits              <code class="nb">true         </code>LimitRange&#13;
namespaces             ns                  <code class="nb">false        </code>Namespace&#13;
nodes                  no                  <code class="nb">false        </code>Node&#13;
persistentvolumeclaims pvc                 <code class="nb">true         </code>PersistentVolumeClaim&#13;
persistentvolumes      pv                  <code class="nb">false        </code>PersistentVolume&#13;
pods                   po                  <code class="nb">true         </code>Pod&#13;
podtemplates                               <code class="nb">true         </code>PodTemplate&#13;
replicationcontrollers rc                  <code class="nb">true         </code>ReplicationController&#13;
resourcequotas         quota               <code class="nb">true         </code>ResourceQuota&#13;
secrets                                    <code class="nb">true         </code>Secret&#13;
serviceaccounts        sa                  <code class="nb">true         </code>ServiceAccount&#13;
services               svc                 <code class="nb">true         </code>Service&#13;
controllerrevisions               apps     <code class="nb">true         </code>ControllerRevision&#13;
daemonsets             ds         apps     <code class="nb">true         </code>DaemonSet&#13;
deployments            deploy     apps     <code class="nb">true         </code>Deployment&#13;
...</pre>&#13;
&#13;
<p>The<a data-primary="" data-startref="CLI02" data-type="indexterm" id="idm46336867304872"/><a data-primary="" data-startref="KAPIcline02" data-type="indexterm" id="idm46336867281080"/><a data-primary="kubectl api-versions" data-type="indexterm" id="idm46336867280136"/> following is a related command that can be very useful to determine the different resource versions supported in your cluster:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl api-versions&#13;
admissionregistration.k8s.io/v1beta1&#13;
apiextensions.k8s.io/v1beta1&#13;
apiregistration.k8s.io/v1&#13;
apiregistration.k8s.io/v1beta1&#13;
appmesh.k8s.aws/v1alpha1&#13;
appmesh.k8s.aws/v1beta1&#13;
apps/v1&#13;
apps/v1beta1&#13;
apps/v1beta2&#13;
authentication.k8s.io/v1&#13;
authentication.k8s.io/v1beta1&#13;
authorization.k8s.io/v1&#13;
authorization.k8s.io/v1beta1&#13;
autoscaling/v1&#13;
autoscaling/v2beta1&#13;
autoscaling/v2beta2&#13;
batch/v1&#13;
batch/v1beta1&#13;
certificates.k8s.io/v1beta1&#13;
coordination.k8s.io/v1beta1&#13;
crd.k8s.amazonaws.com/v1alpha1&#13;
events.k8s.io/v1beta1&#13;
extensions/v1beta1&#13;
networking.k8s.io/v1&#13;
policy/v1beta1&#13;
rbac.authorization.k8s.io/v1&#13;
rbac.authorization.k8s.io/v1beta1&#13;
scheduling.k8s.io/v1beta1&#13;
storage.k8s.io/v1&#13;
storage.k8s.io/v1beta1&#13;
v1</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How the API Server Processes Requests" data-type="sect1"><div class="sect1" id="api-server-request-processing">&#13;
<h1>How the API Server Processes Requests</h1>&#13;
&#13;
<p>Now<a data-primary="Kubernetes API" data-secondary="request processing" data-type="indexterm" id="KAPIrequest02"/><a data-primary="request processing" data-type="indexterm" id="reqpro02"/><a data-primary="server request processing" data-type="indexterm" id="serreqpro02"/> that you have an understanding of the external-facing HTTP interface, let’s focus on the inner workings of the API server. <a data-type="xref" href="#api-server-high-level-flow">Figure 2-5</a> shows a high-level overview of the request processing in the API server.</p>&#13;
&#13;
<figure><div class="figure" id="api-server-high-level-flow">&#13;
<img alt="Kubernetes API server request processing overview" src="assets/prku_0205.png"/>&#13;
<h6><span class="label">Figure 2-5. </span>Kubernetes API server request processing overview</h6>&#13;
</div></figure>&#13;
&#13;
<p>So, what<a data-primary="HTTP interface" data-type="indexterm" id="http02"/> actually happens now when an HTTP request hits the Kubernetes API? On a high level, the following interactions take place:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The HTTP request is processed by a chain of filters registered in <code>DefaultBuildHandlerChain()</code>. This chain is defined in <a href="http://bit.ly/2x9t27e"><em>k8s.io/apiserver/pkg/server/config.go</em></a> and discussed in detail shortly. It applies a series of filter operations on said request. Either the filter passes and attaches respective information to the context—to be precise, <code>ctx.RequestInfo</code>, with <code>ctx</code> being the <a href="https://golang.org/pkg/context">context</a> in Go (e.g., the authenticated user)—or, if a request does not pass a filter, it returns an appropriate HTTP response code stating the reason (e.g., a <a href="https://httpstatuses.com/401"><code>401</code> response</a> if the user authentication failed).</p>&#13;
</li>&#13;
<li>&#13;
<p>Next, depending on the HTTP path, the multiplexer in <a href="http://bit.ly/2WUd0c6"><em>k8s.io/apiserver/pkg/server/handler.go</em></a> routes the HTTP request to the respective handler.</p>&#13;
</li>&#13;
<li>&#13;
<p>A handler is registered for each API group—see <a href="http://bit.ly/2IvvSKA"><em>k8s.io/apiserver/pkg/endpoints/groupversion.go</em></a> and <a href="http://bit.ly/2Y1eySV"><em>k8s.io/apiserver/pkg/endpoints/installer.go</em></a> for details. It takes the HTTP request as well as the context (for example, user and access rights) and retrieves as well as delivers the requested object from <code>etcd</code> storage.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Let’s now take a closer look at the chain of filters that <code>DefaultBuildHandlerChain()</code> in <a href="http://bit.ly/2LWUUnQ"><em>server/config.go</em></a> sets up, and what happens in each of them:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">DefaultBuildHandlerChain</code><code class="p">(</code><code class="nx">apiHandler</code> <code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="p">,</code> <code class="nx">c</code> <code class="o">*</code><code class="nx">Config</code><code class="p">)</code> <code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code> <code class="p">{</code>&#13;
    <code class="nx">h</code> <code class="o">:=</code> <code class="nx">WithAuthorization</code><code class="p">(</code><code class="nx">apiHandler</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">Authorization</code><code class="p">.</code><code class="nx">Authorizer</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">Serializer</code><code class="p">)</code>&#13;
    <code class="nx">h</code> <code class="p">=</code> <code class="nx">WithMaxInFlightLimit</code><code class="p">(</code><code class="nx">h</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">MaxRequestsInFlight</code><code class="p">,</code>&#13;
          <code class="nx">c</code><code class="p">.</code><code class="nx">MaxMutatingRequestsInFlight</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">LongRunningFunc</code><code class="p">)</code>&#13;
    <code class="nx">h</code> <code class="p">=</code> <code class="nx">WithImpersonation</code><code class="p">(</code><code class="nx">h</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">Authorization</code><code class="p">.</code><code class="nx">Authorizer</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">Serializer</code><code class="p">)</code>&#13;
    <code class="nx">h</code> <code class="p">=</code> <code class="nx">WithAudit</code><code class="p">(</code><code class="nx">h</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">AuditBackend</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">AuditPolicyChecker</code><code class="p">,</code> <code class="nx">LongRunningFunc</code><code class="p">)</code>&#13;
    <code class="o">...</code>&#13;
    <code class="nx">h</code> <code class="p">=</code> <code class="nx">WithAuthentication</code><code class="p">(</code><code class="nx">h</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">Authentication</code><code class="p">.</code><code class="nx">Authenticator</code><code class="p">,</code> <code class="nx">failed</code><code class="p">,</code> <code class="o">...</code><code class="p">)</code>&#13;
    <code class="nx">h</code> <code class="p">=</code> <code class="nx">WithCORS</code><code class="p">(</code><code class="nx">h</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">CorsAllowedOriginList</code><code class="p">,</code> <code class="kc">nil</code><code class="p">,</code> <code class="kc">nil</code><code class="p">,</code> <code class="kc">nil</code><code class="p">,</code> <code class="s">"true"</code><code class="p">)</code>&#13;
    <code class="nx">h</code> <code class="p">=</code> <code class="nx">WithTimeoutForNonLongRunningRequests</code><code class="p">(</code><code class="nx">h</code><code class="p">,</code> <code class="nx">LongRunningFunc</code><code class="p">,</code> <code class="nx">RequestTimeout</code><code class="p">)</code>&#13;
    <code class="nx">h</code> <code class="p">=</code> <code class="nx">WithWaitGroup</code><code class="p">(</code><code class="nx">h</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">LongRunningFunc</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">HandlerChainWaitGroup</code><code class="p">)</code>&#13;
    <code class="nx">h</code> <code class="p">=</code> <code class="nx">WithRequestInfo</code><code class="p">(</code><code class="nx">h</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">RequestInfoResolver</code><code class="p">)</code>&#13;
    <code class="nx">h</code> <code class="p">=</code> <code class="nx">WithPanicRecovery</code><code class="p">(</code><code class="nx">h</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="nx">h</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>All packages are in <a href="http://bit.ly/2LUzTdx"><em>k8s.io/apiserver/pkg</em></a>. To review more specifically:</p>&#13;
<dl>&#13;
<dt><code>WithPanicRecovery()</code></dt>&#13;
<dd>&#13;
<p>Takes care of recovery and log panics. Defined in <a href="http://bit.ly/2N0zfNB"><em>server/filters/wrap.go</em></a>.</p>&#13;
</dd>&#13;
<dt><code>WithRequestInfo()</code></dt>&#13;
<dd>&#13;
<p>Attaches a <code>RequestInfo</code> to the context. Defined in <a href="http://bit.ly/2KvKjQH"><em>endpoints/filters/requestinfo.go</em></a>.</p>&#13;
</dd>&#13;
<dt><code>WithWaitGroup()</code></dt>&#13;
<dd>&#13;
<p>Adds all non-long-running requests to a wait group; used for graceful shutdown. Defined in <a href="http://bit.ly/2ItnsD6"><em>server/filters/waitgroup.go</em></a>.</p>&#13;
</dd>&#13;
<dt><code>WithTimeoutForNonLongRunningRequests()</code></dt>&#13;
<dd>&#13;
<p>Times out non-long-running requests (like most <code>GET</code>, <code>PUT</code>, <code>POST</code>, and <code>DELETE</code> requests), in contrast to long-running requests such as watches and proxy requests. Defined in <a href="http://bit.ly/2KrKk8r"><em>server/filters/timeout.go</em></a>.</p>&#13;
</dd>&#13;
<dt><code>WithCORS()</code></dt>&#13;
<dd>&#13;
<p>Provides a <a href="https://enable-cors.org">CORS</a> implementation. CORS, short for cross-origin resource sharing, is a mechanism that allows JavaScript embedded in an HTML page to make XMLHttpRequests to a domain different from the one that the JavaScript originated in. Defined in <a href="http://bit.ly/2L2A6uJ"><em>server/filters/cors.go</em></a>.</p>&#13;
</dd>&#13;
<dt><code>WithAuthentication()</code></dt>&#13;
<dd>&#13;
<p>Attempts to authenticate the given request as a human or machine user and stores the user info in the provided context. On success, the <code>Authorization</code> HTTP header is removed from the request. If the authentication fails, it returns an HTTP <code>401</code> status code. Defined in <a href="http://bit.ly/2Fjzr4b"><em>endpoints/filters/authentication.go</em></a>.</p>&#13;
</dd>&#13;
<dt><code>WithAudit()</code></dt>&#13;
<dd>&#13;
<p>Decorates the handler with audit logging information for all incoming requests. The audit log entries contain information such as the source IP of the request, user invoking the operation, and namespace of the request. Defined in <a href="http://bit.ly/2XpQN9U"><em>admission/audit.go</em></a>.</p>&#13;
</dd>&#13;
<dt><code>WithImpersonation()</code></dt>&#13;
<dd>&#13;
<p>Handles user impersonation by checking requests that attempt to change the user (similar to <code>sudo</code>). Defined in <a href="http://bit.ly/2L2UETP"><em>endpoints/filters/impersonation.go</em></a>.</p>&#13;
</dd>&#13;
<dt><code>WithMaxInFlightLimit()</code></dt>&#13;
<dd>&#13;
<p>Limits the number of in-flight requests. Defined in <a href="http://bit.ly/2IY4unl"><em>server/filters/maxinflight.go</em></a>.</p>&#13;
</dd>&#13;
<dt><code>WithAuthorization()</code></dt>&#13;
<dd>&#13;
<p>Checks permissions by invoking authorization modules and passes all authorized requests on to a multiplexer, which dispatches the request to the right handler. If the user doesn’t have sufficient rights, it returns an HTTP <code>403</code> status code. Kubernetes<a data-primary="access control" data-secondary="role-based access control (RBAC)" data-type="indexterm" id="idm46336867002408"/><a data-primary="role-based access control (RBAC)" data-type="indexterm" id="idm46336867001368"/> nowadays uses role-based access control (RBAC). Defined in <a href="http://bit.ly/31M2NSA"><em>endpoints/filters/authorization.go</em></a>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>After this generic handler chain is passed (the first box in <a data-type="xref" href="#api-server-high-level-flow">Figure 2-5</a>), the actual request processing starts (i.e., the semantics of the request handler is executed):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Requests for <em>/</em>, <em>/version</em>, <em>/apis</em>, <em>/healthz</em>, and other nonRESTful APIs are directly handled.</p>&#13;
</li>&#13;
<li>&#13;
<p>Requests for RESTful resources go into the request pipeline consisting of:</p>&#13;
<dl>&#13;
<dt><em>admission</em></dt>&#13;
<dd>&#13;
<p>Incoming objects go through an admission chain. That chain has some 20 different<a data-primary="admission" data-secondary="plug-in" data-type="indexterm" id="idm46336866993144"/> admission plug-ins.<sup><a data-type="noteref" href="ch02.html#idm46336866991944" id="idm46336866991944-marker">1</a></sup> Each plug-in can be part of the mutating phase (see the third box in <a data-type="xref" href="#api-server-high-level-flow">Figure 2-5</a>), part of the validating phase (see the fourth box in the figure), or both.</p>&#13;
&#13;
<p>In the mutating phase, the incoming request payload can be changed; for example, the image pull policy is set to <code>Always</code>, <code>IfNotPresent</code>, or <code>Never</code> depending on the admission configuration.</p>&#13;
&#13;
<p>The second admission phase is purely for validation; for example, security settings in pods are verified, or the existence of a namespace is verified before creating objects in that namespace.</p>&#13;
</dd>&#13;
<dt><em>validation</em></dt>&#13;
<dd>&#13;
<p>Incoming objects are checked against a large validation logic, which exists for each object type in the system. For example, string formats are checked to verify that only valid DNS-compatible characters are used in service names, or that all container names in a pod are unique.</p>&#13;
</dd>&#13;
<dt><code>etcd</code>-<em>backed CRUD logic</em></dt>&#13;
<dd>&#13;
<p>Here the different verbs we saw in <a data-type="xref" href="#api-server-http-interface">“The HTTP Interface of the API Server”</a> are implemented; for example, the update logic reads the object from <code>etcd</code>, checks that no other user has modified the object in the sense of <a data-type="xref" href="ch01.html#optimistic-concurrency">“Optimistic Concurrency”</a>, and, if not, writes the request object to <code>etcd</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We<a data-primary="" data-startref="http02" data-type="indexterm" id="idm46336866965480"/><a data-primary="" data-startref="serreqpro02" data-type="indexterm" id="idm46336866964472"/><a data-primary="" data-startref="reqpro02" data-type="indexterm" id="idm46336866963528"/><a data-primary="" data-startref="KAPIrequest02" data-type="indexterm" id="idm46336866962584"/> will look into all these steps in greater detail in the following chapters; for <span class="keep-together">example</span>:</p>&#13;
<dl>&#13;
<dt>Custom resources</dt>&#13;
<dd>&#13;
<p>Validation in <a data-type="xref" href="ch04.html#crd-validation">“Validating Custom Resources”</a>, admission in <a data-type="xref" href="ch09.html#admission-webhooks">“Admission Webhooks”</a>, and general CRUD semantics in <a data-type="xref" href="ch04.html#ch_crds">Chapter 4</a></p>&#13;
</dd>&#13;
<dt>Golang native resource</dt>&#13;
<dd>&#13;
<p>Validation in <a data-type="xref" href="ch08.html#aggregated-apiserver-development-validation">“Validation”</a>, admission in <a data-type="xref" href="ch08.html#aggregated-apiserver-development-admission">“Admission”</a>, and the implementation of CRUD semantics in <a data-type="xref" href="ch08.html#aggregated-apiserver-development-registry">“Registry and Strategy”</a></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46336867277688">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we first discussed the Kubernetes API server as a black box and had a look at its HTTP interface. Then you learned how to interact with that black box on the command line, and finally we opened up the black box and explored its inner workings. By now you should know how the API server works internally, and how to interact with it using the CLI tool <code>kubectl</code> for resource exploration and <span class="keep-together">manipulation</span>.</p>&#13;
&#13;
<p>It’s now time to leave the manual interaction on the command line behind us and get started with programmatic API server access using Go: meet <code>client-go</code>, the core of the Kubernetes “standard library.”</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46336866991944"><sup><a href="ch02.html#idm46336866991944-marker">1</a></sup> In a Kubernetes 1.14 cluster, these are (in this order): <code>AlwaysAdmit</code>, <code>NamespaceAutoProvision</code>, <code>Namespace<span class="keep-together">Lifecycle</span></code>, <code>NamespaceExists</code>, <code>SecurityContextDeny</code>, <code>LimitPodHardAntiAffinityTopology</code>, <code>PodPreset</code>, <code>LimitRanger</code>, <code>ServiceAccount</code>, <code>NodeRestriction</code>, <code>TaintNodesByCondition</code>, <code>AlwaysPullImages</code>, <code>ImagePolicyWebhook</code>, <code>PodSecurityPolicy</code>, <code>PodNodeSelector</code>, <code>Priority</code>, <code>DefaultTolerationSeconds</code>, <code>Pod<span class="keep-together">Toleration</span>Restriction</code>, <code>DenyEscalatingExec</code>, <code>DenyExecOnPrivileged</code>, <code>EventRateLimit</code>, <code>ExtendedResourceToleration</code>, <code>PersistentVolumeLabel</code>, <code>DefaultStorageClass</code>, <code>StorageObjectInUseProtection</code>, <code>OwnerReferencesPermissionEnforcement</code>, <code>PersistentVolumeClaimResize</code>, <code>MutatingAdmissionWebhook</code>, <code>ValidatingAdmissionWebhook</code>, <code>ResourceQuota</code>, and <code>AlwaysDeny</code>.</p></div></div></section></body></html>