- en: Chapter 5\. Pods and Namespaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important primitive in the Kubernetes API is the Pod. A Pod lets you
    run a containerized application. In practice, you’ll often encounter a one-to-one
    mapping between a Pod and a container; however, the use cases discussed in [Chapter 8](ch08.xhtml#multi_container_pods)
    benefit from declaring more than one container in a single Pod.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In addition to running a container, a Pod can consume other services like storage,
    configuration data, and much more. Therefore, think of a Pod as a wrapper for
    running containers while at the same time being able to mix in cross-cutting and
    specialized Kubernetes features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Working with Pods
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at working with a Pod running only a single container.
    We’ll discuss all important `kubectl` commands for creating, modifying, interacting,
    and deleting using imperative and declarative approaches.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Creating Pods
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pod definition needs to state an image for every container. Upon creating
    the Pod object, imperatively or declaratively, the scheduler will assign the Pod
    to a node, and the container runtime engine will check if the container image
    already exists on that node. If the image doesn’t exist yet, the engine will download
    it from a container image registry. By default the registry is Docker Hub. As
    soon as the image exists on the node, the container is instantiated and will run.
    [Figure 5-1](Images/#kubelet_container_images) demonstrates the execution flow.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0501](Images/ckd2_0501.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Container Runtime Interface interaction with container images
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `run` command is the central entry point for creating Pods imperatively.
    Let’s talk about its usage and the most important command line options you should
    memorize and practice. Say you wanted to run a [Hazelcast instance](https://hazelcast.com)
    inside of a Pod. The container should use the latest [Hazelcast image](https://oreil.ly/ChxPI),
    expose port 5701, and define an environment variable. In addition, we’ll also
    want to assign two labels to the Pod. The following imperative command combines
    this information and does not require any further editing of the live object:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `run` command offers a wealth of command line options. Execute the `kubectl
    run --help` or refer to the Kubernetes documentation for a broad overview. For
    the exam, you’ll not need to understand every command. [Table 5-1](#important_kubectl_run_command_line_options)
    lists the most commonly used options.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Important `kubectl` run command line options
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Example value | Description |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| `--image` | nginx:1.25.1 | The image for the container to run. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| `--port` | 8080 | The port that this container exposes. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `--rm` | N/A | Deletes the Pod after command in the container finishes. See
    [“Creating a Temporary Pod”](#temporary_pod) for more information. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| `--env` | PROFILE=dev | The environment variables to set in the container.
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| `--labels` | app=frontend | A comma-separated list of labels to apply to
    the Pod. [Chapter 9](ch09.xhtml#labels_annotations) explains labels in more detail.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: 'Some developers are more used to creating Pods from a YAML manifest. Probably
    you’re already accustomed to the declarative approach because you’re using it
    at work. You can express the same configuration for the Hazelcast Pod by opening
    the editor, copying a Pod YAML code snippet from the Kubernetes online documentation,
    and modifying it to your needs. [Example 5-1](#pod_yaml_manifest) shows the Pod
    manifest saved in the file `pod.yaml`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Pod YAML manifest
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_pods_and_namespaces_CO1-1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Assigns the name of `hazelcast` to the Pod.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_pods_and_namespaces_CO1-2)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Specifies labels to the Pod.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_pods_and_namespaces_CO1-3)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Declares the container image to be executed in the container of the Pod.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_pods_and_namespaces_CO1-4)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Injects one or many environment variables to the container.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_pods_and_namespaces_CO1-5)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Number of port to expose on the Pod’s IP address.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the Pod from the manifest is straightforward. Simply use the `create`
    or `apply` command, as shown here and explained in [“Managing Objects”](ch03.xhtml#managing_objects):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing Pods
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have created a Pod, you can further inspect its runtime information.
    The `kubectl` command offers a command for listing all Pods running in the cluster:
    `get pods`. The following command renders the Pod named `hazelcast`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Real-world Kubernetes clusters can run hundreds of Pods at the same time. If
    you know the name of the Pod of interest, it’s often easier to query by name.
    You would still see only a single Pod:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pod Life Cycle Phases
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because Kubernetes is a state engine with asynchronous control loops, it’s possible
    that the status of the Pod doesn’t show a `Running` status right away when listing
    the Pods. It usually takes a couple of seconds to retrieve the image and start
    the container. Upon Pod creation, the object goes through several [life cycle
    phases](https://oreil.ly/Qk5Ob), as shown in [Figure 5-2](#pod_lifecycle_phases).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0502](Images/ckd2_0502.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Pod life cycle phases
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understanding the implications of each phase is important as it gives you an
    idea about the operational status of a Pod. For example, during the exam you may
    be asked to identify a Pod with an issue and further debug the object. [Table 5-2](#pod_lifecycle_phases_table)
    describes all Pod life cycle phases.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Pod life cycle phases
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| `Pending` | The Pod has been accepted by the Kubernetes system, but one or
    more of the container images has not been created. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `Running` | At least one container is still running or is in the process
    of starting or restarting. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `Succeeded` | All containers in the Pod terminated successfully. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `Failed` | Containers in the Pod terminated,; at least one failed with an
    error. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `Unknown` | The state of Pod could not be obtained. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: 'The Pod life cycle phases should not be confused with container states within
    a Pod. Containers can have one of the three possible states: `Waiting`, `Running`,
    and `Terminated`. You can read more about container states in the [Kubernetes
    documentation](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-states).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Pod Details
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rendered table produced by the `get` command provides high-level information
    about a Pod. But what if you needed a deeper look at the details? The `describe`
    command can help:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The terminal output contains the metadata information of a Pod, the containers
    it runs, and the event log, such as failures when the Pod was scheduled. The example
    output has been condensed to show just the metadata section. You can expect the
    output to be very lengthy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a way to be more specific about the information you want to render.
    You can combine the `describe` command with a Unix `grep` command if you want
    to identify the image for running in the container:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Accessing Logs of a Pod
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As application developers, we know very well what to expect in the log files
    produced by the application we implemented. Runtime failures may occur when operating
    an application in a container. The `logs` command downloads the log output of
    a container. The following output indicates that the Hazelcast server started
    up successfully:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s very likely that more log entries will be produced as soon as the container
    receives traffic from end users. You can stream the logs with the command line
    option `-f`. This option is helpful if you want to see logs in real time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes tries to restart a container under certain conditions, such as if
    the image cannot be resolved on the first try. Upon a container restart, you won’t
    have access to the logs of the previous container; the `logs` command renders
    the logs only for the current container. However, you can still get back to the
    logs of the previous container by adding the `-p` command line option. You may
    want to use the option to identify the root cause that triggered a container restart.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Executing a Command in Container
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some situations require you to get the shell to a running container and explore
    the filesystem. Maybe you want to inspect the configuration of your application
    or debug its current state. You can use the `exec` command to open a shell in
    the container to explore it interactively, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that you do not have to provide the resource type. This command only
    works for a Pod. The two dashes (`--`) separate the `exec` command and its options
    from the command you want to run inside of the container.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to execute a single command inside of a container. Say you
    wanted to render the environment variables available to containers without having
    to be logged in. Just remove the interactive flag `-it` and provide the relevant
    command after the two dashes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating a Temporary Pod
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command executed inside of a Pod—usually an application implementing business
    logic—is meant to run infinitely. Once the Pod has been created, it will stick
    around. Under certain conditions, you want to execute a command in a Pod just
    for troubleshooting. This use case doesn’t require a Pod object to run beyond
    the execution of the command. That’s where temporary Pods come into play.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The `run` command provides the flag `--rm`, which will automatically delete
    the Pod after the command running inside of it finishes. Say you want to render
    all environment variables using `env` to see what’s available inside of the container.
    The following command achieves exactly that:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last message rendered in the output clearly states that the Pod was deleted
    after command execution.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Using a Pod’s IP Address for Network Communication
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every Pod is assigned an IP address upon creation. You can inspect a Pod’s
    IP address by using the `-o wide` command-line option for the `get pod` command
    or by describing the Pod. The IP address of the Pod in the following console output
    is `10.244.0.5`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The IP address assigned to a Pod is unique across all nodes and namespaces.
    This is achieved by assigning a dedicated subnet to each node when registering
    it. When creating a new Pod on a node, the IP address is leased from the assigned
    subnet. This is handled by the networking life cycle manager kube-proxy along
    with the Domain Name Service (DNS) and the Container Network Interface (CNI).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily verify the behavior by creating a temporary Pod that calls the
    IP address of another Pod using the command-line tool `curl` or `wget`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s important to understand that the IP address is not considered stable over
    time. A Pod restart leases a new IP address. Therefore, this IP address is often
    referred to as *virtual* IP address. Building a microservices architecture—where
    each of the applications runs in its own Pod with the need to communicate between
    each other with a stable network interface—requires a different concept: the Service.
    Refer to [Chapter 21](ch21.xhtml#services) for more information.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Pods
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The curriculum expects you to feel comfortable with editing YAML manifests either
    as files or as live object representations. This section shows you some typical
    configuration scenarios you may face during the exam. Later chapters will deepen
    your knowledge by touching on other configuration aspects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Declaring environment variables
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications need to expose a way to make their runtime behavior configurable.
    For example, you may want to inject the URL to an external web service or declare
    the username for a database connection. Environment variables are a common option
    to provide this runtime configuration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Avoid creating container images per environment
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It might be tempting to say, “Hey, let’s create a container image for any target
    deployment environment we need, including its configuration.” That’s a bad idea.
    One of the practices of [continuous delivery](https://oreil.ly/w4_2g) and the
    [Twelve-Factor App principles](https://12factor.net) is to build a deployable
    artifact for a commit just once. In this case, the artifact is the container image.
    Deviating configuration runtime behavior should be controllable by injecting runtime
    information when instantiating the container. You can use environment variables
    to control the behavior as needed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Defining environment variables in a Pod YAML manifest is relatively easy. Add
    or enhance the section `env` of a container. Every environment variable consists
    of a key-value pair, represented by the attributes `name` and `value`. Kubernetes
    does not enforce or sanitize typical naming conventions for environment variable
    keys, though it is recommended to follow the standard of using upper-case letters
    and the underscore character (`_`) to separate words.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate a set of environment variables, look at [Example 5-2](#yaml_manifest_for_a_pod_defining_environment_variables).
    The code snippet describes a Pod that runs a Java-based application using the
    Spring Boot framework.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. YAML manifest for a Pod defining environment variables
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first environment variable named `SPRING_PROFILES_ACTIVE` defines a pointer
    to a so-called profile. A profile contains environment-specific properties. Here,
    we are pointing to the profile that configures the production environment. The
    environment variable `VERSION` specifies the application version. Its value corresponds
    to the tag of the image and can be exposed by the running application to display
    the value in the user interface.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Defining a command with arguments
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many container images already define an `ENTRYPOINT` or `CMD` instruction. The
    command assigned to the instruction is automatically executed as part of the container
    startup. For example, the Hazelcast image we used earlier defines the instruction
    `CMD ["/opt/hazelcast/start-hazelcast.sh"]`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In a Pod definition, you can either redefine the image `ENTRYPOINT` and `CMD`
    instructions or assign a command to execute for the container if it hasn’t been
    specified by the image. You can provide this information with the help of the
    `command` and `args` attributes for a container. The `command` attribute overrides
    the image’s `ENTRYPOINT` instruction. The `args` attribute replaces the `CMD`
    instruction of an image.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you wanted to provide a command to an image that doesn’t provide one
    yet. As usual, there are two different approaches: imperative and declarative.
    We’ll generate the YAML manifest with the help of the `run` command. The Pod should
    use the `busybox:1.36.1` image and execute a shell command that renders the current
    date every 10 seconds in an infinite loop:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see in the generated but condensed `pod.yaml` file shown in [Example 5-3](#a_yaml_manifest_containing_a_args_attribute)
    that the command has been turned into an `args` attribute. Kubernetes specifies
    each argument on a single line.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. A YAML manifest containing an args attribute
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You could have achieved the same by a combination of the `command` and `args`
    attributes if you were to handcraft the YAML manifest. [Example 5-4](#a_yaml_file_containing_a_command_and_args_attribute)
    shows a different approach.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. A YAML manifest containing command and args attributes
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can quickly verify if the declared command actually does its job. First,
    create the Pod instance, then tail the logs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Deleting a Pod
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sooner or later you’ll want to delete a Pod. During the exam, you may be asked
    to remove a Pod. Or possibly, you made a configuration mistake and want to start
    the question from scratch:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Keep in mind that Kubernetes tries to delete a Pod *gracefully*. This means
    that the Pod will try to finish active requests to the Pod to avoid unnecessary
    disruption to the end user. A graceful deletion operation can take anywhere from
    5 to 30 seconds, time you don’t want to waste during the exam. See [Chapter 1](ch01.xhtml#exam-details-and-resources)
    for more information on how to speed up the process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to delete a Pod is to point the `delete` command to the
    YAML manifest you used to create it. The behavior is the same:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To save time during the exam, you can circumvent the grace period by adding
    the `--now` option to the `delete` command. Avoid using the `--now` flag in production
    Kubernetes environments.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Working with Namespaces
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Namespaces are an API construct to avoid naming collisions, and they represent
    a scope for object names. A good use case for namespaces is to isolate the objects
    by team or responsibility.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces for objects
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The content in this chapter demonstrates the use of namespaces for Pod objects.
    Namespaces are not a concept applicable only to Pods though. Most object types
    can be grouped by a namespace.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Most questions in the exam will ask you to execute the command in a specific
    namespace that has been set up for you. The following sections briefly touch on
    the basic operations needed to deal with a namespace.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Listing Namespaces
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Kubernetes cluster starts out with a couple of initial namespaces. You can
    list them with the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `default` namespace hosts objects that haven’t been assigned to an explicit
    namespace. Namespaces starting with the prefix `kube-` are not considered end
    user-namespaces. They have been created by the Kubernetes system. You will not
    have to interact with them as an application developer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`命名空间托管尚未分配到显式命名空间的对象。以`kube-`前缀开头的命名空间不视为最终用户命名空间。它们是由 Kubernetes
    系统创建的。作为应用程序开发人员，您不必与它们交互。'
- en: Creating and Using a Namespace
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用命名空间
- en: 'To create a new namespace, use the `create namespace` command. The following
    command uses the name `code-red`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的命名空间，请使用`create namespace`命令。以下命令使用名称`code-red`：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 5-5](#namespace_yaml_manifest) shows the corresponding representation
    as a YAML manifest.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-5](#namespace_yaml_manifest)显示了其作为 YAML 清单的对应表示。'
- en: Example 5-5\. Namespace YAML manifest
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 命名空间 YAML 清单
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the namespace is in place, you can create objects within it. You can do
    so with the command line option `--namespace` or its short-form `-n`. The following
    commands create a new Pod in the namespace `code-red` and then list the available
    Pods in the namespace:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间就位后，您可以在其中创建对象。您可以使用命令行选项`--namespace`或其缩写形式`-n`来执行此操作。以下命令在命名空间`code-red`中创建一个新的
    Pod，然后列出该命名空间中可用的 Pod：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Setting a Namespace Preference
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置命名空间偏好
- en: 'Providing the `--namespace` or `-n` command line option for every command is
    tedious and error-prone. You can set a permanent namespace preference if you know
    that you need to interact with a specific namespace you are responsible for. The
    first command shown sets the permanent namespace `code-red`. The second command
    renders the currently set permanent namespace:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个命令提供`--namespace`或`-n`命令行选项非常繁琐且容易出错。如果您知道需要与负责的特定命名空间交互，可以设置永久命名空间偏好。第一个显示的命令设置了永久命名空间`code-red`。第二个命令显示当前设置的永久命名空间：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Subsequent `kubectl` executions do not have to spell out the namespace `code-red`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的`kubectl`执行不必再次明确指定命名空间`code-red`：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can always switch back to the `default` namespace or another custom namespace
    using the `config set-context` command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以始终使用`config set-context`命令切换回`default`命名空间或其他自定义命名空间：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Deleting a Namespace
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除命名空间
- en: 'Deleting a namespace has a cascading effect on the object existing in it. Deleting
    a namespace will automatically delete its objects:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 删除命名空间会对其中现有的对象产生级联影响。删除命名空间将自动删除其对象：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The exam puts a strong emphasis on the concept of a Pod, a Kubernetes primitive
    responsible for running an application in a container. A Pod can define one or
    many containers that use a container image. Upon its creation, the container image
    is resolved and used to bootstrap the application. Every Pod can be further customized
    with the relevant YAML configuration.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考试强调 Pod 的概念，这是 Kubernetes 的一个原语，负责在容器中运行应用程序。一个 Pod 可以定义使用容器映像的一个或多个容器。在创建时，容器映像将被解析并用于启动应用程序。可以使用相关的
    YAML 配置进一步自定义每个 Pod。
- en: Exam Essentials
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考试要点
- en: Know how to interact with Pods
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何与 Pod 交互
- en: A Pod runs an application inside of a container. You can check on the status
    and the configuration of the Pod by inspecting the object with the `kubectl get`
    or `kubectl describe` commands. Get familiar with the life cycle phases of a Pod
    to be able to quickly diagnose errors. The command `kubectl logs` can be used
    to download the container log information without having to shell into the container.
    Use the command `kubectl exec` to further explore the container environment, e.g.,
    to check on processes or to examine files.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Pod 在容器内运行应用程序。您可以通过检查对象并使用`kubectl get`或`kubectl describe`命令来查看 Pod 的状态和配置。熟悉
    Pod 的生命周期阶段可以快速诊断错误。命令`kubectl logs`可用于下载容器日志信息，而无需进入容器壳。使用命令`kubectl exec`进一步探索容器环境，例如检查进程或检查文件。
- en: Understand advanced Pod configuration options
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 了解高级 Pod 配置选项
- en: Sometimes you have to start with the YAML manifest of a Pod and then create
    the Pod declaratively. This could be the case if you wanted to provide environment
    variables to the container or declare a custom command. Practice different configuration
    options by copy-pasting relevant code snippets from the Kubernetes documentation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您必须从 Pod 的 YAML 清单开始，然后声明性地创建 Pod。如果您想向容器提供环境变量或声明自定义命令，这种情况可能会发生。通过从 Kubernetes
    文档中复制相关代码片段来练习不同的配置选项。
- en: Practice using a custom namespace
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 练习使用自定义命名空间
- en: Most questions in the exam will ask you to work within a given namespace. You
    need to understand how to interact with that namespace from `kubectl` using the
    options `--namespace` and `-n`. To avoid accidentally working on the wrong namespace,
    know how to permanently set a namespace.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考试中的大多数问题将要求您在特定的命名空间中工作。您需要了解如何使用 `kubectl` 的选项 `--namespace` 和 `-n` 与该命名空间进行交互。为了避免意外地在错误的命名空间上工作，知道如何永久设置命名空间。
- en: Sample Exercises
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例练习
- en: Solutions to these exercises are available in [Appendix A](app01_split_001.xhtml#appendix_a_pods_namespaces).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些练习的方案可以在 [附录 A](app01_split_001.xhtml#appendix_a_pods_namespaces) 找到。
- en: Create a new Pod named `nginx` running the image `nginx:1.17.10`. Expose the
    container port 80\. The Pod should live in the namespace named `ckad`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `nginx` 的新 Pod，运行镜像 `nginx:1.17.10`。暴露容器端口 80。Pod 应该位于名为 `ckad` 的命名空间中。
- en: Get the details of the Pod including its IP address.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取 Pod 的详细信息，包括其 IP 地址。
- en: Create a temporary Pod that uses the `busybox:1.36.1` image to execute a `wget`
    command inside of the container. The `wget` command should access the endpoint
    exposed by the `nginx` container. You should see the HTML response body rendered
    in the terminal.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个临时 Pod，使用 `busybox:1.36.1` 镜像在容器内执行 `wget` 命令。`wget` 命令应该访问 `nginx` 容器暴露的端点。您应该在终端看到渲染的
    HTML 响应主体。
- en: Get the logs of the `nginx` container.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取 `nginx` 容器的日志。
- en: Add the environment variables `DB_URL=postgresql://mydb:5432` and `DB_USERNAME=admin`
    to the container of the `nginx` Pod.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向 `nginx` Pod 的容器中添加环境变量 `DB_URL=postgresql://mydb:5432` 和 `DB_USERNAME=admin`。
- en: Open a shell for the `nginx` container and inspect the contents of the current
    directory `ls -l`. Exit out of the container.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开 `nginx` 容器的 shell 并检查当前目录的内容 `ls -l`。退出容器。
- en: 'Create a YAML manifest for a Pod named `loop` that runs the `busybox:1.36.1`
    image in a container. The container should run the following command: `for i in
    {1..10}; do echo "Welcome $i times"; done`. Create the Pod from the YAML manifest.
    What’s the status of the Pod?'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为名为 `loop` 的 Pod 创建一个 YAML 清单，该 Pod 在容器中运行 `busybox:1.36.1` 镜像。容器应运行以下命令：`for
    i in {1..10}; do echo "Welcome $i times"; done`。从 YAML 清单创建 Pod。Pod 的状态是什么？
- en: Edit the Pod named `loop`. Change the command to run in an endless loop. Each
    iteration should `echo` the current date.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑名为 `loop` 的 Pod。将运行命令更改为无限循环。每次迭代应该 `echo` 当前日期。
- en: Inspect the events and the status of the Pod `loop`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查 `loop` Pod 的事件和状态。
