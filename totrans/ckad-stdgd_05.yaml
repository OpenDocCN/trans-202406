- en: Chapter 5\. Pods and Namespaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章\. Pods 和命名空间
- en: The most important primitive in the Kubernetes API is the Pod. A Pod lets you
    run a containerized application. In practice, you’ll often encounter a one-to-one
    mapping between a Pod and a container; however, the use cases discussed in [Chapter 8](ch08.xhtml#multi_container_pods)
    benefit from declaring more than one container in a single Pod.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 中最重要的原语是 Pod。Pod 允许您运行一个容器化的应用程序。在实践中，您通常会发现 Pod 和容器之间是一对一的映射关系；然而，在[第
    8 章](ch08.xhtml#multi_container_pods)讨论的用例中，声明一个 Pod 中多个容器会更有利。
- en: In addition to running a container, a Pod can consume other services like storage,
    configuration data, and much more. Therefore, think of a Pod as a wrapper for
    running containers while at the same time being able to mix in cross-cutting and
    specialized Kubernetes features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行容器外，Pod 还可以使用其他服务，如存储、配置数据等等。因此，将 Pod 视为运行容器的包装器，同时能够混合跨切面和特定的 Kubernetes
    功能。
- en: Working with Pods
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pods
- en: In this chapter, we will look at working with a Pod running only a single container.
    We’ll discuss all important `kubectl` commands for creating, modifying, interacting,
    and deleting using imperative and declarative approaches.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论仅运行单个容器的 Pod 的操作。我们将讨论创建、修改、交互和删除的所有重要的 `kubectl` 命令，使用命令式和声明式方法。
- en: Creating Pods
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Pods
- en: The Pod definition needs to state an image for every container. Upon creating
    the Pod object, imperatively or declaratively, the scheduler will assign the Pod
    to a node, and the container runtime engine will check if the container image
    already exists on that node. If the image doesn’t exist yet, the engine will download
    it from a container image registry. By default the registry is Docker Hub. As
    soon as the image exists on the node, the container is instantiated and will run.
    [Figure 5-1](Images/#kubelet_container_images) demonstrates the execution flow.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 定义需要为每个容器指定一个镜像。在创建 Pod 对象时，无论是命令式还是声明式，调度器都会将 Pod 分配给一个节点，并且容器运行时引擎将检查该节点上是否已存在容器镜像。如果镜像尚不存在，则引擎将从容器镜像注册表下载。默认情况下，注册表是
    Docker Hub。一旦镜像存在于节点上，容器就会被实例化并运行。[图 5-1](Images/#kubelet_container_images) 展示了执行流程。
- en: '![ckd2 0501](Images/ckd2_0501.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![ckd2 0501](Images/ckd2_0501.png)'
- en: Figure 5-1\. Container Runtime Interface interaction with container images
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 容器运行时接口与容器镜像的交互
- en: 'The `run` command is the central entry point for creating Pods imperatively.
    Let’s talk about its usage and the most important command line options you should
    memorize and practice. Say you wanted to run a [Hazelcast instance](https://hazelcast.com)
    inside of a Pod. The container should use the latest [Hazelcast image](https://oreil.ly/ChxPI),
    expose port 5701, and define an environment variable. In addition, we’ll also
    want to assign two labels to the Pod. The following imperative command combines
    this information and does not require any further editing of the live object:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 命令是创建 Pods 的中心入口点。让我们讨论它的用法以及您应该记住和练习的最重要的命令行选项。假设您想在 Pod 中运行一个[Hazelcast
    实例](https://hazelcast.com)。容器应该使用最新的[Hazelcast 镜像](https://oreil.ly/ChxPI)，暴露端口
    5701，并定义一个环境变量。此外，我们还希望为 Pod 分配两个标签。以下命令结合了这些信息，不需要进一步编辑实时对象：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `run` command offers a wealth of command line options. Execute the `kubectl
    run --help` or refer to the Kubernetes documentation for a broad overview. For
    the exam, you’ll not need to understand every command. [Table 5-1](#important_kubectl_run_command_line_options)
    lists the most commonly used options.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 命令提供了丰富的命令行选项。执行 `kubectl run --help` 或参考 Kubernetes 文档获取广泛的概述。在考试中，您不需要理解每一个命令。[表格
    5-1](#important_kubectl_run_command_line_options) 列出了最常用的选项。'
- en: Table 5-1\. Important `kubectl` run command line options
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 5-1\. 重要的 `kubectl` run 命令行选项
- en: '| Option | Example value | Description |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 示例值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `--image` | nginx:1.25.1 | The image for the container to run. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `--image` | nginx:1.25.1 | 要运行的容器的镜像。 |'
- en: '| `--port` | 8080 | The port that this container exposes. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `--port` | 8080 | 此容器暴露的端口。 |'
- en: '| `--rm` | N/A | Deletes the Pod after command in the container finishes. See
    [“Creating a Temporary Pod”](#temporary_pod) for more information. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `--rm` | N/A | 在容器中的命令完成后删除 Pod。有关更多信息，请参见[“创建临时 Pod”](#temporary_pod)。 |'
- en: '| `--env` | PROFILE=dev | The environment variables to set in the container.
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `--env` | PROFILE=dev | 在容器中设置的环境变量。 |'
- en: '| `--labels` | app=frontend | A comma-separated list of labels to apply to
    the Pod. [Chapter 9](ch09.xhtml#labels_annotations) explains labels in more detail.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `--labels` | app=frontend | 要应用于 Pod 的标签的逗号分隔列表。[第 9 章](ch09.xhtml#labels_annotations)
    更详细地解释了标签。'
- en: 'Some developers are more used to creating Pods from a YAML manifest. Probably
    you’re already accustomed to the declarative approach because you’re using it
    at work. You can express the same configuration for the Hazelcast Pod by opening
    the editor, copying a Pod YAML code snippet from the Kubernetes online documentation,
    and modifying it to your needs. [Example 5-1](#pod_yaml_manifest) shows the Pod
    manifest saved in the file `pod.yaml`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员更习惯于根据 YAML 清单创建 Pods。也许您已经习惯于声明性方法，因为您在工作中使用它。您可以通过打开编辑器，从 Kubernetes
    在线文档中复制 Pod YAML 代码片段，并根据需要进行修改，为 Hazelcast Pod 表达相同的配置。[示例 5-1](#pod_yaml_manifest)
    展示了保存在文件 `pod.yaml` 中的 Pod 清单：
- en: Example 5-1\. Pod YAML manifest
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. Pod YAML 清单
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_pods_and_namespaces_CO1-1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_pods_and_namespaces_CO1-1)'
- en: Assigns the name of `hazelcast` to the Pod.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Pod 分配名称 `hazelcast`。
- en: '[![2](Images/2.png)](#co_pods_and_namespaces_CO1-2)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_pods_and_namespaces_CO1-2)'
- en: Specifies labels to the Pod.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要应用于 Pod 的标签。
- en: '[![3](Images/3.png)](#co_pods_and_namespaces_CO1-3)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_pods_and_namespaces_CO1-3)'
- en: Declares the container image to be executed in the container of the Pod.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 声明要在 Pod 的容器中执行的容器镜像。
- en: '[![4](Images/4.png)](#co_pods_and_namespaces_CO1-4)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_pods_and_namespaces_CO1-4)'
- en: Injects one or many environment variables to the container.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 向容器注入一个或多个环境变量。
- en: '[![5](Images/5.png)](#co_pods_and_namespaces_CO1-5)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_pods_and_namespaces_CO1-5)'
- en: Number of port to expose on the Pod’s IP address.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Pod 的 IP 地址上公开的端口数量。
- en: 'Creating the Pod from the manifest is straightforward. Simply use the `create`
    or `apply` command, as shown here and explained in [“Managing Objects”](ch03.xhtml#managing_objects):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从清单创建 Pod 很简单。只需使用 `create` 或 `apply` 命令，如此处所示，并在 [“管理对象”](ch03.xhtml#managing_objects)
    中进行了解：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing Pods
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出 Pods
- en: 'Now that you have created a Pod, you can further inspect its runtime information.
    The `kubectl` command offers a command for listing all Pods running in the cluster:
    `get pods`. The following command renders the Pod named `hazelcast`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了一个 Pod，可以进一步检查其运行时信息。`kubectl` 命令提供了一个列出集群中所有正在运行的 Pods 的命令：`get pods`。以下命令渲染了名为
    `hazelcast` 的 Pod：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Real-world Kubernetes clusters can run hundreds of Pods at the same time. If
    you know the name of the Pod of interest, it’s often easier to query by name.
    You would still see only a single Pod:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的 Kubernetes 集群可以同时运行数百个 Pods。如果您知道感兴趣的 Pod 的名称，通常更容易通过名称查询。您仍然只会看到一个单独的 Pod：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pod Life Cycle Phases
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 生命周期阶段
- en: Because Kubernetes is a state engine with asynchronous control loops, it’s possible
    that the status of the Pod doesn’t show a `Running` status right away when listing
    the Pods. It usually takes a couple of seconds to retrieve the image and start
    the container. Upon Pod creation, the object goes through several [life cycle
    phases](https://oreil.ly/Qk5Ob), as shown in [Figure 5-2](#pod_lifecycle_phases).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Kubernetes 是一个带有异步控制循环的状态引擎，当列出 Pods 时，Pod 的状态可能不会立即显示为 `Running` 状态。通常需要几秒钟来获取镜像并启动容器。在
    Pod 创建时，对象会经历几个 [生命周期阶段](https://oreil.ly/Qk5Ob)，如图 5-2 所示。
- en: '![ckd2 0502](Images/ckd2_0502.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![ckd2 0502](Images/ckd2_0502.png)'
- en: Figure 5-2\. Pod life cycle phases
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. Pod 生命周期阶段
- en: Understanding the implications of each phase is important as it gives you an
    idea about the operational status of a Pod. For example, during the exam you may
    be asked to identify a Pod with an issue and further debug the object. [Table 5-2](#pod_lifecycle_phases_table)
    describes all Pod life cycle phases.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 理解每个阶段的影响很重要，因为它可以让您了解 Pod 的操作状态。例如，在考试期间，您可能会被要求识别具有问题的 Pod 并进一步调试该对象。[表 5-2](#pod_lifecycle_phases_table)
    描述了所有 Pod 生命周期阶段。
- en: Table 5-2\. Pod life cycle phases
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-2\. Pod 生命周期阶段
- en: '| Option | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Pending` | The Pod has been accepted by the Kubernetes system, but one or
    more of the container images has not been created. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `Pending` | Pod 已被 Kubernetes 系统接受，但一个或多个容器镜像尚未创建。 |'
- en: '| `Running` | At least one container is still running or is in the process
    of starting or restarting. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `Running` | 至少有一个容器仍在运行或正在启动或重新启动过程中。 |'
- en: '| `Succeeded` | All containers in the Pod terminated successfully. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `Succeeded` | Pod 中的所有容器均已成功终止。 |'
- en: '| `Failed` | Containers in the Pod terminated,; at least one failed with an
    error. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `Failed` | Pod中的容器已终止；至少一个以错误状态失败。 |'
- en: '| `Unknown` | The state of Pod could not be obtained. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Unknown` | 无法获取Pod的状态。 |'
- en: 'The Pod life cycle phases should not be confused with container states within
    a Pod. Containers can have one of the three possible states: `Waiting`, `Running`,
    and `Terminated`. You can read more about container states in the [Kubernetes
    documentation](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-states).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Pod的生命周期阶段不应与Pod中的容器状态混淆。容器可以处于三种可能的状态之一：`Waiting`、`Running`和`Terminated`。您可以在[Kubernetes文档](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-states)中详细了解容器的状态。
- en: Rendering Pod Details
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染Pod详情
- en: 'The rendered table produced by the `get` command provides high-level information
    about a Pod. But what if you needed a deeper look at the details? The `describe`
    command can help:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`命令生成的表格提供了关于Pod的高级信息。但是，如果您需要更详细的信息，可以使用`describe`命令：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The terminal output contains the metadata information of a Pod, the containers
    it runs, and the event log, such as failures when the Pod was scheduled. The example
    output has been condensed to show just the metadata section. You can expect the
    output to be very lengthy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 终端输出包含Pod的元数据信息、它运行的容器以及事件日志，例如在调度Pod时的失败。示例输出已经被压缩，仅显示元数据部分。您可以期望输出非常长。
- en: 'There’s a way to be more specific about the information you want to render.
    You can combine the `describe` command with a Unix `grep` command if you want
    to identify the image for running in the container:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更具体地渲染所需的信息。如果您想要识别容器中正在运行的镜像，可以结合`describe`命令和Unix的`grep`命令：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Accessing Logs of a Pod
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问Pod的日志
- en: 'As application developers, we know very well what to expect in the log files
    produced by the application we implemented. Runtime failures may occur when operating
    an application in a container. The `logs` command downloads the log output of
    a container. The following output indicates that the Hazelcast server started
    up successfully:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序开发者，我们非常了解我们实现的应用程序生成的日志文件中会出现什么。在容器中操作应用程序时可能会发生运行时故障。`logs`命令会下载容器的日志输出。以下输出表明Hazelcast服务器成功启动：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s very likely that more log entries will be produced as soon as the container
    receives traffic from end users. You can stream the logs with the command line
    option `-f`. This option is helpful if you want to see logs in real time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器接收到来自最终用户的流量，很可能会生成更多的日志条目。您可以使用命令行选项`-f`来实时流式传输日志。如果您希望实时查看日志，这个选项将非常有帮助。
- en: Kubernetes tries to restart a container under certain conditions, such as if
    the image cannot be resolved on the first try. Upon a container restart, you won’t
    have access to the logs of the previous container; the `logs` command renders
    the logs only for the current container. However, you can still get back to the
    logs of the previous container by adding the `-p` command line option. You may
    want to use the option to identify the root cause that triggered a container restart.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在某些条件下会尝试重新启动容器，例如如果在第一次尝试中无法解析镜像。在容器重新启动时，您将无法访问上一个容器的日志；`logs`命令仅会为当前容器渲染日志。然而，您仍然可以通过添加`-p`命令行选项返回到上一个容器的日志。您可能希望使用此选项来识别触发容器重新启动的根本原因。
- en: Executing a Command in Container
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器中执行命令
- en: 'Some situations require you to get the shell to a running container and explore
    the filesystem. Maybe you want to inspect the configuration of your application
    or debug its current state. You can use the `exec` command to open a shell in
    the container to explore it interactively, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况需要您进入正在运行的容器并探索文件系统。也许您想要检查应用程序的配置或调试其当前状态。您可以使用`exec`命令在容器中打开一个shell，以交互方式进行探索，如下所示：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that you do not have to provide the resource type. This command only
    works for a Pod. The two dashes (`--`) separate the `exec` command and its options
    from the command you want to run inside of the container.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您无需提供资源类型。此命令仅适用于Pod。两个破折号（`--`）将`exec`命令及其选项与要在容器内运行的命令分隔开来。
- en: 'It’s also possible to execute a single command inside of a container. Say you
    wanted to render the environment variables available to containers without having
    to be logged in. Just remove the interactive flag `-it` and provide the relevant
    command after the two dashes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在容器内执行单个命令。假设您希望渲染容器中可用的环境变量而无需登录。只需删除交互标志`-it`，并在两个破折号之后提供相关命令即可：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating a Temporary Pod
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建临时 Pod
- en: The command executed inside of a Pod—usually an application implementing business
    logic—is meant to run infinitely. Once the Pod has been created, it will stick
    around. Under certain conditions, you want to execute a command in a Pod just
    for troubleshooting. This use case doesn’t require a Pod object to run beyond
    the execution of the command. That’s where temporary Pods come into play.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 内执行的命令（通常是实现业务逻辑的应用程序）通常意味着要无限运行。一旦创建了 Pod，它就会保持存在。在某些情况下，您需要仅为了故障排除而在
    Pod 中执行命令。这种用例不要求 Pod 对象在命令执行后继续运行。这就是临时 Pod 发挥作用的地方。
- en: 'The `run` command provides the flag `--rm`, which will automatically delete
    the Pod after the command running inside of it finishes. Say you want to render
    all environment variables using `env` to see what’s available inside of the container.
    The following command achieves exactly that:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`命令提供了`--rm`标志，这将在内部运行的命令结束后自动删除 Pod。假设您想使用`env`来查看容器内所有可用的环境变量。以下命令恰好可以做到这一点：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last message rendered in the output clearly states that the Pod was deleted
    after command execution.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中呈现的最后一条消息明确说明，在命令执行后，该 Pod 已被删除。
- en: Using a Pod’s IP Address for Network Communication
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pod 的 IP 地址进行网络通信
- en: 'Every Pod is assigned an IP address upon creation. You can inspect a Pod’s
    IP address by using the `-o wide` command-line option for the `get pod` command
    or by describing the Pod. The IP address of the Pod in the following console output
    is `10.244.0.5`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Pod 在创建时被分配一个 IP 地址。您可以使用`get pod`命令的`-o wide`命令行选项或描述 Pod 来查看 Pod 的 IP 地址。以下控制台输出中的
    Pod 的 IP 地址是`10.244.0.5`：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The IP address assigned to a Pod is unique across all nodes and namespaces.
    This is achieved by assigning a dedicated subnet to each node when registering
    it. When creating a new Pod on a node, the IP address is leased from the assigned
    subnet. This is handled by the networking life cycle manager kube-proxy along
    with the Domain Name Service (DNS) and the Container Network Interface (CNI).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给 Pod 的 IP 地址在所有节点和命名空间中是唯一的。这是通过在注册节点时为每个节点分配专用子网来实现的。在节点上创建新的 Pod 时，IP 地址是从分配的子网中租用的。这由网络生命周期管理器
    kube-proxy 以及域名服务 (DNS) 和容器网络接口 (CNI) 处理。
- en: 'You can easily verify the behavior by creating a temporary Pod that calls the
    IP address of another Pod using the command-line tool `curl` or `wget`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个临时 Pod，在其中使用命令行工具`curl`或`wget`调用另一个 Pod 的 IP 地址来轻松验证其行为。
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s important to understand that the IP address is not considered stable over
    time. A Pod restart leases a new IP address. Therefore, this IP address is often
    referred to as *virtual* IP address. Building a microservices architecture—where
    each of the applications runs in its own Pod with the need to communicate between
    each other with a stable network interface—requires a different concept: the Service.
    Refer to [Chapter 21](ch21.xhtml#services) for more information.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的重点是，IP 地址随时间的推移并不稳定。Pod 重新启动会获得新的 IP 地址。因此，这个 IP 地址通常被称为*虚拟* IP 地址。构建微服务架构——其中每个应用程序在其自己的
    Pod 中运行，并需要使用稳定的网络接口相互通信——需要不同的概念：服务。更多信息请参见[第 21 章](ch21.xhtml#services)。
- en: Configuring Pods
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Pods
- en: The curriculum expects you to feel comfortable with editing YAML manifests either
    as files or as live object representations. This section shows you some typical
    configuration scenarios you may face during the exam. Later chapters will deepen
    your knowledge by touching on other configuration aspects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 课程希望您能够熟悉编辑 YAML 清单文件或作为实时对象表示。本节向您展示了考试期间可能遇到的一些典型配置场景。后续章节将通过触及其他配置方面来深化您的知识。
- en: Declaring environment variables
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明环境变量
- en: Applications need to expose a way to make their runtime behavior configurable.
    For example, you may want to inject the URL to an external web service or declare
    the username for a database connection. Environment variables are a common option
    to provide this runtime configuration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要暴露一种方法来使其运行时行为可配置。例如，您可能希望注入外部Web服务的URL或声明数据库连接的用户名。环境变量是提供此运行时配置的常见选项。
- en: Avoid creating container images per environment
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免为每个环境创建容器镜像
- en: It might be tempting to say, “Hey, let’s create a container image for any target
    deployment environment we need, including its configuration.” That’s a bad idea.
    One of the practices of [continuous delivery](https://oreil.ly/w4_2g) and the
    [Twelve-Factor App principles](https://12factor.net) is to build a deployable
    artifact for a commit just once. In this case, the artifact is the container image.
    Deviating configuration runtime behavior should be controllable by injecting runtime
    information when instantiating the container. You can use environment variables
    to control the behavior as needed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 或许会有诱惑说，“嘿，让我们为所需的每个目标部署环境创建一个容器镜像，包括其配置。”那是一个坏主意。[持续交付](https://oreil.ly/w4_2g)和[十二要素应用程序原则](https://12factor.net)之一的实践是为每次提交构建一个可部署的构件。在这种情况下，构件是容器镜像。通过在实例化容器时注入运行时信息，可以控制偏离的配置运行时行为。根据需要使用环境变量来控制行为。
- en: Defining environment variables in a Pod YAML manifest is relatively easy. Add
    or enhance the section `env` of a container. Every environment variable consists
    of a key-value pair, represented by the attributes `name` and `value`. Kubernetes
    does not enforce or sanitize typical naming conventions for environment variable
    keys, though it is recommended to follow the standard of using upper-case letters
    and the underscore character (`_`) to separate words.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod的YAML清单中定义环境变量相对比较简单。添加或增强容器的`env`部分。每个环境变量由键值对表示，通过`name`和`value`属性表示。Kubernetes不强制执行或清理环境变量键的典型命名约定，但建议遵循使用大写字母和下划线(`_`)来分隔单词的标准。
- en: To illustrate a set of environment variables, look at [Example 5-2](#yaml_manifest_for_a_pod_defining_environment_variables).
    The code snippet describes a Pod that runs a Java-based application using the
    Spring Boot framework.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解一组环境变量的示例，请参阅[示例 5-2](#yaml_manifest_for_a_pod_defining_environment_variables)。此代码片段描述了一个使用Spring
    Boot框架运行Java应用程序的Pod。
- en: Example 5-2\. YAML manifest for a Pod defining environment variables
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. 用于定义Pod环境变量的YAML清单
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first environment variable named `SPRING_PROFILES_ACTIVE` defines a pointer
    to a so-called profile. A profile contains environment-specific properties. Here,
    we are pointing to the profile that configures the production environment. The
    environment variable `VERSION` specifies the application version. Its value corresponds
    to the tag of the image and can be exposed by the running application to display
    the value in the user interface.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个名为`SPRING_PROFILES_ACTIVE`的环境变量定义了指向所谓配置文件的指针。配置文件包含特定于环境的属性。在这里，我们指向配置生产环境的配置文件。环境变量`VERSION`指定了应用程序版本。其值对应于图像的标签，并且可以由运行中的应用程序公开以在用户界面中显示值。
- en: Defining a command with arguments
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义带参数的命令
- en: Many container images already define an `ENTRYPOINT` or `CMD` instruction. The
    command assigned to the instruction is automatically executed as part of the container
    startup. For example, the Hazelcast image we used earlier defines the instruction
    `CMD ["/opt/hazelcast/start-hazelcast.sh"]`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 许多容器镜像已经定义了`ENTRYPOINT`或`CMD`指令。指令分配的命令将作为容器启动的一部分自动执行。例如，我们之前使用的Hazelcast镜像定义了指令`CMD
    ["/opt/hazelcast/start-hazelcast.sh"]`。
- en: In a Pod definition, you can either redefine the image `ENTRYPOINT` and `CMD`
    instructions or assign a command to execute for the container if it hasn’t been
    specified by the image. You can provide this information with the help of the
    `command` and `args` attributes for a container. The `command` attribute overrides
    the image’s `ENTRYPOINT` instruction. The `args` attribute replaces the `CMD`
    instruction of an image.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod定义中，您可以重新定义镜像的`ENTRYPOINT`和`CMD`指令，或者为容器分配一个未被镜像指定的执行命令。您可以借助`command`和`args`属性为容器提供这些信息。`command`属性将覆盖镜像的`ENTRYPOINT`指令。`args`属性替换镜像的`CMD`指令。
- en: 'Imagine you wanted to provide a command to an image that doesn’t provide one
    yet. As usual, there are two different approaches: imperative and declarative.
    We’ll generate the YAML manifest with the help of the `run` command. The Pod should
    use the `busybox:1.36.1` image and execute a shell command that renders the current
    date every 10 seconds in an infinite loop:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要为尚未提供命令的镜像提供一个命令。通常有两种不同的方法：命令式和声明式。我们将利用 `run` 命令生成 YAML 清单。Pod 应该使用 `busybox:1.36.1`
    镜像，并执行一个每 10 秒在无限循环中呈现当前日期的 shell 命令：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see in the generated but condensed `pod.yaml` file shown in [Example 5-3](#a_yaml_manifest_containing_a_args_attribute)
    that the command has been turned into an `args` attribute. Kubernetes specifies
    each argument on a single line.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成但精简的 `pod.yaml` 文件中可以看到，[示例 5-3](#a_yaml_manifest_containing_a_args_attribute)
    中的命令已被转换为 `args` 属性。Kubernetes 将每个参数指定为单独的行。
- en: Example 5-3\. A YAML manifest containing an args attribute
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. 包含 args 属性的 YAML 清单
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You could have achieved the same by a combination of the `command` and `args`
    attributes if you were to handcraft the YAML manifest. [Example 5-4](#a_yaml_file_containing_a_command_and_args_attribute)
    shows a different approach.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要手动创建 YAML 清单，可以通过`command`和`args`属性的组合实现相同的效果。[示例 5-4](#a_yaml_file_containing_a_command_and_args_attribute)展示了一种不同的方法。
- en: Example 5-4\. A YAML manifest containing command and args attributes
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. 包含 command 和 args 属性的 YAML 清单
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can quickly verify if the declared command actually does its job. First,
    create the Pod instance, then tail the logs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以快速验证声明的命令是否真的有效。首先创建 Pod 实例，然后尾随日志：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Deleting a Pod
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除一个 Pod
- en: 'Sooner or later you’ll want to delete a Pod. During the exam, you may be asked
    to remove a Pod. Or possibly, you made a configuration mistake and want to start
    the question from scratch:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早你会想要删除一个 Pod。在考试期间，可能会要求你删除一个 Pod。或者，你可能出现了配置错误，希望从头开始：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Keep in mind that Kubernetes tries to delete a Pod *gracefully*. This means
    that the Pod will try to finish active requests to the Pod to avoid unnecessary
    disruption to the end user. A graceful deletion operation can take anywhere from
    5 to 30 seconds, time you don’t want to waste during the exam. See [Chapter 1](ch01.xhtml#exam-details-and-resources)
    for more information on how to speed up the process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Kubernetes 尝试*优雅地*删除一个 Pod。这意味着 Pod 将尝试完成对其的活动请求，以避免给最终用户带来不必要的中断。一个优雅的删除操作可能需要
    5 到 30 秒的时间，这是你在考试中不想浪费的时间。更多关于如何加速这一过程的信息，请参见 [第一章](ch01.xhtml#exam-details-and-resources)。
- en: 'An alternative way to delete a Pod is to point the `delete` command to the
    YAML manifest you used to create it. The behavior is the same:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个 Pod 的另一种方法是将 `delete` 命令指向你用来创建它的 YAML 清单。行为是相同的：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To save time during the exam, you can circumvent the grace period by adding
    the `--now` option to the `delete` command. Avoid using the `--now` flag in production
    Kubernetes environments.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在考试中节省时间，你可以通过将 `delete` 命令添加 `--now` 选项来绕过优雅期限。在生产 Kubernetes 环境中避免使用 `--now`
    标志。
- en: Working with Namespaces
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理命名空间
- en: Namespaces are an API construct to avoid naming collisions, and they represent
    a scope for object names. A good use case for namespaces is to isolate the objects
    by team or responsibility.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是避免命名冲突的 API 构造，并且它们表示对象名称的作用域。命名空间的一个很好的用例是通过团队或责任来隔离对象。
- en: Namespaces for objects
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的命名空间
- en: The content in this chapter demonstrates the use of namespaces for Pod objects.
    Namespaces are not a concept applicable only to Pods though. Most object types
    can be grouped by a namespace.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容演示了使用命名空间管理 Pod 对象。尽管命名空间不仅适用于 Pod 的概念。大多数对象类型都可以通过命名空间进行分组。
- en: Most questions in the exam will ask you to execute the command in a specific
    namespace that has been set up for you. The following sections briefly touch on
    the basic operations needed to deal with a namespace.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中，大多数问题都会要求你在为你设置的特定命名空间中执行命令。以下部分简要介绍了处理命名空间所需的基本操作。
- en: Listing Namespaces
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出命名空间
- en: 'A Kubernetes cluster starts out with a couple of initial namespaces. You can
    list them with the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群最初会启动几个初始命名空间。你可以使用以下命令列出它们：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `default` namespace hosts objects that haven’t been assigned to an explicit
    namespace. Namespaces starting with the prefix `kube-` are not considered end
    user-namespaces. They have been created by the Kubernetes system. You will not
    have to interact with them as an application developer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`命名空间托管尚未分配到显式命名空间的对象。以`kube-`前缀开头的命名空间不视为最终用户命名空间。它们是由 Kubernetes
    系统创建的。作为应用程序开发人员，您不必与它们交互。'
- en: Creating and Using a Namespace
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用命名空间
- en: 'To create a new namespace, use the `create namespace` command. The following
    command uses the name `code-red`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的命名空间，请使用`create namespace`命令。以下命令使用名称`code-red`：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 5-5](#namespace_yaml_manifest) shows the corresponding representation
    as a YAML manifest.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-5](#namespace_yaml_manifest)显示了其作为 YAML 清单的对应表示。'
- en: Example 5-5\. Namespace YAML manifest
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 命名空间 YAML 清单
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the namespace is in place, you can create objects within it. You can do
    so with the command line option `--namespace` or its short-form `-n`. The following
    commands create a new Pod in the namespace `code-red` and then list the available
    Pods in the namespace:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间就位后，您可以在其中创建对象。您可以使用命令行选项`--namespace`或其缩写形式`-n`来执行此操作。以下命令在命名空间`code-red`中创建一个新的
    Pod，然后列出该命名空间中可用的 Pod：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Setting a Namespace Preference
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置命名空间偏好
- en: 'Providing the `--namespace` or `-n` command line option for every command is
    tedious and error-prone. You can set a permanent namespace preference if you know
    that you need to interact with a specific namespace you are responsible for. The
    first command shown sets the permanent namespace `code-red`. The second command
    renders the currently set permanent namespace:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个命令提供`--namespace`或`-n`命令行选项非常繁琐且容易出错。如果您知道需要与负责的特定命名空间交互，可以设置永久命名空间偏好。第一个显示的命令设置了永久命名空间`code-red`。第二个命令显示当前设置的永久命名空间：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Subsequent `kubectl` executions do not have to spell out the namespace `code-red`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的`kubectl`执行不必再次明确指定命名空间`code-red`：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can always switch back to the `default` namespace or another custom namespace
    using the `config set-context` command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以始终使用`config set-context`命令切换回`default`命名空间或其他自定义命名空间：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Deleting a Namespace
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除命名空间
- en: 'Deleting a namespace has a cascading effect on the object existing in it. Deleting
    a namespace will automatically delete its objects:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 删除命名空间会对其中现有的对象产生级联影响。删除命名空间将自动删除其对象：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The exam puts a strong emphasis on the concept of a Pod, a Kubernetes primitive
    responsible for running an application in a container. A Pod can define one or
    many containers that use a container image. Upon its creation, the container image
    is resolved and used to bootstrap the application. Every Pod can be further customized
    with the relevant YAML configuration.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考试强调 Pod 的概念，这是 Kubernetes 的一个原语，负责在容器中运行应用程序。一个 Pod 可以定义使用容器映像的一个或多个容器。在创建时，容器映像将被解析并用于启动应用程序。可以使用相关的
    YAML 配置进一步自定义每个 Pod。
- en: Exam Essentials
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考试要点
- en: Know how to interact with Pods
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何与 Pod 交互
- en: A Pod runs an application inside of a container. You can check on the status
    and the configuration of the Pod by inspecting the object with the `kubectl get`
    or `kubectl describe` commands. Get familiar with the life cycle phases of a Pod
    to be able to quickly diagnose errors. The command `kubectl logs` can be used
    to download the container log information without having to shell into the container.
    Use the command `kubectl exec` to further explore the container environment, e.g.,
    to check on processes or to examine files.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Pod 在容器内运行应用程序。您可以通过检查对象并使用`kubectl get`或`kubectl describe`命令来查看 Pod 的状态和配置。熟悉
    Pod 的生命周期阶段可以快速诊断错误。命令`kubectl logs`可用于下载容器日志信息，而无需进入容器壳。使用命令`kubectl exec`进一步探索容器环境，例如检查进程或检查文件。
- en: Understand advanced Pod configuration options
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 了解高级 Pod 配置选项
- en: Sometimes you have to start with the YAML manifest of a Pod and then create
    the Pod declaratively. This could be the case if you wanted to provide environment
    variables to the container or declare a custom command. Practice different configuration
    options by copy-pasting relevant code snippets from the Kubernetes documentation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您必须从 Pod 的 YAML 清单开始，然后声明性地创建 Pod。如果您想向容器提供环境变量或声明自定义命令，这种情况可能会发生。通过从 Kubernetes
    文档中复制相关代码片段来练习不同的配置选项。
- en: Practice using a custom namespace
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 练习使用自定义命名空间
- en: Most questions in the exam will ask you to work within a given namespace. You
    need to understand how to interact with that namespace from `kubectl` using the
    options `--namespace` and `-n`. To avoid accidentally working on the wrong namespace,
    know how to permanently set a namespace.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考试中的大多数问题将要求您在特定的命名空间中工作。您需要了解如何使用 `kubectl` 的选项 `--namespace` 和 `-n` 与该命名空间进行交互。为了避免意外地在错误的命名空间上工作，知道如何永久设置命名空间。
- en: Sample Exercises
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例练习
- en: Solutions to these exercises are available in [Appendix A](app01_split_001.xhtml#appendix_a_pods_namespaces).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些练习的方案可以在 [附录 A](app01_split_001.xhtml#appendix_a_pods_namespaces) 找到。
- en: Create a new Pod named `nginx` running the image `nginx:1.17.10`. Expose the
    container port 80\. The Pod should live in the namespace named `ckad`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `nginx` 的新 Pod，运行镜像 `nginx:1.17.10`。暴露容器端口 80。Pod 应该位于名为 `ckad` 的命名空间中。
- en: Get the details of the Pod including its IP address.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取 Pod 的详细信息，包括其 IP 地址。
- en: Create a temporary Pod that uses the `busybox:1.36.1` image to execute a `wget`
    command inside of the container. The `wget` command should access the endpoint
    exposed by the `nginx` container. You should see the HTML response body rendered
    in the terminal.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个临时 Pod，使用 `busybox:1.36.1` 镜像在容器内执行 `wget` 命令。`wget` 命令应该访问 `nginx` 容器暴露的端点。您应该在终端看到渲染的
    HTML 响应主体。
- en: Get the logs of the `nginx` container.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取 `nginx` 容器的日志。
- en: Add the environment variables `DB_URL=postgresql://mydb:5432` and `DB_USERNAME=admin`
    to the container of the `nginx` Pod.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向 `nginx` Pod 的容器中添加环境变量 `DB_URL=postgresql://mydb:5432` 和 `DB_USERNAME=admin`。
- en: Open a shell for the `nginx` container and inspect the contents of the current
    directory `ls -l`. Exit out of the container.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开 `nginx` 容器的 shell 并检查当前目录的内容 `ls -l`。退出容器。
- en: 'Create a YAML manifest for a Pod named `loop` that runs the `busybox:1.36.1`
    image in a container. The container should run the following command: `for i in
    {1..10}; do echo "Welcome $i times"; done`. Create the Pod from the YAML manifest.
    What’s the status of the Pod?'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为名为 `loop` 的 Pod 创建一个 YAML 清单，该 Pod 在容器中运行 `busybox:1.36.1` 镜像。容器应运行以下命令：`for
    i in {1..10}; do echo "Welcome $i times"; done`。从 YAML 清单创建 Pod。Pod 的状态是什么？
- en: Edit the Pod named `loop`. Change the command to run in an endless loop. Each
    iteration should `echo` the current date.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑名为 `loop` 的 Pod。将运行命令更改为无限循环。每次迭代应该 `echo` 当前日期。
- en: Inspect the events and the status of the Pod `loop`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查 `loop` Pod 的事件和状态。
