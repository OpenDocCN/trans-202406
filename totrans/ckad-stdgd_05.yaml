- en: Chapter 5\. Pods and Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important primitive in the Kubernetes API is the Pod. A Pod lets you
    run a containerized application. In practice, you’ll often encounter a one-to-one
    mapping between a Pod and a container; however, the use cases discussed in [Chapter 8](ch08.xhtml#multi_container_pods)
    benefit from declaring more than one container in a single Pod.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to running a container, a Pod can consume other services like storage,
    configuration data, and much more. Therefore, think of a Pod as a wrapper for
    running containers while at the same time being able to mix in cross-cutting and
    specialized Kubernetes features.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at working with a Pod running only a single container.
    We’ll discuss all important `kubectl` commands for creating, modifying, interacting,
    and deleting using imperative and declarative approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Pods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pod definition needs to state an image for every container. Upon creating
    the Pod object, imperatively or declaratively, the scheduler will assign the Pod
    to a node, and the container runtime engine will check if the container image
    already exists on that node. If the image doesn’t exist yet, the engine will download
    it from a container image registry. By default the registry is Docker Hub. As
    soon as the image exists on the node, the container is instantiated and will run.
    [Figure 5-1](Images/#kubelet_container_images) demonstrates the execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0501](Images/ckd2_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Container Runtime Interface interaction with container images
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `run` command is the central entry point for creating Pods imperatively.
    Let’s talk about its usage and the most important command line options you should
    memorize and practice. Say you wanted to run a [Hazelcast instance](https://hazelcast.com)
    inside of a Pod. The container should use the latest [Hazelcast image](https://oreil.ly/ChxPI),
    expose port 5701, and define an environment variable. In addition, we’ll also
    want to assign two labels to the Pod. The following imperative command combines
    this information and does not require any further editing of the live object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `run` command offers a wealth of command line options. Execute the `kubectl
    run --help` or refer to the Kubernetes documentation for a broad overview. For
    the exam, you’ll not need to understand every command. [Table 5-1](#important_kubectl_run_command_line_options)
    lists the most commonly used options.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Important `kubectl` run command line options
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Example value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--image` | nginx:1.25.1 | The image for the container to run. |'
  prefs: []
  type: TYPE_TB
- en: '| `--port` | 8080 | The port that this container exposes. |'
  prefs: []
  type: TYPE_TB
- en: '| `--rm` | N/A | Deletes the Pod after command in the container finishes. See
    [“Creating a Temporary Pod”](#temporary_pod) for more information. |'
  prefs: []
  type: TYPE_TB
- en: '| `--env` | PROFILE=dev | The environment variables to set in the container.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--labels` | app=frontend | A comma-separated list of labels to apply to
    the Pod. [Chapter 9](ch09.xhtml#labels_annotations) explains labels in more detail.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Some developers are more used to creating Pods from a YAML manifest. Probably
    you’re already accustomed to the declarative approach because you’re using it
    at work. You can express the same configuration for the Hazelcast Pod by opening
    the editor, copying a Pod YAML code snippet from the Kubernetes online documentation,
    and modifying it to your needs. [Example 5-1](#pod_yaml_manifest) shows the Pod
    manifest saved in the file `pod.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Pod YAML manifest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_pods_and_namespaces_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Assigns the name of `hazelcast` to the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_pods_and_namespaces_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies labels to the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_pods_and_namespaces_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Declares the container image to be executed in the container of the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_pods_and_namespaces_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects one or many environment variables to the container.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_pods_and_namespaces_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Number of port to expose on the Pod’s IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the Pod from the manifest is straightforward. Simply use the `create`
    or `apply` command, as shown here and explained in [“Managing Objects”](ch03.xhtml#managing_objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Listing Pods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have created a Pod, you can further inspect its runtime information.
    The `kubectl` command offers a command for listing all Pods running in the cluster:
    `get pods`. The following command renders the Pod named `hazelcast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Real-world Kubernetes clusters can run hundreds of Pods at the same time. If
    you know the name of the Pod of interest, it’s often easier to query by name.
    You would still see only a single Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Pod Life Cycle Phases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because Kubernetes is a state engine with asynchronous control loops, it’s possible
    that the status of the Pod doesn’t show a `Running` status right away when listing
    the Pods. It usually takes a couple of seconds to retrieve the image and start
    the container. Upon Pod creation, the object goes through several [life cycle
    phases](https://oreil.ly/Qk5Ob), as shown in [Figure 5-2](#pod_lifecycle_phases).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0502](Images/ckd2_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Pod life cycle phases
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understanding the implications of each phase is important as it gives you an
    idea about the operational status of a Pod. For example, during the exam you may
    be asked to identify a Pod with an issue and further debug the object. [Table 5-2](#pod_lifecycle_phases_table)
    describes all Pod life cycle phases.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Pod life cycle phases
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Pending` | The Pod has been accepted by the Kubernetes system, but one or
    more of the container images has not been created. |'
  prefs: []
  type: TYPE_TB
- en: '| `Running` | At least one container is still running or is in the process
    of starting or restarting. |'
  prefs: []
  type: TYPE_TB
- en: '| `Succeeded` | All containers in the Pod terminated successfully. |'
  prefs: []
  type: TYPE_TB
- en: '| `Failed` | Containers in the Pod terminated,; at least one failed with an
    error. |'
  prefs: []
  type: TYPE_TB
- en: '| `Unknown` | The state of Pod could not be obtained. |'
  prefs: []
  type: TYPE_TB
- en: 'The Pod life cycle phases should not be confused with container states within
    a Pod. Containers can have one of the three possible states: `Waiting`, `Running`,
    and `Terminated`. You can read more about container states in the [Kubernetes
    documentation](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-states).'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Pod Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rendered table produced by the `get` command provides high-level information
    about a Pod. But what if you needed a deeper look at the details? The `describe`
    command can help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The terminal output contains the metadata information of a Pod, the containers
    it runs, and the event log, such as failures when the Pod was scheduled. The example
    output has been condensed to show just the metadata section. You can expect the
    output to be very lengthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a way to be more specific about the information you want to render.
    You can combine the `describe` command with a Unix `grep` command if you want
    to identify the image for running in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Accessing Logs of a Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As application developers, we know very well what to expect in the log files
    produced by the application we implemented. Runtime failures may occur when operating
    an application in a container. The `logs` command downloads the log output of
    a container. The following output indicates that the Hazelcast server started
    up successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It’s very likely that more log entries will be produced as soon as the container
    receives traffic from end users. You can stream the logs with the command line
    option `-f`. This option is helpful if you want to see logs in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes tries to restart a container under certain conditions, such as if
    the image cannot be resolved on the first try. Upon a container restart, you won’t
    have access to the logs of the previous container; the `logs` command renders
    the logs only for the current container. However, you can still get back to the
    logs of the previous container by adding the `-p` command line option. You may
    want to use the option to identify the root cause that triggered a container restart.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a Command in Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some situations require you to get the shell to a running container and explore
    the filesystem. Maybe you want to inspect the configuration of your application
    or debug its current state. You can use the `exec` command to open a shell in
    the container to explore it interactively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you do not have to provide the resource type. This command only
    works for a Pod. The two dashes (`--`) separate the `exec` command and its options
    from the command you want to run inside of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to execute a single command inside of a container. Say you
    wanted to render the environment variables available to containers without having
    to be logged in. Just remove the interactive flag `-it` and provide the relevant
    command after the two dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Temporary Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command executed inside of a Pod—usually an application implementing business
    logic—is meant to run infinitely. Once the Pod has been created, it will stick
    around. Under certain conditions, you want to execute a command in a Pod just
    for troubleshooting. This use case doesn’t require a Pod object to run beyond
    the execution of the command. That’s where temporary Pods come into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `run` command provides the flag `--rm`, which will automatically delete
    the Pod after the command running inside of it finishes. Say you want to render
    all environment variables using `env` to see what’s available inside of the container.
    The following command achieves exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last message rendered in the output clearly states that the Pod was deleted
    after command execution.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Pod’s IP Address for Network Communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every Pod is assigned an IP address upon creation. You can inspect a Pod’s
    IP address by using the `-o wide` command-line option for the `get pod` command
    or by describing the Pod. The IP address of the Pod in the following console output
    is `10.244.0.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The IP address assigned to a Pod is unique across all nodes and namespaces.
    This is achieved by assigning a dedicated subnet to each node when registering
    it. When creating a new Pod on a node, the IP address is leased from the assigned
    subnet. This is handled by the networking life cycle manager kube-proxy along
    with the Domain Name Service (DNS) and the Container Network Interface (CNI).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily verify the behavior by creating a temporary Pod that calls the
    IP address of another Pod using the command-line tool `curl` or `wget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to understand that the IP address is not considered stable over
    time. A Pod restart leases a new IP address. Therefore, this IP address is often
    referred to as *virtual* IP address. Building a microservices architecture—where
    each of the applications runs in its own Pod with the need to communicate between
    each other with a stable network interface—requires a different concept: the Service.
    Refer to [Chapter 21](ch21.xhtml#services) for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Pods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The curriculum expects you to feel comfortable with editing YAML manifests either
    as files or as live object representations. This section shows you some typical
    configuration scenarios you may face during the exam. Later chapters will deepen
    your knowledge by touching on other configuration aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications need to expose a way to make their runtime behavior configurable.
    For example, you may want to inject the URL to an external web service or declare
    the username for a database connection. Environment variables are a common option
    to provide this runtime configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid creating container images per environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It might be tempting to say, “Hey, let’s create a container image for any target
    deployment environment we need, including its configuration.” That’s a bad idea.
    One of the practices of [continuous delivery](https://oreil.ly/w4_2g) and the
    [Twelve-Factor App principles](https://12factor.net) is to build a deployable
    artifact for a commit just once. In this case, the artifact is the container image.
    Deviating configuration runtime behavior should be controllable by injecting runtime
    information when instantiating the container. You can use environment variables
    to control the behavior as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining environment variables in a Pod YAML manifest is relatively easy. Add
    or enhance the section `env` of a container. Every environment variable consists
    of a key-value pair, represented by the attributes `name` and `value`. Kubernetes
    does not enforce or sanitize typical naming conventions for environment variable
    keys, though it is recommended to follow the standard of using upper-case letters
    and the underscore character (`_`) to separate words.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate a set of environment variables, look at [Example 5-2](#yaml_manifest_for_a_pod_defining_environment_variables).
    The code snippet describes a Pod that runs a Java-based application using the
    Spring Boot framework.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. YAML manifest for a Pod defining environment variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first environment variable named `SPRING_PROFILES_ACTIVE` defines a pointer
    to a so-called profile. A profile contains environment-specific properties. Here,
    we are pointing to the profile that configures the production environment. The
    environment variable `VERSION` specifies the application version. Its value corresponds
    to the tag of the image and can be exposed by the running application to display
    the value in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a command with arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many container images already define an `ENTRYPOINT` or `CMD` instruction. The
    command assigned to the instruction is automatically executed as part of the container
    startup. For example, the Hazelcast image we used earlier defines the instruction
    `CMD ["/opt/hazelcast/start-hazelcast.sh"]`.
  prefs: []
  type: TYPE_NORMAL
- en: In a Pod definition, you can either redefine the image `ENTRYPOINT` and `CMD`
    instructions or assign a command to execute for the container if it hasn’t been
    specified by the image. You can provide this information with the help of the
    `command` and `args` attributes for a container. The `command` attribute overrides
    the image’s `ENTRYPOINT` instruction. The `args` attribute replaces the `CMD`
    instruction of an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you wanted to provide a command to an image that doesn’t provide one
    yet. As usual, there are two different approaches: imperative and declarative.
    We’ll generate the YAML manifest with the help of the `run` command. The Pod should
    use the `busybox:1.36.1` image and execute a shell command that renders the current
    date every 10 seconds in an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the generated but condensed `pod.yaml` file shown in [Example 5-3](#a_yaml_manifest_containing_a_args_attribute)
    that the command has been turned into an `args` attribute. Kubernetes specifies
    each argument on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. A YAML manifest containing an args attribute
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You could have achieved the same by a combination of the `command` and `args`
    attributes if you were to handcraft the YAML manifest. [Example 5-4](#a_yaml_file_containing_a_command_and_args_attribute)
    shows a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. A YAML manifest containing command and args attributes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can quickly verify if the declared command actually does its job. First,
    create the Pod instance, then tail the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sooner or later you’ll want to delete a Pod. During the exam, you may be asked
    to remove a Pod. Or possibly, you made a configuration mistake and want to start
    the question from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that Kubernetes tries to delete a Pod *gracefully*. This means
    that the Pod will try to finish active requests to the Pod to avoid unnecessary
    disruption to the end user. A graceful deletion operation can take anywhere from
    5 to 30 seconds, time you don’t want to waste during the exam. See [Chapter 1](ch01.xhtml#exam-details-and-resources)
    for more information on how to speed up the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to delete a Pod is to point the `delete` command to the
    YAML manifest you used to create it. The behavior is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To save time during the exam, you can circumvent the grace period by adding
    the `--now` option to the `delete` command. Avoid using the `--now` flag in production
    Kubernetes environments.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Namespaces are an API construct to avoid naming collisions, and they represent
    a scope for object names. A good use case for namespaces is to isolate the objects
    by team or responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces for objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The content in this chapter demonstrates the use of namespaces for Pod objects.
    Namespaces are not a concept applicable only to Pods though. Most object types
    can be grouped by a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Most questions in the exam will ask you to execute the command in a specific
    namespace that has been set up for you. The following sections briefly touch on
    the basic operations needed to deal with a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Kubernetes cluster starts out with a couple of initial namespaces. You can
    list them with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `default` namespace hosts objects that haven’t been assigned to an explicit
    namespace. Namespaces starting with the prefix `kube-` are not considered end
    user-namespaces. They have been created by the Kubernetes system. You will not
    have to interact with them as an application developer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Using a Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new namespace, use the `create namespace` command. The following
    command uses the name `code-red`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5-5](#namespace_yaml_manifest) shows the corresponding representation
    as a YAML manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. Namespace YAML manifest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the namespace is in place, you can create objects within it. You can do
    so with the command line option `--namespace` or its short-form `-n`. The following
    commands create a new Pod in the namespace `code-red` and then list the available
    Pods in the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Setting a Namespace Preference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Providing the `--namespace` or `-n` command line option for every command is
    tedious and error-prone. You can set a permanent namespace preference if you know
    that you need to interact with a specific namespace you are responsible for. The
    first command shown sets the permanent namespace `code-red`. The second command
    renders the currently set permanent namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Subsequent `kubectl` executions do not have to spell out the namespace `code-red`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can always switch back to the `default` namespace or another custom namespace
    using the `config set-context` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting a namespace has a cascading effect on the object existing in it. Deleting
    a namespace will automatically delete its objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exam puts a strong emphasis on the concept of a Pod, a Kubernetes primitive
    responsible for running an application in a container. A Pod can define one or
    many containers that use a container image. Upon its creation, the container image
    is resolved and used to bootstrap the application. Every Pod can be further customized
    with the relevant YAML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Know how to interact with Pods
  prefs: []
  type: TYPE_NORMAL
- en: A Pod runs an application inside of a container. You can check on the status
    and the configuration of the Pod by inspecting the object with the `kubectl get`
    or `kubectl describe` commands. Get familiar with the life cycle phases of a Pod
    to be able to quickly diagnose errors. The command `kubectl logs` can be used
    to download the container log information without having to shell into the container.
    Use the command `kubectl exec` to further explore the container environment, e.g.,
    to check on processes or to examine files.
  prefs: []
  type: TYPE_NORMAL
- en: Understand advanced Pod configuration options
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you have to start with the YAML manifest of a Pod and then create
    the Pod declaratively. This could be the case if you wanted to provide environment
    variables to the container or declare a custom command. Practice different configuration
    options by copy-pasting relevant code snippets from the Kubernetes documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Practice using a custom namespace
  prefs: []
  type: TYPE_NORMAL
- en: Most questions in the exam will ask you to work within a given namespace. You
    need to understand how to interact with that namespace from `kubectl` using the
    options `--namespace` and `-n`. To avoid accidentally working on the wrong namespace,
    know how to permanently set a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_001.xhtml#appendix_a_pods_namespaces).
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Pod named `nginx` running the image `nginx:1.17.10`. Expose the
    container port 80\. The Pod should live in the namespace named `ckad`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the details of the Pod including its IP address.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a temporary Pod that uses the `busybox:1.36.1` image to execute a `wget`
    command inside of the container. The `wget` command should access the endpoint
    exposed by the `nginx` container. You should see the HTML response body rendered
    in the terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Get the logs of the `nginx` container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the environment variables `DB_URL=postgresql://mydb:5432` and `DB_USERNAME=admin`
    to the container of the `nginx` Pod.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open a shell for the `nginx` container and inspect the contents of the current
    directory `ls -l`. Exit out of the container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a YAML manifest for a Pod named `loop` that runs the `busybox:1.36.1`
    image in a container. The container should run the following command: `for i in
    {1..10}; do echo "Welcome $i times"; done`. Create the Pod from the YAML manifest.
    What’s the status of the Pod?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the Pod named `loop`. Change the command to run in an endless loop. Each
    iteration should `echo` the current date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inspect the events and the status of the Pod `loop`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
