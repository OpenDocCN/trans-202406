["```\n<button type=\"button\">Click me!</button>\n```", "```\nfunction Button(props) {\n  return <button type=\"button\" {...props} />;\n}\n```", "```\ntype ButtonProps = JSX.IntrinsicElements[\"button\"];\n\nfunction Button(props: ButtonProps) {\n  return <button type=\"button\" {...props} />;\n}\n```", "```\ntype ButtonProps = Omit<JSX.IntrinsicElements[\"button\"], \"type\">;\n\nfunction Button(props: ButtonProps) {\n  return <button type=\"button\" {...props} />;\n}\n\nconst aButton = <Button type=\"button\">Hi</Button>;\n//                      ^\n// Type '{ children: string; type: string; }' is not\n// assignable to type 'IntrinsicAttributes & ButtonProps'.\n// Property 'type' does not exist on type\n// 'IntrinsicAttributes & ButtonProps'.(2322)\n```", "```\ntype SubmitButtonProps = Omit<JSX.IntrinsicElements[\"button\"], \"type\">;\n\nfunction SubmitButton(props: SubmitButtonProps) {\n  return <button type=\"submit\" {...props} />;\n}\n```", "```\ntype StyledButton = Omit<\n  JSX.IntrinsicElements[\"button\"],\n  \"type\" | \"className\" | \"style\"\n> & {\n  type: \"primary\" | \"secondary\";\n};\n\nfunction StyledButton({ type, ...allProps }: StyledButton) {\n  return <Button type=\"button\" className={`btn-${type}`} {...allProps}/>;\n}\n```", "```\ntype MakeRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>;\n```", "```\ntype ImgProps\n  = MakeRequired<\n    JSX.IntrinsicElements[\"img\"],\n    \"alt\" | \"src\"\n  >;\n\nexport function Img(props: ImgProps) {\n  return <img {...props} />;\n}\n\nconst anImage = <Img />;\n//               ^\n// Type '{}' is missing the following properties from type\n// 'Required<Pick<DetailedHTMLProps<ImgHTMLAttributes<HTMLImageElement>,\n//  HTMLImageElement>, \"alt\" | \"src\">>': alt, src (2739)\n```", "```\nfunction Input({\n  value = \"\", ...allProps\n}: Props) {\n  return (\n    <input\n      defaultValue={value}\n      {...allProps}\n    />\n  );\n}\n```", "```\ntype ControlledProps =\n  Omit<JSX.IntrinsicElements[\"input\"], \"value\"> & {\n    value: string;\n  };\n```", "```\nfunction Input({\n  value = \"\", onChange, ...allProps\n}: ControlledProps) {\n  return (\n    <input\n      value={value}\n      {...allProps}\n      onChange={onChange}\n    />\n  );\n}\n\nfunction AComponentUsingInput() {\n  const [val, setVal] = useState(\"\");\n  return <Input\n    value={val}\n    onChange={(e) => {\n      setVal(e.target.value);\n    }}\n  />\n}\n```", "```\nimport React, { useState } from \"react\";\n\n// A helper type setting a few properties to be required\ntype OnlyRequired<T, K extends keyof T = keyof T> = Required<Pick<T, K>> &\n  Partial<Omit<T, K>>;\n\n// Branch 1: Make \"value\" and \"onChange\" required, drop `defaultValue`\ntype ControlledProps = OnlyRequired<\n  JSX.IntrinsicElements[\"input\"],\n  \"value\" | \"onChange\"\n> & {\n  defaultValue?: never;\n};\n\n// Branch 2: Drop `value` and `onChange`, make `defaultValue` required\ntype UncontrolledProps = Omit<\n  JSX.IntrinsicElements[\"input\"],\n  \"value\" | \"onChange\"\n> & {\n  defaultValue: string;\n  value?: never;\n  onChange?: never;\n};\n\ntype InputProps = ControlledProps | UncontrolledProps;\n\nfunction Input({ ...allProps }: InputProps) {\n  return <input {...allProps} />;\n}\n\nfunction Controlled() {\n  const [val, setVal] = useState(\"\");\n  return <Input value={val} onChange={(e) => setVal(e.target.value)} />;\n}\n\nfunction Uncontrolled() {\n  return <Input defaultValue=\"Hello\" />;\n}\n```", "```\nconst [state, setState] = useState(0);\n```", "```\nconst [count, setCount] = useState(0);\nconst [darkMode, setDarkMode] = useState(true);\n```", "```\nexport const useToggle = (initialValue: boolean) => {\n  const [value, setValue] = useState(initialValue);\n  const toggleValue = () => setValue(!value);\n  return [value, toggleValue];\n}\n```", "```\nexport const Body = () => {\n  const [isVisible, toggleVisible] = useToggle(false)\n  return (\n    <>\n      <button onClick={toggleVisible}></button>\n    { /* Error. See below */ }\n      {isVisible && <div>World</div>}>}\n    </>\n  )\n}\n// Error: Type 'boolean | (() => void)' is not assignable to\n// type 'MouseEventHandler<HTMLButtonElement> | undefined'.\n// Type 'boolean' is not assignable to type\n// 'MouseEventHandler<HTMLButtonElement>'.(2322)\n```", "```\n// add a return type here\nexport const useToggle = (initialValue: boolean): [boolean, () => void] => {\n  const [value, setValue] = useState(initialValue);\n  const toggleValue = () => setValue(!value);\n  return [value, toggleValue];\n};\n```", "```\nexport const useToggle = (initialValue: boolean) => {\n  const [value, setValue] = useState(initialValue);\n  const toggleValue = () => setValue(!value);\n  // here, we freeze the array to a tuple\n  return [value, toggleValue] as const;\n}\n```", "```\nconst Button = React.forwardRef((props, ref) => (\n  <button type=\"button\" {...props} ref={ref}>\n    {props.children}\n  </button>\n));\n\n// Usage: You can use your proxy just like you use\n// a regular button!\nconst reference = React.createRef();\n<Button className=\"primary\" ref={reference}>Hello</Button>\n```", "```\ntype ButtonProps = JSX.IntrinsicElements[\"button\"];\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  (props, ref) => (\n    <button type=\"button\" {...props} ref={ref}>\n      {props.children}\n    </button>\n  )\n);\n\n// Usage\nconst reference = React.createRef<HTMLButtonElement>();\n<Button className=\"primary\" ref={reference}>Hello</Button>\n```", "```\ntype ClickableListProps<T> = {\n  items: T[];\n  onSelect: (item: T) => void;\n};\n\nfunction ClickableList<T>(props: ClickableListProps<T>) {\n  return (\n    <ul>\n      {props.items.map((item, idx) => (\n        <li>\n          <button key={idx} onClick={() => props.onSelect(item)}>\n            Choose\n          </button>\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Usage\nconst items = [1, 2, 3, 4];\n<ClickableList items={items}\n  onSelect={(item) => {\n    // item is of type number\n    console.log(item);\n  } } />\n```", "```\n// The original component extended with a `ref`\nfunction ClickableListInner<T>(\n  props: ClickableListProps<T>,\n  ref: React.ForwardedRef<HTMLUListElement>\n) {\n  return (\n    <ul ref={ref}>\n      {props.items.map((item, i) => (\n        <li key={i}>\n          <button onClick={(el) => props.onSelect(item)}>Select</button>\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// As an argument in `React.forwardRef`\nconst ClickableList = React.forwardRef(ClickableListInner)\n```", "```\nconst ClickableList = React.forwardRef(ClickableListInner) as <T>(\n  props: ClickableListProps<T> & { ref?: React.ForwardedRef<HTMLUListElement> }\n) => ReturnType<typeof ClickableListInner>;\n```", "```\ntype ClickableListProps<T> = {\n  items: T[];\n  onSelect: (item: T) => void;\n  mRef?: React.Ref<HTMLUListElement> | null;\n};\n\nexport function ClickableList<T>(\n  props: ClickableListProps<T>\n) {\n  return (\n    <ul ref={props.mRef}>\n      {props.items.map((item, i) => (\n        <li key={i}>\n          <button onClick={(el) => props.onSelect(item)}>Select</button>\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```", "```\nfunction ClickableListInner<T>(\n  props: ClickableListProps<T>,\n  ref: React.ForwardedRef<HTMLUListElement>\n) {\n  return (\n    <ul ref={ref}>\n      {props.items.map((item, i) => (\n        <li key={i}>\n          <button onClick={(el) => props.onSelect(item)}>Select</button>\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nconst ClickableListWithRef = forwardRef(ClickableListInner);\n\ntype ClickableListWithRefProps<T> = ClickableListProps<T> & {\n  mRef?: React.Ref<HTMLUListElement>;\n};\n\nexport function ClickableList<T>({\n  mRef,\n  ...props\n}: ClickableListWithRefProps<T>) {\n  return <ClickableListWithRef ref={mRef} {...props} />;\n}\n```", "```\n// Redecalare forwardRef\ndeclare module \"react\" {\n  function forwardRef<T, P = {}>(\n    render: (props: P, ref: React.Ref<T>) => React.ReactElement | null\n  ): (props: P & React.RefAttributes<T>) => React.ReactElement | null;\n}\n\n// Just write your components like you're used to!\n\ntype ClickableListProps<T> = {\n  items: T[];\n  onSelect: (item: T) => void;\n};\nfunction ClickableListInner<T>(\n  props: ClickableListProps<T>,\n  ref: React.ForwardedRef<HTMLUListElement>\n) {\n  return (\n    <ul ref={ref}>\n      {props.items.map((item, i) => (\n        <li key={i}>\n          <button onClick={(el) => props.onSelect(item)}>Select</button>\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nexport const ClickableList = React.forwardRef(ClickableListInner);\n```", "```\nimport React from \"react\";\n\nconst AppContext = React.createContext({\n  authenticated: true,\n  lang: \"en\",\n  theme: \"dark\",\n});\n```", "```\nfunction App() {\n  return (\n    <AppContext.Provider\n      value={{\n        authenticated: true,\n        lang: \"de\",\n        theme: \"light\",\n      }}\n    >\n      <Header />\n    </AppContext.Provider>\n  );\n}\n```", "```\nfunction App() {\n// Property 'theme' is missing in type '{ lang: string; }' but required\n// in type '{ lang: string; theme: string; authenticated: boolean }'.(2741)\n  return (\n    <AppContext.Provider\n      value={{\n        lang: \"de\",\n      }}\n    >\n      <Header />\n    </AppContext.Provider>\n  );\n}\n```", "```\nfunction Header() {\n  return (\n    <AppContext.Consumer>\n      {({ authenticated }) => {\n        if (authenticated) {\n          return <h1>Logged in!</h1>;\n        }\n        return <h1>You need to sign in</h1>;\n      }}\n    </AppContext.Consumer>\n  );\n}\n```", "```\nfunction Header() {\n  const { authenticated } = useContext(AppContext);\n  if (authenticated) {\n    return <h1>Logged in!</h1>;\n  }\n  return <h1>You need to sign in</h1>;\n}\n```", "```\ntype ContextProps = {\n  authenticated: boolean;\n  lang: string;\n  theme: string;\n};\n```", "```\nconst AppContext = React.createContext<Partial<ContextProps>>({});\n```", "```\nfunction App() {\n  return (\n    <AppContext.Provider\n      value={{\n        authenticated: true,\n      }}\n    >\n      <Header />\n    </AppContext.Provider>\n  );\n}\n```", "```\nfunction Header() {\n  const { authenticated, lang } = useContext(AppContext);\n  if (authenticated && lang) {\n    return <>\n      <h1>Logged in!</h1>\n      <p>Your language setting is set to {lang}</p>\n    </> ;\n  }\n  return <h1>You need to sign in (or don't you have a language setting?)</h1>;\n}\n```", "```\nfunction createContext<Props extends {}>() { ![1](assets/1.png)\n  const ctx = React.createContext<Props | undefined>(undefined); ![2](assets/2.png)\n  function useInnerCtx() { ![3](assets/3.png)\n    const c = useContext(ctx);\n    if (c === undefined) ![4](assets/4.png)\n      throw new Error(\"Context must be consumed within a Provider\");\n    return c; ![5](assets/5.png)\n  }\n  return [useInnerCtx, ctx.Provider as React.Provider<Props>] as const; ![6](assets/6.png)\n}\n```", "```\nconst [useAppContext, AppContextProvider] = createContext<ContextProps>();\n```", "```\nfunction App() {\n  return (\n    <AppContextProvider\n      value={{ lang: \"en\", theme: \"dark\", authenticated: true }}\n    >\n      <Header />\n    </AppContextProvider>\n  );\n}\n\nfunction Header() {\n  // consuming Context doesn't change much\n  const { authenticated } = useAppContext();\n  if (authenticated) {\n    return <h1>Logged in!</h1>;\n  }\n  return <h1>You need to sign in</h1>;\n}\n\n```", "```\ntype CardProps = {\n  title: string;\n  content: string;\n};\n\nfunction Card({ title, content }: CardProps) {\n  return (\n    <>\n      <h2>{title}</h2>\n      <div>{content}</div>\n    </>\n  );\n}\n```", "```\n<Card title=\"Info\" content=\"Your task has been processed\" />;\n```", "```\nconst Info = withInjectedProps({ title: \"Info\" }, Card);\n\n// This should work\n<Info content=\"Your task has been processed\" />;\n\n// This should throw an error\n<Info content=\"Your task has been processed\" title=\"Warning\" />;\n```", "```\nfunction withInjectedProps(injected, Component) {\n  return function (props) {\n    const newProps = { ...injected, ...props };\n    return <Component {...newProps} />;\n  };\n}\n```", "```\nfunction withInjectedProps<T extends {}, U extends T>( ![1](assets/1.png)\n  injected: T,\n  Component: React.ComponentType<U> ![2](assets/2.png)\n) {\n  return function (props: Omit<U, keyof T>) { ![3](assets/3.png)\n    const newProps = { ...injected, ...props } as U; ![4](assets/4.png)\n    return <Component {...newProps} />;\n  };\n}\n```", "```\nconst Info = withInjectedProps({ title: \"Info\" }, Card);\n\n<Info content=\"Your task has been processed\" />;\n<Info content=\"Your task has been processed\" title=\"Warning\" />;\n//                                           ^\n// Type '{ content: string; title: string; }' is not assignable\n// to type 'IntrinsicAttributes & Omit<CardProps, \"title\">'.\n// Property 'title' does not exist on type\n// 'IntrinsicAttributes & Omit<CardProps, \"title\">'.(2322)\n```", "```\nfunction withTitle<U extends { title: string }>(\n  title: string,\n  Component: React.ComponentType<U>\n) {\n  return withInjectedProps({ title }, Component);\n}\n```", "```\ntype WithChildren<T = {}> = T & { children?: React.ReactNode };\n\ntype ButtonProps = {\n  onClick: (event: MouseEvent) => void;\n} & WithChildren;\n\nfunction Button({ onClick, children }: ButtonProps) {\n  return <button onClick={onClick}>{children}</button>;\n//               ^\n// Type '(event: MouseEvent) => void' is not assignable to\n// type 'MouseEventHandler<HTMLButtonElement>'.\n// Types of parameters 'event' and 'event' are incompatible.\n// Type 'MouseEvent<HTMLButtonElement, MouseEvent>' is missing the following\n// properties from type 'MouseEvent': offsetX, offsetY, x, y,\n// and 14 more.(2322)\n}\n```", "```\nimport React from \"react\";\n\ntype WithChildren<T = {}> = T & { children?: React.ReactNode };\n\ntype ButtonProps = {\n  onClick: (event: React.MouseEvent) => void;\n} & WithChildren;\n\nfunction Button({ onClick, children }: ButtonProps) {\n  return <button onClick={onClick}>{children}</button>;\n}\n```", "```\nfunction handleClick(event: React.MouseEvent) {\n  console.log(event.nativeEvent.offsetX, event.nativeEvent.offsetY);\n}\n\nconst btn = <Button onClick={handleClick}>Hello</Button>};\n```", "```\ntype WithChildren<T = {}> = T & { children?: React.ReactNode };\n\n// Button maps to an HTMLButtonElement\ntype ButtonProps = {\n  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;\n} & WithChildren;\n\nfunction Button({ onClick, children }: ButtonProps) {\n  return <button onClick={onClick}>{children}</button>;\n}\n\n// handleClick accepts events from HTMLButtonElement or HTMLAnchorElement\nfunction handleClick(\n  event: React.MouseEvent<HTMLButtonElement | HTMLAnchorElement>\n) {\n  console.log(event.currentTarget.tagName);\n}\n\nlet button = <Button onClick={handleClick}>Works</Button>;\nlet link = <a href=\"/\" onClick={handleClick}>Works</a>;\n\nlet broken = <div onClick={handleClick}>Does not work</div>;\n//                ^\n// Type '(event: MouseEvent<HTMLButtonElement | HTMLAnchorElement,\n// MouseEvent>) => void' is not assignable to type\n//'MouseEventHandler<HTMLDivElement>'.\n// Types of parameters 'event' and 'event' are incompatible.\n// Type 'MouseEvent<HTMLDivElement, MouseEvent>' is not assignable to\n// type 'MouseEvent<HTMLButtonElement | HTMLAnchorElement, MouseEvent>'.\n// Type 'HTMLDivElement' is not assignable to type #\n// 'HTMLButtonElement | HTMLAnchorElement'.\n```", "```\nfunction onInput(event: React.SyntheticEvent) {\n  event.preventDefault();\n  // do something\n}\n\nconst inp = <input type=\"text\" onInput={onInput} />;\n```", "```\n<Cta as=\"a\" href=\"https://typescript-cookbook.com\">\n  Hey hey\n</Cta>\n\n<Cta as=\"button\" type=\"button\" onClick={(e) => { /* do something */ }}>\n  My my\n</Cta>\n```", "```\n// Type '{ children: string; as: \"button\"; type: \"button\"; href: string; }'\n// is not assignable to type 'IntrinsicAttributes & { as: \"button\"; } &\n// ClassAttributes<HTMLButtonElement> &\n// ButtonHTMLAttributes<HTMLButtonElement> & { ...; }'.\n// Property 'href' does not exist on type ... (2322)\n//                             v\n<Cta as=\"button\" type=\"button\" href=\"\" ref={(el) => el?.id}>\n  My my\n</Cta>\n```", "```\nfunction Cta({ as: Component, ...props }) {\n  return <Component {...props} />;\n}\n```", "```\ntype CtaElements = \"a\" | \"button\";\n\ntype CtaProps<T extends CtaElements> = {\n  as: T;\n} & JSX.IntrinsicElements[T];\n```", "```\nfunction Cta<T extends CtaElements>({\n  as: Component,\n  ...props\n}: CtaProps<T>) {\n  return <Component {...props} />;\n//        ^\n// Type 'Omit<CtaProps<T>, \"as\" | \"children\"> & { children: ReactNode; }'\n// is not assignable to type 'IntrinsicAttributes &\n// LibraryManagedAttributes<T, ClassAttributes<HTMLAnchorElement> &\n// AnchorHTMLAttributes<HTMLAnchorElement> & ClassAttributes<...> &\n// ButtonHTMLAttributes<...>>'.\n// Type 'Omit<CtaProps<T>, \"as\" | \"children\"> & { children: ReactNode; }' is not\n//  assignable to type\n//  'LibraryManagedAttributes<T, ClassAttributes<HTMLAnchorElement>\n//  & AnchorHTMLAttributes<HTMLAnchorElement> & ClassAttributes<...>\n//  & ButtonHTMLAttributes<...>>'.(2322)\n}\n```", "```\nexport interface Props {\n  name: string;\n}\n\nfunction Greet({ name }: Props) {\n  return <div>Hello {name.toUpperCase()}!</div>;\n}\n// Goes into LibraryManagedAttributes\nGreet.defaultProps = { name: \"world\" };\n\n// Type-checks! No type assertions needed!\nlet el = <Greet key={1} />;\n```", "```\nfunction Cta<T extends CtaElements>({\n  as: Component,\n  ...props\n}: CtaProps<T>) {\n  return <Component {...(props as any)} />;\n}\n```", "```\n<h1 className=\"headline\">Hello World</h1>\n\n// will be transformed to\nReact.createElement(\"h1\", { className: \"headline\" }, [\"Hello World\"]);\n```", "```\ntype WithChildren<T = {}> = T & { children?: React.ReactNode };\n```", "```\ntype CtaProps<T extends CtaElements> = WithChildren<{\n  as: T;\n} & JSX.IntrinsicElements[T]>;\n```", "```\ntype CtaProps<T extends CtaElements> = {\n  as: T;\n} & JSX.IntrinsicElements[T] & WithChildren;\n```", "```\nfunction Cta<T extends CtaElements>({\n  as: Component,\n  children,\n  ...props\n}: CtaProps<T>) {\n  return React.createElement(Component, props, children);\n}\n```"]