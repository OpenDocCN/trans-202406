- en: Appendix A. A Pod-Level Attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix is a hands-on exploration of attacks on the pod level, as we discussed
    in [Chapter 2](ch02.xhtml#ch-pod-level-resources).
  prefs: []
  type: TYPE_NORMAL
- en: '![captain](Images/haku_0000.png)'
  prefs: []
  type: TYPE_IMG
- en: Dread cyberpirate Captain Hashjack can now execute code inside a pod remotely
    and they will start to explore its configuration to see what else can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Like all good pirates, Captain Hashjack has a treasure map, but this is no ordinary
    map with a clearly defined destination. Instead, this map describes only the journey,
    with no guarantee of reaching a conclusion. It’s a cluster attack map, as shown
    in [Figure A-1](#pod-attack-map), and it is used to guide us through the rest
    of the appendix. And now, from inside the pod, it’s time to explore.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Securing any system is difficult. The best way to find vulnerabilities and misconfiguration
    is to methodically observe your environment, build up a library of your own attacks
    and patterns, and not give up!
  prefs: []
  type: TYPE_NORMAL
- en: '![Pod Attack map](Images/haku_aa01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-1\. Pod attack map
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Upon entering a new environment, a little basic checking may lead to useful
    discoveries. The first thing Hashjack does is check to see what kind of container
    they’re in. Checking `/proc/self/cgroup` often gives a clue, and here they can
    see they’re in Kubernetes from the clue `/kubepods/besteffort/pod8a6fa26b-...`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, they might check for capabilities with their process’s status entry in
    */proc/self/status*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel freely provides this information in order to help Linux applications,
    and an attacker in a container can use it to their advantage. Interesting entries
    can be grepped out (notice we’re root below):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The capabilities are not very readable, and need to be decoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `capsh --print` command to show capabilities (if it’s
    installed), `getpcaps` and `filecap` (for a single process or file, respectively),
    `pscap` (for all running processes), and `captest` (for the current process’s
    context):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A production container should never contain these debugging commands, instead
    only containing production applications and code. Using static, slim, or `distroless`
    containers reduces the attack surface of a container by limiting an attacker’s
    access to useful information. This is also why you should limit the availability
    of network-capable applications like `curl` and `wget` where possible, as well
    as any interpreters with network libraries that can be used to pull external tools
    into a running container.
  prefs: []
  type: TYPE_NORMAL
- en: You may prefer to run Jess Frazelle’s [amicontained](https://oreil.ly/j919l),
    which runs these checks quickly and also handily detects capability, seccomp,
    and LSM configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This command requires internet access, which is another privilege that production
    workloads should not be afforded unless required for production operation. Air-gapped
    (fully offline) clusters afford greater security from this type of attack at the
    cost of administrative overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `amicontained`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_pod_level_attack_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Export the sha256sum for verification.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_pod_level_attack_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Download and check the sha256sum.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_a_pod_level_attack_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We installed to a non-standard path to evade immutable filesystems, so we run
    a fully-qualified path
  prefs: []
  type: TYPE_NORMAL
- en: Jackpot! There’s a lot of information available about the security configuration
    of a container—from within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check our `cgroup` limits on the filesystem too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`free -m` uses host-level APIs available to all processes and has not been
    updated to run with `cgroups`. Check the system API to see the process’s actual
    `cgroup` limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Is this tremendously useful to an attacker? Not really. Exhausting the memory
    of a process and causing denial of service is a basic attack (although [fork bombs](https://oreil.ly/pd9zR)
    are elegantly scripted Bash poetry). Nevertheless, you should set `cgroups` to
    prevent DoS of applications in a container or pod (which support individual configuration).
    Cgroups are not a security boundary, and cgroups v1 can be escaped from a privileged
    pod, as nicely demonstrated in [Figure A-2](#tweet-fel1x-cgroup-container-escape).
  prefs: []
  type: TYPE_NORMAL
- en: '![haku aa02](Images/haku_aa02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure A-2\. Felix Wilhelm’s cleverly tweet-sized `cgroups v1` container breakout
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The more secure, and rootless-prerequisite, `cgroups v2` should be the default
    in most Linux installations [from 2022](https://oreil.ly/9lOZa).
  prefs: []
  type: TYPE_NORMAL
- en: Denial of service is more likely to be an application fault than an attack—serious
    DDoS (internet-based distributed denial of service) should be handled by networking
    equipment in front of the cluster for bandwidth and mitigation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In September of 2017 Google fought off a [2.54 Tbps DDoS](https://oreil.ly/zEUbp).
    This type of traffic is dropped by network router hardware at Ingress to prevent
    overwhelming internal systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes sets some useful environment variables into each container in a
    pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is easy for an application to read its configuration from environment variables,
    and the [12 Factor App](https://12factor.net) suggests that config and Secrets
    should be set in the environment. Environment variables are not a safe place to
    store Secrets as they can be read easily from the PID namespace by a process,
    user, or malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can see a process’s environment as root, or the same user. Check PID 1
    with a null-byte translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Even if no compromise takes place, many applications dump their environment
    when they crash, leaking Secrets to anyone who can access the logging system.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets should not be mounted as environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As well as being easy to collect from a parent process if an attacker has remote
    code execution, Kubernetes container environment variables are not updated after
    container creation: if the Secret is updated by the API server, the environment
    variable keeps the same value.'
  prefs: []
  type: TYPE_NORMAL
- en: The safer option is to use a well-known path, and mount a Secret `tmpfs` volume
    into the container, so an adversary has to guess or find the Secret file path,
    which is less likely to be automated by an attacker. Mounted Secrets are updated
    automatically, after a `kubelet` sync period and cache propagation delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a Secret mounted into the path */etc/foo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Mounting Secrets as files protects against information leakage and ensures adversaries
    like Captain Hashjack don’t stumble across production secrets when diving through
    stolen application logs.
  prefs: []
  type: TYPE_NORMAL
- en: tmpfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fastidious explorer leaves no sea uncharted, and to Captain Hashjack attacking
    the filesystem is no different. Checking for anything external added to the mount
    namespace is the first port of call, for which common tools like `mount` and `df`
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Every external device, filesystem, socket, or entity shared into a container
    increases a risk of container breakout through exploit or misconfiguration. Containers
    are at their most secure when they contain only the bare essentials for operation,
    and share nothing with each other or the underlying host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a search of the filesystem mount points for a common container
    filesystem driver, `overlayfs`. This may leak information about the type of container
    runtime that has configured the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the underlying container runtime is using a file path containing
    the name `containerd`, and the location of the container’s filesystem on the host
    disk is */var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/316/fs*.
    There are multiple layered directories listed, and these are combined into a single
    filesystem at runtime by `overlayfs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These paths are fingerprints of the container runtime’s default configuration,
    and `runc` leaks its identity in the same way, with a different filesystem layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `df` command to see if there are any Secrets mounted into the container.
    In this example no external entities are mounted into the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `tmpfs` is used for many different mounts, and some mounts are
    masking host filesystems in */proc* and `/sys`. The container runtime performs
    additional masking on the special files in those directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Potentially interesting mounts in a vulnerable container filesytem may contain
    host mounted Secrets and sockets, especially the infamous Docker socket, and Kubernetes
    service accounts that may have RBAC authorization to escalate privilege, or enable
    further attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest and most convenient of all container breakouts is the */var/run/docker.sock*
    mount points: the container runtime’s socket from the host, that gives access
    to the Docker daemon running on the host. If those new containers are privileged,
    they can be used to trivially “escape” the container namespace and access the
    underlying host as root, as we saw previously in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Other appealing targets include the Kubernetes service account tokens under
    */var/run/secrets/kubernetes.io/serviceaccount*, or writable host mounted directories
    like */etc/secret-volume*. Any of these could lead to a breakout, or assist a
    pivot.
  prefs: []
  type: TYPE_NORMAL
- en: Everything a `kubelet` mounts into its containers is visible to the root user
    on the `kubelet`’s host. We’ll see what the `serviceAccount` mounted at */run/secrets/kubernetes.io/serviceaccount*
    looks like later, and we investigated what to do with stolen `serviceAccount`
    credentials in [Chapter 8](ch08.xhtml#ch-policy).
  prefs: []
  type: TYPE_NORMAL
- en: 'From within a pod `kubectl` uses the credentials in */run/secrets/kubernetes.io/serviceaccount*
    by default. From the `kubelet` host these files are mounted under */var/lib/kubelet/pods/123e4567-e89b-12d3-a456-426614174000/volumes/kubernetes.io~secret/my-pod-token-7vzn2*,
    so load the following command into a Bash shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And run it against a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You’re now able to use the `system:serviceaccount:kube-system:priv-app` service
    account (SA) more easily with `kubectl` as it’s configured in your *~/.kube/config*.
    An attacker can do the same thing—hostile root access to Kubernetes nodes reveals
    all its Secrets!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: CSI storage interfaces and host filesystem mounts both pose a security risk
    if others have access to them. We explore external storage, the Container Storage
    Interface (CSI), and other mounts in greater detail in the [Chapter 6](ch06.xhtml#ch-storage).
  prefs: []
  type: TYPE_NORMAL
- en: What else is there mounted that might catch an adversary’s treasure-hungry gaze?
    Let’s explore further.
  prefs: []
  type: TYPE_NORMAL
- en: Host Mounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes `hostPath` volume type mounts a filesystem path from the host
    into the container, which may be useful for some applications. */var/log* is a
    popular mount point, so the host’s journal process collects container syslog events.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`HostPath` volumes should be avoided when possible as they present many risks.
    Best practice is to scope to only the needed file or directory using the `ReadOnly`
    mount flag.'
  prefs: []
  type: TYPE_NORMAL
- en: Other use cases for `hostPath` mounts include persistence for datastores in
    the pod or hosting static data, libraries, and caches.
  prefs: []
  type: TYPE_NORMAL
- en: Using host disks or permanently attaching storage to a node creates a coupling
    between workloads and the underlying node, as the workloads must be restarted
    on that node in order to function properly. This makes scaling and resilience
    much more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Host mounts can be dangerous if a symlink is created inside the container that
    is unintentionally resolved on the host filesystem. This happened in CVE-2017–1002101,
    where a bug in the symbolic link–handling code allowed an adversary inside a container
    to explore the host mounted filesystem that the mount point was on.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting of sockets from the host into the container is also a popular `hostMount`
    use case, which allows a client inside the container to run commands against a
    server on the host. This is an easy path to container breakout by starting a new
    privileged container on the host and escaping.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting sensitive directories or files from the host may also provide an opportunity
    to pivot if they can be used for network services.
  prefs: []
  type: TYPE_NORMAL
- en: '`hostPath` volumes are writeable on the host partition outside the container,
    and are always mounted on the host filesystem as owned by `root:root`. For this
    reason, a nonroot user should always be used inside the container, and filesystem
    permissions should always be configured on the host if write access is needed
    inside the container.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you are restricting `hostPath` access to specific directories with admission
    controllers, those `volumeMounts` must be `readOnly`, otherwise new symlinks can
    be used to traverse the host filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately data is the lifeblood of your business, and managing state is hard.
    An attacker will be looking to gather, exfiltrate, and cryptolock any data they
    can find in your systems. Consuming an external service (such as an object store
    or database hosted outside your cluster) to persist data is often the most resilient
    and scalable way to secure a system—however, for high-bandwidth or low-latency
    applications this may be impossible.
  prefs: []
  type: TYPE_NORMAL
- en: For everything else, cloud provider or internal service integrations remove
    the link between a workload and the underlying host, which makes scaling, upgrades,
    and system deployments much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Managed services and dedicated infrastructure clusters are an easier cluster
    security abstraction to reason about, and we talk more about them in [Chapter 7](ch07.xhtml#ch-hard-multi-tenancy).
  prefs: []
  type: TYPE_NORMAL
- en: Hostile Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hostile container is one that is under an attacker’s control. It may be created
    by an attacker with Kubernetes access (perhaps the `kubelet`, or API server),
    or a container image with automated exploit code embedded (for example, a “trojanized”
    image from [dockerscan](https://oreil.ly/2vvV0) that can start a reverse shell
    in a legitimate container to give attackers access to your production systems),
    or have been accessed by a remote adversary post-deployment.
  prefs: []
  type: TYPE_NORMAL
- en: What about the filesystem of a hostile container image? If Captain Hashjack
    can force Kubernetes to run a container they have built or corrupted, they may
    try to attack the orchestrator or container, runtimes, or clients (such as `kubectl`).
  prefs: []
  type: TYPE_NORMAL
- en: 'One attack ([CVE-2019-16884](https://oreil.ly/Hj4i3)) involves a container
    image that defines a `VOLUME` over a directory AppArmor uses for configuration,
    essentially disabling it at container runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This may be used as part of a further attack on the system, but as AppArmor
    is unlikely to be the only layer of defense, it is not as serious as it may appear.
  prefs: []
  type: TYPE_NORMAL
- en: Another dangerous container image is one used by a */proc/self/exe* breakout
    in [CVE-2019-5736](https://oreil.ly/1j7We). This exploit requires a container
    with a maliciously linked `ENTRYPOINT`, so can’t be run in a container that has
    already started.
  prefs: []
  type: TYPE_NORMAL
- en: As these attacks show, unless a container is built from trusted components,
    it should be considered untrusted to defend against further unknown attacks such
    as this.
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A collection of `kubectl cp` CVEs ([CVE-2018-1002100](https://oreil.ly/QdTZ9),
    [CVE-2019-11249](https://oreil.ly/wB13O)) require a malicious tar binary inside
    the container. The vulnerability stems from `kubectl` trusting the input it receives
    from the `scp` and `tar` process inside the container, which can be manipulated
    to overwrite files on the machine the `kubectl` binary is being run on.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The danger of the */proc/self/exe* breakout in [CVE-2019-5736](https://oreil.ly/yRLNz)
    is that a hostile container process can overwrite the `runc` binary on the host.
    That `runc` binary is owned by root, but as it is also executed by root on the
    host (as most container runtimes need some root capabilities), it can be overwritten
    from inside the container in this attack. This is because the container process
    is a child of `runc`, and this exploit uses the permission `runc` has to overwrite
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Protecting the host from privileged container processes is best achieved by
    removing root privileges from the container runtime. Both `runc` and Podman can
    run in rootless mode, which we explore in [Chapter 3](ch03.xhtml#ch-container-runtime-isolation).
  prefs: []
  type: TYPE_NORMAL
- en: The root user has many special privileges as a result of years of kernel development
    that assumed only one “root” user. To limit the impact of RCE to the container,
    pod, and host, applications inside a container should not be run as root, and
    their capabilities should be dropped, without the ability to gain privileges by
    setting the `allowPrivilegeEscalation` `securityContext` field to `false` (which
    sets the `no_new_privs` flag on the container process).
  prefs: []
  type: TYPE_NORMAL
