<html><head></head><body><section data-pdf-bookmark="Chapter 8. Helper Types" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch08">&#13;
<h1><span class="label">Chapter 8. </span>Helper Types</h1>&#13;
&#13;
&#13;
<p><a data-primary="helper types" data-type="indexterm" id="id764"/>One of TypeScript’s strengths is the ability to derive types from other types. This allows you to define relationships between types, where updates in one type trickle through to all derived types automatically. This reduces maintenance and ultimately results in more robust type setups.</p>&#13;
&#13;
<p>When creating derived types, we usually apply the same type modifications but in different combinations. TypeScript already has a set of <a href="https://oreil.ly/inM2y">built-in utility types</a>, some of which we’ve already seen in this book. But sometimes they are not enough. Some situations require you either to apply known techniques differently or to dig deep into the inner workings of the type system to produce the desired result. You might need your own set of helper types.</p>&#13;
&#13;
<p>This chapter introduces you to the concept of helper types and shows you some use cases where a custom helper type expands your ability to derive types from others tremendously. Each type is designed to work in different situations, and each type should teach you a new aspect of the type system. Of course, the list of types you see here is by no means complete, but they give you a good entry point and enough resources to branch out.</p>&#13;
&#13;
<p>In the end, TypeScript’s type system can be seen as its own functional meta-programming language, where you combine small, single-purpose helper types with bigger helper types to make type derivates as easy as applying a single type to your existing models.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.1 Setting Specific Properties Optional" data-type="sect1"><div class="sect1" id="ch08_one_optional">&#13;
<h1>8.1 Setting Specific Properties Optional</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id226">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="helper types" data-secondary="setting specific properties optional" data-type="indexterm" id="ix_08-01-asciidoc0"/>You want to derive types where you set specific properties optional.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id118">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="SetOptional (custom helper type)" data-type="indexterm" id="ix_08-01-asciidoc1"/>Create a custom helper type <code>SetOptional</code> that intersects two object types: one that maps over all selected properties using the optional mapped type modifier and one that maps over all remaining properties.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id119">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>All your models in your TypeScript project are set and defined, and you want to refer to them throughout your code:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">profession</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>One situation that occurs pretty often is that you need something that looks like &#13;
<span class="keep-together"><code>Person</code></span> but does not require all properties to be set; some of them can be <em>optional</em>. This will make your API more open to other structures and types that are of similar shape but lack one or two fields. You don’t want to maintain different types (see <a data-type="xref" href="ch12.html#ch12_low_maintenance_types">Recipe 12.1</a>) but rather derive them from the original model, which is still in use.</p>&#13;
&#13;
<p>TypeScript has a built-in helper type called <code>Partial&lt;T&gt;</code> that modifies all properties to be optional:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code> <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">?:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">];</code> <code class="p">};</code></pre>&#13;
&#13;
<p>It’s a <em>mapped type</em> that maps out over all keys and uses the <em>optional mapped type modifier</em> to set each property to optional. The first step in making a <code>SetOptional</code> type is to reduce the set of keys that can be set as optional:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SelectPartial</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">?:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">]</code>&#13;
<code class="p">};</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <em>optional mapped type modifier</em> applies the symbol for an optional property—the question mark—to a set of properties. You learned about mapped type modifiers in <a data-type="xref" href="ch04.html#ch04_new_object_types">Recipe 4.5</a>.</p>&#13;
</div>&#13;
&#13;
<p>In <code>SelectPartial&lt;T, K extends keyof T&gt;</code>, we don’t map over all keys, just a subset of keys provided. With the <code>extends keyof T</code> generic constraint, we make sure that we pass only valid property keys. If we apply <code>SelectPartial</code> to <code>Person</code> to select <code>"age"</code>, we end up with a type where we see <em>only</em> the <code>age</code> property, which is set &#13;
<span class="keep-together">to optional:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Age</code> <code class="o">=</code> <code class="nx">SelectPartial</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="s2">"age"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// type Age = { age?: number | undefined };</code></pre>&#13;
&#13;
<p>The first half is done: everything we want to set as optional is optional. But the rest of the properties are missing. Let’s get them back to the object type.</p>&#13;
&#13;
<p>The easiest way of extending an existing object type with more properties is to create an intersection type with another object type. So in our case, we take what we’ve written in <code>SelectPartial</code> and intersect it with a type that includes all remaining keys.</p>&#13;
&#13;
<p>We can get all remaining keys by using the <code>Exclude</code> helper type. <code>Exclude&lt;T, U&gt;</code> is a <em>conditional type</em> that compares two sets. If elements from set <code>T</code> are in <code>U</code>, they will be removed using <code>never</code>; otherwise, they stay in the type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">U</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">U</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code> <code class="nx">T</code><code class="p">;</code></pre>&#13;
&#13;
<p>This works in contrast to <code>Extract&lt;T, U&gt;</code> which we described in <a data-type="xref" href="ch05.html#ch05_grouping_elements">Recipe 5.3</a>. <code>Exclude&lt;T, U&gt;</code> is a <em>distributive conditional type</em> (see <a data-type="xref" href="ch05.html#ch05_filtering_never">Recipe 5.2</a>) and distributes the conditional type over every element of a union:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// This example shows how TypeScript evaluates a</code>&#13;
<code class="c1">// helper type step by step.</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ExcludeAge</code> <code class="o">=</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="s2">"name"</code> <code class="o">|</code> <code class="s2">"age"</code><code class="p">,</code> <code class="s2">"age"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// 1. Distribute</code>&#13;
<code class="kr">type</code> <code class="nx">ExcludeAge</code> <code class="o">=</code>&#13;
  <code class="s2">"name"</code> <code class="kr">extends</code> <code class="s2">"age"</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code> <code class="s2">"name"</code> <code class="o">|</code>&#13;
  <code class="s2">"age"</code> <code class="kr">extends</code> <code class="s2">"age"</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code> <code class="s2">"age"</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// 2. Evaluate</code>&#13;
<code class="kr">type</code> <code class="nx">ExcludeAge</code> <code class="o">=</code> <code class="s2">"name"</code> <code class="o">|</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// 3. Remove unnecessary `never`</code>&#13;
<code class="kr">type</code> <code class="nx">ExcludeAge</code> <code class="o">=</code> <code class="s2">"name"</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is exactly what we want! In <code>SetOptional</code>, we create one type that <em>picks</em> all selected keys and makes them optional, then we <em>exclude</em> the same keys from the bigger set of all of the object’s keys:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SetOptional</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">?:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">];</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code>&#13;
  <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">];</code>&#13;
  <code class="p">};</code></pre>&#13;
&#13;
<p>The intersection of both types is the new object type, which we can use with any model we like:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">OptionalAge</code> <code class="o">=</code> <code class="nx">SetOptional</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="s2">"age"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="cm">/*</code>&#13;
<code class="cm">type OptionalAge = {</code>&#13;
<code class="cm">  name: string;</code>&#13;
<code class="cm">  age?: number | undefined;</code>&#13;
<code class="cm">  profession: string;</code>&#13;
<code class="cm">};</code>&#13;
<code class="cm">*/</code></pre>&#13;
&#13;
<p>If we want to make more than one key optional, we need to provide a union type with all desired property keys:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">OptionalAgeAndProf</code> <code class="o">=</code> <code class="nx">SetOptional</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="s2">"age"</code> <code class="o">|</code> <code class="s2">"profession"</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>TypeScript not only allows you to define types like this yourself but also has a set of built-in helper types that you can easily combine for similar effect. We could write the same type <code>SetOptional</code> solely based on helper types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SetOptional</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code> <code class="o">&amp;</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>Pick&lt;T, K&gt;</code> selects keys <code>K</code> from object <code>T</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Omit&lt;T, K&gt;</code> selects everything but <code>K</code> from object <code>T</code> (using <code>Exclude</code> under the hood).</p>&#13;
</li>&#13;
<li>&#13;
<p>And we already learned what <code>Partial&lt;T&gt;</code> does.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Depending on how you like to read types, this combination of helper types can be easier to read and understand, especially since the built-in types are much better known among developers.</p>&#13;
&#13;
<p>There is only one problem: if you hover over your newly generated types, TypeScript will show you how the type is made, not what the actual properties are. With the <code>Remap</code> helper type from <a data-type="xref" href="#ch08_remapping">Recipe 8.3</a>, we can make our types more readable and usable:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SetOptional</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Remap</code><code class="o">&lt;</code>&#13;
  <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code> <code class="o">&amp;</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code>&#13;
<code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>If you think about your type arguments as a function interface, you might want to think about your type parameters as well. One optimization you could do is to set the second argument—the selected object keys—to a default value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SetOptional</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Remap</code><code class="o">&lt;</code>&#13;
  <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code> <code class="o">&amp;</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code>&#13;
<code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>With <code>K extends keyof T = keyof T</code>, we can make sure that we set all property keys as optional, and only select specific ones if we need them. Our helper type just became a little bit more flexible.<a data-startref="ix_08-01-asciidoc1" data-type="indexterm" id="id765"/></p>&#13;
&#13;
<p>In the same vein, you can start creating types for other situations, like <code>SetRequired</code>, where you want to make sure that some keys are definitely required:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SetRequired</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Remap</code><code class="o">&lt;</code>&#13;
  <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code> <code class="o">&amp;</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code>&#13;
<code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Or <code>OnlyRequired</code>, where all keys you provide are required, but the rest are optional:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">OnlyRequired</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Remap</code><code class="o">&lt;</code>&#13;
  <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code> <code class="o">&amp;</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code>&#13;
<code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>The best thing: you end up with an arsenal of helper types that can be used throughout multiple projects.<a data-startref="ix_08-01-asciidoc0" data-type="indexterm" id="id766"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.2 Modifying Nested Objects" data-type="sect1"><div class="sect1" id="ch08_nested_objects">&#13;
<h1>8.2 Modifying Nested Objects</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id120">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="helper types" data-secondary="modifying nested objects" data-type="indexterm" id="ix_08-02-asciidoc0"/><a data-primary="nested objects, modifying" data-type="indexterm" id="ix_08-02-asciidoc1"/><a data-primary="recursive helper types" data-type="indexterm" id="ix_08-02-asciidoc2"/>Object helper types like <code>Partial</code>, <code>Required</code>, and <code>Readonly</code> modify only the first level of an object and won’t touch nested object properties.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id767">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create recursive helper types that do the same operation on nested objects.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id121">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Say that your application has different settings that can be configured by users. To make it easy for you to extend settings over time, you store only the difference between a set of defaults and the settings your user configured:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Settings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">mode</code><code class="o">:</code> <code class="s2">"light"</code> <code class="o">|</code> <code class="s2">"dark"</code><code class="p">;</code>&#13;
  <code class="nx">playbackSpeed</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">subtitles</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">active</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
    <code class="nx">color</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">defaults</code><code class="o">:</code> <code class="nx">Settings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">mode</code><code class="o">:</code> <code class="s2">"dark"</code><code class="p">,</code>&#13;
  <code class="nx">playbackSpeed</code><code class="o">:</code> <code class="mf">1.0</code><code class="p">,</code>&#13;
  <code class="nx">subtitles</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">active</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
    <code class="nx">color</code><code class="o">:</code> <code class="s2">"white"</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>The function <code>applySettings</code> takes both the defaults and the settings from your users. You defined them as <code>Partial&lt;Settings&gt;</code>, since the user needs to provide only <em>some</em> keys; the rest will be taken from the default settings:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">applySettings</code><code class="p">(</code>&#13;
  <code class="nx">defaultSettings</code><code class="o">:</code> <code class="nx">Settings</code><code class="p">,</code>&#13;
  <code class="nx">userSettings</code><code class="o">:</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Settings</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">Settings</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="p">...</code><code class="nx">defaultSettings</code><code class="p">,</code> <code class="p">...</code><code class="nx">userSettings</code> <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This works really well if you need to set certain properties on the first level:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">settings</code> <code class="o">=</code> <code class="nx">applySettings</code><code class="p">(</code><code class="nx">defaults</code><code class="p">,</code> <code class="p">{</code> <code class="nx">mode</code><code class="o">:</code> <code class="s2">"light"</code> <code class="p">});</code></pre>&#13;
&#13;
<p>But this causes problems if you want to modify specific properties deeper down in your object, like setting <code>subtitles</code> to <code>active</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">settings</code> <code class="o">=</code> <code class="nx">applySettings</code><code class="p">(</code><code class="nx">defaults</code><code class="p">,</code> <code class="p">{</code> <code class="nx">subtitles</code><code class="o">:</code> <code class="p">{</code> <code class="nx">active</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code> <code class="p">});</code>&#13;
<code class="c1">//                        ^</code>&#13;
<code class="c1">// Property 'color' is missing in type '{ active: true; }'</code>&#13;
<code class="c1">// but required in type '{ active: boolean; color: string; }'.(2741)</code></pre>&#13;
&#13;
<p>TypeScript complains that for <code>subtitles</code> you need to provide the entire object. This is because <code>Partial&lt;T&gt;</code>—like its siblings <code>Required&lt;T&gt;</code> and <code>Readonly&lt;T&gt;</code>—modifies only the first level of an object. Nested objects will be treated as simple values.</p>&#13;
&#13;
<p><a data-primary="DeepPartial&lt;T&gt; type" data-type="indexterm" id="ix_08-02-asciidoc3"/>To change this, we need to create a new type called <code>DeepPartial&lt;T&gt;</code>, which recursively goes through every property and applies the <em>optional mapped type modifier</em> for each level:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">DeepPartial</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">?:</code> <code class="nx">DeepPartial</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>The first draft already works well, thanks to TypeScript stopping recursion at primitive values, but it has the potential to result in unreadable output. A simple condition that checks that we go deep only if we are dealing with an object makes our type much more robust and the result more readable:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">DeepPartial</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">object</code>&#13;
  <code class="o">?</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">?:</code> <code class="nx">DeepPartial</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">:</code> <code class="nx">T</code><code class="p">;</code></pre>&#13;
&#13;
<p>For example, <code>DeepPartial&lt;Settings&gt;</code> results in the following output:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">DeepPartialSettings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">mode</code><code class="o">?:</code> <code class="s2">"light"</code> <code class="o">|</code> <code class="s2">"dark"</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">playbackSpeed</code><code class="o">?:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">subtitles</code><code class="o">?:</code> <code class="p">{</code>&#13;
    <code class="nx">active</code><code class="o">?:</code> <code class="kr">boolean</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
    <code class="nx">color</code><code class="o">?:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This is exactly what we’ve been aiming for. If we use <code>DeepPartial&lt;T&gt;</code> in <code>ap⁠ply​Set⁠tin⁠gs</code>, we see that the actual usage of <code>applySettings</code> works, but TypeScript greets us with another error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">applySettings</code><code class="p">(</code>&#13;
  <code class="nx">defaultSettings</code><code class="o">:</code> <code class="nx">Settings</code><code class="p">,</code>&#13;
  <code class="nx">userSettings</code><code class="o">:</code> <code class="nx">DeepPartial</code><code class="o">&lt;</code><code class="nx">Settings</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">Settings</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="p">...</code><code class="nx">defaultSettings</code><code class="p">,</code> <code class="p">...</code><code class="nx">userSettings</code> <code class="p">};</code>&#13;
<code class="c1">//       ^</code>&#13;
<code class="c1">// Type '{ mode: "light" | "dark"; playbackSpeed: number;</code>&#13;
<code class="c1">//   subtitles: { active?: boolean | undefined;</code>&#13;
<code class="c1">//   color?: string | undefined; }; }' is not assignable to type 'Settings'.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, TypeScript complains that it can’t merge the two objects into something that results in <code>Settings</code>, as some of the <code>DeepPartial</code> set elements might not be assignable to <code>Settings</code>. And this is true! Object merge using destructuring also works only on the first level, just like <code>Partial&lt;T&gt;</code> has defined for us. This means that if we called <code>applySettings</code> like before, we would get a totally different type than for <code>settings</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">settings</code> <code class="o">=</code> <code class="nx">applySettings</code><code class="p">(</code><code class="nx">defaults</code><code class="p">,</code> <code class="p">{</code> <code class="nx">subtitles</code><code class="o">:</code> <code class="p">{</code> <code class="nx">active</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code> <code class="p">});</code>&#13;
&#13;
<code class="c1">// results in</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">settings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">mode</code><code class="o">:</code> <code class="s2">"dark"</code><code class="p">,</code>&#13;
  <code class="nx">playbackSpeed</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
  <code class="nx">subtitles</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">active</code><code class="o">:</code> <code class="kc">true</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p><code>color</code> is all gone! This is one situation where TypeScript’s type might be unintuitive at first: why do object modification types go only one level deep? Because JavaScript goes only one level deep! But ultimately, they point out bugs you wouldn’t have caught otherwise.</p>&#13;
&#13;
<p>To circumvent this situation, you need to apply your settings recursively. This can be nasty to implement yourself, so we resort to <code>lodash</code> and its <code>merge</code> function for &#13;
<span class="keep-together">this functionality:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">merge</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"lodash"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">applySettings</code><code class="p">(</code>&#13;
  <code class="nx">defaultSettings</code><code class="o">:</code> <code class="nx">Settings</code><code class="p">,</code>&#13;
  <code class="nx">userSettings</code><code class="o">:</code> <code class="nx">DeepPartial</code><code class="o">&lt;</code><code class="nx">Settings</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">Settings</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">merge</code><code class="p">(</code><code class="nx">defaultSettings</code><code class="p">,</code> <code class="nx">userSettings</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>merge</code> defines its interface to produce an intersection of two objects:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">merge</code><code class="o">&lt;</code><code class="nx">TObject</code><code class="p">,</code> <code class="nx">TSource</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">object</code><code class="o">:</code> <code class="nx">TObject</code><code class="p">,</code> <code class="nx">source</code><code class="o">:</code> <code class="nx">TSource</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">TObject</code> <code class="o">&amp;</code> <code class="nx">TSource</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Again, exactly what we are looking for. An intersection of <code>Settings</code> and <code>De⁠ep​Par⁠tia⁠l&lt;Set⁠tin⁠gs&gt;</code> also produces an intersection of both, which is—due to the nature of the types—<code>Settings</code> again.<a data-startref="ix_08-02-asciidoc3" data-type="indexterm" id="id768"/></p>&#13;
&#13;
<p>So we end up with expressive types that tell us exactly what to expect, correct results for the output, and another helper type for our arsenal. You can create <code>DeepReadonly</code> and <code>DeepRequired</code> similarly.<a data-startref="ix_08-02-asciidoc2" data-type="indexterm" id="id769"/><a data-startref="ix_08-02-asciidoc1" data-type="indexterm" id="id770"/><a data-startref="ix_08-02-asciidoc0" data-type="indexterm" id="id771"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.3 Remapping Types" data-type="sect1"><div class="sect1" id="ch08_remapping">&#13;
<h1>8.3 Remapping Types</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id122">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="DeepRemap&lt;T&gt; helper type" data-type="indexterm" id="ix_08-03-asciidoc0"/><a data-primary="editor hints" data-type="indexterm" id="ix_08-03-asciidoc1"/><a data-primary="helper types" data-secondary="remapping" data-type="indexterm" id="ix_08-03-asciidoc2"/><a data-primary="Remap&lt;T&gt; helper type" data-type="indexterm" id="ix_08-03-asciidoc3"/>Constructing types gives you flexible, self-maintaining types, but the editor hints leave a lot to be desired.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id772">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>Remap&lt;T&gt;</code> and <code>DeepRemap&lt;T&gt;</code> helper types to improve editor hints.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id123">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>When you use TypeScript’s type system to construct new types, by using helper types, complex conditional types, or even simple intersections, you might end up with editor hints that are hard to decipher.</p>&#13;
&#13;
<p>Let’s look at <code>OnlyRequired</code> from <a data-type="xref" href="#ch08_one_optional">Recipe 8.1</a>. The type uses four helper types and one intersection to construct a new type in which all keys provided as the second type parameter are set to required, while all others are set to optional:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">OnlyRequired</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code> <code class="o">&amp;</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>This way of writing types gives you a good idea of what’s happening. You can read the functionality based on how helper types are composed with one another. However, when you are actually using the types on your models, you might want to know more than the actual construction of the type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">profession</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">NameRequired</code> <code class="o">=</code> <code class="nx">OnlyRequired</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="s2">"name"</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>If you hover over <code>NameRequired</code>, you see that TypeScript gives you information on how the type was constructed based on the parameters you provide, but the editor hint won’t show you the result, the final type being constructed with those helper types. You can see the editor’s feedback in <a data-type="xref" href="#img-remap">Figure 8-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-remap">&#13;
<img alt="tscb 0801" src="assets/tscb_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>Editor hints on complex types expand very shallowly; without knowing the types underneath and their functionality, it becomes hard to understand the result</h6>&#13;
</div></figure>&#13;
&#13;
<p>To make the final result look like an actual type and to spell out all the properties, we have to use a simple yet effective type called <code>Remap</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Remap</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p><code>Remap&lt;T&gt;</code> is just an object type that goes through every property and maps it to the value defined. No modifications, no filters, just putting out what’s being put in. TypeScript will print out every property of mapped types, so instead of seeing the construction, you see the actual type, as shown in <a data-type="xref" href="#img-remap2">Figure 8-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-remap2">&#13;
<img alt="tscb 0802" src="assets/tscb_0802.png"/>&#13;
<h6><span class="label">Figure 8-2. </span>With <code>Remap&lt;T&gt;</code>, the presentation of <code>NameRequired</code> becomes much &#13;
<span class="keep-together">more readable</span></h6>&#13;
</div></figure>&#13;
&#13;
<p>Beautiful! This has become a staple in TypeScript utility type libraries. Some call it <code>Debug</code>; others call it <code>Simplify</code>. <code>Remap</code> is just another name for the same tool and the same effect: getting an idea of what your result will look like.</p>&#13;
&#13;
<p>Like other mapped types <code>Partial&lt;T&gt;</code>, <code>Readonly&lt;T&gt;</code>, and <code>Required&lt;T&gt;</code>, <code>Remap&lt;T&gt;</code> also works on the first level only. A nested type like <code>Settings</code> that includes the <code>Subtitles</code> type will be remapped to the same output, and the editor feedback will be the same:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Subtitles</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">active</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
  <code class="nx">color</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Settings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">mode</code><code class="o">:</code> <code class="s2">"light"</code> <code class="o">|</code> <code class="s2">"dark"</code><code class="p">;</code>&#13;
  <code class="nx">playbackSpeed</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">subtitles</code><code class="o">:</code> <code class="nx">Subtitles</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>But also, as shown in <a data-type="xref" href="#ch08_nested_objects">Recipe 8.2</a>, we can create a recursive variation that remaps <em>all</em> nested object types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">DeepRemap</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">object</code>&#13;
  <code class="o">?</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="nx">DeepRemap</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">:</code> <code class="nx">T</code><code class="p">;</code></pre>&#13;
&#13;
<p>Applying <code>DeepRemap&lt;T&gt;</code> to <code>Settings</code> will also expand <code>Subtitles</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SettingsRemapped</code> <code class="o">=</code> <code class="nx">DeepRemap</code><code class="o">&lt;</code><code class="nx">Settings</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// results in</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">SettingsRemapped</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">mode</code><code class="o">:</code> <code class="s2">"light"</code> <code class="o">|</code> <code class="s2">"dark"</code><code class="p">;</code>&#13;
    <code class="nx">playbackSpeed</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
    <code class="nx">subtitles</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">active</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
        <code class="nx">color</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="p">};</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Using <code>Remap</code> is mostly a matter of taste. Sometimes you want to know about the implementation, and sometimes the terse view of nested types is more readable than the expanded versions. But in other scenarios, you actually care about the result itself. In those cases, having a <code>Remap&lt;T&gt;</code> helper type handy and available is &#13;
<span class="keep-together">definitely helpful</span>.<a data-startref="ix_08-03-asciidoc3" data-type="indexterm" id="id773"/><a data-startref="ix_08-03-asciidoc2" data-type="indexterm" id="id774"/><a data-startref="ix_08-03-asciidoc1" data-type="indexterm" id="id775"/><a data-startref="ix_08-03-asciidoc0" data-type="indexterm" id="id776"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.4 Getting All Required Keys" data-type="sect1"><div class="sect1" id="ch08_all_required">&#13;
<h1>8.4 Getting All Required Keys</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id124">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="GetRequired&lt;T&gt;" data-type="indexterm" id="ix_08-04-asciidoc0"/><a data-primary="helper types" data-secondary="getting all required keys" data-type="indexterm" id="ix_08-04-asciidoc1"/><a data-primary="required properties, getting keys for" data-type="indexterm" id="ix_08-04-asciidoc2"/>You want to create a type that extracts all <em>required</em> properties from an object.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id777">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a mapped helper type <code>GetRequired&lt;T&gt;</code> that filters keys based on a subtype check against its required counterpart.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id125">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Optional properties have a tremendous effect on type compatibility. A simple type modifier, the question mark, widens the original type significantly. They allow us to define fields that might be there, but they can be used only if we do additional checks.</p>&#13;
&#13;
<p>This means we can make our functions and interfaces compatible with types that lack certain properties entirely:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">?:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
&#13;
<code class="kr">type</code> <code class="nx">Student</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">semester</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">student</code><code class="o">:</code> <code class="nx">Student</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">semester</code><code class="o">:</code> <code class="mi">37</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="nx">student</code><code class="p">);</code> <code class="c1">// all good!</code></pre>&#13;
&#13;
<p>We see that <code>age</code> is defined in <code>Person</code> but not at all defined in <code>Student</code>. Since it’s optional, it doesn’t keep us from using <code>printPerson</code> with objects of type <code>Student</code>. The set of compatible values is wider, as we can use objects of types that drop <code>age</code> entirely.</p>&#13;
&#13;
<p>TypeScript solves that by attaching <code>undefined</code> to properties that are optional. This is the truest representation of “it might be there.”</p>&#13;
&#13;
<p>This fact is important if we want to check if property keys are required or not. Let’s start by doing the most basic check. We have an object and want to check if all keys are required. We use the helper type <code>Required&lt;T&gt;</code>, which modifies all properties to be required. The simplest check is to see if an object type—for example, <code>Name</code>—is a subset of its <code>Required&lt;T&gt;</code> counterpart:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Name</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Test</code> <code class="o">=</code> <code class="nx">Name</code> <code class="kr">extends</code> <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Name</code><code class="o">&gt;</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code>&#13;
<code class="c1">// type Test = true</code></pre>&#13;
&#13;
<p>Here, <code>Test</code> results in <code>true</code>, because if we change all properties to <code>required</code> using <code>Required&lt;T&gt;</code>, we still get the same type. However, things change if we introduce an optional property:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">?:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Test</code> <code class="o">=</code> <code class="nx">Person</code> <code class="kr">extends</code> <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Person</code><code class="o">&gt;</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code>&#13;
<code class="c1">// type Test = false</code></pre>&#13;
&#13;
<p>Here, <code>Test</code> results in <code>false</code>, because type <code>Person</code> with the optional property <code>age</code> accepts a much broader set of values than <code>Required&lt;Person&gt;</code>, where <code>age</code> needs to be set. Contrary to this check, if we swap <code>Person</code> and <code>Required&lt;Person&gt;</code>, we can see that the narrower type <code>Required&lt;Person&gt;</code> is in fact a subset of <code>Person</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Test</code> <code class="o">=</code> <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Person</code><code class="o">&gt;</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code>&#13;
<code class="c1">// type Test = true</code></pre>&#13;
&#13;
<p>What we’ve checked so far is if the entire object has the required keys. But what we actually want is to get an object that includes only property keys that are set to required. This means we need to do this check with each property key. The need to iterate the same check over a set of keys is a good indicator for a mapped type.</p>&#13;
&#13;
<p>Our next step is to create a mapped type that does the subset check for each property, to see if the resulting values include <code>undefined</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">RequiredPerson</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">Person</code><code class="p">]</code><code class="o">: </code><code class="kr">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="cm">/*</code>&#13;
<code class="cm">type RequiredPerson = {</code>&#13;
<code class="cm">    name: true;</code>&#13;
<code class="cm">    age?: true | undefined;</code>&#13;
<code class="cm">}</code>&#13;
<code class="cm">*/</code></pre>&#13;
&#13;
<p>This is a good guess but gives us results that don’t work. Each property resolves to <code>true</code>, meaning that the subset checks only for the value types <em>without</em> &#13;
<span class="keep-together"><code>undefined</code>.</span> This is because <code>Required&lt;T&gt;</code> works on objects, not on primitive types. Something that gets us more robust results is checking if <code>Person[K]</code> includes any <em>nullable</em> values. <code>NonNullable&lt;T&gt;</code> removes <code>undefined</code> and <code>null</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">RequiredPerson</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">Person</code><code class="p">]</code><code class="o">: </code><code class="kr">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="nx">NonNullable</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code> <code class="o">?</code> <code class="kc">true</code> <code class="o">:</code> <code class="kc">false</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="cm">/*</code>&#13;
<code class="cm">type RequiredPerson = {</code>&#13;
<code class="cm">    name: true;</code>&#13;
<code class="cm">    age?: false | undefined;</code>&#13;
<code class="cm">}</code>&#13;
<code class="cm">*/</code></pre>&#13;
&#13;
<p>That’s better, but still not where we want it to be. <code>undefined</code> is back again, as it’s being added by the property modifier. Also, the property is still in the type, and we want to get rid of it.</p>&#13;
&#13;
<p>What we need to do is reduce the set of possible keys. So instead of checking for the values, we do a conditional check on each property while we are mapping out keys. We check if <code>Person[K]</code> is a subset of <code>Required&lt;Person&gt;[K]</code>, doing a proper check against the bigger subset. If this is the case, we print out the key <code>K</code>; otherwise, we drop the property using <code>never</code> (see <a data-type="xref" href="ch05.html#ch05_filtering_never">Recipe 5.2</a>):</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">RequiredPerson</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">Person</code> <code class="kr">as</code> <code class="nx">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Person</code><code class="o">&gt;</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code>&#13;
    <code class="o">?</code> <code class="nx">K</code>&#13;
    <code class="o">:</code> <code class="kr">never</code><code class="p">]</code><code class="o">: </code><code class="kr">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This gives us the results we want. Now we substitute <code>Person</code> for a generic type parameter and our helper type <code>GetRequired&lt;T&gt;</code> is done:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">GetRequired</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code> <code class="kr">as</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code>&#13;
    <code class="o">?</code> <code class="nx">K</code>&#13;
    <code class="o">:</code> <code class="kr">never</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>From here on, we can derive variations like <code>GetOptional&lt;T&gt;</code>. However, checking if something is optional is not as easy as checking if some property keys are required, but we can use <code>GetRequired&lt;T&gt;</code> and a <code>keyof</code> operator to get all the required property keys:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">RequiredKeys</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">GetRequired</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p class="pagebreak-before">After that, we use the <code>RequiredKeys&lt;T&gt;</code> to <em>omit</em> them from our target object:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">GetOptional</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">RequiredKeys</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Again, a combination of multiple helper types produces derived, self-maintaining types.<a data-startref="ix_08-04-asciidoc2" data-type="indexterm" id="id778"/><a data-startref="ix_08-04-asciidoc1" data-type="indexterm" id="id779"/><a data-startref="ix_08-04-asciidoc0" data-type="indexterm" id="id780"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.5 Allowing at Least One Property" data-type="sect1"><div class="sect1" id="ch08_splitting_types">&#13;
<h1>8.5 Allowing at Least One Property</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id126">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="helper types" data-secondary="allowing at least one property" data-type="indexterm" id="ix_08-05-asciidoc0"/><a data-primary="one-property objects" data-type="indexterm" id="ix_08-05-asciidoc1"/><a data-primary="Split&lt;T&gt; helper type" data-type="indexterm" id="ix_08-05-asciidoc2"/><a data-primary="union types" data-secondary="Split&lt;T&gt; helper type and" data-type="indexterm" id="ix_08-05-asciidoc3"/>You have a type for which you want to make sure that at least one property is set.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id781">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a <code>Split&lt;T&gt;</code> helper type that splits an object into a union of one-property objects.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id127">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Your application stores a set of URLs—for example, for video formats—in an object where each key identifies a different format:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">VideoFormatURLs</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">format360p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
  <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
  <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
  <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>You want to create a function <code>loadVideo</code> that can load any of those video format URLs but needs to load at least one URL.</p>&#13;
&#13;
<p>If <code>loadVideo</code> accepts parameters of type <code>VideoFormatURLs</code>, you need to provide <em>all</em> video format URLs:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">loadVideo</code><code class="p">(</code><code class="nx">formats</code><code class="o">:</code> <code class="nx">VideoFormatURLs</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// tbd</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({</code>&#13;
  <code class="nx">format360p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
  <code class="nx">format480p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
  <code class="nx">format720p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
  <code class="nx">format1080p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p class="pagebreak-before">But some videos might not exist, so a subset of all available types is actually what you’re looking for. <code>Partial&lt;VideoFormatURLs&gt;</code> gives you that:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">loadVideo</code><code class="p">(</code><code class="nx">formats</code><code class="o">:</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">VideoFormatURLs</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// tbd</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({</code>&#13;
  <code class="nx">format480p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
  <code class="nx">format720p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>But since all keys are optional, you would also allow the empty object as a valid parameter:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">loadVideo</code><code class="p">({});</code></pre>&#13;
&#13;
<p>This results in undefined behavior. You want to have at least one URL so you can load that video.</p>&#13;
&#13;
<p>We have to find a type expressing that we expect at least one of the available video formats: a type that allows us to pass all of them and some of them but also prevents us from passing none.</p>&#13;
&#13;
<p>Let’s start with the “only one” cases. Instead of finding one type, let’s create a union type that combines all situations where there’s only one property set:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AvailableVideoFormats</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">format360p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="p">};</code></pre>&#13;
&#13;
<p>This allows us to pass in objects that only have one property set. Next, let’s add the situations where we have two properties set:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AvailableVideoFormats</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">format360p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="p">};</code></pre>&#13;
&#13;
<p>Wait! That’s the same type! But that’s the way union types work. If they aren’t discriminated (see <a data-type="xref" href="ch03.html#ch03_item_discriminated_unions">Recipe 3.2</a>), union types will allow for values that are located at all intersections of the original set, as shown in <a data-type="xref" href="#img-split-type">Figure 8-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-split-type">&#13;
<img alt="tscb 0803" src="assets/tscb_0803.png"/>&#13;
<h6><span class="label">Figure 8-3. </span>The union type <code>AvailableVideoFormats</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>Each union member defines a set of possible values. The intersections describe the values where both types overlap. All possible combinations can be expressed with this union.</p>&#13;
&#13;
<p>So now that we know the type, it would be fantastic to derive it from the original type. We want to split an object type into a union of types where each member contains exactly one property.</p>&#13;
&#13;
<p class="pagebreak-before">One way to get a union type related to <code>VideoFormatURLs</code> is to use the <code>keyof</code> operator:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AvailableVideoFormats</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">VideoFormatURLs</code><code class="p">;</code></pre>&#13;
&#13;
<p>This yields <code>"format360p" | "format480p" | "format720p" | "format1080p"</code>, a union of the keys. We can use the <code>keyof</code> operator to index access the original type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AvailableVideoFormats</code> <code class="o">=</code> <code class="nx">VideoFormatURLs</code><code class="p">[</code><code class="kr">keyof</code> <code class="nx">VideoFormatURLs</code><code class="p">];</code></pre>&#13;
&#13;
<p>This yields <code>URL</code>, which is just one type, but in reality it is a union of the types of values. Now we only need to find a way to get proper values that represent an actual object type and are related to each property key.</p>&#13;
&#13;
<p>Read this phrase again: “related to each property key.” This calls for a mapped type! We can map through all <code>VideoFormatURLs</code> to get the property key to the righthand side of the object:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AvailableVideoFormats</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">VideoFormatURLs</code><code class="p">]</code><code class="o">:</code> <code class="nx">K</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="cm">/* yields</code>&#13;
<code class="cm">type AvailableVideoFormats = {</code>&#13;
<code class="cm">  format360p: "format360p";</code>&#13;
<code class="cm">  format480p: "format480p";</code>&#13;
<code class="cm">  format720p: "format720p";</code>&#13;
<code class="cm">  format1080p: "format1080p";</code>&#13;
<code class="cm">}; */</code></pre>&#13;
&#13;
<p>With that, we can index access the mapped type and get value types for each element. But we’re not only setting the key to the righthand side but also creating another object type that takes this string as a property key and maps it to the respective value type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AvailableVideoFormats</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">VideoFormatURLs</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">VideoFormatURLs</code><code class="p">[</code><code class="nx">P</code><code class="p">]</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="err">/* yields</code>&#13;
<code class="kr">type</code> <code class="nx">AvailableVideoFormats</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">format360p</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">format360p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
  <code class="nx">format480p</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
  <code class="nx">format720p</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
  <code class="nx">format1080p</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now we can use index access again to grep each value type from the righthand side into a union:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AvailableVideoFormats</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">VideoFormatURLs</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">VideoFormatURLs</code><code class="p">[</code><code class="nx">P</code><code class="p">]</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}[</code><code class="kr">keyof</code> <code class="nx">VideoFormatURLs</code><code class="p">];</code>&#13;
&#13;
<code class="cm">/* yields</code>&#13;
<code class="cm">type AvailableVideoFormats =</code>&#13;
<code class="cm">  | {</code>&#13;
<code class="cm">      format360p: URL;</code>&#13;
<code class="cm">    }</code>&#13;
<code class="cm">  | {</code>&#13;
<code class="cm">      format480p: URL;</code>&#13;
<code class="cm">    }</code>&#13;
<code class="cm">  | {</code>&#13;
<code class="cm">      format720p: URL;</code>&#13;
<code class="cm">    }</code>&#13;
<code class="cm">  | {</code>&#13;
<code class="cm">      format1080p: URL;</code>&#13;
<code class="cm">    };</code>&#13;
<code class="cm">*/</code></pre>&#13;
&#13;
<p>And that’s what we’ve been looking for! As a next step, we take the concrete types and substitute them with generics, resulting in the <code>Split&lt;T&gt;</code> helper type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Split</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">];</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}[</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">];</code></pre>&#13;
&#13;
<p>Another helper type in our arsenal. Using it with <code>loadVideo</code> gives us exactly the behavior we have been aiming for:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">loadVideo</code><code class="p">(</code><code class="nx">formats</code><code class="o">:</code> <code class="nx">Split</code><code class="o">&lt;</code><code class="nx">VideoFormatURLs</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// tbd</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({});</code>&#13;
<code class="c1">//        ^</code>&#13;
<code class="c1">// Argument of type '{}' is not assignable to parameter</code>&#13;
<code class="c1">// of type 'Split&lt;VideoFormatURLs&gt;'</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({</code>&#13;
  <code class="nx">format480p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
<code class="p">});</code> <code class="c1">// all good</code></pre>&#13;
&#13;
<p><code>Split&lt;T&gt;</code> is a nice way to see how basic type system functionality can change the behavior of your interfaces significantly, and how some simple typing techniques like mapped types, index access types, and property keys can be used to get a tiny yet powerful helper type.<a data-startref="ix_08-05-asciidoc3" data-type="indexterm" id="id782"/><a data-startref="ix_08-05-asciidoc2" data-type="indexterm" id="id783"/><a data-startref="ix_08-05-asciidoc1" data-type="indexterm" id="id784"/><a data-startref="ix_08-05-asciidoc0" data-type="indexterm" id="id785"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.6 Allowing Exactly One and All or None" data-type="sect1"><div class="sect1" id="ch08_all_or_none">&#13;
<h1>8.6 Allowing Exactly One and All or None</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id128">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="AllOrNone&lt;T, K&gt; helper type" data-type="indexterm" id="ix_08-08-asciidoc0"/><a data-primary="ExactlyOne&lt;T&gt; helper type" data-type="indexterm" id="ix_08-08-asciidoc1"/><a data-primary="helper types" data-secondary="allowing exactly one or all or none" data-type="indexterm" id="ix_08-08-asciidoc2"/><a data-primary="never type" data-secondary="allowing exactly one or all or none" data-type="indexterm" id="ix_08-08-asciidoc3a"/><a data-primary="optional never technique" data-secondary="allowing exactly one or all or none" data-type="indexterm" id="ix_08-08-asciidoc3"/><a data-primary="union types" data-secondary="allowing exactly one or all or none" data-type="indexterm" id="ix_08-08-asciidoc4"/>Next to requiring <em>at least one</em> like in <a data-type="xref" href="#ch08_splitting_types">Recipe 8.5</a>, you also want to provide scenarios where users provide <em>exactly one</em> or <em>all or none</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id786">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create <code>ExactlyOne&lt;T&gt;</code> and <code>AllOrNone&lt;T, K&gt;</code>. Both rely on the <em>optional never</em> technique in combination with a derivate of <code>Split&lt;T&gt;</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id129">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>With <code>Split&lt;T&gt;</code> from <a data-type="xref" href="#ch08_splitting_types">Recipe 8.5</a> we create a nice helper type that makes it possible to describe the scenario where we want <em>at least one</em> parameter provided. This is something that <code>Partial&lt;T&gt;</code> can’t provide for us, but regular union types can.</p>&#13;
&#13;
<p>Starting from this idea we, might also run into scenarios where we want our users to provide <em>exactly one</em>, making sure they don’t add too many options.</p>&#13;
&#13;
<p>One technique that can be used here is optional never, which we learned in <a data-type="xref" href="ch03.html#ch03_item_optional_never">Recipe 3.8</a>. <a data-primary="never type" data-secondary="optional never technique and" data-type="indexterm" id="id787"/>Next to all the properties you want to allow, you set all the properties you don’t want to allow to optional and their value to <code>never</code>. This means the moment you write the property name, TypeScript wants you to set its value to something that is compatible with <code>never</code>, which you can’t, as the <code>never</code> has no values.</p>&#13;
&#13;
<p>A union type where we put all property names in an <em>exclusive or</em> relation is the key. We get a union type with each property already with <code>Split&lt;T&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Split</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">];</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}[</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">];</code></pre>&#13;
&#13;
<p>All we need to do is to intersect each element with the remaining keys and set them to optional never:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ExactlyOne</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">];</code>&#13;
  <code class="p">}</code> <code class="o">&amp;</code>&#13;
    <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code><code class="p">]</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code> <code class="c1">// optional never</code>&#13;
    <code class="p">};</code>&#13;
<code class="p">}[</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">];</code></pre>&#13;
&#13;
<p>With that, the resulting type is more extensive but tells us exactly which properties to exclude:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ExactlyOneVideoFormat</code> <code class="o">=</code> <code class="p">({</code>&#13;
    <code class="nx">format360p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
    <code class="nx">format480p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="nx">format720p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="nx">format1080p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
<code class="p">})</code> <code class="o">|</code> <code class="p">({</code>&#13;
    <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
    <code class="nx">format360p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="nx">format720p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="nx">format1080p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
<code class="p">})</code> <code class="o">|</code> <code class="p">({</code>&#13;
    <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
    <code class="nx">format320p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="nx">format480p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="nx">format1080p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
<code class="p">})</code> <code class="o">|</code> <code class="p">({</code>&#13;
    <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
    <code class="nx">format320p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="nx">format480p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="nx">format720p</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>And it works as expected:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">loadVideo</code><code class="p">(</code><code class="nx">formats</code><code class="o">:</code> <code class="nx">ExactlyOne</code><code class="o">&lt;</code><code class="nx">VideoFormatURLs</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// tbd</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({</code>&#13;
  <code class="nx">format360p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
<code class="p">});</code> <code class="c1">// works</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({</code>&#13;
  <code class="nx">format360p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
  <code class="nx">format1080p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
<code class="p">});</code>&#13;
<code class="c1">// ^</code>&#13;
<code class="c1">// Argument of type '{ format360p: URL; format1080p: URL; }'</code>&#13;
<code class="c1">// is not assignable to parameter of type 'ExactlyOne&lt;VideoFormatURLs&gt;'.</code></pre>&#13;
&#13;
<p><code>ExactlyOne&lt;T&gt;</code> is so much like <code>Split&lt;T&gt;</code> that we could think of extending <code>Split&lt;T&gt;</code> with the functionality to include the optional never pattern:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Split</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">OptionalNever</code> <code class="kr">extends</code> <code class="kr">boolean</code> <code class="o">=</code> <code class="kc">false</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">];</code>&#13;
  <code class="p">}</code> <code class="o">&amp;</code>&#13;
    <code class="p">(</code><code class="nx">OptionalNever</code> <code class="kr">extends</code> <code class="kc">false</code>&#13;
      <code class="o">?</code> <code class="p">{}</code>&#13;
      <code class="o">:</code> <code class="p">{</code>&#13;
          <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code><code class="p">]</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
        <code class="p">});</code>&#13;
<code class="p">}[</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">];</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ExactlyOne</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Split</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="kc">true</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>We add a new generic type parameter <code>OptionalNever</code>, which we default to <code>false</code>. We then intersect the part where we create new objects with a conditional type that checks if the parameter <code>OptionalNever</code> is actually false. If so, we intersect with the empty object (leaving the original object intact); otherwise, we add the optional never part to the object. <code>ExactlyOne&lt;T&gt;</code> is refactored to <code>Split&lt;T, true&gt;</code>, where we activate the <code>OptionalNever</code> flag.</p>&#13;
&#13;
<p>Another scenario very similar to <code>Split&lt;T&gt;</code> or <code>ExactlyOne&lt;T&gt;</code> is to provide all arguments or no arguments. Think of splitting video formats into standard definition (SD: 360p and 480p) and high definition (HD: 720p and 1080p). In your app, you want to make sure that if your users provide SD formats, they should provide all possible formats. It’s OK to have a single HD format.</p>&#13;
&#13;
<p>This is also where the optional never technique comes in. We define a type that <em>requires</em> all selected keys or sets them to <code>never</code> if only one is provided:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AllOrNone</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Keys</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Keys</code><code class="p">]</code><code class="o">-?:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code> <code class="c1">// all available</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Keys</code><code class="p">]</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code> <code class="c1">// or none</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>If you want to make sure that you provide also <em>all</em> HD formats, add the rest to it via an intersection:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AllOrNone</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Keys</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Keys</code><code class="p">]</code><code class="o">-?:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Keys</code><code class="p">]</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">)</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">Keys</code><code class="o">&gt;</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="c1">// the rest, as it was defined</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Or if HD formats are totally optional, add them via a <code>Partial&lt;T&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AllOrNone</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Keys</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Keys</code><code class="p">]</code><code class="o">-?:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Keys</code><code class="p">]</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">)</code> <code class="o">&amp;</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Keys</code><code class="o">&gt;&gt;</code><code class="p">;</code> <code class="c1">// the rest, but optional</code></pre>&#13;
&#13;
<p>But then you run into the same problem as in <a data-type="xref" href="#ch08_splitting_types">Recipe 8.5</a>, where you can provide values that don’t include any formats at all. Intersecting the <em>all or none</em> variation with <code>Split&lt;T&gt;</code> is the solution we are aiming for:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AllOrNone</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Keys</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Keys</code><code class="p">]</code><code class="o">-?:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Keys</code><code class="p">]</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">)</code> <code class="o">&amp;</code> <code class="nx">Split</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>And it works as intended:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">loadVideo</code><code class="p">(</code>&#13;
  <code class="nx">formats</code><code class="o">:</code> <code class="nx">AllOrNone</code><code class="o">&lt;</code><code class="nx">VideoFormatURLs</code><code class="p">,</code> <code class="s2">"format360p"</code> <code class="o">|</code> <code class="s2">"format480p"</code><code class="o">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// TBD</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({</code>&#13;
  <code class="nx">format360p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
  <code class="nx">format480p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
<code class="p">});</code> <code class="c1">// OK</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({</code>&#13;
  <code class="nx">format360p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
  <code class="nx">format480p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
  <code class="nx">format1080p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
<code class="p">});</code> <code class="c1">// OK</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({</code>&#13;
  <code class="nx">format1080p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
<code class="p">});</code> <code class="c1">// OK</code>&#13;
&#13;
<code class="nx">loadVideo</code><code class="p">({</code>&#13;
  <code class="nx">format360p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
  <code class="nx">format1080p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>&#13;
<code class="p">});</code>&#13;
<code class="c1">// ^ Argument of type '{ format360p: URL; format1080p: URL; }' is</code>&#13;
<code class="c1">// not assignable to parameter of type</code>&#13;
<code class="c1">// '({ format360p: URL; format480p: URL; } &amp; ... (abbreviated)</code></pre>&#13;
&#13;
<p>If we look closely at what <code>AllOrNone</code> does, we can easily rewrite it with built-in helper types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AllOrNone</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Keys</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="o">|</code> <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Keys</code><code class="o">&gt;&gt;</code>&#13;
  <code class="o">|</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Record</code><code class="o">&lt;</code><code class="nx">Keys</code><code class="p">,</code> <code class="kr">never</code><code class="o">&gt;&gt;</code>&#13;
<code class="p">)</code> <code class="o">&amp;</code>&#13;
  <code class="nx">Split</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is arguably more readable but also more to the point of metaprogramming in the type system. You have a set of helper types, and you can combine them to create new helper types: almost like a functional programming language, but on sets of values, in the type system.<a data-startref="ix_08-08-asciidoc4" data-type="indexterm" id="id788"/><a data-startref="ix_08-08-asciidoc3a" data-type="indexterm" id="id789"/><a data-startref="ix_08-08-asciidoc3" data-type="indexterm" id="id790"/><a data-startref="ix_08-08-asciidoc2" data-type="indexterm" id="id791"/><a data-startref="ix_08-08-asciidoc1" data-type="indexterm" id="id792"/><a data-startref="ix_08-08-asciidoc0" data-type="indexterm" id="id793"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.7 Converting Union to Intersection Types" data-type="sect1"><div class="sect1" id="ch08_union_to_intersection">&#13;
<h1>8.7 Converting Union to Intersection Types</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id130">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="helper types" data-secondary="converting union to intersection types" data-type="indexterm" id="ix_08-06-asciidoc0"/><a data-primary="intersection types" data-secondary="converting union types to" data-type="indexterm" id="ix_08-06-asciidoc1"/><a data-primary="union types" data-secondary="converting to intersection type" data-type="indexterm" id="ix_08-06-asciidoc2"/><a data-primary="UnionToIntersection&lt;T&gt; helper type" data-type="indexterm" id="ix_08-06-asciidoc3"/>Your model is defined as a union type of several variants. To derive other types from it, you first need to convert the union type to an intersection type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id794">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a <code>UnionToIntersection&lt;T&gt;</code> helper type that uses contravariant positions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id131">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In <a data-type="xref" href="#ch08_splitting_types">Recipe 8.5</a> we discussed how we can split a model type into a union of its variants. Depending on how your application works, you may want to define the model as a union type of several variants right from the beginning:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">BasicVideoData</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">// tbd</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Format320</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">urls</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format320p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="p">};</code>&#13;
<code class="kr">type</code> <code class="nx">Format480</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">urls</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="p">};</code>&#13;
<code class="kr">type</code> <code class="nx">Format720</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">urls</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="p">};</code>&#13;
<code class="kr">type</code> <code class="nx">Format1080</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">urls</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Video</code> <code class="o">=</code> <code class="nx">BasicVideoData</code> <code class="o">&amp;</code> <code class="p">(</code><code class="nx">Format320</code> <code class="o">|</code> <code class="nx">Format480</code> <code class="o">|</code> <code class="nx">Format720</code> <code class="o">|</code> <code class="nx">Format1080</code><code class="p">);</code></pre>&#13;
&#13;
<p class="pagebreak-before">The type <code>Video</code> allows you to define several formats but requires you to define at &#13;
<span class="keep-together">least one:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">video1</code><code class="o">:</code> <code class="nx">Video</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
  <code class="nx">urls</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">format320p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"https://..."</code><code class="p">),</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">};</code> <code class="c1">// OK</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">video2</code><code class="o">:</code> <code class="nx">Video</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
  <code class="nx">urls</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">format320p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"https://..."</code><code class="p">),</code>&#13;
    <code class="nx">format480p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"https://..."</code><code class="p">),</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">};</code> <code class="c1">// OK</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">video3</code><code class="o">:</code> <code class="nx">Video</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
  <code class="nx">urls</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">format1080p</code><code class="o">:</code> <code class="k">new</code> <code class="nx">URL</code><code class="p">(</code><code class="s2">"https://..."</code><code class="p">),</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">};</code> <code class="c1">// OK</code></pre>&#13;
&#13;
<p>However, putting them in a union has some side effects—for example, when you need all available keys:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatKeys</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">Video</code><code class="p">[</code><code class="s2">"urls"</code><code class="p">];</code>&#13;
<code class="c1">// FormatKeys = never</code>&#13;
&#13;
<code class="c1">// This is not what we want here!</code>&#13;
<code class="kd">function</code> <code class="nx">selectFormat</code><code class="p">(</code><code class="nx">format</code><code class="o">:</code> <code class="nx">FormatKeys</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">// tbd.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You might expect <code>FormatKeys</code> to provide a union type of all keys that are nested in <code>urls</code>. Index access on a union type, however, tries to find the lowest common denominator. And in this case, there is none. To get a union type of all format keys, you need to have all keys within one type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Video</code> <code class="o">=</code> <code class="nx">BasicVideoData</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">urls</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">format320p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
    <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">FormatKeys</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">Video</code><code class="p">[</code><code class="s2">"urls"</code><code class="p">];</code>&#13;
<code class="c1">// type FormatKeys =</code>&#13;
<code class="c1">//   "format320p" | "format480p" | "format720p" | "format1080p";</code></pre>&#13;
&#13;
<p>A way to create an object like this is to modify the union type to an intersection type.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In <a data-type="xref" href="#ch08_splitting_types">Recipe 8.5</a>, modeling data in a single type was the way to go; in this recipe, we see that modeling data as a union type is more to our liking. In reality, there is no single answer to how you define your models. Use the representation that best fits your application domain and that doesn’t get in your way too much. The important thing is to be able to derive other types as you need them. This reduces maintenance and allows you to create more robust types. In <a data-type="xref" href="ch12.html#ch12">Chapter 12</a> and especially <a data-type="xref" href="ch12.html#ch12_low_maintenance_types">Recipe 12.1</a> we will look at the principle of “low maintenance types.”</p>&#13;
</div>&#13;
&#13;
<p>Converting a union type to an intersection type is a peculiar task in TypeScript and requires some deep knowledge of the inner workings of the type system. To learn all these concepts, we look at the finished type, and then see what happens under the hood:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="p">(</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="kr">extends</code>&#13;
  <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>There is a <em>lot</em> to unpack here:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We have two conditional types. The first one seems to always result in the <code>true</code> branch, so why do we need it?</p>&#13;
</li>&#13;
<li>&#13;
<p>The first conditional type wraps the type in a function argument, and the second conditional type unwraps it again. Why is this necessary?</p>&#13;
</li>&#13;
<li>&#13;
<p>And how do both conditional types transform a union type to an intersection type?</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s analyze <code>UnionToIntersection&lt;T&gt;</code> step by step.</p>&#13;
&#13;
<p>In the first conditional within <code>UnionToIntersection&lt;T&gt;</code>, we use the generic type argument as a <em>naked type</em>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="p">(</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="c1">//...</code></pre>&#13;
&#13;
<p>This means we check if <code>T</code> is in a subtype condition without wrapping it in some other type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Naked</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="p">...;</code> <code class="c1">// a naked type</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">NotNaked</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="nx">T</code> <code class="p">}</code> <code class="kr">extends</code> <code class="p">...;</code> <code class="c1">// a non-naked type</code></pre>&#13;
&#13;
<p>Naked types in conditional types have a certain feature. If <code>T</code> is a union, they run the conditional type for each constituent of the union. So with a naked type, a <em>conditional of union types becomes a union of conditional types</em>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">WrapNaked</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>  <code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="nx">T</code> <code class="p">}</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Foo</code> <code class="o">=</code> <code class="nx">WrapNaked</code><code class="o">&lt;</code><code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="kr">boolean</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// A naked type, so this equals to</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Foo</code> <code class="o">=</code>&#13;
  <code class="nx">WrapNaked</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="o">|</code> <code class="nx">WrapNaked</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code> <code class="o">|</code> <code class="nx">WrapNaked</code><code class="o">&lt;</code><code class="kr">boolean</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// equals to</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Foo</code> <code class="o">=</code>&#13;
  <code class="kt">string</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code> <code class="o">:</code> <code class="kr">never</code> <code class="o">|</code>&#13;
  <code class="kt">number</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="kt">number</code> <code class="p">}</code> <code class="o">:</code> <code class="kr">never</code> <code class="o">|</code>&#13;
  <code class="kr">boolean</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">}</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Foo</code> <code class="o">=</code>&#13;
  <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code> <code class="o">|</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="kt">number</code> <code class="p">}</code> <code class="o">|</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">};</code></pre>&#13;
&#13;
<p>As compared to the non-naked version:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">WrapNaked</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="nx">T</code> <code class="p">}</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="nx">T</code> <code class="p">}</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Foo</code> <code class="o">=</code> <code class="nx">WrapNaked</code><code class="o">&lt;</code><code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="kr">boolean</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// A non-naked type, so this equals to</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Foo</code> <code class="o">=</code>&#13;
  <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="kr">boolean</code> <code class="p">}</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code>&#13;
  <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="kr">boolean</code> <code class="p">}</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Foo</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">o</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="kr">boolean</code> <code class="p">};</code></pre>&#13;
&#13;
<p>Subtle, but considerably different for complex types!</p>&#13;
&#13;
<p>In our example, we use the naked type and ask if it extends <code>any</code> (which it always does; <code>any</code> is the allow-it-all top type):</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="p">(</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="c1">//...</code></pre>&#13;
&#13;
<p>Since this condition is always true, we wrap our generic type in a function, where <code>T</code> is the type of the function’s parameter. But why are we doing that?</p>&#13;
&#13;
<p>This leads to the second condition:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="p">(</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="kr">extends</code>&#13;
  <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code></pre>&#13;
&#13;
<p>As the first condition always yields true, meaning that we wrap our type in a function type, the other condition also always yields true. We are basically checking if the type we just created is a subtype of itself. But instead of passing through <code>T</code>, we infer a new type <code>R</code>, and return the inferred type.</p>&#13;
&#13;
<p>What we do is wrap and unwrap type <code>T</code> via a function type.</p>&#13;
&#13;
<p>Doing this via function arguments brings the new inferred type <code>R</code> in a <em>contravariant position</em>.</p>&#13;
&#13;
<p><a data-primary="contravariance" data-type="indexterm" id="ix_08-06-asciidoc4"/><a data-primary="covariance" data-type="indexterm" id="ix_08-06-asciidoc5"/>So what does <em>contravariance</em> mean? The opposite of <em>contravariance</em> is <em>covariance</em>, and what you would expect from normal subtyping:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kd">let</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="kr">declare</code> <code class="kd">let</code> <code class="nx">c</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
<code class="nx">c</code> <code class="o">=</code> <code class="nx">b</code> <code class="c1">// OK</code></pre>&#13;
&#13;
<p><code>string</code> is a subtype of <code>string | number</code>; all elements of <code>string</code> appear in <code>string | number</code>, so we can assign <code>b</code> to <code>c</code>. <code>c</code> still behaves as we originally intended. This is covariance.</p>&#13;
&#13;
<p>This, on the other hand, won’t work:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Fun</code><code class="o">&lt;</code><code class="nx">X</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">X</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
&#13;
<code class="kr">declare</code> <code class="kd">let</code> <code class="nx">f</code><code class="o">:</code> <code class="nx">Fun</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kr">declare</code> <code class="kd">let</code> <code class="nx">g</code><code class="o">:</code> <code class="nx">Fun</code><code class="o">&lt;</code><code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="nx">g</code> <code class="o">=</code> <code class="nx">f</code> <code class="c1">// this cannot be assigned</code></pre>&#13;
&#13;
<p>We can’t assign <code>f</code> to <code>g</code>, because then we would also be able to call <code>f</code> with a number! We miss part of the contract of <code>g</code>. This is contravariance.</p>&#13;
&#13;
<p>The interesting thing is that contravariance effectively works like an intersection: if <code>f</code> accepts <code>string</code> and <code>g</code> accepts <code>string | number</code>, the type that is accepted by both is <code>(string | number) &amp; string</code>, which is <code>string</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id795">&#13;
<h1>Covariance and Contravariance</h1>&#13;
<p><a href="https://oreil.ly/dX3DM">Orginate.com</a> says that “variance determines how instances of paramterized types are subtypes or supertypes of one another.”</p>&#13;
&#13;
<p>TypeScript uses variance to see if types can be substantiated for another type in an expression. Next to the description in this recipe, <a data-type="xref" href="#img-contra-variance">Figure 8-4</a>, based on material by <a href="https://oreil.ly/ftfP7">Rice University</a>, shows how covariance and contravariance &#13;
<span class="keep-together">play out.</span></p>&#13;
&#13;
<figure><div class="figure" id="img-contra-variance">&#13;
<img alt="tscb 0804" src="assets/tscb_0804.png"/>&#13;
<h6><span class="label">Figure 8-4. </span>Covariance and contravariance explained through consumers &#13;
<span class="keep-together">and producers</span></h6>&#13;
</div></figure>&#13;
</div></aside>&#13;
&#13;
<p>When we put types in contravariant positions within a conditional type, TypeScript creates an <em>intersection</em> out of it. Meaning that since we <em>infer</em> from a function argument, TypeScript knows that we have to fulfill the complete contract, creating an intersection of all constituents in the union.</p>&#13;
&#13;
<p>Basically, <em>union to intersection</em>.</p>&#13;
&#13;
<p>Let’s run it through:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="p">(</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code> <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="kr">extends</code>&#13;
  <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Intersected</code> <code class="o">=</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="nx">Video</code><code class="p">[</code><code class="s2">"urls"</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// equals to</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Intersected</code> <code class="o">=</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code>&#13;
  <code class="p">{</code> <code class="nx">format320p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="o">|</code>&#13;
  <code class="p">{</code> <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="o">|</code>&#13;
  <code class="p">{</code> <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="o">|</code>&#13;
  <code class="p">{</code> <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code>&#13;
<code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>We have a naked type; this means we can do a union of conditionals:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Intersected</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="p">{</code> <code class="nx">format320p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code><code class="o">&gt;</code>&#13;
  <code class="o">|</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="p">{</code> <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code><code class="o">&gt;</code>&#13;
  <code class="o">|</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="p">{</code> <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code><code class="o">&gt;</code>&#13;
  <code class="o">|</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="p">{</code> <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Let’s expand <code>UnionToIntersection&lt;T&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Intersected</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="p">({</code> <code class="nx">format320p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code>&#13;
      <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format320p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="kr">extends</code>&#13;
      <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="p">({</code> <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code>&#13;
      <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="kr">extends</code>&#13;
      <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="p">({</code> <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code>&#13;
      <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="kr">extends</code>&#13;
      <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="p">({</code> <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="kr">extends</code> <code class="kr">any</code> <code class="o">?</code>&#13;
     <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="kr">extends</code>&#13;
      <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>And evaluate the first conditional:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Intersected</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="p">((</code><code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format320p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="p">)</code> <code class="kr">extends</code> <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="p">((</code><code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="p">)</code> <code class="kr">extends</code> <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="p">((</code><code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="p">)</code> <code class="kr">extends</code> <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="p">((</code><code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="p">)</code> <code class="kr">extends</code> <code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code> <code class="o">?</code> <code class="nx">R</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>Let’s evaluate conditional two, where we infer <code>R</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Intersected</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="p">{</code> <code class="nx">format320p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="o">|</code> <code class="p">{</code> <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code> <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="o">|</code> <code class="p">{</code> <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">};</code></pre>&#13;
&#13;
<p>But wait! <code>R</code> is inferred from a contravariant position. We have to make an intersection; otherwise, we lose type compatibility:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Intersected</code> <code class="o">=</code>&#13;
  <code class="p">{</code> <code class="nx">format320p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">format480p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="o">&amp;</code>&#13;
  <code class="p">{</code> <code class="nx">format720p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">format1080p</code><code class="o">:</code> <code class="nx">URL</code> <code class="p">};</code></pre>&#13;
&#13;
<p>And that’s what we have been looking for! So, applied to our original example:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatKeys</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">UnionToIntersection</code><code class="o">&lt;</code><code class="nx">Video</code><code class="p">[</code><code class="s2">"urls"</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p><code>FormatKeys</code> is now <code>"format320p" | "format480p" | "format720p" | "format1080p"#</code>. Whenever we add another format to the original union, the <code>FormatKeys</code> type updates automatically. Maintain once; use everywhere<a data-startref="ix_08-06-asciidoc5" data-type="indexterm" id="id796"/><a data-startref="ix_08-06-asciidoc4" data-type="indexterm" id="id797"/>.<a data-startref="ix_08-06-asciidoc3" data-type="indexterm" id="id798"/><a data-startref="ix_08-06-asciidoc2" data-type="indexterm" id="id799"/><a data-startref="ix_08-06-asciidoc1" data-type="indexterm" id="id800"/><a data-startref="ix_08-06-asciidoc0" data-type="indexterm" id="id801"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="8.8 Using type-fest" data-type="sect1"><div class="sect1" id="ch08_type_fest">&#13;
<h1>8.8 Using type-fest</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id132">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="helper types" data-secondary="using type-fest" data-type="indexterm" id="ix_08-07-asciidoc0"/><a data-primary="libraries" data-secondary="type-fest" data-type="indexterm" id="ix_08-07-asciidoc1"/><a data-primary="type-fest library" data-type="indexterm" id="ix_08-07-asciidoc2"/>You love your helper types so much that you want to create a utility library for easy access.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id802">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Chances are <em>type-fest</em> already has everything you need.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id133">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The whole idea of this chapter was to introduce you to a couple of useful helper types that are not part of standard Typescript but have proven to be highly flexible for many scenarios: single-purpose generic helper types that can be combined and composed to derive types based on your existing models. You write your models once, and all other types get updated automatically. <a data-primary="low maintenance types" data-secondary="type-fest and" data-type="indexterm" id="id803"/>This idea of having <em>low maintenance types</em>, by deriving types from others, is unique to TypeScript and appreciated by tons of developers who create complex applications or libraries<a data-primary="libraries" data-seealso="standard library" data-type="indexterm" id="id804"/>.</p>&#13;
&#13;
<p>You might end up using your helper types a lot, so you start out combining them in a utility library for easy access, but chances are one of the existing libraries already has everything you need. Using a well-defined set of helper types is nothing new, and plenty out there give you everything you’ve seen in this chapter. Sometimes it’s exactly the same but under a different name; other times it’s a similar idea but solved differently. The basics are most likely covered by all type libraries, but one library, <a href="https://oreil.ly/Cw4Kc"><em>type-fest</em></a>, is not only useful but actively maintained, well documented, and widely used.</p>&#13;
&#13;
<p><em>Type-fest</em> has a few aspects that make it stand out. First, it’s extensively documented. Not only does its documentation include the <em>usage</em> of a certain helper type, but it also includes use cases and scenarios that tell you where you might want to use this helper type. One example is <code>Integer&lt;T&gt;</code>, which makes sure that the number you provide does not have any decimals.</p>&#13;
&#13;
<p class="pagebreak-before">This is a utility type that almost made it into <em>TypeScript Cookbook</em>, but I saw that giving you the snippet from <em>type-fest</em> tells you everything you need to know about &#13;
<span class="keep-together">the type:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm">A `number` that is an integer.</code>&#13;
<code class="cm">You can't pass a `bigint` as they are already guaranteed to be integers.</code>&#13;
<code class="cm">Use-case: Validating and documenting parameters.</code>&#13;
&#13;
<code class="cm">@example</code>&#13;
<code class="cm">```</code>&#13;
<code class="cm">import type {Integer} from 'type-fest';</code>&#13;
<code class="cm">declare function setYear&lt;T extends number&gt;(length: Integer&lt;T&gt;): void;</code>&#13;
<code class="cm">```</code>&#13;
<code class="cm">@see NegativeInteger</code>&#13;
<code class="cm">@see NonNegativeInteger</code>&#13;
<code class="cm">@category Numeric</code>&#13;
<code class="cm">*/</code>&#13;
<code class="c1">// `${bigint}` is a type that matches a valid bigint</code>&#13;
<code class="c1">// literal without the `n` (ex. 1, 0b1, 0o1, 0x1)</code>&#13;
<code class="c1">// Because T is a number and not a string we can effectively use</code>&#13;
<code class="c1">// this to filter out any numbers containing decimal points</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">type</code> <code class="nx">Integer</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">number</code><code class="o">&gt;</code> <code class="o">=</code> <code class="sb">`</code><code class="si">${</code><code class="nx">T</code><code class="si">}</code><code class="sb">`</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="nx">bigint</code><code class="si">}</code><code class="sb">`</code> <code class="o">?</code> <code class="nx">T</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>The rest of the file deals with negative integers, non-negative integers, floating point numbers, and so on. It’s a real treasure trove of information if you want to know more about how types are constructed.</p>&#13;
&#13;
<p><a data-primary="DeepPartial&lt;T&gt; type" data-type="indexterm" id="ix_08-07-asciidoc3"/><a data-primary="edge cases" data-type="indexterm" id="ix_08-07-asciidoc4"/>Second, <em>type-fest</em> deals with edge cases. In <a data-type="xref" href="#ch08_nested_objects">Recipe 8.2</a>, we learned about recursive types and defined <code>DeepPartial&lt;T&gt;</code>. Its <em>type-fest</em> counterpart, <code>PartialDeep&lt;T&gt;</code>, is a bit more extensive:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">type</code> <code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Opts</code> <code class="kr">extends</code> <code class="nx">PartialDeepOptions</code> <code class="o">=</code> <code class="p">{}</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">BuiltIns</code>&#13;
  <code class="o">?</code> <code class="nx">T</code>&#13;
  <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Map</code><code class="o">&lt;</code><code class="kr">infer</code> <code class="nx">KeyType</code><code class="p">,</code> <code class="kr">infer</code> <code class="nx">ValueType</code><code class="o">&gt;</code>&#13;
    <code class="o">?</code> <code class="nx">PartialMapDeep</code><code class="o">&lt;</code><code class="nx">KeyType</code><code class="p">,</code> <code class="nx">ValueType</code><code class="p">,</code> <code class="nx">Opts</code><code class="o">&gt;</code>&#13;
    <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Set</code><code class="o">&lt;</code><code class="kr">infer</code> <code class="nx">ItemType</code><code class="o">&gt;</code>&#13;
      <code class="o">?</code> <code class="nx">PartialSetDeep</code><code class="o">&lt;</code><code class="nx">ItemType</code><code class="p">,</code> <code class="nx">Opts</code><code class="o">&gt;</code>&#13;
      <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">ReadonlyMap</code><code class="o">&lt;</code><code class="kr">infer</code> <code class="nx">KeyType</code><code class="p">,</code> <code class="kr">infer</code> <code class="nx">ValueType</code><code class="o">&gt;</code>&#13;
        <code class="o">?</code> <code class="nx">PartialReadonlyMapDeep</code><code class="o">&lt;</code><code class="nx">KeyType</code><code class="p">,</code> <code class="nx">ValueType</code><code class="p">,</code> <code class="nx">Opts</code><code class="o">&gt;</code>&#13;
        <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">ReadonlySet</code><code class="o">&lt;</code><code class="kr">infer</code> <code class="nx">ItemType</code><code class="o">&gt;</code>&#13;
          <code class="o">?</code> <code class="nx">PartialReadonlySetDeep</code><code class="o">&lt;</code><code class="nx">ItemType</code><code class="p">,</code> <code class="nx">Opts</code><code class="o">&gt;</code>&#13;
          <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="p">((...</code><code class="nx">arguments</code><code class="o">:</code> <code class="kr">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="kr">unknown</code><code class="p">)</code>&#13;
            <code class="o">?</code> <code class="nx">T</code> <code class="o">|</code> <code class="kc">undefined</code>&#13;
            <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">object</code>&#13;
              <code class="o">?</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="kr">infer</code> <code class="nx">ItemType</code><code class="o">&gt;</code>&#13;
                <code class="o">?</code> <code class="nx">Opts</code><code class="p">[</code><code class="s1">'recurseIntoArrays'</code><code class="p">]</code> <code class="kr">extends</code> <code class="kc">true</code>&#13;
                  <code class="o">?</code> <code class="nx">ItemType</code><code class="p">[]</code> <code class="kr">extends</code> <code class="nx">T</code>&#13;
                    <code class="o">?</code> <code class="kr">readonly</code> <code class="nx">ItemType</code><code class="p">[]</code> <code class="kr">extends</code> <code class="nx">T</code>&#13;
                      <code class="o">?</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">ItemType</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">Opts</code><code class="o">&gt;&gt;</code>&#13;
                      <code class="o">:</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">ItemType</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">Opts</code><code class="o">&gt;&gt;</code>&#13;
                    <code class="o">:</code> <code class="nx">PartialObjectDeep</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Opts</code><code class="o">&gt;</code>&#13;
                  <code class="o">:</code> <code class="nx">T</code>&#13;
                <code class="o">:</code> <code class="nx">PartialObjectDeep</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Opts</code><code class="o">&gt;</code>&#13;
              <code class="o">:</code> <code class="kr">unknown</code><code class="p">;</code>&#13;
&#13;
<code class="cm">/**</code>&#13;
<code class="cm">Same as `PartialDeep`, but accepts only `Map`s and as inputs.</code>&#13;
<code class="cm">Internal helper for `PartialDeep`.</code>&#13;
<code class="cm">*/</code>&#13;
<code class="kr">type</code> <code class="nx">PartialMapDeep</code><code class="o">&lt;</code><code class="nx">KeyType</code><code class="p">,</code> <code class="nx">ValueType</code><code class="p">,</code> <code class="nx">Options</code> <code class="kr">extends</code> <code class="nx">PartialDeepOptions</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="p">{}</code> <code class="o">&amp;</code> <code class="nx">Map</code><code class="o">&lt;</code><code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">KeyType</code><code class="p">,</code> <code class="nx">Options</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">ValueType</code><code class="p">,</code> <code class="nx">Options</code><code class="o">&gt;&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="cm">/**</code>&#13;
<code class="cm">Same as `PartialDeep`, but accepts only `Set`s as inputs.</code>&#13;
<code class="cm">Internal helper for `PartialDeep`.</code>&#13;
<code class="cm">*/</code>&#13;
<code class="kr">type</code> <code class="nx">PartialSetDeep</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Options</code> <code class="kr">extends</code> <code class="nx">PartialDeepOptions</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="p">{}</code> <code class="o">&amp;</code> <code class="nx">Set</code><code class="o">&lt;</code><code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Options</code><code class="o">&gt;&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="cm">/**</code>&#13;
<code class="cm">Same as `PartialDeep`, but accepts only `ReadonlyMap`s as inputs.</code>&#13;
<code class="cm">Internal helper for `PartialDeep`.</code>&#13;
<code class="cm">*/</code>&#13;
<code class="kr">type</code> <code class="nx">PartialReadonlyMapDeep</code><code class="o">&lt;</code>&#13;
  <code class="nx">KeyType</code><code class="p">,</code> <code class="nx">ValueType</code><code class="p">,</code>&#13;
  <code class="nx">Options</code> <code class="kr">extends</code> <code class="nx">PartialDeepOptions</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="p">{}</code> <code class="o">&amp;</code> <code class="nx">ReadonlyMap</code><code class="o">&lt;</code>&#13;
    <code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">KeyType</code><code class="p">,</code> <code class="nx">Options</code><code class="o">&gt;</code><code class="p">,</code>&#13;
    <code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">ValueType</code><code class="p">,</code> <code class="nx">Options</code><code class="o">&gt;</code>&#13;
  <code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="cm">/**</code>&#13;
<code class="cm">Same as `PartialDeep`, but accepts only `ReadonlySet`s as inputs.</code>&#13;
<code class="cm">Internal helper for `PartialDeep`.</code>&#13;
<code class="cm">*/</code>&#13;
<code class="kr">type</code> <code class="nx">PartialReadonlySetDeep</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Options</code> <code class="kr">extends</code> <code class="nx">PartialDeepOptions</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="p">{}</code> <code class="o">&amp;</code> <code class="nx">ReadonlySet</code><code class="o">&lt;</code><code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Options</code><code class="o">&gt;&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="cm">/**</code>&#13;
<code class="cm">Same as `PartialDeep`, but accepts only `object`s as inputs.</code>&#13;
<code class="cm">Internal helper for `PartialDeep`.</code>&#13;
<code class="cm">*/</code>&#13;
<code class="kr">type</code> <code class="nx">PartialObjectDeep</code><code class="o">&lt;</code>&#13;
  <code class="nx">ObjectType</code> <code class="kr">extends</code> <code class="nx">object</code><code class="p">,</code>&#13;
  <code class="nx">Options</code> <code class="kr">extends</code> <code class="nx">PartialDeepOptions</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">KeyType</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">ObjectType</code><code class="p">]</code><code class="o">?:</code> <code class="nx">PartialDeep</code><code class="o">&lt;</code><code class="nx">ObjectType</code><code class="p">[</code><code class="nx">KeyType</code><code class="p">],</code> <code class="nx">Options</code><code class="o">&gt;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>There is no need to go through the entirety of this implementation, but it should give you an idea about how hardened their implementations for certain utility types are.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>PartialDeep&lt;T&gt;</code> is extensive and deals with all possible edge cases, but it also comes at a cost of being complex and hard to swallow for the TypeScript type-checker. Depending on your use case, the simpler version from <a data-type="xref" href="#ch08_nested_objects">Recipe 8.2</a> might be the one you’re looking for.<a data-startref="ix_08-07-asciidoc4" data-type="indexterm" id="id805"/><a data-startref="ix_08-07-asciidoc3" data-type="indexterm" id="id806"/></p>&#13;
</div>&#13;
&#13;
<p>Third, they don’t add helper types just for the sake of adding them. Their <em>Readme</em> file has a list of declined types and the reasoning behind the decline: either the use cases are limited or better alternatives exist. Just like everything, they document their choices really, really well.</p>&#13;
&#13;
<p>Fourth, <em>type-fest</em> educates about existing helper types. Helper types have existed in TypeScript forever but barely have been documented in the past. Years ago, <a href="https://oreil.ly/eRtx9">my blog</a> attempted to be a resource on built-in helper types, until the <a href="https://oreil.ly/K5cXq">official documentation added a chapter on utility types</a>. Utility types are not something that you easily pick up just by using TypeScript. You need to understand that they exist and need to read up on them. <em>type-fest</em> has an entire section dedicated to built-ins, with examples and use cases.</p>&#13;
&#13;
<p>Last, but not least, it’s widely adopted and developed by reliable open source developers. Its creator, <a href="https://oreil.ly/thSin">Sindre Sorhus</a>, has worked on open source projects for decades and has a track record of fantastic projects. <em>type-fest</em> is just another stroke of genius. Chances are a lot of your work relies on his work.</p>&#13;
&#13;
<p>With <em>type-fest</em> you get another resource of helper types you can add to your project. Decide for yourself if you want to keep a small set of helper types or if you rely on the implementations by the community.<a data-startref="ix_08-07-asciidoc2" data-type="indexterm" id="id807"/><a data-startref="ix_08-07-asciidoc1" data-type="indexterm" id="id808"/><a data-startref="ix_08-07-asciidoc0" data-type="indexterm" id="id809"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>