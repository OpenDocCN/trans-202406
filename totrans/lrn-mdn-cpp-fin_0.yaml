- en: Chapter 1\. An Overview of C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before launching into programming in C++, it will be useful to present a brief
    overview of the language the C++ Standard Library, and the ways in which C++ continues
    to have a major presence in quantitative finance.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already felt intimidated by opinions and rumors claiming that C++
    is extraordinarily difficult to learn and fraught with minefields. So, in this
    chapter, we will try to allay these fears by first debunking some of the common
    myths about C++, and then presenting straightforward examples to help you get
    up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the content here is likely familiar for most readers, but the discussion
    here attempts to extend some of the basics with points about quantitative programming
    and best practices that often are not included in introductory books. We will
    also have our first look at C++20, namely mathematical constants that have been
    added to the C++ Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you should be able to write, compile, and run simple
    C++ programs, understand basic numerical types, and employ mathematical functions
    in the Standard Library that are fundamental in just about any quantitative discipline,
    including finance.
  prefs: []
  type: TYPE_NORMAL
- en: C++ and Quantitative Finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ started its rapid growth in the financial sector around the mid-1990’s.
    Many of us who were in the industry around this time had been raised on FORTRAN,
    particularly for writing numerical routines and scientific applications. While
    FORTRAN and its supporting libraries were very well-developed in terms of mathematical
    and linear algebra support, it lacked support for object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Financial modeling in the abstract is naturally comprised of different components
    that interact with each other. For example, to price even a simple derivative
    contract based on foreign exchange and interest rates, one would typically require
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The term structure of interest rates for each currency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A market rate feed of live foreign exchange rate quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volatility curves or surfaces for movements in FX rates and interest rates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of pricing methods, eg closed form, simulation, or other numerical approximations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these components can be represented by an *object*, and C++ provided
    the means for creating these objects and managing their relationships to each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Banks and other financial institutions also needed a way to calculate risk measures
    at both a regional and global scale. This was a particular challenge for companies
    with trading operations spread across the major financial centers of New York,
    London, and Tokyo, as well as other capital markets. At the start of each trading
    day, risk reporting was required for a firm’s headquarters in, say, New York that
    took into account the portfolios maintained both locally and around the world.
    This could be a computationally intensive task, but the performance of C++ made
    it possible and was yet another significant factor in its early adoption in the
    financial industry.
  prefs: []
  type: TYPE_NORMAL
- en: Around the turn of the century, newer object-oriented languages, such as Java
    and C#, made software development a relatively simpler and faster process, while
    more efficient processors became less expensive. However, the same features in
    these languages that enabled quicker deployment, such as built-in managed memory
    and intermediate compilation, could also introduce overhead in terms of run-time
    performance. Management decisions on which language to adopt often came down to
    a trade-off between more rapid development and run-time efficiency. Even if one
    of these language alternatives was employed, computationally intensive pricing
    models and risk calculations were -- and still are -- often delegated to existing
    C++ libraries and called via an interface. It should also be noted that C++ also
    offers certain compile-time optimizations that are not available in these other
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ 11: The Modern Era is Born'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2011, the [Standard C++ Foundation](https://isocpp.org) released a substantial
    revision that addressed long-needed modernization and in particular provided some
    very welcome abstractions that are immediately useful to quantitative developers.
    These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Random number generation from a variety of probability distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions that encapsulate mathematical functions that can also be
    passed as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task-based concurrency that can parallelize computations without the need for
    manual thread management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart pointers that prevent memory-related program crashes, without affecting
    performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These topics and more will be discussed in the chapters ahead. An excellent
    reference that covers the history and evolution of C++ into the modern era is
    also available from O’Reilly: *C++* *Today: The Beast is Back*, by Jon Kalb and
    Gasper Azman [1]. It should also be noted that with more attention to, and promotion
    of [best practices](https://isocpp.org/wiki/faq/coding-standards)[1] and [guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)[2]
    by the ISO C++ committee, cross-platform development is now a much easier task
    than in years past.'
  prefs: []
  type: TYPE_NORMAL
- en: And following C++11, new releases with more and more modern features addressing
    the demands of financial and data science industries are being rolled out on a
    threeyear cadence, with the most recent release being C++20\. This book will primarily
    cover developments through C++20, particularly those that should be of interest
    to financial quant developers. Proposals currently in the works for future standards
    are also mentioned where relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Proprietary and high-frequency trading firms have been at the forefront of adopting
    the C++11 Standard and later, where the speed of acting on market and trading
    book signals in statistical strategies can mean a profound difference in profit
    and loss. Modern C++ is also in keen demand for derivatives pricing models utilized
    by traders and risk managers at investment banks and hedge funds. The recent random
    number generation and concurrency features in the Standard Library, for example,
    provide built-in support for efficient Monte Carlo simulation that is a key component
    in both evaluating trading strategies and pricing complex exotic options. These
    tasks used to require many more hours of distributional random number generation
    code development and time-consuming integration of platform-dependent threading
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Open Source Mathematical Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another very welcome development over the past decade has been the proliferation
    of robust open-source mathematical libraries written in standard C++ that therefore
    do not require the time-consuming C-language interface gymnastics of the past.
    Primary among these are the Boost libraries, the Eigen and Armadillo matrix algebra
    libraries, and machine learning libraries such as TensorFlow and PyTorch. We will
    cover Boost and Eigen in more detail later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Debunking Myths About C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a multitude of myths about C++. Here are several of the more infamous
    beliefs, and explanations which debunk them.
  prefs: []
  type: TYPE_NORMAL
- en: '*Knowledge of C is necessary for learning C++*: While the C++ Standard retains
    most of the C language, it is entirely possible to learn C++ without knowledge
    of C, as we shall see. Clinging to C style can in fact hinder learning the powerful
    abstractions and potential benefits of C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ is too difficult*: There is no doubt that C++ is a rich language that
    provides plenty of the proverbial rope with which one can hang oneself, but by
    leveraging _modern_ features of the language while holding legacy issues in abeyance
    at the outset, it is entirely possible to become very productive as a quantitative
    developer in C++ very quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Memory leaks are always a problem in* *C++*: With smart pointers available
    since C++11, this no longer needs to be an issue in most financial model implementations,
    as we shall see.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiled vs Interpreted Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As alluded to above, C++ is a compiled language, where commands typed into a
    file by us mere mortals are translated into binary instructions, or *machine code*,
    that a computer processor will understand. This is in contrast to non-typed and
    interpreted quantitative languages such as Python, R, and Matlab, where each line
    of code must be individually translated to machine code at run-time, thus slowing
    down execution time for larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: This is by no means a knock on these languages, as their power is evident in
    their popularity for rapid implementations of models arising in quantitative fields
    such as finance, data science, and biosciences, with their built-in mathematical
    and statistical functions are often compiled in C, C++, or FORTRAN. However, the
    financial world at least is replete with stories where a model would require days
    to run in an interpreted language, where run times could be reduced to a matter
    of minutes when reimplemented in C++.
  prefs: []
  type: TYPE_NORMAL
- en: An effective approach is to use interpreted mathematical languages with C++
    in a complementary fashion. For example, when computationally intensive models
    code is written in a C++ library, and then called either interactively or from
    an application in R, for example, C++ efficiently takes care of the number crunching.
    The results can then be used inside powerful plotting and other visualization
    tools in R that are not available in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage is that the models code is written once and maintained in
    a C++ library that can be deployed across many different departments, divisions,
    and even international boundaries, and called via interfaces from applications
    in written in different front-end languages, while ensuring consistent numerical
    results throughout the organization. This can be particularly advantageous for
    regulatory compliance purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Popular open-source C++ packages are available for both R and Python, namely
    [Rcpp](http://www.rcpp.org/) and [pybind11](https://github.com/pybind/pybind11),
    respectively. Matlab also provides options for C++ interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The Components of C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Standard C++ releases, at a high level, consist of two components: language
    features, and the C++ Standard Library. A software library is essentially a set
    of functions and classes that are not executable on their own but that are called
    by an application or system. Library development -- both open source and commercial
    -- now dominates modern C++ development compared to standalone applications that
    were popular in previous decades, and we will discuss some of those later that
    are useful for computational work. The most important C++ library is the Standard
    Library that is shipped with modern compilers.'
  prefs: []
  type: TYPE_NORMAL
- en: C++ Language Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++ language features mostly overlap with the essential operators and constructs
    one would find in other programming languages, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental integer and floating-point numerical types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conditional branching: `if/else if/else` statements and switch/case statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iterative constructs: for loops and `while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Standard mathematical variable types: integer, double precision floating point,
    etc'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Standard mathematical and logical operators for numerical types: addition,
    subtraction, multiplication, division, modulus, and inequalities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, C++ is not limited to object-oriented programming; rather, the
    language also supports the other three major programming paradigms, namely procedural
    programming, generic programming, and functional programming. Each of these will
    be discussed in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ is a strongly-typed language, meaning that before we use a variable, we
    must declare it by its type. The language provides a variety of numerical types;
    however, those that we will primarily use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description | Minimum Value | Maximum Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| double | Double Precision | +/- 2.2e-308 | +/- 1.8e308 |'
  prefs: []
  type: TYPE_TB
- en: '| int | Integer | -2,147,483,648 | 2,147,483,647 |'
  prefs: []
  type: TYPE_TB
- en: Others, such as unsigned and extended integer types, will be introduced later
    when we need them.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ Standard Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As Nicolai Josuttis describes it in his indispensable text, *The C++ Standard
    Library - A Tutorial and Reference, 2nd Edition*[3], the C++ Standard Library
    “enable(s) programmers to use general components and a higher level of abstraction
    without losing portability rather than having to develop all code from scratch.”
    Up through the latest C++20 release, highly useful library features for quantitative
    model implementations include:'
  prefs: []
  type: TYPE_NORMAL
- en: Array-style containers, particularly the venerable `vector` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wide set of standard algorithms that operate on these array containers, such
    as sorting, searching, and efficiently applying functions to a range of elements
    in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard real-valued mathematical functions such as square root, exponential,
    and trigonometric functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex numbers and arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random number generation from a set of standard probability distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task-based concurrency that manages threads internally and safely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart pointers that abstract away the dangers associated with memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class to store and manage character data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming functions to take input from and display results to the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of Standard Library components, however, requires the programmer to explicitly
    import them into the code, as they reside in a separate library rather than within
    the core language. The idea is similar to importing a NumPy array into a Python
    program or loading an external package of functions into an R script. In C++,
    this is a two-step process, starting with loading the file containing the Standard
    Library declarations of functions and classes we wish to use, and then scoping
    these functions with the Standard Library namespace name, `std` (often pronounced
    as “stood” by C++ developers).
  prefs: []
  type: TYPE_NORMAL
- en: Compilers and IDE’s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get started with learning C++, you will need to obtain a compiler
    and a development environment. The three major modern and freely available compilers,
    which ship with their implementations of the C++ Standard Library, are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Microsoft Visual Studio 2019 compiler](https://visualstudio.microsoft.com/vs/features/cplusplus/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Clang (LLVM Project)](https://clang.llvm.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GNU gcc compiler](https://gcc.gnu.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also several integrated development environments (IDE’s) available,
    namely Visual Studio, Apple’s Xcode (which ships with the Clang compiler), and
    CLion, a product that typically requires purchase from JetBrains. For this book,
    Microsoft’s Visual Studio compiler and IDE are highly recommended. They are user-friendly
    options to get up and running quickly on C++, with very powerful debugging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the Visual Studio option also includes a Clang option that allows
    a programmer to switch between it and the Microsoft compiler, helping to ensure
    cross-platform compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the Visual Studio option for C++ only exists for Windows, as
    the Mac version does not ship with a C++ option. In this case, one might opt for
    downloading Apple’s Xcode, which ships with the Clang compiler. Linux users will
    typically want to opt for the gcc or Clang compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Review of C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following will be a quick review of C++ using some simple code examples.
    We will also have our first look at a new feature in C++20, namely mathematical
    constants.
  prefs: []
  type: TYPE_NORMAL
- en: Good Old “Hello World!”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, here is a “Hello World!” example to get started. The following code
    will return the message to the screen, and then allow the user to input the name
    of someone to whom to say hello:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to say hello to your mother, then after compiling and running the
    code, the screen would resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The main review points here are
  prefs: []
  type: TYPE_NORMAL
- en: '`cout` and `cin`, along with the string class, depend upon including the C++
    Standard Library declaration files iostream and string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Members of the Standard Library need to be scoped by their namespace `std`.
    An alternative is to put `using` statements with the namespace scopes at the top
    of the file, indicating that anytime these elements appear in the code, they are
    understood to be coming from the std namespace. Also, you may find it easier to
    type `endl` (end of line) rather than ''\n’:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Importing the std namespace into the global namespace with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: is sometimes used to replace the individual using statements; however, this
    is not considered good practice, as it can result in naming clashes at compile
    time. The motivation behind namespaces will be presented in Chapter 3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Output to and input from the console is almost never used in production-level
    financial programming. User input data will typically come from graphical user
    interfaces (GUIs) or web applications, while market data usually comes from live
    feeds. Results are typically displayed in the user interface and then stored in
    a database, such as when a trade in executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use `cout` and `cin` to sometimes mimic these inputs, but they should
    be avoided in production code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple Procedural Programming in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The structure of a procedural program should be familiar, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: A `main()` function, which is called first in execution of a program, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of user-defined functions that contain individual tasks that comprise
    the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the simplest case, these can all be written in a single executable file containing
    `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: We first *declare* each user-defined function in a function *declaration* statement,
    prior to the start of program execution in the `main()` function. A function declaration
    states its name, return type, and input argument types, followed by a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: The function *implementations* are written beneath `main()`, each containing
    a series of commands within open and closed braces. User-defined function calls
    can then be made within the `main` function, or from other user-defined functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Single line comments are indicated by two consecutive forward slashes. The
    high-level format is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For larger and more robust production applications, we will soon look at writing
    functions in separate *modules*, using a new feature in C++20, in which the same
    method of declaring and implementing functions will carry over.
  prefs: []
  type: TYPE_NORMAL
- en: Further details on functions follow in the next two subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ functions may or may not return a value; furthermore, they may or may not
    take input arguments. A function that has no return value is indicated by a `void`
    return type. For example, if we move our “Hello World” example into a separate
    function, it would simply output a message to the screen without returning a value
    when called from the `main` function, so it would be declared as a `void` function.
    In addition, it does not require any input parameters, so its declaration would
    take on the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, suppose we want to write a real-valued function that takes in a single
    variable and returns twice its value. In this case, our declaration will have
    a double precision floating type return, indicated by `double`, and an input of
    the same type. If we name this function `twice_a_real`, and the input variable
    `x`, our declaration would be written as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As a final example, as in other programming languages, a function can take in
    more than one variable. Suppose we wish to add three integers in a function called
    `add_three_ints` and return the sum of variables `i`, `j`, and `k`. Integer types
    are indicated by `int`, so our function declaration would be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Function implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function implementations, also called function *definitions*, are where we implement
    the actual commands to display a message to the screen, calculate a mathematical
    result, or to perform other tasks. The *body* of the function is placed inside
    braces, as shown here for the `hello_world` function. We again need to indicate
    the `void` return type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can write the implementations of our two simple mathematical functions.
    As in their declarations, the `double` and `int` return types, respectively, as
    well as the types of their input variables, must be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, we initialize a new `double` variable `y` and with the result
    of the calculation. Because C++ is a strongly typed language, we need to indicate
    the type of a variable when it is initialized. This variable is then returned
    to the `main` function with the result. In the second function, we just put the
    sum operations in the return statement itself; this is also perfectly legal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we put this all together with a `main` function that is called when
    the program starts and makes calls to our user-defined functions. It goes in between
    the user-defined function declarations and their implementations below, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: C++ Syntax and Style Guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section a review of essential C++ syntax is provided, along with guidelines
    on code formatting and variable naming. The guidelines discussion might not be
    high on many people’s priority list, but this topic is in fact quite important
    when writing critical production code in financial systems, in a feature-rich
    language such as C++. Bugs, runtime errors, and program crashes are much more
    easily avoided or addressed if the source code is written in a clean and maintainable
    state.
  prefs: []
  type: TYPE_NORMAL
- en: We will review essential rules about C++ syntax. Even if you are familiar with
    some of it already, a summary will be presented in one place that you may find
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Code Blocks in Braces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function implementations, also called *function definitions*, are placed inside
    braces, as shown in each of the function implementations in 6.2.2 above. When
    control reaches the closing brace, the function terminates. This is also true
    for other code blocks such as in conditional statements, loops, user-defined functions,
    and user-defined classes. When the closing brace is encountered, non-static local
    variables and objects defined within the block are said to _go out of scope_.
    That is, they are wiped from memory and no longer accessible. Pointers can be
    an exception to this rule, but we will discuss this in more detail in Chapter
    XX.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax Review
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Commands and declarations in C++ terminate with a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, as C++ is a strongly-typed language, numerical variable types should
    be indicated before initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: C++11 introduced the `auto` keyword that can automatically deduce a variable
    or object type, as well as uniform initialization (with braces). Varied opinions
    on their use exist, but many programmers still prefer to explicitly state plain
    old data (POD) types such as `int` and `double` to avoid ambiguity. This will
    be the style followed in this book. `auto` and uniform initialization will be
    discussed later within contexts where they tend to be more useful.
  prefs: []
  type: TYPE_NORMAL
- en: One-line comments are indicated with two forward slashes, eg,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple lines of comments in a block can also be commented out, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no difference to the compiler between a single space or multiple spaces;
    for example, despite the variations in whitespace, the following code is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A well-known mantra in programming, however, and particularly relevant to C++,
    is *just because you can do something, doesn’t mean you should*. The above code
    will be more readable and maintainable if written with clear and consistent spacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Again, for more realistic and complex code, this mantra should be kept in mind.
    It will be a recurring theme throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Code may also be continued onto multiple lines without the use of a continuation
    character, and vertical spaces are ignored. Returning to our previous example,
    writing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: would yield the same result. As before, the preceding example, with uniform
    spacing and each command placed in a single line, would be preferable. However,
    it should be noted that, in quantitative programming where complex and nested
    calculations are involved, it often becomes highly advisable to split up formulae
    and algorithms on multiple lines for clarity and code maintainability. We will
    see examples of this in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, C++ syntax is *case sensitive*. For example, two `double` variables
    `x` and `X` would be as different as two other variables `kirk` and `spock`. The
    same applies to function names. In examples above, we used the Standard Library
    function `std::cout`. Attempting to write `std::Cout` instead would trigger a
    compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variable, function, and class names can be any contiguous combination of letters
    and numbers, subject to the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Names must begin with a letter or an underscore; leading numerals are not allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than the underscore character, special characters, such as `@`, `=`, `$`
    etc are not allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spaces are not allowed. Names must be contiguous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language keywords are not allowed in naming, such as `double`, `if`, `while`,
    etc. A complete listing can be found on https://en.cppreference.com/w/cpp/keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum name length is compiler-dependent, and in at least one case – the
    GNU gcc compiler – imposes no limitation; however, see the *mantra* discussed
    above.
  prefs: []
  type: TYPE_NORMAL
- en: Single letter variable and function names are fine for simple examples and plain
    mathematical functions. However, for quantitative models, it will usually be better
    to pass function arguments with more descriptive names. Function and class names
    as well should also provide some indication of what they do.
  prefs: []
  type: TYPE_NORMAL
- en: Several naming styles have been common over the years, namely
  prefs: []
  type: TYPE_NORMAL
- en: 'Lower Camel case; eg, `optionDelta`, `riskFreeRate`, `efficientFrontier`: Letter
    of first word in lower case, and following words capitalized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upper Camel, aka Pascal case; eg, `OptionDelta`, `RiskFreeRate`, `EfficientFrontier`:
    Letter of each word is in upper case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Snake case; eg, `option_delta`, `risk_free_rate`, `efficient_frontier`: Each
    word begins with lower case, separated by an underscore character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower Camel and Snake cases are the most typical of what is found in C++ function
    and variable names, and class names are usually in Upper Camel form. In recent
    years – likely propelled by [Google’s C++ Style Guide](https://google.github.io/styleguide/cppguide.html=General_Naming_Rules)
    [5] – variable and function names have gravitated more toward the snake case.
    As such, we will adopt this convention in this book, and use Upper Camel for class
    names.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where single characters are used for integral counting variables, it
    is still common to use the FORTRAN convention of letters `i` through `n`, although
    this is not required. We will also adopt this practice.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Operators, Functions, and Constants in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the previous discussion was loads of fun, our focus in this book is on
    math and finance. We have already used the mathematical operators for addition
    and multiplication of built-in C++ numerical types above. These are language features
    in C++, and a comprehensive discussion of these standard operators follows. Common
    mathematical functions, however -- such as cosine, exponential, etc -- are provided
    in the C++ Standard Library rather than in the core language.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Arithmetic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As suggested in the examples above, addition, subtraction, multiplication,
    and division of numerical types are provided in C++ with the operators `+`, `-`,
    `*`, and `/`, respectively, as usually found in other programming languages. In
    addition, the modulus operator, `%`, is also included. Examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The order and precedence of arithmetic operators are the same as found in most
    other programming languages, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Order runs from left to right:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using the above integer values would result in 8 + 5 - 2 = 11
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplication, division, and modulus take precedence over addition and subtraction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using the above double precision values would result in 30.6 + 2.0 = 32.6
  prefs: []
  type: TYPE_NORMAL
- en: 'Use round brackets to change the precedence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This would yield ![](Images/1.1.png)
  prefs: []
  type: TYPE_NORMAL
- en: with the same double precision values.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Functions in the Standard Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of the usual mathematical functions one finds in other languages have
    the same or similar syntax in C++. Functions commonly used in computational finance
    include the following, where `x` and `y` are assumed to be double precision variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `cos(x)` | cosine of *x* |'
  prefs: []
  type: TYPE_TB
- en: '| `sin(x)` | sine of *x* |'
  prefs: []
  type: TYPE_TB
- en: '| `tan` | tangent of *x* |'
  prefs: []
  type: TYPE_TB
- en: '| `exp` | exponential function *e^x* |'
  prefs: []
  type: TYPE_TB
- en: '| `log` | natural logarithm *ln(x)* |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrt` | square root of *x* |'
  prefs: []
  type: TYPE_TB
- en: '| `cbrt` | cube root of *x* |'
  prefs: []
  type: TYPE_TB
- en: '| `pow` | *x* raised to the power of *y* |'
  prefs: []
  type: TYPE_TB
- en: '| `hypot` | computes ![](Images/1.2.png) for two numerical values x and y |'
  prefs: []
  type: TYPE_TB
- en: 'As these are contained in the Standard Library rather than as language features.
    The `cmath` header file should always be included, with the functions scoped by
    the `std::` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, if you don’t feel like typing out `std::` all the time, putting `using`
    statements after the `include` statement are also fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can also now write our first finance example. We want to price a zero coupon
    bond
  prefs: []
  type: TYPE_NORMAL
- en: Ae^(-rt)
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: A = the face value of the bond,
  prefs: []
  type: TYPE_NORMAL
- en: r is the interest rate, and
  prefs: []
  type: TYPE_NORMAL
- en: t is the time to maturity as a year fraction.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, we could then write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For a more comprehensive list of Standard Library math functions, again see
    Josuttis, *The C++ Standard Library (2E)*[4], Section 17.3, or the listing available
    on [the CppReference website](https://en.cppreference.com/w/cpp/numeric/math)
    [6]. Both are indispensable references for any modern C++ developer and are highly
    recommended advanced complementary resources for this book. Some additional guidance
    on the use of Standard Library math functions follows in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: There is No Power Operator in C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike other languages, where an exponent is typically indicated by a `^` or
    a `**` operator, this does not exist as a C++ language feature. Instead, one needs
    to call the Standard Library `std::pow` function in `cmath`. When computing polynomials,
    however, it is more efficient to apply factoring per Horner’s Method and reduce
    the number of multiplicative operations[6]. For example, if we wish to implement
    a function
  prefs: []
  type: TYPE_NORMAL
- en: it would be preferable to write it in C++ as
  prefs: []
  type: TYPE_NORMAL
- en: '*f(x)* = 8*x*⁴ + 7*x*³ + 4*x*²- 10^x - 6'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: rather than
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For the case of a non-integer exponent, say
  prefs: []
  type: TYPE_NORMAL
- en: '*g(x,y)* = *x*^(-1.368*x*) + 4.19*y*'
  prefs: []
  type: TYPE_NORMAL
- en: 'then there is no alternative but to use `std::pow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '` < cmath >` Ensures Consistency Across Compilers'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It may be the case that you can use these math functions without `#include <cmath>`,
    but one should adhere to including `cmath` and scoping the functions with `std::`.
    First, because C++ is built upon C, some compilers retain the old math functions
    from C in what is called the *global namespace*. Other compilers, however, might
    put `cmath` into the global namespace. As a result, one might actually be calling
    old C functions rather than the ISO C++ Standard versions, and this could cause
    unexpected or inconsistent behavior among different compilers.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of inconsistencies that can arise is with the absolute value
    function. In C, and on older C++ compilers, the `abs` function was only implemented
    for integer types. In order to calculate the absolute value of a floating point
    number, one would need to use the `fabs` function. However, `std::abs` is overloaded
    for both integer and floating point (eg `double`) arguments and should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is unfortunately one of the quirks in C++ due to its long association
    with C; however, the moral of the story is quite simple: to keep C++ code ISO-compliant,
    we should always put `#include <cmath>`, and scope the math functions with `std::`.
    This will help ensure cross-compatibility on different compilers and operating
    system platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note: Regarding C headers and namespace std, this is clarified, for example,
    in the specifications for the gcc compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The standard specifies that if one includes the C-style header (<**math.h**>
    in this case), the symbols will be available in the global namespace and perhaps
    in namespace* *std::* *(but this is no longer a firm requirement.) On the other
    hand, including the C++-style header (<**cmath**>) guarantees that the entities
    will be found in namespace std and perhaps in the global namespace*.[8]'
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any type of quantitative programming, there is often a need to use constant
    values in calculations. In C++, one can define a constant by simply appending
    the keyword `const` when a value is assigned. Furthermore, beginning with C++20,
    a set of commonly used mathematical constants is now available.
  prefs: []
  type: TYPE_NORMAL
- en: The `const` Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a variable doesn’t change value, it is safer to declare it as a constant
    type, by using the `const` keyword. For example, we could use it to store an approximation
    of earth’s gravitational acceleration constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if later within the same scope someone attempted to reassign it to a
    different value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: a compiler error would result, with a message indicating an attempt was made
    to modify the value of a constant. Catching errors at compile time is better than
    chasing them at runtime and tracking down the cause, especially in a live production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: '`const` also has other important uses and interesting properties that we will
    cover later, particularly in an object-oriented programming context.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard Library Mathematical Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A handy addition to the C++ 20 Standard Library is a set of commonly used mathematical
    constants, such as the values of ![](Images/1.3.png), *e*, ![](Images/1.4.png),
    etc. Some of those that are convenient for quantitative finance are shown in the
    following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| C++ constant | `e` | `pi` | `inv_pi` | `inv_sqrt_pi` | `sqrt2` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Definition | *e* | ![](Images/1.3.png) | ![](Images/1.5.png) | ![](Images/1.6.png)
    | ![](Images/1.4.png) |'
  prefs: []
  type: TYPE_TB
- en: To use these constants, one must first include the `numbers` header in the Standard
    Library. At the time of this writing, each must be scoped with the `std::numbers`
    namespace. For example, to implement the function
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1.7.png)'
  prefs: []
  type: TYPE_IMG
- en: we could write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This way, whenever ![](Images/1.3.png)is used in calculations for example, its
    value will be consistent throughout the program, rather than leaving it up to
    different programmers on a project who might use approximations out to varying
    precisions, resulting in possible consistencies in numerical results.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the value of ![](Images/1.4.png), which can crop up somewhat frequently
    in mathematical calculations, does not have to be computed with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: each time it is needed. The constant
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: holds the double precision approximation itself. While perhaps of trivial consequence
    in terms of one-off performance, repeated calls to the `std::sqrt` function millions
    of times in computationally intensive code could potentially have some effect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While not essential to know at this point, it is worth at least mentioning that
    these constants are set at *compile time* rather than runtime, using a C++11 designation
    called `constexpr`. This ties in with the much broader and more advanced subject
    of *template metaprogramming*, in which calculations of constant values to be
    used at runtime are performed at compile time. [[Might return to this topic later,
    although it is of limited used in financial modeling where the computations depend
    on data only available at runtime]].
  prefs: []
  type: TYPE_NORMAL
- en: As a closing note, it is somewhat curious that the set of mathematical constants
    provided in C++20 include the value ![](Images/1.8.png), but not ![](Images/1.9.png)or
    ![](Images/1.10.png), despite the latter two being more commonly present in statistical
    calculations. [[See later chapter on the Boost libraries – they are included there]].
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concludes our whirlwind overview of C++. We emphasized quantitative programming,
    along with the mathematical constants now included in C++20.
  prefs: []
  type: TYPE_NORMAL
- en: Our coverage of best practices with respect to coding style will be a consistent
    theme throughout the book, as C++ is an extremely feature-rich language with plenty
    of the proverbial rope with which to hang oneself. Adhering to best practices
    and consistent coding style is vital to ensure code maintainability and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: One other point to remember is that while we use a lot of screen output and
    input, this is not how C++ is typically used in quantitative development. `std::cout`,
    and `std::cin` should be thought as placeholders for real-world interfaces. We
    will continue to use them as devices to check our results, but they will mostly
    be relegated to use within the test functions that are called from `main()`, rather
    than within mathematical and models code itself where they should be avoided in
    practice anyway.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] Kalb and Azman, *C++* *Today: The Beast is Back*, available on [https://resources.jetbrains.com/storage/products/cpp/books/Cplusplus_Today.pdf](https://resources.jetbrains.com/storage/products/cpp/books/Cplusplus_Today.pdf)
    (link)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] [Guideline Support Library (ISO)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
    (link)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] [ISO C++ Coding Standards](https://isocpp.org/wiki/faq/coding-standards)
    (link)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Nicolai Josuttis, [*The C++ Standard Library (2E)*](http://www.cppstdlib.com)
    (link)'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] Google C++ Style Guide (https://google.github.io/styleguide/cppguide.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] cppreference.com'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] Stepanov, Mathematics of Generic Programming (Horner’s Method)'
  prefs: []
  type: TYPE_NORMAL
- en: '[8] GNU gcc Compiler Documentation'
  prefs: []
  type: TYPE_NORMAL
- en: (https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_headers.html
  prefs: []
  type: TYPE_NORMAL
