<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. Efficiency at the Keyboard"><div class="chapter" id="ch_context_switching">
<h1><span class="label">Chapter 10. </span>Efficiency at the Keyboard</h1>


<p>On a typical day, on a typical Linux workstation, you might have many<a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="about" id="idm46586637548736"/>
application windows open: web browsers, text editors, software
development environments, music players, video editors, virtual
machines, and so on. Some applications are GUI-focused, such as a
paint program, and tailored to a pointing device like a mouse or
trackball. Others are more keyboard-focused, like a shell inside a
terminal program. A typical Linux user might shift between keyboard
and mouse dozens (or even hundreds) of times per hour. Each switch
takes time. It slows you down. If you can reduce the number of
switches, you can work more efficiently.</p>

<p>This chapter is about spending more time at the keyboard and less with
a pointing device. Ten fingers tapping one hundred keys are often more
nimble than a couple of fingers on a mouse. I’m not just talking about
using keyboard shortcuts—I’m confident you can look them up without
needing this book (though I present a few). I’m talking about a
different approach to speed up some everyday tasks that seem
inherently “mousey”: working with windows, retrieving information from
the web, and copying and pasting with the clipboard.</p>






<section data-type="sect1" data-pdf-bookmark="Working with Windows"><div class="sect1" id="idm46586637547248">
<h1>Working with Windows</h1>

<p>In this section, I share tips for launching windows
efficiently, particularly shell windows (terminals) and browser
windows.</p>








<section data-type="sect2" data-pdf-bookmark="Instant Shells and Browsers"><div class="sect2" id="section_popup">
<h2>Instant Shells and Browsers</h2>

<p><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="terminal shell launch" id="idm46586637544256"/><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="web browser" data-tertiary="new window" id="idm46586637542976"/><a data-type="indexterm" data-primary="keyboard shortcuts" data-secondary="terminal shell launch" id="idm46586637541792"/><a data-type="indexterm" data-primary="keyboard shortcuts" data-secondary="web browsers" data-tertiary="window opened" id="idm46586637540848"/><a data-type="indexterm" data-primary="terminal program" data-secondary="keyboard shortcut  to launch" id="idm46586637539632"/><a data-type="indexterm" data-primary="shell" data-secondary="new window via keyboard shortcut" id="idm46586637538720"/><a data-type="indexterm" data-primary="web browser" data-secondary="keyboard shortcuts" data-tertiary="new window" id="idm46586637537808"/><a data-type="indexterm" data-primary="browser" data-see="web browser" id="idm46586637536592"/><a data-type="indexterm" data-primary="keyboard shortcuts" data-secondary="defining custom" id="idm46586637535648"/>
Most Linux desktop environments,<a data-type="indexterm" data-primary="desktop environment" data-secondary="keyboard shortcuts" id="idm46586637534576"/> such as GNOME<a data-type="indexterm" data-primary="GNOME" id="idm46586637533504"/>, KDE Plasma<a data-type="indexterm" data-primary="KDE Plasma" id="idm46586637532672"/>, Unity<a data-type="indexterm" data-primary="Unity" id="idm46586637531840"/>, and
Cinnamon<a data-type="indexterm" data-primary="Cinnamon" id="idm46586637531008"/>, provide some way to define hotkeys<a data-type="indexterm" data-primary="hotkeys" data-see="keyboard shortcuts" id="idm46586637530176"/>  or custom keyboard
shortcuts—special keystrokes that launch commands or perform other
operations. I strongly recommend that you define keyboard shortcuts
for these common operations:</p>

<ul>
<li>
<p>Opening a new shell window (a terminal program)</p>
</li>
<li>
<p>Opening a new web browser window</p>
</li>
</ul>

<p>With these shortcuts defined, you can open a terminal or browser
anytime in an instant, no matter what other application you’re in the
middle of using.<sup><a data-type="noteref" id="idm46586637526832-marker" href="ch10.xhtml#idm46586637526832">1</a></sup>
To set this up, you need to know the following:</p>
<dl>
<dt>The command that launches your preferred terminal program</dt>
<dd>
<p>Some
popular ones are <code>gnome-terminal</code>,<a data-type="indexterm" data-primary="gnome-terminal command" id="idm46586637523552"/> <code>konsole</code>,<a data-type="indexterm" data-primary="konsole command" id="idm46586637522272"/> and <code>xterm</code>.<a data-type="indexterm" data-primary="xterm command" id="idm46586637520992"/></p>
</dd>
<dt>The command that launches your preferred browser</dt>
<dd>
<p>Some popular ones
are <code>firefox</code>,<a data-type="indexterm" data-primary="firefox command" id="idm46586637518464"/> <code>google-chrome</code>,<a data-type="indexterm" data-primary="google-chrome command" id="idm46586637517184"/><a data-type="indexterm" data-primary="Chrome" data-see="google-chrome command" id="idm46586637516448"/> and <code>opera</code>.<a data-type="indexterm" data-primary="opera command" id="idm46586637514960"/></p>
</dd>
<dt>How to define a custom keyboard shortcut</dt>
<dd>
<p>The instructions differ
for each desktop environment and may change from version to version,
so it’s better if you look them up on the web. Search for the name of
your desktop environment followed by “define keyboard shortcut.”</p>
</dd>
</dl>

<p>On my desktop, I assign the keyboard shortcut Ctrl-Windows-T to run
<code>konsole</code> and Ctrl-Windows-C to run <code>google-chrome</code>.</p>
<div data-type="note" epub:type="note"><h1>Working Directories</h1>
<p>When you launch a shell via a keyboard shortcut in your desktop<a data-type="indexterm" data-primary="current directory" data-secondary="new shell window" id="idm46586637510144"/><a data-type="indexterm" data-primary="directory" data-secondary="current" data-tertiary="new shell window" id="idm46586637509168"/><a data-type="indexterm" data-primary="shell" data-secondary="child shell" id="idm46586637507952"/><a data-type="indexterm" data-primary="child shell" id="idm46586637507008"/>
environment, it’s a child of your login shell. Its current directory
is your home directory (unless you’ve somehow configured it to be
different).</p>

<p>Contrast this with opening a new shell from within your terminal
program—by explicitly running (say) <code>gnome-terminal</code> or <code>xterm</code> at
the command line or using your terminal program’s menu to open a new
window. In this case, the new shell is a child of <em>that terminal’s
shell</em>. Its current directory is the same as its parent’s, which might
not be your home directory.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="One-Shot Windows"><div class="sect2" id="idm46586637503904">
<h2>One-Shot Windows</h2>

<p><a data-type="indexterm" data-primary="one-shot windows" id="idm46586637502528"/><a data-type="indexterm" data-primary="windows" data-secondary="opening with keyboard shortcut" id="idm46586637501824"/><a data-type="indexterm" data-primary="opening windows via keyboard shortcuts" id="idm46586637500912"/>
Suppose you’re in the middle of using several applications when
suddenly you need a shell to run one command. Many users would grab
the mouse and hunt through their open windows for a running terminal.
Don’t do this—you’re wasting time. Just pop open a new terminal
with your hotkey, run your command, and exit the terminal right
afterward.</p>

<p>Once you have hotkeys assigned to launch terminal programs and browser
windows, go ahead and open and close these windows in great numbers
with wild abandon. I recommend it! Create and destroy terminals and
browser windows on a regular basis, rather than leaving them open for
a long time. I call these short-lived windows <em>one-shot windows</em>. You
pop them open quickly, use them for a few moments, and close them.</p>

<p>You might leave a few shells open for a long time if you’re developing
software or performing other lengthy work, but one-shot terminal
windows are perfect for other random commands throughout
the day. <em>It’s often quicker to pop up a new terminal than to search
your screen for an existing terminal.</em> Don’t ask yourself, “Where’s
that terminal window I need?”  and poke around the desktop looking
for it. Make a new one and close it after it has served its purpose.</p>

<p>Likewise for web browser windows. Do you ever lift your head after a
long day of Linux hacking to discover that your browser has just one
window and 83 open tabs?  That’s a symptom of too few one-shot
windows. Pop one open, view whatever web page you need to view, and
close it. Need to revisit the page later? Locate it in your browser
history.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Browser Keyboard Shortcuts"><div class="sect2" id="idm46586637497696">
<h2>Browser Keyboard Shortcuts</h2>

<p><a data-type="indexterm" data-primary="web browser" data-secondary="keyboard shortcuts" id="idm46586637496528"/><a data-type="indexterm" data-primary="keyboard shortcuts" data-secondary="web browsers" id="idm46586637495552"/><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="web browser" data-tertiary="keyboard shortcuts" id="idm46586637494608"/>
While we’re on the topic of browser windows, make sure you know the
most important keyboard shortcuts in <a data-type="xref" href="#table_browser_shortcuts">Table 10-1</a>.  If
your hands are already on the keyboard and you want to browse to a new
website, it’s often faster to press Ctrl-L to jump to the address bar
or Ctrl-T to open a tab than to point and click.</p>
<table id="table_browser_shortcuts">
<caption><span class="label">Table 10-1. </span>The most important keyboard shortcuts for Firefox, Google Chrome, and Opera</caption>
<thead>
<tr>
<th>Action</th>
<th>Keyboard shortcut</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Open new window</p></td>
<td><p>Ctrl-N</p></td>
</tr>
<tr>
<td><p>Open new private/incognito window</p></td>
<td><p>Ctrl-Shift-P (Firefox), Ctrl-Shift-N (Chrome and Opera)</p></td>
</tr>
<tr>
<td><p>Open new tab</p></td>
<td><p>Ctrl-T</p></td>
</tr>
<tr>
<td><p>Close tab</p></td>
<td><p>Ctrl-W</p></td>
</tr>
<tr>
<td><p>Cycle through browser tabs</p></td>
<td><p>Ctrl-Tab (cycle forward) and Ctrl-Shift-Tab (cycle backward)</p></td>
</tr>
<tr>
<td><p>Jump to address bar</p></td>
<td><p>Ctrl-L (or Alt-D or F6)</p></td>
</tr>
<tr>
<td><p>Find (search) for text in current page</p></td>
<td><p>Ctrl-F</p></td>
</tr>
<tr>
<td><p>Display your browsing history</p></td>
<td><p>Ctrl-H</p></td>
</tr>
</tbody>
</table>
</div></section>













<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Switching Windows and Desktops"><div class="sect2" id="idm46586637475872">
<h2>Switching Windows and Desktops</h2>

<p><a data-type="indexterm" data-primary="windows" data-secondary="switching" id="idm46586637474288"/><a data-type="indexterm" data-primary="switching windows" id="idm46586637473312"/><a data-type="indexterm" data-primary="keyboard shortcuts" data-secondary="switching windows" id="idm46586637472640"/>
When your busy desktop is filled with windows, how do you find the
window you want quickly? You could point and click your way through
the morass, but it’s often quicker to use the keyboard shortcut
Alt-Tab. Keep pressing Alt-Tab and you cycle through all windows on
the desktop, one at a time. When you reach the window you want, release
the keys and that window is in focus and ready to use. To cycle
in the reverse direction, press Alt-Shift-Tab.</p>

<p>To cycle through all windows on the desktop that belong to the same
application, such as all Firefox windows, press Alt-` (Alt-backquote,
or Alt plus the key above Tab). To cycle backward, add the Shift key
(Alt-Shift-backquote).</p>

<p>Once you can switch windows, it’s time to talk about switching
desktops.<a data-type="indexterm" data-primary="desktop switching" id="idm46586637470768"/><a data-type="indexterm" data-primary="switching desktops" id="idm46586637470064"/><a data-type="indexterm" data-primary="virtual desktops" id="idm46586637469392"/><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="desktop switching" id="idm46586637468720"/>  If you do serious work on Linux and you’re using just one
desktop, you’re missing out on a great way to organize your
work. Multiple desktops, also called workspaces or virtual desktops,
are just what they sound like. Instead of a single desktop, you might
have four or six or more, each with its own windows, and you can
switch between them.</p>

<p>On my workstation running Ubuntu Linux with KDE Plasma<a data-type="indexterm" data-primary="KDE Plasma" id="idm46586637467200"/>, I run six virtual
desktops and assign them different purposes. Desktop #1 is my main
workspace with email and browsing, #2 is for family-related tasks, #3
is where I run VMware virtual machines, #4 is for writing books like
this one, and #5–6 are for any ad hoc tasks. These consistent assignments make it
quick and easy to locate my open windows from different applications.</p>

<p>Each Linux desktop environment<a data-type="indexterm" data-primary="desktop environment" data-secondary="virtual desktops" id="idm46586637465984"/> such as GNOME<a data-type="indexterm" data-primary="GNOME" id="idm46586637464880"/>, KDE Plasma, Cinnamon<a data-type="indexterm" data-primary="Cinnamon" id="idm46586637464048"/>, and Unity<a data-type="indexterm" data-primary="Unity" id="idm46586637463216"/> has its own way to implement virtual desktops, and they all
provide a graphical “switcher” or “pager” to switch between them. I
recommend defining keyboard shortcuts in your desktop environment to
jump speedily to each desktop. On my computer, I defined Windows + F1
through Windows + F6 to jump to desktops #1 through #6, respectively.</p>

<p>There are many other styles of working with desktops and windows.
Some people use one desktop per application: a desktop for shells, a
desktop for web browsing, a desktop for word processing, and so on.
Some people with small laptop screens open just one window on each
desktop, full-screen, instead of multiple windows per desktop. Find a
style that works for you, as long as it’s speedy and efficient.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Web Access from the Command Line"><div class="sect1" id="idm46586637461872">
<h1>Web Access from the Command Line</h1>

<p>Point-and-click browsers are almost synonymous with the web, but you
can also access websites from the Linux command line to great effect.</p>








<section data-type="sect2" data-pdf-bookmark="Launching Browser Windows from the Command Line"><div class="sect2" id="idm46586637460112">
<h2>Launching Browser Windows from the Command Line</h2>

<p><a data-type="indexterm" data-primary="web browser" data-secondary="launching from command line" id="idm46586637458208"/><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="web browser" data-tertiary="launching from command line" id="idm46586637457216"/>
You may be accustomed to launching a web browser by clicking or
tapping an icon, but you can also do it from the Linux command
line. If the browser isn’t running yet, add an ampersand to run it in
the background<a data-type="indexterm" data-primary="background commands" data-secondary="web browsers" id="idm46586637455632"/> so you get your shell prompt back:</p>

<pre data-type="programlisting">$ <strong>firefox &amp;</strong>
$ <strong>google-chrome &amp;</strong>
$ <strong>opera &amp;</strong></pre>

<p>If a given browser is already running, omit the ampersand. The command
tells an existing browser instance to open a new window or tab.
The command immediately exits and gives you the shell prompt back.</p>
<div data-type="tip"><h6>Tip</h6>
<p>A backgrounded browser command might print diagnostic messages and
clutter up your shell window. To prevent this, redirect all output<a data-type="indexterm" data-primary="output redirection" data-secondary="/dev/null" id="idm46586637451040"/> to
<em>/dev/null</em><a data-type="indexterm" data-primary="/dev/null" id="idm46586637449648"/><a data-type="indexterm" data-primary="/dev/null" data-primary-sortas="dev null" id="idm46586637448944"/><a data-type="indexterm" data-primary="null device" id="idm46586637448000"/><a data-type="indexterm" data-primary="redirection" data-secondary="output to /dev/null" id="idm46586637447328"/> when you first launch the browser. For example:</p>

<pre data-type="programlisting">$ <strong>firefox &amp;&gt; /dev/null &amp;</strong></pre>
</div>

<p>To open a browser and visit a URL from the command line, provide the
URL as an argument:<a data-type="indexterm" data-primary="web browser" data-secondary="launching from command line" data-tertiary="arguments" id="idm46586637444560"/><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="web browser" data-tertiary="launch arguments" id="idm46586637443248"/></p>

<pre data-type="programlisting">$ <strong>firefox https://oreilly.com</strong>
$ <strong>google-chrome https://oreilly.com</strong>
$ <strong>opera https://oreilly.com</strong></pre>

<p>By default, the preceding commands open a new tab and bring it into
focus. To force them to open a new window instead, add an option:</p>

<pre data-type="programlisting">$ <strong>firefox --new-window https://oreilly.com</strong>
$ <strong>google-chrome --new-window https://oreilly.com</strong>
$ <strong>opera --new-window https://oreilly.com</strong></pre>

<p>To open a private or incognito browser window,<a data-type="indexterm" data-primary="web browser" data-secondary="launching from command line" data-tertiary="incognito/private" id="idm46586637437136"/><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="web browser" data-tertiary="launching incognito/private" id="idm46586637435824"/> add the appropriate
command-line option:</p>

<pre data-type="programlisting">$ <strong>firefox --private-window https://oreilly.com</strong>
$ <strong>google-chrome --incognito https://oreilly.com</strong>
$ <strong>opera --private https://oreilly.com</strong></pre>

<p>The preceding commands might seem like a lot of typing and effort, but
you can be efficient by defining aliases for sites you visit often:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># Place in a shell configuration file and source it:</code>
<code class="nb">alias</code> <code class="nv">oreilly</code><code class="o">=</code><code class="s2">"firefox --new-window https://oreilly.com"</code></pre>

<p>Likewise, if you have a file that contains a URL of interest, extract
the URL with <code>grep</code>, <code>cut</code>, or other Linux commands and pass it to the
browser on the command line with
command substitution.<a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586637416752"/> Here’s an
example with a tab-separated file with two columns:</p>
<pre data-type="programlisting">$ <strong>cat urls.txt</strong>
duckduckgo.com	My search engine
nytimes.com	My newspaper
spotify.com	My music
$ <strong>grep music urls.txt | cut -f1</strong>
spotify.com
$ <strong>google-chrome https://$(<mark class="box">grep music urls.txt | cut -f1</mark>)</strong>      <em>Visit spotify</em></pre>

<p>Or, suppose you keep track of packages you’re expecting with a
file of tracking 
<span class="keep-together">numbers:</span><a data-type="indexterm" data-primary="tracking packages" id="idm46586637425008"/><a data-type="indexterm" data-primary="package tracking" id="idm46586637411888"/></p>

<pre data-type="programlisting">$ <strong>cat packages.txt</strong>
1Z0EW7360669374701	UPS	Shoes
568733462924		FedEx	Kitchen blender
9305510823011761842873	USPS	Care package from Mom</pre>

<p>The shell script in <a data-type="xref" href="#ex_ups">Example 10-1</a> opens the tracking pages for the
appropriate shippers (UPS, FedEx, or the US Postal Service) by
appending tracking numbers to the appropriate URLs.<a data-type="indexterm" data-primary="while loop" data-secondary="while read" id="idm46586637408544"/><a data-type="indexterm" data-primary="loops" data-secondary="bash" data-tertiary="while read loop" id="idm46586637407600"/></p>
<div id="ex_ups" data-type="example">
<h5><span class="label">Example 10-1. </span><code>track-it</code> script that hits the tracking page of shippers</h5>

<pre data-type="programlisting" data-code-language="bash" class="pagebreak-after"><code class="ch">#!/bin/bash</code>
<code class="nv">PROGRAM</code><code class="o">=</code><code class="k">$(</code>basename <code class="nv">$0</code><code class="k">)</code>
<code class="nv">DATAFILE</code><code class="o">=</code>packages.txt
<code class="c1"># Choose a browser command: firefox, opera, google-chrome</code>
<code class="nv">BROWSER</code><code class="o">=</code><code class="s2">"opera"</code>
<code class="nv">errors</code><code class="o">=</code><code class="m">0</code>

cat <code class="s2">"</code><code class="nv">$DATAFILE</code><code class="s2">"</code> <code class="p">|</code> <code class="k">while</code> <code class="nb">read</code> line<code class="p">;</code> <code class="k">do</code>
  <code class="nv">track</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code> <code class="s2">"</code><code class="nv">$line</code><code class="s2">"</code> <code class="p">|</code> awk <code class="s1">'{print $1}'</code><code class="k">)</code>
  <code class="nv">service</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code> <code class="s2">"</code><code class="nv">$line</code><code class="s2">"</code> <code class="p">|</code> awk <code class="s1">'{print $2}'</code><code class="k">)</code>
  <code class="k">case</code> <code class="s2">"</code><code class="nv">$service</code><code class="s2">"</code> <code class="k">in</code>
    UPS<code class="o">)</code>
      <code class="nv">$BROWSER</code> <code class="s2">"https://www.ups.com/track?tracknum=</code><code class="nv">$track</code><code class="s2">"</code> <code class="p">&amp;</code>
      <code class="p">;;</code>
    FedEx<code class="o">)</code>
      <code class="nv">$BROWSER</code> <code class="s2">"https://www.fedex.com/fedextrack/?trknbr=</code><code class="nv">$track</code><code class="s2">"</code> <code class="p">&amp;</code>
      <code class="p">;;</code>
    USPS<code class="o">)</code>
      <code class="nv">$BROWSER</code> <code class="s2">"https://tools.usps.com/go/TrackConfirmAction?tLabels=</code><code class="nv">$track</code><code class="s2">"</code> <code class="p">&amp;</code>
      <code class="p">;;</code>
    *<code class="o">)</code>
      &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: Unknown service '</code><code class="nv">$service</code><code class="s2">'"</code>
      <code class="nv">errors</code><code class="o">=</code><code class="m">1</code>
      <code class="p">;;</code>
  <code class="k">esac</code>
<code class="k">done</code>
<code class="nb">exit</code> <code class="nv">$errors</code></pre></div>
</div></section>













<section data-type="sect2" class="less_space" data-pdf-bookmark="Retrieving HTML with curl and wget"><div class="sect2" id="idm46586637459488">
<h2>Retrieving HTML with curl and wget</h2>

<p><a data-type="indexterm" data-primary="retrieving HTML" id="retrieveHTML"/><a data-type="indexterm" data-primary="HTML" data-secondary="retrieving" id="retrieveHTML2"/><a data-type="indexterm" data-primary="web pages" data-secondary="downloading" id="retrieveHTML3"/><a data-type="indexterm" data-primary="downloading web content" id="retrieveHTML4"/><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="retrieving HTML" id="retrieveHTML5"/><a data-type="indexterm" data-primary="web browser" data-secondary="downloading pages without" id="idm46586637240752"/>
Web browsers aren’t the only Linux programs that visit websites. The
programs <code>curl</code><a data-type="indexterm" data-primary="curl command" id="idm46586637239520"/> and <code>wget</code><a data-type="indexterm" data-primary="wget command" id="idm46586637238528"/> can download web pages and other web
content with a single command, without touching a browser. By default,
<code>curl</code> prints its output to stdout, and <code>wget</code> saves its output to a
file (after printing lots of diagnostic messages):</p>

<pre data-type="programlisting">$ <strong>curl https://efficientlinux.com/welcome.html</strong>
Welcome to Efficient Linux.com!
$ <strong>wget https://efficientlinux.com/welcome.html</strong>
--2021-10-27 20:05:47--  https://efficientlinux.com/
Resolving efficientlinux.com (efficientlinux.com)...
Connecting to efficientlinux.com (efficientlinux.com)...
⋮
2021-10-27 20:05:47 (12.8 MB/s) - ‘welcome.html’ saved [32/32]
$ <strong>cat welcome.html</strong>
Welcome to Efficient Linux.com!</pre>
<div data-type="tip"><h6>Tip</h6>
<p>Some sites don’t support retrieval by <code>wget</code> and <code>curl</code>. Both commands
can masquerade as another browser in such cases. Just tell each
program to change its user agent—the string that identifies a web
client to a web server.<a data-type="indexterm" data-primary="user agent" id="idm46586637233120"/><a data-type="indexterm" data-primary="web browser" data-secondary="user agent" id="idm46586637232416"/> A convenient user agent is “Mozilla”:</p>

<pre data-type="programlisting">$ <strong>wget -U Mozilla <em>url</em></strong>
$ <strong>curl -A Mozilla <em>url</em></strong></pre>
</div>

<p>Both <code>wget</code> and <code>curl</code> have tons of options and features that you can
discover on their manpages. For now, let’s see how to incorporate
these commands into brash one-liners<a data-type="indexterm" data-primary="brash one-liner" data-secondary="retrieving HTML" id="idm46586637227616"/>. Suppose the
website <em>efficientlinux.com</em> has a directory, <em>images</em>, containing files
<em>1.jpg</em> through <em>20.jpg</em>, and you’d like to download them. Their URLs
are:</p>

<pre data-type="programlisting">https://efficientlinux.com/images/1.jpg
https://efficientlinux.com/images/2.jpg
https://efficientlinux.com/images/3.jpg
⋮</pre>

<p>An inefficient method would be to visit each URL in a web browser, one
at a time, and download each image. (Raise your hand if you’ve ever
done this!) A better method is to use <code>wget</code>.  Generate the URLs with
<code>seq</code> and <code>awk</code>:<a data-type="indexterm" data-primary="seq command" data-secondary="examples" id="idm46586637222304"/><a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586637221296"/></p>
<pre data-type="programlisting" class="pagebreak-after">$ <strong>seq 1 20 | awk '{print "https://efficientlinux.com/images/" $1 ".jpg"}'</strong>
https://efficientlinux.com/images/1.jpg
https://efficientlinux.com/images/2.jpg
https://efficientlinux.com/images/3.jpg
⋮</pre>

<p>Then add the string “wget” into the awk program and pipe the resulting
commands to <code>bash</code> for execution:</p>
<pre data-type="programlisting">$ <strong>seq 1 20 \
  | awk '{print "<mark class="box">wget</mark> https://efficientlinux.com/images/" $1 ".jpg"}' \
  | bash</strong></pre>

<p>Alternatively, use <code>xargs</code> to create and execute the <code>wget</code> commands:<a data-type="indexterm" data-primary="xargs command" data-secondary="examples" id="idm46586637215200"/></p>

<pre data-type="programlisting">$ <strong>seq 1 20 | xargs -I@ wget https://efficientlinux.com/images/@.jpg</strong></pre>

<p>The <code>xargs</code> solution is superior if your <code>wget</code> commands contain any
special characters.<a data-type="indexterm" data-primary="pipes" data-secondary="piping commands to bash" data-tertiary="xargs versus" id="idm46586637211856"/><a data-type="indexterm" data-primary="xargs command" data-secondary="piping commands to bash versus" id="idm46586637210608"/> The “pipe to bash” solution would cause the shell
to evaluate those characters (which you don’t want to happen) whereas <code>xargs</code>
would not.</p>

<p>My example was a bit contrived because the image filenames are so
uniform. In a more realistic example, you could download all the
images on a web page by retrieving the page with <code>curl</code>, piping it
through a clever sequence of commands to isolate the image URLs, one
per line, and then applying one of the techniques I just showed you:</p>

<pre data-type="programlisting"><strong>curl <em>URL</em> | <em>...clever pipeline here...</em> | xargs -n1 wget</strong></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Processing HTML with HTML-XML-utils"><div class="sect2" id="idm46586637290656">
<h2>Processing HTML with HTML-XML-utils</h2>

<p><a data-type="indexterm" data-primary="HTML" data-secondary="parsing with HTML-XML-utils package" id="idm46586637204320"/><a data-type="indexterm" data-primary="parsing HTML" id="idm46586637203328"/><a data-type="indexterm" data-primary="web pages" data-secondary="parsing HTML" id="idm46586637202656"/>
If you know some HTML and CSS, you can parse the HTML source of web
pages from the command line. It’s sometimes more efficient than
copying and pasting chunks of a web page from a browser window by
hand. A handy suite of tools for this purpose is HTML-XML-utils, which
is available in many Linux distros and from the
<a href="https://oreil.ly/81yM2">World Wide Web Consortium</a>. A general recipe is:</p>
<ol>
<li>
<p>Use <code>curl</code> (or <code>wget</code>) to capture the HTML source.</p>
</li>
<li>
<p>Use <code>hxnormalize</code><a data-type="indexterm" data-primary="hxnormalize command" id="idm46586637197744"/> to help ensure that the HTML is well-formed.</p>
</li>
<li>
<p>Identify CSS selectors<a data-type="indexterm" data-primary="CSS selectors" id="idm46586637196016"/><a data-type="indexterm" data-primary="cascading style sheets, selectors" id="idm46586637195280"/> for the values you want to capture.</p>
</li>
<li>
<p>Use <code>hxselect</code><a data-type="indexterm" data-primary="hxselect command" id="idm46586637193264"/> to isolate the values, and pipe the output to further commands
for processing.</p>
</li>

</ol>

<p>Let’s extend the example from <a data-type="xref" href="ch09.xhtml#sec_areacodes">“Building an Area Code Database”</a> to grab area code data<a data-type="indexterm" data-primary="area codes" data-secondary="downloading" id="idm46586637190912"/>
from the web and produce the <em>areacodes.txt</em> file used in that
example. For your convenience, I’ve created an HTML table of area
codes for you to download and process, shown in <a data-type="xref" href="#fig_areacodes">Figure 10-1</a>.</p>

<figure><div id="fig_areacodes" class="figure">
<img src="Images/elcl_1001.png" alt="A table of area codes, US states, and US cities" width="439" height="413"/>
<h6><span class="label">Figure 10-1. </span>A table of area codes at <a href="https://efficientlinux.com/areacodes.html"><em class="hyperlink">https://efficientlinux.com/areacodes.html</em></a></h6>
</div></figure>

<p>First, grab the HTML source with <code>curl</code>, using the <code>-s</code><a data-type="indexterm" data-primary="curl command" data-secondary="suppress messages (-s option)" id="idm46586637183952"/> option to suppress
on-screen messages. Pipe the output to
<code>hxnormalize -x</code><a data-type="indexterm" data-primary="hxnormalize command" data-secondary="cleaning up output (-x option)" id="idm46586637182528"/> to clean it up a bit. Pipe it to <code>less</code> to view the
output one screenful at a time:</p>
<pre data-type="programlisting">$ <strong>curl -s https://efficientlinux.com/areacodes.html  \
  | hxnormalize -x  \
  | less</strong>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;html&gt;
⋮
  &lt;body&gt;
    &lt;h1&gt;Area code test&lt;/h1&gt;
    ⋮</pre>

<p>The HTML table on that page, shown in <a data-type="xref" href="#ex_areacodes_html">Example 10-2</a>, has CSS
ID <code>#ac</code>, and its three columns (area code, state, and location) use
CSS classes <code>ac</code>, <code>state</code>, and <code>cities</code>, respectively.</p>
<div id="ex_areacodes_html" data-type="example">
<h5><span class="label">Example 10-2. </span>Partial HTML source of the table in <a data-type="xref" href="#fig_areacodes">Figure 10-1</a></h5>

<pre data-type="programlisting" data-code-language="html"><code class="p">&lt;</code><code class="nt">table</code> <code class="na">id</code><code class="o">=</code><code class="s">"ac"</code><code class="p">&gt;</code>
  <code class="p">&lt;</code><code class="nt">thead</code><code class="p">&gt;</code>
    <code class="p">&lt;</code><code class="nt">tr</code><code class="p">&gt;</code>
      <code class="p">&lt;</code><code class="nt">th</code><code class="p">&gt;</code>Area code<code class="p">&lt;/</code><code class="nt">th</code><code class="p">&gt;</code>
      <code class="p">&lt;</code><code class="nt">th</code><code class="p">&gt;</code>State<code class="p">&lt;/</code><code class="nt">th</code><code class="p">&gt;</code>
      <code class="p">&lt;</code><code class="nt">th</code><code class="p">&gt;</code>Location<code class="p">&lt;/</code><code class="nt">th</code><code class="p">&gt;</code>
    <code class="p">&lt;/</code><code class="nt">tr</code><code class="p">&gt;</code>
  <code class="p">&lt;/</code><code class="nt">thead</code><code class="p">&gt;</code>
  <code class="p">&lt;</code><code class="nt">tbody</code><code class="p">&gt;</code>
    <code class="p">&lt;</code><code class="nt">tr</code><code class="p">&gt;</code>
      <code class="p">&lt;</code><code class="nt">td</code> <code class="na">class</code><code class="o">=</code><code class="s">"ac"</code><code class="p">&gt;</code>201<code class="p">&lt;/</code><code class="nt">td</code><code class="p">&gt;</code>
      <code class="p">&lt;</code><code class="nt">td</code> <code class="na">class</code><code class="o">=</code><code class="s">"state"</code><code class="p">&gt;</code>NJ<code class="p">&lt;/</code><code class="nt">td</code><code class="p">&gt;</code>
      <code class="p">&lt;</code><code class="nt">td</code> <code class="na">class</code><code class="o">=</code><code class="s">"cities"</code><code class="p">&gt;</code>Hackensack, Jersey City<code class="p">&lt;/</code><code class="nt">td</code><code class="p">&gt;</code>
    <code class="p">&lt;/</code><code class="nt">tr</code><code class="p">&gt;</code>
    ⋮
<code class="p">&lt;/</code><code class="nt">tbody</code><code class="p">&gt;</code>
<code class="p">&lt;/</code><code class="nt">table</code><code class="p">&gt;</code></pre></div>

<p>Run <code>hxselect</code> to extract the area code data from each table cell,
supplying the <code>-c</code><a data-type="indexterm" data-primary="hxselect command" data-secondary="omitting tags from output (-c option)" id="idm46586637169984"/> option to omit the <code>td</code> tags from the output. Print the
results as one long line, with fields separated<a data-type="indexterm" data-primary="separator" data-secondary="hxselect output" id="idm46586637125680"/> by a character of your
choice (using the <code>-s</code><a data-type="indexterm" data-primary="hxselect command" data-secondary="output separator (-s option)" id="idm46586637124320"/> option).<sup><a data-type="noteref" id="idm46586637066128-marker" href="ch10.xhtml#idm46586637066128">2</a></sup> I chose the character <code>@</code> for its easy visibility on the page:</p>
<pre data-type="programlisting">$ <strong>curl -s https://efficientlinux.com/areacodes.html \
  | hxnormalize -x \
  | hxselect -c -s@ '#ac .ac, #ac .state, #ac .cities'</strong>
201@NJ@Hackensack, Jersey City@202@DC@Washington@203@CT@New Haven, Stamford@...</pre>

<p>Finally, pipe the output to <code>sed</code> to turn this long line into three
tab-separated columns. Write a regular expression to match the
following strings:</p>
<ol>
<li>
<p>An area code, which consists of digits, <code>[0-9]*</code></p>
</li>
<li>
<p>An <code>@</code> symbol</p>
</li>
<li>
<p>A state abbreviation, which is two capital letters, <code>[A-Z][A-Z]</code></p>
</li>
<li>
<p>An <code>@</code> symbol</p>
</li>
<li>
<p>The cities, which is any text that doesn’t include an <code>@</code> symbol, <code>[^@]*</code></p>
</li>
<li>
<p>An <code>@</code> symbol</p>
</li>

</ol>

<p>Combine the parts to produce the following regular expression:</p>
<pre data-type="programlisting"><mark class="box">[0-9]*</mark>@<mark class="box">[A-Z][A-Z]</mark>@<mark class="box">[^@]*</mark>@</pre>

<p>Capture the area code, state, and cities as three subexpressions by
surrounding them with <code>\(</code> and <code>\)</code>. You now have a complete regular
expression for <code>sed</code>:<a data-type="indexterm" data-primary="sed command" data-secondary="examples" id="idm46586637046416"/></p>
<pre data-type="programlisting">\(<mark class="box">[0-9]*</mark>\)@\(<mark class="box">[A-Z][A-Z]</mark>\)@\(<mark class="box">[^@]*</mark>\)@</pre>

<p>For <code>sed</code>’s replacement string, provide the three subexpressions<a data-type="indexterm" data-primary="sed scripts" data-secondary="subexpressions" id="idm46586637041696"/>
separated by tabs and terminated by newlines, which produces the
format of the <em>areacodes.txt</em> file:</p>

<pre data-type="programlisting">\1\t\2\t\3\n</pre>

<p>Combine the preceding regular expression and replacement string to
make this sed script:</p>
<pre data-type="programlisting">s/<mark class="box">\([0-9]*\)@\([A-Z][A-Z]\)@\([^@]*\)@</mark>/<mark class="box">\1\t\2\t\3\n</mark>/g</pre>

<p>The finished command produces the needed data for the <em>areacodes.txt</em>
file:</p>
<pre data-type="programlisting">$ <strong>curl -s https://efficientlinux.com/areacodes.html \
  | hxnormalize -x \
  | hxselect -c -s'@' '#ac .ac, #ac .state, #ac .cities' \
  | sed 's/\([0-9]*\)@\([A-Z][A-Z]\)@\([^@]*\)@/\1\t\2\t\3\n/g'</strong>
201	NJ	Hackensack, Jersey City
202	DC	Washington
203	CT	New Haven, Stamford
⋮</pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_long_regex">
<h5>Handling Long Regular Expressions</h5>
<p>If your sed scripts become so long they look like random noise:<a data-type="indexterm" data-primary="regular expressions" data-secondary="simplifying lengthy" id="idm46586637032896"/></p>

<pre data-type="programlisting">s/\([0-9]*\)@\([A-Z][A-Z]\)@\([^@]*\)@/\1\t\2\t\3\n/g</pre>

<p>try splitting them up. Store parts of the regular expression in
several shell variables,<a data-type="indexterm" data-primary="variables" data-secondary="breaking up regular expressions" id="idm46586637011152"/> and combine the variables later, as in the
following shell script:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># The three parts of the regular expression.</code>
<code class="c1"># Use single quotes to prevent evaluation by the shell.</code>
<code class="nv">areacode</code><code class="o">=</code><code class="s1">'\([0-9]*\)'</code>
<code class="nv">state</code><code class="o">=</code><code class="s1">'\([A-Z][A-Z]\)'</code>
<code class="nv">cities</code><code class="o">=</code><code class="s1">'\([^@]*\)'</code>

<code class="c1"># Combine the three parts, separated by @ symbols.</code>
<code class="c1"># Use double quotes to permit variable evaluation by the shell.</code>
<code class="nv">regexp</code><code class="o">=</code><code class="s2">"</code><code class="nv">$areacode</code><code class="s2">@</code><code class="nv">$state</code><code class="s2">@</code><code class="nv">$cities</code><code class="s2">@"</code>

<code class="c1"># The replacement string.</code>
<code class="c1"># Use single quotes to prevent evaluation by the shell.</code>
<code class="nv">replacement</code><code class="o">=</code><code class="s1">'\1\t\2\t\3\n'</code>

<code class="c1"># The sed script now becomes much simpler to read:</code>
<code class="c1">#   s/$regexp/$replacement/g</code>
<code class="c1"># Run the full command:</code>
curl -s https://efficientlinux.com/areacodes.html <code class="se">\</code>
  <code class="p">|</code> hxnormalize -x <code class="se">\</code>
  <code class="p">|</code> hxselect -c -s<code class="s1">'@'</code> <code class="s1">'#ac .ac, #ac .state, #ac .cities'</code> <code class="se">\</code>
  <code class="p">|</code> sed <code class="s2">"s/</code><code class="nv">$regexp</code><code class="s2">/</code><code class="nv">$replacement</code><code class="s2">/g"</code></pre>
</div></aside>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Retrieving Rendered Web Content with a Text-Based Browser"><div class="sect2" id="idm46586636986368">
<h2>Retrieving Rendered Web Content with a Text-Based Browser</h2>

<p><a data-type="indexterm" data-primary="text-based web browser" id="idm46586636970832"/><a data-type="indexterm" data-primary="web browser" data-secondary="text-based" id="idm46586636969936"/><a data-type="indexterm" data-primary="web browser" data-secondary="downloading pages with text-based" id="idm46586636968992"/>
Sometimes when you retrieve data from the web at the command line, you
might not want the HTML source of a web page, but a rendered version
of the page in text.  The rendered text might be easier to parse. To
accomplish this task, use a text-based browser such as <code>lynx</code><a data-type="indexterm" data-primary="lynx command" id="idm46586636967696"/> or
<code>links</code>.<a data-type="indexterm" data-primary="links command" id="idm46586636966448"/> Text-based browsers display web pages in a stripped-down
format without images or other fancy features. <a data-type="xref" href="#fig_lynx">Figure 10-2</a>
displays the area codes page from the previous section as
rendered by <code>lynx</code>.</p>

<figure><div id="fig_lynx" class="figure">
<img src="Images/elcl_1002.png" alt="lynx renders the page https://efficientlinux.com/areacodes.html" width="600" height="360"/>
<h6><span class="label">Figure 10-2. </span><code>lynx</code> renders the page <a href="https://efficientlinux.com/areacodes.html"><em class="hyperlink">https://efficientlinux.com/areacodes.html</em></a></h6>
</div></figure>

<p>Both <code>lynx</code> and <code>links</code> download a rendered page with the <code>-dump</code><a data-type="indexterm" data-primary="lynx command" data-secondary="render and download (-dump option)" id="idm46586636959616"/><a data-type="indexterm" data-primary="links command" data-secondary="render and download (-dump option)" id="idm46586636916960"/><a data-type="indexterm" data-primary="HTML" data-secondary="rendering as text" id="idm46586636916112"/>
option. Use whichever program you prefer.</p>

<pre data-type="programlisting">$ <strong>lynx -dump https://efficientlinux.com/areacodes.html &gt; tempfile</strong>
$ <strong>cat tempfile</strong>
                              Area code test

Area code State   Location
201       NJ      Hackensack, Jersey City
202       DC      Washington
203       CT      New Haven, Stamford
⋮</pre>
<div data-type="tip"><h6>Tip</h6>
<p><code>lynx</code> and <code>links</code> are also great for checking out a
suspicious-looking link<a data-type="indexterm" data-primary="security" data-secondary="web links" id="idm46586636911744"/><a data-type="indexterm" data-primary="web pages" data-secondary="suspicious-looking links" id="idm46586636910768"/><a data-type="indexterm" data-primary="lynx command" data-secondary="suspicious-looking links" id="idm46586636909856"/><a data-type="indexterm" data-primary="links command" data-secondary="suspicious-looking links" id="idm46586636908896"/> when you’re unsure if it’s legitimate or
malicious. These text-based browsers don’t support JavaScript or
render images, so they are less vulnerable to attack. (They
can’t promise complete security, of course, so use your best
judgment.)<a data-type="indexterm" data-startref="retrieveHTML" id="idm46586636907552"/><a data-type="indexterm" data-startref="retrieveHTML2" id="idm46586636906880"/><a data-type="indexterm" data-startref="retrieveHTML3" id="idm46586636906208"/><a data-type="indexterm" data-startref="retrieveHTML4" id="idm46586636905536"/><a data-type="indexterm" data-startref="retrieveHTML5" id="idm46586636904864"/></p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Clipboard Control from the Command Line"><div class="sect1" id="idm46586636904064">
<h1>Clipboard Control from the Command Line</h1>

<p><a data-type="indexterm" data-primary="clipboard" data-secondary="control from command line" id="idm46586636902784"/><a data-type="indexterm" data-primary="X selections" data-secondary="from command line" id="idm46586636901840"/><a data-type="indexterm" data-primary="copying text" id="idm46586636900896"/><a data-type="indexterm" data-primary="pasting text" id="idm46586636900224"/><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="clipboard via command line" id="idm46586636899552"/><a data-type="indexterm" data-primary="text" data-secondary="clipboard from command line" id="idm46586636898592"/>
Every modern software application with an Edit menu includes the
operations cut, copy, and paste to transfer content in and out of the
system clipboard. You might also know keyboard shortcuts for these
operations. But did you know that you can process the clipboard
directly from the command line?</p>

<p>A bit of background first: copy and paste operations on Linux are part
of a more general mechanism called <em>X selections</em>. A selection is a
destination for copied content, such as the system clipboard. “X”<a data-type="indexterm" data-primary="X (windowing software)" id="idm46586636896464"/> is
just the name of the Linux windowing software.</p>

<p>Most Linux desktop environments<a data-type="indexterm" data-primary="desktop environment" data-secondary="X-based" id="idm46586636895248"/><a data-type="indexterm" data-primary="selection types in X-based environments" id="idm46586636893920"/> that are built on X, such
as GNOME<a data-type="indexterm" data-primary="GNOME" id="idm46586636893056"/>, Unity<a data-type="indexterm" data-primary="Unity" id="idm46586636892256"/>, Cinnamon<a data-type="indexterm" data-primary="Cinnamon" id="idm46586636891424"/>, and KDE Plasma<a data-type="indexterm" data-primary="KDE Plasma" id="idm46586636890592"/>, support two selections.<sup><a data-type="noteref" id="idm46586636889712-marker" href="ch10.xhtml#idm46586636889712">3</a></sup> The first is the
<em>clipboard</em>,<a data-type="indexterm" data-primary="clipboard" data-secondary="X-based desktop environments" id="idm46586636887328"/> and it works just like clipboards on other operating
systems. When you run cut or copy operations in an application, the
content goes to the clipboard, and you retrieve the content with a
paste operation. A less familiar X selection is called the <em>primary
selection</em>.<a data-type="indexterm" data-primary="primary selection" id="idm46586636885744"/> When you select text in certain applications, it’s written
to the primary selection even if you don’t run a copy
operation. An example is highlighting text in a terminal window with
the mouse. That text is automatically written to the primary
selection.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you connect to a Linux host remotely by<a data-type="indexterm" data-primary="SSH" data-secondary="copy and paste" id="idm46586636883888"/><a data-type="indexterm" data-primary="pasting text" data-secondary="over SSH connection" id="idm46586636882912"/><a data-type="indexterm" data-primary="copying text" data-secondary="over SSH connection" id="idm46586636881968"/> SSH or similar programs, copy/paste generally is
handled by the local computer, not by X selections on the remote Linux
host.</p>
</div>

<p><a data-type="xref" href="#table_clipboards">Table 10-2</a> lists mouse and keyboard operations to access
X selections in GNOME’s Terminal (<code>gnome-terminal</code>)<a data-type="indexterm" data-primary="gnome-terminal command" id="idm46586636879040"/> and KDE’s Konsole
(<code>konsole</code>).<a data-type="indexterm" data-primary="konsole command" id="idm46586636877760"/> If you use a different terminal program, check its Edit menu for keyboard equivalents for Copy and Paste.<a data-type="indexterm" data-primary="copying text" data-secondary="with mouse" id="idm46586636876768"/><a data-type="indexterm" data-primary="pasting text" data-secondary="with mouse" id="idm46586636875824"/><a data-type="indexterm" data-primary="terminal program" data-secondary="X selections" id="idm46586636874880"/></p>
<table id="table_clipboards">
<caption><span class="label">Table 10-2. </span>Accessing X selections in common terminal programs</caption>
<thead>
<tr>
<th>Operation</th>
<th>Clipboard</th>
<th>Primary selection</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Copy (mouse)</p></td>
<td><p>Open the right button menu and select Copy</p></td>
<td><p>Click and drag; or double-click to select the current word; or triple-click to select the current line</p></td>
</tr>
<tr>
<td><p>Paste (mouse)</p></td>
<td><p>Open the right button menu and select Paste</p></td>
<td><p>Press the middle mouse button (usually the scroll wheel)</p></td>
</tr>
<tr>
<td><p>Copy (keyboard)</p></td>
<td><p>Ctrl-Shift-C</p></td>
<td><p><em>n/a</em></p></td>
</tr>
<tr>
<td><p>Paste (keyboard), <span class="keep-together"><code>gnome-terminal</code></span></p></td>
<td><p>Ctrl-Shift-V or Ctrl-Shift-Insert</p></td>
<td><p>Shift-Insert</p></td>
</tr>
<tr>
<td><p>Paste (keyboard), <span class="keep-together"><code>konsole</code></span></p></td>
<td><p>Ctrl-Shift-V or Shift-Insert</p></td>
<td><p>Ctrl-Shift-Insert</p></td>
</tr>
</tbody>
</table>








<section data-type="sect2" data-pdf-bookmark="Connecting Selections to stdin and stdout"><div class="sect2" id="idm46586636857392">
<h2>Connecting Selections to stdin and stdout</h2>

<p><a data-type="indexterm" data-primary="stdin" data-secondary="X selections" id="idm46586636855504"/><a data-type="indexterm" data-primary="stdout" data-secondary="X selections" id="idm46586636854528"/><a data-type="indexterm" data-primary="copying text" data-secondary="xclip" id="idm46586636853584"/><a data-type="indexterm" data-primary="keyboard efficiency" data-secondary="X selections to stdin and stdout" id="idm46586636852640"/>
Linux provides a command, <code>xclip</code>,<a data-type="indexterm" data-primary="xclip command" id="idm46586636851216"/> that connects X selections to stdin
and stdout. You can therefore insert copy and paste operations into
pipelines and other combined commands. For example, you may have
copied text into an application like this:</p>
<ol>
<li>
<p>Run a Linux command and redirect its output to a file.</p>
</li>
<li>
<p>View the file.</p>
</li>
<li>
<p>Use your mouse to copy the file’s content to the clipboard.</p>
</li>
<li>
<p>Paste the content into another application.</p>
</li>

</ol>

<p>With <code>xclip</code>, you can shorten the process considerably:</p>
<ol>
<li>
<p>Pipe a Linux command’s output to <code>xclip</code>.</p>
</li>
<li>
<p>Paste the content into another application.</p>
</li>

</ol>

<p>Conversely, you may have pasted text into a file to process it with
Linux commands like this:</p>
<ol>
<li>
<p>Use your mouse to copy a bunch of text in an application program.</p>
</li>
<li>
<p>Paste it into a text file.</p>
</li>
<li>
<p>Process the text file with Linux commands.</p>
</li>

</ol>

<p>With <code>xclip -o</code>,<a data-type="indexterm" data-primary="xclip command" data-secondary="output (-o option)" id="idm46586636837776"/><a data-type="indexterm" data-primary="pasting text" data-secondary="xclip" id="idm46586636836768"/> you can skip the intermediate text file:</p>
<ol>
<li>
<p>Use your mouse to copy a bunch of text in an application program.</p>
</li>
<li>
<p>Pipe the output of <code>xclip -o</code> to other Linux commands for processing.</p>
</li>

</ol>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you’re reading this book digitally on a Linux device and want to
try some of the <code>xclip</code> commands in this section, <em>don’t copy and
paste the commands</em> into a shell window. Type the commands by
hand. Why? Because your copy operation may overwrite the same X
selection that the commands access with <code>xclip</code>, causing the commands
to produce unexpected results.</p>
</div>

<p>By default, <code>xclip</code> reads stdin and writes the primary selection. It
can read from a file:</p>

<pre data-type="programlisting">$ <strong>xclip &lt; myfile.txt</strong></pre>

<p>or from a pipe:</p>

<pre data-type="programlisting">$ <strong>echo "Efficient Linux at the Command Line" | xclip</strong></pre>

<p>Now print the text to stdout, or pipe the selection contents to other
commands, such as <code>wc</code>:<a data-type="indexterm" data-primary="wc command" data-secondary="examples" id="idm46586636825840"/></p>

<pre data-type="programlisting">$ <strong>xclip -o</strong>                                         <em>Paste to stdout</em>
Efficient Linux at the Command Line
$ <strong>xclip -o &gt; anotherfile.txt</strong>                       <em>Paste to a file</em>
$ <strong>xclip -o | wc -w</strong>                                 <em>Count words</em>
6</pre>

<p>Any combined command that writes to stdout can pipe its results to
<code>xclip</code>, like this one from <a data-type="xref" href="ch01.xhtml#section_uniq">“Command #6: uniq”</a>:</p>
<pre data-type="programlisting">$ <strong>cut -f1 grades | sort | uniq -c | sort -nr | head -n1 | cut -c9 <mark class="box"> | xclip</mark></strong></pre>

<p>Clear the primary selection by setting its value to the empty string
with <code>echo -n</code>:<a data-type="indexterm" data-primary="echo command" data-secondary="clearing X selections" id="idm46586636817104"/><a data-type="indexterm" data-primary="X selections" data-secondary="clearing" id="idm46586636816096"/><a data-type="indexterm" data-primary="echo command" data-secondary="suppressing newline (-n option)" id="idm46586636815152"/></p>

<pre data-type="programlisting">$ <strong>echo -n | xclip</strong></pre>

<p>The <code>-n</code> option is important; otherwise, <code>echo</code> prints a newline
character on stdout that ends up in the primary selection.</p>

<p>To copy text to the clipboard instead of the primary selection,
run <code>xclip</code> with the option <code>-selection clipboard</code>:<a data-type="indexterm" data-primary="xclip command" data-secondary="choose selection (--selection option)" id="idm46586636810576"/></p>

<pre data-type="programlisting">$ <strong>echo https://oreilly.com | xclip -selection clipboard</strong>               <em>Copy</em>
$ <strong>xclip -selection clipboard -o</strong>                                       <em>Paste</em>
https://oreilly.com</pre>

<p><code>xclip</code> options may be abbreviated<a data-type="indexterm" data-primary="xclip command" data-secondary="abbreviating options" id="idm46586636806256"/> as long as they’re unambiguous:</p>

<pre data-type="programlisting">$ <strong>xclip -sel c -o</strong>                     <em>Same as xclip -selection clipboard -o</em>
https://oreilly.com</pre>

<p>Launch a Firefox browser window to visit the preceding URL, using
<a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586636803088"/>command 
<span class="keep-together">substitution:</span></p>

<pre data-type="programlisting">$ <strong>firefox $(xclip -selection clipboard -o)</strong></pre>

<p>Linux offers another command, <code>xsel</code>,<a data-type="indexterm" data-primary="xsel command" id="idm46586636799248"/> that also reads and writes X
selections. It has a few extra features, like clearing<a data-type="indexterm" data-primary="X selections" data-secondary="clearing" id="idm46586636798384"/> a selection
(<code>xsel -c</code>) and appending<a data-type="indexterm" data-primary="X selections" data-secondary="appending" id="idm46586636796896"/> to a selection (<code>xsel -a</code>). Feel free to
read the manpage and experiment with <code>xsel</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Improving the Password Manager"><div class="sect2" id="sec_pman2">
<h2>Improving the Password Manager</h2>

<p><a data-type="indexterm" data-primary="password manager" data-secondary="X selection support" id="passmanX"/>
Let’s use your newfound knowledge of <code>xclip</code> to integrate X selections
into the password manager <code>pman</code><a data-type="indexterm" data-primary="pman script" id="pman2"/> from <a data-type="xref" href="ch09.xhtml#section_pman">“Building a Password Manager”</a>. When the
modified <code>pman</code> script matches
a single line in the <em>vault.gpg</em> file, it writes the username to the
clipboard and the password to the primary selection. Afterward, you can fill
out a login page on the web, for example, by pasting the username with
Ctrl-V and pasting the password with the middle mouse button.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Ensure that you are <em>not</em> running a clipboard manager<a data-type="indexterm" data-primary="clipboard" data-secondary="manager and passwords" id="idm46586636786720"/> or any other
applications that keep track of X selections and their
contents. Otherwise, usernames and/or passwords become visible in
the clipboard manager, which is a security<a data-type="indexterm" data-primary="security" data-secondary="clipboard manager and passwords" id="idm46586636785424"/> risk.</p>
</div>

<p>The new version of <code>pman</code> is in <a data-type="xref" href="#ex_pman_clip">Example 10-3</a>. <code>pman</code>’s behavior
has changed in the following ways:</p>

<ul>
<li>
<p>A new function,<a data-type="indexterm" data-primary="function in pman script" id="idm46586636780896"/><a data-type="indexterm" data-primary="shell" data-secondary="functions" id="idm46586636780160"/> <code>load_password</code>, loads the associated username and
password into X selections.</p>
</li>
<li>
<p>If <code>pman</code> locates a single match for the search string, either by
key (field 3) or by any other part of a line, it runs <code>load_password</code>.</p>
</li>
<li>
<p>If <code>pman</code> locates multiple matches, it prints all the keys and notes
(fields 3 and 4) from the matching lines so the user can search
again by key.<a data-type="indexterm" data-primary="gpg command (GnuPG)" id="idm46586636775136"/></p>
</li>
</ul>
<div id="ex_pman_clip" data-type="example">
<h5><span class="label">Example 10-3. </span>An improved <code>pman</code> script that loads username and password as selections</h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="nv">PROGRAM</code><code class="o">=</code><code class="k">$(</code>basename <code class="nv">$0</code><code class="k">)</code>
<code class="nv">DATABASE</code><code class="o">=</code><code class="nv">$HOME</code>/etc/vault.gpg

load_password <code class="o">()</code> <code class="o">{</code>
    <code class="c1"># Place username (field 1) into clipboard</code>
    <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code> <code class="p">|</code> cut -f1 <code class="p">|</code> tr -d <code class="s1">'\n'</code> <code class="p">|</code> xclip -selection clipboard
    <code class="c1"># Place password (field 2) into X primary selection</code>
    <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code> <code class="p">|</code> cut -f2 <code class="p">|</code> tr -d <code class="s1">'\n'</code> <code class="p">|</code> xclip -selection primary
    <code class="c1"># Give feedback to the user</code>
    <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: Found"</code> <code class="k">$(</code><code class="nb">echo</code> <code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code> <code class="p">|</code> cut -f3- --output-delimiter <code class="s1">': '</code><code class="k">)</code>
    <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: username and password loaded into X selections"</code>
<code class="o">}</code>

<code class="k">if</code> <code class="o">[</code> <code class="nv">$#</code> -ne <code class="m">1</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: look up passwords"</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"Usage: </code><code class="nv">$PROGRAM</code><code class="s2"> string"</code>
    <code class="nb">exit</code> <code class="m">1</code>
<code class="k">fi</code>
<code class="nv">searchstring</code><code class="o">=</code><code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code>

<code class="c1"># Store the decrypted text in a variable</code>
<code class="nv">decrypted</code><code class="o">=</code><code class="k">$(</code>gpg -d -q <code class="s2">"</code><code class="nv">$DATABASE</code><code class="s2">"</code><code class="k">)</code>
<code class="k">if</code> <code class="o">[</code> <code class="nv">$?</code> -ne <code class="m">0</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: could not decrypt </code><code class="nv">$DATABASE</code><code class="s2">"</code>
    <code class="nb">exit</code> <code class="m">1</code>
<code class="k">fi</code>

<code class="c1"># Look for exact matches in the third column</code>
<code class="nv">match</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code> <code class="s2">"</code><code class="nv">$decrypted</code><code class="s2">"</code> <code class="p">|</code> awk <code class="s1">'$3~/^'</code><code class="nv">$searchstring</code><code class="s1">'$/'</code><code class="k">)</code>
<code class="k">if</code> <code class="o">[</code> -n <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    load_password <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code>
    <code class="nb">exit</code> <code class="nv">$?</code>
<code class="k">fi</code>

<code class="c1"># Look for any match</code>
<code class="nv">match</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code> <code class="s2">"</code><code class="nv">$decrypted</code><code class="s2">"</code> <code class="p">|</code> awk <code class="s2">"/</code><code class="nv">$searchstring</code><code class="s2">/"</code><code class="k">)</code>
<code class="k">if</code> <code class="o">[</code> -z <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: no matches"</code>
    <code class="nb">exit</code> <code class="m">1</code>
<code class="k">fi</code>

<code class="c1"># Count the matches</code>
<code class="nv">count</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code> <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code> <code class="p">|</code> wc -l<code class="k">)</code>

<code class="k">case</code> <code class="s2">"</code><code class="nv">$count</code><code class="s2">"</code> <code class="k">in</code>
    <code class="m">0</code><code class="o">)</code>
	&gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: no matches"</code>
	<code class="nb">exit</code> <code class="m">1</code>
	<code class="p">;;</code>
    <code class="m">1</code><code class="o">)</code>
	load_password <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code>
	<code class="nb">exit</code> <code class="nv">$?</code>
	<code class="p">;;</code>
    *<code class="o">)</code>
	&gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: multiple matches for the following keys:"</code>
	<code class="nb">echo</code> <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code> <code class="p">|</code> cut -f3
	&gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: rerun this script with one of the keys"</code>
	<code class="nb">exit</code>
	<code class="p">;;</code>
<code class="k">esac</code></pre></div>

<p class="pagebreak-before">Run the script:</p>

<pre data-type="programlisting">$ <strong>pman dropbox</strong>
Passphrase: <strong>xxxxxxxx</strong>
pman: Found dropbox: dropbox.com account for work
pman: username and password loaded into X selections
$ <strong>pman account</strong>
Passphrase: <strong>xxxxxxxx</strong>
pman: multiple matches for the following keys:
google
dropbox
bank
dropbox2
pman: rerun this script with one of the keys</pre>

<p>Passwords hang around in the primary selection until it’s overwritten.
To automatically clear the password after (say) 30 seconds, append the
following line to the <code>load_password</code> function. The line launches a
subshell in the background that waits 30 seconds and then clears the
primary selection (by setting it to the empty string). Adjust the
number 30 as you see fit.</p>

<pre data-type="programlisting" data-code-language="bash"><code class="o">(</code>sleep <code class="m">30</code> <code class="o">&amp;&amp;</code> <code class="nb">echo</code> -n <code class="p">|</code> xclip -selection primary<code class="o">)</code> <code class="p">&amp;</code></pre>

<p>If you defined a custom keyboard shortcut to launch terminal windows
in <a data-type="xref" href="#section_popup">“Instant Shells and Browsers”</a>, you now have a quick way to access your
passwords. Pop up a terminal by hotkey, run <code>pman</code>, and close the
terminal.<a data-type="indexterm" data-startref="pman2" id="idm46586636443648"/><a data-type="indexterm" data-startref="passmanX" id="idm46586636443008"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586636794736">
<h1>Summary</h1>

<p>I hope this chapter has encouraged you to try some new techniques that
keep your hands on the keyboard. They may seem effortful at first, but
with practice they become quick and automatic. Soon you’ll be the
envy of your Linux friends as you smoothly manipulate desktop windows,
web content, and X selections in ways that the mouse-bound masses
cannot.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586637526832"><sup><a href="ch10.xhtml#idm46586637526832-marker">1</a></sup> Unless you’re working in an application that captures all keystrokes, such as a virtual machine in a window.</p><p data-type="footnote" id="idm46586637066128"><sup><a href="ch10.xhtml#idm46586637066128-marker">2</a></sup> This example uses three CSS selectors, but some old versions of <code>hxselect</code> can handle only two. If your version of <code>hxselect</code> is afflicted by this shortcoming, download<a data-type="indexterm" data-primary="HTML" data-secondary="parsing with HTML-XML-utils package" data-tertiary="downloading" id="idm46586637064496"/> the latest version from the <a href="https://oreil.ly/81yM2">World Wide Web Consortium</a> and build it with the command <code>configure &amp;&amp; make</code>.</p><p data-type="footnote" id="idm46586636889712"><sup><a href="ch10.xhtml#idm46586636889712-marker">3</a></sup> Really there are three X selections, but one of them, called the <em>secondary selection</em>,<a data-type="indexterm" data-primary="secondary selection" id="idm46586636888768"/> is rarely exposed by modern desktop environments.</p></div></div></section></div></body></html>