- en: Chapter 2\. JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html#ch01), we learned about the basics of React and its
    origin story, comparing it to other popular JavaScript libraries and frameworks
    of its time. We learned about the true value proposition of React and why it’s
    a thing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn about JSX, which is a syntax extension for JavaScript
    that allows us to write HTML-like code within our JavaScript code. Back when React
    was introduced in 2013, it was the first thing people noticed and heavily criticized,
    so it makes sense to zero in on it this early in the book. With that, let’s dive
    deep into this language extension, how it works, and how we can conceptually make
    our own code.
  prefs: []
  type: TYPE_NORMAL
- en: To begin our discussion, let’s understand what JSX stands for. We already know
    that JS is JavaScript. Does that mean JSX is JavaScript version 10? Like Mac OS
    X? Is it JS Xtra? We may think the X in JSX means 10 or Xtra, which would both
    be good guesses! But the X in JSX stands for *JavaScript Syntax eXtension*. It’s
    also sometimes called *JavaScript XML*.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript XML?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’ve been around the web for a while, you might remember the term *AJAX*,
    or *Asynchronous JavaScript and XML*, from around the 2000s. AJAX was essentially
    a new way of using existing technologies to create highly interactive web pages
    that updated asynchronously and in place, instead of the status quo at the time:
    each state change would load an entire new page.'
  prefs: []
  type: TYPE_NORMAL
- en: Using tools like `XMLHttpRequest` in the browser, it would initiate an asynchronous
    (that is, nonblocking) request over HTTP (HyperText Transfer Protocol). The response
    to this request traditionally would be a response in XML. Today, we tend to respond
    with JSON instead. This is likely one of the reasons why `fetch` has overtaken
    `XMLHTTPRequest`, since `XMLHttpRequest` has XML in the name.
  prefs: []
  type: TYPE_NORMAL
- en: JSX is a syntax extension for JavaScript that allows developers to write HTML-like
    code within their JavaScript code. It was originally developed by Meta to be used
    with React, but it has since been adopted by other libraries and frameworks as
    well. JSX is not a separate language, but rather a syntax extension that is transformed
    into regular JavaScript code by a compiler or transpiler. When JSX code is compiled,
    it is transformed into plain JavaScript code. We’ll get into the details of this
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'While JSX syntax looks similar to HTML, there are some key differences. For
    example, JSX uses curly braces `{}` to embed JavaScript expressions within the
    HTML-like code. Additionally, JSX attributes are written in camel case instead
    of HTML attributes: `onclick` in HTML is `onClick` in JSX. HTML elements are written
    in lowercase instead of title case like custom JSX elements or components: `div`
    is HTML, `Div` is a React component.'
  prefs: []
  type: TYPE_NORMAL
- en: Further, we should mention that it is possible to create React applications
    without JSX, but the code tends to become hard to read, reason about, and maintain.
    Still, if we want to, we can. Let’s look at a React component expressed with JSX
    and without.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a list with JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of the same list without JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of clarity, we’ve used an earlier JSX transform to illustrate how
    React was written without JSX. We’ll get into transforms in detail later in this
    chapter, but for now let’s establish that a transform is something that takes
    syntax A and turns it into syntax B.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, React ships with a newer transform introduced in React 17 that automatically
    imports some special functions to essentially do the same thing. This is a minor
    detail in the grand scheme of things, but with the newer transformer, we’d express
    the list without JSX like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Either way, do you see the difference between examples with and without JSX?
    You might find the first example with JSX far more readable and maintainable than
    the latter. The former is JSX, the latter is vanilla JS. Let’s talk about its
    trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several benefits to using JSX in web development:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier to read and write
  prefs: []
  type: TYPE_NORMAL
- en: JSX syntax is easier to read and write, especially for developers who are familiar
    with HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Improved security
  prefs: []
  type: TYPE_NORMAL
- en: JSX code can be compiled into safer JavaScript code that produces HTML strings
    that have dangerous characters removed, like `<` and `>`, which could create new
    elements. Instead, these HTML strings replace the angular brackets with the less-than
    and greater-than signs in this scenario to make things safer. This process is
    called sanitization.
  prefs: []
  type: TYPE_NORMAL
- en: Strong typing
  prefs: []
  type: TYPE_NORMAL
- en: JSX allows for strong typing, which can help catch errors before they occur.
    This is because JSX can be expressed with TypeScript, but even without TypeScript
    it can still benefit from enhanced type safety through the use of JSDoc-style
    comments and `propTypes`.
  prefs: []
  type: TYPE_NORMAL
- en: Encourages component-based architecture
  prefs: []
  type: TYPE_NORMAL
- en: JSX encourages a component-based architecture, which can help make code more
    modular and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Widely used
  prefs: []
  type: TYPE_NORMAL
- en: JSX is widely used in the React community and is also supported by other libraries
    and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are also some drawbacks to using JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning curve
  prefs: []
  type: TYPE_NORMAL
- en: Developers who are not familiar with JSX may find it difficult to learn and
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: Requires tooling
  prefs: []
  type: TYPE_NORMAL
- en: JSX code must be compiled into regular JavaScript code before it can be executed,
    which adds an extra step to the development toolchain. Other alternatives, like
    Vue.js, for example, can work immediately in a browser environment when included
    as nothing more than a `<script>` tag in a page.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing of concerns
  prefs: []
  type: TYPE_NORMAL
- en: Some developers argue that JSX mixes concerns by combining HTML-like code with
    JavaScript code, making it harder to separate presentation from logic.
  prefs: []
  type: TYPE_NORMAL
- en: Partial JavaScript compatibility
  prefs: []
  type: TYPE_NORMAL
- en: JSX supports inline expressions, but not inline blocks. That is, inside a tree
    of JSX elements, we can have inline expression, but not if or switch blocks. This
    can be somewhat difficult to reason about for engineers newer to JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its drawbacks, JSX has become a popular choice for web developers, particularly
    those of us working with React. It offers a powerful and flexible way to create
    components and build user interfaces, and has been embraced by a large and active
    community. In addition to its use with React, JSX has also been adopted by other
    libraries and frameworks, including Vue.js, Solid, Qwik, and more. This shows
    that JSX has wider applications beyond just React, and its popularity is likely
    to continue to grow in the coming years, even breaking out of the React and web
    ecosystem by influencing implementations like SwiftUI in the iOS space and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, JSX is a powerful and flexible tool that can help us build dynamic
    and responsive user interfaces. JSX was created with one job: make expressing,
    presenting, and maintaining the code for React components simple while preserving
    powerful capabilities such as iteration, computation, and inline execution.'
  prefs: []
  type: TYPE_NORMAL
- en: JSX becomes vanilla JavaScript before it makes it to the browser. How does it
    accomplish this? Let’s take a look under the hood!
  prefs: []
  type: TYPE_NORMAL
- en: Under the Hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How does one make a language extension? How do they work? To answer these questions,
    we need to understand a little bit about programming languages. Specifically,
    we need to explore how, exactly, code like this outputs `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Understanding this will help us understand JSX better, which will in turn help
    us understand React better, thereby increasing our fluency with React.
  prefs: []
  type: TYPE_NORMAL
- en: How Does Code Work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code snippet we just saw is literally just text. How is this interpreted
    by a computer and then executed? For starters, it’s not a big, clever `RegExp`
    (regular expression) that can identify key words in a text file. I once tried
    to build a programming language this way and failed miserably, because regular
    expressions are often hard to get right, harder still to read back and mentally
    parse, and quite difficult to maintain because of the readability issues. For
    example, what follows is a regular expression to identify a valid email address.
    At first glance, it’s almost impossible to know its purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That regular expression isn’t even fully valid because the full version doesn’t
    fit on the page! This is why instead of using regular expressions, code is compiled
    using a *compiler*. A compiler is a piece of software that translates source code
    written in a high-level programming language into a syntax tree (literally, a
    tree data structure like a JavaScript object) according to specific rules. The
    process of compiling code involves several steps, including lexical analysis,
    parsing, semantic analysis, optimization, and code generation. Let’s explore each
    of these steps in more detail and discuss the role of compilers in the modern
    software development landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'A compiler uses a three-step process (at least in JavaScript anyway) that is
    in play here. These steps are called *tokenization*, *parsing*, and *code generation*.
    Let’s look at each of these steps in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Tokenization
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially breaking up a string of characters into meaningful *tokens*. When
    a tokenizer is stateful and each token contains state about its parents and/or
    children, a tokenizer is called a *lexer*. This is a necessary simplification
    for the purposes of our discussion here: lexing is essentially stateful tokenization.'
  prefs: []
  type: TYPE_NORMAL
- en: Lexers have *lexer rules* that, in some cases, indeed use a regular expression
    or similar to detect key tokens like variable names, object keys and values, and
    more in a text string representing a programming language. The lexer then maps
    these key words to some type of enumerable value, depending on its implementation.
    For example, `const` becomes `0`, `let` becomes `1`, `function` becomes `2`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Once a string is tokenized or lexed, we move on to the next step, parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of taking the tokens and converting them into a syntax tree. The
    syntax tree is a data structure that represents the structure of the code. For
    example, the code snippet we looked at earlier would be represented as a syntax
    tree, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The string, thanks to the parser, becomes a JSON object. As programmers, when
    we have a data structure like this, we can do some really fun things. Language
    engines use these data structures to complete the process with the third step,
    code generation.
  prefs: []
  type: TYPE_NORMAL
- en: Code generation
  prefs: []
  type: TYPE_NORMAL
- en: This is where the compiler generates machine code from the abstract syntax tree
    (AST). This involves translating the code in the AST into a series of instructions
    that can be executed directly by the computer’s processor. The resulting machine
    code is then executed by the JavaScript engine. Overall, the process of converting
    an AST into machine code is complex and involves many different steps. However,
    modern compilers are highly sophisticated and can produce highly optimized code
    that runs efficiently on a wide range of hardware architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of compilers, each with different characteristics and
    use cases. Some of the most common types of compilers include:'
  prefs: []
  type: TYPE_NORMAL
- en: Native compilers
  prefs: []
  type: TYPE_NORMAL
- en: These compilers produce machine code that can be executed directly by the target
    platform’s processor. Native compilers are typically used to create standalone
    applications or system-level software.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compilers
  prefs: []
  type: TYPE_NORMAL
- en: These compilers produce machine code for a different platform than the one on
    which the compiler is running. Cross-compilers are often used in embedded systems
    development or when targeting specialized hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Just-in-Time (JIT) compilers
  prefs: []
  type: TYPE_NORMAL
- en: These compilers translate code into machine code at runtime, rather than ahead
    of time. JIT compilers are commonly used in virtual machines, such as the Java
    virtual machine, and can offer significant performance advantages over traditional
    interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreters
  prefs: []
  type: TYPE_NORMAL
- en: These programs execute source code directly, without the need for compilation.
    Interpreters are typically slower than compilers, but offer greater flexibility
    and ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: To execute JavaScript code efficiently, many modern environments, including
    web browsers, utilize JIT compilers. In these systems, JavaScript source code
    might first be translated into an intermediate representation, such as bytecode.
    The JIT compiler then dynamically compiles this bytecode into machine code as
    the program runs. This on-the-fly compilation allows the engine to make optimizations
    based on real-time information, such as variable types and frequently executed
    code paths. Some engines employ multiple stages of compilation, starting with
    a quick, nonoptimized compilation to begin execution swiftly, followed by more
    optimized compilation for frequently executed code segments. This dynamic approach
    allows JavaScript engines to achieve impressive performance for a wide range of
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: '*Runtimes* usually interface with engines to provide more contextual helpers
    and features for their specific environment. The most popular JavaScript runtime,
    by far, is the common web browser, such as Google Chrome: it ships the Chromium
    *runtime* that interfaces with the engine. Similarly, on the server side we use
    the Node.js runtime that still uses the v8 *engine*. What more engines and runtimes
    can you identify in the wild?'
  prefs: []
  type: TYPE_NORMAL
- en: Runtimes give JavaScript engines context, like the `window` object and the `document`
    object that browser runtimes ship with. If you’ve worked with both browsers and
    Node.js before, you may have noticed Node.js does not have a global `window` object.
    This is because it’s a different runtime and, as such, provides different context.
    Cloudflare created a similar runtime called *Workers* whose sole responsibility
    is executing JavaScript on globally distributed machines called edge servers,
    with Bun and Deno being even more alternative runtimes—but we’re digressing. How
    does this all relate to JSX?
  prefs: []
  type: TYPE_NORMAL
- en: Extending JavaScript Syntax with JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand how we would extend JavaScript syntax, how does JSX work?
    How would we do it? To extend JavaScript syntax, we’d need to either have a different
    engine that can understand our new syntax, or deal with our new syntax before
    it reaches the engine. The former is nearly impossible to do because engines require
    a lot of thought to create and maintain since they tend to be widely used. If
    we decided to go with that option, it might take years or decades before we can
    use our extended syntax! We’d then have to make sure our “bespoke special engine”
    is used everywhere. How would we convince browser vendors and other stakeholders
    to switch to our unpopular new thing? This wouldn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latter is quicker: let’s explore how we can deal with our new syntax before
    it reaches the engine. To do this, we need to create our own lexer and parser
    that can understand our extended language: that is, take a text string of code
    and understand it. Then, instead of generating machine code as is traditional,
    we can take this syntax tree and instead generate plain old regular vanilla JavaScript
    that all current engines can understand. This is precisely what *Babel* in the
    JavaScript ecosystem does, along with other tools like TypeScript, Traceur, and
    swc (see [Figure 2-1](#figure2-1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new JSX engine vs. using a JS preprocessor](assets/frea_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Creating a new JSX engine versus using a JS preprocessor
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Because of this, JSX cannot be used directly in the browser, but instead requires
    a “build step” where a custom parser runs against it, then compiles it into a
    syntax tree. This code is then transformed into vanilla JavaScript in a final,
    distributable bundle. This is called *transpilation*: transformed, then compiled
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, transpilation is the process of taking source code written in one
    language and transforming it into another language that has a similar level of
    abstraction. That’s why it’s also known as *source-to-source compilation*.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, it’s a type of translator. This generic term could refer to a compiler,
    assembler, or interpreter, for example. Conceptually, it’s near-identical to compiling,
    except the target language is something on a similar abstraction level like the
    source language.
  prefs: []
  type: TYPE_NORMAL
- en: For example, TypeScript is a high-level language that, when transpiled, is turned
    into JavaScript (another high-level language). Babel’s transpilation of ES6 JavaScript
    code into ES5 JavaScript is another example.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how we can build our own extension of JavaScript, let’s
    look at what we can do with this specific extension JSX.
  prefs: []
  type: TYPE_NORMAL
- en: The JSX Pragma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It all starts with `<`, which, on its own, is an unrecognizable character in
    JavaScript when used outside of comparison operations. When a JavaScript engine
    encounters this, it throws a `SyntaxError: Unexpected token ''<''`. In JSX, this
    “JSX pragma” can be transpiled into a function call. A pragma is a compiler directive
    to provide additional information to the compiler, usually beyond what is conveyed
    in the language itself. It can, for example, tell the compiler how it should handle
    some contents of a file.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of this in JavaScript are the “use strict” pragmas that we sometimes
    see atop older modules, and the recent “use client” pragma in the context of React
    Server Components (RSCs). More on those in [Chapter 9](ch09.html#ch09).
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the function to call when a parser sees a `<` pragma is configurable,
    and defaults to the function `React.createElement` or `_jsxs` with the newer transform,
    as discussed earlier. The signature of this function is expected to be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, it receives `tag`, `props`, and `children` as arguments. Here’s how
    JSX maps to regular JavaScript syntax. The following JSX code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the mapping between the tag (`MyComponent`), the props (`prop="value"`),
    and the children (`"contents"`). This is essentially the role of the JSX pragma:
    syntax sugar over multiple, recursive function calls. The JSX pragma is effectively
    an alias: `<` instead of `React.createElement`.'
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most powerful features of JSX is the ability to execute code inside
    a tree of elements. To iterate over a list as we did in [“Under the Hood”](#under_the_hood),
    we can put executable code inside curly braces like we did with our `map` earlier
    in this chapter. If we want to show a sum of two numbers in JSX, we’d do it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render `Here''s an expression: 3`, because the stuff inside curly
    brackets is executed as an expression. Using JSX expressions, we can iterate over
    lists and execute a variety of expressions, including conditional checks with
    ternary operations, string replacement, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example with a conditional check using a ternary operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render `Is b more than a? YES` since the comparison is an evaluated
    expression. For posterity, it’s worth mentioning here that JSX expressions are
    exactly that—expressions. It’s not possible to execute statements inside of a
    JSX element tree. This will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn’t work because statements do not return anything and are considered
    side effects: they set state without yielding a value. After statements and computations,
    how would we print a value inline? Notice that in the example, we just put the
    number `3` in there on line 6. How is our renderer supposed to know we intend
    to print `3`? This is why expressions are evaluated, but statements are not.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, we’ve covered a fair amount of ground on the topic of JSX. We should be
    feeling pretty confident (or even fluent, if you will) about the topic, to the
    point where we can confidently explain aspects of it.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s make sure you’ve fully grasped the topics we covered. Take a moment to
    answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX? What are some of its pros and cons?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between JSX and HTML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a string of text become machine code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are JSX expressions, and what benefits do they provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have trouble answering these questions, this chapter may be worth another
    read. If not, let’s explore the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Up Next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’re pretty fluent with JSX, let’s turn our attention to the next
    aspect of React and see how we can squeeze the most knowledge out of it to further
    boost our fluency. Let’s explore the virtual DOM.
  prefs: []
  type: TYPE_NORMAL
