<html><head></head><body><section data-pdf-bookmark="Chapter 11. Classes" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch11">&#13;
<h1><span class="label">Chapter 11. </span>Classes</h1>&#13;
&#13;
&#13;
<p><a data-primary="classes" data-secondary="overview" data-type="indexterm" id="id916"/>When TypeScript was released for the very first time in 2012, the JavaScript ecosystem and the features of the JavaScript language were not comparable to what we have today. TypeScript introduced many features not only in the form of a type system but also syntax, enriching an already existing language with possibilities to abstract parts of your code across modules, namespaces, and types.</p>&#13;
&#13;
<p>One of these features was classes, a staple in object-oriented programming. TypeScript’s classes originally drew a lot of influence from C#, which is not surprising if you know the people behind both programming languages.<sup><a data-type="noteref" href="ch11.html#id917" id="id917-marker">1</a></sup> But they are also designed based on concepts from the abandoned ECMAScript 4 proposals.</p>&#13;
&#13;
<p>Over time, JavaScript gained much of the language features pioneered by TypeScript and others; classes, along with private fields, static blocks, and decorators, are now part of the ECMAScript standard and have been shipped to language runtimes in the browser and the server.</p>&#13;
&#13;
<p>This leaves TypeScript in a sweet spot between the innovation it brought to the language in the early days and standards, which is what the TypeScript team sees as a baseline for all upcoming features of the type system. While the original design is close to what JavaScript ended up with, there are some differences worth mentioning.</p>&#13;
&#13;
<p>In this chapter, we look at how classes behave in TypeScript and JavaScript, the possibilities we have to express ourselves, and the differences between the standard and the original design. We look at keywords, types, and generics, and we train an eye to spot what’s being added by TypeScript to JavaScript, and what JavaScript brings to the table on its own.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.1 Choosing the Right Visibility Modifier" data-type="sect1"><div class="sect1" id="ch11_visibility_modifier">&#13;
<h1>11.1 Choosing the Right Visibility Modifier</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id166">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="access modifiers" data-type="indexterm" id="ix_11-01-asciidoc0"/><a data-primary="classes" data-secondary="choosing the right visibility modifier" data-type="indexterm" id="ix_11-01-asciidoc1"/><a data-primary="property visibility modifiers" data-type="indexterm" id="ix_11-01-asciidoc2"/><a data-primary="visibility, the right modifier for" data-type="indexterm" id="ix_11-01-asciidoc3"/>There are two flavors in TypeScript for property visibility and access: one through special keyword syntax—<code>public</code>, <code>protected</code>, <code>private</code>—and another one through actual JavaScript syntax, when properties start with a hash character. Which one should you choose?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id918">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Prefer JavaScript-native syntax as it has some implications at runtime that you don’t want to miss. If you rely on a complex setup that involves variations of visibility modifiers, stay with the TypeScript ones. They won’t go away.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id167">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>TypeScript’s classes have been around for quite a while, and while they draw huge inspiration from ECMAScript classes that followed a few years after, the TypeScript team also decided to introduce features that were useful and popular in traditional class-based object-oriented programming at the time.</p>&#13;
&#13;
<p>One of those features is <em>property visibility modifiers</em>, also referred to as <em>access modifiers</em>. Visibility modifiers are special keywords you can put in front of members—properties and methods—to tell the compiler how they can be seen and accessed from other parts of your software.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>All visibility modifiers, as well as JavaScript private fields, work on methods as well as properties.</p>&#13;
</div>&#13;
&#13;
<p>The default visibility modifier is <code>public</code>, which can be written explicitly or just &#13;
<span class="keep-together">omitted:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="kr">public</code> <code class="nx">name</code><code class="p">;</code> <code class="c1">// modifier public is optional</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">myName</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">).</code><code class="nx">name</code><code class="p">;</code> <code class="c1">// works</code></pre>&#13;
&#13;
<p>Another modifier is <code>protected</code>, limiting visibility to classes and subclasses:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="kr">protected</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">getName</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// access works</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">myName</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">).</code><code class="nx">name</code><code class="p">;</code>&#13;
<code class="c1">//                                   ^</code>&#13;
<code class="c1">// Property 'name' is private and only accessible within</code>&#13;
<code class="c1">// class 'Person'.(2341)</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Teacher</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">getFullName</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// access works</code>&#13;
    <code class="k">return</code> <code class="sb">`Professor </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>protected</code> access can be overwritten in derived classes to be <code>public</code> instead. &#13;
<span class="keep-together"><code>protected</code></span> access also prohibits accessing members from class references that are not from the same subclass. So while this works:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Player</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">pair</code><code class="p">(</code><code class="nx">p</code><code class="o">:</code> <code class="nx">Player</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// works</code>&#13;
    <code class="k">return</code> <code class="sb">`Pairing </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> with </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>using the base class or a different subclass won’t work:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Player</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">pair</code><code class="p">(</code><code class="nx">p</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="sb">`Pairing </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> with </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
    <code class="c1">//                                    ^</code>&#13;
    <code class="c1">// Property 'name' is protected and only accessible through an</code>&#13;
    <code class="c1">// instance of class 'Player'. This is an instance of</code>&#13;
    <code class="c1">// class 'Person'.(2446)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The last visibility modifier is <code>private</code>, which allows access only from within the same class:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">myName</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">).</code><code class="nx">name</code><code class="p">;</code>&#13;
<code class="c1">//                                   ^</code>&#13;
<code class="c1">// Property 'name' is protected and only accessible within</code>&#13;
<code class="c1">// class 'Person' and its subclasses.(2445)</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Teacher</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">getFullName</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="sb">`Professor </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
    <code class="c1">//                        ^</code>&#13;
    <code class="c1">// Property 'name' is private and only accessible</code>&#13;
    <code class="c1">// within class 'Person'.(2341)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Visibility modifiers also can be used in constructors as a shortcut to define properties and initialize them:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Category</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code>&#13;
    <code class="kr">public</code> <code class="nx">title</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
    <code class="kr">public</code> <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code>&#13;
    <code class="kr">private</code> <code class="nx">reference</code><code class="o">:</code> <code class="nx">bigint</code>&#13;
  <code class="p">)</code> <code class="p">{}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// transpiles to</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Category</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">title</code><code class="p">,</code> <code class="nx">id</code><code class="p">,</code> <code class="nx">reference</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">title</code> <code class="o">=</code> <code class="nx">title</code><code class="p">;</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="o">=</code> <code class="nx">id</code><code class="p">;</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">reference</code> <code class="o">=</code> <code class="nx">reference</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With all the features described here, it should be noted that TypeScript’s visibility modifiers are compile-time annotations that get erased after the compilation step. Often, entire property declarations get removed if they are not initialized via the class description but in the constructor, as we saw in the last example.</p>&#13;
&#13;
<p>They are also valid only during compile-time checks, meaning that a <code>private</code> property in TypeScript will be fully accessible in JavaScript afterward; thus, you can bypass the <code>private</code> access check by asserting your instances <code>as any</code>, or access them directly once your code has been compiled. They are also <em>enumerable</em>, which means that their names and values become visible when being serialized via <code>JSON.stringify</code> or <code>Object.getOwnPropertyNames</code>. In short: the moment they leave the boundaries of the type system they behave like regular JavaScript class members.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Next to visibility modifiers, it’s also possible to add <code>readonly</code> &#13;
<span class="keep-together">modifiers</span> to class properties.</p>&#13;
</div>&#13;
&#13;
<p><a data-primary="private fields" data-type="indexterm" id="ix_11-01-asciidoc4"/>Since limited access to properties is a feature that is reasonable not only within a type system, ECMAScript has adopted a similar concept called <em>private fields</em> for regular JavaScript classes.</p>&#13;
&#13;
<p><a data-primary="# (pound sign; hash)" data-type="indexterm" id="id919"/>Instead of a visibility modifier, private fields actually introduce new syntax in the form of a pound sign or <em>hash</em> in front of the member’s name.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Introducing a new syntax for private fields has resulted in heated debate within the community on the pleasance and aesthetics of the pound sign. Some participants even called them abominable. If this addition irritates you as well, it might help to think of the pound sign as a little fence that you put in front of the things you don’t want everybody to have access to. Suddenly, the pound sign syntax becomes a lot more pleasant.</p>&#13;
</div>&#13;
&#13;
<p>The pound sign becomes a part of the property’s name, meaning that it also needs to be accessed with the sign in front of it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="err">#</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// we can use getters!</code>&#13;
  <code class="nx">get</code> <code class="nx">name</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">name</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">me</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">);</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">me</code><code class="p">.</code><code class="err">#</code><code class="nx">name</code><code class="p">);</code>&#13;
<code class="c1">//              ^</code>&#13;
<code class="c1">// Property '#name' is not accessible outside</code>&#13;
<code class="c1">// class 'Person' because it has a private identifier.(18013)</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">me</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// works</code></pre>&#13;
&#13;
<p>Private fields are JavaScript through and through; there is nothing the TypeScript compiler will remove, and they retain their functionality—hiding information inside the class—even after the compilation step. The transpiled result, with the latest ECMAScript version as a target, looks almost identical to the TypeScript version, just without type annotations:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="err">#</code><code class="nx">name</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">get</code> <code class="nx">name</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">name</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Private fields can’t be accessed in runtime code, and they are also not enumerable, meaning that no information of their contents will be leaked in any way.</p>&#13;
&#13;
<p>The problem is now that both private visibility modifiers and private fields exist in TypeScript. Visibility modifiers have been there forever and have more variety combined with <code>protected</code> members. Private fields, on the other hand, are as close to JavaScript as they can get, and with TypeScript’s goal to be a “JavaScript syntax for types,” they pretty much hit the mark when it comes to the long-term plans of the language. So which one should you choose?</p>&#13;
&#13;
<p>First, no matter which modifier you choose, they both fulfill their goal of telling you at compile time when there’s property access where it shouldn’t be. This is the first feedback you get informing you that something might be wrong, and this is what we’re aiming for when we use TypeScript. So if you need to hide information from the outside, every tool does its job.</p>&#13;
&#13;
<p>But when you look further, it again depends on your setting. If you already set up a project with elaborate visibility rules, you might not be able to migrate them to the native JavaScript version immediately. Also, the lack of <code>protected</code> visibility in &#13;
<span class="keep-together">JavaScript</span> might be problematic for your goals. There is no need to change something if what you have already works.</p>&#13;
&#13;
<p>If you run into problems with the runtime visibility showing details you want to hide: if you depend on others using your code as a library and they should not be able to access all the internal information, then private fields are the way to go. They are well-supported in browsers and other language runtimes, and TypeScript comes with polyfills for older platforms<a data-startref="ix_11-01-asciidoc4" data-type="indexterm" id="id920"/>.<a data-startref="ix_11-01-asciidoc3" data-type="indexterm" id="id921"/><a data-startref="ix_11-01-asciidoc2" data-type="indexterm" id="id922"/><a data-startref="ix_11-01-asciidoc1" data-type="indexterm" id="id923"/><a data-startref="ix_11-01-asciidoc0" data-type="indexterm" id="id924"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.2 Explicitly Defining Method Overrides" data-type="sect1"><div class="sect1" id="ch11_overriding">&#13;
<h1>11.2 Explicitly Defining Method Overrides</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id168">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="base class" data-type="indexterm" id="ix_11-02-asciidoc0"/><a data-primary="classes" data-secondary="explicitly defining method overrides" data-type="indexterm" id="ix_11-02-asciidoc1"/><a data-primary="method overrides" data-type="indexterm" id="ix_11-02-asciidoc2"/>In your class hierarchy, you extend from base classes and override specific methods in subclasses. When you refactor the base class, you might end up carrying around old, unused methods because nothing tells you that the base class has changed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id925">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Switch on the <code>noImplicitOverride</code> flag and use the <code>override</code> keyword to signal overrides.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id169">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>You want to draw shapes on a canvas. Your software is able to take a collection of points with <code>x</code> and <code>y</code> coordinates, and based on a specific render function, it will draw either polygons, rectangles, or other elements on an HTML canvas.</p>&#13;
&#13;
<p>You decide to go for a class hierarchy, where the base class <code>Shape</code> takes an arbitrary list of <code>Point</code> elements and draws lines between them. This class takes care of housekeeping through setters and getters but also implements the <code>render</code> function itself:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Point</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Shape</code> <code class="p">{</code>&#13;
  <code class="nx">points</code><code class="o">:</code> <code class="nx">Point</code><code class="p">[];</code>&#13;
  <code class="nx">fillStyle</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="s2">"white"</code><code class="p">;</code>&#13;
  <code class="nx">lineWidth</code><code class="o">:</code> <code class="kt">number</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">points</code><code class="o">:</code> <code class="nx">Point</code><code class="p">[])</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">points</code> <code class="o">=</code> <code class="nx">points</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">set</code> <code class="nx">fill</code><code class="p">(</code><code class="nx">style</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">fillStyle</code> <code class="o">=</code> <code class="nx">style</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">set</code> <code class="nx">width</code><code class="p">(</code><code class="nx">width</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">lineWidth</code> <code class="o">=</code> <code class="nx">width</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">render</code><code class="p">(</code><code class="nx">ctx</code><code class="o">:</code> <code class="nx">CanvasRenderingContext2D</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">fillStyle</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">fillStyle</code><code class="p">;</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">lineWidth</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">lineWidth</code><code class="p">;</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">beginPath</code><code class="p">();</code>&#13;
      <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">moveTo</code><code class="p">(</code><code class="nx">point</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">point</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>&#13;
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">point</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>&#13;
        <code class="nx">ctx</code><code class="p">.</code><code class="nx">lineTo</code><code class="p">(</code><code class="nx">point</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">point</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>&#13;
      <code class="p">}</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">closePath</code><code class="p">();</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">stroke</code><code class="p">();</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To use it, create a 2D context from an HTML canvas element, create a new instance of <code>Shape</code>, and pass the context to the <code>render</code> function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">canvas</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementsByTagName</code><code class="p">(</code><code class="s2">"canvas"</code><code class="p">)[</code><code class="mi">0</code><code class="p">];</code>&#13;
<code class="kr">const</code> <code class="nx">ctx</code> <code class="o">=</code> <code class="nx">canvas</code><code class="o">?</code><code class="p">.</code><code class="nx">getContext</code><code class="p">(</code><code class="s2">"2d"</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">shape</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Shape</code><code class="p">([</code>&#13;
  <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">50</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">140</code> <code class="p">},</code>&#13;
  <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">150</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">60</code> <code class="p">},</code>&#13;
  <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">250</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">140</code> <code class="p">},</code>&#13;
<code class="p">]);</code>&#13;
<code class="nx">shape</code><code class="p">.</code><code class="nx">fill</code> <code class="o">=</code> <code class="s2">"red"</code><code class="p">;</code>&#13;
<code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">=</code> <code class="mi">20</code><code class="p">;</code>&#13;
&#13;
<code class="nx">shape</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="nx">ctx</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now we want to use the established base class and derive subclasses for specific shapes, like rectangles. We keep the housekeeping methods and specifically override the <code>constructor</code>, as well as the <code>render</code> method:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Rectangle</code> <code class="kr">extends</code> <code class="nx">Shape</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">points</code><code class="o">:</code> <code class="nx">Point</code><code class="p">[])</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">points</code><code class="p">.</code><code class="nx">length</code> <code class="o">!==</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">throw</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`Wrong number of points, expected 2, got </code><code class="si">${</code><code class="nx">points</code><code class="p">.</code><code class="nx">length</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
    <code class="kr">super</code><code class="p">(</code><code class="nx">points</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">render</code><code class="p">(</code><code class="nx">ctx</code><code class="o">:</code> <code class="nx">CanvasRenderingContext2D</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">ctx</code><code class="p">.</code><code class="nx">fillStyle</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">fillStyle</code><code class="p">;</code>&#13;
    <code class="nx">ctx</code><code class="p">.</code><code class="nx">lineWidth</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">lineWidth</code><code class="p">;</code>&#13;
    <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>&#13;
    <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>&#13;
    <code class="nx">ctx</code><code class="p">.</code><code class="nx">strokeRect</code><code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">a</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">b</code><code class="p">.</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">b</code><code class="p">.</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The usage of <code>Rectangle</code> is pretty much the same:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">rectangle</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Rectangle</code><code class="p">([</code>&#13;
  <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">130</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">190</code><code class="p">},</code>&#13;
  <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">170</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">250</code><code class="p">}</code>&#13;
<code class="p">]);</code>&#13;
<code class="nx">rectangle</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="nx">ctx</code><code class="p">);</code></pre>&#13;
&#13;
<p>As our software evolves, we inevitably change classes, methods, and functions, and somebody in our codebase will rename the <code>render</code> method to <code>draw</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Shape</code> <code class="p">{</code>&#13;
  <code class="c1">// see above</code>&#13;
&#13;
  <code class="nx">draw</code><code class="p">(</code><code class="nx">ctx</code><code class="o">:</code> <code class="nx">CanvasRenderingContext2D</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">fillStyle</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">fillStyle</code><code class="p">;</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">lineWidth</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">lineWidth</code><code class="p">;</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">beginPath</code><code class="p">();</code>&#13;
      <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">moveTo</code><code class="p">(</code><code class="nx">point</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">point</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>&#13;
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">point</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>&#13;
        <code class="nx">ctx</code><code class="p">.</code><code class="nx">lineTo</code><code class="p">(</code><code class="nx">point</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">point</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>&#13;
      <code class="p">}</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">closePath</code><code class="p">();</code>&#13;
      <code class="nx">ctx</code><code class="p">.</code><code class="nx">stroke</code><code class="p">();</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is not a problem per se, but if we are not using the <code>render</code> method of <code>Rectangle</code> anywhere in our code, perhaps because we publish this software as a library and didn’t use it in our tests, nothing tells us that the <code>render</code> method in <code>Rectangle</code> still exists, with no connection to the original class whatsoever.</p>&#13;
&#13;
<p>This is why TypeScript allows you to annotate methods you want to override with the <code>override</code> keyword. This is a syntax extension from TypeScript and will be removed the moment TypeScript transpiles your code to JavaScript.</p>&#13;
&#13;
<p class="pagebreak-before">When a method is marked with the <code>override</code> keyword, TypeScript will make sure that a method of the same name and signature exists in the base class. If you rename <code>render</code> to <code>draw</code>, TypeScript will tell you that the method <code>render</code> wasn’t declared in the base class <code>Shape</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Rectangle</code> <code class="kr">extends</code> <code class="nx">Shape</code> <code class="p">{</code>&#13;
  <code class="c1">// see above</code>&#13;
&#13;
  <code class="nx">override</code> <code class="nx">render</code><code class="p">(</code><code class="nx">ctx</code><code class="o">:</code> <code class="nx">CanvasRenderingContext2D</code><code class="p">)</code> <code class="p">{</code>&#13;
<code class="c1">//         ^</code>&#13;
<code class="c1">// This member cannot have an 'override' modifier because it</code>&#13;
<code class="c1">// is not declared in the base class 'Shape'.(4113)</code>&#13;
    <code class="nx">ctx</code><code class="p">.</code><code class="nx">fillStyle</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">fillStyle</code><code class="p">;</code>&#13;
    <code class="nx">ctx</code><code class="p">.</code><code class="nx">lineWidth</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">lineWidth</code><code class="p">;</code>&#13;
    <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>&#13;
    <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>&#13;
    <code class="nx">ctx</code><code class="p">.</code><code class="nx">strokeRect</code><code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">a</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">b</code><code class="p">.</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">b</code><code class="p">.</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This error is a great safeguard to ensure that renames and refactors don’t break your existing contracts.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Even though a <code>constructor</code> could be seen as an overridden method, its semantics are different and handled through other rules (for example, making sure that you call <code>super</code> when instantiating a subclass).</p>&#13;
</div>&#13;
&#13;
<p>By switching on the <code>noImplicitOverrides</code> flag in your <em>tsconfig.json</em>, you can further ensure that you need to mark functions with the <code>override</code> keyword. Otherwise, TypeScript will throw another error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Rectangle</code> <code class="kr">extends</code> <code class="nx">Shape</code> <code class="p">{</code>&#13;
  <code class="c1">// see above</code>&#13;
&#13;
  <code class="nx">draw</code><code class="p">(</code><code class="nx">ctx</code><code class="o">:</code> <code class="nx">CanvasRenderingContext2D</code><code class="p">)</code> <code class="p">{</code>&#13;
<code class="c1">// ^</code>&#13;
<code class="c1">// This member must have an 'override' modifier because it</code>&#13;
<code class="c1">// overrides a member in the base class 'Shape'.(4114)</code>&#13;
    <code class="nx">ctx</code><code class="p">.</code><code class="nx">fillStyle</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">fillStyle</code><code class="p">;</code>&#13;
    <code class="nx">ctx</code><code class="p">.</code><code class="nx">lineWidth</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">lineWidth</code><code class="p">;</code>&#13;
    <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>&#13;
    <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">points</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>&#13;
    <code class="nx">ctx</code><code class="p">.</code><code class="nx">strokeRect</code><code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">a</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">b</code><code class="p">.</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">b</code><code class="p">.</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Techniques like implementing interfaces that define the basic shape of a class already provide a solid baseline to prevent you from running into problems like this. So, it’s good to see the <code>override</code> keyword and <code>noImplictOverrides</code> as additional safeguards when &#13;
<span class="keep-together">creating</span> class hierarchies.</p>&#13;
</div>&#13;
&#13;
<p>When your software needs to rely on class hierarchies to work, using <code>override</code> together with <code>noImplicitAny</code> is a good way to ensure that you don’t forget anything. Class hierarchies, like any hierarchies, tend to grow complicated over time, so take any safeguard you can get.<a data-startref="ix_11-02-asciidoc2" data-type="indexterm" id="id926"/><a data-startref="ix_11-02-asciidoc1" data-type="indexterm" id="id927"/><a data-startref="ix_11-02-asciidoc0" data-type="indexterm" id="id928"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.3 Describing Constructors and Prototypes" data-type="sect1"><div class="sect1" id="ch11_constructor_interfaace">&#13;
<h1>11.3 Describing Constructors and Prototypes</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id170">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="abstract classes" data-secondary="describing constructors and prototypes" data-type="indexterm" id="ix_11-03-asciidoc0"/><a data-primary="class hierarchies" data-type="indexterm" id="ix_11-03-asciidoc1"/><a data-primary="classes" data-secondary="describing constructors and prototypes" data-type="indexterm" id="ix_11-03-asciidoc2"/><a data-primary="constructor interface pattern" data-type="indexterm" id="ix_11-03-asciidoc3"/><a data-primary="instantiation" data-secondary="describing constructors and prototypes" data-type="indexterm" id="ix_11-03-asciidoc4"/>You want to instantiate subclasses of a specific abstract class dynamically, but TypeScript won’t allow you to instantiate abstract classes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id929">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Describe your classes with the <em>constructor interface</em> pattern.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id171">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>If you use class hierarchies with TypeScript, the structural features of TypeScript sometimes get in your way. Look at the following class hierarchy for instance, where we want to filter a set of elements based on different rules:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">abstract</code> <code class="kr">class</code> <code class="nx">FilterItem</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code> <code class="nx">property</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{};</code>&#13;
  <code class="nx">someFunction</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">};</code>&#13;
  <code class="kr">abstract</code> <code class="nx">filter</code><code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">AFilter</code> <code class="kr">extends</code> <code class="nx">FilterItem</code> <code class="p">{</code>&#13;
  <code class="nx">filter</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
&#13;
<code class="kr">class</code> <code class="nx">BFilter</code> <code class="kr">extends</code> <code class="nx">FilterItem</code> <code class="p">{</code>&#13;
  <code class="nx">filter</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">The <code>FilterItem</code> abstract class needs to be implemented by other classes. In this example <code>AFilter</code> and <code>BFilter</code>, both concretizations of <code>FilterItem</code>, serve as a baseline for filters:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">some</code><code class="o">:</code> <code class="nx">FilterItem</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">AFilter</code><code class="p">(</code><code class="s1">'afilter'</code><code class="p">);</code> <code class="c1">// ok</code></pre>&#13;
&#13;
<p>Things get interesting when we are not working with instances right off the bat. Let’s say we want to instantiate new filters based on a token we get from an AJAX call. To make it easier for us to select the filter, we store all possible filters in a map:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kr">const</code> <code class="nx">filterMap</code><code class="o">:</code> <code class="nx">Map</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="k">typeof</code> <code class="nx">FilterItem</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="nx">filterMap</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'number'</code><code class="p">,</code> <code class="nx">AFilter</code><code class="p">);</code>&#13;
<code class="nx">filterMap</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'stuff'</code><code class="p">,</code> <code class="nx">BFilter</code><code class="p">);</code></pre>&#13;
&#13;
<p>The map’s generics are set to a <code>string</code> (for the token from the backend) and everything that complements the type signature of <code>FilterItem</code>. We use the <code>typeof</code> keyword here to be able to add classes to the map, not objects. We want to instantiate them afterward, after all.</p>&#13;
&#13;
<p>So far everything works as you would expect. The problem occurs when you want to fetch a class from the map and create a new object with it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">obj</code><code class="o">:</code> <code class="nx">FilterItem</code><code class="p">;</code>&#13;
<code class="c1">// get the constructor</code>&#13;
<code class="kr">const</code> <code class="nx">ctor</code> <code class="o">=</code> <code class="nx">filterMap</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'number'</code><code class="p">);</code>&#13;
&#13;
<code class="k">if</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">ctor</code> <code class="o">!==</code> <code class="s1">'undefined'</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">obj</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ctor</code><code class="p">();</code>&#13;
<code class="c1">//          ^</code>&#13;
<code class="c1">// cannot create an object of an abstract class</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is a problem! TypeScript only knows at this point that we get a <code>FilterItem</code> back and we can’t instantiate <code>FilterItem</code>. Abstract classes mix type information (<em>type namespace</em>) with an actual implementation (<em>value namespace</em>). As a first step, let’s just look at the types: what are we expecting to get back from <code>filterMap</code>? Let’s create an interface (or type alias) that defines how the <em>shape</em> of <code>FilterItem</code> should look:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">interface</code> <code class="nx">IFilter</code> <code class="p">{</code>&#13;
  <code class="k">new</code><code class="p">(</code><code class="nx">property</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">IFilter</code><code class="p">;</code>&#13;
  <code class="nx">someFunction</code><code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="nx">filter</code><code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">declare</code> <code class="kr">const</code> <code class="nx">filterMap</code><code class="o">:</code> <code class="nx">Map</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="nx">IFilter</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Note the <code>new</code> keyword. This is a way for TypeScript to define the type signature of a constructor function. If we substitute the abstract class for an actual interface, lots of errors start appearing. No matter where you put the <code>implements IFilter</code> command, no implementation seems to satisfy our contract:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">abstract</code> <code class="kr">class</code> <code class="nx">FilterItem</code> <code class="kr">implements</code> <code class="nx">IFilter</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="c1">// ^</code>&#13;
<code class="c1">// Class 'FilterItem' incorrectly implements interface 'IFilter'.</code>&#13;
<code class="c1">// Type 'FilterItem' provides no match for the signature</code>&#13;
<code class="c1">// 'new (property: string): IFilter'.</code>&#13;
&#13;
<code class="nx">filterMap</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'number'</code><code class="p">,</code> <code class="nx">AFilter</code><code class="p">);</code>&#13;
<code class="c1">//                      ^</code>&#13;
<code class="c1">// Argument of type 'typeof AFilter' is not assignable</code>&#13;
<code class="c1">// to parameter of type 'IFilter'. Type 'typeof AFilter' is missing</code>&#13;
<code class="c1">// the following properties from type 'IFilter': someFunction, filter</code></pre>&#13;
&#13;
<p>What’s happening here? It seems like neither the implementation nor the class itself can get all the properties and functions we’ve defined in our interface declaration. Why?</p>&#13;
&#13;
<p>JavaScript classes are special; they have not just one type we could easily define but two: the type of the static side and the type of the instance side. It might be clearer if we transpile our class to what it was before ES6, a constructor function and a &#13;
<span class="keep-together">prototype:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">AFilter</code><code class="p">(</code><code class="nx">property</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// this is part of the static side</code>&#13;
  <code class="k">this</code><code class="p">.</code><code class="nx">property</code> <code class="o">=</code> <code class="nx">property</code><code class="p">;</code>  <code class="c1">// this is part of the instance side</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// a function of the instance side</code>&#13;
<code class="nx">AFilter</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">filter</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code><code class="cm">/* ... */</code><code class="p">}</code>&#13;
&#13;
<code class="c1">// not part of our example, but on the static side</code>&#13;
<code class="nx">Afilter</code><code class="p">.</code><code class="nx">something</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code></pre>&#13;
&#13;
<p>One type to create the object. One type for the object itself. So let’s split it up and create two type declarations for it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">interface</code> <code class="nx">FilterConstructor</code> <code class="p">{</code>&#13;
  <code class="k">new</code> <code class="p">(</code><code class="nx">property</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">IFilter</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">IFilter</code> <code class="p">{</code>&#13;
  <code class="nx">someFunction</code><code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="nx">filter</code><code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The first type, <code>FilterConstructor</code>, is the <em>constructor interface</em>. Here are all static properties and the constructor function itself. The constructor function returns an instance: <code>IFilter</code>. <code>IFilter</code> contains type information of the instance side. All the functions we declare.</p>&#13;
&#13;
<p class="pagebreak-before">By splitting this up, our subsequent typings also become a lot clearer:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kr">const</code> <code class="nx">filterMap</code><code class="o">:</code> <code class="nx">Map</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="nx">FilterConstructor</code><code class="o">&gt;</code><code class="p">;</code>  <code class="cm">/* 1 */</code>&#13;
&#13;
<code class="nx">filterMap</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'number'</code><code class="p">,</code> <code class="nx">AFilter</code><code class="p">);</code>&#13;
<code class="nx">filterMap</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'stuff'</code><code class="p">,</code> <code class="nx">BFilter</code><code class="p">);</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">obj</code><code class="o">:</code> <code class="nx">IFilter</code><code class="p">;</code>  <code class="cm">/* 2 */</code>&#13;
<code class="kr">const</code> <code class="nx">ctor</code> <code class="o">=</code> <code class="nx">filterMap</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'number'</code><code class="p">);</code>&#13;
<code class="k">if</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">ctor</code> <code class="o">!==</code> <code class="s1">'undefined'</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">obj</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ctor</code><code class="p">(</code><code class="s1">'a'</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
<ol>&#13;
<li>&#13;
<p>We add instances of type <code>FilterConstructor</code> to our map. This means we only can add classes that produce the desired objects.</p>&#13;
</li>&#13;
<li>&#13;
<p>What we want in the end is an instance of <code>IFilter</code>. This is what the constructor function returns when being called with <code>new</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Our code compiles again, and we get all the autocompletion and tooling we desire. Even better, we are not able to add abstract classes to the map because they don’t produce a valid instance:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">filterMap</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'notworking'</code><code class="p">,</code> <code class="nx">FilterItem</code><code class="p">);</code>&#13;
<code class="c1">//                          ^</code>&#13;
<code class="c1">// Cannot assign an abstract constructor type to a</code>&#13;
<code class="c1">// non-abstract constructor type.</code></pre>&#13;
&#13;
<p>The constructor interface pattern is used throughout TypeScript and the standard library. To get an idea, look at the <code>ObjectContructor</code> interface from <em>lib.es5.d.ts</em>.<a data-startref="ix_11-03-asciidoc4" data-type="indexterm" id="id930"/><a data-startref="ix_11-03-asciidoc3" data-type="indexterm" id="id931"/><a data-startref="ix_11-03-asciidoc2" data-type="indexterm" id="id932"/><a data-startref="ix_11-03-asciidoc1" data-type="indexterm" id="id933"/><a data-startref="ix_11-03-asciidoc0" data-type="indexterm" id="id934"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.4 Using Generics in Classes" data-type="sect1"><div class="sect1" id="ch11_generic_classes">&#13;
<h1>11.4 Using Generics in Classes</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id231">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="using generics in" data-type="indexterm" id="ix_11-04-asciidoc0"/><a data-primary="generics" data-secondary="using in classes" data-type="indexterm" id="ix_11-04-asciidoc1"/>TypeScript generics are designed to be inferred a lot, but in classes, this doesn’t always work.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id935">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Explicitly annotate generics at instantiation if you can’t infer them from your parameters; otherwise, they default to <code>unknown</code> and accept a broad range of values. Use generic constraints and default parameters for extra safety.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id172">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Classes also allow for generics. Instead of only being able to add generic type parameters to functions, we can also add generic type parameters to classes. While generic type parameters at class methods are valid only in function scope, generic type parameters for classes are valid for the entirety of a class.</p>&#13;
&#13;
<p>Let’s create a collection, a simple wrapper around an array with a restricted set of convenience functions. We can add <code>T</code> to the class definition of <code>Collection</code> and reuse this type parameter throughout the entire class:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Collection</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">items</code><code class="o">:</code> <code class="nx">T</code><code class="p">[];</code>&#13;
  <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">items</code> <code class="o">=</code> <code class="p">[];</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">add</code><code class="p">(</code><code class="nx">item</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">contains</code><code class="p">(</code><code class="nx">item</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With that, we are able to explicitly substitute <code>T</code> with a generic type annotation, for example, allowing a collection of only numbers or only strings:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">numbers</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Collection</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">();</code>&#13;
<code class="nx">numbers</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>&#13;
<code class="nx">numbers</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">strings</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Collection</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">();</code>&#13;
<code class="nx">strings</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">);</code>&#13;
<code class="nx">strings</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s2">"World"</code><code class="p">);</code></pre>&#13;
&#13;
<p>We as developers are not required to explicitly annotate generic type parameters. TypeScript usually tries to infer generic types from usage. <a data-primary="unknown type" data-secondary="in absence of generic type parameter" data-secondary-sortas="absence" data-type="indexterm" id="id936"/>If we <em>forget</em> to add a generic type parameter, TypeScript falls back to <code>unknown</code>, allowing us to add everything:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">unknowns</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Collection</code><code class="p">();</code>&#13;
<code class="nx">unknowns</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>&#13;
<code class="nx">unknowns</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s2">"World"</code><code class="p">);</code></pre>&#13;
&#13;
<p>Let’s stay at this point for a second. TypeScript is very honest with us. The moment we construct a new instance of <code>Collection</code>, we don’t know what the type of our items is. <code>unknown</code> is the most accurate depiction of the collection’s state. And it comes with all the downsides: we can add anything, and we need to do type-checks every time we retrieve a value. While TypeScript does the only thing possible at this point, we might want to do better. A concrete type for <code>T</code> is mandatory for <code>Collection</code> to properly work.</p>&#13;
&#13;
<p>Let’s see if we can rely on inference. TypeScript’s inference on classes works just like it does on functions. If there is a parameter of a certain type, TypeScript will take this type and substitute the generic type parameter. Classes are designed to keep state, and state changes throughout their use. The state also defines our generic type parameter <code>T</code>. To correctly infer <code>T</code>, we need to require a parameter at construction, maybe an initial value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Collection</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">items</code><code class="o">:</code> <code class="nx">T</code><code class="p">[];</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">initial</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">items</code> <code class="o">=</code> <code class="p">[</code><code class="nx">initial</code><code class="p">];</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">add</code><code class="p">(</code><code class="nx">item</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">contains</code><code class="p">(</code><code class="nx">item</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// T is number!</code>&#13;
<code class="kr">const</code> <code class="nx">numbersInf</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Collection</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
<code class="nx">numbersInf</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code></pre>&#13;
&#13;
<p>This works, but it leaves a lot to be desired for our API design. What if we don’t have initial values? While other classes might have parameters that can be used for inference, this might not make a lot of sense for a collection of various items.</p>&#13;
&#13;
<p>For <code>Collection</code>, it is absolutely essential to provide a type through annotation. The only way left is to ensure we don’t forget to add an annotation. <a data-primary="never type" data-secondary="when using generics in classes" data-type="indexterm" id="id937"/>To achieve this, we can make sure of TypeScript’s generic default parameters and the bottom type <code>never</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Collection</code><code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="kr">never</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">items</code><code class="o">:</code> <code class="nx">T</code><code class="p">[];</code>&#13;
  <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">items</code> <code class="o">=</code> <code class="p">[];</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">add</code><code class="p">(</code><code class="nx">item</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">contains</code><code class="p">(</code><code class="nx">item</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We set the generic type parameter <code>T</code> to default to <code>never</code>, which adds some very interesting behavior to our class. <code>T</code> still can be explicitly substituted with every type through annotation, working just as before, but the moment we forget an annotation the type is not <code>unknown</code>, it’s <code>never</code>. Meaning that no value is compatible with our collection, resulting in many errors the moment we try to add something:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">nevers</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Collection</code><code class="p">();</code>&#13;
<code class="nx">nevers</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>&#13;
<code class="c1">//     ^</code>&#13;
<code class="c1">// Argument of type 'number' is not assignable</code>&#13;
<code class="c1">// to parameter of type 'never'.(2345)</code>&#13;
<code class="nx">nevers</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s2">"World"</code><code class="p">);</code>&#13;
<code class="c1">//     ^</code>&#13;
<code class="c1">// Argument of type 'string' is not assignable</code>&#13;
<code class="c1">// to parameter of type 'never'.(2345)</code></pre>&#13;
&#13;
<p>This fallback makes the use of our generic classes a lot safer.<a data-startref="ix_11-04-asciidoc1" data-type="indexterm" id="id938"/><a data-startref="ix_11-04-asciidoc0" data-type="indexterm" id="id939"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.5 Deciding When to Use Classes or Namespaces" data-type="sect1"><div class="sect1" id="ch11_when_to_use_classes">&#13;
<h1>11.5 Deciding When to Use Classes or Namespaces</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id232">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="deciding when to use classes or namespaces" data-type="indexterm" id="ix_11-06-asciidoc0"/>TypeScript offers a lot of syntax for object-oriented concepts like namespaces, or static and abstract classes. Those features don’t exist in JavaScript, so what should you do?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id940">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Stick with namespace declarations for additional type declarations, avoid abstract classes when possible, and prefer ECMAScript modules instead of static classes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id173">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>One thing we see from people who worked a lot with traditional object-oriented programming languages like Java or C# is their urge to wrap everything inside a class. In Java, you don’t have any other options as classes are the only way to structure code. In JavaScript (and thus TypeScript), plenty of other possibilities do what you want without any extra steps. One of those is static classes or classes with static methods:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Environment.ts</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="nx">Environment</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="kr">static</code> <code class="nx">variableList</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[]</code>&#13;
  <code class="kr">static</code> <code class="nx">variables</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
  <code class="kr">static</code> <code class="nx">setVariable</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>  <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
  <code class="kr">static</code> <code class="nx">getValue</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kr">unknown</code>  <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Usage in another file</code>&#13;
<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">Environment</code> <code class="nx">from</code> <code class="s2">"./Environment"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">Environment</code><code class="p">.</code><code class="nx">variables</code><code class="p">());</code></pre>&#13;
&#13;
<p>While this works and is even—sans type annotations—valid JavaScript, it’s way too much ceremony for something that can easily be just plain, boring functions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Environment.ts</code>&#13;
<code class="kr">const</code> <code class="nx">variableList</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="p">[]</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">variables</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">setVariable</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>  <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">getValue</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kr">unknown</code>  <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
&#13;
<code class="c1">// Usage in another file</code>&#13;
<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">Environment</code> <code class="nx">from</code> <code class="s2">"./Environment"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">Environment</code><code class="p">.</code><code class="nx">variables</code><code class="p">());</code></pre>&#13;
&#13;
<p>The interface for your users is exactly the same. You can access module scope variables just the way you would access static properties in a class, but you have them module scoped automatically. You decide what to export and what to make visible, not some TypeScript field modifiers. Also, you don’t end up creating an <code>Environment</code> instance that doesn’t do anything.</p>&#13;
&#13;
<p>Even the implementation becomes easier. Check out the class version of &#13;
<span class="keep-together"><code>variables()</code>:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="nx">Environment</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="kr">static</code> <code class="nx">variableList</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>&#13;
  <code class="kr">static</code> <code class="nx">variables</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">variableList</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>as opposed to the module version:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">variableList</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="p">[]</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">variables</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">variableList</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>No <code>this</code> means less to think about. As an added benefit, your bundlers have an easier time doing tree shaking, so you end up with only the things you actually use:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Only the variables function and variableList</code>&#13;
<code class="c1">// end up in the bundle</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">variables</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./Environment"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">variables</code><code class="p">());</code></pre>&#13;
&#13;
<p>That’s why a proper module is always preferred to a class with static fields and methods. That’s just an added boilerplate with no extra benefit.</p>&#13;
&#13;
<p><a data-primary="namespaces" data-secondary="deciding when to use" data-type="indexterm" id="ix_11-06-asciidoc1"/>As with static classes, people with a Java or C# background cling to namespaces, a feature that TypeScript introduced to organize code long before ECMAScript &#13;
<span class="keep-together">modules</span> were standardized. They allowed you to split things across files, merging them again with reference markers:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// file users/models.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Users</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kr">interface</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// file users/controller.ts</code>&#13;
&#13;
<code class="c1">/// &lt;reference path="./models.ts" /&gt;</code>&#13;
<code class="nx">namespace</code> <code class="nx">Users</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">updateUser</code><code class="p">(</code><code class="nx">p</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// do the rest</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Back then, TypeScript even had a bundling feature. It should still work. But as noted, this was before ECMAScript introduced modules. Now with modules, we have a way to organize and structure code that is compatible with the rest of the JavaScript ecosystem. And that’s a plus.</p>&#13;
&#13;
<p>So why do we need namespaces? Namespaces are still valid if you want to extend definitions from a third-party dependency, for example, that lives inside node modules. Say you want to extend the global <code>JSX</code> namespace and make sure <code>img</code> elements feature alt texts:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">namespace</code> <code class="nx">JSX</code> <code class="p">{</code>&#13;
  <code class="kr">interface</code> <code class="nx">IntrinsicElements</code> <code class="p">{</code>&#13;
    <code class="s2">"img"</code><code class="o">:</code> <code class="nx">HTMLAttributes</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
      <code class="nx">alt</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
      <code class="nx">src</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
      <code class="nx">loading</code><code class="o">?:</code> <code class="s1">'lazy'</code> <code class="o">|</code> <code class="s1">'eager'</code> <code class="o">|</code> <code class="s1">'auto'</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Or you want to write elaborate type definitions in ambient modules. But other than that? There is not much use for it anymore.</p>&#13;
&#13;
<p>Namespaces wrap your definitions into an object, writing something like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">Users</code> <code class="p">{</code>&#13;
  <code class="kr">type</code> <code class="nx">User</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">createUser</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">User</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">age</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This emits something very elaborate:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kd">var</code> <code class="nx">Users</code><code class="p">;</code>&#13;
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">Users</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kd">function</code> <code class="nx">createUser</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">age</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="p">{</code>&#13;
            <code class="nx">name</code><code class="p">,</code> <code class="nx">age</code>&#13;
        <code class="p">};</code>&#13;
    <code class="p">}</code>&#13;
    <code class="nx">Users</code><code class="p">.</code><code class="nx">createUser</code> <code class="o">=</code> <code class="nx">createUser</code><code class="p">;</code>&#13;
<code class="p">})(</code><code class="nx">Users</code> <code class="o">||</code> <code class="p">(</code><code class="nx">Users</code> <code class="o">=</code> <code class="p">{}));</code></pre>&#13;
&#13;
<p>This not only adds cruft but also keeps your bundlers from tree shaking properly! Using them also becomes a bit wordier:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">Users</code> <code class="nx">from</code> <code class="s2">"./users"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">Users</code><code class="p">.</code><code class="nx">Users</code><code class="p">.</code><code class="nx">createUser</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">,</code> <code class="s2">"39"</code><code class="p">);</code></pre>&#13;
&#13;
<p>Dropping them makes things a lot easier. Stick to what JavaScript offers. Not using namespaces outside of declaration files makes your code clear, simple, and tidy.<a data-startref="ix_11-06-asciidoc1" data-type="indexterm" id="id941"/></p>&#13;
&#13;
<p><a data-primary="abstract classes" data-secondary="when to use" data-type="indexterm" id="ix_11-06-asciidoc2"/>Last but not least, there are abstract classes. Abstract classes are a way to structure a more complex class hierarchy where you predefine a behavior but leave the actual implementation of some features to classes that <em>extend</em> from your abstract class:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">abstract</code> <code class="kr">class</code> <code class="nx">Lifeform</code> <code class="p">{</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">age</code> <code class="o">=</code> <code class="nx">age</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="kr">abstract</code> <code class="nx">move</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Human</code> <code class="kr">extends</code> <code class="nx">Lifeform</code> <code class="p">{</code>&#13;
  <code class="nx">move</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="s2">"Walking, mostly..."</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It’s for all subclasses of <code>Lifeform</code> to implement <code>move</code>. This is a concept that exists in basically every class-based programming language. The problem is that JavaScript isn’t traditionally class based. For example, an abstract class like the following generates a valid JavaScript class but is not allowed to be instantiated in TypeScript:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">abstract</code> <code class="kr">class</code> <code class="nx">Lifeform</code> <code class="p">{</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">age</code> <code class="o">=</code> <code class="nx">age</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">lifeform</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Lifeform</code><code class="p">(</code><code class="mi">20</code><code class="p">);</code>&#13;
<code class="c1">//               ^</code>&#13;
<code class="c1">// Cannot create an instance of an abstract class.(2511)</code></pre>&#13;
&#13;
<p>This can lead to some unwanted situations if you’re writing regular JavaScript but rely on TypeScript to provide the information in the form of implicit documentation, such as if a function definition looks like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kd">function</code> <code class="nx">moveLifeform</code><code class="p">(</code><code class="nx">lifeform</code><code class="o">:</code> <code class="nx">Lifeform</code><code class="p">);</code></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You or your users might read this as an invitation to pass a <code>Lifeform</code> object to <code>moveLifeform</code>. Internally, it calls <code>lifeform.move()</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Lifeform</code> can be instantiated in JavaScript, as it is a valid class.</p>&#13;
</li>&#13;
<li>&#13;
<p>The method <code>move</code> does not exist in <code>Lifeform</code>, thus breaking your application!</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This is due to a false sense of security. What you actually want is to put some pre-defined implementation in the prototype chain and have a contract that tells you what to expect:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">interface</code> <code class="nx">Lifeform</code> <code class="p">{</code>&#13;
  <code class="nx">move</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">BasicLifeForm</code> <code class="p">{</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">age</code> <code class="o">=</code> <code class="nx">age</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Human</code> <code class="kr">extends</code> <code class="nx">BasicLifeForm</code> <code class="kr">implements</code> <code class="nx">Lifeform</code> <code class="p">{</code>&#13;
  <code class="nx">move</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="s2">"Walking"</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The moment you look up <code>Lifeform</code>, you can see the interface and everything it expects, but you seldom run into a situation where you instantiate the wrong class by accident.</p>&#13;
&#13;
<p>With everything said about when <em>not</em> to use classes and namespaces, when should you use them? Every time you need multiple instances of the same object, where the internal state is paramount to the functionality of the object<a data-startref="ix_11-06-asciidoc2" data-type="indexterm" id="id942"/>.<a data-startref="ix_11-06-asciidoc0" data-type="indexterm" id="id943"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.6 Writing Static Classes" data-type="sect1"><div class="sect1" id="ch11_static_classes">&#13;
<h1>11.6 Writing Static Classes</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id174">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="writing static classes" data-type="indexterm" id="ix_11-05-asciidoc0"/><a data-primary="static classes" data-type="indexterm" id="ix_11-05-asciidoc1"/><a data-primary="static modifiers" data-type="indexterm" id="ix_11-05-asciidoc2"/>Class-based object-oriented programming taught you to use static classes for certain features, but you wonder how those principles are supported in TypeScript.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id944">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Traditional static classes don’t exist in TypeScript, but TypeScript has static modifiers for class members for several purposes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id175">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Static classes are classes that can’t be instantiated into concrete objects. Their purpose is to contain methods and other members that exist once and are the same when being accessed from various points in your code. Static classes are necessary for programming languages that have only classes as their means of abstraction, like Java or C#. In JavaScript, and subsequently TypeScript, there are many more ways to express ourselves.</p>&#13;
&#13;
<p>In TypeScript, we can’t declare classes to be <code>static</code>, but we can define <code>static</code> members on classes. The behavior is what you’d expect: the method or property is not part of an object but can be accessed from the class itself.</p>&#13;
&#13;
<p>As we saw in <a data-type="xref" href="#ch11_when_to_use_classes">Recipe 11.5</a>, classes with only static members are an antipattern in TypeScript. Functions exist; you can keep state per module. A combination of exported functions and module-scoped entries is usually the way to go:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Anti-Pattern</code>&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="nx">Environment</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="kr">static</code> <code class="nx">variableList</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[]</code>&#13;
  <code class="kr">static</code> <code class="nx">variables</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
  <code class="kr">static</code> <code class="nx">setVariable</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>  <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
  <code class="kr">static</code> <code class="nx">getValue</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kr">unknown</code>  <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Better: Module-scoped functions and variables</code>&#13;
<code class="kr">const</code> <code class="nx">variableList</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="p">[]</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">variables</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">setVariable</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>  <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">getValue</code><code class="p">(</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kr">unknown</code>  <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code></pre>&#13;
&#13;
<p>But there is still a use for <code>static</code> parts of a class. We established in <a data-type="xref" href="#ch11_constructor_interfaace">Recipe 11.3</a> that a class consists of static members and dynamic members.</p>&#13;
&#13;
<p>The <code>constructor</code> is part of the static features of a class, and properties and methods are part of the dynamic features of a class. With the <code>static</code> keyword we can add to those static features.</p>&#13;
&#13;
<p>Let’s think of a class called <code>Point</code> that describes a point in a two-dimensional space. It has <code>x</code> and <code>y</code> coordinates, and we create a method that calculates the distance between this point and another one:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Point</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="nx">x</code><code class="p">;</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="nx">y</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">distanceTo</code><code class="p">(</code><code class="nx">point</code><code class="o">:</code> <code class="nx">Point</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">dx</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">point</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
    <code class="kr">const</code> <code class="nx">dy</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">point</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>&#13;
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">dx</code> <code class="o">*</code> <code class="nx">dx</code> <code class="o">+</code> <code class="nx">dy</code> <code class="o">*</code> <code class="nx">dy</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Point</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Point</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">distance</code> <code class="o">=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">distanceTo</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code></pre>&#13;
&#13;
<p>This is good behavior, but the API might feel a bit weird if we choose a starting point and end point, especially since the distance is the same no matter which one is first. A static method on <code>Point</code> gets rid of the order, and we have a nice <code>distance</code> method that takes two arguments:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Point</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="nx">x</code><code class="p">;</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="nx">y</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">distanceTo</code><code class="p">(</code><code class="nx">point</code><code class="o">:</code> <code class="nx">Point</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">dx</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">point</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
    <code class="kr">const</code> <code class="nx">dy</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">point</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>&#13;
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">dx</code> <code class="o">*</code> <code class="nx">dx</code> <code class="o">+</code> <code class="nx">dy</code> <code class="o">*</code> <code class="nx">dy</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="kr">static</code> <code class="nx">distance</code><code class="p">(</code><code class="nx">p1</code><code class="o">:</code> <code class="nx">Point</code><code class="p">,</code> <code class="nx">p2</code><code class="o">:</code> <code class="nx">Point</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">p1</code><code class="p">.</code><code class="nx">distanceTo</code><code class="p">(</code><code class="nx">p2</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Point</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Point</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">distance</code> <code class="o">=</code> <code class="nx">Point</code><code class="p">.</code><code class="nx">distance</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">);</code></pre>&#13;
&#13;
<p>A similar version using the constructor function/prototype pattern that was used pre-ECMAScript classes in JavaScript would look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Point</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="nx">x</code><code class="p">;</code>&#13;
  <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="nx">y</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">Point</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">distanceTo</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">p</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">dx</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">p</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
  <code class="kr">const</code> <code class="nx">dy</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>&#13;
  <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">dx</code> <code class="o">*</code> <code class="nx">dx</code> <code class="o">+</code> <code class="nx">dy</code> <code class="o">*</code> <code class="nx">dy</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">Point</code><code class="p">.</code><code class="nx">distance</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code><code class="p">.</code><code class="nx">distanceTo</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As in <a data-type="xref" href="#ch11_constructor_interfaace">Recipe 11.3</a>, we can easily see which parts are static and which parts are dynamic. Everything that is in the <em>prototype</em> belongs to the dynamic parts. Everything else is <em>static</em>.</p>&#13;
&#13;
<p>But classes are not only syntactic sugar to the constructor function/prototype pattern. With the inclusion of private fields, which are absent in regular objects, we can do something that is actually related to classes and their instances.</p>&#13;
&#13;
<p>If we want to, for example, hide the <code>distanceTo</code> method because it might be confusing and we’d prefer our users to use the static method instead, a simple private modifier in front of <code>distanceTo</code> makes it inaccessible from the outside but still keeps it accessible from within static members:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Point</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="nx">x</code><code class="p">;</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="nx">y</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="err">#</code><code class="nx">distanceTo</code><code class="p">(</code><code class="nx">point</code><code class="o">:</code> <code class="nx">Point</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">dx</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">point</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
    <code class="kr">const</code> <code class="nx">dy</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">point</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>&#13;
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">dx</code> <code class="o">*</code> <code class="nx">dx</code> <code class="o">+</code> <code class="nx">dy</code> <code class="o">*</code> <code class="nx">dy</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="kr">static</code> <code class="nx">distance</code><code class="p">(</code><code class="nx">p1</code><code class="o">:</code> <code class="nx">Point</code><code class="p">,</code> <code class="nx">p2</code><code class="o">:</code> <code class="nx">Point</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">p1</code><code class="p">.</code><code class="err">#</code><code class="nx">distanceTo</code><code class="p">(</code><code class="nx">p2</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The visibility also goes in the other direction. Let’s say you have a class that represents a certain <code>Task</code> in your system, and you want to limit the number of existing tasks.</p>&#13;
&#13;
<p>We use a static private field called <code>nextId</code> that we start at <code>0</code>, and we increase this private field with every constructed instance <code>Task</code>. If we reach <code>100</code>, we throw an error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Task</code> <code class="p">{</code>&#13;
  <code class="kr">static</code> <code class="err">#</code><code class="nx">nextId</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>&#13;
  <code class="err">#</code><code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">Task</code><code class="p">.</code><code class="err">#</code><code class="nx">nextId</code> <code class="o">&gt;</code> <code class="mi">99</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">throw</code> <code class="s2">"Max number of tasks reached"</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">id</code> <code class="o">=</code> <code class="nx">Task</code><code class="p">.</code><code class="err">#</code><code class="nx">nextId</code><code class="o">++</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we want to limit the number of instances by a dynamic value from a backend, we can use a <code>static</code> instantiation block that fetches this data and updates the static private fields accordingly:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Config</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">instances</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Task</code> <code class="p">{</code>&#13;
  <code class="kr">static</code> <code class="err">#</code><code class="nx">nextId</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>&#13;
  <code class="kr">static</code> <code class="err">#</code><code class="nx">maxInstances</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="err">#</code><code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">static</code> <code class="p">{</code>&#13;
    <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/available-slots"</code><code class="p">)</code>&#13;
      <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code>&#13;
      <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">result</code><code class="o">:</code> <code class="nx">Config</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
        <code class="nx">Task</code><code class="p">.</code><code class="err">#</code><code class="nx">maxInstances</code> <code class="o">=</code> <code class="nx">result</code><code class="p">.</code><code class="nx">instances</code><code class="p">;</code>&#13;
      <code class="p">});</code>&#13;
    <code class="p">}</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">Task</code><code class="p">.</code><code class="err">#</code><code class="nx">nextId</code> <code class="o">&gt;</code> <code class="nx">Task</code><code class="p">.</code><code class="err">#</code><code class="nx">maxInstances</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">throw</code> <code class="s2">"Max number of tasks reached"</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">id</code> <code class="o">=</code> <code class="nx">Task</code><code class="p">.</code><code class="err">#</code><code class="nx">nextId</code><code class="o">++</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Other than fields in instances, TypeScript at the time of writing does not check if static fields are instantiated. If we, for example, load the number of available slots from a backend asynchronously, we have a certain time frame during which we can construct instances but have no check if we reached our maximum.</p>&#13;
&#13;
<p>So, even if there is no construct of a static class in TypeScript and static-only classes are considered an antipattern, there might be a good use for static members in many situations.<a data-startref="ix_11-05-asciidoc2" data-type="indexterm" id="id945"/><a data-startref="ix_11-05-asciidoc1" data-type="indexterm" id="id946"/><a data-startref="ix_11-05-asciidoc0" data-type="indexterm" id="id947"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.7 Working with Strict Property Initialization" data-type="sect1"><div class="sect1" id="ch11_strict_prop">&#13;
<h1>11.7 Working with Strict Property Initialization</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id176">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="working with strict property initialization" data-type="indexterm" id="ix_11-07-asciidoc0"/><a data-primary="state, managing" data-secondary="working with strict property initialization" data-type="indexterm" id="ix_11-07-asciidoc1"/><a data-primary="strict property initialization" data-type="indexterm" id="ix_11-07-asciidoc2"/>Classes keep state, but nothing tells you if this state is being initialized.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id948">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Activate strict property initialization by setting <code>strictPropertyInitialization</code> to <code>true</code> in your <em>tsconfig</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id177">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Classes can be seen as code templates for creating objects. You define properties and methods, and only through instantiation do actual values get assigned. TypeScript classes take basic JavaScript classes and enhance them with more syntax to define types. For example, TypeScript allows you to define the properties of the instance in a type- or interface-like manner:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">State</code> <code class="o">=</code> <code class="s2">"active"</code> <code class="o">|</code> <code class="s2">"inactive"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Account</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">userName</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="nx">State</code><code class="p">;</code>&#13;
  <code class="nx">orders</code><code class="o">:</code> <code class="kt">number</code><code class="p">[];</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>However, this notation only defines the shape: it doesn’t set any concrete values, yet. When being transpiled to regular JavaScript, all those properties are erased; they exist only in the <em>type namespace</em>.</p>&#13;
&#13;
<p>This notation is arguably very readable and gives the developer a good idea of what properties to expect. But there is no guarantee that these properties actually exist. If we don’t initialize them, everything is either missing or <code>undefined</code>.</p>&#13;
&#13;
<p>TypeScript has safeguards for this. With the <code>strictPropertyInitialization</code> flag set to <code>true</code> in your <em>tsconfig.json</em>, TypeScript will make sure that all properties you’d expect are actually initialized when creating a new object from your class.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>strictPropertyInitialization</code> is part of TypeScript’s <code>strict</code> mode. If you set <code>strict</code> to <code>true</code> in your <em>tsconfig</em>—which you should—you also activate strict property initialization.</p>&#13;
</div>&#13;
&#13;
<p>Once this is activated, TypeScript will greet you with many red squiggly lines:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Account</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="c1">// ^ Property 'id' has no initializer and is</code>&#13;
<code class="c1">// not definitely assigned in the constructor.(2564)</code>&#13;
  <code class="nx">userName</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="c1">// ^ Property 'userName' has no initializer and is</code>&#13;
<code class="c1">// not definitely assigned in the constructor.(2564)</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="nx">State</code><code class="p">;</code>&#13;
<code class="c1">// ^ Property 'state' has no initializer and is</code>&#13;
<code class="c1">// not definitely assigned in the constructor.(2564)</code>&#13;
  <code class="nx">orders</code><code class="o">:</code> <code class="kt">number</code><code class="p">[];</code>&#13;
<code class="c1">// ^ Property 'orders' has no initializer and is</code>&#13;
<code class="c1">// not definitely assigned in the constructor.(2564)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Beautiful! Now it’s up to us to make sure that every property will receive a value. There are multiple ways to do this. If we look at the <code>Account</code> example, we can define some constraints or rules, if our application’s domain allows us to do so:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>id</code> and <code>userName</code> need to be set; they control the communication to our backend and are necessary for display.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>state</code> also needs to be set, but it has a default value of <code>active</code>. Usually, accounts in our software are active, unless they are set intentionally to <code>inactive</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>orders</code> is an array that contains order IDs, but what if we haven’t ordered anything? An empty array works just as well, or maybe we set <code>orders</code> to not be defined yet.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Given those constraints, we already can rule out two errors. We set <code>state</code> to be <code>active</code> by default, and we make <code>orders</code> optional. There’s also the possibility to set <code>orders</code> to be of type <code>number[] | undefined</code>, which is the same thing as optional:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Account</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code> <code class="c1">// still errors</code>&#13;
  <code class="nx">userName</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code> <code class="c1">// still errors</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="nx">State</code> <code class="o">=</code> <code class="s2">"active"</code><code class="p">;</code> <code class="c1">// ok</code>&#13;
  <code class="nx">orders</code><code class="o">?:</code> <code class="kt">number</code><code class="p">[];</code> <code class="c1">// ok</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The other two properties still throw errors. By adding a <code>constructor</code> and initializing these properties, we rule out the other errors as well:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Account</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">userName</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="nx">State</code> <code class="o">=</code> <code class="s2">"active"</code><code class="p">;</code>&#13;
  <code class="nx">orders</code><code class="o">?:</code> <code class="kt">number</code><code class="p">[];</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">userName</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">userName</code> <code class="o">=</code> <code class="nx">userName</code><code class="p">;</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="o">=</code> <code class="nx">id</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That’s it, a proper TypeScript class! TypeScript also allows for a constructor shorthand, where you can turn constructor parameters into class properties with the same name and value by adding a visibility modifier like <code>public</code>, <code>private</code>, or <code>protected</code>. It’s a convenient feature that gets rid of a lot of boilerplate code. It’s important that you don’t define the same property in the class shape:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Account</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="nx">State</code> <code class="o">=</code> <code class="s2">"active"</code><code class="p">;</code>&#13;
  <code class="nx">orders</code><code class="o">?:</code> <code class="kt">number</code><code class="p">[];</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="kr">public</code> <code class="nx">userName</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="kr">public</code> <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you look at the class right now, you see that we rely only on TypeScript features. The transpiled class, the JavaScript equivalent, looks a lot different:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Account</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">userName</code><code class="p">,</code> <code class="nx">id</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">userName</code> <code class="o">=</code> <code class="nx">userName</code><code class="p">;</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="o">=</code> <code class="nx">id</code><code class="p">;</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">state</code> <code class="o">=</code> <code class="s2">"active"</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Everything is in the <code>constructor</code>, because the <code>constructor</code> defines an instance.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>While TypeScript shortcuts and syntax for classes seem nice, be careful how much you buy into them. TypeScript switched gears in recent years to be mostly a syntax extension for types on top of regular JavaScript, but their class features that have existed for many years now are still available and add different semantics to your code than you’d expect. If you lean toward your code being “JavaScript with types,” be careful when you venture into the depths of TypeScript class features.</p>&#13;
</div>&#13;
&#13;
<p>Strict property initialization also understands complex scenarios, like setting the property within a function that is being called via the <code>constructor</code>. It also understands that an async class might leave your class with a potentially uninitialized state.</p>&#13;
&#13;
<p>Let’s say you just want to initialize your class via an <code>id</code> property and fetch the <code>userName</code> from a backend. If you do the async call within your constructor and set <code>userName</code> after the <code>fetch</code> call is complete, you still get strict property initialization errors:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">User</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">userName</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Account</code> <code class="p">{</code>&#13;
  <code class="nx">userName</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="c1">// ^ Property 'userName' has no initializer and is</code>&#13;
<code class="c1">// not definitely assigned in the constructor.(2564)</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="nx">State</code> <code class="o">=</code> <code class="s2">"active"</code><code class="p">;</code>&#13;
  <code class="nx">orders</code><code class="o">?:</code> <code class="kt">number</code><code class="p">[];</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="kr">public</code> <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">fetch</code><code class="p">(</code><code class="sb">`/api/getName?id=</code><code class="si">${</code><code class="nx">id</code><code class="si">}</code><code class="sb">`</code><code class="p">)</code>&#13;
      <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code>&#13;
      <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">data</code><code class="o">:</code> <code class="nx">User</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">userName</code> <code class="o">=</code> <code class="nx">data</code><code class="p">.</code><code class="nx">userName</code> <code class="o">??</code> <code class="s2">"not-found"</code><code class="p">));</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And it’s true! Nothing tells you that the <code>fetch</code> call will be successful, and even if you <code>catch</code> errors and make sure that the property will be initialized with a fallback value, there is a certain amount of time when your object has an uninitialized <code>userName</code> state.</p>&#13;
&#13;
<p>You can do a few things to get around this. One nice pattern is having a static factory function that works asynchronously, where you get the data first and then call a constructor that expects both properties:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Account</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="nx">State</code> <code class="o">=</code> <code class="s2">"active"</code><code class="p">;</code>&#13;
  <code class="nx">orders</code><code class="o">?:</code> <code class="kt">number</code><code class="p">[];</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="kr">public</code> <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="kr">public</code> <code class="nx">userName</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{}</code>&#13;
&#13;
  <code class="kr">static</code> <code class="kr">async</code> <code class="nx">create</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">user</code><code class="o">:</code> <code class="nx">User</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="sb">`/api/getName?id=</code><code class="si">${</code><code class="nx">id</code><code class="si">}</code><code class="sb">`</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
      <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">()</code>&#13;
    <code class="p">);</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Account</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">user</code><code class="p">.</code><code class="nx">userName</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This allows both objects to be instantiated in a non-async context if you have access to both properties, or within an async context if you have only <code>id</code> available. We switch responsibilities and remove <code>async</code> from the constructor entirely.</p>&#13;
&#13;
<p><a data-primary="! (exclamation mark)" data-type="indexterm" id="id949"/><a data-primary="definite assignment assertion" data-type="indexterm" id="id950"/>Another technique is to simply ignore the uninitialized state. What if the state of <code>userName</code> is totally irrelevant to your application, and you want to access it only when needed? Use the <em>definite assignment assertion</em> (an exclamation mark) to tell TypeScript you will treat this property as initialized:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Account</code> <code class="p">{</code>&#13;
  <code class="nx">userName</code><code class="o">!:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="nx">State</code> <code class="o">=</code> <code class="s2">"active"</code><code class="p">;</code>&#13;
  <code class="nx">orders</code><code class="o">?:</code> <code class="kt">number</code><code class="p">[];</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="kr">public</code> <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">fetch</code><code class="p">(</code><code class="sb">`/api/getName?id=</code><code class="si">${</code><code class="nx">id</code><code class="si">}</code><code class="sb">`</code><code class="p">)</code>&#13;
      <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code>&#13;
      <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">data</code><code class="o">:</code> <code class="nx">User</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">userName</code> <code class="o">=</code> <code class="nx">data</code><code class="p">.</code><code class="nx">userName</code><code class="p">));</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The responsibility is now in your hands, and with the exclamation mark you have TypeScript-specific syntax you can qualify as unsafe operation, runtime errors included.<a data-startref="ix_11-07-asciidoc2" data-type="indexterm" id="id951"/><a data-startref="ix_11-07-asciidoc1" data-type="indexterm" id="id952"/><a data-startref="ix_11-07-asciidoc0" data-type="indexterm" id="id953"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.8 Working with this Types in Classes" data-type="sect1"><div class="sect1" id="ch11_this_return">&#13;
<h1>11.8 Working with this Types in Classes</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id178">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="working with types in" data-type="indexterm" id="ix_11-08-asciidoc0"/><a data-primary="this type" data-type="indexterm" id="ix_11-08-asciidoc1"/><a data-primary="types" data-secondary="working with types in classes" data-type="indexterm" id="ix_11-08-asciidoc2"/>You extend from base classes to reuse functionality, and your methods have signatures that refer to an instance of the same class. You want to make sure that no other subclasses are getting mixed in your interfaces, but you don’t want to override methods just to change the type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id954">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <code>this</code> as type instead of the actual class type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id179">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In this example, we want to model a bulletin board software’s different user roles using classes. We start with a general <code>User</code> class that is identified by its user ID and has the ability to open threads:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">User</code> <code class="p">{</code>&#13;
  <code class="err">#</code><code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="kr">static</code> <code class="err">#</code><code class="nx">nextThreadId</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">id</code> <code class="o">=</code> <code class="nx">id</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">equals</code><code class="p">(</code><code class="nx">user</code><code class="o">:</code> <code class="nx">User</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">id</code> <code class="o">===</code> <code class="nx">user</code><code class="p">.</code><code class="err">#</code><code class="nx">id</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="kr">async</code> <code class="nx">openThread</code><code class="p">(</code><code class="nx">title</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">threadId</code> <code class="o">=</code> <code class="nx">User</code><code class="p">.</code><code class="err">#</code><code class="nx">nextThreadId</code><code class="o">++</code><code class="p">;</code>&#13;
    <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/createThread"</code><code class="p">,</code> <code class="p">{</code>&#13;
      <code class="nx">method</code><code class="o">:</code> <code class="s2">"POST"</code><code class="p">,</code>&#13;
      <code class="nx">body</code><code class="o">:</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">({</code>&#13;
        <code class="nx">content</code><code class="p">,</code>&#13;
        <code class="nx">title</code><code class="p">,</code>&#13;
        <code class="nx">threadId</code><code class="p">,</code>&#13;
      <code class="p">}),</code>&#13;
    <code class="p">});</code>&#13;
    <code class="k">return</code> <code class="nx">threadId</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This class also contains an <code>equals</code> method. Somewhere in our codebase, we need to make sure that two references to users are the same, and since we identify users by their ID, we can easily compare numbers.</p>&#13;
&#13;
<p><code>User</code> is the base class of all users, so if we add roles with more privileges, we can easily inherit from the base <code>User</code> class. For example, <code>Admin</code> has the ability to close threads, and it stores a set of other privileges that we might use in other methods.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There is much debate in the programming community if inheritance is a technique better to ignore since its benefits hardly outweigh its pitfalls. Nevertheless, some parts of JavaScript rely on inheritance, such as Web Components.</p>&#13;
</div>&#13;
&#13;
<p>Since we inherit from <code>User</code>, we don’t need to write another <code>openThread</code> method, and we can reuse the same <code>equals</code> method since all administrators are also users:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Admin</code> <code class="kr">extends</code> <code class="nx">User</code> <code class="p">{</code>&#13;
  <code class="err">#</code><code class="nx">privileges</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">privileges</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[])</code> <code class="p">{</code>&#13;
    <code class="kr">super</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">privileges</code> <code class="o">=</code> <code class="nx">privileges</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="kr">async</code> <code class="nx">closeThread</code><code class="p">(</code><code class="nx">threadId</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/closeThread"</code><code class="p">,</code> <code class="p">{</code>&#13;
      <code class="nx">method</code><code class="o">:</code> <code class="s2">"POST"</code><code class="p">,</code>&#13;
      <code class="nx">body</code><code class="o">:</code> <code class="s2">""</code> <code class="o">+</code> <code class="nx">threadId</code><code class="p">,</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>After setting up our classes, we can create new objects of type <code>User</code> and <code>Admin</code> by instantiating the right classes. We can also call the <code>equals</code> method to compare if two users might be the same:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">User</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">admin</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Admin</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">equals</code><code class="p">(</code><code class="nx">admin</code><code class="p">));</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">admin</code><code class="p">.</code><code class="nx">equals</code><code class="p">(</code><code class="nx">user</code><code class="p">));</code></pre>&#13;
&#13;
<p>One thing is bothersome, though: the direction of comparison. Of course, comparing two numbers is commutative; it shouldn’t matter if we compare a <code>user</code> to an <code>admin</code>, but if we think about the surrounding classes and subtypes, there is some room for improvement:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It’s OK to check if a <code>user</code> equals an <code>admin</code>, because it might gain privileges.</p>&#13;
</li>&#13;
<li>&#13;
<p>It’s doubtful if we want an <code>admin</code> to equal a <code>user</code>, because the broader supertype has less information.</p>&#13;
</li>&#13;
<li>&#13;
<p>If we have another subclass of <code>Moderator</code> adjacent to <code>Admin</code>, we definitely don’t want to be able to compare them as they don’t share properties outside the base class.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Still, in the way <code>equals</code> is developed now, all comparisons would work. We can work around this by changing the type of what we want to compare. We annotated the input parameter with <code>User</code> first, but in reality we want to compare <em>with another instance of the same type</em>. There is a type for that, and it is called <code>this</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">User</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
&#13;
  <code class="nx">equals</code><code class="p">(</code><code class="nx">user</code><code class="o">:</code> <code class="k">this</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">id</code> <code class="o">===</code> <code class="nx">user</code><code class="p">.</code><code class="err">#</code><code class="nx">id</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is different from the erasable <code>this</code> parameter we know from functions, which we learned about in <a data-type="xref" href="ch02.html#ch02_item_this_types">Recipe 2.7</a>, as the <code>this</code> parameter type allows us to set a concrete type for the <code>this</code> global variable within the scope of a function. The <code>this</code> type is a reference to the class where the method is located. And it changes depending on the implementation. So if we annotate a <code>user</code> with <code>this</code> in <code>User</code>, it becomes an <code>Admin</code> in the class that inherits from <code>User</code>, or a <code>Moderator</code>, and so on. With that, <code>admin.equals</code> expects another <code>Admin</code> class to be compared to; otherwise, we get an error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">admin</code><code class="p">.</code><code class="nx">equals</code><code class="p">(</code><code class="nx">user</code><code class="p">));</code>&#13;
<code class="c1">//                       ^</code>&#13;
<code class="c1">// Argument of type 'User' is not assignable to parameter of type 'Admin'.</code></pre>&#13;
&#13;
<p>The other way around still works. Since <code>Admin</code> contains all properties from <code>User</code> (it’s a subclass, after all), we can easily compare <code>user.equals(admin)</code>.</p>&#13;
&#13;
<p><a data-primary="builder pattern" data-type="indexterm" id="ix_11-08-asciidoc3"/><a data-primary="OptionBuilder&lt;T&gt;" data-type="indexterm" id="ix_11-08-asciidoc4"/><code>this</code> types can also be used as return types. Take a look at this <code>OptionBuilder</code>, which implements the <em>builder pattern</em>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">OptionBuilder</code><code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="kr">boolean</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="err">#</code><code class="nx">options</code><code class="o">:</code> <code class="nx">Map</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">();</code>&#13;
  <code class="kr">constructor</code><code class="p">()</code> <code class="p">{}</code>&#13;
&#13;
  <code class="nx">add</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">OptionBuilder</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">options</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">has</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">options</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">build</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">fromEntries</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">options</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It’s a soft wrapper around a <code>Map</code>, which allows us to set key/value pairs. It has a chainable interface, which means that after each <code>add</code> call, we get the current instance back, allowing us to do <code>add</code> call after <code>add</code> call. Note that we annotated the return type with <code>OptionBuilder&lt;T&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">options</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">OptionBuilder</code><code class="p">()</code>&#13;
  <code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s2">"deflate"</code><code class="p">,</code> <code class="kc">true</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s2">"compressionFactor"</code><code class="p">,</code> <code class="mi">10</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">build</code><code class="p">();</code></pre>&#13;
&#13;
<p>We are now creating a <code>StringOptionBuilder</code> that inherits from <code>OptionBuilder</code> and sets the type of possible elements to <code>string</code>. We also add a <code>safeAdd</code> method with checks if a certain value is already set before it is written, so we don’t override &#13;
<span class="keep-together">previous settings:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">StringOptionBuilder</code> <code class="kr">extends</code> <code class="nx">OptionBuilder</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">safeAdd</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">name</code><code class="p">))</code> <code class="p">{</code>&#13;
      <code class="k">this</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When we start using the new builder, we see that we can’t reasonably use <code>safeAdd</code> if we have an <code>add</code> as the first step:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">languages</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">StringOptionBuilder</code><code class="p">()</code>&#13;
  <code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s2">"en"</code><code class="p">,</code> <code class="s2">"English"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">safeAdd</code><code class="p">(</code><code class="s2">"de"</code><code class="p">,</code> <code class="s2">"Deutsch"</code><code class="p">)</code>&#13;
<code class="c1">// ^</code>&#13;
<code class="c1">// Property 'safeAdd' does not exist on type 'OptionBuilder&lt;string&gt;'.(2339)</code>&#13;
  <code class="p">.</code><code class="nx">safeAdd</code><code class="p">(</code><code class="s2">"de"</code><code class="p">,</code> <code class="s2">"German"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">build</code><code class="p">();</code></pre>&#13;
&#13;
<p>TypeScript tells us that <code>safeAdd</code> does not exist on type <code>OptionBuilder&lt;string&gt;</code>. Where has this function gone? The problem is that <code>add</code> has a very broad annotation. Of course <code>StringOptionBuilder</code> is a subtype of <code>OptionBuilder&lt;string&gt;</code>, but with the annotation, we lose the information on the narrower type. The solution? Use <code>this</code> as return type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">OptionBuilder</code><code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="kr">boolean</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
&#13;
  <code class="nx">add</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="k">this</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">options</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The same effect happens as with the previous example. In <code>OptionBuilder&lt;T&gt;</code>, <code>this</code> becomes <code>OptionBuilder&lt;T&gt;</code>. In <code>StringBuilder</code>, <code>this</code> becomes <code>StringBuilder</code>. If you return <code>this</code> and leave out the return type annotation, <code>this</code> becomes the <em>inferred</em> return type. So using <code>this</code> explicitly depends on your preference (see <a data-type="xref" href="ch02.html#ch02_item_annotation">Recipe 2.1</a>)<a data-startref="ix_11-08-asciidoc4" data-type="indexterm" id="id955"/><a data-startref="ix_11-08-asciidoc3" data-type="indexterm" id="id956"/>.<a data-startref="ix_11-08-asciidoc2" data-type="indexterm" id="id957"/><a data-startref="ix_11-08-asciidoc1" data-type="indexterm" id="id958"/><a data-startref="ix_11-08-asciidoc0" data-type="indexterm" id="id959"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.9 Writing Decorators" data-type="sect1"><div class="sect1" id="ch10_decorators">&#13;
<h1>11.9 Writing Decorators</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id180">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="writing decorators" data-type="indexterm" id="ix_11-09-asciidoc0"/><a data-primary="decorators" data-type="indexterm" id="ix_11-09-asciidoc1"/><a data-primary="log (class method decorator)" data-type="indexterm" id="ix_11-09-asciidoc2"/>You want to log the execution of your methods for your telemetry, but adding manual logs to every method is cumbersome.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id960">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Write a class method decorator called <code>log</code> to annotate your methods.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id181">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The <em>decorator</em> design pattern has been described in the renowned book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma et al. (Addison-Wesley) and describes a technique that can <em>decorate</em> classes and methods to dynamically add or overwrite certain behavior.</p>&#13;
&#13;
<p>What began as a naturally emerging design pattern in object-oriented programming has become so popular that programming languages that feature object-oriented aspects have added decorators as a language feature with a special syntax. You can see forms of it in Java (called <em>annotations</em>) or C# (called <em>attributes</em>) and in JavaScript.</p>&#13;
&#13;
<p><a data-primary="ECMAScript" data-secondary="decorator proposal" data-type="indexterm" id="id961"/>The ECMAScript proposal for decorators has been in proposal hell for quite a while but reached stage 3 (ready for implementation) in 2022. And with all features reaching stage 3, TypeScript is one of the first tools to pick up the new specification.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Decorators have existed in TypeScript for a long time under the <code>experimentalDecorators</code> compiler flag. With TypeScript 5.0, the native ECMAScript decorator proposal is fully implemented and available without a flag. The actual ECMAScript implementation differs fundamentally from the original design, and if you developed decorators prior to TypeScript 5.0, they won’t work with the new specification. Note that a switched-on <code>experimentalDecorators</code>  flag turns off the ECMAScript native decorators. Also, in regard to types, <em>lib.decorators.d.ts</em> contains all type information for the ECMAScript native decorators, while types in <em>lib.decorators.legacy.d.ts</em> contain old type information. Make sure your settings are correct and that you don’t consume types from the wrong &#13;
<span class="keep-together">definition</span> file.</p>&#13;
</div>&#13;
&#13;
<p>Decorators allow us to decorate almost anything in a class. For this example, we want to start with a method decorator that allows us to log the execution of method calls.</p>&#13;
&#13;
<p>Decorators are described as functions with a <em>value</em> and a <em>context</em>, both depending on the type of class element you want to decorate. Those decorator functions return another function that will be executed before your own method (or before field initialization, or before an accessor call, etc.).</p>&#13;
&#13;
<p>A simple <code>log</code> decorator for methods could look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="nb">Function</code><code class="p">,</code> <code class="nx">context</code><code class="o">:</code> <code class="nx">ClassMethodDecoratorContext</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">any</code><code class="p">[])</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`calling </code><code class="si">${</code><code class="nx">context</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="nx">value</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Toggler</code> <code class="p">{</code>&#13;
  <code class="err">#</code><code class="nx">toggled</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>&#13;
&#13;
  <code class="kd">@log</code>&#13;
  <code class="nx">toggle</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">toggled</code> <code class="o">=</code> <code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">toggled</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">toggler</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Toggler</code><code class="p">();</code>&#13;
<code class="nx">toggler</code><code class="p">.</code><code class="nx">toggle</code><code class="p">();</code></pre>&#13;
&#13;
<p>The <code>log</code> function follows a <code>ClassMethodDecorator</code> type defined in the original <a href="https://oreil.ly/76JuE">decorator proposal</a>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ClassMethodDecorator</code> <code class="o">=</code> <code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="nb">Function</code><code class="p">,</code> <code class="nx">context</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"method"</code><code class="p">;</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">symbol</code><code class="p">;</code>&#13;
  <code class="nx">access</code><code class="o">:</code> <code class="p">{</code> <code class="nx">get</code><code class="p">()</code><code class="o">:</code> <code class="kr">unknown</code> <code class="p">};</code>&#13;
  <code class="kr">static</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
  <code class="kr">private</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
  <code class="nx">addInitializer</code><code class="p">(</code><code class="nx">initializer</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">})</code> <code class="o">=&gt;</code> <code class="nb">Function</code> <code class="o">|</code> <code class="k">void</code><code class="p">;</code></pre>&#13;
&#13;
<p>Many decorator context types are available. <em>lib.decorator.d.ts</em> defines the following decorators:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ClassMemberDecoratorContext</code> <code class="o">=</code>&#13;
    <code class="o">|</code> <code class="nx">ClassMethodDecoratorContext</code>&#13;
    <code class="o">|</code> <code class="nx">ClassGetterDecoratorContext</code>&#13;
    <code class="o">|</code> <code class="nx">ClassSetterDecoratorContext</code>&#13;
    <code class="o">|</code> <code class="nx">ClassFieldDecoratorContext</code>&#13;
    <code class="o">|</code> <code class="nx">ClassAccessorDecoratorContext</code>&#13;
    <code class="p">;</code>&#13;
&#13;
<code class="cm">/**</code>&#13;
<code class="cm"> * The decorator context types provided to any decorator.</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kr">type</code> <code class="nx">DecoratorContext</code> <code class="o">=</code>&#13;
    <code class="o">|</code> <code class="nx">ClassDecoratorContext</code>&#13;
    <code class="o">|</code> <code class="nx">ClassMemberDecoratorContext</code>&#13;
    <code class="p">;</code></pre>&#13;
&#13;
<p>You can read from the names exactly which part of a class they target.</p>&#13;
&#13;
<p>Note that we haven’t written detailed types yet. We resort to a lot of <code>any</code>, mostly because the types can get very complex. If we want to add types for all parameters, we need to resort to a lot of generics:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">log</code><code class="o">&lt;</code><code class="nx">This</code><code class="p">,</code> <code class="nx">Args</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">Return</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Return</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="nx">ClassMethodDecoratorContext</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Return</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`calling </code><code class="si">${</code><code class="nx">context</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="nx">value</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The generic type parameters are necessary to describe the method we are passing in. We want to catch the following types:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>This</code> is a generic type parameter for the <code>this</code> parameter type (see <a data-type="xref" href="ch02.html#ch02_item_this_types">Recipe 2.7</a>). We need to set <code>this</code> as decorators are run in the context of an object instance.</p>&#13;
</li>&#13;
<li>&#13;
<p>Then we have the method’s arguments as <code>Args</code>. As we learned in <a data-type="xref" href="ch02.html#ch02_item_tuple_types">Recipe 2.4</a>, a method or function’s arguments can be described as a tuple.</p>&#13;
</li>&#13;
<li>&#13;
<p>Last, but not least, the <code>Return</code> type parameter. The method needs to return a value of a certain type, and we want to specify this.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>With all three, we are able to describe the input method as well as the output method in the most generic way, for all classes. We can use generic constraints to make sure that our decorator works only in certain cases, but for <code>log</code>, we want to be able to log every method call.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>At the time of writing, ECMAScript decorators in TypeScript are fairly new. Types get better over time, so the type information you get may already be much better.</p>&#13;
</div>&#13;
&#13;
<p>We also want to log our class fields and their initial value before the <code>constructor</code> method is called:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Toggler</code> <code class="p">{</code>&#13;
  <code class="kd">@logField</code> <code class="err">#</code><code class="nx">toggled</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>&#13;
&#13;
  <code class="kd">@log</code>&#13;
  <code class="nx">toggle</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">toggled</code> <code class="o">=</code> <code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">toggled</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For that, we create another decorator called <code>logField</code>, which works on a <code>ClassFieldDecoratorContext</code>. The <a href="https://oreil.ly/76JuE">decorator proposal</a> describes the decorator for class fields as follows:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ClassFieldDecorator</code> <code class="o">=</code> <code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">context</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"field"</code><code class="p">;</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">symbol</code><code class="p">;</code>&#13;
  <code class="nx">access</code><code class="o">:</code> <code class="p">{</code> <code class="nx">get</code><code class="p">()</code><code class="o">:</code> <code class="kr">unknown</code><code class="p">,</code> <code class="nx">set</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kr">unknown</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">};</code>&#13;
  <code class="kr">static</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
  <code class="kr">private</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
<code class="p">})</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">initialValue</code><code class="o">:</code> <code class="kr">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">unknown</code> <code class="o">|</code> <code class="k">void</code><code class="p">;</code></pre>&#13;
&#13;
<p>Note that the <em>value</em> is <code>undefined</code>. The initial value is being passed to the replacement method:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FieldDecoratorFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">val</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">any</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">logField</code><code class="o">&lt;</code><code class="nx">Val</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="nx">ClassFieldDecoratorContext</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">FieldDecoratorFn</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">initialValue</code><code class="o">:</code> <code class="nx">Val</code><code class="p">)</code><code class="o">:</code> <code class="nx">Val</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Initializing </code><code class="si">${</code><code class="nx">context</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb"> to </code><code class="si">${</code><code class="nx">initialValue</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="nx">initialValue</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>There’s one thing that feels off. Why would we need different decorators for different kinds of members? Shouldn’t our <code>log</code> decorator be capable of handling it all? Our decorator is called in a specific <em>decorator context</em>, and we can identify the right context via the <code>kind</code> property (a pattern we saw in <a data-type="xref" href="ch03.html#ch03_item_discriminated_unions">Recipe 3.2</a>). So there’s nothing easier than writing a <code>log</code> function that does different decorator calls depending on the context, right?</p>&#13;
&#13;
<p>Well, yes and no. Of course, having a wrapper function that branches correctly is the way to go, but the type definitions, as we’ve seen, are pretty complex. Finding <em>one</em> function signature that can handle them all is close to impossible without defaulting to <code>any</code> everywhere. And remember: we need the right function signature typings; otherwise, the decorators won’t work with class members.</p>&#13;
&#13;
<p><a data-primary="function overloads" data-secondary="decorators and" data-type="indexterm" id="id962"/>Multiple different function signatures just scream <em>function overloads</em>. So instead of finding one function signature for all possible decorators, we create overloads for <em>field decorators</em>, <em>method decorators</em>, and so on. Here, we can type them just as we would type the single decorators. The function signature for the implementation takes <code>any</code> for <code>value</code> and brings all required decorator context types in a union, so we can do proper discrimination checks afterward:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">log</code><code class="o">&lt;</code><code class="nx">This</code><code class="p">,</code> <code class="nx">Args</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">Return</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Return</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="nx">ClassMethodDecoratorContext</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Return</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">log</code><code class="o">&lt;</code><code class="nx">Val</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="nx">Val</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="nx">ClassFieldDecoratorContext</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">FieldDecoratorFn</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">log</code><code class="p">(</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="nx">ClassMethodDecoratorContext</code> <code class="o">|</code> <code class="nx">ClassFieldDecoratorContext</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">kind</code> <code class="o">===</code> <code class="s2">"method"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">logMethod</code><code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">context</code><code class="p">);</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">logField</code><code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">context</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Instead of fumbling all the actual code into the <code>if</code> branches, we’d rather call the original methods. If you don’t want to have your <code>logMethod</code> or <code>logField</code> functions exposed, then you can put them in a module and only export <code>log</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>There are a lot of different decorator types, and they all have various fields that differ slightly. The type definitions in <em>lib.decorators.d.ts</em> are excellent, but if you need a bit more information, check out <a href="https://oreil.ly/76JuE">the original decorator proposal at TC39</a>. Not only does it include extensive information on all types of decorators, but it also contains additional TypeScript typings that complete the picture.</p>&#13;
</div>&#13;
&#13;
<p>There is one last thing we want to do: adapt <code>logMethod</code> to log both <em>before</em> and <em>after</em> the call. For normal methods, it’s as easy as temporarily storing the return value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">log</code><code class="o">&lt;</code><code class="nx">This</code><code class="p">,</code> <code class="nx">Args</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">Return</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Return</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="nx">ClassMethodDecoratorContext</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`calling </code><code class="si">${</code><code class="nx">context</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="kr">const</code> <code class="nx">val</code> <code class="o">=</code> <code class="nx">value</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`called </code><code class="si">${</code><code class="nx">context</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">val</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="nx">val</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But for asynchronous methods, things get a little more interesting. Calling an asynchronous method yields a <code>Promise</code>. The <code>Promise</code> itself might already have been executed, or the execution is deferred to later. This means if we stick with the implementation from before, the <em>called</em> log message might appear before the method actually yields a value.</p>&#13;
&#13;
<p class="pagebreak-before">As a workaround, we need to chain the log message as the next step after the <code>Promise</code> yields a result. To do so, we need to check if the method is actually a <code>Promise</code>. JavaScript Promises are interesting because all they need to be awaited is having a <code>then</code> method. This is something we can check in a helper method:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">isPromise</code><code class="p">(</code><code class="nx">val</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="nx">val</code> <code class="nx">is</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kr">unknown</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="k">typeof</code> <code class="nx">val</code> <code class="o">===</code> <code class="s2">"object"</code> <code class="o">&amp;&amp;</code>&#13;
    <code class="nx">val</code> <code class="o">&amp;&amp;</code>&#13;
    <code class="s2">"then"</code> <code class="k">in</code> <code class="nx">val</code> <code class="o">&amp;&amp;</code>&#13;
    <code class="k">typeof</code> <code class="nx">val</code><code class="p">.</code><code class="nx">then</code> <code class="o">===</code> <code class="s2">"function"</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And with that, we decide whether to log directly or deferred based on if we have a <code>Promise</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">logMethod</code><code class="o">&lt;</code><code class="nx">This</code><code class="p">,</code> <code class="nx">Args</code> <code class="kr">extends</code> <code class="kr">any</code><code class="p">[],</code> <code class="nx">Return</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Return</code><code class="p">,</code>&#13;
  <code class="nx">context</code><code class="o">:</code> <code class="nx">ClassMethodDecoratorContext</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Return</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">This</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="o">:</code> <code class="nx">Args</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`calling </code><code class="si">${</code><code class="nx">context</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="kr">const</code> <code class="nx">val</code> <code class="o">=</code> <code class="nx">value</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">isPromise</code><code class="p">(</code><code class="nx">val</code><code class="p">))</code> <code class="p">{</code>&#13;
      <code class="nx">val</code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">p</code><code class="o">:</code> <code class="kr">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`called </code><code class="si">${</code><code class="nx">context</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">p</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
        <code class="k">return</code> <code class="nx">p</code><code class="p">;</code>&#13;
      <code class="p">});</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`called </code><code class="si">${</code><code class="nx">context</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">val</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">val</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Decorators can get very complex but are ultimately a useful tool to make classes in JavaScript and TypeScript more expressive.<a data-startref="ix_11-09-asciidoc2" data-type="indexterm" id="id963"/><a data-startref="ix_11-09-asciidoc1" data-type="indexterm" id="id964"/><a data-startref="ix_11-09-asciidoc0" data-type="indexterm" id="id965"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id917"><sup><a href="ch11.html#id917-marker">1</a></sup> C# and TypeScript are made by Microsoft, and Anders Hejlsberg has been heavily involved in both  <span class="keep-together">programming</span> languages.</p></div></div></section></body></html>