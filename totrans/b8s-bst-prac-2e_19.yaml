- en: Chapter 19\. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is a powerful platform for orchestrating cloud native applications.
    However, under the veneer and polish of the APIs and tooling we know and love
    lies a large, complex distributed system that requires specific knowledge to secure.
    Securing Kubernetes is a complex topic that honestly requires its own book; however,
    there’s so much at stake if you overlook taking the time to understand and implement
    security best practices that we cover it in brief here. The risk of not securing
    your Kubernetes clusters and workloads properly is the possibility of exposing
    your data and resources to hackers, malware, and unauthorized access. We would
    be remiss not to cover some of the main security areas and provide best practices
    to help along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Given the complexity of Kubernetes, we recommend breaking the problem down into
    logical layers where you can focus on specific tooling at each layer. A great
    way to handle security is to follow the “defense in depth” strategy. This requires
    the use of multiple security measures at each layer to protect Kubernetes and
    your workloads. Additionally, keep the principle of least privilege in mind, which
    states that users and workloads should have access only to what they absolutely
    need to perform their functions. This all sounds great in theory, but what does
    it look like in practice? This chapter lays out an approach to bucketing security
    concerns into layers that will help you focus on the solutions and tooling available
    as well as cluster security, container security, and code security.
  prefs: []
  type: TYPE_NORMAL
- en: Many security best practices have been covered in detail in other chapters,
    including Chapters [4](ch04.html#configuration_secrets_and_rbac) through [11](ch11.html#policy_and_governance_for_your_cluster).
    We encourage you to review those chapters as we won’t cover those specific topics
    in the same level of detail again here but rather focus on areas we haven’t covered.
    In particular, this chapter will focus on layers; digging deeper into them, covering
    security areas, and providing best practices for each layer.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that the Kubernetes control plane is exposed via a set of APIs, the first
    step in securing the cluster is to regulate and restrict who can access the cluster
    and what actions they can perform. Next, we will cover the different parts of
    the Kubernetes control plane and how to secure them.
  prefs: []
  type: TYPE_NORMAL
- en: etcd Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default storage system for Kubernetes is etcd. You must ensure that only
    the Kubernetes API server has access to etcd by using strong credentials that
    aren’t shared. You must also make sure that only the API servers have network
    access to etcd by using network firewalls. Having direct access to etcd bypasses
    all the subsequent security measures you have in place, so this is an incredibly
    important layer to secure.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes provides several different authentication methods, from bearer tokens
    and certificates to OpenID Connect (OIDC) and Lightweight Directory Access Protocol
    (LDAP) integrations. It’s important to choose the right authentication model that
    suits the needs of your business. Security challenges usually appear in the creation,
    distribution, and storage of Kubeconfig files that users require to authenticate
    to Kubernetes using tools like `kubectl`. Using authentication providers allows
    the retrieval of temporary dynamic tokens rather that using static tokens or certificates
    that can be easily retrieved by a malicious actor. Papers have been written about
    instances of malicious code stored in Kubeconfig files, so it’s important to control
    their creation and distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We covered authorization in [Chapter 17](ch17.html#admission_control_and_authorization);
    however, in the context of Kubernetes security it’s a powerful tool to enforce
    who can perform what actions on what resources. The primary tool at your disposal
    is role-based access control (RBAC). Thankfully, Kubernetes ships with sane defaults;
    however, you will want to consider incorporating attributes such as team membership
    as well as namespaces as a way of scaling the number of RBAC resources that need
    to be created to support a growing number of workloads and users. It’s also very
    important to lock down service accounts using RBAC to confirm that workloads that
    need access to the Kubernetes API can access only the minimum actions required
    to perform their function.
  prefs: []
  type: TYPE_NORMAL
- en: TLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Kubernetes ships with TLS-secured API endpoints enabled. However,
    different tools and platforms may enable HTTP plaintext communications, which
    opens up an attack vector as the traffic will be unsecure. It’s important to safely
    store and control access to any certificates and keys in use by Kubernetes and
    create a plan to rotate them if they are lost or compromised. Having short lifetimes
    on certificates helps decrease the security risk.
  prefs: []
  type: TYPE_NORMAL
- en: Kubelet and Cloud Metadata Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubelets are the component that run on each node and are responsible for managing
    the node and the pods that run on it. Unfortunately, Kubelet ships with unauthenticated
    API enabled. The Kubelet API is extremely powerful and hence should have authentication
    and authorization enabled. It is likely that your Kubernetes provider has taken
    care of this for you; however, you should double check if rolling your own Kubernetes
    cluster. In addition to the Kubelet API, if running on a cloud provider it’s likely
    that the node has access to a cloud metadata API that could be used to expose
    Kubernetes provisioning credentials. It’s recommended that you lock down access
    to the metadata endpoint using network policies.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s no secret that Kubernetes secrets are not encrypted by default. This means
    that malicious actors may be able to read these secrets at rest from other vectors.
    Thankfully, there are several different solutions to help with this. The Kubernetes
    API server provides the ability to configure an encryption provider that is used
    in partnership with a configuration file to encrypt specific Kubernetes resources
    prior to storage in etcd. Encryption providers are typically cloud secret storage
    services. The only challenge with the current encryption provider implementation
    is that there is no way to encrypt everything, and the configuration is cumbersome
    and error prone. Another solution that the Kubernetes community has built is [csi
    secret store](https://oreil.ly/cbiYT), which enables secrets to be mounted directly
    into pods via a temporary RAMDISK filesystem. Using `csi-secret-store` enables
    you to bypass the need to use Kubernetes secrets and instead directly access them
    from another trusted secret store.
  prefs: []
  type: TYPE_NORMAL
- en: Logging and Auditing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes ships with rich logging configured out of the box. In addition, it’s
    important to also enable audit logging on the API server, which will enable a
    chronological log of all security-specific events and is configurable via an audit
    policy. Enabling auditing is only part of the solution; you also must make sure
    that the audit logs are shipped to a point of aggregation and configure triggers
    that, if detected, fire an alert to the security team that a suspicious event
    has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Security Posture Tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting Kubernetes security implemented can be challenging. The great news is
    that there are open source tools that can scan your Kubernetes clusters, detect
    security risks, and flag common misconfigurations. Additionally, they can scan
    all the resources on a cluster and provide best practices. Tools like [Kubescape](https://oreil.ly/qPoHQ)
    are quick to run and provide outputs based on severity. It’s recommended that
    you run these tools periodically on all clusters to determine the security posture
    of your cluster and the resources deployed to it.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Security Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we’ve covered the biggest security areas at the cluster layer, here
    is a handy list of security best practices for you to check off:'
  prefs: []
  type: TYPE_NORMAL
- en: Lock down etcd access and store access credentials and certificates in secure
    locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable insecure and unauthenticated API endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use authentication providers that provide temporary dynamic tokens rather than
    static configured tokens in Kubeconfig.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure users and services follow least privilege.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate infrastructure credentials regularly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypt sensitive data at rest and in transit using keys and certificates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan container images for vulnerabilities and malware before deploying them
    to the cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable audit logging and monitoring to detect and respond to suspicious activities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use security scanning tools such as Kubescape to baseline the security posture
    of your Kubernetes cluster and workloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workload Container Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered the core components of cluster security we’ll look at
    the security mechanisms at the workload layer. Kubernetes offers many security-focused
    APIs, which makes configuration simple via the same tooling that you use to deploy
    your workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Pod Security Admission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pod Security Admission is a critical piece of your workload security story that
    allows you to configure and manage all the security-sensitive components of your
    pod configuration and apply out-of-the-box best practices either to a namespace
    or at the cluster level. [Chapter 10](ch10.html#pod_and_container_security) is
    dedicated to container and pod security, and we encourage you to review it for
    further detail.
  prefs: []
  type: TYPE_NORMAL
- en: Seccomp, AppArmor, and SELinux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux offers several different security mechanisms that can be utilized in concert
    with Kubernetes to increase the security posture of your workloads running on
    Kubernetes. Seccomp allows the creation of syscall filtering profiles that can
    be used to restrict syscalls coming from a container. Unfortunately, Seccomp profiles
    aren’t talked about enough in the Kubernetes community and have not been configured
    at all or are misconfigured, allowing containers access to syscalls that could
    be used for malicious purposes. The Kubernetes community has created a great tool
    called the [security profile operator](https://oreil.ly/g0tNJ) that simplifies
    the management overhead in the configuration of Seccomp profiles. Seccomp is low-hanging
    fruit to configure from a security perspective, so you are strongly encouraged
    to enable the Seccomp default profile at a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor and SELinux are Linux kernel security modules that allow the granular
    configuration of per-container mandatory access control. These allow a cluster
    administrator fine-grained control over what action a container can perform. Using
    both Pod Security Admission and these Linux security mechanisms, you can control
    the level of access a container should have to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Admission Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Admission controllers are a critical piece in securing your workloads. Kubernetes
    ships with a set of integrated admission controllers, and all security-related
    admission controllers are enabled by default. For example, the NodeRestriction
    admission controller restricts Kubelet’s permissions to only be able to modify
    pods assigned to that specific node. Admission controllers are a big topic, and
    we suggest you look at [Chapter 17](ch17.html#admission_control_and_authorization)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators are controllers that use the Kubernetes APIs to provide custom resources
    to support specific workloads that require application-specific knowledge. If
    you would like to learn more about the Operator pattern, refer to [Chapter 21](ch21.html#implementing_an_operator)
    where we cover how to implement an operator in detail. In the context of security,
    unfortunately, many operators ship with very permissive RBAC configuration, for
    ease of use. Many grant cluster-admin or equivalent privileges, which may serve
    as an attack vector. Additionally, though less common, these operators may expose
    other APIs directly, which could provide a pathway to privilege escalation.
  prefs: []
  type: TYPE_NORMAL
- en: Network Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes ships with a network policy resource; however, you need to double
    check that your networking provider implements the resource at runtime. For more
    details on network security, refer to [Chapter 9](ch09.html#networking_network_security_and_service_mesh).
    Kubernetes network policy provides fine-grained control over what network traffic
    is allowed to enter or exit a service or namespace for resources both internal
    and external to your cluster. Network policy also allows cluster administrators
    to create cluster-wide or namespace-specific policies and delegate application-specific
    network policy to application developers. Network policy covers only IP addresses
    and TCP/UDP ports and not specific HTTP traffic or endpoint routing access control.
    If you require application-specific access policies, service meshes include higher-level
    access policies that aren’t part of the integrated APIs of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most Kubernetes clusters utilize container runtimes such as [containerd](https://oreil.ly/Vyq_N)
    or [CRI-O](https://oreil.ly/OiXpP) by default, which leverage Linux cgroups under
    the hood to provide a lightweight sandbox for the container runtime. For some
    security-sensitive workloads, these security guarantees may not be sufficient.
    There is an ecosystem of different container runtimes, including [Kata containers](https://oreil.ly/ANDje)
    and [gvisor](https://oreil.ly/fuNPn), that provide different security profiles
    to suit the needs of the workload. Kubernetes supports the use of multiple container
    runtimes on the same cluster using the `RuntimeClass` field in the pod specification.
    Please refer to [Chapter 10](ch10.html#pod_and_container_security) for more detail
    on `RuntimeClass`. If you still require a higher level of security then [Confidential
    Containers](https://oreil.ly/v66K0) may also be something to consider. Confidential
    Containers leverage [trusted execution environments](https://oreil.ly/eSJfX),
    which are secure areas on the CPU to run the workload.
  prefs: []
  type: TYPE_NORMAL
- en: Like audit logs at the Kubernetes control plane, you should also invest in audit
    logging inside the container runtime. Tooling like [Falco](https://oreil.ly/9KOeg)
    provides a way to enable audit logging and policy on what the application can
    do inside the container runtime. Having visibility into the container runtime
    allows you to monitor and catch malicious behavior as close to the source as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Workload Container Security Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes provides a rich set of security tooling for you to use that can
    almost be overwhelming to grok. Here is a shortlist of best practices you can
    focus on to quickly improve the security posture of the workloads running on your
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Node and RBAC authorizers together, in combination with the NodeRestriction
    admission plug-in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure the cluster control plane with strong authentication and authorization
    mechanisms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review operator API permissions and make sure that they follow least privilege.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the principle of least privilege to limit the access and permissions of
    users, pods, and service accounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement network policies to restrict the traffic between pods and namespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the recommended set of security-based admission controllers are enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Seccomp, AppArmor, and SELinux to minimize the Linux kernel attack surface
    area the container runtime has access to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure dynamic webhook admission controllers are securely configured, scoped
    to only the resources they need to validate/mutate, and follow least privilege
    RBAC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide different container runtime sandboxes on your cluster and use `RuntimeClass`
    to allow application developers to select the runtime to match the security requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use admission controllers to validate security best practices on application
    workloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good security starts before the code even reaches Kubernetes. We’ll cover some
    different tools and techniques that you can introduce to further improve your
    security posture.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Root and Distroless Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two quick wins when it comes to building containers with an improved
    security posture. Configure the application process to not run as the root user
    by specifying a non-root user as part of the container build file. Kubernetes
    allows for this also to be set as part of the `securityContext` section of the
    pod specification via the `runAsUser`. This can be used as a fail-safe; however,
    configuring it in the container build file is preferred. Additionally, many base
    containers provide commonly used packages preinstalled in the container. These
    packages may not be used and can introduce vulnerabilities. Tools like [distroless](https://oreil.ly/tpSEA)
    and scratch containers provide the smallest possible base container image, which
    again decreases the attack surface area.
  prefs: []
  type: TYPE_NORMAL
- en: Container Vulnerability Scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many open source tools provide vulnerability scanning of container images. These
    tools, like [Trivy](https://oreil.ly/pFbNN), are easy to use and can provide a
    baseline of the vulnerabilities in a container image. You can then decide whether
    or not to deploy the container based on these results. However, these tools can
    be very noisy and provide inconsistent results. Many container repository providers
    offer integrated vulnerability scanning, and some admission controllers will either
    admit or deny a workload being deployed based on the vulnerabilities present in
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: Code Repository Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source code repositories are another great place to improve security, and thankfully
    there is tooling and guidance to help improve the security posture at this layer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Supply-Chain Levels for Software Artifacts](https://oreil.ly/CWXWD), or SLSA,
    is a framework that provides a checklist of controls based on incremental levels
    that you can adopt to help improve software security and integrity. Many open
    source projects are adopting SLSA in an effort to improve software security. The
    levels are well-defined and when implemented raise the security posture of your
    source code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[OpenSSF Scorecard](https://oreil.ly/q-NI3) gives an automated set of tools
    that provide a 0–10 score on the security posture of an open source repository
    that you might be using or considering to use as a dependency. The aggregate score
    provides an at-a-glance view that can be used to evaluate how trustworthy an open
    source project is. Many prominent open source projects are adopting this scorecard.'
  prefs: []
  type: TYPE_NORMAL
- en: Code Security Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Good security starts well before a container is deployed to a Kubernetes cluster.
    The code repository is a great place to also implement security measures to build
    your in-depth security strategy. Here are some best practices to help guide you
    to some quick wins on your code security front:'
  prefs: []
  type: TYPE_NORMAL
- en: Review operator API permissions and make sure that they follow least privilege.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the container build file to run application processes as a non-root
    user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use container base images like scratch and distroless.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform vulnerability scanning on your containers, and implement policy on whether
    to allow a container to be deployed based on these vulnerabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review OpenSSF scorecards on open source projects that you depend on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement SLSA level 1 to provide baseline-level transparency and integrity
    for your software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered a lot of ground in this chapter. It’s important to understand
    the full breadth of what it takes to secure Kubernetes so that you can start to
    break down the problem into smaller pieces that you can implement. Security is
    a journey and not a destination. It will always be a moving target, and by following
    these best practices, you can improve the security posture of your Kubernetes
    cluster and reduce the risk of data breaches or compromises.
  prefs: []
  type: TYPE_NORMAL
