<html><head></head><body><section data-pdf-bookmark="Chapter 12. Serialization and Transports" data-type="chapter" epub:type="chapter"><div class="chapter" id="topics_transports">&#13;
<h1><span class="label">Chapter 12. </span>Serialization and Transports</h1>&#13;
&#13;
&#13;
<p>To<a data-primary="transports" data-see="serialization and transports" data-type="indexterm" id="idm46177219560216"/><a data-primary="serialization and transports" data-secondary="process of" data-type="indexterm" id="idm46177219559240"/> serialize an object we convert the abstract concept (the “model”) to transportable entities, usually either a <code>String</code> representation of the model, like XML or JSON, or bytes.</p>&#13;
&#13;
<p>To deserialize data means to convert it from a series of entities to an object your program recognizes. For example, you might have an <code>Author</code> entity with a <code>name</code> <span class="keep-together">property</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177219555416">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="serialization and transports" data-secondary="task overview" data-type="indexterm" id="idm46177219554056"/> this chapter, you’ll learn to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Serialize and deserialize an object instance.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177219551272">&#13;
<h1>Android</h1>&#13;
&#13;
<p>Android<a data-primary="serialization and transports" data-secondary="Android" data-tertiary="XML, JSON, and Protocol Buffers" data-type="indexterm" id="idm46177219549944"/><a data-primary="Android" data-secondary="serialization and transports" data-tertiary="XML, JSON, and Protocol Buffers" data-type="indexterm" id="idm46177219548584"/> uses a lot of XML internally, but in the real world, JSON is still the primary serialization mechanism (although larger organizations with plenty of engineering resources have started to embrace “protobuf,” or Protocol Buffers). This is a neat concept and highly performant, but beyond the scope of our examination of the framework and standard APIs.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Serialize and Deserialize an Object Instance" data-type="sect2"><div class="sect2" id="idm46177219546712">&#13;
<h2>Serialize and Deserialize an Object Instance</h2>&#13;
&#13;
<p>In<a data-primary="serialization and transports" data-secondary="Android" data-tertiary="serializing and deserializing object instances" data-type="indexterm" id="STandserial12"/><a data-primary="Android" data-secondary="serialization and transports" data-tertiary="serializing and deserializing object instances" data-type="indexterm" id="Asatser12"/><a data-primary="Java" data-secondary="serializing and deserializing object instances" data-type="indexterm" id="Jserial12"/><a data-primary="Kotlin" data-secondary="serializing and deserializing object instances" data-type="indexterm" id="Kserial12"/> Java and Android, deserialization probably starts with a data model, like this:</p>&#13;
<aside class="java-kotlin less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177219539272">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Author</code> <code class="o">{</code>&#13;
  <code class="kd">private</code> <code class="n">String</code> <code class="n">mName</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="n">String</code> <code class="nf">getName</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">mName</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setName</code><code class="o">(</code><code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">mName</code> <code class="o">=</code> <code class="n">name</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Author</code> <code class="p">{</code>&#13;
  <code class="k">var</code> <code class="py">name</code><code class="p">:</code><code class="n">String</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Deserialized to JSON, an <code>Author</code> instance that returned “Mike” by invoking <code>getName</code> would probably look like this:</p>&#13;
&#13;
<pre data-type="programlisting">{ name : "Mike" }</pre>&#13;
&#13;
<p>Once it’s in JSON format, it can be passed along with a network request, written to disk, or even handed off to another program in wildly different technologies; since the JSON format has an established spec, we can trust that the JSON rules used by your Android application will look like the JSON rules used by an iOS application, or even a Windows or Unix program.</p>&#13;
&#13;
<p>There<a data-primary="JSON serialization" data-secondary="Android" data-type="indexterm" id="jsonser12"/><a data-primary="org.json package" data-type="indexterm" id="orgjson12"/> are really three main modes of serialization in the Android framework:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>JSON</p>&#13;
</li>&#13;
<li>&#13;
<p>XML</p>&#13;
</li>&#13;
<li>&#13;
<p>Java Serialization</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Those are roughly in order of popularity. While some level of support for each is available from the Java standard libraries, or the Android framework, we’ll also take a look at third-party libraries like <a href="https://oreil.ly/RRhOS">Gson</a>. While Gson is a Google product, there are some very popular alternatives—do a quick search if you don’t find Gson or org.json compelling or if you don’t use a ton of JSON in your <span class="keep-together">application</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="org.json" data-type="sect3"><div class="sect3" id="idm46177219479336">&#13;
<h3>org.json</h3>&#13;
&#13;
<p>See <a href="https://oreil.ly/5Zw0T">the developer docs for this package</a> for reference.</p>&#13;
&#13;
<p>Basic serialization and deserialization using the <code>org.json</code> package is pretty straightforward. Let’s consider the <code>Author</code> class used earlier. To serialize that, we can instantiate a <code>JSONObject</code> instance, copy our properties to it, and call the <code>toString</code> method:</p>&#13;
<aside class="java-kotlin less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177219474328">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Author</code> <code class="n">author</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Author</code><code class="o">();</code>&#13;
<code class="n">author</code><code class="o">.</code><code class="na">setName</code><code class="o">(</code><code class="s">"Mike"</code><code class="o">);</code>&#13;
<code class="c1">// ...</code>&#13;
<code class="n">JSONObject</code> <code class="n">jsonObject</code> <code class="o">=</code> <code class="k">new</code> <code class="n">JSONObject</code><code class="o">();</code>&#13;
<code class="n">jsonObject</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="s">"name"</code><code class="o">,</code> <code class="n">author</code><code class="o">.</code><code class="na">getName</code><code class="o">());</code>&#13;
<code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="n">jsonObject</code><code class="o">.</code><code class="na">toString</code><code class="o">());</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">author</code> <code class="p">=</code> <code class="n">Author</code><code class="p">()</code>&#13;
<code class="n">author</code><code class="p">.</code><code class="n">name</code> <code class="p">=</code> <code class="s">"Mike"</code>&#13;
<code class="k">val</code> <code class="py">jsonObject</code> <code class="p">=</code> <code class="n">JSONObject</code><code class="p">()</code>&#13;
<code class="n">jsonObject</code><code class="p">.</code><code class="n">put</code><code class="p">(</code><code class="s">"name"</code><code class="p">,</code> <code class="n">author</code><code class="p">.</code><code class="n">name</code><code class="p">)</code>&#13;
<code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="n">jsonObject</code><code class="p">.</code><code class="n">toString</code><code class="p">())</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>This would print out <code>{"name":"Mike"}</code>.</p>&#13;
&#13;
<p>Deserializing is more automated:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177219244808">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="n">json</code> <code class="o">=</code> <code class="s">"{name:'Mike'}"</code><code class="o">;</code>&#13;
<code class="n">JSONObject</code> <code class="n">jsonObject</code> <code class="o">=</code> <code class="k">new</code> <code class="n">JSONObject</code><code class="o">(</code><code class="n">json</code><code class="o">);</code>&#13;
<code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="n">jsonObject</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="s">"name"</code><code class="o">));</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">json</code> <code class="p">=</code> <code class="s">"{name:'Mike'}"</code>&#13;
<code class="k">val</code> <code class="py">jsonObject</code> <code class="p">=</code> <code class="n">JSONObject</code><code class="p">(</code><code class="n">json</code><code class="p">)</code>&#13;
<code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="n">jsonObject</code><code class="p">.</code><code class="k">get</code><code class="p">(</code><code class="s">"name"</code><code class="p">)</code> <code class="k">as</code> <code class="n">String</code><code class="p">?)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>This would log <code>Mike</code>.</p>&#13;
&#13;
<p>There are similar facilities for arrays (lists), but there can be a fairly large amount of conversion with checked exceptions handling large objects this way, and it’s not as common as Gson. Let’s take a look at that.</p>&#13;
&#13;
<p>Using<a data-primary="Gson" data-type="indexterm" id="idm46177219145032"/> Gson, serialization works pretty similarly, but you don’t need an intermediary wrapper:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Author</code> <code class="n">author</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Author</code><code class="o">();</code>&#13;
<code class="n">author</code><code class="o">.</code><code class="na">setName</code><code class="o">(</code><code class="s">"Mike"</code><code class="o">);</code>&#13;
<code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="k">new</code> <code class="n">Gson</code><code class="o">().</code><code class="na">toJson</code><code class="o">(</code><code class="n">author</code><code class="o">));</code></pre>&#13;
&#13;
<p>This would output <code>{"mName":"Mike"}</code>.</p>&#13;
&#13;
<p>Did you catch it? <code>mName</code>, not <code>name</code>. Gson uses the property name by default, rather than getter or setter method names.</p>&#13;
&#13;
<p>This<a data-primary="Hungarian notation" data-type="indexterm" id="idm46177219092984"/> type of notation—using an <code>m</code> to prefix member variables, and <code>s</code> to prefix static variables—is known as Hungarian notation. You see that AOSP itself uses Hungarian notation exclusively, so many Android developers have taken to using that style as well. As you’ll see in the following, there’s a simple fix, but do note that Hungarian notation does create an issue with Gson (or similar libraries) out of the box. Note that the issue with Hungarian (or any arbitrary) notation is NOT an issue in Kotlin. If your <code>Author</code> class were defined as shown in the Kotlin sample, earlier, the output would be just as you’d expect: <code>{"name": "Mike"}</code>.</p>&#13;
&#13;
<p>Back to the Java example. This issue is common but also very simple to modify—you can annotate any property with <code>@SerializedName</code> to use an alternative. For example, assume the <code>Author</code> class looked like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Author</code> <code class="o">{</code>&#13;
  <code class="nd">@SerializedName</code><code class="o">(</code><code class="s">"name"</code><code class="o">)</code>&#13;
  <code class="kd">private</code> <code class="n">String</code> <code class="n">mName</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="n">String</code> <code class="nf">getName</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">mName</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setName</code><code class="o">(</code><code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">mName</code> <code class="o">=</code> <code class="n">name</code><code class="o">;</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Then the output would be as you’d expect: <code>{"name":"Mike"}</code>. Note that this works both ways, and it will deserialize from annotated values as well. Let’s assume we’ve updated the <code>Author</code> class for the next example, deserialization:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="n">json</code> <code class="o">=</code> <code class="s">"{name:'Mike'}"</code><code class="o">;</code>&#13;
<code class="n">Author</code> <code class="n">author</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Gson</code><code class="o">().</code><code class="na">fromJson</code><code class="o">(</code><code class="n">json</code><code class="o">,</code> <code class="n">Author</code><code class="o">.</code><code class="na">class</code><code class="o">);</code>&#13;
<code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="n">author</code><code class="o">.</code><code class="na">getName</code><code class="o">());</code></pre>&#13;
&#13;
<p>This would output <code>Mike</code>, just as you’d expect.</p>&#13;
&#13;
<p>The biggest benefit of Gson is that it will handle this in a recursive strategy, and the <code>org.json</code> classes often will not.<a data-primary="" data-startref="orgjson12" data-type="indexterm" id="idm46177218995352"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="org.xmlpull" data-type="sect3"><div class="sect3" id="idm46177219478360">&#13;
<h3>org.xmlpull</h3>&#13;
&#13;
<p>Another<a data-primary="org.xmlpull" data-type="indexterm" id="orgxml12"/> common transport is XML. If you’ve ever written for the web, you’re sure to have seen XML or some variant of it—if you see data that’s chock full of angle brackets, it’s probably XML or a cousin.</p>&#13;
&#13;
<p>While Java standard libraries available within the Android framework don’t provide any built-in APIs for handling XML, Android does provide a third-party package that is maintained is vetted: <code>org.xmlpull</code>. This package provides object instances known as “XML pull parsers,” with which we can read and traverse XML data. A “pull parser” is just one that requests tokens from a stream—the opposite “push parser” sends tokens to the parser as they’re encountered, not as they’re requested. This is really a semantic detail and is unimportant to how you’ll use these classes in practice.</p>&#13;
&#13;
<p>In any event, we’ll provide as basic an example of XML parsing as we can, but even this small sample you’ll notice is verbose and not exactly readable. If you have data coming in from XML and need to parse it, do a deep dive on the <code>org.xml</code> classes, or find a good third-party alternative. Here’s the basic operation:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177218956168">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">XmlParser</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">parseNodeText</code><code class="o">()</code> <code class="kd">throws</code> <code class="n">Exception</code> <code class="o">{</code>&#13;
    <code class="c1">// just some simple, conformant XML; note the root node (required)</code>&#13;
    <code class="n">String</code> <code class="n">xml</code> <code class="o">=</code> <code class="s">"&lt;root&gt;&lt;child&gt;A&lt;/child&gt;&lt;child&gt;B&lt;/child&gt;&lt;/root&gt;"</code><code class="o">;</code>&#13;
    <code class="c1">// let's turn it into a byte stream for the parser</code>&#13;
    <code class="n">InputStream</code> <code class="n">inputStream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ByteArrayInputStream</code><code class="o">(</code><code class="n">xml</code><code class="o">.</code><code class="na">getBytes</code><code class="o">());</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
      <code class="c1">// grab an instance of the default parser</code>&#13;
      <code class="n">XmlPullParser</code> <code class="n">parser</code> <code class="o">=</code> <code class="n">Xml</code><code class="o">.</code><code class="na">newPullParser</code><code class="o">();</code>&#13;
      <code class="c1">// we don't want namespaces for this simple example</code>&#13;
      <code class="n">parser</code><code class="o">.</code><code class="na">setFeature</code><code class="o">(</code><code class="n">XmlPullParser</code><code class="o">.</code><code class="na">FEATURE_PROCESS_NAMESPACES</code><code class="o">,</code> <code class="kc">false</code><code class="o">);</code>&#13;
      <code class="c1">// specify the input stream and the namespace (null)</code>&#13;
      <code class="n">parser</code><code class="o">.</code><code class="na">setInput</code><code class="o">(</code><code class="n">inputStream</code><code class="o">,</code> <code class="kc">null</code><code class="o">);</code>&#13;
      <code class="c1">// go to the next (first) tag</code>&#13;
      <code class="n">parser</code><code class="o">.</code><code class="na">nextTag</code><code class="o">();</code>&#13;
      <code class="c1">// make sure it's an opening root tag</code>&#13;
      <code class="n">parser</code><code class="o">.</code><code class="na">require</code><code class="o">(</code><code class="n">XmlPullParser</code><code class="o">.</code><code class="na">START_TAG</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="s">"root"</code><code class="o">);</code>&#13;
      <code class="c1">// iterate through, stopping at each start tag</code>&#13;
      <code class="k">while</code> <code class="o">(</code><code class="n">parser</code><code class="o">.</code><code class="na">next</code><code class="o">()</code> <code class="o">!=</code> <code class="n">XmlPullParser</code><code class="o">.</code><code class="na">END_TAG</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">parser</code><code class="o">.</code><code class="na">getEventType</code><code class="o">()</code> <code class="o">!=</code> <code class="n">XmlPullParser</code><code class="o">.</code><code class="na">START_TAG</code><code class="o">)</code> <code class="o">{</code>&#13;
          <code class="k">continue</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
        <code class="c1">// what's the name of the node, or attribute?</code>&#13;
        <code class="n">String</code> <code class="n">name</code> <code class="o">=</code> <code class="n">parser</code><code class="o">.</code><code class="na">getName</code><code class="o">();</code>&#13;
        <code class="c1">// if it's "child", the content node name we're using</code>&#13;
        <code class="c1">// in our exmaple, let's examine it</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">name</code><code class="o">.</code><code class="na">equals</code><code class="o">(</code><code class="s">"child"</code><code class="o">))</code> <code class="o">{</code>&#13;
          <code class="c1">// first we have to move from the start tag to the content</code>&#13;
          <code class="n">parser</code><code class="o">.</code><code class="na">next</code><code class="o">();</code>&#13;
          <code class="c1">// log it out</code>&#13;
          <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"text="</code> <code class="o">+</code> <code class="n">parser</code><code class="o">.</code><code class="na">getText</code><code class="o">());</code>&#13;
          <code class="c1">// then move from the content to the end tag,</code>&#13;
          <code class="c1">// and start the iteration again</code>&#13;
          <code class="n">parser</code><code class="o">.</code><code class="na">next</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
      <code class="o">}</code>&#13;
    <code class="o">}</code> <code class="k">finally</code> <code class="o">{</code>&#13;
      <code class="n">inputStream</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">@Throws</code><code class="p">(</code><code class="n">Exception</code><code class="o">::</code><code class="k">class</code><code class="p">)</code>&#13;
<code class="k">fun</code> <code class="nf">parseNodeText</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="c1">// just some simple, conformant XML; note the root node (required)</code>&#13;
  <code class="k">val</code> <code class="py">xml</code> <code class="p">=</code> <code class="s">"&lt;root&gt;&lt;child&gt;A&lt;/child&gt;&lt;child&gt;B&lt;/child&gt;&lt;/root&gt;"</code>&#13;
  <code class="c1">// let's turn it into a byte stream for the parser</code>&#13;
  <code class="k">val</code> <code class="py">inputStream</code> <code class="p">=</code> <code class="n">ByteArrayInputStream</code><code class="p">(</code><code class="n">xml</code><code class="p">.</code><code class="n">toByteArray</code><code class="p">())</code>&#13;
  <code class="k">try</code> <code class="p">{</code>&#13;
    <code class="c1">// grab an instance of the default parser</code>&#13;
    <code class="k">val</code> <code class="py">parser</code> <code class="p">=</code> <code class="n">Xml</code><code class="p">.</code><code class="n">newPullParser</code><code class="p">()</code>&#13;
    <code class="c1">// we don't want namespaces for this simple example</code>&#13;
    <code class="n">parser</code><code class="p">.</code><code class="n">setFeature</code><code class="p">(</code><code class="n">XmlPullParser</code><code class="p">.</code><code class="n">FEATURE_PROCESS_NAMESPACES</code><code class="p">,</code> <code class="k">false</code><code class="p">)</code>&#13;
    <code class="c1">// specify the input stream and the namespace (null)</code>&#13;
    <code class="n">parser</code><code class="p">.</code><code class="n">setInput</code><code class="p">(</code><code class="n">inputStream</code><code class="p">,</code> <code class="k">null</code><code class="p">)</code>&#13;
    <code class="c1">// go to the next (first) tag</code>&#13;
    <code class="n">parser</code><code class="p">.</code><code class="n">nextTag</code><code class="p">()</code>&#13;
    <code class="c1">// make sure it's an opening root tag</code>&#13;
    <code class="n">parser</code><code class="p">.</code><code class="n">require</code><code class="p">(</code><code class="n">XmlPullParser</code><code class="p">.</code><code class="n">START_TAG</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="s">"root"</code><code class="p">)</code>&#13;
    <code class="c1">// iterate through, stopping at each start tag</code>&#13;
    <code class="k">while</code> <code class="p">(</code><code class="n">parser</code><code class="p">.</code><code class="n">next</code><code class="p">()</code> <code class="p">!=</code> <code class="n">XmlPullParser</code><code class="p">.</code><code class="n">END_TAG</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="n">parser</code><code class="p">.</code><code class="n">eventType</code> <code class="p">!=</code> <code class="n">XmlPullParser</code><code class="p">.</code><code class="n">START_TAG</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">continue</code>&#13;
      <code class="p">}</code>&#13;
      <code class="c1">// what's the name of the node, or attribute?</code>&#13;
      <code class="k">val</code> <code class="py">name</code> <code class="p">=</code> <code class="n">parser</code><code class="p">.</code><code class="n">name</code>&#13;
      <code class="c1">// if it's "child", the content node name we're using</code>&#13;
      <code class="c1">// in our exmaple, let's examine it</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="n">name</code> <code class="p">==</code> <code class="s">"child"</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="c1">// first we have to move from the start tag to the content</code>&#13;
        <code class="n">parser</code><code class="p">.</code><code class="n">next</code><code class="p">()</code>&#13;
        <code class="c1">// log it out</code>&#13;
        <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"text="</code> <code class="p">+</code> <code class="n">parser</code><code class="p">.</code><code class="n">text</code><code class="p">)</code>&#13;
        <code class="c1">// then move from the content to the end tag,</code>&#13;
        <code class="c1">// and start the iteration again</code>&#13;
        <code class="n">parser</code><code class="p">.</code><code class="n">next</code><code class="p">()</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>&#13;
    <code class="n">inputStream</code><code class="p">.</code><code class="n">close</code><code class="p">()</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>For a deep dive into the <code>org.xml</code> package, see <a href="https://oreil.ly/OEm5A">the Android developer docs</a>.<a data-primary="" data-startref="orgxml12" data-type="indexterm" id="idm46177218767080"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Java serialization" data-type="sect3"><div class="sect3" id="idm46177218766008">&#13;
<h3>Java serialization</h3>&#13;
&#13;
<p>Java serialization<a data-primary="Java" data-secondary="Java serialization" data-type="indexterm" id="JS12"/> is perhaps the easiest transport to understand and from a distance can seem like a great strategy. In practice, however, there are lots of downsides—we’ll touch on them briefly, but that’s not to say there is never a circumstance where Java serialization is appropriate.</p>&#13;
&#13;
<p>The basic premise is simple: convert an object instance to bytes. You can then save those bytes to disk, or send them across the wire, and reassemble the original object as needed. However, this requires that any program attempting to deserialize an object serialized in this fashion must have the exact Java definition of the object—the<a data-primary="Java virtual machine (JVM)" data-type="indexterm" id="idm46177218535784"/> Java virtual machine (JVM) must have a class that matches the fully qualified class name of the object, and if any of the methods or properties are accessed on either side and don’t match, you’ve pretty much hit the end of the road.</p>&#13;
&#13;
<p>As an example, imagine that you have inherited your application code from a third-party contractor. They used a class called “Chapter” that had a variety of properties and methods useful for an object representing that chapter. However, the package name (and therefore the fully qualified class name, or the “canonical” name) included the domain of the contractor, and when you took ownership of the application source code, you no longer had a matching package name. Normally, this would be fine and you’d come up with our own <code>Chapter</code> class, which may or may not have methods and properties with names or functionality similar to that old <code>Chapter</code> class. However, the contractor had violated a community consensus: they had stored <code>Chapter</code> instances in a user’s favorites list by serializing the <code>Chapter</code> instance to bytes and saving that blob to a local SQLite database. This means you <em>have</em> to maintain a package with a name matching exactly the previous canonical name, including the contractor’s domain. Of course, when you want to define how a <code>Chapter</code> instance works in your own app, this intermediary class exists only long enough to deserialize from the database, convert to the updated version of the <code>Chapter</code> class, and save its properties to our updated database. This is not only confusing because we have to tell this story to each new developer, but every time you open Android Studio, that unused contractor’s package sits at the top of your source code, littered with skeleton classes that exist only so users from the previous version can migrate their content to the new app.</p>&#13;
&#13;
<p>Warnings aside, let’s dig in to how you can use Java serialization if you ever decide you need it.</p>&#13;
&#13;
<p>The first thing you’ll need to know is that to use built-in Java serialization, the class being serialized must implement the <code>Serializable</code> interface. Now, there is no contract with that interface (no methods you have to implement); it just has to implement the interface itself.</p>&#13;
&#13;
<p>You should also provide a <code>Long</code> serialization ID, in the form of <code>private static final long serialVersionUID = 12345467890;</code>. Any valid <code>Long</code> is allowed here, and it should be unique amongst your serializable classes. Most Java or Android-aware IDEs can generate this value for you, with the correct name and value.</p>&#13;
&#13;
<p>From there, there’s not a lot left. You’ll write the object to a file using the subclasses of the <code>InputStream</code> and <code>OutputStream</code> classes we learned about in <a data-type="xref" href="ch06.html#topics_files">Chapter 6</a>. Let’s take a look on how to serialize a simple class—in fact, we’ll use the same <code>Author</code> class we showed earlier:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177218523384">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="c1">// assume "myObject" is a valid object instance</code>&#13;
<code class="k">try</code> <code class="o">{</code>&#13;
   <code class="n">File</code> <code class="n">file</code> <code class="o">=</code> <code class="k">new</code> <code class="n">File</code><code class="o">(</code><code class="n">context</code><code class="o">.</code><code class="na">getFilesDir</code><code class="o">(),</code> <code class="s">"data.obj"</code><code class="o">);</code>&#13;
   <code class="n">FileOutputStream</code> <code class="n">fileOutputStream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">FileOutputStream</code><code class="o">(</code><code class="n">file</code><code class="o">);</code>&#13;
   <code class="n">ObjectOutputStream</code> <code class="n">objectOutputStream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectOutputStream</code><code class="o">(</code><code class="n">fileOutputStream</code><code class="o">);</code>&#13;
   <code class="n">objectOutputStream</code><code class="o">.</code><code class="na">writeObject</code><code class="o">(</code><code class="n">myObject</code><code class="o">);</code>&#13;
   <code class="n">objectOutputStream</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
<code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">IOException</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
   <code class="c1">// failed</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="c1">// assume "myObject" is a valid object instance</code>&#13;
<code class="k">try</code> <code class="p">{</code>&#13;
  <code class="k">val</code> <code class="py">file</code> <code class="p">=</code> <code class="n">File</code><code class="p">(</code><code class="n">context</code><code class="p">.</code><code class="n">getFilesDir</code><code class="p">(),</code> <code class="s">"data.obj"</code><code class="p">)</code>&#13;
  <code class="k">val</code> <code class="py">fileOutputStream</code> <code class="p">=</code> <code class="n">FileOutputStream</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>&#13;
  <code class="k">val</code> <code class="py">objectOutputStream</code> <code class="p">=</code> <code class="n">ObjectOutputStream</code><code class="p">(</code><code class="n">fileOutputStream</code><code class="p">)</code>&#13;
  <code class="n">objectOutputStream</code><code class="p">.</code><code class="n">writeObject</code><code class="p">(</code><code class="n">myObject</code><code class="p">)</code>&#13;
  <code class="n">objectOutputStream</code><code class="p">.</code><code class="n">close</code><code class="p">()</code>&#13;
  <code class="n">fileOutputStream</code><code class="p">.</code><code class="n">close</code><code class="p">()</code>&#13;
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">i</code><code class="p">:</code> <code class="n">IOException</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// failed</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Now you’ve got a file called “data.obj” that contains the bytes representing your object instance. Note that this is a complete reproduction and can be deserialized back to the state it was at the time of serialization, as long as the class file is on your CLASSPATH at the time you want to deserialize. Reading it back out is also pretty familiar:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177218318456">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="o">{</code>&#13;
   <code class="n">FileInputStream</code> <code class="n">fileInputStream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">FileInputStream</code><code class="o">(</code><code class="s">"data.obj"</code><code class="o">);</code>&#13;
   <code class="n">ObjectInputStream</code> <code class="n">objectInputStream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectInputStream</code><code class="o">(</code><code class="n">fileInputStream</code><code class="o">);</code>&#13;
   <code class="n">Author</code> <code class="n">author</code> <code class="o">=</code> <code class="o">(</code><code class="n">Author</code><code class="o">)</code> <code class="n">objectInputStream</code><code class="o">.</code><code class="na">readObject</code><code class="o">();</code>&#13;
   <code class="n">objectInputStream</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
   <code class="n">fileInputStream</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
<code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">IOException</code> <code class="o">|</code> <code class="n">ClassNotFoundException</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
   <code class="c1">// failed</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">try</code> <code class="p">{</code>&#13;
  <code class="k">val</code> <code class="py">fileInputStream</code> <code class="p">=</code> <code class="n">FileInputStream</code><code class="p">(</code><code class="s">"data.obj"</code><code class="p">)</code>&#13;
  <code class="k">val</code> <code class="py">objectInputStream</code> <code class="p">=</code> <code class="n">ObjectInputStream</code><code class="p">(</code><code class="n">fileInputStream</code><code class="p">)</code>&#13;
  <code class="k">val</code> <code class="py">author</code> <code class="p">=</code> <code class="n">objectInputStream</code><code class="p">.</code><code class="n">readObject</code><code class="p">()</code> <code class="k">as</code> <code class="n">Author</code>&#13;
  <code class="n">objectInputStream</code><code class="p">.</code><code class="n">close</code><code class="p">()</code>&#13;
  <code class="n">fileInputStream</code><code class="p">.</code><code class="n">close</code><code class="p">()</code>&#13;
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">IOException</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// failed</code>&#13;
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">ClassNotFoundException</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// failed</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>That’s it! As mentioned, a lot of the community has moved to JSON as the standard serialization strategy for networked computing, but as you can see there are lots of options. For more fun, take a quick Google around “protobuffs”—a new, Googley way to transport data.<a data-primary="" data-startref="JS12" data-type="indexterm" id="idm46177221650520"/><a data-primary="" data-startref="STandserial12" data-type="indexterm" id="idm46177218147640"/><a data-primary="" data-startref="Asatser12" data-type="indexterm" id="idm46177218146728"/><a data-primary="" data-startref="Jserial12" data-type="indexterm" id="idm46177218145784"/><a data-primary="" data-startref="Kserial12" data-type="indexterm" id="idm46177218144840"/><a data-primary="" data-startref="jsonser12" data-type="indexterm" id="idm46177218143896"/><a data-primary="" data-startref="orgjson12" data-type="indexterm" id="idm46177218142952"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177219546120">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>There<a data-primary="iOS" data-secondary="serializing and deserializing object instances" data-type="indexterm" id="IOSserial12"/><a data-primary="serialization and transports" data-secondary="iOS" data-tertiary="serializing and deserializing object instances" data-type="indexterm" id="SATiosserial1"/> are a variety of ways to convert data to and from transport entities. Usually, this is done during network requests, and the two most common data transport formats are JSON and XML, with JSON becoming much more popular in recent years than XML. The process for converting between these two formats and Swift object instances is very different. There<a data-primary="property lists (plist files)" data-type="indexterm" id="idm46177218137176"/> is an additional format used almost exclusively by Apple called property lists. They are special-purpose XML that iOS (and macOS) apps can read and write data to and from.</p>&#13;
&#13;
<p>Updates to Swift have made parsing this data much more straightforward and less error-prone in the past, but there is still significant complexity involved. In other words, we’ve got a lot to cover, so let’s dive in.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Serialize and Deserialize an Object Instance" data-type="sect2"><div class="sect2" id="idm46177218135464">&#13;
<h2>Serialize and Deserialize an Object Instance</h2>&#13;
&#13;
<p>Historically, in the primeval days of Objective-C, parsing an object to JSON was unnecessarily complex or required a third-party library. Indeed, even the early days of Swift were fraught with complexity and distress. Thankfully, Apple paid attention to the needs of developers and with Swift 3 brought a new, modern approach to JSON serialization and deserialization.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JSON" data-type="sect3"><div class="sect3" id="idm46177218133416">&#13;
<h3>JSON</h3>&#13;
&#13;
<p>Let’s<a data-primary="JSON serialization" data-secondary="iOS" data-type="indexterm" id="idm46177218131688"/> start with a Swift object that looks like this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">struct</code> <code class="nc">Author</code> <code class="p">{</code>&#13;
	<code class="kd">let</code> <code class="nv">name</code><code class="p">:</code> <code class="nb">String</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The JSON representation would probably look like this:</p>&#13;
&#13;
<pre data-type="programlisting">{ "name": "Mike" }</pre>&#13;
&#13;
<p>When communicating with a server, it’s usually necessary to send and receive JSON like this and convert it into the pure Swift object. It’s certainly common to persist data an app needs to read later as JSON (or any of the other formats covered in this chapter) locally as well. Using the <code>Author</code> structure defined earlier, converting an instance of that object to the JSON previously displayed would look like similar to this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">struct</code> <code class="nc">Author</code><code class="p">:</code> <code class="n">Codable</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nv">name</code><code class="p">:</code> <code class="nb">String</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">author</code> <code class="p">=</code> <code class="n">Author</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"Mike"</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nv">rawData</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">JSONEncoder</code><code class="p">().</code><code class="n">encode</code><code class="p">(</code><code class="n">author</code><code class="p">)</code></pre>&#13;
&#13;
<p>Walking<a data-primary="Codable protocol" data-type="indexterm" id="idm46177218066776"/> through this, you can see that we’ve added a protocol for our object to implement called <code>Codable</code>. This protocol is a composition of two other protocols: <code>Encodable</code> and <code>Decodable</code>. They provide a set of functionality that the Swift compiler is able to interpret through some syntactic sugar and expected values.</p>&#13;
&#13;
<p>Objects that implement <code>Codable</code> are required to implement <code>encode(to:)</code> and <code>init(from:)</code>. If no implementation is provided, instead of erroring out, the Swift compiler applies some special logic to write the logic for the type itself. This is done by looking at the properties an object has and modifying a special nested enum type by the name of <code>CodingKeys</code>. Using this enum, the compiler is then able to create proper implementations of <code>encode(to:)</code> and <code>init(from:)</code>.</p>&#13;
&#13;
<p>You could call it magic, but really it’s the compiler making pragmatic decisions about the code.</p>&#13;
&#13;
<p>In our example, this plays out through <code>JSONEncoder</code> being able to encode <code>author</code> as a <code>Data</code> object that can used for storing locally on the device or sending across the wire to a server.</p>&#13;
&#13;
<p><code>Codable</code> also helps in converting (or “deserializing”) our object from JSON back into a normal Swift object. Here’s an example of what that looks like:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">rawJson</code> <code class="p">=</code> <code class="nb">String</code><code class="p">(</code><code class="s">"{</code><code class="se">\"</code><code class="s">name</code><code class="se">\"</code><code class="s">:</code><code class="se">\"</code><code class="s">Mike</code><code class="se">\"</code><code class="s">}"</code><code class="p">).</code><code class="n">data</code><code class="p">(</code><code class="n">using</code><code class="p">:</code> <code class="p">.</code><code class="n">utf8</code><code class="p">)</code><code class="o">!</code>&#13;
<code class="kd">let</code> <code class="nv">author</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">JSONDecoder</code><code class="p">().</code><code class="n">decode</code><code class="p">(</code><code class="n">Author</code><code class="p">.</code><code class="kc">self</code><code class="p">,</code> <code class="n">from</code><code class="p">:</code> <code class="n">rawJson</code><code class="p">)</code></pre>&#13;
&#13;
<p>First, we’re defining a <code>Data</code> object named <code>rawJson</code> that contains the JSON we might receive from a server. Next, we take that JSON and pass it into an instance of <span class="keep-together"><code>JSONDecoder</code></span> in the <code>decode(_:from:)</code> method. This method also takes an object type to attempt to transform the data into; in this case, we’re passing <code>Author.self</code>, which is the <code>Author</code> structure defined in the preceding example. The decoder decodes the object back into a native Swift object named <code>author</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Now, if we had given <code>JSONDecoder</code> an object type that it couldn’t decode the data back into, it would have produced an error. We’ve marked our call to this method as <code>try?</code>, which is sufficient for this example, but in a shipping app, you’d probably want to handle this with some user feedback or logging.</p>&#13;
</div>&#13;
&#13;
<p>There is more functionality packed into <code>Codable</code>, but it’s outside the scope of this chapter. For now, let’s talk about another popular transport format: XML.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="XML" data-type="sect3"><div class="sect3" id="idm46177218132792">&#13;
<h3>XML</h3>&#13;
&#13;
<p>XML<a data-primary="XML serialization" data-type="indexterm" id="xmlserial12"/> is a format older than JSON. There are various standards of XML, including some very specific transport types like the<a data-primary="Simple Object Access Protocol (SOAP)" data-type="indexterm" id="idm46177217936616"/> Simple Object Access Protocol (SOAP), but for the purposes of our example, we’re going to use a slightly modified version of the JSON we used previously to keep things simple. Let’s start with this XML:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>&#13;
<code class="nt">&lt;author</code> <code class="na">type=</code><code class="s">"human"</code><code class="nt">&gt;</code>&#13;
	<code class="nt">&lt;name&gt;</code>Mike<code class="nt">&lt;/name&gt;</code>&#13;
<code class="nt">&lt;/author&gt;</code></pre>&#13;
&#13;
<p>This XML describes an author with the name of “Mike” that happens to be human (and an author of this book, coincidentally).</p>&#13;
&#13;
<p>If you’re expecting the same simplicity as <code>Codable</code> offers with <code>JSONEncoder</code> and <code>JSONDecoder</code>, I’m afraid I have some bad news: <code>XMLParser</code> in iOS is much more verbose.</p>&#13;
&#13;
<p>Let’s start with the same XML and create an object that starts parsing:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeObject</code><code class="p">:</code> <code class="bp">NSObject</code> <code class="p">{</code>&#13;
    <code class="kd">func</code> <code class="nf">parseSomeXML</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kd">let</code> <code class="nv">xml</code> <code class="p">=</code> <code class="s">"&lt;?xml version=</code><code class="se">\"</code><code class="s">1.0</code><code class="se">\"</code><code class="s"> encoding=</code><code class="se">\"</code><code class="s">UTF-8</code><code class="se">\"</code><code class="s">?&gt;</code>&#13;
<code class="s">            &lt;author type=</code><code class="se">\"</code><code class="s">human</code><code class="se">\"</code><code class="s">&gt;&lt;name&gt;Mike&lt;/name&gt;&lt;/author&gt;"</code>&#13;
        <code class="kd">let</code> <code class="nv">rawData</code> <code class="p">=</code> <code class="n">xml</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="n">using</code><code class="p">:</code> <code class="p">.</code><code class="n">utf8</code><code class="p">)</code><code class="o">!</code>&#13;
&#13;
        <code class="kd">let</code> <code class="nv">parser</code> <code class="p">=</code> <code class="n">XMLParser</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">rawData</code><code class="p">)</code>&#13;
        <code class="n">parser</code><code class="p">.</code><code class="n">delegate</code> <code class="p">=</code> <code class="kc">self</code><code class="p">;</code>&#13;
        <code class="n">parser</code><code class="p">.</code><code class="n">parse</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We have an <code>NSObject</code> named <code>SomeObject</code> that has a method called <code>parseSomeXml</code> that we’ve created. This method has a string variable named <code>xml</code> that contains our XML from earlier encoded. In the next line, we convert it to a <code>Data</code> object with UTF-8 encoding. Next, we instantiate an <code>XMLParser</code> with the <code>rawData</code> object. Then, we set ourselves as the delegate to handle the parsing. Finally, we call <code>parse()</code> to start <span class="keep-together">parsing</span>.</p>&#13;
&#13;
<p>If you attempted to run this code right now, you’d have an error because <code>SomeObject</code> currently doesn’t implement the <code>XMLParserDelegate</code> protocol it’s supposed to implement to properly handle the parse operating. This is the core of what drives parsing, so let’s look at each protocol method we’re implementing in depth to understand what’s going on.</p>&#13;
&#13;
<p>XML parsing is synchronous. The document is scanned and walked through element by element. There are four methods we’re going to use in our XML parsing delegate. They are:</p>&#13;
<ol>&#13;
<li>&#13;
<p><code>parser(_:didStartElement:namespaceURI:qualifiedName:attributes:)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>parser(_:foundCharacters:)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>parser(_:didEndElement:namespaceURI:qualifiedName:)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>parserDidEndDocument(_:)</code></p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Let’s take a look at the first method in this list:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">parser</code><code class="p">(</code><code class="kc">_</code> <code class="n">parser</code><code class="p">:</code> <code class="n">XMLParser</code><code class="p">,</code> <code class="n">didStartElement</code> <code class="n">elementName</code><code class="p">:</code> <code class="nb">String</code><code class="p">,</code> <code class="n">namespaceURI</code><code class="p">:</code> <code class="nb">String</code><code class="p">?,</code>&#13;
  <code class="n">qualifiedName</code> <code class="n">qName</code><code class="p">:</code> <code class="nb">String</code><code class="p">?,</code> <code class="n">attributes</code> <code class="n">attributeDict</code><code class="p">:</code> <code class="p">[</code><code class="nb">String</code> <code class="p">:</code> <code class="nb">String</code><code class="p">]</code> <code class="p">=</code> <code class="p">[:])</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="n">elementName</code> <code class="p">==</code> <code class="s">"author"</code> <code class="p">{</code>&#13;
        <code class="n">author</code> <code class="p">=</code> <code class="n">Author</code><code class="p">()</code>&#13;
        <code class="k">if</code> <code class="kd">let</code> <code class="nv">type</code> <code class="p">=</code> <code class="n">attributeDict</code><code class="p">[</code><code class="s">"type"</code><code class="p">]</code> <code class="p">{</code>&#13;
            <code class="n">author</code><code class="p">?.</code><code class="n">type</code> <code class="p">=</code> <code class="n">type</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This method is called every time a new XML element is found in the document as we walk through it. In our preceding example XML, the only valid elements are <code>author</code> and <code>name</code>. If we find a new <code>author</code> element, we create a new <code>Author</code> instance in a new property that’s been added to the <code>SomeObject</code> class called <code>author</code>. This acts as something of a temporary place to store the <code>Author</code> instance as we build it out with data we find during parsing this element.</p>&#13;
&#13;
<p>The first piece of data discovered is the attribute <code>type</code>. If you recall, our authors have a type and in our particular XML element this is <code>human</code> for the <code>Mike</code> author. We set the <code>type</code> property on our temporary <code>Author</code> instance to this value.</p>&#13;
&#13;
<p>As the document parses, the next element we will find will be <code>name</code>. We don’t need to do anything special once that element is started, but we do need to capture the data between the <code>&lt;name&gt;</code> and <code>&lt;/name&gt;</code> tags. The next method in our list, <code>parser(_:foundCharacters:)</code>, allows us to do that like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">parser</code><code class="p">(</code><code class="kc">_</code> <code class="n">parser</code><code class="p">:</code> <code class="n">XMLParser</code><code class="p">,</code> <code class="n">foundCharacters</code> <code class="n">string</code><code class="p">:</code> <code class="nb">String</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">characters</code> <code class="o">+=</code> <code class="n">string</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Inside the body of this method, we’re storing any found characters inside another new property added to our <code>SomeObject</code> instance called <code>characters</code>. This property acts as a temporary buffer of sorts to keep the characters around for the next step in the process, which occurs whenever we find the closing element for this tag:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">parser</code><code class="p">(</code><code class="kc">_</code> <code class="n">parser</code><code class="p">:</code> <code class="n">XMLParser</code><code class="p">,</code> <code class="n">didEndElement</code> <code class="n">elementName</code><code class="p">:</code> <code class="nb">String</code><code class="p">,</code> <code class="n">namespaceURI</code><code class="p">:</code> <code class="nb">String</code><code class="p">?,</code>&#13;
  <code class="n">qualifiedName</code> <code class="n">qName</code><code class="p">:</code> <code class="nb">String</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="n">elementName</code> <code class="p">==</code> <code class="s">"name"</code> <code class="p">{</code>&#13;
        <code class="n">author</code><code class="p">?.</code><code class="n">name</code> <code class="p">=</code> <code class="n">characters</code>&#13;
    <code class="p">}</code>&#13;
    <code class="n">characters</code> <code class="p">=</code> <code class="s">""</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This delegate method is called whenever the parser finds a closing tag for an element. In our case, this is <code>&lt;/name&gt;</code>. We take the string buffer we had, <code>characters</code>, and add it to the <code>name</code> property on our <code>author</code> object that we’re building.</p>&#13;
&#13;
<p>Last, we take what we’ve created and display it as a <code>print()</code> statement at the end of the XML document:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">parserDidEndDocument</code><code class="p">(</code><code class="kc">_</code> <code class="n">parser</code><code class="p">:</code> <code class="n">XMLParser</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="bp">print</code><code class="p">(</code><code class="n">author</code><code class="p">.</code><code class="n">name</code><code class="p">)</code>&#13;
    <code class="bp">print</code><code class="p">(</code><code class="n">author</code><code class="p">.</code><code class="n">type</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If we had more items in the XML document, we’d continue building out more and more author instances, and we’d need to save them whenever a new element is started and a temporary object is created.</p>&#13;
</div>&#13;
&#13;
<p>Here’s the example in its entirety:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">struct</code> <code class="nc">Author</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">name</code><code class="p">:</code> <code class="nb">String</code><code class="p">?</code>&#13;
    <code class="kd">var</code> <code class="nv">type</code><code class="p">:</code> <code class="nb">String</code><code class="p">?</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">SomeObject</code><code class="p">:</code> <code class="bp">NSObject</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">author</code><code class="p">:</code> <code class="n">Author</code><code class="p">?</code>&#13;
    <code class="kd">var</code> <code class="nv">characters</code><code class="p">:</code> <code class="nb">String</code> <code class="p">=</code> <code class="s">""</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">parseSomeXML</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kd">let</code> <code class="nv">xml</code> <code class="p">=</code> <code class="s">"&lt;?xml version=</code><code class="se">\"</code><code class="s">1.0</code><code class="se">\"</code><code class="s"> encoding=</code><code class="se">\"</code><code class="s">UTF-8</code><code class="se">\"</code><code class="s">?&gt;</code>&#13;
<code class="s">            &lt;author type=</code><code class="se">\"</code><code class="s">human</code><code class="se">\"</code><code class="s">&gt;&lt;name&gt;Mike&lt;/name&gt;&lt;/author&gt;"</code>&#13;
        <code class="kd">let</code> <code class="nv">rawData</code> <code class="p">=</code> <code class="n">xml</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="n">using</code><code class="p">:</code> <code class="p">.</code><code class="n">utf8</code><code class="p">)</code><code class="o">!</code>&#13;
&#13;
        <code class="kd">let</code> <code class="nv">parser</code> <code class="p">=</code> <code class="n">XMLParser</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">rawData</code><code class="p">)</code>&#13;
        <code class="n">parser</code><code class="p">.</code><code class="n">delegate</code> <code class="p">=</code> <code class="kc">self</code><code class="p">;</code>&#13;
        <code class="n">parser</code><code class="p">.</code><code class="n">parse</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
<code class="kd">extension</code> <code class="nc">SomeObject</code><code class="p">:</code> <code class="n">XMLParserDelegate</code> <code class="p">{</code>&#13;
    <code class="kd">func</code> <code class="nf">parser</code><code class="p">(</code><code class="kc">_</code> <code class="n">parser</code><code class="p">:</code> <code class="n">XMLParser</code><code class="p">,</code> <code class="n">didStartElement</code> <code class="n">elementName</code><code class="p">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="n">namespaceURI</code><code class="p">:</code> <code class="nb">String</code><code class="p">?,</code> <code class="n">qualifiedName</code> <code class="n">qName</code><code class="p">:</code> <code class="nb">String</code><code class="p">?,</code> <code class="n">attributes</code> <code class="n">attributeDict</code><code class="p">:</code>&#13;
      <code class="p">[</code><code class="nb">String</code> <code class="p">:</code> <code class="nb">String</code><code class="p">]</code> <code class="p">=</code> <code class="p">[:])</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="n">elementName</code> <code class="p">==</code> <code class="s">"author"</code> <code class="p">{</code>&#13;
            <code class="n">author</code> <code class="p">=</code> <code class="n">Author</code><code class="p">()</code>&#13;
            <code class="k">if</code> <code class="kd">let</code> <code class="nv">type</code> <code class="p">=</code> <code class="n">attributeDict</code><code class="p">[</code><code class="s">"type"</code><code class="p">]</code> <code class="p">{</code>&#13;
                <code class="n">author</code><code class="p">?.</code><code class="n">type</code> <code class="p">=</code> <code class="n">type</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">parser</code><code class="p">(</code><code class="kc">_</code> <code class="n">parser</code><code class="p">:</code> <code class="n">XMLParser</code><code class="p">,</code> <code class="n">foundCharacters</code> <code class="n">string</code><code class="p">:</code> <code class="nb">String</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">characters</code> <code class="o">+=</code> <code class="n">string</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">parser</code><code class="p">(</code><code class="kc">_</code> <code class="n">parser</code><code class="p">:</code> <code class="n">XMLParser</code><code class="p">,</code> <code class="n">didEndElement</code> <code class="n">elementName</code><code class="p">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="n">namespaceURI</code><code class="p">:</code> <code class="nb">String</code><code class="p">?,</code>&#13;
      <code class="n">qualifiedName</code> <code class="n">qName</code><code class="p">:</code> <code class="nb">String</code><code class="p">?)</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="n">elementName</code> <code class="p">==</code> <code class="s">"name"</code> <code class="p">{</code>&#13;
            <code class="n">author</code><code class="p">?.</code><code class="n">name</code> <code class="p">=</code> <code class="n">characters</code>&#13;
        <code class="p">}</code>&#13;
        <code class="n">characters</code> <code class="p">=</code> <code class="s">""</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">parserDidEndDocument</code><code class="p">(</code><code class="kc">_</code> <code class="n">parser</code><code class="p">:</code> <code class="n">XMLParser</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="n">author</code><code class="p">?.</code><code class="n">name</code><code class="p">)</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="n">author</code><code class="p">?.</code><code class="n">type</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’ve had a good look at straight XML, but what about something XML based that’s a little bit less verbose?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Property lists" data-type="sect3"><div class="sect3" id="idm46177217938984">&#13;
<h3>Property lists</h3>&#13;
&#13;
<p>Property lists, or<a data-primary="property lists (plist files)" data-type="indexterm" id="idm46177217421064"/> plist files, are an XML-based format that have traditionally been used for serializing and deserializing data in apps. Let’s take a look at how to read a plist file from the filesystem:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="c1">// Our .plist file on the filesystem</code>&#13;
<code class="kd">let</code> <code class="nv">plistURL</code> <code class="p">=</code> <code class="nb">URL</code><code class="p">(...)</code><code class="o">!</code>&#13;
<code class="k">guard</code> <code class="kd">let</code> <code class="nv">plistData</code> <code class="p">=</code> <code class="n">Data</code><code class="p">(</code><code class="n">contentsOf</code><code class="p">:</code> <code class="n">plistURL</code><code class="p">)</code> <code class="k">else</code> <code class="p">{</code> <code class="k">return</code> <code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">object</code> <code class="p">=</code> <code class="n">PropertyListDecoder</code><code class="p">().</code><code class="n">decode</code><code class="p">(</code><code class="n">Author</code><code class="p">.</code><code class="kc">self</code><code class="p">,</code> <code class="n">from</code><code class="p">:</code> <code class="n">plistData</code><code class="p">)</code></pre>&#13;
&#13;
<p>This looks pretty similar to our JSON decoding example. Notice the use of <code>PropertyListDecoder</code>, which is functionally similar to <code>JSONDecoder</code> except it handles plist data instead of JSON data.</p>&#13;
&#13;
<p>Writing to a plist file is similar to the JSON example as well:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">author</code> <code class="p">=</code> <code class="n">Author</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"Mike"</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nv">data</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">PropertyListEncoder</code><code class="p">().</code><code class="n">encode</code><code class="p">(</code><code class="n">author</code><code class="p">)</code>&#13;
<code class="n">data</code><code class="p">?.</code><code class="n">write</code><code class="p">(</code><code class="n">to</code><code class="p">:</code> <code class="p">...)</code> <code class="c1">// save the plist file to the device</code></pre>&#13;
&#13;
<p>This will output a plist file as XML. There are additional options available for exporting property list files, however. In fact, there are three common types you can export to: XML, binary, or Open Step.</p>&#13;
&#13;
<p>Here’s<a data-primary="" data-startref="IOSserial12" data-type="indexterm" id="idm46177217058008"/><a data-primary="" data-startref="SATiosserial1" data-type="indexterm" id="idm46177217057128"/><a data-primary="" data-startref="xmlserial12" data-type="indexterm" id="idm46177217056184"/> an example of how to export to a binary plist file:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">author</code> <code class="p">=</code> <code class="n">Author</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"Mike"</code><code class="p">)</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">encoder</code> <code class="p">=</code> <code class="n">PropertyListEncoder</code><code class="p">()</code>&#13;
<code class="n">encoder</code><code class="p">.</code><code class="n">outputFormat</code> <code class="p">=</code> <code class="p">.</code><code class="n">binary</code> <code class="c1">// set the output type to binary data</code>&#13;
<code class="kd">let</code> <code class="nv">data</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">encoder</code><code class="p">.</code><code class="n">encode</code><code class="p">(</code><code class="n">author</code><code class="p">)</code>&#13;
&#13;
<code class="n">data</code><code class="p">?.</code><code class="n">write</code><code class="p">(</code><code class="n">to</code><code class="p">:</code> <code class="p">...)</code> <code class="c1">// save the plist file to the device</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS Notes" data-type="sect2"><div class="sect2" id="idm46177217095224">&#13;
<h2>iOS Notes</h2>&#13;
&#13;
<p>Although<a data-primary="Codable protocol" data-type="indexterm" id="idm46177216990168"/> <code>Codable</code> appears to be magic, there are some very interesting things happening at the compiler level that do have the option to be overwritten. For example, to use a different property name for JSON other than what’s declared in the Swift-defined structure of <code>Author</code>, the following code could work:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">struct</code> <code class="nc">Author</code><code class="p">:</code> <code class="n">Codable</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nv">name</code><code class="p">:</code> <code class="nb">String</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kd">enum</code> <code class="nc">CodingKeys</code><code class="p">:</code> <code class="nb">String</code><code class="p">,</code> <code class="n">CodingKey</code> <code class="p">{</code>&#13;
        <code class="k">case</code> <code class="n">name</code> <code class="p">=</code> <code class="s">"something"</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">author</code> <code class="p">=</code> <code class="n">Author</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"Mike"</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nv">rawData</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">JSONEncoder</code><code class="p">().</code><code class="n">encode</code><code class="p">(</code><code class="n">author</code><code class="p">)</code></pre>&#13;
&#13;
<p>This example changes the <code>name</code> property in the JSON output to <code>something</code>. Running this code would output JSON like the following:</p>&#13;
&#13;
<pre data-type="programlisting">{ "something" : "Mike" }</pre>&#13;
&#13;
<p>In addition, it’s possible to provide your own separate implementations of the <span class="keep-together"><code>Encodable</code></span> and <code>Decodable</code> methods <code>encode(to:)</code> and <code>init(from:)</code> for completely manual serialization and deserialization.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177216922440">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>Android and iOS have remarkably similar approaches to serializing and deserializing data like XML and JSON. There is also a similar path to take a Java, Kotlin, or Swift object and serialize it out to a native platform format. Despite the differences in the language and frameworks, this is an area where both platforms make it a bit easier to jump back and forth.</p>&#13;
&#13;
<p>In the next chapter, we’ll explain a bit about extending the base framework objects (and other objects) to add a bit of functionality. Let’s have a look!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>