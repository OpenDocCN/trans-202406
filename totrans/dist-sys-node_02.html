<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Why Distributed?" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_introduction">&#13;
<h1><span class="label">Chapter 1. </span>Why Distributed?</h1>&#13;
&#13;
&#13;
<p>Node.js is a self-contained runtime for running JavaScript code on the server. It provides a JavaScript language engine and dozens of APIs, many of which allow application code to interact with the underlying operating system and the world outside of it. But you probably already knew that.</p>&#13;
&#13;
<p>This chapter takes a high-level look at Node.js, in particular how it relates to this book. It looks at the single-threaded nature of JavaScript, simultaneously one of its greatest strengths and greatest weaknesses, and part of the reason why it’s so important to run Node.js in a distributed manner.</p>&#13;
&#13;
<p>It also contains a small pair of sample applications that are used as a baseline, only to be upgraded numerous times throughout the book. The first iteration of these applications is likely simpler than anything you’ve previously shipped to production.</p>&#13;
&#13;
<p>If you find that you already know the information in these first few sections, then feel free to skip directly to <a data-type="xref" href="#ch_introduction_sec_sample">“Sample Applications”</a>.</p>&#13;
&#13;
<p>The JavaScript language is <a data-primary="JavaScript" data-secondary="multithreading" data-type="indexterm" id="idm46291210697064"/><a data-primary="multithreading" data-type="indexterm" id="idm46291210696088"/>transitioning from being a single-threaded language to being a multithreaded language. The <a class="orm:hideurl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics"><code>Atomics</code></a> object, for example, provides mechanisms to coordinate communication across different threads, while instances of <a class="orm:hideurl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a> can be written to and read from across threads. That said, as of this writing, multithreaded JavaScript still hasn’t caught on within the community. &#13;
<span class="keep-together">JavaScript</span> today <em>is</em> multithreaded, but it’s still the nature of the language, and of the &#13;
<span class="keep-together">ecosystem,</span> to be single-threaded.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Single-Threaded Nature of JavaScript" data-type="sect1"><div class="sect1" id="ch_introduction_sec_js_overview">&#13;
<h1>The Single-Threaded Nature of JavaScript</h1>&#13;
&#13;
<p>JavaScript, like most programming <a data-primary="JavaScript" data-secondary="single-threading" data-type="indexterm" id="idm46291210688152"/><a data-primary="single-threading" data-type="indexterm" id="idm46291210687176"/>languages, makes heavy use of <em>functions</em>. Functions <a data-primary="functions" data-type="indexterm" id="idm46291210685992"/>are a way to combine units of related work. Functions can call other functions as well. Each time one function calls another function, it adds frames to <a data-primary="call stack" data-type="indexterm" id="idm46291210684952"/><a data-primary="functions" data-secondary="call stack and" data-type="indexterm" id="idm46291210684280"/>the <em>call stack</em>, which is a fancy way of saying the stack of currently run functions is getting taller. When you accidentally write a recursive <a data-primary="functions" data-secondary="recursive" data-type="indexterm" id="idm46291210682648"/><a data-primary="recursive functions" data-type="indexterm" id="idm46291210681672"/>function that would otherwise run forever, you’re usually greeted with a <em>RangeError: Maximum call stack size exceeded</em> error. When this happens you’ve reached the maximum limit of frames in the <a data-primary="call stack" data-secondary="frame limit" data-type="indexterm" id="idm46291210680488"/>call stack.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The maximum call stack size is <a data-primary="call stack" data-secondary="maximum" data-type="indexterm" id="idm46291210678536"/><a data-primary="JavaScript" data-secondary="call stack maximum" data-type="indexterm" id="idm46291210677560"/>usually inconsequential and is chosen by the JavaScript engine. The V8 JavaScript engine used by Node.js v14 has a maximum call stack size of more than 15,000 frames.</p>&#13;
</div>&#13;
&#13;
<p>However, JavaScript is different from some other languages in that it does not constrain itself to running within a single call stack throughout the lifetime of a JavaScript application. For example, when I wrote PHP several years ago, the entire lifetime of a PHP script (a lifetime ties directly to the time it takes to serve an HTTP request) correlated to a single stack, growing and shrinking and then disappearing once the request was finished.</p>&#13;
&#13;
<p>JavaScript handles <em>concurrency</em>—performing <a data-primary="concurrency, event loops and" data-type="indexterm" id="idm46291210674472"/><a data-primary="event loops" data-type="indexterm" id="eventloops"/><a data-primary="loops" data-see="event loops" data-type="indexterm" id="idm46291210672728"/>multiple things at the same time—by way of an event loop. The event loop used by Node.js is covered more in <a data-type="xref" href="#ch_introduction_sec_eventloop">“The Node.js Event Loop”</a>, but for now just think of it as an infinitely running loop that continuously checks to see if there is work to perform. When it finds something to do, it begins its task—in this case it executes a function with a new call stack—and once the function is complete, it waits until more work is ready to be performed.</p>&#13;
&#13;
<p>The code sample in <a data-type="xref" href="#ex_js_stacks">Example 1-1</a> is an example of this happening. First, it runs the <code>a()</code> function in the current stack. It also <a data-primary="setTimeout() function" data-type="indexterm" id="idm46291210668520"/><a data-primary="functions" data-secondary="setTimeout()" data-type="indexterm" id="idm46291210667816"/>calls the <code>setTimeout()</code> function that will queue up the <code>x()</code> function. Once the current stack completes, the event loop checks for more work to do. The event loop  gets to check for more work to do <em>only</em> once a stack is complete. It isn’t, for example, checking after every instruction. Since there’s not a lot going on in this simple program, the <code>x()</code> function will be the next thing that gets run after the first stack completes.</p>&#13;
<div data-type="example" id="ex_js_stacks">&#13;
<h5><span class="label">Example 1-1. </span>Example of multiple JavaScript stacks</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">a</code><code class="p">()</code> <code class="p">{</code> <code class="nx">b</code><code class="p">();</code> <code class="p">}</code>&#13;
<code class="kd">function</code> <code class="nx">b</code><code class="p">()</code> <code class="p">{</code> <code class="nx">c</code><code class="p">();</code> <code class="p">}</code>&#13;
<code class="kd">function</code> <code class="nx">c</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/**/</code> <code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">x</code><code class="p">()</code> <code class="p">{</code> <code class="nx">y</code><code class="p">();</code> <code class="p">}</code>&#13;
<code class="kd">function</code> <code class="nx">y</code><code class="p">()</code> <code class="p">{</code> <code class="nx">z</code><code class="p">();</code> <code class="p">}</code>&#13;
<code class="kd">function</code> <code class="nx">z</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/**/</code> <code class="p">}</code>&#13;
&#13;
<code class="nx">setTimeout</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>&#13;
<code class="nx">a</code><code class="p">();</code></pre></div>&#13;
&#13;
<p><a data-type="xref" href="#fig_stacks">Figure 1-1</a> is a visualization of the preceding code sample. Notice how there are two separate <a data-primary="stacks, functions and" data-type="indexterm" id="idm46291210146536"/><a data-primary="functions" data-secondary="stacks and" data-type="indexterm" id="idm46291210145928"/>stacks and that each stack increases in depth as more functions are called. The horizontal axis represents time; code within each function naturally takes time to execute.</p>&#13;
&#13;
<figure><div class="figure" id="fig_stacks">&#13;
<img alt="Two separate stacks, each three frames deep" src="assets/dsnj_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>Visualization of multiple JavaScript stacks</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>setTimeout()</code> function <a data-primary="setTimeout() function" data-type="indexterm" id="idm46291210141704"/><a data-primary="functions" data-secondary="setTimeout()" data-type="indexterm" id="idm46291210140968"/>is essentially saying, “Try to run the provided function 0ms from now.” However, the <code>x()</code> function doesn’t run <em>immediately</em>, as the <code>a()</code> call stack is still in progress. It doesn’t even run immediately after the <code>a()</code> call stack is complete, either. The event loop takes a nonzero amount of time to check for more work to perform. It also takes time to prepare the new call stack. So, even though <code>x()</code> was scheduled to run in 0ms, in practice it may take a few milliseconds before the code runs, a discrepancy that increases as application load increases.</p>&#13;
&#13;
<p>Another thing to keep in mind is that functions can take a long time to run. If the <code>a()</code> function took 100ms to run, then the earliest you should expect <code>x()</code> to run might be 101ms. Because of this, think of the time argument as the earliest time the function can be called. A function <a data-primary="event loops" data-secondary="blocking" data-type="indexterm" id="idm46291210135848"/><a data-primary="blocking event loops" data-type="indexterm" id="idm46291210134872"/>that takes a long time to run is said to <em>block the event loop</em>—since the application is stuck processing slow synchronous code, the event loop is temporarily unable to process further <a data-primary="event loops" data-startref="eventloops" data-type="indexterm" id="idm46291210133480"/>tasks.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46291210132376">&#13;
<h5>Surprise Interview Question</h5>&#13;
<p>This is a question that I’ve asked a few times while interviewing candidates for advanced JavaScript roles: If the code in <a data-type="xref" href="#ex_interview_question">Example 1-2</a> were executed, in what order would you expect the messages to be printed to the screen? And, as a bonus, how much time would you expect to pass before each message is printed?</p>&#13;
<div data-type="example" id="ex_interview_question">&#13;
<h5><span class="label">Example 1-2. </span>JavaScript timing question</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'A'</code><code class="p">),</code> <code class="mi">0</code><code class="p">);</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'B'</code><code class="p">);</code>&#13;
<code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'C'</code><code class="p">),</code> <code class="mi">100</code><code class="p">);</code>&#13;
<code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'D'</code><code class="p">),</code> <code class="mi">0</code><code class="p">);</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">1</code><code class="nx">_000_000_000</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// Assume this takes ~500ms</code>&#13;
  <code class="kd">let</code> <code class="nx">ignore</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>&#13;
  <code class="nx">i</code><code class="o">++</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'E'</code><code class="p">);</code></pre></div>&#13;
&#13;
<p>Write down the order that you think the messages will be printed in, as well as how long it takes each message to print since the start of the script. The answer and a detailed explanation is provided at the end of this section in <a data-type="xref" href="#table_interview_order">Table 1-1</a>.</p>&#13;
</div></aside>&#13;
&#13;
<p>Now that call stacks are out of the way, it’s time for the interesting part of this section.</p>&#13;
&#13;
<p>Since JavaScript applications <a data-primary="call stack" data-secondary="multiple, simultaneous" data-type="indexterm" id="idm46291209448600"/><a data-primary="functions" data-secondary="parallel" data-type="indexterm" id="idm46291209447656"/>are mostly run in a single-threaded manner, two call stacks won’t exist at the same time, which is another way of saying that two functions cannot run in parallel.<sup><a data-type="noteref" href="ch01.html#idm46291209446408" id="idm46291209446408-marker">1</a></sup> This implies that multiple copies of an application need to be run simultaneously by some means to allow the application to scale.</p>&#13;
&#13;
<p>Several tools are available to make it easier <a data-primary="applications" data-secondary="multiple copies" data-type="indexterm" id="idm46291209445224"/>to manage multiple copies of an application. <a data-type="xref" href="ch03.html#ch_scaling_sec_clustering">“The Cluster Module”</a> looks <a data-primary="cluster module" data-type="indexterm" id="idm46291209442904"/><a data-primary="modules" data-secondary="cluster" data-type="indexterm" id="idm46291209442200"/>at using the built-in <code>cluster</code> module for routing incoming HTTP requests to different application instances. The <a data-primary="worker_threads module" data-type="indexterm" id="idm46291209440712"/><a data-primary="modules" data-secondary="worker_threads" data-type="indexterm" id="idm46291209440008"/>built-in <code>worker_threads</code> module also helps run multiple JavaScript instances at once. The <code>child_process</code> module <a data-primary="child_process module" data-type="indexterm" id="idm46291209438104"/><a data-primary="modules" data-secondary="child_process" data-type="indexterm" id="idm46291209437368"/>can be used to spawn and manage a full Node.js process &#13;
<span class="keep-together">as well.</span></p>&#13;
&#13;
<p>However, with each of these approaches, JavaScript <em>still</em> can run only a single line of JavaScript at a time within an application. This means that with each solution, each JavaScript environment still has its own distinct global variables, and no object references can be shared between them.</p>&#13;
&#13;
<p>Since objects <a data-primary="message passing" data-type="indexterm" id="idm46291209434264"/>cannot be directly shared with the three aforementioned approaches, some other method for communicating between the different isolated JavaScript contexts is needed. Such a feature does exist and is called <em>message passing</em>. Message passing works by sharing some sort of serialized representation of an object/data (such as JSON) between the separate isolates. This is necessary because directly sharing objects is impossible, not to mention that it would be a painful debugging experience if two separate isolates could modify the same object at the same time. These types of issues are <a data-primary="deadlocks" data-type="indexterm" id="idm46291209432408"/><a data-primary="race conditions" data-type="indexterm" id="idm46291209431704"/>referred to as <em>deadlocks</em> and <em>race conditions</em>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>By using <code>worker_threads</code> it is <a data-primary="worker_threads module" data-secondary="memory sharing" data-type="indexterm" id="idm46291209428456"/><a data-primary="memory" data-secondary="sharing, worker_threads module" data-type="indexterm" id="idm46291209427448"/><a data-primary="sharing memory, worker_threads module" data-type="indexterm" id="idm46291209426536"/>possible to share memory between two different JavaScript instances. This can be done by creating an instance of <code>SharedArrayBuffer</code> and <a data-primary="SharedArrayBuffer" data-type="indexterm" id="idm46291209425208"/><a data-primary="postMessage(  ) method" data-type="indexterm" id="idm46291209424472"/><a data-primary="methods" data-secondary="postMessage(  )" data-type="indexterm" id="idm46291209423800"/>passing it from one thread to another using the same <code>postMessage(value)</code> method used for worker thread message passing. This results in an array of bytes that both threads can read and write to at the same time.</p>&#13;
</div>&#13;
&#13;
<p>Overhead is incurred with message passing <a data-primary="serialization" data-type="indexterm" id="idm46291209421640"/>when data is serialized and deserialized. Such overhead doesn’t need to exist in languages that support proper multithreading, as objects can be shared directly.</p>&#13;
&#13;
<p>This is one of the biggest factors that necessitates running Node.js applications in a distributed manner. In order to handle scale, enough instances need to run so that any single instance of a Node.js process doesn’t completely saturate its available CPU.</p>&#13;
&#13;
<p>Now that you’ve looked at JavaScript—the language that powers Node.js—it’s time to look at Node.js itself.</p>&#13;
&#13;
<p>The solution to the surprise interview question is provided in <a data-type="xref" href="#table_interview_order">Table 1-1</a>. The most important part is the order that the messages print, and the bonus is the time it takes them to print. Consider your bonus answer correct if you’re within a few milliseconds of the timing.</p>&#13;
<table id="table_interview_order">&#13;
<caption><span class="label">Table 1-1. </span>Surprise interview solution</caption>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Log</p></td>&#13;
<td><p>B</p></td>&#13;
<td><p>E</p></td>&#13;
<td><p>A</p></td>&#13;
<td><p>D</p></td>&#13;
<td><p>C</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Time</p></td>&#13;
<td><p>1ms</p></td>&#13;
<td><p>501ms</p></td>&#13;
<td><p>502ms</p></td>&#13;
<td><p>502ms</p></td>&#13;
<td><p>502ms</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The first thing that <a data-primary="surprise interview solution" data-type="indexterm" id="idm46291209407992"/>happens is the function to log A is scheduled with a timeout of 0ms. Recall that this doesn’t mean the function will run in 0ms; instead it is scheduled to run as early as 0 milliseconds but after the current stack ends. Next, the log B method is called directly, so it’s the first to print. Then, the log C function is scheduled to run as early as 100ms, and the log D is scheduled to happen as early as 0ms.</p>&#13;
&#13;
<p>Then the application gets busy doing calculations with the while loop, which eats up half a second of CPU time. Once the loop concludes, the final call for log E is made directly and it is now the second to print. The current stack is now complete. At this point, only a single stack has executed.</p>&#13;
&#13;
<p>Once that’s done, the event loop looks for more work to do. It checks the queue and sees that there are three tasks scheduled to happen. The order of items in the queue is based on the provided timer value and the order that the <code>setTimeout()</code> calls were made. So, it first processes the log A function. At this point the script has been running for roughly half a second, and it sees that log A is roughly 500ms overdue, and so that function is executed. The next item in the queue is the log D function, which is also roughly 500ms overdue. Finally, the log C function is run and is roughly 400ms overdue.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Quick Node.js Overview" data-type="sect1"><div class="sect1" id="ch_introduction_sec_node_overview">&#13;
<h1>Quick Node.js Overview</h1>&#13;
&#13;
<p>Node.js fully embraces <a data-primary="CPS (Continuous-Passing Style)" data-type="indexterm" id="idm46291209402328"/>the Continuation-Passing Style (CPS) pattern throughout its internal modules by way of <em>callbacks</em>—functions <a data-primary="functions" data-secondary="callbacks" data-type="indexterm" id="idm46291209401112"/><a data-primary="callbacks" data-type="indexterm" id="idm46291209400104"/><a data-primary="event loops" data-secondary="callbacks" data-type="indexterm" id="idm46291209399432"/>that are passed around and invoked by the event loop once a task is complete. In Node.js parlance, functions that are invoked in the future with a new stack are said to <a data-primary="functions" data-secondary="asynchronous" data-type="indexterm" id="idm46291209398168"/><a data-primary="asynchronous functions" data-type="indexterm" id="idm46291209397224"/><a data-primary="functions" data-secondary="synchronous" data-type="indexterm" id="idm46291209396552"/><a data-primary="synchronous functions" data-type="indexterm" id="idm46291209395608"/>be run <em>asynchronously</em>. Conversely, when one function calls another function in the same stack, that code is said to run <em>synchronously</em>.</p>&#13;
&#13;
<p>The types of tasks that <a data-primary="tasks" data-see="I/O tasks" data-type="indexterm" id="idm46291209393544"/><a data-primary="I/O tasks" data-type="indexterm" id="idm46291209392568"/>are long-running are typically I/O tasks. For example, imagine that your application wants to perform two tasks. Task A is to read a file from disk, and Task B is to send an HTTP request to a third-party service. If an operation depends on both of these tasks being performed—an operation such as responding to an incoming HTTP request—the application can perform the operations in parallel, as shown in <a data-type="xref" href="#fig_seq_par_io">Figure 1-2</a>. If they couldn’t be performed at the same time—if they had to be run sequentially—then the overall time it takes to respond to the incoming HTTP request would be longer.</p>&#13;
&#13;
<figure><div class="figure" id="fig_seq_par_io">&#13;
<img alt="Sequential vs Parallel I/O Diagram" src="assets/dsnj_0102.png"/>&#13;
<h6><span class="label">Figure 1-2. </span>Visualization of sequential versus parallel I/O</h6>&#13;
</div></figure>&#13;
&#13;
<p>At first this seems to <a data-primary="sequential I/O" data-type="indexterm" id="idm46291209387912"/><a data-primary="parallel I/O" data-type="indexterm" id="idm46291209387176"/><a data-primary="I/O tasks" data-secondary="sequential" data-type="indexterm" id="idm46291209386504"/><a data-primary="I/O tasks" data-secondary="parallel" data-type="indexterm" id="idm46291209385560"/>violate the single-threaded nature of JavaScript. How can a Node.js application <em>both</em> read data from disk <em>and</em> make an HTTP request at the same time if JavaScript is single-threaded?</p>&#13;
&#13;
<p>This is where things start <a data-primary="Node.js" data-secondary="binding layer" data-type="indexterm" id="idm46291209383016"/><a data-primary="C++" data-type="indexterm" id="idm46291209382040"/>to get interesting. Node.js itself <em>is</em> multithreaded. The lower levels of Node.js are written in C++. This includes third-party tools <a data-primary="libuv" data-type="indexterm" id="idm46291209380744"/>like <em>libuv</em>, which handles operating system abstractions and I/O, as well as V8 (the JavaScript engine) and other third-party modules. The layer above that, the Node.js binding layer, also contains a bit of C++. It’s only the highest layers of Node.js that are written in &#13;
<span class="keep-together">JavaScript,</span> such as <a data-primary="userland" data-type="indexterm" id="idm46291209378520"/>parts of the Node.js APIs that deal directly with objects provided by userland.<sup><a data-type="noteref" href="ch01.html#idm46291209353624" id="idm46291209353624-marker">2</a></sup> <a data-type="xref" href="#fig_node_layers">Figure 1-3</a> depicts the relationship between these different layers.</p>&#13;
&#13;
<figure><div class="figure" id="fig_node_layers">&#13;
<img alt="Node.js is a combination of C++ and JavaScript" src="assets/dsnj_0103.png"/>&#13;
<h6><span class="label">Figure 1-3. </span>The layers of Node.js</h6>&#13;
</div></figure>&#13;
&#13;
<p>Internally, libuv maintains a <a data-primary="thread pool, libuv" data-type="indexterm" id="idm46291209349496"/>thread pool for managing I/O operations, as well as CPU-heavy operations like <code>crypto</code> and <code>zlib</code>. This is a pool of finite size where I/O operations are allowed to happen. If the pool only contains four threads, then only four files can be read at the same time. Consider <a data-type="xref" href="#ex_libuv_threads">Example 1-3</a> where the application attempts to read a file, does some other work, and then deals with the file content. Although the JavaScript code within the application is able to run, a thread within the bowels of Node.js is busy reading the content of the file from disk into memory.</p>&#13;
<div data-type="example" id="ex_libuv_threads">&#13;
<h5><span class="label">Example 1-3. </span>Node.js threads</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c-Hashbang">#!/usr/bin/env node&#13;
</code><code>&#13;
</code><code class="kr">const</code><code> </code><code class="nx">fs</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="s1">'fs'</code><code class="p">)</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s1">'/etc/passwd'</code><code class="p">,</code><code> </code><a class="co" href="#callout_why_distributed__CO1-1" id="co_why_distributed__CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="p">(</code><code class="nx">err</code><code class="p">,</code><code> </code><code class="nx">data</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_why_distributed__CO1-4" id="co_why_distributed__CO1-2"><img alt="4" src="assets/4.png"/></a><code>&#13;
    </code><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code> </code><code class="k">throw</code><code> </code><code class="nx">err</code><code class="p">;</code><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="nx">setImmediate</code><code class="p">(</code><code> </code><a class="co" href="#callout_why_distributed__CO1-2" id="co_why_distributed__CO1-3"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_why_distributed__CO1-3" id="co_why_distributed__CO1-4"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'This runs while file is being read'</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_why_distributed__CO1-1" id="callout_why_distributed__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Node.js reads <code>/etc/passwd</code>. It’s scheduled by libuv.</p></dd>&#13;
<dt><a class="co" href="#co_why_distributed__CO1-3" id="callout_why_distributed__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Node.js runs a callback in a new stack. It’s scheduled by V8.</p></dd>&#13;
<dt><a class="co" href="#co_why_distributed__CO1-4" id="callout_why_distributed__CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Once the previous stack ends, a new stack is created and prints a message.</p></dd>&#13;
<dt><a class="co" href="#co_why_distributed__CO1-2" id="callout_why_distributed__CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Once the file is done reading, libuv passes the result to the V8 event loop.</p></dd>&#13;
</dl></div>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The libuv thread <a data-primary="thread pool, libuv" data-secondary="size" data-type="indexterm" id="idm46291209208424"/>pool size defaults to four, has a max of 1,024, and can be overridden by setting the <code>UV_THREADPOOL_SIZE=&lt;threads&gt;</code> environment variable. In practice it’s not that common to modify it and should only be done after benchmarking the effects in a perfect replication of production. An app running locally on a macOS laptop will behave very differently than one in a container on a Linux server.</p>&#13;
</div>&#13;
&#13;
<p>Internally, Node.js <a data-primary="I/O tasks" data-secondary="asynchronous" data-type="indexterm" id="idm46291209206216"/><a data-primary="asynchronous tasks" data-type="indexterm" id="idm46291209205208"/>maintains a list of asynchronous tasks that still need to be completed. This list is used to keep the process running. When a stack completes and the event loop looks for more work to do, if there are no more operations left to keep the process alive, it will exit. That is why a very simple application that does nothing asynchronous is able to exit when the stack ends. Here’s an example of such an &#13;
<span class="keep-together">application:</span></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Print, then exit'</code><code class="p">);</code></pre>&#13;
&#13;
<p>However, once an asynchronous task has been created, this is enough to keep a process alive, like in this example:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">setInterval</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Process will run forever'</code><code class="p">);</code>&#13;
<code class="p">},</code> <code class="mi">1</code><code class="nx">_000</code><code class="p">);</code></pre>&#13;
&#13;
<p>There are many Node.js API calls <a data-primary="API calls" data-type="indexterm" id="idm46291209182392"/>that result in the creation of objects that keep the process alive. As another example of this, when an HTTP server is created, it also keeps the process running forever. A process that closes immediately after an HTTP server is created wouldn’t be very useful.</p>&#13;
&#13;
<p>There is a common pattern in the Node.js APIs where such objects can be configured to no longer keep the process alive. Some of these are more obvious than others. For example, if a listening HTTP server port is closed, then the process may choose to end. Additionally, many of these <a data-primary="objects" data-secondary="unref() method" data-type="indexterm" id="idm46291209158232"/><a data-primary="objects" data-secondary="ref() method" data-type="indexterm" id="idm46291209157320"/><a data-primary="ref() method" data-type="indexterm" id="idm46291209156376"/><a data-primary="unref() method" data-type="indexterm" id="idm46291209155704"/><a data-primary="methods" data-secondary="unref()" data-type="indexterm" id="idm46291209155032"/><a data-primary="methods" data-secondary="ref()" data-type="indexterm" id="idm46291209154088"/>objects have a pair of methods attached to them, <code>.unref()</code> and <code>.ref()</code>. The former method is used to tell the object to no longer keep the process alive, whereas the latter does the opposite.&#13;
<a data-type="xref" href="#ex_ref_unref">Example 1-4</a> demonstrates this happening.</p>&#13;
<div data-type="example" id="ex_ref_unref">&#13;
<h5><span class="label">Example 1-4. </span>The common <code>.ref()</code> and <code>.unref()</code> methods</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code><code> </code><code class="nx">t1</code><code> </code><code class="o">=</code><code> </code><code class="nx">setTimeout</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code class="p">}</code><code class="p">,</code><code> </code><code class="mi">1</code><code class="nx">_000_000</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_why_distributed__CO2-1" id="co_why_distributed__CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="kr">const</code><code> </code><code class="nx">t2</code><code> </code><code class="o">=</code><code> </code><code class="nx">setTimeout</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code class="p">}</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="nx">_000_000</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_why_distributed__CO2-2" id="co_why_distributed__CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="c1">// ...&#13;
</code><code class="nx">t1</code><code class="p">.</code><code class="nx">unref</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_why_distributed__CO2-3" id="co_why_distributed__CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="c1">// ...&#13;
</code><code class="nx">clearTimeout</code><code class="p">(</code><code class="nx">t2</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_why_distributed__CO2-4" id="co_why_distributed__CO2-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_why_distributed__CO2-1" id="callout_why_distributed__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>There is now one asynchronous operation keeping Node.js alive. The process should end in 1,000 seconds.</p></dd>&#13;
<dt><a class="co" href="#co_why_distributed__CO2-2" id="callout_why_distributed__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>There are now two such operations. The process should now end in 2,000 &#13;
<span class="keep-together">seconds.</span></p></dd>&#13;
<dt><a class="co" href="#co_why_distributed__CO2-3" id="callout_why_distributed__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <em>t1</em> timer has been <a data-primary="timers" data-type="indexterm" id="idm46291203972216"/>unreferenced. Its callback can still run in 1,000 seconds, but it won’t keep the process alive.</p></dd>&#13;
<dt><a class="co" href="#co_why_distributed__CO2-4" id="callout_why_distributed__CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The <em>t2</em> timer has been cleared and will never run. A side effect of this is that it no longer keeps the process alive. With no remaining asynchronous operations keeping the process alive, the next iteration of the event loop ends the process.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This example <a data-primary="setTimeout() function" data-type="indexterm" id="idm46291203932264"/><a data-primary="functions" data-secondary="setTimeout()" data-type="indexterm" id="idm46291203931672"/>also highlights another feature of Node.js: not all of the APIs that exist in browser JavaScript behave the <a data-primary="API (application programming interface)" data-type="indexterm" id="idm46291203930472"/>same way in Node.js. The <code>setTimeout()</code> function, for example, returns an integer in web browsers. The Node.js implementation returns an object with several properties and methods.</p>&#13;
&#13;
<p>The event loop has been mentioned a few times, but it really deserves to be looked at in much more detail.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Node.js Event Loop" data-type="sect1"><div class="sect1" id="ch_introduction_sec_eventloop">&#13;
<h1>The Node.js Event Loop</h1>&#13;
&#13;
<p>Both the JavaScript that runs in your browser and the JavaScript that runs in Node.js come with an implementation of an event loop. They’re similar in that they both schedule and execute asynchronous tasks in separate stacks. But they’re also different since the event loop used in a browser is optimized to power modern single page applications, while the one in Node.js has been tuned for use in a server. This section covers, at a high level, the event loop used in Node.js. Understanding the basics of the event loop is beneficial because it handles all the scheduling of your application code—and misconceptions can lead to poor performance.</p>&#13;
&#13;
<p>As the name implies, the event loop runs in a loop. The elevator pitch is that it manages a queue of events that are used to trigger callbacks and move the application along. But, as you might expect, the implementation is much more nuanced than that. It executes <a data-primary="event loops" data-secondary="callbacks" data-type="indexterm" id="idm46291203925672"/><a data-primary="callbacks" data-secondary="event loops" data-type="indexterm" id="idm46291203924696"/>callbacks when I/O events happen, like a message being received on a socket, a file changing on disk, a <code>setTimeout()</code> callback being ready to run, etc.</p>&#13;
&#13;
<p>At a low level, the <a data-primary="event loops" data-secondary="libuv code" data-type="indexterm" id="idm46291203922696"/><a data-primary="libuv" data-secondary="event loops" data-type="indexterm" id="idm46291203921688"/>operating system notifies the program that <em>something</em> has happened. Then, libuv code inside the program springs to life and figures out what to do. If appropriate, the message then bubbles up to code in a Node.js API, and this can finally trigger a callback in application code. The event loop is a way to allow these events in lower level C++ land to cross the boundary and run code in JavaScript.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Event Loop Phases" data-type="sect2"><div class="sect2" id="idm46291203919736">&#13;
<h2>Event Loop Phases</h2>&#13;
&#13;
<p>The event loop has several <a data-primary="event loops" data-secondary="phases" data-type="indexterm" id="idm46291203918120"/>different phases to it. Some of these phases don’t deal with application code directly; for example, some might involve running JavaScript <a data-primary="JavaScript" data-secondary="internal APIs" data-type="indexterm" id="idm46291203916856"/>code that internal Node.js APIs are concerned about. An overview of the phases that handle the execution of userland code is provided in <a data-type="xref" href="#fig_event_loop">Figure 1-4</a>.</p>&#13;
&#13;
<p>Each one of these phases maintains a queue of callbacks that are to be executed. Callbacks are destined for different phases based on how they are used by the application. Here are some details about these phases:</p>&#13;
<dl>&#13;
<dt>Poll</dt>&#13;
<dd>&#13;
<p>The poll phase <a data-primary="event loops" data-secondary="phases" data-tertiary="poll phase" data-type="indexterm" id="idm46291203912296"/><a data-primary="poll phase (event loops)" data-type="indexterm" id="idm46291203911016"/>executes I/O-related callbacks. This is the phase that application code is most likely to execute in. When your main application code starts running, it runs in this phase.</p>&#13;
</dd>&#13;
<dt>Check</dt>&#13;
<dd>&#13;
<p>In this phase, <a data-primary="event loops" data-secondary="phases" data-tertiary="check phase" data-type="indexterm" id="idm46291203908728"/><a data-primary="check phase (event loops)" data-type="indexterm" id="idm46291203907448"/>callbacks that are triggered via <code>setImmediate()</code> are executed.</p>&#13;
</dd>&#13;
<dt>Close</dt>&#13;
<dd>&#13;
<p>This phase executes <a data-primary="event loops" data-secondary="phases" data-tertiary="close phase" data-type="indexterm" id="idm46291203904680"/><a data-primary="close phase (event loops)" data-type="indexterm" id="idm46291203903400"/>callbacks that are triggered via <code>EventEmitter</code> <code>close</code> events. For example, when a <code>net.Server</code> TCP server closes, it emits a <code>close</code> event that runs a callback in this phase.</p>&#13;
</dd>&#13;
<dt>Timers</dt>&#13;
<dd>&#13;
<p>Callbacks <a data-primary="event loops" data-secondary="phases" data-tertiary="timers phase" data-type="indexterm" id="idm46291203899640"/><a data-primary="timers phase (event loops)" data-type="indexterm" id="idm46291203898360"/>scheduled using <code>setTimeout()</code> and <code>setInterval()</code> are executed in this phase.</p>&#13;
</dd>&#13;
<dt>Pending</dt>&#13;
<dd>&#13;
<p>Special system <a data-primary="event loops" data-secondary="phases" data-tertiary="pending phase" data-type="indexterm" id="idm46291203895368"/><a data-primary="pending phase (event loops)" data-type="indexterm" id="idm46291203894088"/>events are run in this phase, like when a <code>net.Socket</code> TCP socket throws an <code>ECONNREFUSED</code> error.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>To make things a <a data-primary="event loops" data-secondary="phases" data-tertiary="microtask queues" data-type="indexterm" id="idm46291203891784"/><a data-primary="microtask queues" data-type="indexterm" id="idm46291203890504"/><a data-primary="callbacks" data-secondary="event loop phases" data-type="indexterm" id="idm46291203889832"/><a data-primary="event loops" data-secondary="phases" data-tertiary="callbacks" data-type="indexterm" id="idm46291203888888"/>little more complicated, there are also two special <em>microtask queues</em> that can have callbacks added to them while a phase is running. The first microtask queue handles callbacks that have been registered using <code>process.nextTick()</code>.<sup><a data-type="noteref" href="ch01.html#idm46291203886584" id="idm46291203886584-marker">3</a></sup> The second microtask queue handles promises that reject or resolve. Callbacks in the microtask queues take priority over callbacks in the phase’s normal queue, and callbacks in the next tick microtask queue run before callbacks in the promise microtask queue.</p>&#13;
&#13;
<figure><div class="figure" id="fig_event_loop">&#13;
<img alt="Five stages of the Node.js event loop: Timers, Pending, Poll, Check, Close" src="assets/dsnj_0104.png"/>&#13;
<h6><span class="label">Figure 1-4. </span>Notable phases of the Node.js event loop</h6>&#13;
</div></figure>&#13;
&#13;
<p>When the application starts running, the event loop is also started and the phases are handled one at a time. Node.js adds callbacks to different queues as appropriate while the application runs. When the event loop gets to a phase, it will run all the callbacks in that phase’s queue. Once all the callbacks in a given phase are exhausted, the event loop then moves on to the next phase. If the application runs out of things to do but is waiting for I/O operations to complete, it’ll hang out in the poll phase.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Example" data-type="sect2"><div class="sect2" id="idm46291203881912">&#13;
<h2>Code Example</h2>&#13;
&#13;
<p>Theory is nice and <a data-primary="event-loop-phases.js file" data-type="indexterm" id="loopphasesfile"/>all, but to truly understand how the event loop works, you’re going to have to get your hands dirty. This example uses the poll, check, and timers phases.&#13;
Create a file named <em>event-loop-phases.js</em> and add the content from <a data-type="xref" href="#ex_event_loop_phases">Example 1-5</a> to it.</p>&#13;
<div data-type="example" id="ex_event_loop_phases">&#13;
<h5><span class="label">Example 1-5. </span><em>event-loop-phases.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'fs'</code><code class="p">);</code>&#13;
&#13;
<code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>&#13;
<code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">().</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">2</code><code class="p">));</code>&#13;
<code class="nx">process</code><code class="p">.</code><code class="nx">nextTick</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">3</code><code class="p">));</code>&#13;
<code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="nx">__filename</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code>&#13;
  <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">5</code><code class="p">));</code>&#13;
  <code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">6</code><code class="p">));</code>&#13;
  <code class="nx">process</code><code class="p">.</code><code class="nx">nextTick</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">7</code><code class="p">));</code>&#13;
<code class="p">});</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code></pre></div>&#13;
&#13;
<p>If you feel inclined, try to guess the order of the output, but don’t feel bad if your answer doesn’t match up. This is a bit of a complex subject.</p>&#13;
&#13;
<p>The script starts off executing line by line in the poll phase. First, the <code>fs</code> module is required, and a whole lot of magic happens behind the scenes. Next, the &#13;
<span class="keep-together"><code>setImmediate()</code></span> call is run, which adds the callback printing 1 to the check queue. Then, the promise resolves, adding callback 2 to the promise microtask queue. &#13;
<span class="keep-together"><code>process.nextTick()</code></span> runs next, adding callback 3 to the next tick microtask queue. Once that’s done the <code>fs.readFile()</code> call tells the Node.js APIs to start reading a file, placing its callback in the poll queue once it’s ready. Finally, log number 8 is called directly and is printed to the screen.</p>&#13;
&#13;
<p>That’s it for the current stack. Now the two microtask queues are consulted. The next tick microtask queue is always checked first, and callback 3 is called. Since there’s only one callback in the next tick microtask queue, the promise microtask queue is checked next. Here callback 2 is executed. That finishes the two microtask queues, and the current poll phase is complete.</p>&#13;
&#13;
<p>Now the event loop enters the check phase. This phase has callback 1 in it, which is then executed. Both the microtask queues are empty at this point, so the check phase ends. The close phase is checked next but is empty, so the loop continues. The same happens with the timers phase and the pending phase, and the event loop continues back around to the poll phase.</p>&#13;
&#13;
<p>Once it’s back in the poll phase, the application doesn’t have much else going on, so it basically waits until the file has finished being read. Once that happens the &#13;
<span class="keep-together"><code>fs.readFile()</code></span> callback is run.</p>&#13;
&#13;
<p>The number 4 is immediately printed since it’s the first line in the callback. Next, the <code>setTimeout()</code> call is made and callback 5 is added to the timers queue. The &#13;
<span class="keep-together"><code>setImmediate()</code></span> call happens next, adding callback 6 to the check queue. Finally, the &#13;
<span class="keep-together"><code>process.nextTick()</code></span> call is made, adding callback 7 to the next tick microtask queue. The poll queue is now finished, and the microtask queues are again consulted. Callback 7 runs from the next tick queue, the promise queue is consulted and found empty, and the poll phase ends.</p>&#13;
&#13;
<p>Again, the event loop switches to the check phase where callback 6 is encountered. The number is printed, the microtask queues are determined to be empty, and the phase ends. The close phase is checked again and found empty. Finally the timers phase is consulted wherein callback 5 is executed. Once that’s done, the application doesn’t have <a data-primary="event-loop-phases.js file" data-startref="loopphasesfile" data-type="indexterm" id="idm46291203774488"/>any more work to do and it exits.</p>&#13;
&#13;
<p>The log statements have been printed in this order: 8, 3, 2, 1, 4, 7, 6, 5.</p>&#13;
&#13;
<p>When it comes to <code>async</code> functions, <a data-primary="asynchronous functions" data-type="indexterm" id="idm46291203772168"/><a data-primary="functions" data-secondary="asynchronous" data-type="indexterm" id="idm46291203771432"/>and operations that use the <code>await</code> keyword, code still plays by the same event loop rules. The main difference ends up being the syntax.</p>&#13;
&#13;
<p>Here is an example of some complex code that interleaves awaited statements with statements that schedule callbacks in a more straightforward manner. Go through it and write down the order in which you think the log statements will be printed:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">sleep_st</code> <code class="o">=</code> <code class="p">(</code><code class="nx">t</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">r</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">t</code><code class="p">));</code>&#13;
<code class="kr">const</code> <code class="nx">sleep_im</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">r</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">setImmediate</code><code class="p">(</code><code class="nx">r</code><code class="p">));</code>&#13;
&#13;
<code class="p">(</code><code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>&#13;
  <code class="nx">await</code> <code class="nx">sleep_st</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
  <code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">3</code><code class="p">));</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code>&#13;
  <code class="nx">await</code> <code class="nx">sleep_im</code><code class="p">();</code>&#13;
  <code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">5</code><code class="p">));</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">6</code><code class="p">);</code>&#13;
  <code class="nx">await</code> <code class="mi">1</code><code class="p">;</code>&#13;
  <code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">7</code><code class="p">));</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code>&#13;
<code class="p">})();</code></pre>&#13;
&#13;
<p>When it comes to <code>async</code> functions and statements preceded with <code>await</code>, you can almost think of them as being syntactic sugar for code that uses nested callbacks, or even as a chain of <code>.then()</code> calls. The following example is another way to think of the previous example. Again, look at the code and write down the order in which you think the log commands will print:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>&#13;
<code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">().</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">3</code><code class="p">));</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code>&#13;
  <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">().</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">5</code><code class="p">));</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">6</code><code class="p">);</code>&#13;
    <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">().</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">setImmediate</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">7</code><code class="p">));</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">}));</code>&#13;
<code class="p">},</code> <code class="mi">0</code><code class="p">));</code></pre>&#13;
&#13;
<p>Did you come up with a different solution when you read this second example? Did it seem easier to reason about? This time around, you can more easily apply the same rules about the event loop that have already been covered. In this example it’s hopefully clearer that, even though the resolved promises make it look like the code &#13;
<span class="keep-together">that follows</span> should be run much earlier, they still have to wait for the underlying &#13;
<span class="keep-together"><code>setTimeout()</code></span> or <code>setImmediate()</code> calls to fire before the program can continue.</p>&#13;
&#13;
<p>The log statements have been printed in this order: 2, 1, 4, 3, 6, 8, 5, 7.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Event Loop Tips" data-type="sect2"><div class="sect2" id="idm46291203881288">&#13;
<h2>Event Loop Tips</h2>&#13;
&#13;
<p>When it comes to building a Node.js application, you don’t necessarily need to know this level of detail about the event loop. In a lot of cases it “just works” and you usually don’t need to worry about which callbacks are executed first. That said, there are a few important things to keep in mind when it comes to the event loop.</p>&#13;
&#13;
<p><em>Don’t starve the event loop.</em> Running <a data-primary="event loops" data-secondary="starving" data-type="indexterm" id="idm46291203448952"/>too much code in a single stack will stall the event loop and prevent other callbacks from firing. One way to fix this is to break CPU-heavy operations up across multiple stacks. For example, if you need to process 1,000 data records, you might consider breaking it up into 10 batches of 100 records, using <code>setImmediate()</code> at the <a data-primary="event loops" data-secondary="setImmediate() function" data-type="indexterm" id="idm46291203447144"/><a data-primary="setImmediate() function" data-type="indexterm" id="idm46291203446136"/><a data-primary="functions" data-secondary="setImmediate()" data-type="indexterm" id="idm46291203445464"/>end of each batch to continue processing the next batch. Depending on the situation, it might make more sense to offload processing to a child process.</p>&#13;
&#13;
<p>You should never <a data-primary="functions" data-secondary="process.nextTick()" data-type="indexterm" id="idm46291203443848"/><a data-primary="process.nextTick() function" data-type="indexterm" id="idm46291203442840"/>break up such work using <code>process.nextTick()</code>. Doing so will lead to a microtask queue that never empties—your application will be trapped in the same phase forever! Unlike an infinitely recursive function, the code won’t throw a <code>RangeError</code>. Instead, it’ll remain a zombie process that eats through CPU. Check out the following for an example of this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">nt_recursive</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">process</code><code class="p">.</code><code class="nx">nextTick</code><code class="p">(</code><code class="nx">nt_recursive</code><code class="p">);</code>&#13;
<code class="nx">nt_recursive</code><code class="p">();</code> <code class="c1">// setInterval will never run</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">si_recursive</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">setImmediate</code><code class="p">(</code><code class="nx">si_recursive</code><code class="p">);</code>&#13;
<code class="nx">si_recursive</code><code class="p">();</code> <code class="c1">// setInterval will run</code>&#13;
&#13;
<code class="nx">setInterval</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'hi'</code><code class="p">),</code> <code class="mi">10</code><code class="p">);</code></pre>&#13;
&#13;
<p>In this example, the <code>setInterval()</code> represents <a data-primary="setInterval() functions" data-type="indexterm" id="idm46291203328936"/><a data-primary="functions" data-secondary="setInterval()" data-type="indexterm" id="idm46291203328296"/><a data-primary="event loops" data-secondary="setInterval() function" data-type="indexterm" id="idm46291203327352"/>some asynchronous work that the application performs, such as responding to incoming HTTP requests. Once the <code>nt_recursive()</code> function is run, the application ends up with a microtask queue that never empties and the asynchronous work never gets processed. But the alternative version <code>si_recursive()</code> does <a data-primary="si_recursive() function" data-type="indexterm" id="idm46291203325176"/><a data-primary="functions" data-secondary="si_recursive()" data-type="indexterm" id="idm46291203324440"/>not have the same side effect. Making <code>setImmediate()</code> calls within a check phase adds callbacks to the <em>next</em> event loop iteration’s check phase queue, not the current phase’s queue.</p>&#13;
&#13;
<p><em>Don’t introduce Zalgo.</em> When <a data-primary="Zalgo" data-type="indexterm" id="idm46291203411720"/>exposing a method that takes a callback, that callback should always be run asynchronously. For example, it’s far too easy to write something like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Antipattern</code>&#13;
<code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">count</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">count</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">callback</code><code class="p">(</code><code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s1">'count &gt; 0'</code><code class="p">));</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">myAsyncOperation</code><code class="p">(</code><code class="nx">count</code><code class="p">,</code> <code class="nx">callback</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The callback is <a data-primary="callbacks" data-secondary="synchronous" data-type="indexterm" id="idm46291203408520"/><a data-primary="callbacks" data-secondary="asynchronous" data-type="indexterm" id="idm46291203298888"/>sometimes called synchronously, like when <code>count</code> is set to zero, and sometimes asynchronously, like when <code>count</code> is set to one. Instead, ensure the callback is executed in a new stack, like in this example:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">count</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">count</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">process</code><code class="p">.</code><code class="nx">nextTick</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">callback</code><code class="p">(</code><code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s1">'count &gt; 0'</code><code class="p">)));</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">myAsyncOperation</code><code class="p">(</code><code class="nx">count</code><code class="p">,</code> <code class="nx">callback</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this case, either <a data-primary="event loops" data-secondary="recursive" data-type="indexterm" id="idm46291203292120"/>using <code>setImmediate()</code> or <code>process.nextTick()</code> is okay; just make sure you don’t accidentally introduce recursion. With this reworked example, the callback is always run asynchronously. Ensuring the callback is run consistently is important because of the following situation:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">let</code> <code class="nx">bar</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>&#13;
<code class="nx">foo</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">assert</code><code class="p">(</code><code class="nx">bar</code><code class="p">);</code>&#13;
<code class="p">});</code>&#13;
<code class="nx">bar</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code></pre>&#13;
&#13;
<p>This might look a bit contrived, but essentially the problem is that when the callback is sometimes run synchronously and sometimes run asynchronously, the value of <code>bar</code> may or may not have been modified. In a real application this can be the difference between accessing a variable that may or may not have been properly initialized.</p>&#13;
&#13;
<p>Now that you’re a little more familiar with the inner workings of Node.js, it’s time to build out some sample applications.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sample Applications" data-type="sect1"><div class="sect1" id="ch_introduction_sec_sample">&#13;
<h1>Sample Applications</h1>&#13;
&#13;
<p>In this section you’ll <a data-primary="sample applications" data-type="indexterm" id="idm46291208505816"/><a data-primary="applications" data-secondary="sample" data-see="sample applications" data-type="indexterm" id="idm46291208505112"/>build a pair of small sample Node.js applications. They are intentionally simple and lack features that real applications require. You’ll then add to the complexity of these base applications throughout the remainder of the book.</p>&#13;
&#13;
<p>I struggled with the decision to avoid using <em>any</em> third-party packages in these examples (for example, to stick with the internal <code>http</code> module), but using these packages reduces boilerplate and increases clarity. That said, feel free to choose whatever your preferred framework or request library is; it’s not the intent of this book to ever prescribe a particular package.</p>&#13;
&#13;
<p>By building two services instead of just one, you can combine them later in interesting ways, like choosing the protocol they communicate with or the manner in which they discover each other.</p>&#13;
&#13;
<p>The first application, namely the <em>recipe-api</em>, represents an internal API that isn’t accessed from the outside world; it’ll only be accessed by other internal applications. Since you own both the service and any clients that access it, you’re later free to make protocol decisions. This holds true for any internal service within an organization.</p>&#13;
&#13;
<p>The second application represents an API that is accessed by third parties over the internet. It exposes an HTTP server so that web browsers can easily communicate with it. This application is called the <em>web-api</em>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Service Relationship" data-type="sect2"><div class="sect2" id="idm46291203207464">&#13;
<h2>Service Relationship</h2>&#13;
&#13;
<p>The <em>web-api</em> service is <a data-primary="web-api service" data-type="indexterm" id="idm46291203205192"/><a data-primary="API (application programming interface)" data-secondary="web-api service" data-type="indexterm" id="idm46291203204456"/><a data-primary="recipe-api" data-type="indexterm" id="idm46291203203544"/><a data-primary="API (application programming interface)" data-secondary="recipe-api service" data-type="indexterm" id="idm46291203202872"/>downstream of the <em>recipe-api</em> and, conversely, the <em>recipe-api</em> is upstream of the <em>web-api</em>. <a data-type="xref" href="#fig_prod_cons">Figure 1-5</a> is a visualization of the relationship between these two services.</p>&#13;
&#13;
<figure><div class="figure" id="fig_prod_cons">&#13;
<img alt="Relationship between web-api and recipe-api" src="assets/dsnj_0105.png"/>&#13;
<h6><span class="label">Figure 1-5. </span>The relationship between <em>web-api</em> and <em>recipe-api</em></h6>&#13;
</div></figure>&#13;
&#13;
<p>Both of these <a data-primary="web-api service" data-secondary="as client/consumer" data-type="indexterm" id="idm46291203196504"/>applications can be referred to as servers because they are both actively listening for incoming network requests. However, when describing the specific relationship between the two APIs (arrow B in <a data-type="xref" href="#fig_prod_cons">Figure 1-5</a>), the <em>web-api</em> can be referred to as the client/consumer and <a data-primary="recipe-api" data-secondary="as server/producer" data-type="indexterm" id="idm46291203193944"/>the <em>recipe-api</em> as the server/producer. <a data-type="xref" href="ch02.html#ch_protocols">Chapter 2</a> focuses on this relationship. When referring to the relationship between web browser and <em>web-api</em> (arrow A in <a data-type="xref" href="#fig_prod_cons">Figure 1-5</a>), the browser is called the client/consumer, and <em>web-api</em> is then called the server/producer.</p>&#13;
&#13;
<p>Now it’s time to examine <a data-primary="distributed-node/ directory" data-type="indexterm" id="idm46291208477944"/>the source code of the two services. Since these two services will evolve throughout the book, now would be a good time to create some sample projects for them. Create a <em>distributed-node/</em> directory to hold all of the code samples you’ll create for this book. Most of the commands you’ll run require that you’re inside of this directory, unless otherwise noted. Within this directory, create a <em>web-api/</em>, a <em>recipe-api/</em>, and a <em>shared/</em> directory. The first two directories will contain different &#13;
<span class="keep-together">service</span> representations. The <em>shared/</em> directory will contain shared files to make it easier to apply the examples in this book.<sup><a data-type="noteref" href="ch01.html#idm46291208473736" id="idm46291208473736-marker">4</a></sup></p>&#13;
&#13;
<p>You’ll also need to install the required dependencies. Within both project directories, run the following command:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm init -y</pre>&#13;
&#13;
<p>This creates <a data-primary="dependencies" data-secondary="installing" data-type="indexterm" id="idm46291207530840"/><a data-primary="npm install commands" data-type="indexterm" id="idm46291209132680"/><a data-primary="commands" data-secondary="npm install" data-type="indexterm" id="idm46291207546072"/><a data-primary="JSON" data-secondary="package.json files" data-type="indexterm" id="idm46291206621736"/>basic <em>package.json</em> files for you. Once that’s done, run the appropriate <code>npm install</code> commands from the top comment of the code examples. Code samples use this convention throughout the book to convey which packages need to be installed, so you’ll need to run the init and install commands on your own after this. Note that each project will start to contain superfluous dependencies since the code samples are reusing directories. In a real-world project, only necessary packages should be listed as dependencies.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Producer Service" data-type="sect2"><div class="sect2" id="idm46291209516232">&#13;
<h2>Producer Service</h2>&#13;
&#13;
<p>Now that the setup is complete, it’s <a data-primary="recipe-api" data-secondary="source code" data-type="indexterm" id="idm46291209770888"/>time to view the source code. <a data-type="xref" href="#ex_producer">Example 1-6</a> is an internal Recipe API service, an upstream service that provides data. For this example it will simply provide static data. A real-world application might instead retrieve data from a database.</p>&#13;
<div data-type="example" id="ex_producer">&#13;
<h5><span class="label">Example 1-6. </span><em>recipe-api/producer-http-basic.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c-Hashbang">#!/usr/bin/env node</code>&#13;
&#13;
<code class="c1">// npm install fastify@3.2</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'fastify'</code><code class="p">)();</code>&#13;
<code class="kr">const</code> <code class="nx">HOST</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">HOST</code> <code class="o">||</code> <code class="s1">'127.0.0.1'</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">PORT</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">4000</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`worker pid=</code><code class="si">${</code><code class="nx">process</code><code class="p">.</code><code class="nx">pid</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/recipes/:id'</code><code class="p">,</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">reply</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`worker request pid=</code><code class="si">${</code><code class="nx">process</code><code class="p">.</code><code class="nx">pid</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">id</code> <code class="o">!==</code> <code class="mi">42</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">reply</code><code class="p">.</code><code class="nx">statusCode</code> <code class="o">=</code> <code class="mi">404</code><code class="p">;</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">error</code><code class="o">:</code> <code class="s1">'not_found'</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
    <code class="nx">producer_pid</code><code class="o">:</code> <code class="nx">process</code><code class="p">.</code><code class="nx">pid</code><code class="p">,</code>&#13;
    <code class="nx">recipe</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Chicken Tikka Masala"</code><code class="p">,</code>&#13;
      <code class="nx">steps</code><code class="o">:</code> <code class="s2">"Throw it in a pot..."</code><code class="p">,</code>&#13;
      <code class="nx">ingredients</code><code class="o">:</code> <code class="p">[</code>&#13;
        <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Chicken"</code><code class="p">,</code> <code class="nx">quantity</code><code class="o">:</code> <code class="s2">"1 lb"</code><code class="p">,</code> <code class="p">},</code>&#13;
        <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Sauce"</code><code class="p">,</code> <code class="nx">quantity</code><code class="o">:</code> <code class="s2">"2 cups"</code><code class="p">,</code> <code class="p">}</code>&#13;
      <code class="p">]</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="nx">PORT</code><code class="p">,</code> <code class="nx">HOST</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Producer running at http://</code><code class="si">${</code><code class="nx">HOST</code><code class="si">}</code><code class="sb">:</code><code class="si">${</code><code class="nx">PORT</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
<code class="p">});</code></pre></div>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The first line in these files is <a data-primary="shebang" data-type="indexterm" id="idm46291208465944"/>known as a <em>shebang</em>. When a file begins with this line and is made executable (by running <strong><code><code>chmod +x filename.js</code></code></strong>), it can be executed by running <strong><code><code>./filename.js</code></code></strong>. As a convention in this book, any time code contains a shebang, it represents a file used as an entry point for an application.</p>&#13;
</div>&#13;
&#13;
<p>Once this service is ready, you can work with it in two different terminal windows.<sup><a data-type="noteref" href="ch01.html#idm46291205957864" id="idm46291205957864-marker">5</a></sup> Execute the following commands; the first <a data-primary="recipe-api" data-secondary="starting" data-type="indexterm" id="idm46291205956984"/>starts the <em>recipe-api</em> service, and the second tests that it’s running and can return data:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>node recipe-api/producer-http-basic.js <code class="c"># terminal 1</code>&#13;
<code class="nv">$ </code>curl http://127.0.0.1:4000/recipes/42  <code class="c"># terminal 2</code></pre>&#13;
&#13;
<p>You should then see JSON output like the following (whitespace added for clarity):</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"producer_pid"</code><code class="p">:</code> <code class="mi">25765</code><code class="p">,</code>&#13;
  <code class="nt">"recipe"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"id"</code><code class="p">:</code> <code class="mi">42</code><code class="p">,</code>&#13;
    <code class="nt">"name"</code><code class="p">:</code> <code class="s2">"Chicken Tikka Masala"</code><code class="p">,</code>&#13;
    <code class="nt">"steps"</code><code class="p">:</code> <code class="s2">"Throw it in a pot..."</code><code class="p">,</code>&#13;
    <code class="nt">"ingredients"</code><code class="p">:</code> <code class="p">[</code>&#13;
      <code class="p">{</code> <code class="nt">"id"</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nt">"name"</code><code class="p">:</code> <code class="s2">"Chicken"</code><code class="p">,</code> <code class="nt">"quantity"</code><code class="p">:</code> <code class="s2">"1 lb"</code> <code class="p">},</code>&#13;
      <code class="p">{</code> <code class="nt">"id"</code><code class="p">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nt">"name"</code><code class="p">:</code> <code class="s2">"Sauce"</code><code class="p">,</code> <code class="nt">"quantity"</code><code class="p">:</code> <code class="s2">"2 cups"</code> <code class="p">}</code>&#13;
    <code class="p">]</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Consumer Service" data-type="sect2"><div class="sect2" id="idm46291205941768">&#13;
<h2>Consumer Service</h2>&#13;
&#13;
<p>The second service, a public-facing Web API service, doesn’t contain as much data but is more complex since it’s going to make an outbound request. Copy the source code from <a data-type="xref" href="#ex_consumer">Example 1-7</a> to the file located at <em>web-api/consumer-http-basic.js</em>.</p>&#13;
<div data-type="example" id="ex_consumer">&#13;
<h5><span class="label">Example 1-7. </span><em>web-api/consumer-http-basic.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c-Hashbang">#!/usr/bin/env node</code>&#13;
&#13;
<code class="c1">// npm install fastify@3.2 node-fetch@2.6</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'fastify'</code><code class="p">)();</code>&#13;
<code class="kr">const</code> <code class="nx">fetch</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'node-fetch'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">HOST</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">HOST</code> <code class="o">||</code> <code class="s1">'127.0.0.1'</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">PORT</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">3000</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">TARGET</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">TARGET</code> <code class="o">||</code> <code class="s1">'localhost:4000'</code><code class="p">;</code>&#13;
&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/'</code><code class="p">,</code> <code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">req</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="sb">`http://</code><code class="si">${</code><code class="nx">TARGET</code><code class="si">}</code><code class="sb">/recipes/42`</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">producer_data</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">req</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
    <code class="nx">consumer_pid</code><code class="o">:</code> <code class="nx">process</code><code class="p">.</code><code class="nx">pid</code><code class="p">,</code>&#13;
    <code class="nx">producer_data</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="nx">PORT</code><code class="p">,</code> <code class="nx">HOST</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Consumer running at http://</code><code class="si">${</code><code class="nx">HOST</code><code class="si">}</code><code class="sb">:</code><code class="si">${</code><code class="nx">PORT</code><code class="si">}</code><code class="sb">/`</code><code class="p">);</code>&#13;
<code class="p">});</code></pre></div>&#13;
&#13;
<p>Make sure that the <em>recipe-api</em> service is still running. Then, once you’ve created the file and have added the code, execute the new service and generate a request using the following commands:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>node web-api/consumer-http-basic.js <code class="c"># terminal 1</code>&#13;
<code class="nv">$ </code>curl http://127.0.0.1:3000/         <code class="c"># terminal 2</code></pre>&#13;
&#13;
<p>The result of this operation is a superset of the JSON provided from the previous request:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"consumer_pid"</code><code class="p">:</code> <code class="mi">25670</code><code class="p">,</code>&#13;
  <code class="nt">"producer_data"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"producer_pid"</code><code class="p">:</code> <code class="mi">25765</code><code class="p">,</code>&#13;
    <code class="nt">"recipe"</code><code class="p">:</code> <code class="p">{</code>&#13;
      <code class="err">...</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>pid</code> values in the <a data-primary="PID values" data-type="indexterm" id="idm46291205685128"/>responses are the numeric process IDs of each service. These PID values are used by operating systems to differentiate running processes. They’re included in the responses to make it obvious that the data came from two separate processes. These values are unique across a particular running operating system, meaning there should not be duplicates on the same running machine, though there will be collisions across separate machines, virtual or otherwise.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46291209446408"><sup><a href="ch01.html#idm46291209446408-marker">1</a></sup> Even a multithreaded application is constrained by the limitations of a single machine.</p><p data-type="footnote" id="idm46291209353624"><sup><a href="ch01.html#idm46291209353624-marker">2</a></sup> “Userland” is a term borrowed from operating systems, meaning the space outside of the kernel where a user’s applications can run. In the case of Node.js programs, it refers to application code and npm packages—basically, everything not built into Node.js.</p><p data-type="footnote" id="idm46291203886584"><sup><a href="ch01.html#idm46291203886584-marker">3</a></sup> A “tick” refers to a complete pass through the event loop. Confusingly, <code>setImmediate()</code> takes a tick to run, whereas <code>process.nextTick()</code> is more immediate, so the two functions deserve a name swap.</p><p data-type="footnote" id="idm46291208473736"><sup><a href="ch01.html#idm46291208473736-marker">4</a></sup> In a real-world scenario, any shared files should be checked in via source control or loaded as an outside dependency via an npm package.</p><p data-type="footnote" id="idm46291205957864"><sup><a href="ch01.html#idm46291205957864-marker">5</a></sup> Many of the examples in this book require you two run multiple processes, with some acting as clients and some as servers. For this reason, you’ll often need to run processes in separate terminal windows. In general, if you run a command and it doesn’t immediately exit, it probably requires a dedicated terminal.</p></div></div></section></body></html>