<html><head></head><body><section data-pdf-bookmark="Chapter 21. Immutable Configuration" data-type="chapter" epub:type="chapter"><div class="chapter" id="ImmutableConfiguration">&#13;
<h1><span class="label">Chapter 21. </span>Immutable Configuration</h1>&#13;
&#13;
&#13;
<p>The<a data-primary="Immutable Configuration" data-type="indexterm" id="immtbcnfgrn21"/><a data-primary="configuration information" data-secondary="immutable and versioned" data-type="indexterm" id="idm45902089442096"/> <em>Immutable Configuration</em> pattern offers two ways to make configuration data immutable so that your application’s configuration is always in a well-known and recorded state.&#13;
With this pattern, we can not only use immutable and versioned configuration data, but also overcome the size limitation of configuration data stored in environment variables or ConfigMaps.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902089440416">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>As<a data-primary="EnvVar Configuration" data-type="indexterm" id="idm45902089439088"/><a data-primary="EnvVar Configuration" data-secondary="Immutable Configuration" data-type="indexterm" id="idm45902089438352"/><a data-primary="problems" data-secondary="configuration data, immutable and versioned" data-type="indexterm" id="idm45902089437408"/> you saw in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch19.html#EnvVarConfiguration">Chapter 19, “EnvVar Configuration”</a>, environment variables provide a simple way to configure container-based applications. And although they are easy to use and universally supported, as soon as the number of environment variables exceeds a certain threshold, managing them becomes hard.</p>&#13;
&#13;
<p>This complexity can be handled to some degree by using <em>Configuration Resources</em>, as described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch20.html#ConfigurationResource">Chapter 20, “Configuration Resource”</a>, which since Kubernetes 1.21 can be declared as <em>immutable</em>.&#13;
However, ConfigMaps still have a size limitation, so if you work with large configuration data (like precomputed data models in a machine learning context), then ConfigMaps are not suitable even when marked as immutable.</p>&#13;
&#13;
<p><em>Immutability</em> here means that we can’t change the configuration after the application has started, in order to ensure that we always have a well-defined state for our configuration data. In addition, immutable configuration can be put under version control and follow a change control process.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902089431472">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>There are several options to address the concern of configuration immutability. The simplest and preferred option is to use ConfigMaps or Secrets that are marked as immutable in their declaration. You learned about immutable ConfigMaps in <a data-type="xref" href="ch20.html#ConfigurationResource">Chapter 20</a>.&#13;
ConfigMaps should be the first choice if your configuration fits into a ConfigMap and is reasonably easy to maintain.&#13;
In real-world scenarios, however, the amount of configuration data can increase quickly.&#13;
Although a<a data-primary="WildFly" data-type="indexterm" id="idm45902089428848"/> WildFly application server configuration might still fit in a ConfigMap, it is quite huge.&#13;
It becomes really ugly when you have to nest XML or YAML within YAML—i.e., when the content of your configuration is also YAML and you embed this as within the ConfigMaps YAML section.&#13;
Editor support for such use cases is limited, so you have to be very careful about the indentation, and even then, you will probably mess it up more than once (believe us!).&#13;
Another nightmare is having to maintain tens or hundreds of entries in a single ConfigMap because your application requires many different configuration files.&#13;
Although this pain can be mitigated to some degree with good tooling, large configuration data sets like pretrained machine learning data models are just impossible with ConfigMap because of the backend size restriction of 1 MB.</p>&#13;
&#13;
<p>To address the concern of complex configuration data, we can put all environment-specific configuration data into a single, passive data image that we can distribute as a regular container image.&#13;
During runtime, the application and the data image are linked together so that the application can extract the configuration from the data image. With this approach, it is easy to craft different configuration data images for various environments. These images then combine all configuration information for specific environments and can be versioned like any other container image.</p>&#13;
&#13;
<p>Creating such a data image is trivial, as it is a simple container image that contains only data. The challenge is the linking step during startup. We can use various approaches, depending on the platform.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Docker Volumes" data-type="sect2"><div class="sect2" id="idm45902089427120">&#13;
<h2>Docker Volumes</h2>&#13;
&#13;
<p>Before<a data-primary="Docker volumes" data-type="indexterm" id="idm45902089425456"/> looking at Kubernetes, let’s go one step back and consider the vanilla Docker case. In Docker, it is possible for a container to expose a <em>volume</em> with data from the container. With a <code>VOLUME</code> directive in a Dockerfile, you can specify a directory that can be shared later. During startup, the content of this directory within the container is copied over to this shared directory. As shown in <a data-type="xref" href="#img-immutable-configuration-volumes">Figure 21-1</a>, this volume linking is an excellent way to share configuration information from a dedicated configuration container with another application container.</p>&#13;
&#13;
<figure><div class="figure" id="img-immutable-configuration-volumes">&#13;
<img alt="Immutable Configuration with Docker volumes" src="assets/kup2_2101.png"/>&#13;
<h6><span class="label">Figure 21-1. </span>Immutable configuration with Docker volume</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s have a look at an example. For the development environment, we create a Docker image that holds the developer configuration and creates a volume with mount point <em>/config</em>. We can create such an image with <code>Dockerfile-config</code>, as in <a data-type="xref" href="#ex-immutable-config-dockerfile">Example 21-1</a>.</p>&#13;
<div data-type="example" id="ex-immutable-config-dockerfile">&#13;
<h5><span class="label">Example 21-1. </span>Dockerfile for a configuration image</h5>&#13;
&#13;
<pre data-type="programlisting">FROM scratch&#13;
ADD app-dev.properties /config/app.properties  <a class="co" href="#callout_immutable_configuration_CO1-1" id="co_immutable_configuration_CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
VOLUME /config                                 <a class="co" href="#callout_immutable_configuration_CO1-2" id="co_immutable_configuration_CO1-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_immutable_configuration_CO1-1" id="callout_immutable_configuration_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Add specified property.</p></dd>&#13;
<dt><a class="co" href="#co_immutable_configuration_CO1-2" id="callout_immutable_configuration_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create volume and copy property into it.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>We now create the image itself and the Docker container with the Docker CLI in <a data-type="xref" href="#ex-immutable-config-build-image">Example 21-2</a>.</p>&#13;
<div data-type="example" id="ex-immutable-config-build-image">&#13;
<h5><span class="label">Example 21-2. </span>Building the configuration Docker image</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">docker<code class="w"> </code>build<code class="w"> </code>-t<code class="w"> </code>k8spatterns/config-dev-image:1.0.1<code class="w"> </code>-f<code class="w"> </code>Dockerfile-config<code class="w"> </code>.<code class="w"/>&#13;
docker<code class="w"> </code>create<code class="w"> </code>--name<code class="w"> </code>config-dev<code class="w"> </code>k8spatterns/config-dev-image:1.0.1<code class="w"> </code>.<code class="w"/></pre></div>&#13;
&#13;
<p>The final step is to start the application container and connect it to this configuration container (<a data-type="xref" href="#ex-immutable-config-start-application">Example 21-3</a>).</p>&#13;
<div data-type="example" id="ex-immutable-config-start-application">&#13;
<h5><span class="label">Example 21-3. </span>Start application container with config container linked</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">docker<code class="w"> </code>run<code class="w"> </code>--volumes-from<code class="w"> </code>config-dev<code class="w"> </code>k8spatterns/welcome-servlet:1.0<code class="w"/></pre></div>&#13;
&#13;
<p class="pagebreak-before">The application image expects its configuration files to be within a <em>/config</em> directory, the volume exposed by the configuration container. When you move this application from the development environment to the production environment, all you have to do is change the startup command. There is no need to alter the application image itself. Instead, you simply volume-link the application container with the production configuration container, as seen in <a data-type="xref" href="#ex-immutable-config-production">Example 21-4</a>.</p>&#13;
<div data-type="example" id="ex-immutable-config-production">&#13;
<h5><span class="label">Example 21-4. </span>Use different configuration for production environment</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">docker<code class="w"> </code>build<code class="w"> </code>-t<code class="w"> </code>k8spatterns/config-prod-image:1.0.1<code class="w"> </code>-f<code class="w"> </code>Dockerfile-config<code class="w"> </code>.<code class="w"/>&#13;
docker<code class="w"> </code>create<code class="w"> </code>--name<code class="w"> </code>config-prod<code class="w"> </code>k8spatterns/config-prod-image:1.0.1<code class="w"> </code>.<code class="w"/>&#13;
docker<code class="w"> </code>run<code class="w"> </code>--volumes-from<code class="w"> </code>config-prod<code class="w"> </code>k8spatterns/welcome-servlet:1.0<code class="w"/></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes Init Containers" data-type="sect2"><div class="sect2" id="immutable-configuration-init-containers">&#13;
<h2>Kubernetes Init Containers</h2>&#13;
&#13;
<p>In Kubernetes, volume<a data-primary="containers" data-secondary="volumes" data-type="indexterm" id="idm45902089341216"/> sharing within a Pod is perfectly suited for this kind of linking of configuration and application containers. However, if we want to transfer this technique of Docker volume linking to the Kubernetes world, we will find that there is currently no support for container volumes in Kubernetes. Considering the age of the discussion and the complexity of implementing this feature versus its limited benefits, it’s likely that container volumes will not arrive anytime soon.</p>&#13;
&#13;
<p>So<a data-primary="Init Container" data-type="indexterm" id="idm45902089300192"/><a data-primary="Init Container" data-secondary="Immutable Configuration" data-type="indexterm" id="idm45902089299456"/> containers can share (external) volumes, but they cannot yet directly share directories located within the containers. To use immutable configuration containers in Kubernetes, we can use the <em>Init Containers</em> pattern from <a data-type="xref" href="ch15.html#InitContainer">Chapter 15</a> that can initialize an empty shared volume during startup.</p>&#13;
&#13;
<p>In the Docker example, we base the configuration Docker image on <code>scratch</code>, an empty Docker image with no operating system files. We don’t need anything else because we only want the configuration data shared via Docker volumes. But for Kubernetes init containers, we need help from the base image to copy over the configuration data to a shared Pod volume. A good choice for this is <code>busybox</code><a data-primary="busybox" data-type="indexterm" id="idm45902089296048"/>, which is still small but allows us to use a plain Unix <code>cp</code> command for this task.</p>&#13;
&#13;
<p>So how does the initialization of shared volumes with configuration work under the hood? Let’s have a look at an example. First, we need to create a configuration image again with a Dockerfile, as in <a data-type="xref" href="#ex-immutable-config-dev-properties">Example 21-5</a>.</p>&#13;
<div data-type="example" id="ex-immutable-config-dev-properties">&#13;
<h5><span class="label">Example 21-5. </span>Development configuration image</h5>&#13;
&#13;
<pre data-type="programlisting">FROM busybox&#13;
ADD dev.properties /config-src/demo.properties&#13;
ENTRYPOINT [ "sh", "-c", "cp /config-src/* $1", "--" ]  <a class="co" href="#callout_immutable_configuration_CO2-1" id="co_immutable_configuration_CO2-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_immutable_configuration_CO2-1" id="callout_immutable_configuration_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Using a shell here in order to resolve wildcards.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The only difference from the vanilla Docker case in <a data-type="xref" href="#ex-immutable-config-dockerfile">Example 21-1</a> is that we have a different base image and we add an <code>ENTRYPOINT</code> that copies the properties file to the directory given as an argument when the container image starts. This image can now be referenced in an init container within a Deployment’s <code>.template.spec</code> (see <a data-type="xref" href="#ex-immutable-config-deployment-init">Example 21-6</a>).</p>&#13;
<div data-type="example" id="ex-immutable-config-deployment-init">&#13;
<h5><span class="label">Example 21-6. </span>Deployment that copies configuration to destination in init container</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">initContainers</code><code class="p">:</code><code class="w"/>&#13;
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/config-dev:1</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">init</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">args</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"/config"</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/config"</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-directory</code><code class="w"/>&#13;
<code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/demo:1</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">http</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/var/config"</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-directory</code><code class="w"/>&#13;
<code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-directory</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/></pre></div>&#13;
&#13;
<p>The Deployment’s Pod template specification contains a single volume and two <span class="keep-together">containers</span>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The volume <code>config-directory</code> is of the type <code>emptyDir</code>, so it’s created as an empty directory on the node hosting this Pod.</p>&#13;
</li>&#13;
<li>&#13;
<p>The init container Kubernetes calls during startup is built from the image we just created, and we set a single argument, <code>/config</code>, used by the image’s <code>ENTRYPOINT</code>. This argument instructs the init container to copy its content to the specified directory. The directory <em>/config</em> is mounted from the volume <code>config-directory</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The application container mounts the volume <code>config-directory</code> to access the configuration that was copied over by the init container.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="#img-immutable-configuration-init-container">Figure 21-2</a> illustrates how the application container accesses the configuration data created by an init container over a shared volume.</p>&#13;
&#13;
<figure><div class="figure" id="img-immutable-configuration-init-container">&#13;
<img alt="Immutable Configuration with an init container" src="assets/kup2_2102.png"/>&#13;
<h6><span class="label">Figure 21-2. </span>Immutable configuration with an init container</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now to change the configuration from the development to the production environment, all we need to do is exchange the image of the init container. We can do this either by changing the YAML definition or by updating with<a data-primary="kubectl" data-secondary="updating YAML definition" data-type="indexterm" id="idm45902089110848"/> <code>kubectl</code>. However, it is not ideal to have to edit the resource descriptor for each environment. If you are on Red Hat OpenShift, an enterprise distribution of Kubernetes, <em>OpenShift Templates</em> can help address this. OpenShift Templates can create different resource descriptors for the different environments from a single template.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="OpenShift Templates" data-type="sect2"><div class="sect2" id="idm45902089108528">&#13;
<h2>OpenShift Templates</h2>&#13;
&#13;
<p>OpenShift Templates are regular resource descriptors that are parameterized. As seen in <a data-type="xref" href="#ex-immutable-config-template">Example 21-7</a>, we can easily use the configuration image as a<a data-primary="Red Hat OpenShift" data-secondary="DeploymentConfig" data-type="indexterm" id="idm45902089105936"/> parameter.</p>&#13;
<div data-type="example" id="ex-immutable-config-template">&#13;
<h5><span class="label">Example 21-7. </span>OpenShift Template for parameterizing config image</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Template</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w">&#13;
</code><code class="nt">parameters</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">CONFIG_IMAGE</code><code class="w">                       </code><a class="co" href="#callout_immutable_configuration_CO3-1" id="co_immutable_configuration_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">description</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Name</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">of</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">configuration</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">image</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/config-dev:1</code><code class="w">&#13;
</code><code class="nt">objects</code><code class="p">:</code><code class="w">&#13;
</code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w">&#13;
</code><code class="w">    </code><code class="l-Scalar-Plain">//</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">....</code><code class="w">&#13;
</code><code class="w">    </code><code class="l-Scalar-Plain">spec</code><code class="p-Indicator">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">template</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="l-Scalar-Plain">//</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">....</code><code class="w">&#13;
</code><code class="w">            </code><code class="l-Scalar-Plain">spec</code><code class="p-Indicator">:</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">initContainers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">              </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">init</code><code class="w">&#13;
</code><code class="w">                </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">${CONFIG_IMAGE}</code><code class="w">       </code><a class="co" href="#callout_immutable_configuration_CO3-2" id="co_immutable_configuration_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">                </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"</code><code class="s">/config</code><code class="s">"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w">&#13;
</code><code class="w">                </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">                </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/config</code><code class="w">&#13;
</code><code class="w">                  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-directory</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">              </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/demo:1</code><code class="w">&#13;
</code><code class="w">                </code><code class="l-Scalar-Plain">//</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">...</code><code class="w">&#13;
</code><code class="w">                </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">                </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/config</code><code class="w">&#13;
</code><code class="w">                  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-directory</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-directory</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_immutable_configuration_CO3-1" id="callout_immutable_configuration_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Template parameter <code>CONFIG_IMAGE</code> declaration.</p></dd>&#13;
<dt><a class="co" href="#co_immutable_configuration_CO3-2" id="callout_immutable_configuration_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use of the template parameter.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>We show here only a fragment of the full descriptor, but you can quickly recognize the parameter <code>CONFIG_IMAGE</code> we reference in the<a data-primary="Init Container" data-type="indexterm" id="idm45902088914448"/><a data-primary="Init Container" data-secondary="Immutable Configuration" data-type="indexterm" id="idm45902088913712"/> init container declaration. If we create this template on an OpenShift cluster, we can instantiate it by calling <code>oc</code>, as in <a data-type="xref" href="#ex-immutable-config-template-apply">Example 21-8</a>.</p>&#13;
<div data-type="example" id="ex-immutable-config-template-apply">&#13;
<h5><span class="label">Example 21-8. </span>Applying OpenShift template to create new application</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">oc<code class="w"> </code>new-app<code class="w"> </code>demo<code class="w"> </code>-p<code class="w"> </code><code class="nv">CONFIG_IMAGE</code><code class="o">=</code>k8spatterns/config-prod:1<code class="w"/></pre></div>&#13;
&#13;
<p>Detailed instructions for running this example, as well as the full Deployment descriptors, can be found as usual in our example Git repository.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902088831200">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>Using data containers for the <em>Immutable Configuration</em> pattern is admittedly a bit involved.&#13;
Use these only if immutable ConfigMaps and Secret are not suitable for your use case.</p>&#13;
&#13;
<p>Data containers have some unique advantages:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Environment-specific configuration is sealed within a container. Therefore, it can be versioned like any other container image.</p>&#13;
</li>&#13;
<li>&#13;
<p>Configuration created this way can be distributed over a container registry. The configuration can be examined even without accessing the cluster.</p>&#13;
</li>&#13;
<li>&#13;
<p>The configuration is immutable, as is the container image holding the configuration: a change in the configuration requires a version update and a new container image.</p>&#13;
</li>&#13;
<li>&#13;
<p>Configuration data images are useful when the configuration data is too complex to put into environment variables or ConfigMaps, since it can hold arbitrarily large configuration data.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>As expected, the <em>Immutable Configuration</em> pattern also has certain drawbacks:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It has higher complexity, because extra container images need to be built and distributed via registries.</p>&#13;
</li>&#13;
<li>&#13;
<p>It does not address any of the security concerns around sensitive configuration data.</p>&#13;
</li>&#13;
<li>&#13;
<p>Since no image volume support is actually available for Kubernetes workloads, the technique described here is still limited for use cases where the overhead of copying over data from init containers to a local volume is acceptable. We hope that eventually mounting container images directly as volumes will be possible in the future, but as of 2023, only experimental CSI support is available.</p>&#13;
</li>&#13;
<li>&#13;
<p>Extra<a data-primary="Init Container" data-type="indexterm" id="idm45902088796832"/><a data-primary="Init Container" data-secondary="Immutable Configuration" data-type="indexterm" id="idm45902088796336"/> init container processing is required in the Kubernetes case, and hence we need to manage different Deployment objects for different environments.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>All in all, you should carefully evaluate whether such an involved approach is really required.</p>&#13;
&#13;
<p>Another approach for dealing with large configuration files that differ only slightly from environment to environment is described with the <em>Configuration Template</em> pattern, the topic of the next chapter.<a data-primary="" data-startref="immtbcnfgrn21" data-type="indexterm" id="idm45902088793520"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902088792416">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/1bPZ2">Immutable Configuration Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/bTtty">How to Mimic <code>--volumes-from</code> in Kubernetes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/RfrwN">Immutable ConfigMaps</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/XQ54e">Feature Request: Image Volumes and Container Volumes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/vhCdH">docker-flexvol: A Kubernetes Driver That Supports Docker Volumes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/QyX2y">Red Hat OpenShift: Using Templates</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/OMqRo">Kubernetes CSI Driver for Mounting Images</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>