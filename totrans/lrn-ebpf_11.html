<html><head></head><body><section data-pdf-bookmark="Chapter 11. The Future Evolution of eBPF" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_future_evolution_of_ebpf">&#13;
<h1><span class="label">Chapter 11. </span>The Future Evolution of eBPF</h1>&#13;
<p>eBPF is not finished yet! Like most software, it’s under continual development within the Linux kernel, and it’s being added to the Windows operating system as well. In this chapter we’ll look at some of the likely future paths for this technology.</p>&#13;
<p>Since it was introduced within the Linux kernel, BPF has evolved into its own subsystem with its own mailing list and maintainers.<sup><a data-type="noteref" href="ch11.html#ch11fn1" id="ch11fn1-marker">1</a></sup> As eBPF’s popularity increased and interest broadened beyond the Linux kernel community, it made sense to create a neutral body that could coordinate among the different parties involved. That body is the eBPF Foundation.</p>&#13;
<section data-pdf-bookmark="The eBPF Foundation" data-type="sect1"><div class="sect1" id="the_ebpf_foundation">&#13;
<h1>The eBPF Foundation</h1>&#13;
<p><a contenteditable="false" data-primary="eBPF Foundation" data-type="indexterm" id="idm46123190383456"/>The <a href="https://ebpf.io/foundation">eBPF Foundation</a> was set up in 2021 by Google, Isovalent, Meta (then known as Facebook), Microsoft, and Netflix, under the auspices of the Linux Foundation. The foundation acts as a neutral body that can hold funds and intellectual property, such that various commercial companies can collaborate with one another.</p>&#13;
<p>The intent was not to change anything about the way eBPF technology is developed by the Linux kernel community and contributors to the Linux BPF subsystem. The foundation’s activities are directed by the BPF Steering Committee, which is entirely composed of the technical experts who build the technology, including the Linux kernel BPF maintainers and representatives from other core eBPF projects.</p>&#13;
<p>The eBPF Foundation focuses on eBPF as a technology platform and the ecosystem of tools that enable eBPF development. Projects that build on top of eBPF looking for neutral ownership may find a better home in other foundations. For example, Cilium, Pixie, and Falco are all part of the CNCF, which makes sense as they are all intended to be used in cloud native environments.</p>&#13;
<p>One of the key drivers of this collaboration beyond the existing Linux maintainers was the interest that Microsoft had in developing eBPF within the Windows operating system. This brings about a need to define a standard for eBPF,<sup><a data-type="noteref" href="ch11.html#ch11fn2" id="ch11fn2-marker">2</a></sup> such that programs written for one OS can be used on another. This work is being done under the auspices of the eBPF Foundation.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="eBPF for Windows" data-type="sect1"><div class="sect1" id="ebpf_for_windows">&#13;
<h1>eBPF for Windows</h1>&#13;
<p><a contenteditable="false" data-primary="eBPF for Windows" data-type="indexterm" id="ch11.html1"/><a contenteditable="false" data-primary="Microsoft (eBPF for Windows)" data-type="indexterm" id="ch11.html3"/><a contenteditable="false" data-primary="Windows, eBPF for" data-type="indexterm" id="ch11.html4"/>Work is well underway at Microsoft to support <a href="https://oreil.ly/ArwkR">eBPF for Windows</a>. As I write this in the closing months of 2022, there are already <a href="https://oreil.ly/H-0dv">functional demos</a> that show Cilium Layer 4 load balancing and eBPF-based connection tracking running on Windows.</p>&#13;
<p>I’ve said before that eBPF programming is kernel programming, and at first glance it might seem unintuitive that a program written to run in the Linux kernel and that has access to Linux kernel data structures would in any way be able to operate in an entirely different operating system. But in practice, particularly when it comes to networking, all operating systems will have quite a lot in common. A network packet has the same structure whether it was created on a Windows or Linux machine, and the layers of the network stack have to be handled the same way.</p>&#13;
<p>You’ll also recall that eBPF programs consist of a set of bytecode instructions that are processed by a virtual machine (VM) implemented within the kernel. That VM can be implemented within Windows too!</p>&#13;
<p><a data-type="xref" href="#architectural_overview_of_ebpf_for_wind">Figure 11-1</a> shows the eBPF for Windows architectural overview, taken from <a href="https://oreil.ly/Ii4j2">the project’s GitHub repo</a>. As you can see from this diagram, eBPF for Windows reuses some open source components from the existing eBPF ecosystem, such as <em>libbpf</em>, and the support in Clang for producing eBPF bytecode. The Linux kernel is licensed under GPL, and Windows is proprietary, so the Windows project can’t reuse any parts of the Linux kernel’s implementation of the verifier.<sup><a data-type="noteref" href="ch11.html#ch11fn3" id="ch11fn3-marker">3</a></sup> Instead, it uses the <a href="https://vbpf.github.io">PREVAIL verifier</a> and the <a href="https://oreil.ly/btrkJ">uBPF JIT <span class="keep-together">compiler</span></a> (both of which are permissively licensed so that they can be used by a broader range of projects and organizations).</p>&#13;
<figure><div class="figure" id="architectural_overview_of_ebpf_for_wind">&#13;
<img alt="Architectural overview of eBPF for Windows, taken from https://oreil.ly/HxKsu" src="assets/lebp_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>Architectural overview of eBPF for Windows, adapted from <a href="https://oreil.ly/HxKsu"><em class="hyperlink">https://oreil.ly/HxKsu</em></a></h6>&#13;
</div></figure>&#13;
<p>One interesting difference is that eBPF code is verified and JIT-compiled in a Windows Secure environment in user space rather than within the kernel (the uBPF interpreter shown in the kernel in <a data-type="xref" href="#architectural_overview_of_ebpf_for_wind">Figure 11-1</a> is used only in debug builds and not production environments).</p>&#13;
<p class="pagebreak-before">It would be unrealistic to expect that every single eBPF program written to run on Linux will work on Windows. But this isn’t so different from the challenge of getting eBPF programs to run on different Linux kernel versions: even with CO-RE support, internal kernel data structures can be changed as well as added or removed between versions. It is the eBPF programmer’s job to handle these possibilities gracefully.<a contenteditable="false" data-primary="" data-startref="ch11.html4" data-type="indexterm" id="idm46123190358016"/><a contenteditable="false" data-primary="" data-startref="ch11.html3" data-type="indexterm" id="idm46123190356640"/><a contenteditable="false" data-primary="" data-startref="ch11.html1" data-type="indexterm" id="idm46123190355264"/></p>&#13;
<p>Speaking of changes to the Linux kernel, what changes can we expect to see in eBPF in the coming years?</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Linux eBPF Evolution" data-type="sect1"><div class="sect1" id="linux_ebpf_evolution">&#13;
<h1>Linux eBPF Evolution</h1>&#13;
<p>The capabilities of eBPF have evolved with practically every kernel release since 3.15. If you want to know what features are available in any given version, the BCC project maintains a <a href="https://oreil.ly/4H5hU">useful list</a>. And I certainly expect more additions over the coming years.</p>&#13;
<p>The best way to predict what’s coming is simply to listen to the people who are working on it. For example, at the 2022 Linux Plumbers Conference, eBPF maintainer Alexei Starovoitov gave a talk discussing how he expects to see the C language used by eBPF programs to evolve.<sup><a data-type="noteref" href="ch11.html#ch11fn4" id="ch11fn4-marker">4</a></sup> We’ve already seen eBPF evolve from supporting a few thousand instructions to practically unlimited complexity, with the addition of support for loops and an ever-increasing set of BPF helper functions. As additional capabilities are added into the C that’s supported, and with the support of the verifier, eBPF C could evolve to allow all the flexibility of developing kernel modules, but with the safety and dynamic loading characteristics of eBPF.</p>&#13;
<p>Some of the other ideas being discussed and developed for new eBPF features and capabilities include:</p>&#13;
<dl>&#13;
<dt>Signed eBPF programs</dt>&#13;
<dd>Software supply chain security has been a hot topic for the past few years, and a key element is the ability to check that a program you’re thinking of running comes from the expected source and has not been tampered with. One way to achieve this is, in general, to validate a cryptographic signature that accompanies a program. You might think this is something the kernel could do for eBPF programs, perhaps as part of the verification step, but unfortunately this is not straightforward! As you’ve seen in this book, user space loaders dynamically adjust programs with information about where maps are located, and for CO-RE purposes, which from a signing perspective is hard to distinguish from malicious modifications. This is a problem for which the eBPF community is <a href="https://oreil.ly/ns03-">keen to find a solution</a>.</dd>&#13;
<dt>Long-lived kernel pointers</dt>&#13;
<dd>An eBPF program can retrieve a pointer to a kernel object using a helper function or a kfunc, but a pointer is valid only during that execution of the program. The pointer cannot be stored in a map for later retrieval. The idea of <a href="https://oreil.ly/fWVdo">typed pointer support</a> will allow for more flexibility in this area.</dd>&#13;
<dt>Memory allocation</dt>&#13;
<dd>It’s not safe for eBPF programs to simply call memory allocation functions like <code>kmalloc()</code>, but there is <a href="https://oreil.ly/Yxxc5">a proposal that suggests</a> an eBPF-specific alternative.</dd>&#13;
</dl>&#13;
<p>When will you be able to take advantage of new eBPF features as they emerge? As an end user, the features you’re able to take advantage of depend on the version of the kernel you’re running in production, and as I discussed in <a data-type="xref" href="ch01.html#what_is_ebpf_and_why_is_it_importantque">Chapter 1</a>, it can take several years for kernel releases to make it to stable distributions of Linux. As an individual you might opt for a bleeding-edge kernel, but the vast majority of organizations running server deployments use a stable, supported version. eBPF programmers have to take into account that if they write code that takes advantage of the newest features added to the kernel, the features are unlikely to be usable in most production environments for some years to come. Some organizations will have sufficiently urgent needs that it’s worth rolling out newer kernel versions more quickly in order to early-adopt new eBPF features.</p>&#13;
<p>For example, in another forward-looking talk on <a href="https://oreil.ly/IvPgd">building tomorrow’s networking</a>, Daniel Borkmann discussed a feature called <em>Big TCP</em>. This was added to Linux in version 5.19 to enable network speeds of 100 GBit/s (and faster) by batching up network packets to be processed in the kernel. Most Linux distributions won’t support a kernel this recent for a few years, but for specialist organizations dealing with large amounts of network traffic, it might well be worth upgrading sooner. Adding Big TCP support into eBPF and Cilium today means it’s available for those massive-scale users, even if it’s not something that can be enabled by most of us for a while.</p>&#13;
<p>Since eBPF allows kernel code to be adjusted dynamically, it’s reasonable to expect it to be used to address problems “in the field.” In <a data-type="xref" href="ch09.html#ebpf_for_security">Chapter 9</a> you read about using eBPF to mitigate kernel vulnerabilities; work is also underway to use eBPF to help support hardware devices such as <a href="https://oreil.ly/JVYcY">human interface devices</a> like mice, keyboards, and game controllers. This builds on existing support for decoding the protocols used by infrared controllers that I mentioned in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>.</p>&#13;
</div></section>&#13;
<section class="pagebreak-before" data-pdf-bookmark="eBPF Is a Platform, Not a Feature" data-type="sect1"><div class="sect1" id="ebpf_is_a_platformcomma_not_a_feature">&#13;
<h1 class="less_space">eBPF Is a Platform, Not a Feature</h1>&#13;
<p>Coming up to a decade ago, the hot new technology was containers, and it seemed as though everyone was talking about what they were and what advantages they would bring. We’re at a similar stage with eBPF today, with lots of conference talks and blog posts—several of which I’ve referred to in this book—extolling the benefits of eBPF. Today, containers are part of daily life for many developers, whether they’re running code locally using Docker or other container runtimes, or deploying code to Kubernetes environments. Will eBPF become part of everyone’s regular toolkit too?</p>&#13;
<p>The answer, I believe, is no—or at least, not directly. Most users won’t write eBPF programs directly or manipulate them manually with utilities like <code>bpftool</code>. But they’ll interact regularly with tools built using eBPF, whether that’s for performance measurement, debugging, networking, security, tracing, or a whole host of other capabilities yet to be implemented using eBPF. Users might not be aware that they’re using eBPF, much as they might not know that when they use containers, they’re using kernel features like namespaces and cgroups.</p>&#13;
<p>Today, projects and vendors with knowledge of eBPF highlight their use of it because it’s so powerful and implies many advantages. As eBPF-based projects and products gain traction and market share, eBPF is becoming the de facto default technology platform for infrastructure tooling.</p>&#13;
<p>Knowledge of eBPF programming is—and will continue to be—a sought-after but relatively rare skill, just as kernel development today is much less common than developing, say, business applications or games. If you enjoy diving into the lower levels of systems and want to build essential infrastructure tooling, eBPF skills will serve you well. I hope this book has been of some assistance on your eBPF journey!</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="further_reading">&#13;
<h5>Further Reading</h5>&#13;
<p>Throughout this book I have provided references to specific articles and documentation pages. Here is a list of some additional resources to help you on your eBPF <span class="keep-together">journey</span>:</p>&#13;
<ul>&#13;
<li><p>The eBPF community site <a href="http://ebpf.io"><em>ebpf.io</em></a></p></li>&#13;
<li><p>The BPF and XDP reference in the <a href="https://docs.cilium.io">Cilium documentation</a></p></li>&#13;
<li><p><a href="https://oreil.ly/q8xh3">Linux kernel documentation on BPF</a></p></li>&#13;
<li><p><a href="https://www.brendangregg.com">Brendan Gregg’s website</a> on using eBPF for performance and observability</p></li>&#13;
<li><p><a href="https://nakryiko.com">Andrii Nakryiko’s website</a>, particularly for more information on CO-RE and <em>libbpf</em></p></li>&#13;
<li><p><a class="orm:hideurl" href="https://lwn.net">Lwn.net</a>, a wonderful resource for updates to the Linux kernel, including the BPF subsystem</p></li>&#13;
<li><p><a href="http://elixir.bootlin.com">Elixir.bootlin.com</a>, where you can browse the Linux source code</p></li>&#13;
<li><p><a href="https://oreil.ly/2AATZ">eCHO</a>, a weekly livestream covering topics from across the eBPF and Cilium community (in which this author is a regular presenter)</p></li>&#13;
</ul>&#13;
</div></aside>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="conclusion">&#13;
<h1>Conclusion</h1>&#13;
<p>Congratulations on reaching the end of this book!</p>&#13;
<p>I hope that reading <em>Learning eBPF</em> has given you insight into the power of eBPF. Perhaps it has inspired you to write eBPF code yourself or experiment with some of the tools I’ve discussed. If you’ve decided to do some eBPF programming, I hope the book has given you some confidence about how to get started. And if you have been completing the exercises as you worked through the book, bravo!</p>&#13;
<p>If you’re excited about eBPF there are plenty of ways to get involved in the community. The best starting point is the website <a href="http://ebpf.io">ebpf.io</a>. This will point you to the latest news, projects, events, and happenings, and also to the <a href="http://ebpf.io/slack">eBPF Slack</a> channel where you’re likely to find someone with the expertise to answer any questions you might have.</p>&#13;
<p>I welcome your feedback, comments, and any corrections to this text. You can provide your input through the GitHub repository that accompanies this book: <a class="orm:hideurl" href="https://github.com/lizrice/learning-ebpf"><em>github.com/lizrice/learning-ebpf</em></a>. I’d also be happy to hear your comments directly. You can find me as @lizrice in many places across the internet.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch11fn1"><sup><a href="ch11.html#ch11fn1-marker">1</a></sup> Shout-out to <a contenteditable="false" data-primary="Borkmann, Daniel" data-type="indexterm" id="idm46123190388944"/><a contenteditable="false" data-primary="Nakryiko, Andrii" data-type="indexterm" id="idm46123190387808"/><a contenteditable="false" data-primary="Starovoitov, Alexei " data-type="indexterm" id="idm46123190386704"/>Alexei Starovoitov and Andrii Nakryiko from Meta, and Daniel Borkmann from Isovalent, who maintain the BPF subtree in the Linux kernel.</p><p data-type="footnote" id="ch11fn2"><sup><a href="ch11.html#ch11fn2-marker">2</a></sup> <a href="https://oreil.ly/4bo6Y">Dave Thaler presented on the state of this standardization work</a> at the Linux Plumbers Conference.</p><p data-type="footnote" id="ch11fn3"><sup><a href="ch11.html#ch11fn3-marker">3</a></sup> Well, it <em>could</em>, but doing so would require Microsoft to also release the Windows source code under the GPL license.</p><p data-type="footnote" id="ch11fn4"><sup><a href="ch11.html#ch11fn4-marker">4</a></sup> Alexei Starovoitov discusses the journey of BPF from restricted C language to extended and safe C <a href="https://oreil.ly/xunKW">in this video</a>.</p></div></div></section></body></html>