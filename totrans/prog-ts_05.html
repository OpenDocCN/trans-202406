<html><head></head><body><section data-pdf-bookmark="Chapter 5. Classes and Interfaces" data-type="chapter" epub:type="chapter"><div class="chapter" id="classes">&#13;
<h1><span class="label">Chapter 5. </span>Classes and Interfaces</h1>&#13;
&#13;
&#13;
<p>If you’re like most programmers coming from an object-oriented programming language, classes are your bread and butter.<a data-primary="classes" data-type="indexterm" id="ix_class"/> Classes are how you organize and think about your code, and they serve as your primary unit of encapsulation. You’ll be pleased to learn that TypeScript classes borrow heavily from C#, and support things like visibility modifiers, property initializers, polymorphism, decorators, and interfaces. But because TypeScript classes compile down to regular JavaScript classes, you can also express  JavaScript idioms like mixins in a typesafe way.</p>&#13;
&#13;
<p>Some of TypeScript’s class features, like property initializers and decorators, are supported by JavaScript classes too,<sup><a data-type="noteref" href="ch05.html#idm46304973683464" id="idm46304973683464-marker">1</a></sup> and so generate runtime code. Other features, like visibility modifiers, interfaces, and generics, are TypeScript-only features that just exist at compile time, and don’t generate any code when you compile your application to JavaScript.</p>&#13;
&#13;
<p>In this chapter I’ll guide you through an extended example of how we work with classes in TypeScript, so that you can gain some intuition not only for TypeScript’s object-oriented language features, but for how and why we use them. Try to follow along, entering the code in your code editor as we go.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Classes and Inheritance" data-type="sect1"><div class="sect1" id="classes-and-inheritance">&#13;
<h1>Classes and Inheritance</h1>&#13;
&#13;
<p>We’re going to build a chess engine.<a data-primary="classes" data-secondary="and inheritance" data-type="indexterm" id="ix_classinh"/><a data-primary="inheritance" data-type="indexterm" id="ix_inherit"/> Our engine will model a game of chess and provide an API for two players to take turns making moves.</p>&#13;
&#13;
<p class="pagebreak-before">We’ll start by sketching out the types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Represents a chess game</code>&#13;
<code class="kr">class</code> <code class="nx">Game</code> <code class="p">{}</code>&#13;
&#13;
<code class="c1">// A chess piece</code>&#13;
<code class="kr">class</code> <code class="nx">Piece</code> <code class="p">{}</code>&#13;
&#13;
<code class="c1">// A set of coordinates for a piece</code>&#13;
<code class="kr">class</code> <code class="nx">Position</code> <code class="p">{}</code></pre>&#13;
&#13;
<p>There are six types of pieces:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// ...</code>&#13;
<code class="kr">class</code> <code class="nx">King</code> <code class="kr">extends</code> <code class="nx">Piece</code> <code class="p">{}</code>&#13;
<code class="kr">class</code> <code class="nx">Queen</code> <code class="kr">extends</code> <code class="nx">Piece</code> <code class="p">{}</code>&#13;
<code class="kr">class</code> <code class="nx">Bishop</code> <code class="kr">extends</code> <code class="nx">Piece</code> <code class="p">{}</code>&#13;
<code class="kr">class</code> <code class="nx">Knight</code> <code class="kr">extends</code> <code class="nx">Piece</code> <code class="p">{}</code>&#13;
<code class="kr">class</code> <code class="nx">Rook</code> <code class="kr">extends</code> <code class="nx">Piece</code> <code class="p">{}</code>&#13;
<code class="kr">class</code> <code class="nx">Pawn</code> <code class="kr">extends</code> <code class="nx">Piece</code> <code class="p">{}</code></pre>&#13;
&#13;
<p>Every piece has a color and a current position. In chess, positions are modeled as (letter, number) coordinate pairs; letters run from left to right along the x-axis, numbers from bottom to top along the y-axis (<a data-type="xref" href="#standard-alg-fig">Figure 5-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="standard-alg-fig">&#13;
<img alt="prts 0501" src="assets/prts_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>Standard algebraic notation in chess: A–H (the x-axis) are called “files” and 1–8 (the inverted y-axis) “ranks”</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Let’s add color and position to our <code>Piece</code> class:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<strong><code class="nx">type</code><code> </code><code class="nx">Color</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Black'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'White'</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">File</code><code> </code><code class="o">=</code><code> </code><code class="s1">'A'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'B'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'C'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'D'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'E'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'F'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'G'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'H'</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Rank</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code> </code><code class="o">|</code><code> </code><code class="mi">2</code><code> </code><code class="o">|</code><code> </code><code class="mi">3</code><code> </code><code class="o">|</code><code> </code><code class="mi">4</code><code> </code><code class="o">|</code><code> </code><code class="mi">5</code><code> </code><code class="o">|</code><code> </code><code class="mi">6</code><code> </code><code class="o">|</code><code> </code><code class="mi">7</code><code> </code><code class="o">|</code><code> </code><code class="mi">8</code></strong><code> </code><a class="co" href="#callout_item_classes__amp__oop_CO1-1" id="icon_in_code_classes__amp__oop_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="kr noBold">class</code><code> </code><code class="nx">Position</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="kr">constructor</code><code class="p">(</code><code>&#13;
    </code><code class="kr">private</code><code> </code><code class="nx">file</code><code>: </code><code class="kt">File</code><code class="p">,</code></strong><code> </code><a class="co" href="#callout_item_classes__amp__oop_CO1-2" id="icon_in_code_classes__amp__oop_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
    </code><strong><code class="kr">private</code><code> </code><code class="nx">rank</code><code>: </code><code class="kt">Rank</code><code>&#13;
  </code><code class="p">)</code><code> </code><code class="p">{</code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kr noBold">class</code><code> </code><code class="nx">Piece</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="kr">protected</code><code> </code><code class="nx">position</code><code>: </code><code class="kt">Position</code></strong><code> </code><a class="co" href="#callout_item_classes__amp__oop_CO1-3" id="icon_in_code_classes__amp__oop_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><strong><code class="kr">constructor</code><code class="p">(</code><code>&#13;
    </code><code class="kr">private</code><code> </code><code class="nx">readonly</code><code> </code><code class="nx">color</code><code>: </code><code class="kt">Color</code><code class="p">,</code></strong><code> </code><a class="co" href="#callout_item_classes__amp__oop_CO1-4" id="icon_in_code_classes__amp__oop_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
    </code><strong><code class="nx">file</code><code>: </code><code class="kt">File</code><code class="p">,</code><code>&#13;
    </code><code class="nx">rank</code><code>: </code><code class="kt">Rank</code><code>&#13;
  </code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">this</code><code class="p">.</code><code class="nx">position</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">Position</code><code class="p">(</code><code class="nx">file</code><code class="p">,</code><code> </code><code class="nx">rank</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code>&#13;
</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#icon_in_code_classes__amp__oop_CO1-1" id="callout_item_classes__amp__oop_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Since there are relatively few colors, ranks, and files, we can manually enumerate their possible values as type literals. This will let us squeeze out some extra safety by constraining these types’ domains from all strings and all numbers to a handful of very specific strings and numbers.</p></dd>&#13;
<dt><a class="co" href="#icon_in_code_classes__amp__oop_CO1-2" id="callout_item_classes__amp__oop_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>private</code> <em>access modifier</em> in the constructor automatically assigns the parameter to <code>this</code> (<code>this.file</code> and so on), and sets its visibility to private, meaning that code within a <code>Piece</code> instance can read and write to it, but code outside of a <code>Piece</code> instance can’t. Different instances of <code>Piece</code> can access each other’s private members; instances of any other class—even a subclass of <code>Piece</code>—can’t.</p></dd>&#13;
<dt><a class="co" href="#icon_in_code_classes__amp__oop_CO1-3" id="callout_item_classes__amp__oop_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>We declare the instance variable <code>position</code> as <code>protected</code>. Like <code>private</code>, <code>protected</code> assigns the property to <code>this</code>, but unlike <code>private</code>, <code>protected</code> makes the property visible both to instances of <code>Piece</code> and to instances of any subclass of <code>Piece</code>. We didn’t assign <code>position</code> a value when declaring it, so we have to assign a value to it in <code>Piece</code>’s constructor function. If we hadn’t assigned it a value in the constructor, TypeScript would have told us that the variable is not <em>definitely assigned</em>, i.e., we said it’s of type <code>T</code>, but it’s actually <code>T | undefined</code> because it’s not assigned a value in a property initializer or in the constructor—so we would need to update its signature to indicate that it’s not necessarily a <code>Position</code>, but it might also be <code>undefined</code>.</p></dd>&#13;
<dt><a class="co" href="#icon_in_code_classes__amp__oop_CO1-4" id="callout_item_classes__amp__oop_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p><code>new Piece</code> takes three parameters: <code>color</code>, <code>file</code>, and <code>rank</code>. We added two modifiers to <code>color</code>: <code>private</code>, meaning assign it to <code>this</code> and make sure it’s only accessible from an instance of <code>Piece</code>, and <code>readonly</code>, meaning that after this initial assignment it can only be read and can’t be written anymore.</p></dd>&#13;
</dl>&#13;
<div data-type="tip"><h1>TSC Flags: strictNullChecks and strictPropertyInitialization</h1>&#13;
<p>To opt into definite assignment checks for class instance variables, enable <code>strictNullChecks</code> and <code>strictPropertyInitialization</code> flags in your <em>tsconfig.json</em>.<a data-primary="TSC compiler" data-secondary="strictNullChecks and strictPropertyInitialization flags" data-type="indexterm" id="idm46304973439656"/><a data-primary="strictNullChecks and strictPropertyInitialization TSC flags" data-type="indexterm" id="idm46304973438552"/> If you’re already using the <code>strict</code> flag, you’re good to go.</p>&#13;
</div>&#13;
&#13;
<p>TypeScript supports three access modifiers <a data-primary="classes" data-secondary="and inheritance" data-tertiary="access modifiers for properties and methods" data-type="indexterm" id="idm46304973436968"/><a data-primary="methods" data-secondary="access modifiers for" data-type="indexterm" id="idm46304973435592"/><a data-primary="properties" data-secondary="access modifiers for" data-type="indexterm" id="idm46304973434648"/>for properties and methods on a class:</p>&#13;
<dl>&#13;
<dt><code>public</code></dt>&#13;
<dd>&#13;
<p>Accessible from anywhere. <a data-primary="public (access modifier)" data-type="indexterm" id="idm46304973431752"/>This is the default access level.</p>&#13;
</dd>&#13;
<dt><code>protected</code></dt>&#13;
<dd>&#13;
<p>Accessible from instances of this class and its subclasses.<a data-primary="protected (access modifier)" data-type="indexterm" id="idm46304973429448"/></p>&#13;
</dd>&#13;
<dt><code>private</code></dt>&#13;
<dd>&#13;
<p>Accessible from instances of this class only.<a data-primary="private (access modifier)" data-type="indexterm" id="idm46304973427192"/></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Using access modifiers, you can design classes that don’t expose too much information about their implementations, and instead expose well-defined APIs for others to use.</p>&#13;
&#13;
<p>We’ve defined a <code>Piece</code> class, but we don’t want users to instantiate a new <code>Piece</code> directly—we want them to extend it to create a <code>Queen</code>, a <code>Bishop</code>, and so on, and instantiate <em>that</em>. <a data-primary="classes" data-secondary="and inheritance" data-tertiary="abstract classes" data-type="indexterm" id="idm46304973422888"/><a data-primary="abstract classes" data-type="indexterm" id="idm46304973421608"/>We can use the type system to enforce that for us, using the <code>abstract</code> keyword:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><strong><code class="kr">abstract</code></strong><code> </code><code class="kr">class</code><code> </code><code class="nx">Piece</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">constructor</code><code class="p">(</code><code>&#13;
    </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code></pre>&#13;
&#13;
<p>Now if you try to instantiate a <code>Piece</code> directly,<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2511" data-type="indexterm" id="idm46304973397960"/> TypeScript complains:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="k">new</code> <code class="nx">Piece</code><code class="p">(</code><code class="s1">'White'</code><code class="p">,</code> <code class="s1">'E'</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>  <code class="c1">// Error TS2511: Cannot create an instance</code>&#13;
                            <code class="c1">// of an abstract class.</code></pre>&#13;
&#13;
<p>The <code>abstract</code> keyword means that you can’t instantiate the class directly, but it doesn’t mean you can’t define some methods on it:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="kr">abstract</code><code> </code><code class="kr">class</code><code> </code><code class="nx">Piece</code><code> </code><code class="p">{</code><code>&#13;
  </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code>  </code><strong><code class="nx">moveTo</code><code class="p">(</code><code class="nx">position</code><code>: </code><code class="kt">Position</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">this</code><code class="p">.</code><code class="nx">position</code><code> </code><code class="o">=</code><code> </code><code class="nx">position</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="kr">abstract</code><code> </code><code class="nx">canMoveTo</code><code class="p">(</code><code class="nx">position</code><code>: </code><code class="kt">Position</code><code class="p">)</code><code class="o">:</code><code> </code><code class="kr">boolean</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Our <code>Piece</code> class now:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Tells its subclasses that they have to implement a method called <code>canMoveTo</code> that is compatible with the given signature. If a class extends <code>Piece</code> but forgets to implement the abstract <code>canMoveTo</code> method, that’s a type error at compile time: when you implement an abstract class, you have to implement its abstract methods too.<a data-primary="methods" data-secondary="abstract" data-type="indexterm" id="idm46304973310616"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Comes with a default implementation for <code>moveTo</code> (which its subclasses can override if they want). We didn’t put an access modifier on <code>moveTo</code>, so it’s <code>public</code> by default, meaning it’s readable and writable from any other code.<a data-primary="public (access modifier)" data-secondary="methods" data-type="indexterm" id="idm46304973307416"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s update <code>King</code> to implement <code>canMoveTo</code>, to satisfy this new requirement. We’ll also implement a <code>distanceFrom</code> function for convenience, so we can easily compute the distance between two pieces:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="kr">class</code><code> </code><code class="nx">Position</code><code> </code><code class="p">{</code><code>&#13;
  </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code>  </code><strong><code class="nx">distanceFrom</code><code class="p">(</code><code class="nx">position</code><code>: </code><code class="kt">Position</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="p">{</code><code>&#13;
      </code><code class="nx">rank</code><code>: </code><code class="kt">Math.abs</code><code class="p">(</code><code class="nx">position</code><code class="p">.</code><code class="nx">rank</code><code> </code><code class="o">-</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">rank</code><code class="p">)</code><code class="p">,</code><code>&#13;
      </code><code class="nx">file</code><code>: </code><code class="kt">Math.abs</code><code class="p">(</code><code class="nx">position</code><code class="p">.</code><code class="nx">file</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code> </code><code class="o">-</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">file</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code class="p">)</code><code>&#13;
    </code><code class="p">}</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kr">class</code><code> </code><code class="nx">King</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">Piece</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="nx">canMoveTo</code><code class="p">(</code><code class="nx">position</code><code>: </code><code class="kt">Position</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="kd">let</code><code> </code><code class="nx">distance</code><code> </code><code class="o">=</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">position</code><code class="p">.</code><code class="nx">distanceFrom</code><code class="p">(</code><code class="nx">position</code><code class="p">)</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="nx">distance</code><code class="p">.</code><code class="nx">rank</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">2</code><code> </code><code class="o">&amp;&amp;</code><code> </code><code class="nx">distance</code><code class="p">.</code><code class="nx">file</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">2</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>When we make a new game, we’ll automatically create a board and some pieces:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="kr">class</code><code> </code><code class="nx">Game</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="kr">private</code><code> </code><code class="nx">pieces</code><code> </code><code class="o">=</code><code> </code><code class="nx">Game</code><code class="p">.</code><code class="nx">makePieces</code><code class="p">(</code><code class="p">)</code><code>&#13;
&#13;
  </code><code class="kr">private</code><code> </code><code class="kr">static</code><code> </code><code class="nx">makePieces() {</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="p">[</code><code>&#13;
&#13;
      </code><code class="c1">// Kings&#13;
</code><code>      </code><code class="k">new</code><code> </code><code class="nx">King</code><code class="p">(</code><code class="s1">'White'</code><code class="p">,</code><code> </code><code class="s1">'E'</code><code class="p">,</code><code> </code><code class="mi">1</code><code class="p">)</code><code class="p">,</code><code>&#13;
      </code><code class="k">new</code><code> </code><code class="nx">King</code><code class="p">(</code><code class="s1">'Black'</code><code class="p">,</code><code> </code><code class="s1">'E'</code><code class="p">,</code><code> </code><code class="mi">8</code><code class="p">)</code><code class="p">,</code><code>&#13;
&#13;
      </code><code class="c1">// Queens&#13;
</code><code>      </code><code class="k">new</code><code> </code><code class="nx">Queen</code><code class="p">(</code><code class="s1">'White'</code><code class="p">,</code><code> </code><code class="s1">'D'</code><code class="p">,</code><code> </code><code class="mi">1</code><code class="p">)</code><code class="p">,</code><code>&#13;
      </code><code class="k">new</code><code> </code><code class="nx">Queen</code><code class="p">(</code><code class="s1">'Black'</code><code class="p">,</code><code> </code><code class="s1">'D'</code><code class="p">,</code><code> </code><code class="mi">8</code><code class="p">)</code><code class="p">,</code><code>&#13;
&#13;
      </code><code class="c1">// Bishops&#13;
</code><code>      </code><code class="k">new</code><code> </code><code class="nx">Bishop</code><code class="p">(</code><code class="s1">'White'</code><code class="p">,</code><code> </code><code class="s1">'C'</code><code class="p">,</code><code> </code><code class="mi">1</code><code class="p">)</code><code class="p">,</code><code>&#13;
      </code><code class="k">new</code><code> </code><code class="nx">Bishop</code><code class="p">(</code><code class="s1">'White'</code><code class="p">,</code><code> </code><code class="s1">'F'</code><code class="p">,</code><code> </code><code class="mi">1</code><code class="p">)</code><code class="p">,</code><code>&#13;
      </code><code class="k">new</code><code> </code><code class="nx">Bishop</code><code class="p">(</code><code class="s1">'Black'</code><code class="p">,</code><code> </code><code class="s1">'C'</code><code class="p">,</code><code> </code><code class="mi">8</code><code class="p">)</code><code class="p">,</code><code>&#13;
      </code><code class="k">new</code><code> </code><code class="nx">Bishop</code><code class="p">(</code><code class="s1">'Black'</code><code class="p">,</code><code> </code><code class="s1">'F'</code><code class="p">,</code><code> </code><code class="mi">8</code><code class="p">)</code><code class="p">,</code></strong><code>&#13;
&#13;
      </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code>    </code><strong><code class="p">]</code></strong><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Because of how strictly we typed <code>Rank</code> and <code>File</code>, if we had entered another letter (like <code>'J'</code>) or an out-of-range number (like <code>12</code>), TypeScript would have given us a compile-time error (<a data-type="xref" href="#typescript-valid-fig">Figure 5-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="typescript-valid-fig">&#13;
<img alt="prts 0502" src="assets/prts_0502.png"/>&#13;
<h6><span class="label">Figure 5-2. </span>TypeScript helps us stick to valid ranks and files</h6>&#13;
</div></figure>&#13;
&#13;
<p>This is enough to show off how TypeScript classes work—I’ll avoid getting into the nitty-gritty details like how to know when a knight can take a piece, how bishops move, and so on. If you’re ambitious, see if you can use what we’ve done so far as a starting point to implement the rest of the game yourself.</p>&#13;
&#13;
<p>To sum up:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Declare classes with the <code>class</code> keyword. Extend them with the <code>extends</code> keyword.<a data-primary="extends keyword" data-type="indexterm" id="idm46304972971480"/><a data-primary="class keyword" data-type="indexterm" id="idm46304972970872"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Classes can be either concrete or <code>abstract</code>. Abstract classes can have <code>abstract</code> methods and <code>abstract</code> properties.<a data-primary="abstract classes" data-type="indexterm" id="idm46304972974664"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Methods can be <code>private</code>, <code>protected</code>, or, by default, <code>public</code>. They can be instance methods or static methods.<a data-primary="methods" data-type="indexterm" id="idm46304972980216"/><a data-primary="instance methods" data-type="indexterm" id="idm46304972979512"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Classes can have instance properties, which can also be <code>private</code>, <code>protected</code>, or, by default, <code>public</code>. You can declare them in constructor parameters or as property initializers.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can mark instance properties as <code>readonly</code> when declaring them.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="super" data-type="sect1"><div class="sect1" id="idm46304973680744">&#13;
<h1>super</h1>&#13;
&#13;
<p>Like JavaScript, TypeScript supports <code>super</code> calls.<a data-primary="classes" data-secondary="super calls" data-type="indexterm" id="idm46304972986600"/><a data-primary="super calls" data-type="indexterm" id="idm46304972933032"/> If your child class overrides a method defined on its parent class (say, if <code>Queen</code> and <code>Piece</code> both implement the <code>take</code> method), the child instance can make a <code>super</code> call to call its parent’s version of the method (e.g., <code>super.take</code>). There are two kinds of <code>super</code> calls:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Method calls, like <code>super.take</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Constructor calls, which have the special form <code>super()</code> and can only be called from a constructor function. If your child class has a constructor function, you must call <code>super()</code> from the child’s constructor to correctly wire up the class (don’t worry, TypeScript will warn you if you forget; it’s like a cool futuristic robot elephant in that way).<a data-primary="constructors" data-secondary="super calls" data-type="indexterm" id="idm46304973019496"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Note that you can only access a parent class’s methods, and not its properties, with <code>super</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using this as a Return Type" data-type="sect1"><div class="sect1" id="this-in-return-type">&#13;
<h1>Using this as a Return Type</h1>&#13;
&#13;
<p>Just like you can use <code>this</code> as a value, you can also use it as a type (like we did in <a data-type="xref" href="ch04.html#typing-this">“Typing this”</a>). When working with classes, the <code>this</code> type can be useful for annotating methods’ return types.<a data-primary="classes" data-secondary="using this as return type" data-type="indexterm" id="idm46304973001688"/><a data-primary="this variable" data-secondary="using as method return type" data-type="indexterm" id="idm46304973005400"/><a data-primary="return types" data-secondary="this variable" data-type="indexterm" id="idm46304973004488"/></p>&#13;
&#13;
<p>For example, let’s build a simplified version of ES6’s <code>Set</code> data structure that supports two operations: adding a number to the set, and checking whether or not a given number is in the set. You use it like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">set</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code>&#13;
<code class="nx">set</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="nx">add</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="nx">add</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>&#13;
<code class="nx">set</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code> <code class="c1">// true</code>&#13;
<code class="nx">set</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code> <code class="c1">// false</code></pre>&#13;
&#13;
<p>Let’s define the <code>Set</code> class, starting with the <code>has</code> method:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">Set</code> <code class="p">{</code>&#13;
  <code class="nx">has</code><code class="p">(</code><code class="nx">value</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>How about <code>add</code>? When you call <code>add</code>, you get back an instance of <code>Set</code>. We could type that as:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">class</code><code> </code><code class="nx">Set</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">has</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">number</code><code class="p">)</code><code class="o">:</code><code> </code><code class="kr">boolean</code><code> </code><code class="p">{</code><code>&#13;
    </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
  </code><strong><code class="nx">add</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">number</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Set</code><code> </code><code class="p">{</code></strong><code>&#13;
    </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code>  </code><strong><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>So far, so good. What happens when we try to subclass <code>Set</code>?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">MutableSet</code> <code class="kr">extends</code> <code class="nx">Set</code> <code class="p">{</code>&#13;
  <code class="k">delete</code><code class="p">(</code><code class="nx">value</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Of course, <code>Set</code>’s <code>add</code> method still returns a <code>Set</code>, which we’ll need to override with <code>MutableSet</code> for our subclass:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">class</code><code> </code><code class="nx">MutableSet</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">Set</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">delete</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">number</code><code class="p">)</code><code class="o">:</code><code> </code><code class="kr">boolean</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
  </code><strong><code class="nx">add</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">number</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">MutableSet</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>This can get a bit tedious when working with classes that extend other classes—you have to override the signature for each method that returns <code>this</code>. And if you end up having to override each method to please the typechecker, what’s the point of inheriting from your base class at all?</p>&#13;
&#13;
<p>Instead, you can use <code>this</code> as a return type annotation to let TypeScript do the work for you:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">class</code><code> </code><code class="nx">Set</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">has</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">number</code><code class="p">)</code><code class="o">:</code><code> </code><code class="kr">boolean</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">add</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">number</code><code class="p">)</code><code class="o">:</code><code> </code><strong><code class="k">this</code></strong><code> </code><code class="p">{</code><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Now, you can remove the <code>add</code> override from <code>MutableSet</code>, since <code>this</code> in <code>Set</code> points to a <code>Set</code> instance, and <code>this</code> in <code>MutableSet</code> points to a <code>MutableSet</code> instance:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">MutableSet</code> <code class="kr">extends</code> <code class="nx">Set</code> <code class="p">{</code>&#13;
  <code class="k">delete</code><code class="p">(</code><code class="nx">value</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is a really convenient feature for working with chained APIs, like we do in <a data-type="xref" href="#builder-pattern">“Builder Pattern”</a>.<a data-primary="classes" data-startref="ix_class" data-type="indexterm" id="idm46304972570200"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="Interfaces" data-type="sect1"><div class="sect1" id="interfaces">&#13;
<h1>Interfaces</h1>&#13;
&#13;
<p>When you use classes, you will often find yourself using them with <em>interfaces</em>.</p>&#13;
&#13;
<p>Like type aliases, interfaces are a way to name a type so you don’t have to define it inline.<a data-primary="interfaces" data-type="indexterm" id="ix_intf"/> Type aliases and interfaces are mostly two syntaxes for the same thing (like function expressions and function declarations), but there are a few small differences.<a data-primary="type aliases" data-secondary="comparison with interfaces" data-type="indexterm" id="idm46304972564504"/><a data-primary="interfaces" data-secondary="comparison with type aliases" data-type="indexterm" id="idm46304972563592"/> Let’s start with what they have in common. Consider the following type alias:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Sushi</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">calories</code>: <code class="kt">number</code>&#13;
  <code class="nx">salty</code>: <code class="kt">boolean</code>&#13;
  <code class="nx">tasty</code>: <code class="kt">boolean</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It’s easy to rewrite it as an interface:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<strong><code class="kr">interface</code><code> </code><code class="nx">Sushi</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">calories</code><code>: </code><code class="kt">number</code><code>&#13;
  </code><code class="nx">salty</code><code>: </code><code class="kt">boolean</code><code>&#13;
  </code><code class="nx">tasty</code><code>: </code><code class="kt">boolean</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Everywhere you used your <code>Sushi</code> type alias, you can also use your <code>Sushi</code> interface. Both declarations define shapes, and those shapes are assignable to one another (in fact, they’re identical!).</p>&#13;
&#13;
<p>Things get more interesting when you start combining types. Let’s model another food in addition to <code>Sushi</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Cake</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">calories</code>: <code class="kt">number</code>&#13;
  <code class="nx">sweet</code>: <code class="kt">boolean</code>&#13;
  <code class="nx">tasty</code>: <code class="kt">boolean</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A lot of foods have calories and are tasty—not just <code>Sushi</code> and <code>Cake</code>. Let’s pull <code>Food</code> out into its own type, and redefine our foods in terms of it:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">Food</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">calories</code><code>: </code><code class="kt">number</code><code>&#13;
  </code><code class="nx">tasty</code><code>: </code><code class="kt">boolean</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Sushi</code><code> </code><code class="o">=</code><code> </code><strong><code class="nx">Food</code><code> </code><code class="o">&amp;</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">salty</code><code>: </code><code class="kt">boolean</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Cake</code><code> </code><code class="o">=</code><code> </code><strong><code class="nx">Food</code><code> </code><code class="o">&amp;</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">sweet</code><code>: </code><code class="kt">boolean</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Nearly equivalently, you can do that with interfaces too:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">interface</code><code> </code><code class="nx">Food</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">calories</code><code>: </code><code class="kt">number</code><code>&#13;
  </code><code class="nx">tasty</code><code>: </code><code class="kt">boolean</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">interface</code><code> </code><code class="nx">Sushi</code><code> </code><strong><code class="kr">extends</code><code> </code><code class="nx">Food</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">salty</code><code>: </code><code class="kt">boolean</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">interface</code><code> </code><code class="nx">Cake</code><code> </code><strong><code class="kr">extends</code><code> </code><code class="nx">Food</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">sweet</code><code>: </code><code class="kt">boolean</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Interfaces don’t have to extend other interfaces. In fact, an interface can extend any shape: an object <code>type</code>, a <code>class</code>, or another <code>interface</code>.<a data-primary="interfaces" data-secondary="extending objects, classes, or other interfaces" data-type="indexterm" id="idm46304972341000"/></p>&#13;
</div>&#13;
&#13;
<p>What are the differences between types and interfaces? There are three, and they’re subtle.</p>&#13;
&#13;
<p>The first is that type aliases are more general, in that their righthand side can be any type, including a type expression (a type, and maybe some type operators like <code>&amp;</code> or <code>|</code>); for an interface, the righthand side must be a shape. For example, there is no way to rewrite the following type aliases as interfaces:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="kt">number</code>&#13;
<code class="nx">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">A</code> <code class="o">|</code> <code class="kt">string</code></pre>&#13;
&#13;
<p>The second difference is that when you extend an interface, TypeScript will make sure that the interface you’re extending is assignable to your extension. For <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2430" data-type="indexterm" id="idm46304972303384"/>example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nx">A</code> <code class="p">{</code>&#13;
  <code class="nx">good</code><code class="p">(</code><code class="nx">x</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code>&#13;
  <code class="nx">bad</code><code class="p">(</code><code class="nx">x</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">B</code> <code class="kr">extends</code> <code class="nx">A</code> <code class="p">{</code>&#13;
  <code class="nx">good</code><code class="p">(</code><code class="nx">x</code>: <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code>&#13;
  <code class="nx">bad</code><code class="p">(</code><code class="nx">x</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code>  <code class="c1">// Error TS2430: Interface 'B' incorrectly extends</code>&#13;
<code class="p">}</code>                         <code class="c1">// interface 'A'. Type 'number' is not assignable</code>&#13;
                          <code class="c1">// to type 'string'.</code></pre>&#13;
&#13;
<p>This is not the case when you use <a data-primary="intersection types" data-type="indexterm" id="idm46304972248280"/>intersection types: if you turn the interfaces from the last example into type aliases and the <code>extends</code> into an intersection (<code>&amp;</code>), TypeScript will do its best to combine your extension with the type it’s extending, resulting in an overloaded signature for <code>bad</code> instead of a compile-time error (try it in your code <span class="keep-together">editor!</span>).</p>&#13;
&#13;
<p>When you’re modeling inheritance for object types, the assignability check that TypeScript does for interfaces can be a helpful tool to catch errors.</p>&#13;
&#13;
<p>The third difference is that multiple interfaces with the same name in the same scope are automatically merged; multiple <em>type aliases</em> with the same name in the same scope will throw a compile-time error. This is a feature called <em>declaration merging</em>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Declaration Merging" data-type="sect2"><div class="sect2" id="interface-merging">&#13;
<h2>Declaration Merging</h2>&#13;
&#13;
<p>Declaration merging is TypeScript’s way of automatically combining multiple declarations that share the same name.<a data-primary="declaration merging" data-type="indexterm" id="idm46304972210072"/><a data-primary="interfaces" data-secondary="declaration merging" data-type="indexterm" id="idm46304972209368"/>  It came up when we introduced enums (<a data-type="xref" href="ch03.html#enums">“Enums”</a>), and it also comes up when working with other features like <code>namespace</code> declarations (see <a data-type="xref" href="ch10.html#namespaces">“Namespaces”</a>). In this section we’ll briefly introduce declaration merging in the context of interfaces. For a deeper dive, head over to <a data-type="xref" href="ch10.html#namespace-merging">“Declaration Merging”</a>.</p>&#13;
&#13;
<p>For example, if you declare two identically named <code>User</code> interfaces, then TypeScript will automatically combine them for you into a single interface:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// User has a single field, name</code>&#13;
<code class="kr">interface</code> <code class="nx">User</code> <code class="p">{</code>&#13;
  <code class="nx">name</code>: <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// User now has two fields, name and age</code>&#13;
<code class="kr">interface</code> <code class="nx">User</code> <code class="p">{</code>&#13;
  <code class="nx">age</code>: <code class="kt">number</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">a</code>: <code class="kt">User</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Ashley'</code><code class="p">,</code>&#13;
  <code class="nx">age</code>: <code class="kt">30</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here’s what <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2300" data-type="indexterm" id="idm46304972184872"/>happens if you repeat that example with type aliases:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">User</code> <code class="o">=</code> <code class="p">{</code>  <code class="c1">// Error TS2300: Duplicate identifier 'User'.</code>&#13;
  <code class="nx">name</code>: <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">User</code> <code class="o">=</code> <code class="p">{</code>  <code class="c1">// Error TS2300: Duplicate identifier 'User'.</code>&#13;
  <code class="nx">age</code>: <code class="kt">number</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that the two interfaces can’t conflict; if one types <code>property</code> as a <code>T</code> and the other types it as a <code>U</code>, and <code>T</code> and <code>U</code> aren’t identical, then you’ll get an <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2717" data-type="indexterm" id="idm46304972144328"/>error:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nx">User</code> <code class="p">{</code>&#13;
  <code class="nx">age</code>: <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">User</code> <code class="p">{</code>&#13;
  <code class="nx">age</code>: <code class="kt">number</code>  <code class="c1">// Error TS2717: Subsequent property declarations must have</code>&#13;
<code class="p">}</code>              <code class="c1">// the same type. Property 'age' must be of type 'string',</code>&#13;
               <code class="c1">// but here has type 'number'.</code></pre>&#13;
&#13;
<p>And if your interface declares generics (skip ahead to <a data-type="xref" href="#class-generics">“Polymorphism”</a> to learn more),<a data-primary="generics" data-secondary="interface declaring" data-type="indexterm" id="idm46304972094136"/> those generics have to be declared the exact same way for two interfaces to be mergeable—down to the generic’s name!</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nx">User</code><code class="o">&lt;</code><code class="nx">Age</code> <code class="kr">extends</code> <code class="kt">number</code><code class="o">&gt;</code> <code class="p">{</code>  <code class="c1">// Error TS2428: All declarations of 'User'</code>&#13;
  <code class="nx">age</code>: <code class="kt">Age</code>                            <code class="c1">// must have identical type parameters.</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">User</code><code class="o">&lt;</code><code class="nx">Age</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">age</code>: <code class="kt">Age</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Interestingly, this <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2428" data-type="indexterm" id="idm46304972091496"/>is a rare place where TypeScript checks that two types are not only assignable, but <em>identical</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Implementations" data-type="sect2"><div class="sect2" id="idm46304972211800">&#13;
<h2>Implementations</h2>&#13;
&#13;
<p>When you declare a class, you can use the <code>implements</code> keyword to say that it satisfies a particular interface.<a data-primary="classes" data-secondary="implementing interfaces" data-type="indexterm" id="idm46304972020408"/><a data-primary="interfaces" data-secondary="implementation" data-type="indexterm" id="idm46304972019432"/><a data-primary="implements keyword" data-type="indexterm" id="idm46304972018488"/> Like other explicit type annotations, this is a convenient way to add a type-level constraint that your class is implemented correctly as closely as possible to the implementation itself, so that the error from an incorrect implementation doesn’t show up downstream where it’s less clear why it was thrown. It’s also a familiar way to implement common design patterns like adapters, factories, and strategies (see the end of this chapter for some examples).</p>&#13;
&#13;
<p>Here’s what that looks like:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nx">Animal</code> <code class="p">{</code>&#13;
  <code class="nx">eat</code><code class="p">(</code><code class="nx">food</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
  <code class="nx">sleep</code><code class="p">(</code><code class="nx">hours</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Cat</code> <code class="kr">implements</code> <code class="nx">Animal</code> <code class="p">{</code>&#13;
  <code class="nx">eat</code><code class="p">(</code><code class="nx">food</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Ate some'</code><code class="p">,</code> <code class="nx">food</code><code class="p">,</code> <code class="s1">'. Mmm!'</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">sleep</code><code class="p">(</code><code class="nx">hours</code>: <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Slept for'</code><code class="p">,</code> <code class="nx">hours</code><code class="p">,</code> <code class="s1">'hours'</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>Cat</code> has to implement every method that <code>Animal</code> declares, and can implement more methods and properties on top if it wants.</p>&#13;
&#13;
<p>Interfaces can declare instance properties, but they can’t declare visibility modifiers (<code>private</code>, <code>protected</code>, and <code>public</code>) and they can’t use the <code>static</code> keyword. You can also mark instance properties as <code>readonly</code>, just like we did for object types in Objects (in <a data-type="xref" href="ch03.html#types">Chapter 3</a>):</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">interface</code><code> </code><code class="nx">Animal</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="nx">readonly</code><code> </code><code class="nx">name</code><code>: </code><code class="kt">string</code></strong><code>&#13;
  </code><code class="nx">eat</code><code class="p">(</code><code class="nx">food</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">void</code><code>&#13;
  </code><code class="nx">sleep</code><code class="p">(</code><code class="nx">hours</code><code>: </code><code class="kt">number</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">void</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>You’re not limited to implementing just one interface—you can implement as many as you want:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">interface</code><code> </code><code class="nx">Animal</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">readonly</code><code> </code><code class="nx">name</code><code>: </code><code class="kt">string</code><code>&#13;
  </code><code class="nx">eat</code><code class="p">(</code><code class="nx">food</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">void</code><code>&#13;
  </code><code class="nx">sleep</code><code class="p">(</code><code class="nx">hours</code><code>: </code><code class="kt">number</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">void</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><strong><code class="kr">interface</code><code> </code><code class="nx">Feline</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">meow</code><code class="p">(</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">void</code><code>&#13;
</code><code class="p">}</code></strong><code>&#13;
&#13;
</code><code class="kr">class</code><code> </code><code class="nx">Cat</code><code> </code><code class="kr">implements</code><code> </code><code class="nx">Animal</code><strong><code class="p">,</code><code> </code><code class="nx">Feline</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Whiskers'</code><code>&#13;
  </code><code class="nx">eat</code><code class="p">(</code><code class="nx">food</code><code>: </code><code class="kt">string</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Ate some'</code><code class="p">,</code><code> </code><code class="nx">food</code><code class="p">,</code><code> </code><code class="s1">'. Mmm!'</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">sleep</code><code class="p">(</code><code class="nx">hours</code><code>: </code><code class="kt">number</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Slept for'</code><code class="p">,</code><code> </code><code class="nx">hours</code><code class="p">,</code><code> </code><code class="s1">'hours'</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><strong><code class="nx">meow() {</code><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Meow'</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>All of these features are completely typesafe. If you forget to implement a method or a property, or implement it incorrectly, TypeScript will come to the rescue (see <a data-type="xref" href="#typescript-error-fig">Figure 5-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="typescript-error-fig">&#13;
<img alt="prts 0503" src="assets/prts_0503.png"/>&#13;
<h6><span class="label">Figure 5-3. </span>TypeScript throws an error when you forget to implement a required method</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Implementing Interfaces Versus Extending Abstract Classes" data-type="sect2"><div class="sect2" id="idm46304972021960">&#13;
<h2>Implementing Interfaces Versus Extending Abstract Classes</h2>&#13;
&#13;
<p>Implementing an interface is really similar to extending an abstract class. The difference is that interfaces are more general and lightweight, and abstract classes are more special-purpose and feature-rich.<a data-primary="interfaces" data-secondary="implementing versus extending abstract classes" data-type="indexterm" id="idm46304971719528"/><a data-primary="classes" data-secondary="implementing interfaces" data-tertiary="versus extending abstract classes" data-type="indexterm" id="idm46304971718584"/><a data-primary="abstract classes" data-secondary="extending versus implementing interfaces" data-type="indexterm" id="idm46304971717400"/></p>&#13;
&#13;
<p>An interface is a way to model a shape. At the value level, that means an object, array, function, class, or class instance. Interfaces do not emit JavaScript code, and only exist at compile time.</p>&#13;
&#13;
<p>An abstract class can only model, well, a class. It emits runtime code that is, you guessed it, a JavaScript class. Abstract classes can have constructors, provide default implementations, and set access modifiers for properties and methods. Interfaces can’t do any of those things.</p>&#13;
&#13;
<p>Which one you use depends on your use case. When an implementation is shared among multiple classes, use an abstract class. When you need a lightweight way to say “this class is a <code>T</code>,” use an interface.<a data-primary="interfaces" data-startref="ix_intf" data-type="indexterm" id="idm46304971714152"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Classes Are Structurally Typed" data-type="sect1"><div class="sect1" id="idm46304972568344">&#13;
<h1>Classes Are Structurally Typed</h1>&#13;
&#13;
<p>Like every other type in TypeScript, TypeScript compares classes by their structure, not by their name.<a data-primary="classes" data-secondary="structural typing" data-type="indexterm" id="idm46304971687896"/><a data-primary="structural typing" data-secondary="classes in TypeScript" data-type="indexterm" id="idm46304971687048"/> A class is compatible with any other type that shares its shape, including a regular old object that defines the same properties or methods as the class. This is important to keep in mind for those of you coming from C#, Java, Scala, and most other languages where classes are typed nominally. It means that if you have a function that takes a <code>Zebra</code> and you give it a <code>Poodle</code>, TypeScript might not mind:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">Zebra</code> <code class="p">{</code>&#13;
  <code class="nx">trot() {</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Poodle</code> <code class="p">{</code>&#13;
  <code class="nx">trot() {</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">ambleAround</code><code class="p">(</code><code class="nx">animal</code>: <code class="kt">Zebra</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">animal</code><code class="p">.</code><code class="nx">trot</code><code class="p">()</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">zebra</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Zebra</code>&#13;
<code class="kd">let</code> <code class="nx">poodle</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Poodle</code>&#13;
&#13;
<code class="nx">ambleAround</code><code class="p">(</code><code class="nx">zebra</code><code class="p">)</code>   <code class="c1">// OK</code>&#13;
<code class="nx">ambleAround</code><code class="p">(</code><code class="nx">poodle</code><code class="p">)</code>  <code class="c1">// OK</code></pre>&#13;
&#13;
<p>As the phylogeneticists among you know, a zebra is no poodle—but TypeScript doesn’t mind! As long as <code>Poodle</code> is assignable to <code>Zebra</code>, TypeScript is OK with it because from our function’s point of view, the two are interchangeable; all that matters is that they implement <code>.trot</code>. If you were using almost any other language that types classes nominally, this code would have raised an error; but TypeScript is structurally typed through and through, so this code is perfectly acceptable.<a data-primary="private (access modifier)" data-secondary="classes with private fields" data-type="indexterm" id="idm46304971636328"/><a data-primary="protected (access modifier)" data-secondary="classes with protected fields" data-type="indexterm" id="idm46304971635448"/></p>&#13;
&#13;
<p>The exception to this rule is classes with <code>private</code> or <span class="keep-together"><code>protected</code></span> fields: when checking whether or not a shape is assignable to a class, if the class has any <code>private</code> or <code>protected</code> fields and the shape is not an instance of that class or a subclass of that class, then <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304971631608"/>the shape is not assignable to the class:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">A</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code>&#13;
<code class="p">}</code>&#13;
<code class="kr">class</code> <code class="nx">B</code> <code class="kr">extends</code> <code class="nx">A</code> <code class="p">{}</code>&#13;
<code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">a</code>: <code class="kt">A</code><code class="p">)</code> <code class="p">{}</code>&#13;
&#13;
<code class="nx">f</code><code class="p">(</code><code class="k">new</code> <code class="nx">A</code><code class="p">)</code>   <code class="c1">// OK</code>&#13;
<code class="nx">f</code><code class="p">(</code><code class="k">new</code> <code class="nx">B</code><code class="p">)</code>   <code class="c1">// OK</code>&#13;
&#13;
<code class="nx">f</code><code class="p">({</code><code class="nx">x</code>: <code class="kt">1</code><code class="p">})</code>  <code class="c1">// Error TS2345: Argument of type '{x: number}' is not</code>&#13;
           <code class="c1">// assignable to parameter of type 'A'. Property 'x' is</code>&#13;
           <code class="c1">// private in type 'A' but not in type '{x: number}'.</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Classes Declare Both Values and Types" data-type="sect1"><div class="sect1" id="classes-declare-values-and-types">&#13;
<h1>Classes Declare Both Values and Types</h1>&#13;
&#13;
<p>Most things that you can express in TypeScript<a data-primary="classes" data-secondary="declaring both values and types" data-type="indexterm" id="ix_classdecvt"/><a data-primary="types" data-secondary="classes declaring both values and types" data-type="indexterm" id="ix_typecl"/><a data-primary="values" data-secondary="classes declaring both values and types" data-type="indexterm" id="ix_valclass"/> are either values <em>or</em> types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// values</code>&#13;
<code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1999</code>&#13;
<code class="kd">function</code> <code class="nx">b() {</code><code class="p">}</code>&#13;
&#13;
<code class="c1">// types</code>&#13;
<code class="nx">type</code> <code class="nx">a</code> <code class="o">=</code> <code class="kt">number</code>&#13;
<code class="kr">interface</code> <code class="nx">b</code> <code class="p">{</code>&#13;
  <code class="p">()</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Types and values are namespaced separately in TypeScript. Depending on how you use a term (<code>a</code> or <code>b</code> in this example), TypeScript knows whether to resolve it to a type or to a value:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// ...</code>&#13;
<code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">+</code> <code class="mi">1</code> <code class="o">&gt;</code> <code class="mi">3</code><code class="p">)</code> <code class="c1">//... // TypeScript infers from context that you mean the value a</code>&#13;
<code class="kd">let</code> <code class="nx">x</code>: <code class="kt">a</code> <code class="o">=</code> <code class="mi">3</code>         <code class="c1">// TypeScript infers from context that you mean the type a</code></pre>&#13;
&#13;
<p>This <em>contextual term resolution</em> is really nice, and lets us do cool things like implement companion types (see <a data-type="xref" href="ch06.html#companion-objects">“Companion Object Pattern”</a>).</p>&#13;
&#13;
<p>Classes and enums are special. They are unique because they generate both a type in the type namespace and a value in the value namespace:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code><code> </code><code class="nx">C</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
</code><code class="kd">let</code><code> </code><code class="nx">c</code><code>: </code><code class="kt">C</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO1-1" id="co_classes_and_interfaces_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">C</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO1-2" id="co_classes_and_interfaces_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
&#13;
</code><code class="kr">enum</code><code> </code><code class="nx">E</code><code> </code><code class="p">{</code><code class="nx">F</code><code class="p">,</code><code> </code><code class="nx">G</code><code class="p">}</code><code>&#13;
</code><code class="kd">let</code><code> </code><code class="nx">e</code><code>: </code><code class="kt">E</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO1-3" id="co_classes_and_interfaces_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="o">=</code><code> </code><code class="nx">E</code><code class="p">.</code><code class="nx">F</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO1-4" id="co_classes_and_interfaces_CO1-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO1-1" id="callout_classes_and_interfaces_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>In this context, <code>C</code> refers to the instance type of our <code>C</code> class.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO1-2" id="callout_classes_and_interfaces_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>In this context, <code>C</code> refers to <code>C</code> the value.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO1-3" id="callout_classes_and_interfaces_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>In this context, <code>E</code> refers to the type of our <code>E</code> enum.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO1-4" id="callout_classes_and_interfaces_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>In this context, <code>E</code> refers to <code>E</code> the value.</p></dd>&#13;
</dl>&#13;
&#13;
<p>When we work with classes, we need a way to say “this variable should be an instance of this class” and the same goes for enums (“this variable should be a member of this enum”). Because classes and enums generate types at the type level we’re able to express this “is-a” relationship easily.<sup><a data-type="noteref" href="ch05.html#idm46304971345608" id="idm46304971345608-marker">2</a></sup></p>&#13;
&#13;
<p>We also need a way to represent a class at runtime, so that we can instantiate it with <code>new</code>, call static methods on it, do metaprogramming with it, and operate on it with <code>instanceof</code>—so a class needs to generate a value too.<a data-primary="instanceof operator" data-type="indexterm" id="idm46304971343736"/></p>&#13;
&#13;
<p>In the previous example <code>C</code> refers to an <em>instance of</em> the class <code>C</code>. How do you talk about the <code>C</code> class itself? <a data-primary="typeof operator" data-type="indexterm" id="idm46304971340984"/>We use the <code>typeof</code> keyword (a type operator provided by TypeScript, which is like JavaScript’s value-level <code>typeof</code> but for types).</p>&#13;
&#13;
<p>Let’s create a class <code>StringDatabase</code>—the world’s simplest database:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">State</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">key</code>: <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">StringDatabase</code> <code class="p">{</code>&#13;
  <code class="nx">state</code>: <code class="kt">State</code> <code class="o">=</code> <code class="p">{}</code>&#13;
  <code class="nx">get</code><code class="p">(</code><code class="nx">key</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kc">null</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">key</code> <code class="k">in</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code> <code class="o">?</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">:</code> <code class="kc">null</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">set</code><code class="p">(</code><code class="nx">key</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">state</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>&#13;
  <code class="p">}</code>&#13;
  <code class="kr">static</code> <code class="nx">from</code><code class="p">(</code><code class="nx">state</code>: <code class="kt">State</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nx">db</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">StringDatabase</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">state</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">db</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">state</code><code class="p">[</code><code class="nx">key</code><code class="p">])</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="nx">db</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What types does this class declaration generate? The instance type <code>StringDatabase</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nx">StringDatabase</code> <code class="p">{</code>&#13;
  <code class="nx">state</code>: <code class="kt">State</code>&#13;
  <code class="nx">get</code><code class="p">(</code><code class="nx">key</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kc">null</code>&#13;
  <code class="nx">set</code><code class="p">(</code><code class="nx">key</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And the constructor type <code>typeof StringDatabase</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nx">StringDatabaseConstructor</code> <code class="p">{</code>&#13;
  <code class="k">new</code><code class="p">()</code><code class="o">:</code> <code class="nx">StringDatabase</code>&#13;
  <code class="nx">from</code><code class="p">(</code><code class="nx">state</code>: <code class="kt">State</code><code class="p">)</code><code class="o">:</code> <code class="nx">StringDatabase</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That is, <code>StringDatabaseConstructor</code> has a single method <code>.from</code>, and <code>new</code>-ing the constructor gives a <code>StringDatabase</code> instance. Combined, these two interfaces model both the constructor and instance sides of a class.</p>&#13;
&#13;
<p>That <code>new()</code> bit is called a <em>constructor signature</em>, and is TypeScript’s way of saying that a given type can be instantiated with the <code>new</code> operator.<a data-primary="constructor signatures" data-type="indexterm" id="idm46304971205912"/><a data-primary="new operator" data-type="indexterm" id="idm46304971205176"/> Because TypeScript is structurally typed, that’s the best we can do to describe what a class is: a class is anything that can be <code>new</code>-ed.</p>&#13;
&#13;
<p>In this case the constructor doesn’t take any arguments, but you can use it to declare constructors that take arguments too. For example, say we update <code>StringDatabase</code> to take an optional initial state:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">StringDatabase</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="kr">public</code> <code class="nx">state</code>: <code class="kt">State</code> <code class="o">=</code> <code class="p">{})</code> <code class="p">{}</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We could then type <code>StringDatabase</code>’s constructor signature as:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nx">StringDatabaseConstructor</code> <code class="p">{</code>&#13;
  <code class="k">new</code><code class="p">(</code><code class="nx">state?</code>: <code class="kt">State</code><code class="p">)</code><code class="o">:</code> <code class="nx">StringDatabase</code>&#13;
  <code class="nx">from</code><code class="p">(</code><code class="nx">state</code>: <code class="kt">State</code><code class="p">)</code><code class="o">:</code> <code class="nx">StringDatabase</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So, not only does a class declaration generate terms at the value and type levels, but it generates two terms at the type level: one representing an instance of the class; one representing the class constructor itself (reachable with the <code>typeof</code> type operator).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Polymorphism" data-type="sect1"><div class="sect1" id="class-generics">&#13;
<h1>Polymorphism</h1>&#13;
&#13;
<p>Like functions and types, classes and interfaces have rich support for generic type parameters, including defaults and bounds.<a data-primary="generics" data-secondary="classes and interfaces support for" data-type="indexterm" id="ix_genclint"/><a data-primary="polymorphism" data-secondary="classes and interfaces" data-type="indexterm" id="ix_polycl"/><a data-primary="classes" data-secondary="polymorphism" data-type="indexterm" id="idm46304971056456"/> You can scope a generic to your whole class or interface, or to a specific method:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code><code> </code><code class="nx">MyMap</code><code class="o">&lt;</code><code class="nx">K</code><code class="p">,</code><code> </code><code class="nx">V</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO2-1" id="co_classes_and_interfaces_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="kr">constructor</code><code class="p">(</code><code class="nx">initialKey</code><code>: </code><code class="kt">K</code><code class="p">,</code><code> </code><code class="nx">initialValue</code><code>: </code><code class="kt">V</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO2-2" id="co_classes_and_interfaces_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">get</code><code class="p">(</code><code class="nx">key</code><code>: </code><code class="kt">K</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">V</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO2-3" id="co_classes_and_interfaces_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code>: </code><code class="kt">K</code><code class="p">,</code><code> </code><code class="nx">value</code><code>: </code><code class="kt">V</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">void</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">merge</code><code class="o">&lt;</code><code class="nx">K1</code><code class="p">,</code><code> </code><code class="nx">V1</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">map</code><code>: </code><code class="kt">MyMap</code><code class="o">&lt;</code><code class="nx">K1</code><code class="p">,</code><code> </code><code class="nx">V1</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">MyMap</code><code class="o">&lt;</code><code class="nx">K</code><code> </code><code class="o">|</code><code> </code><code class="nx">K1</code><code class="p">,</code><code> </code><code class="nx">V</code><code> </code><code class="o">|</code><code> </code><code class="nx">V1</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO2-4" id="co_classes_and_interfaces_CO2-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
  </code><code class="kr">static</code><code> </code><code class="nx">of</code><code class="o">&lt;</code><code class="nx">K</code><code class="p">,</code><code> </code><code class="nx">V</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">k</code><code>: </code><code class="kt">K</code><code class="p">,</code><code> </code><code class="nx">v</code><code>: </code><code class="kt">V</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">MyMap</code><code class="o">&lt;</code><code class="nx">K</code><code class="p">,</code><code> </code><code class="nx">V</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO2-5" id="co_classes_and_interfaces_CO2-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO2-1" id="callout_classes_and_interfaces_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Bind class-scoped generic types when you declare your <code>class</code>. Here, <code>K</code> and <code>V</code> are available to every instance method and instance property on <code>MyMap</code>.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO2-2" id="callout_classes_and_interfaces_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Note that you cannot declare generic types in a <code>constructor</code>. Instead, move the declaration up to your <code>class</code> declaration.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO2-3" id="callout_classes_and_interfaces_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Use class-scoped generic types anywhere inside your class.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO2-4" id="callout_classes_and_interfaces_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Instance methods have access to class-level generics, and can also declare their own generics on top. <code>.merge</code> makes use of the <code>K</code> and <code>V</code> class-level generics, and also declares two of its own generics, <code>K1</code> and <code>V1</code>.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO2-5" id="callout_classes_and_interfaces_CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Static methods do not have access to their class’s generics, just like at the value level they don’t have access to their class’s instance variables. <code>of</code> does not have access to the <code>K</code> and <code>V</code> declared in <a class="co" href="#co_classes_and_interfaces_CO2-1"><img alt="1" src="assets/1.png"/></a>; instead, it declares its own <code>K</code> and <code>V</code> generics.</p></dd>&#13;
</dl>&#13;
&#13;
<p>You can bind <a data-primary="interfaces" data-secondary="polymorphism" data-type="indexterm" id="idm46304970809768"/>generics to interfaces too:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nx">MyMap</code><code class="o">&lt;</code><code class="nx">K</code><code class="p">,</code> <code class="nx">V</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">get</code><code class="p">(</code><code class="nx">key</code>: <code class="kt">K</code><code class="p">)</code><code class="o">:</code> <code class="nx">V</code>&#13;
  <code class="nx">set</code><code class="p">(</code><code class="nx">key</code>: <code class="kt">K</code><code class="p">,</code> <code class="nx">value</code>: <code class="kt">V</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And like with functions, you can bind concrete types to generics explicitly, or let TypeScript infer the types for you:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyMap</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="s1">'k'</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code> <code class="c1">// MyMap&lt;string, number&gt;</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyMap</code><code class="p">(</code><code class="s1">'k'</code><code class="p">,</code> <code class="kc">true</code><code class="p">)</code> <code class="c1">// MyMap&lt;string, boolean&gt;</code>&#13;
&#13;
<code class="nx">a</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'k'</code><code class="p">)</code>&#13;
<code class="nx">b</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'k'</code><code class="p">,</code> <code class="kc">false</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mixins" data-type="sect1"><div class="sect1" id="mixins">&#13;
<h1>Mixins</h1>&#13;
&#13;
<p>JavaScript and TypeScript don’t have <code>trait</code> or <code>mixin</code> keywords, but it’s straightforward to implement them ourselves.<a data-primary="generics" data-secondary="classes and interfaces support for" data-startref="ix_genclint" data-type="indexterm" id="idm46304970714584"/><a data-primary="polymorphism" data-secondary="classes and interfaces" data-startref="ix_polycl" data-type="indexterm" id="idm46304970713368"/><a data-primary="inheritance" data-secondary="simulating multiple inheritance" data-type="indexterm" id="idm46304970712152"/> <a data-primary="role-oriented programming" data-type="indexterm" id="idm46304970711112"/>Both are ways to simulate <em>multiple inheritance</em>  (classes that extend more than one other class) and do <em>role-oriented programming</em>, a style of programming where you don’t say things like “this thing is a <code>Shape</code>" but instead describe properties of a thing, like “it can be measured” or “it has four sides.” Instead of “is-a” relationships, you describe “can” and “has-a” relationships.<a data-primary="classes" data-secondary="mixins" data-type="indexterm" id="ix_classmix"/><a data-primary="mixins" data-type="indexterm" id="ix_mix"/><a data-primary="traits" data-seealso="mixins" data-type="indexterm" id="idm46304970706728"/></p>&#13;
&#13;
<p>Let’s build a mixin implementation.</p>&#13;
&#13;
<p>Mixins are a pattern that allows us to <em>mix</em> behaviors and properties <em>into</em> a class. By convention, mixins:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Can have state (i.e., instance properties)</p>&#13;
</li>&#13;
<li>&#13;
<p>Can only provide concrete methods (not abstract ones)</p>&#13;
</li>&#13;
<li>&#13;
<p>Can have constructors, which are called in the same order as their classes were mixed in</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>TypeScript doesn’t have a built-in concept of mixins, but it’s easy to implement them ourselves. For example, let’s design a debugging library for TypeScript classes. We’ll call it <code>EZDebug</code>. The library works by letting you log out information about whatever classes use the library, so that you can inspect them at runtime. We’ll use it like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">User</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">User</code><code class="p">.</code><code class="nx">debug</code><code class="p">()</code> <code class="c1">// evaluates to 'User({"id": 3, "name": "Emma Gluzman"})'</code></pre>&#13;
&#13;
<p>With a standard <code>.debug</code> interface, our users will be able to debug anything! Let’s build it. We’ll model it with a mixin, which we’ll call <code>withEZDebug</code>. <a data-primary="constructors" data-secondary="class, mixins and" data-type="indexterm" id="idm46304970678472"/>A mixin is just a function that takes a class constructor and returns a class constructor, so our mixin might look like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">ClassConstructor</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code>: </code><code class="kt">any</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code class="p">}</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO3-1" id="co_classes_and_interfaces_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">withEZDebug</code><code class="o">&lt;</code><code class="nx">C</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">ClassConstructor</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">Class</code><code>: </code><code class="kt">C</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO3-2" id="co_classes_and_interfaces_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="k">return</code><code> </code><code class="kr">class</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">Class</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO3-3" id="co_classes_and_interfaces_CO3-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="kr">constructor</code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code>: </code><code class="kt">any</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO3-4" id="co_classes_and_interfaces_CO3-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
      </code><code class="kr">super</code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code class="p">)</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO3-5" id="co_classes_and_interfaces_CO3-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
    </code><code class="p">}</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO3-1" id="callout_classes_and_interfaces_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We start by declaring a type <code>ClassConstructor</code>, which represents any constructor. Since TypeScript is completely structurally typed, we say that a constructor is anything that can be <code>new</code>-ed. We don’t know what types of parameters the constructor might have, so we say it takes any number of arguments of any type.<sup><a data-type="noteref" href="ch05.html#idm46304970560536" id="idm46304970560536-marker">3</a></sup></p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO3-2" id="callout_classes_and_interfaces_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We declare our <code>withEZDebug</code> mixin with a single type parameter, <code>C</code>. <code>C</code> has to be at least a class constructor, which we enforce with an <code>extends</code> clause. We let TypeScript infer <code>withEZDebug</code>’s return type, which is the intersection of <code>C</code> and our new anonymous class.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO3-3" id="callout_classes_and_interfaces_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Since a mixin is a function that takes a constructor and returns a constructor, we return an anonymous class constructor.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO3-4" id="callout_classes_and_interfaces_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The class constructor has to take <em>at least</em> the arguments that the class you pass in might take. But remember, since we don’t know what class you might pass in beforehand, I have to keep it as general as possible, which means any number of parameters of any type—just like <code>ClassConstructor</code>.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO3-5" id="callout_classes_and_interfaces_CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Finally, since this anonymous class extends another class, to wire everything up correctly we need to remember to call <code>Class</code>’s constructor too.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Like with regular JavaScript classes, if you don’t have any more logic in the <code>constructor</code>, you can omit lines  <a class="co" href="#co_classes_and_interfaces_CO3-4"><img alt="4" src="assets/4.png"/></a> and  <a class="co" href="#co_classes_and_interfaces_CO3-5"><img alt="5" src="assets/5.png"/></a>. We aren’t going to put any logic into the constructor for this <code>withEZDebug</code> example, so we can omit them.</p>&#13;
&#13;
<p>Now that we’ve set up the boilerplate, it’s time to work some debugging magic. When we call <code>.debug</code>, we want to log out the class’s constructor name and the instance’s value:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">ClassConstructor</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code>: </code><code class="kt">any</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">withEZDebug</code><code class="o">&lt;</code><code class="nx">C</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">ClassConstructor</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">Class</code><code>: </code><code class="kt">C</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="kr">class</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">Class</code><code> </code><code class="p">{</code><code>&#13;
    </code><strong><code class="nx">debug() {</code><code>&#13;
      </code><code class="kd">let</code><code> </code><code class="nx">Name</code><code> </code><code class="o">=</code><code> </code><code class="nx">Class</code><code class="p">.</code><code class="kr">constructor</code><code class="p">.</code><code class="nx">name</code><code>&#13;
      </code><code class="kd">let</code><code> </code><code class="nx">value</code><code> </code><code class="o">=</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">getDebugValue</code><code class="p">(</code><code class="p">)</code><code>&#13;
      </code><code class="k">return</code><code> </code><code class="nx">Name</code><code> </code><code class="o">+</code><code> </code><code class="s1">'('</code><code> </code><code class="o">+</code><code> </code><code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code><code> </code><code class="o">+</code><code> </code><code class="s1">')'</code><code>&#13;
    </code><code class="p">}</code></strong><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>But wait! How do we make sure the class implements a <code>.getDebugValue</code> method, so that we can call it? Think about this for a second before you move on—can you figure it out?</p>&#13;
&#13;
<p>The answer is that instead of accepting any old class, we use a generic type to make sure the class passed into <code>withEZDebug</code> defines a <code>.getDebugValue</code> method:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">ClassConstructor</code><strong><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code></strong><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code>: </code><code class="kt">any</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><strong><code class="nx">T</code></strong><code> </code><a class="co" href="#co_5_1" id="callout_5_1"><img src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">withEZDebug</code><code class="o">&lt;</code><code class="nx">C</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">ClassConstructor</code><strong><code class="o">&lt;</code><code class="p">{</code><code>&#13;
  </code><code class="nx">getDebugValue</code><code class="p">(</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">object</code></strong><code> </code><a class="co" href="#co_5_2" id="callout_5_2"><img src="assets/2.png"/></a><code>&#13;
</code><strong><code class="p">}</code><code class="o">&gt;</code></strong><code class="o">&gt;</code><code class="p">(</code><code class="nx">Class</code><code>: </code><code class="kt">C</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#callout_5_1" id="co_5_1"><img src="assets/1.png"/></a></dt>&#13;
<dd><p>We add a generic type parameter to <code>ClassConstructor</code>.</p></dd>&#13;
<dt><a class="co" href="#callout_5_2" id="co_5_2"><img src="assets/2.png"/></a></dt>&#13;
<dd><p>We bind a shape type to <code>ClassConstructor</code>, <code>C</code>, enforcing that the constructor we passed to <span class="keep-together"><code>withEZDebug</code></span> at least defines the <code>.getDebugValue</code> method.</p></dd>&#13;
</dl>&#13;
&#13;
<p>That’s it! So, how do you use this incredible debugging utility? Like so:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">HardToDebugUser</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code>&#13;
    <code class="kr">private</code> <code class="nx">id</code>: <code class="kt">number</code><code class="p">,</code>&#13;
    <code class="kr">private</code> <code class="nx">firstName</code>: <code class="kt">string</code><code class="p">,</code>&#13;
    <code class="kr">private</code> <code class="nx">lastName</code>: <code class="kt">string</code>&#13;
  <code class="p">)</code> <code class="p">{}</code>&#13;
  <code class="nx">getDebugValue() {</code>&#13;
    <code class="k">return</code> <code class="p">{</code>&#13;
      <code class="nx">id</code>: <code class="kt">this.id</code><code class="p">,</code>&#13;
      <code class="nx">name</code>: <code class="kt">this.firstName</code> <code class="o">+</code> <code class="s1">' '</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">User</code> <code class="o">=</code> <code class="nx">withEZDebug</code><code class="p">(</code><code class="nx">HardToDebugUser</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nx">user</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">User</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="s1">'Emma'</code><code class="p">,</code> <code class="s1">'Gluzman'</code><code class="p">)</code>&#13;
<code class="nx">user</code><code class="p">.</code><code class="nx">debug</code><code class="p">()</code> <code class="c1">// evaluates to 'User({"id": 3, "name": "Emma Gluzman"})'</code></pre>&#13;
&#13;
<p>Cool, right? You can apply as many mixins to a class as you want to yield a class with richer and richer behavior, all in a typesafe way. Mixins help encapsulate behavior, and are an expressive way to specify reusable behaviors.<sup><a data-type="noteref" href="ch05.html#idm46304970288936" id="idm46304970288936-marker">4</a></sup></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Decorators" data-type="sect1"><div class="sect1" id="decorators">&#13;
<h1>Decorators</h1>&#13;
&#13;
<p>Decorators are an experimental TypeScript feature that gives us a clean syntax for metaprogramming with classes,<a data-primary="classes" data-secondary="mixins" data-startref="ix_classmix" data-type="indexterm" id="idm46304970227176"/><a data-primary="mixins" data-startref="ix_mix" data-type="indexterm" id="idm46304970225928"/> class methods, properties, and method parameters.<a data-primary="decorators" data-type="indexterm" id="ix_deco"/><a data-primary="classes" data-secondary="decorators" data-type="indexterm" id="ix_classdeco"/> They’re just a syntax for calling a function on the thing you’re decorating.</p>&#13;
<div data-type="tip"><h1>TSC Flag: experimentalDecorators</h1>&#13;
<p>Because they’re still experimental—meaning they may change in a backward-incompatible way, or may even be entirely removed in future TypeScript releases—decorators are hidden behind a TSC flag. <a data-primary="TSC compiler" data-secondary="experimentalDecorators flag" data-type="indexterm" id="idm46304970221112"/><a data-primary="experimentalDecorators TSC flag" data-type="indexterm" id="idm46304970220168"/>If you’re OK with that, and want to play around with the feature, set <code>"experimentalDecorators": true</code> in your <em>tsconfig.json</em> and read on.</p>&#13;
</div>&#13;
&#13;
<p>To get a sense for how decorators work, let’s start with an example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="err">@</code><code class="nx">serializable</code>&#13;
<code class="kr">class</code> <code class="nx">APIPayload</code> <code class="p">{</code>&#13;
  <code class="nx">getValue</code><code class="p">()</code><code class="o">:</code> <code class="nx">Payload</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>@serializable</code> class decorator wraps our <code>APIPayload</code> class, and optionally returns a new class that replaces it. Without decorators, you might implement the same thing with:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">APIPayload</code> <code class="o">=</code> <code class="nx">serializable</code><code class="p">(</code><code class="kr">class</code> <code class="nx">APIPayload</code> <code class="p">{</code>&#13;
  <code class="nx">getValue</code><code class="p">()</code><code class="o">:</code> <code class="nx">Payload</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>For each type of decorator, TypeScript requires that you have a function in scope with the given name and the required signature<a data-primary="decorators" data-secondary="expected type signatures for decorator functions" data-type="indexterm" id="idm46304970194472"/><a data-primary="functions" data-secondary="decorator" data-type="indexterm" id="idm46304970193496"/> for that type of decorator (see <a data-type="xref" href="#expected-type-table">Table 5-1</a>).</p>&#13;
<table id="expected-type-table">&#13;
<caption><span class="label">Table 5-1. </span>Expected type signatures for the different kinds of decorator functions</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>What you’re decorating</th>&#13;
<th>Expected type signature</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Class</p></td>&#13;
<td><p><code>(Constructor: {new(...any[]) =&gt; any}) =&gt; any</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Method</p></td>&#13;
<td><p><code>(classPrototype: {}, methodName: string, descriptor:</code> <code><span class="keep-together">PropertyDescriptor</span></code><code>) =&gt; any</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Static method</p></td>&#13;
<td><p><code>(Constructor: {new(...any[]) =&gt; any}, methodName: string, descriptor: PropertyDescriptor) =&gt; any</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Method parameter</p></td>&#13;
<td><p><code>(classPrototype: {}, paramName: string, index: number) =&gt; void</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Static method parameter</p></td>&#13;
<td><p><code>(Constructor: {new(...any[]) =&gt; any}, paramName: string, index: number) =&gt; void</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Property</p></td>&#13;
<td><p><code>(classPrototype: {}, propertyName: string) =&gt; any</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Static property</p></td>&#13;
<td><p><code>(Constructor: {new(...any[]) =&gt; any}, propertyName: string) =&gt; any</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Property getter/setter</p></td>&#13;
<td><p><code>(classPrototype: {}, propertyName: string, descriptor:</code> <code><span class="keep-together">PropertyDescriptor</span></code><code>) =&gt; any</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Static property getter/setter</p></td>&#13;
<td><p><code>(Constructor: {new(...any[]) =&gt; any}, propertyName: string, descriptor: PropertyDescriptor) =&gt; any</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>TypeScript doesn’t come with any built-in decorators: whatever decorators you use, you have to implement yourself (or install from NPM). The implementation for each kind of decorator—for classes, methods, properties, and function parameters—is a regular function that satisfies a specific signature, depending on what it’s decorating.<a data-primary="decorators" data-secondary="example, @serializable decorator" data-type="indexterm" id="idm46304970081448"/> For example, our <code>@serializable</code> decorator might look like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">ClassConstructor</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code>: </code><code class="kt">any</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">T</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO4-1" id="co_classes_and_interfaces_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">serializable</code><code class="o">&lt;</code><code>&#13;
  </code><code class="nx">T</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">ClassConstructor</code><code class="o">&lt;</code><code class="p">{</code><code>&#13;
    </code><code class="nx">getValue</code><code class="p">(</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Payload</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO4-2" id="co_classes_and_interfaces_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="p">}</code><code class="o">&gt;</code><code>&#13;
</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">Constructor</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO4-3" id="co_classes_and_interfaces_CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="k">return</code><code> </code><code class="kr">class</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">Constructor</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO4-4" id="co_classes_and_interfaces_CO4-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
    </code><code class="nx">serialize() {</code><code>&#13;
      </code><code class="k">return</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">getValue</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="p">)</code><code>&#13;
    </code><code class="p">}</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO4-1" id="callout_classes_and_interfaces_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Remember, <code>new()</code> is how we structurally type a class constructor in TypeScript.<a data-primary="constructors" data-secondary="extended class constructors" data-type="indexterm" id="idm46304970001688"/><a data-primary="new operator" data-secondary="new(…any[]) syntax for extended class constructors)" data-type="indexterm" id="idm46304970000744"/> And for a class constructor that can be extended (with <code>extends</code>), TypeScript requires that we type its arguments with an <code>any</code> spread: <code>new(...any[])</code>.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO4-2" id="callout_classes_and_interfaces_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><code>@serializable</code> can decorate any class whose instances implement the method <code>.getValue</code>, which returns a <code>Payload</code>.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO4-3" id="callout_classes_and_interfaces_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Class decorators are functions that take a single argument—the class. If the decorator function returns a class (as in the example) it will replace the class it’s decorating at runtime; otherwise, it will return the original class.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO4-4" id="callout_classes_and_interfaces_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>To decorate the class, we return a class that extends it and adds a <code>.serialize</code> method along the way.</p></dd>&#13;
</dl>&#13;
&#13;
<p>What happens when we try to call <code>.serialize</code>?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">payload</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">APIPayload</code>&#13;
<code class="kd">let</code> <code class="nx">serialized</code> <code class="o">=</code> <code class="nx">payload</code><code class="p">.</code><code class="nx">serialize</code><code class="p">()</code> <code class="c1">// Error TS2339: Property 'serialize' does</code>&#13;
                                     <code class="c1">// not exist on type 'APIPayload'.</code></pre>&#13;
&#13;
<p>TypeScript assumes that a decorator doesn’t change the shape of the thing it’s decorating—meaning that you didn’t add or remove methods and properties. It checks at compile time that the class you returned is assignable to the class you passed in, but at the time of writing, TypeScript does not keep track of extensions you make in your decorators.</p>&#13;
&#13;
<p>Until decorators in TypeScript become a more mature feature, I recommend you avoid using them and stick to regular functions instead:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">DecoratedAPIPayload</code> <code class="o">=</code> <code class="nx">serializable</code><code class="p">(</code><code class="nx">APIPayload</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nx">payload</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">DecoratedAPIPayload</code>&#13;
<code class="nx">payload</code><code class="p">.</code><code class="nx">serialize</code><code class="p">()</code>                  <code class="c1">// string</code></pre>&#13;
&#13;
<p>We won’t delve more deeply into decorators in this book. For more information, head over to the <a href="http://bit.ly/2IDQd1U">official documentation</a>.<a data-primary="decorators" data-startref="ix_deco" data-type="indexterm" id="idm46304969921240"/><a data-primary="classes" data-secondary="decorators" data-startref="ix_classdeco" data-type="indexterm" id="idm46304969920328"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simulating final Classes" data-type="sect1"><div class="sect1" id="idm46304970228616">&#13;
<h1>Simulating final Classes</h1>&#13;
&#13;
<p>Though TypeScript doesn’t support the <code>final</code> keyword for classes or methods, it’s easy to simulate it for classes.<a data-primary="final classes, simulating" data-type="indexterm" id="idm46304969885432"/><a data-primary="classes" data-secondary="simulating final classes" data-type="indexterm" id="idm46304969884760"/> If you haven’t worked much with object-oriented languages before, <code>final</code> is the keyword some languages use to mark a class as nonextensible, or a method as nonoverridable.</p>&#13;
&#13;
<p>To simulate <code>final</code> classes in TypeScript, we can take advantage of private constructors:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">MessageQueue</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code> <code class="nx">messages</code>: <code class="kt">string</code><code class="p">[])</code> <code class="p">{}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When a <code>constructor</code> is marked <code>private</code>, you can’t <code>new</code> the <a data-primary="constructors" data-secondary="private class constructors" data-type="indexterm" id="idm46304969872552"/><a data-primary="private (access modifier)" data-secondary="class constructors" data-type="indexterm" id="idm46304969871576"/>class or extend it:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">BadQueue</code> <code class="kr">extends</code> <code class="nx">MessageQueue</code> <code class="p">{}</code>  <code class="c1">// Error TS2675: Cannot extend a class</code>&#13;
                                        <code class="c1">// 'MessageQueue'. Class constructor is</code>&#13;
                                        <code class="c1">// marked as private.</code>&#13;
&#13;
<code class="k">new</code> <code class="nx">MessageQueue</code><code class="p">([])</code>                    <code class="c1">// Error TS2673: Constructor of class</code>&#13;
                                        <code class="c1">// 'MessageQueue' is private and only</code>&#13;
                                        <code class="c1">// accessible within the class</code>&#13;
                                        <code class="c1">// declaration.</code></pre>&#13;
&#13;
<p>As well as preventing you from extending the class—which is what we want—private constructors also prevent you from directly instantiating it. But for <code>final</code> classes we do want the ability to instantiate a class, just not to extend it. How do we keep the first restriction but get rid of the second? Easy:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">class</code><code> </code><code class="nx">MessageQueue</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">private</code><code> </code><code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code><code> </code><code class="nx">messages</code><code>: </code><code class="kt">string</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
  </code><strong><code class="kr">static</code><code> </code><code class="nx">create</code><code class="p">(</code><code class="nx">messages</code><code>: </code><code class="kt">string</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">new</code><code> </code><code class="nx">MessageQueue</code><code class="p">(</code><code class="nx">messages</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>This changes <code>MessageQueue</code>’s API a bit, but it does a great job of preventing extensions at compile time:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">BadQueue</code> <code class="kr">extends</code> <code class="nx">MessageQueue</code> <code class="p">{}</code>  <code class="c1">// Error TS2675: Cannot extend a class</code>&#13;
                                        <code class="c1">// 'MessageQueue'. Class constructor is</code>&#13;
                                        <code class="c1">// marked as private.</code>&#13;
&#13;
<code class="nx">MessageQueue</code><code class="p">.</code><code class="nx">create</code><code class="p">([])</code> <code class="c1">// MessageQueue</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Design Patterns" data-type="sect1"><div class="sect1" id="idm46304969710040">&#13;
<h1>Design Patterns</h1>&#13;
&#13;
<p>This wouldn’t be a chapter on object-oriented programming if we didn’t walk through implementing a design pattern or two in TypeScript, right?<a data-primary="design patterns" data-type="indexterm" id="ix_despatt"/><a data-primary="classes" data-secondary="design patterns" data-type="indexterm" id="ix_classdes"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Factory Pattern" data-type="sect2"><div class="sect2" id="factory-pattern">&#13;
<h2>Factory Pattern</h2>&#13;
&#13;
<p>The <em>factory pattern</em> is a way to create objects of some type, leaving the decision of which concrete object to create to the specific factory that creates that object.<a data-primary="classes" data-secondary="design patterns" data-tertiary="factory pattern" data-type="indexterm" id="idm46304969697448"/><a data-primary="factory pattern" data-type="indexterm" id="idm46304969696200"/><a data-primary="design patterns" data-secondary="factory pattern" data-type="indexterm" id="idm46304969695528"/></p>&#13;
&#13;
<p>Let’s build a shoe factory. We’ll start by defining a <code>Shoe</code> type, and a few kinds of shoes:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Shoe</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">purpose</code>: <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">BalletFlat</code> <code class="kr">implements</code> <code class="nx">Shoe</code> <code class="p">{</code>&#13;
  <code class="nx">purpose</code> <code class="o">=</code> <code class="s1">'dancing'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Boot</code> <code class="kr">implements</code> <code class="nx">Shoe</code> <code class="p">{</code>&#13;
  <code class="nx">purpose</code> <code class="o">=</code> <code class="s1">'woodcutting'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Sneaker</code> <code class="kr">implements</code> <code class="nx">Shoe</code> <code class="p">{</code>&#13;
  <code class="nx">purpose</code> <code class="o">=</code> <code class="s1">'walking'</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that this example uses a <code>type</code>, but we could have just as well used an <code>interface</code> instead.</p>&#13;
&#13;
<p>Now, let’s make a shoe factory:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code><code> </code><code class="nx">Shoe</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">create</code><code class="p">(</code><code class="nx">type</code><code class="o">:</code><code> </code><code class="s1">'balletFlat'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'boot'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'sneaker'</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Shoe</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO5-1" id="co_classes_and_interfaces_CO5-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
    </code><code class="k">switch</code><code> </code><code class="p">(</code><code class="nx">type</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_classes_and_interfaces_CO5-2" id="co_classes_and_interfaces_CO5-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
      </code><code class="k">case</code><code> </code><code class="s1">'balletFlat'</code><code class="o">:</code><code> </code><code class="k">return</code><code> </code><code class="k">new</code><code> </code><code class="nx">BalletFlat</code><code>&#13;
      </code><code class="k">case</code><code> </code><code class="s1">'boot'</code><code class="o">:</code><code> </code><code class="k">return</code><code> </code><code class="k">new</code><code> </code><code class="nx">Boot</code><code>&#13;
      </code><code class="k">case</code><code> </code><code class="s1">'sneaker'</code><code class="o">:</code><code> </code><code class="k">return</code><code> </code><code class="k">new</code><code> </code><code class="nx">Sneaker</code><code>&#13;
    </code><code class="p">}</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO5-1" id="callout_classes_and_interfaces_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Using a union type for <code>type</code> helps make <code>.create</code> as typesafe as possible, preventing consumers from passing in an invalid <code>type</code> at compile time.</p></dd>&#13;
<dt><a class="co" href="#co_classes_and_interfaces_CO5-2" id="callout_classes_and_interfaces_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Switching on <code>type</code> makes it easy for TypeScript to enforce that we’ve handled every type of <code>Shoe</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>In this example we use the companion object pattern (see <a data-type="xref" href="ch06.html#companion-objects">“Companion Object Pattern”</a>) to declare a type <code>Shoe</code> and a value <code>Shoe</code> with the same name (remember that TypeScript has separate namespaces for values and for types), as a way to signal that the value provides methods for operating on the type. To use the factory, we can just call <code>.create</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">Shoe</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="s1">'boot'</code><code class="p">)</code> <code class="c1">// Shoe</code></pre>&#13;
&#13;
<p>Voilà! We have a factory pattern. Note that we could have gone further and indicated in <code>Shoe.create</code>’s type signature that passing in <code>'boot'</code> will give a <code>Boot</code>, <code>'sneaker'</code> will give a <code>Sneaker</code>, and so on, but that would break the abstraction that the factory pattern gives us (that the consumer shouldn’t know what concrete class they’ll get back, just that the class satisfies a particular interface).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Builder Pattern" data-type="sect2"><div class="sect2" id="builder-pattern">&#13;
<h2>Builder Pattern</h2>&#13;
&#13;
<p>The <em>builder pattern</em> is a way to separate the construction of an object from the way that object is actually implemented.<a data-primary="design patterns" data-secondary="builder pattern" data-type="indexterm" id="idm46304969492120"/><a data-primary="classes" data-secondary="design patterns" data-tertiary="builder pattern" data-type="indexterm" id="idm46304969491144"/><a data-primary="builder pattern" data-type="indexterm" id="idm46304969484872"/> If you’ve used JQuery, or ES6 data structures like <code>Map</code> and <code>Set</code>, this style of API should look familiar. Here’s what it looks like:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="k">new</code> <code class="nx">RequestBuilder</code><code class="p">()</code>&#13;
  <code class="p">.</code><code class="nx">setURL</code><code class="p">(</code><code class="s1">'/users'</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">setMethod</code><code class="p">(</code><code class="s1">'get'</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">setData</code><code class="p">({</code><code class="nx">firstName</code><code class="o">:</code> <code class="s1">'Anna'</code><code class="p">})</code>&#13;
  <code class="p">.</code><code class="nx">send</code><code class="p">()</code></pre>&#13;
&#13;
<p>How do we implement <code>RequestBuilder</code>? Easy—we’ll start with a bare class:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">RequestBuilder</code> <code class="p">{}</code></pre>&#13;
&#13;
<p>First we’ll add the <code>.setURL</code> method:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">class</code><code> </code><code class="nx">RequestBuilder</code><code> </code><code class="p">{</code><code>&#13;
&#13;
  </code><strong><code class="kr">private</code><code> </code><code class="nx">url</code><code>: </code><code class="kt">string</code><code> </code><code class="o">|</code><code> </code><code class="kc">null</code><code> </code><code class="o">=</code><code> </code><code class="kc">null</code></strong><code> </code><a class="co" href="#callout_5_2_1" id="co_5_2_1"><img src="assets/1.png"/></a><code>&#13;
&#13;
  </code><strong><code class="nx">setURL</code><code class="p">(</code><code class="nx">url</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">this</code><code> </code><code class="p">{</code></strong><code> </code><a class="co" href="#callout_5_2_1" id="co_5_2_2"><img src="assets/2.png"/></a><code>&#13;
    </code><strong><code class="k">this</code><code class="p">.</code><code class="nx">url</code><code> </code><code class="o">=</code><code> </code><code class="nx">url</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">this</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_5_2_1" id="callout_5_2_1"><img src="assets/1.png"/></a></dt>&#13;
<dd><p>We keep track of the URL the user set in a private instance variable <code>url</code>, which we initialize to <code>null</code>.</p></dd>&#13;
<dt><a class="co" href="#co_5_2_2" id="callout_5_2_2"><img src="assets/2.png"/></a></dt>&#13;
<dd><p><code>setURL</code>’s return type is <code>this</code> (see <a data-type="xref" href="#this-in-return-type">“Using this as a Return Type”</a>), that is, the specific instance of <code>RequestBuilder</code> that the user called <code>setURL</code> on.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now let’s add the other methods from our example:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">class</code><code> </code><code class="nx">RequestBuilder</code><code> </code><code class="p">{</code><code>&#13;
&#13;
  </code><strong><code class="kr">private</code><code> </code><code class="nx">data</code><code>: </code><code class="kt">object</code><code> </code><code class="o">|</code><code> </code><code class="kc">null</code><code> </code><code class="o">=</code><code> </code><code class="kc">null</code><code>&#13;
  </code><code class="kr">private</code><code> </code><code class="nx">method</code><code class="o">:</code><code> </code><code class="s1">'get'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'post'</code><code> </code><code class="o">|</code><code> </code><code class="kc">null</code><code> </code><code class="o">=</code><code> </code><code class="kc">null</code></strong><code>&#13;
  </code><code class="kr">private</code><code> </code><code class="nx">url</code><code>: </code><code class="kt">string</code><code> </code><code class="o">|</code><code> </code><code class="kc">null</code><code> </code><code class="o">=</code><code> </code><code class="kc">null</code><code>&#13;
&#13;
  </code><strong><code class="nx">setMethod</code><code class="p">(</code><code class="nx">method</code><code class="o">:</code><code> </code><code class="s1">'get'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'post'</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">this</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">this</code><code class="p">.</code><code class="nx">method</code><code> </code><code class="o">=</code><code> </code><code class="nx">method</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">this</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">setData</code><code class="p">(</code><code class="nx">data</code><code>: </code><code class="kt">object</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">this</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">this</code><code class="p">.</code><code class="nx">data</code><code> </code><code class="o">=</code><code> </code><code class="nx">data</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">this</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
  </code><code class="nx">setURL</code><code class="p">(</code><code class="nx">url</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">this</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">this</code><code class="p">.</code><code class="nx">url</code><code> </code><code class="o">=</code><code> </code><code class="nx">url</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">this</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
&#13;
  </code><strong><code class="nx">send() {</code><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>That’s all there is to it.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This traditional builder design is not completely safe: we can call <code>.send</code> before we set the method, URL, or data, resulting in a runtime exception (remember, that’s the bad kind of exception). See Exercise 4 for some ideas about how to improve this design.<a data-primary="classes" data-secondary="design patterns" data-startref="ix_classdes" data-type="indexterm" id="idm46304969188312"/><a data-primary="design patterns" data-startref="ix_despatt" data-type="indexterm" id="idm46304969187224"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46304969206728">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>We’ve now explored TypeScript classes from all sides: how to declare classes; how to inherit from classes and implement interfaces; how to mark classes as <code>abstract</code> so they can’t be instantiated; how to put a field or method on a class with <code>static</code> and on an instance without it; how to control access to a field or method with the <code>private</code>, <code>protected</code>, and <code>public</code> visibility modifiers; and how to mark a field as nonwritable using the <code>readonly</code> modifier. We’ve covered how to safely use <code>this</code> and <code>super</code>, explored what it means for classes to be both values and types at the same time, and talked about the differences between type aliases and interfaces, the basics of declaration merging, and using generic types in classes. Finally, we covered a few more advanced patterns for working with classes: mixins, decorators, and simulating <code>final</code> classes. And to cap the chapter off, we went through and derived a couple of common patterns for working with classes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="ch05-exercises">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>What are the differences between a class and an interface?</p>&#13;
</li>&#13;
<li>&#13;
<p>When you mark a class’s constructor as <code>private</code>, that means you can’t instantiate or extend the class. What happens when you mark it as <code>protected</code> instead? Play around with this in your code editor, and see if you can figure it out.</p>&#13;
</li>&#13;
<li>&#13;
<p>Extend the implementation we developed <a data-type="xref" href="#factory-pattern">“Factory Pattern”</a> to make it safer, at the expense of breaking the abstraction a bit. Update the implementation so that a consumer knows at compile time that calling <code>Shoe.create('boot')</code> returns a <code>Boot</code> and calling <code>Shoe.create('balletFlat')</code> returns a <code>BalletFlat</code> (rather than both returning a <code>Shoe</code>). Hint: think back to <a data-type="xref" href="ch04.html#function-overloads">“Overloaded Function Types”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>[Hard] As an exercise, think about how you might design a typesafe builder pattern. Extend the Builder pattern <a data-type="xref" href="#builder-pattern">“Builder Pattern”</a> to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Guarantee at compile time that someone can’t call <code>.send</code> before setting at least a URL and a method. Would it be easier to make this guarantee if you also force the user to call methods in a specific order? (Hint: what can you return instead of <code>this</code>?)</p>&#13;
</li>&#13;
<li>&#13;
<p>[Harder] How would you change your design if you wanted to make this guarantee, but still let people call methods in any order? (Hint: what TypeScript feature can you use to make each method’s return type “add” to the <code>this</code> type after each method call?)</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304973683464"><sup><a href="ch05.html#idm46304973683464-marker">1</a></sup> Or are on track to soon be supported by JavaScript classes.</p><p data-type="footnote" id="idm46304971345608"><sup><a href="ch05.html#idm46304971345608-marker">2</a></sup> Because TypeScript is structurally typed, of course, the relationship for classes is more of a “looks-like”—any object that implements the same shape as your class will be assignable to the type of your class.</p><p data-type="footnote" id="idm46304970560536"><sup><a href="ch05.html#idm46304970560536-marker">3</a></sup> Note that TypeScript is picky here: the type of a constructor type’s arguments has to be <code>any[]</code> (not <code>void</code>, <code>unknown[]</code>, etc.) in order for us to be able to extend it.</p><p data-type="footnote" id="idm46304970288936"><sup><a href="ch05.html#idm46304970288936-marker">4</a></sup> A handful of languages—Scala, PHP, Kotlin, and Rust, to name a few—implement a pared-down version of mixins, called <em>traits</em>. Traits are like mixins, but don’t have constructors and don’t support instance properties. This makes it easier to wire them up and prevent collisions between multiple traits accessing state that is shared between them and the base class.</p></div></div></section></body></html>