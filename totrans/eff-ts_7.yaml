- en: Chapter 7\. Writing and Running Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is a bit of a grab bag: it covers some issues that come up in
    writing code (not types) as well as issues you may run into when you run your
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Item 53: Prefer ECMAScript Features to TypeScript Features'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The relationship between TypeScript and JavaScript has changed over time. When
    Microsoft first started work on TypeScript in 2010, the prevailing attitude around
    JavaScript was that it was a problematic language that needed to be fixed. It
    was common for frameworks and source-to-source compilers to add missing features
    like classes, decorators, and a module system to JavaScript. TypeScript was no
    different. Early versions included home-grown versions of classes, enums, and
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time TC39, the standards body that governs JavaScript, added many of these
    same features to the core JavaScript language. And the features they added were
    not compatible with the versions that existed in TypeScript. This left the TypeScript
    team in an awkward predicament: adopt the new features from the standard or break
    existing code?'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript has largely chosen to do the latter and eventually articulated its
    current governing principle: TC39 defines the runtime while TypeScript innovates
    solely in the type space.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few remaining features from before this decision. It’s important
    to recognize and understand these, because they don’t fit the pattern of the rest
    of the language. In general, I recommend avoiding them to keep the relationship
    between TypeScript and JavaScript as clear as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many languages model types that can take on a small set of values using *enumerations*
    or *enums*. TypeScript adds them to JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument for enums is that they provide more safety and transparency than
    bare numbers. But enums in TypeScript have some quirks. There are actually several
    variants on enums that all have subtly different behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: A number-valued enum (like `Flavor`). Any number is assignable to this, so it’s
    not very safe. (It was designed this way to make bit flag structures possible.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string-valued enum. This does offer type safety, and also more transparent
    values at runtime. But it’s not structurally typed, unlike every other type in
    TypeScript (more on this momentarily).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const enum`. Unlike regular enums, const enums go away completely at runtime.
    If you changed to `const enum Flavor` in the previous example, the compiler would
    rewrite `Flavor.CHOCOLATE` as `0`. This also breaks our expectations around how
    the compiler behaves and still has the divergent behaviors between `string` and
    `number`-valued enums.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const enum` with the `preserveConstEnums` flag set. This emits runtime code
    for `const enum`s, just like for a regular `enum`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That string-valued enums are nominally typed comes as a particular surprise,
    since every other type in TypeScript uses structural typing for assignability
    (see [Item 4](ch01.html#structural)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This has implications when you publish a library. Suppose you have a function
    that takes a `Flavor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Because a `Flavor` at runtime is really just a string, it’s fine for your JavaScript
    users to call it with one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'but your TypeScript users will need to import the `enum` and use that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These divergent experiences for JavaScript and TypeScript users are a reason
    to avoid string-valued enums.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript offers an alternative to enums that is less common in other languages:
    a union of literal types.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This offers as much safety as the enum and has the advantage of translating
    more directly to JavaScript. It also offers similarly strong autocomplete in your
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For more on this approach, see [Item 33](ch04.html#avoid-strings).
  prefs: []
  type: TYPE_NORMAL
- en: Parameter Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s common to assign properties to a constructor parameter when initializing
    a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript provides a more compact syntax for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called a “parameter property,” and it is equivalent to the code in
    the first example. There are a few issues to be aware of with parameter properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They are one of the few constructs which generates code when you compile to
    JavaScript (`enum`s are another). Generally compilation just involves erasing
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the parameter is only used in generated code, the source looks like
    it has unused parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mix of parameter and non-parameter properties can hide the design of your
    classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This class has three properties (`first`, `last`, `name`), but this is hard
    to read off the code because only two are listed before the constructor. This
    gets worse if the constructor takes other parameters, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your class consists *only* of parameter properties and no methods, you might
    consider making it an `interface` and using object literals. Remember that the
    two are assignable to one another because of structural typing [Item 4](ch01.html#structural):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Opinions are divided on parameter properties. While I generally avoid them,
    others appreciate the saved keystrokes. Be aware that they do not fit the pattern
    of the rest of TypeScript, and may in fact obscure that pattern for new developers.
    Try to avoid hiding the design of your class by using a mix of parameter and non-parameter
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces and Triple-Slash Imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before ECMAScript 2015, JavaScript didn’t have an official module system. Different
    environments added this missing feature in different ways: Node.js used `require`
    and `module.exports` whereas AMD used a `define` function with a callback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript also filled this gap with its own module system. This was done using
    a `module` keyword and “triple-slash” imports. After ECMAScript 2015 added an
    official module system, TypeScript added `namespace` as a synonym for `module`,
    to avoid confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Outside of type declarations, triple-slash imports and the `module` keyword
    are just a historical curiosity. In your own code, you should use ECMASCript 2015–style
    modules (`import` and `export`). See [Item 58](ch08.html#write-modern-js).
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Decorators can be used to annotate or modify classes, methods, and properties.
    For example, you could define a `logged` annotation that logs all calls to a method
    on a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This feature was initially added to support the Angular framework and requires
    the `experimentalDecorators` property to be set in `tsconfig.json`. Their implementation
    has not yet been standardized by TC39 at the time of this writing, so any code
    you write today using decorators is liable to break or become non-standard in
    the future. Unless you’re using Angular or another framework that requires annotations
    and until they’re standardized, don’t use TypeScript’s decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By and large, you can convert TypeScript to JavaScript by removing all the types
    from your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums, parameter properties, triple-slash imports, and decorators are historical
    exceptions to this rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to keep TypeScript’s role in your codebase as clear as possible, I
    recommend avoiding these features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 54: Know How to Iterate Over Objects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This code runs fine, and yet TypeScript flags an error in it. Why?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting the `obj` and `k` symbols gives a clue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `k` is `string`, but you’re trying to index into an object whose
    type only has three specific keys: `''one''`, `''two''`, and `''three''`. There
    are strings other than these three, so this has to fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plugging in a narrower type declaration for `k` fixes the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So the real question is: why is the type of `k` in the first example inferred
    as `string` rather than `"one" | "two" | "three"`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand, let’s look at a slightly different example involving an interface
    and a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s the same error as before. And you can “fix” it using the same sort of
    declaration (`let k: keyof ABC`). But in this case TypeScript is right to complain.
    Here’s why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The function `foo` can be called with any value *assignable* to `ABC`, not just
    a value with “a,” “b,” and “c” properties. It’s entirely possible that the value
    will have other properties, too (see [Item 4](ch01.html#structural)). To allow
    for this, TypeScript gives `k` the only type it can be confident of, namely, `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `keyof` declaration would have another downside here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If `"a" | "b" | "c"` is too narrow for `k`, then `string | number` is certainly
    too narrow for `v`. In the preceding example one of the values is a `Date`, but
    it could be anything. The types here give a false sense of certainty that could
    lead to chaos at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what if you just want to iterate over the object’s keys and values without
    type errors? `Object.entries` lets you iterate over both simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While these types may be hard to work with, they are at least honest!
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also be aware of the possibility of *prototype pollution*. Even
    in the case of an object literal that you define, for-in can produce additional
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully this doesn’t happen in a nonadversarial environment (you should never
    add enumerable properties to `Object.prototype`), but it is another reason that
    for-in produces `string` keys even for object literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to iterate over the keys and values in an object, use either a
    `keyof` declaration (`let k: keyof T`) or `Object.entries`. The former is appropriate
    for constants or other situations where you know that the object won’t have additional
    keys and you want precise types. The latter is more generally appropriate, though
    the key and value types are more difficult to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `let k: keyof T` and a for-in loop to iterate objects when you know exactly
    what the keys will be. Be aware that any objects your function receives as parameters
    might have additional keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `Object.entries` to iterate over the keys and values of any object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 55: Understand the DOM hierarchy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the items in this book are agnostic about where you run your TypeScript:
    in a web browser, on a server, on a phone. This one is different. If you’re not
    working in a browser, skip ahead!'
  prefs: []
  type: TYPE_NORMAL
- en: The DOM hierarchy is always present when you’re running JavaScript in a web
    browser. When you use `document.getElementById` to get an element or `document.createElement`
    to create one, it’s always a particular kind of element, even if you’re not entirely
    familiar with the taxonomy. You call the methods and use the properties that you
    want and hope for the best.
  prefs: []
  type: TYPE_NORMAL
- en: With TypeScript, the hierarchy of DOM elements becomes more visible. Knowing
    your `Node`s from your `Element`s and `EventTarget`s will help you debug type
    errors and decide when type assertions are appropriate. Because so many APIs are
    based on the DOM, this is relevant even if you’re using a framework like React
    or d3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to track a user’s mouse as they drag it across a `<div>`.
    You write some seemingly innocuous JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript’s type checker flags no fewer than 11 errors in these 14 lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What went wrong? What’s this `EventTarget`? And why might everything be `null`?
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the `EventTarget` errors it helps to dig into the DOM hierarchy
    a bit. Here’s some HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open your browser’s JavaScript console and get a reference to the `p`
    element, you’ll see that it’s an `HTMLParagraphElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'An `HTMLParagraphElement` is a subtype of `HTMLElement`, which is a subtype
    of `Element`, which is a subtype of `Node`, which is a subtype of `EventTarget`.
    Here are some examples of types along the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Types in the DOM Hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| EventTarget | `window`, `XMLHttpRequest` |'
  prefs: []
  type: TYPE_TB
- en: '| Node | `document`, `Text`, `Comment` |'
  prefs: []
  type: TYPE_TB
- en: '| Element | *includes HTMLElements, SVGElements* |'
  prefs: []
  type: TYPE_TB
- en: '| HTMLElement | `<i>`, `<b>` |'
  prefs: []
  type: TYPE_TB
- en: '| HTMLButtonElement | `<button>` |'
  prefs: []
  type: TYPE_TB
- en: 'An `EventTarget` is the most generic of DOM types. All you can do with it is
    add event listeners, remove them, and dispatch events. With this in mind, the
    `classList` errors start to make a bit more sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As its name implies, an `Event`’s `currentTarget` property is an `EventTarget`.
    It could even be `null`. TypeScript has no reason to believe that it has a `classList`
    property. While an `EventTarget`s *could* be an `HTMLElement` in practice, from
    the type system’s perspective there’s no reason it couldn’t be `window` or `XMLHTTPRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving up the hierarchy we come to `Node`. A couple of examples of `Node`s
    that are not `Element`s are text fragments and comments. For instance, in this
    HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'the outermost element is an `HTMLParagraphElement`. As you can see here, it
    has `children` and `childNodes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`children` returns an `HTMLCollection`, an array-like structure containing
    just the child `Element`s (`<i>yet</i>`). `childNodes` returns a `NodeList`, an
    Array-like collection of `Node`s. This includes not just `Element`s (`<i>yet</i>`)
    but also text fragments (“And,” “it moves”) and comments (“quote from Galileo”).'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference between an `Element` and an `HTMLElement`? There are non-HTML
    `Element`s including the whole hierarchy of SVG tags. These are `SVGElement`s,
    which are another type of `Element`. What’s the type of an `<html>` or `<svg>`
    tag? They’re `HTMLHtmlElement` and `SVGSvgElement`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes these specialized classes will have properties of their own—for example,
    an `HTMLImageElement` has a `src` property, and an `HTMLInputElement` has a `value`
    property. If you want to read one of these properties off a value, its type must
    be specific enough to have that property.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript’s type declarations for the DOM make liberal use of literal types
    to try to get you the most specific type possible. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'but this is not always possible, notably with `document.getElementById`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'While type assertions are generally frowned upon ([Item 9](ch02_split_000.html#prefer-declarations-to-assertions)),
    this is a case where you know more than TypeScript does and so they are appropriate.
    There’s nothing wrong with this, so long as you know that `#my-div` is a div:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'with `strictNullChecks` enabled, you will need to consider the case that `document.getElementById`
    returns `null`. Depending on whether this can really happen, you can either add
    an if statement or an assertion (`!`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These types are not specific to TypeScript. Rather, they are generated from
    the formal specification of the DOM. This is an example of the advice of [Item
    35](ch04.html#consider-codegen) to generate types from specs when possible.
  prefs: []
  type: TYPE_NORMAL
- en: So much for the DOM hierarchy. What about the `clientX` and `clientY` errors?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the hierarchy for `Node`s and `Element`s, there is also a hierarchy
    for `Event`s. The Mozilla documentation currently lists no fewer than 52 types
    of `Event`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Plain `Event` is the most generic type of event. More specific types include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UIEvent`'
  prefs: []
  type: TYPE_NORMAL
- en: Any sort of user interface event
  prefs: []
  type: TYPE_NORMAL
- en: '`MouseEvent`'
  prefs: []
  type: TYPE_NORMAL
- en: An event triggered by the mouse such as a click
  prefs: []
  type: TYPE_NORMAL
- en: '`TouchEvent`'
  prefs: []
  type: TYPE_NORMAL
- en: A touch event on a mobile device
  prefs: []
  type: TYPE_NORMAL
- en: '`WheelEvent`'
  prefs: []
  type: TYPE_NORMAL
- en: An event triggered by rotating the scroll wheel
  prefs: []
  type: TYPE_NORMAL
- en: '`KeyboardEvent`'
  prefs: []
  type: TYPE_NORMAL
- en: A key press
  prefs: []
  type: TYPE_NORMAL
- en: The problem in `handleDrag` is that the events are declared as `Event`, while
    `clientX` and `clientY` exist only on the more specific `MouseEvent` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how can you fix the example from the start of this item? TypeScript’s declarations
    for the DOM make extensive use of context ([Item 26](ch03.html#context-inference)).
    Inlining the mousedown handler gives TypeScript more information to work with
    and removes most of the errors. You can also declare the parameter type to be
    `MouseEvent` rather than `Event`. Here’s a version that uses both techniques to
    fix the errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement at the end handles the possibility that there is no `#surface`
    element. If you know that this element exists, you could use an assertion instead
    (`div!`). `addDragHandler` requires a non-null `HTMLElement`, so this is an example
    of pushing `null` values to the perimeter ([Item 31](ch04.html#null-values-to-perimeter)).
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DOM has a type hierarchy that you can usually ignore while writing JavaScript.
    But these types become more important in TypeScript. Understanding them will help
    you write TypeScript for the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know the differences between `Node`, `Element`, `HTMLElement`, and `EventTarget`,
    as well as those between `Event` and `MouseEvent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either use a specific enough type for DOM elements and Events in your code or
    give TypeScript the context to infer it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 56: Don’t Rely on Private to Hide Information'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript has historically lacked a way to make properties of a class private.
    The usual workaround is a convention of prefixing fields that are not part of
    a public API with underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But this only discourages users from accessing private data. It is easy to
    circumvent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript adds `public`, `protected`, and `private` field modifiers that seem
    to provide some enforcement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'But `private` is a feature of the type system and, like all features of the
    type system, it goes away at runtime (see [Item 3](ch01.html#independent)). Here’s
    what this snippet looks like when TypeScript compiles it to JavaScript (with `target=ES2017`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `private` indicator is gone, and your secret is out! Much like the `_private`
    convention, TypeScript’s access modifiers only discourage you from accessing private
    data. With a type assertion, you can even access a private property from within
    TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In other words, *don’t rely on `private` to hide information!*
  prefs: []
  type: TYPE_NORMAL
- en: 'So what should you do if you want something more robust? The traditional answer
    has been to take advantage of one of JavaScript’s most reliable ways to hide information:
    closures. You can create one in a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript offers no way to access the `passwordHash` variable from outside
    of the constructor of `PasswordChecker`. This does have a few downsides, however:
    specifically, because `passwordHash` can’t be seen outside the constructor, every
    method that uses it also has to be defined there. This results in a copy of each
    method being created for every class instance, which will lead to higher memory
    use. It also prevents other instances of the same class from accessing private
    data. Closures may be inconvenient, but they will certainly keep your data private!'
  prefs: []
  type: TYPE_NORMAL
- en: 'A newer option is to use private fields, a proposed language feature that is
    solidifying as this book goes to print. In this proposal, to make a field private
    both for type checking and at runtime, prefix it with a `#`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `#passwordHash` property is not accessible from outside the class. In contrast
    to the closure technique, it *is* accessible from class methods and from other
    instances of the same class. For ECMAScript targets that don’t natively support
    private fields, a fallback implementation using `WeakMap`s is used instead. The
    upshot is that your data is still private. This proposal was stage 3 and support
    was being added to TypeScript as this book went to print. If you’d like to use
    it, check the TypeScript release notes to see if it’s generally available.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you are worried about *security*, rather than just encapsulation,
    then there are others concerns to be aware of such as modifications to built-in
    prototypes and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `private` access modifier is only enforced through the type system. It has
    no effect at runtime and can be bypassed with an assertion. Don’t assume it will
    keep data hidden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more reliable information hiding, use a closure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 57: Use Source Maps to Debug TypeScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run TypeScript code, you’re actually running the JavaScript that the
    TypeScript compiler generates. This is true of any source-to-source compiler,
    be it a minifier, a compiler, or a preprocessor. The hope is that this is mostly
    transparent, that you can pretend that the TypeScript source code is being executed
    without ever having to look at the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: This works well until you have to debug your code. Debuggers generally work
    on the code you’re executing and don’t know about the translation process it went
    through. Since JavaScript is such a popular target language, browser vendors collaborated
    to solve this problem. The result is source maps. They map positions and symbols
    in a generated file back to the corresponding positions and symbols in the original
    source. Most browsers and many IDEs support them. If you’re not using them to
    debug your TypeScript, you’re missing out!
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you’ve created a small script to add a button to an HTML page that
    increments every time you click it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you load this in your browser and open the debugger, you’ll see the generated
    JavaScript. This closely matches the original source, so debugging isn’t too difficult,
    as you can see in [Figure 7-1](#efts-07in01).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 07in01](assets/efts_07in01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Debugging generated JavaScript using Chrome’s developer tools.
    For this simple example, the generated JavaScript closely resembles the TypeScript
    source.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s make the page more fun by fetching an interesting fact about each number
    from numbersapi.com:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you open up your browser’s debugger now, you’ll see that the generated source
    has gotten dramatically more complicated (see [Figure 7-2](#efts-07in02)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 07in02](assets/efts_07in02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. In this case the TypeScript compiler has generated JavaScript that
    doesn’t closely resemble the original TypeScript source. This will make debugging
    more difficult.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To support `async` and `await` in older browsers, TypeScript has rewritten the
    event handler as a state machine. This has the same behavior, but the code no
    longer bears such a close resemblance to the original source.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where source maps can help. To tell TypeScript to generate one, set
    the `sourceMap` option in your *tsconfig.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run `tsc`, it generates two output files for each *.ts* file:
    a *.js* file and a *.js.map* file. The latter is the source map.'
  prefs: []
  type: TYPE_NORMAL
- en: With this file in place, a new *index.ts* file appears in your browser’s debugger.
    You can set breakpoints and inspect variables in it, just as you’d hope (see [Figure 7-3](#efts-07in03)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 07in03](assets/efts_07in03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. When a source map is present, you can work with the original TypeScript
    source in your debugger, rather than the generated JavaScript.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that *index.ts* appears in italics in the file list on the left. This indicates
    that it isn’t a “real” file in the sense that the web page included it. Rather,
    it was included via the source map. Depending on your settings, *index.js.map*
    will contain either a reference to *index.ts* (in which case the browser loads
    it over the network) or an inline copy of it (in which case no request is needed).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things to be aware of with source maps:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a bundler or minifier with TypeScript, it may generate a source
    map of its own. To get the best debugging experience, you want this to map all
    the way back to the original TypeScript sources, not the generated JavaScript.
    If your bundler has built-in support for TypeScript, then this should just work.
    If not, you may need to hunt down some flags to make it read source map inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware of whether you’re serving source maps in production. The browser won’t
    load source maps unless the debugger is open, so there’s no performance impact
    for end users. But if the source map contains an inline copy of your original
    source code, then there may be content that you didn’t intend to publicize. Does
    the world really need to see your snarky comments or internal bug tracker URLs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also debug NodeJS programs using source maps. This is typically done
    via your editor or by connecting to your node process from a browser’s debugger.
    Consult the Node docs for details.
  prefs: []
  type: TYPE_NORMAL
- en: The type checker can catch many errors before you run your code, but it is no
    substitute for a good debugger. Use source maps to get a great TypeScript debugging
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t debug generated JavaScript. Use source maps to debug your TypeScript code
    at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that your source maps are mapped all the way through to the code that
    you run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on your settings, your source maps might contain an inline copy of
    your original code. Don’t publish them unless you know what you’re doing!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
