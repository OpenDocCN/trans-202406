<html><head></head><body><section data-pdf-bookmark="Chapter 4. Type Design" data-type="chapter" epub:type="chapter" class="praise"><div class="praise" id="ch-design">
<h1 class="calibre14"><span class="calibre">Chapter 4. </span>Type Design</h1>

<blockquote class="calibre4 pcalibre pcalibre1">
  <p class="calibre5">Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious.</p>
  <p data-type="attribution" class="pcalibre2 calibre6">Fred Brooks, <em class="calibre3">The Mythical Man Month</em></p>
</blockquote>

<p class="author1">The<a data-primary="Brooks, Fred" data-type="indexterm" id="idm45331659721784" class="calibre9"/> language in Fred Brooks’s quote is dated, but the sentiment remains true: code is difficult to understand if you can’t see the data or data types on which it operates. This is one of the great advantages of a type system: by writing out types, you make them visible to readers of your code. And this makes your code understandable.</p>

<p class="author1">Other chapters cover the nuts and bolts of TypeScript types: using them, inferring them, and writing declarations with them. This chapter discusses the design of the types themselves. The examples in this chapter are all written with TypeScript in mind, but most of the ideas are more broadly applicable.</p>

<p class="author1">If you write your types well, then with any luck your flowcharts will be obvious, too.</p>






<section data-pdf-bookmark="Item 28: Prefer Types That Always Represent Valid States" data-type="sect1" class="praise"><div class="praise" id="valid-states">
<h1 class="calibre16">Item 28: Prefer Types That Always Represent Valid States</h1>

<p class="author1">If<a data-primary="type design" data-secondary="types representing valid versus invalid states" data-type="indexterm" id="TDvalid04" class="calibre9"/><a data-primary="valid states" data-type="indexterm" id="valids04" class="calibre9"/><a data-primary="invalid states" data-type="indexterm" id="invalid04" class="calibre9"/> you design your types well, your code should be straightforward to write. But if you design your types poorly, no amount of cleverness or documentation will save you. Your code will be confusing and bug prone.</p>

<p class="author1">A key to effective type design is crafting types that can only represent a valid state. This item walks through a few examples of how this can go wrong and shows you how to fix them.</p>

<p class="author1">Suppose you’re building a web application that lets you select a page, loads the content of that page, and then displays it. You might write the state like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">pageText</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">isLoading</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="nx">error?</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">When you write your code to render the page, you need to consider all of these fields:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">renderPage</code><code class="p">(</code><code class="nx">state</code>: <code class="nx">State</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="s">`Error! Unable to load </code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">: </code><code class="si">${</code><code class="nx">state</code><code class="p">.</code><code class="nx">error</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">isLoading</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="s">`Loading </code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">...`</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="s">`&lt;h1&gt;</code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">&lt;/h1&gt;</code><code class="si">\</code><code class="s">n</code><code class="si">${</code><code class="nx">state</code><code class="p">.</code><code class="nx">pageText</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Is this right, though? What if <code class="calibre18">isLoading</code> and <code class="calibre18">error</code> are both set? What would that mean? Is it better to display the loading message or the error message? It’s hard to say! There’s not enough information available.</p>

<p class="author1">Or what if you’re writing a <code class="calibre18">changePage</code> function? Here’s an attempt:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">changePage</code><code class="p">(</code><code class="nx">state</code>: <code class="nx">State</code><code class="p">,</code> <code class="nx">newPage</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">state</code><code class="p">.</code><code class="nx">isLoading</code> <code class="o">=</code> <code class="kd">true</code><code class="p">;</code>
  <code class="kd">try</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">getUrlForPage</code><code class="p">(</code><code class="nx">newPage</code><code class="p">));</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">`Unable to load </code><code class="si">${</code><code class="nx">newPage</code><code class="si">}</code><code class="s">: </code><code class="si">${</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusText</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="kd">const</code> <code class="nx">text</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">isLoading</code> <code class="o">=</code> <code class="kd">false</code><code class="p">;</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">pageText</code> <code class="o">=</code> <code class="nx">text</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">error</code> <code class="o">=</code> <code class="s">''</code> <code class="o">+</code> <code class="nx">e</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">There are many problems with this! Here are a few:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">We forgot to set <code class="calibre18">state.isLoading</code> to <code class="calibre18">false</code> in the error case.</p>
</li>
<li class="calibre12">
<p class="author1">We didn’t clear out <code class="calibre18">state.error</code>, so if the previous request failed, then you’ll keep seeing that error message instead of a loading message.</p>
</li>
<li class="calibre12">
<p class="author1">If the user changes pages again while the page is loading, who knows what will happen. They might see a new page and then an error, or the first page and not the second depending on the order in which the responses come back.</p>
</li>
</ul>

<p class="author1">The problem is that the state includes both too little information (which request failed? which is loading?) and too much: the <code class="calibre18">State</code> type allows both <code class="calibre18">isLoading</code> and <code class="calibre18">error</code> to be set, even though this represents an invalid state. This makes both <span class="calibre"><code class="calibre18">render()</code></span> and <code class="calibre18">changePage()</code> impossible to implement well.</p>

<p class="author1">Here’s a better way to represent the application state:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">RequestPending</code> <code class="p">{</code>
  <code class="nx">state</code><code class="o">:</code> <code class="s">'pending'</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">RequestError</code> <code class="p">{</code>
  <code class="nx">state</code><code class="o">:</code> <code class="s">'error'</code><code class="p">;</code>
  <code class="nx">error</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">RequestSuccess</code> <code class="p">{</code>
  <code class="nx">state</code><code class="o">:</code> <code class="s">'ok'</code><code class="p">;</code>
  <code class="nx">pageText</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">RequestState</code> <code class="o">=</code> <code class="nx">RequestPending</code> <code class="o">|</code> <code class="nx">RequestError</code> <code class="o">|</code> <code class="nx">RequestSuccess</code><code class="p">;</code>

<code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">currentPage</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">requests</code><code class="o">:</code> <code class="p">{[</code><code class="nx">page</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">RequestState</code><code class="p">};</code>
<code class="p">}</code></pre>

<p class="author1">This uses a tagged union (also known as a “discriminated union”) to explicitly model the different states that a network request can be in. This version of the state is three to four times longer, but it has the enormous advantage of not admitting invalid states. The current page is modeled explicitly, as is the state of every request that you issue. As a result, the <code class="calibre18">renderPage</code> and <code class="calibre18">changePage</code> functions are easy to implement:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">renderPage</code><code class="p">(</code><code class="nx">state</code>: <code class="nx">State</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">currentPage</code><code class="p">}</code> <code class="o">=</code> <code class="nx">state</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">requestState</code> <code class="o">=</code> <code class="nx">state</code><code class="p">.</code><code class="nx">requests</code><code class="p">[</code><code class="nx">currentPage</code><code class="p">];</code>
  <code class="kd">switch</code> <code class="p">(</code><code class="nx">requestState</code><code class="p">.</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">case</code> <code class="s">'pending'</code><code class="o">:</code>
      <code class="kd">return</code> <code class="s">`Loading </code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">...`</code><code class="p">;</code>
    <code class="kd">case</code> <code class="s">'error'</code><code class="o">:</code>
      <code class="kd">return</code> <code class="s">`Error! Unable to load </code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">: </code><code class="si">${</code><code class="nx">requestState</code><code class="p">.</code><code class="nx">error</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
    <code class="kd">case</code> <code class="s">'ok'</code><code class="o">:</code>
      <code class="kd">return</code> <code class="s">`&lt;h1&gt;</code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">&lt;/h1&gt;</code><code class="si">\</code><code class="s">n</code><code class="si">${</code><code class="nx">requestState</code><code class="p">.</code><code class="nx">pageText</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">async</code> <code class="kd">function</code> <code class="nx">changePage</code><code class="p">(</code><code class="nx">state</code>: <code class="nx">State</code><code class="p">,</code> <code class="nx">newPage</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">state</code><code class="p">.</code><code class="nx">requests</code><code class="p">[</code><code class="nx">newPage</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code><code class="nx">state</code><code class="o">:</code> <code class="s">'pending'</code><code class="p">};</code>
  <code class="nx">state</code><code class="p">.</code><code class="nx">currentPage</code> <code class="o">=</code> <code class="nx">newPage</code><code class="p">;</code>
  <code class="kd">try</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">getUrlForPage</code><code class="p">(</code><code class="nx">newPage</code><code class="p">));</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">`Unable to load </code><code class="si">${</code><code class="nx">newPage</code><code class="si">}</code><code class="s">: </code><code class="si">${</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusText</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="kd">const</code> <code class="nx">pageText</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">requests</code><code class="p">[</code><code class="nx">newPage</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code><code class="nx">state</code><code class="o">:</code> <code class="s">'ok'</code><code class="p">,</code> <code class="nx">pageText</code><code class="p">};</code>
  <code class="p">}</code> <code class="kd">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">requests</code><code class="p">[</code><code class="nx">newPage</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code><code class="nx">state</code><code class="o">:</code> <code class="s">'error'</code><code class="p">,</code> <code class="nx">error</code><code class="o">:</code> <code class="s">''</code> <code class="o">+</code> <code class="nx">e</code><code class="p">};</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">The ambiguity from the first implementation is entirely gone: it’s clear what the current page is, and every request is in exactly one state. If the user changes the page after a request has been issued, that’s no problem either. The old request still completes, but it doesn’t affect the UI.</p>

<p class="author1">For a simpler but more dire example, consider the fate of Air France Flight 447, an Airbus 330 that disappeared over the Atlantic on June 1, 2009. The Airbus was a fly-by-wire aircraft, meaning that the pilots’ control inputs went through a computer system before affecting the physical control surfaces of the plane. In the wake of the crash there were many questions raised about the wisdom of relying on computers to make such life-and-death decisions. Two years later when the black box recorders were recovered, they revealed many factors that led to the crash. But a key one was bad state design.</p>

<p class="author1">The cockpit of the Airbus 330 had a separate set of controls for the pilot and copilot. The “side sticks” controlled the angle of attack. Pulling back would send the airplane into a climb, while pushing forward would make it dive. The Airbus 330 used a system called “dual input” mode, which let the two side sticks move independently. Here’s how you might model its state in TypeScript:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">CockpitControls</code> <code class="p">{</code>
  <code class="c">/** Angle of the left side stick in degrees, 0 = neutral, + = forward */</code>
  <code class="nx">leftSideStick</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="c">/** Angle of the right side stick in degrees, 0 = neutral, + = forward */</code>
  <code class="nx">rightSideStick</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Suppose you were given this data structure and asked to write a <code class="calibre18">getStickSetting</code> function that computed the current stick setting. How would you do it?</p>

<p class="author1">One way would be to assume that the pilot (who sits on the left) is in control:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">controls</code><code class="p">.</code><code class="nx">leftSideStick</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">But what if the copilot has taken control? Maybe you should use whichever stick is away from zero:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">leftSideStick</code><code class="p">,</code> <code class="nx">rightSideStick</code><code class="p">}</code> <code class="o">=</code> <code class="nx">controls</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">rightSideStick</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">leftSideStick</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">But there’s a problem with this implementation: we can only be confident returning the left setting if the right one is neutral. So you should check for that:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">leftSideStick</code><code class="p">,</code> <code class="nx">rightSideStick</code><code class="p">}</code> <code class="o">=</code> <code class="nx">controls</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">rightSideStick</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">rightSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">leftSideStick</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="c">// ???</code>
<code class="p">}</code></pre>

<p class="author1">What do you do if they’re both non-zero? Hopefully they’re about the same, in which case you could just average them:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">leftSideStick</code><code class="p">,</code> <code class="nx">rightSideStick</code><code class="p">}</code> <code class="o">=</code> <code class="nx">controls</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">rightSideStick</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">rightSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">leftSideStick</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">-</code> <code class="nx">rightSideStick</code><code class="p">)</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">+</code> <code class="nx">rightSideStick</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="c">// ???</code>
<code class="p">}</code></pre>

<p class="author1">But what if they’re not? Can you throw an error? Not really: the ailerons need to be set at some angle!</p>

<p class="author1">On Air France 447, the copilot silently pulled back on his side stick as the plane entered a storm. It gained altitude but eventually lost speed and entered a stall, a condition in which the plane is moving too slowly to effectively generate lift. It began to drop.</p>

<p class="author1">To escape a stall, pilots are trained to push the controls forward to make the plane dive and regain speed. This is exactly what the pilot did. But the copilot was still silently pulling back on his side stick. And the Airbus function looked like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">(</code><code class="nx">controls</code><code class="p">.</code><code class="nx">leftSideStick</code> <code class="o">+</code> <code class="nx">controls</code><code class="p">.</code><code class="nx">rightSideStick</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Even though the pilot pushed the stick fully forward, it averaged out to nothing. He had no idea why the plane wasn’t diving. By the time the copilot revealed what he’d done, the plane had lost too much altitude to recover and it crashed into the ocean, killing all 228 people on board.</p>

<p class="author1">The point of all this is that there is no good way to implement <code class="calibre18">getStickSetting</code> given that input! The function has been set up to fail. In most planes the two sets of controls are mechanically connected. If the copilot pulls back, the pilot’s controls will also pull back. The state of these controls is simple to express:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">CockpitControls</code> <code class="p">{</code>
  <code class="c">/** Angle of the stick in degrees, 0 = neutral, + = forward */</code>
  <code class="nx">stickAngle</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">And<a data-primary="Brooks, Fred" data-type="indexterm" id="idm45331658624456" class="calibre9"/> now, as in the Fred Brooks quote from the start of the chapter, our flowcharts are obvious. You don’t need a <code class="calibre18">getStickSetting</code> function at all.</p>

<p class="author1">As you design your types, take care to think about which values you are including and which you are excluding. If you only allow values that represent valid states, your code will be easier to write and TypeScript will have an easier time checking it. This is a very general principle, and several of the other items in this chapter will cover specific manifestations of it.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331658622392">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Types that represent both valid and invalid states are likely to lead to confusing and error-prone code.</p>
</li>
<li class="calibre12">
<p class="author1">Prefer types that only represent valid states. Even if they are longer or harder to express, they will save you time and pain in the end!<a data-primary="" data-startref="invalid04" data-type="indexterm" id="idm45331658709624" class="calibre9"/><a data-primary="" data-startref="valids04" data-type="indexterm" id="idm45331658708648" class="calibre9"/><a data-primary="" data-startref="TDvalid04" data-type="indexterm" id="idm45331658707704" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 29: Be Liberal in What You Accept and Strict in What You Produce" data-type="sect1" class="praise"><div class="praise" id="loose-accept-strict-produce">
<h1 class="calibre16">Item 29: Be Liberal in What You Accept and Strict in What You Produce</h1>

<p class="author1">This<a data-primary="type design" data-secondary="robustness principle" data-type="indexterm" id="TDrobuts04" class="calibre9"/><a data-primary="robustness principle" data-type="indexterm" id="robust04" class="calibre9"/><a data-primary="Postel's Law" data-type="indexterm" id="postel04" class="calibre9"/><a data-primary="functions" data-secondary="robustness principle" data-type="indexterm" id="Frobust04" class="calibre9"/> idea is known as the <em class="calibre3">robustness principle</em> or <em class="calibre3">Postel’s Law</em>, after Jon Postel, who wrote it in the context of TCP:</p>
<blockquote class="calibre4 pcalibre pcalibre1">
<p class="calibre5">TCP implementations should follow a general principle of robustness: be conservative in what you do, be liberal in what you accept from others.</p></blockquote>

<p class="author1">A similar rule applies to the contracts for functions. It’s fine for your functions to be broad in what they accept as inputs, but they should generally be more specific in what they produce as outputs.</p>

<p class="author1">As an example, a 3D mapping API might provide a way to position the camera and to calculate a viewport for a bounding box:</p>

<pre data-code-language="ts" data-type="programlisting" id="set-camera-viewport" class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">setCamera</code><code class="p">(</code><code class="nx">camera</code>: <code class="nx">CameraOptions</code><code class="p">)</code><code class="o">:</code> <code class="kd">void</code><code class="p">;</code>
<code class="kd">declare</code> <code class="kd">function</code> <code class="nx">viewportForBounds</code><code class="p">(</code><code class="nx">bounds</code>: <code class="nx">LngLatBounds</code><code class="p">)</code><code class="o">:</code> <code class="nx">CameraOptions</code><code class="p">;</code></pre>

<p class="author1">It is convenient that the result of <code class="calibre18">viewportForBounds</code> can be passed directly to <span class="calibre"><code class="calibre18">setCamera</code></span> to position the camera.</p>

<p class="author1">Let’s look at the definitions of these types:</p>

<pre data-code-language="ts" data-type="programlisting" id="camera-lnglat-defs" class="calibre17"><code class="kd">interface</code> <code class="nx">CameraOptions</code> <code class="p">{</code>
  <code class="nx">center?</code>: <code class="nx">LngLat</code><code class="p">;</code>
  <code class="nx">zoom?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">bearing?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">pitch?</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">LngLat</code> <code class="o">=</code>
  <code class="p">{</code> <code class="nx">lng</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">lat</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code> <code class="o">|</code>
  <code class="p">{</code> <code class="nx">lon</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">lat</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code> <code class="o">|</code>
  <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code></pre>

<p class="author1">The fields in <code class="calibre18">CameraOptions</code> are all optional because you might want to set just the center or zoom without changing the bearing or pitch. The <code class="calibre18">LngLat</code> type also makes <code class="calibre18">setCamera</code> liberal in what it accepts: you can pass in a <code class="calibre18">{lng, lat}</code> object, a <code class="calibre18">{lon, lat}</code> object, or a <code class="calibre18">[lng, lat]</code> pair if you’re confident you got the order right. These accommodations make the function easy to call.</p>

<p class="author1">The <code class="calibre18">viewportForBounds</code> function takes in another “liberal” type:</p>

<pre data-code-language="ts" data-type="programlisting" id="camera-lnglat-bounds-def" class="calibre17"><code class="kd">type</code> <code class="nx">LngLatBounds</code> <code class="o">=</code>
  <code class="p">{</code><code class="nx">northeast</code>: <code class="nx">LngLat</code><code class="p">,</code> <code class="nx">southwest</code>: <code class="nx">LngLat</code><code class="p">}</code> <code class="o">|</code>
  <code class="p">[</code><code class="nx">LngLat</code><code class="p">,</code> <code class="nx">LngLat</code><code class="p">]</code> <code class="o">|</code>
  <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code></pre>

<p class="author1">You can specify the bounds either using named corners, a pair of lat/lngs, or a four-tuple if you’re confident you got the order right. Since <code class="calibre18">LngLat</code> already accommodates three forms, there are no fewer than 19 possible forms for <code class="calibre18">LngLatBounds</code>. Liberal indeed!</p>

<p class="author1">Now<a data-primary="GeoJSON" data-type="indexterm" id="idm45331658499704" class="calibre9"/> let’s write a function that adjusts the viewport to accommodate a GeoJSON Feature and stores the new viewport in the URL (for a definition of <code class="calibre18">calculateBoundingBox</code>, see <a href="#null-values-to-perimeter" class="calibre9">Item 31</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">focusOnFeature</code><code class="p">(</code><code class="nx">f</code>: <code class="nx">Feature</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">bounds</code> <code class="o">=</code> <code class="nx">calculateBoundingBox</code><code class="p">(</code><code class="nx">f</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">camera</code> <code class="o">=</code> <code class="nx">viewportForBounds</code><code class="p">(</code><code class="nx">bounds</code><code class="p">);</code>
  <code class="nx">setCamera</code><code class="p">(</code><code class="nx">camera</code><code class="p">);</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">center</code><code class="o">:</code> <code class="p">{</code><code class="nx">lat</code><code class="p">,</code> <code class="nx">lng</code><code class="p">},</code> <code class="nx">zoom</code><code class="p">}</code> <code class="o">=</code> <code class="nx">camera</code><code class="p">;</code>
               <code class="c">// ~~~      Property 'lat' does not exist on type ...</code>
               <code class="c">//      ~~~ Property 'lng' does not exist on type ...</code>
  <code class="nx">zoom</code><code class="p">;</code>  <code class="c">// Type is number | undefined</code>
  <code class="nb">window</code><code class="p">.</code><code class="nx">location</code><code class="p">.</code><code class="nx">search</code> <code class="o">=</code> <code class="s">`?v=@</code><code class="si">${</code><code class="nx">lat</code><code class="si">}</code><code class="s">,</code><code class="si">${</code><code class="nx">lng</code><code class="si">}</code><code class="s">z</code><code class="si">${</code><code class="nx">zoom</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Whoops! Only the <code class="calibre18">zoom</code> property exists, but its type is inferred as <code class="calibre18">number|undefined</code>, which is also problematic. The issue is that the type declaration for <code class="calibre18">viewportForBounds</code> indicates that it is liberal not just in what it accepts but also in what it <em class="calibre3">produces</em>. The only type-safe way to use the <code class="calibre18">camera</code> result is to introduce a code branch for each component of the union type (<a href="ch03.html#narrowing" class="calibre9">Item 22</a>).</p>

<p class="author1">The<a data-primary="union types" data-secondary="difficulty in using" data-type="indexterm" id="idm45331658340488" class="calibre9"/><a data-primary="parameter types" data-type="indexterm" id="idm45331658339592" class="calibre9"/><a data-primary="return types" data-type="indexterm" id="idm45331658338920" class="calibre9"/> return type with lots of optional properties and union types makes <code class="calibre18">viewportForBounds</code> difficult to use. Its broad parameter type is convenient, but its broad return type is not. A more convenient API would be strict in what it produces.</p>

<p class="author1">One way to do this is to distinguish a canonical format for coordinates. Following JavaScript’s convention of distinguishing “Array” and “Array-like” (<a href="ch02_split_001.html#number-index" class="calibre9">Item 16</a>), you can draw a distinction between <code class="calibre18">LngLat</code> and <code class="calibre18">LngLatLike</code>. You can also distinguish between a fully defined <code class="calibre18">Camera</code> type and the partial version accepted by <code class="calibre18">setCamera</code>:</p>

<pre data-code-language="ts" data-type="programlisting" id="camera-revised-definitions" class="calibre17"><code class="kd">interface</code> <code class="nx">LngLat</code> <code class="p">{</code> <code class="nx">lng</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">lat</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">};</code>
<code class="kd">type</code> <code class="nx">LngLatLike</code> <code class="o">=</code> <code class="nx">LngLat</code> <code class="o">|</code> <code class="p">{</code> <code class="nx">lon</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">lat</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code> <code class="o">|</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>

<code class="kd">interface</code> <code class="nx">Camera</code> <code class="p">{</code>
  <code class="nx">center</code>: <code class="nx">LngLat</code><code class="p">;</code>
  <code class="nx">zoom</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">bearing</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">pitch</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">CameraOptions</code> <code class="kd">extends</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Camera</code><code class="o">&gt;</code><code class="p">,</code> <code class="s">'center'</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="nx">center?</code>: <code class="nx">LngLatLike</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">LngLatBounds</code> <code class="o">=</code>
  <code class="p">{</code><code class="nx">northeast</code>: <code class="nx">LngLatLike</code><code class="p">,</code> <code class="nx">southwest</code>: <code class="nx">LngLatLike</code><code class="p">}</code> <code class="o">|</code>
  <code class="p">[</code><code class="nx">LngLatLike</code><code class="p">,</code> <code class="nx">LngLatLike</code><code class="p">]</code> <code class="o">|</code>
  <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>

<code class="kd">declare</code> <code class="kd">function</code> <code class="nx">setCamera</code><code class="p">(</code><code class="nx">camera</code>: <code class="nx">CameraOptions</code><code class="p">)</code><code class="o">:</code> <code class="kd">void</code><code class="p">;</code>
<code class="kd">declare</code> <code class="kd">function</code> <code class="nx">viewportForBounds</code><code class="p">(</code><code class="nx">bounds</code>: <code class="nx">LngLatBounds</code><code class="p">)</code><code class="o">:</code> <code class="nx">Camera</code><code class="p">;</code></pre>

<p class="author1">The loose <code class="calibre18">CameraOptions</code> type adapts the stricter <code class="calibre18">Camera</code> type (<a href="ch02_split_001.html#map-between-types" class="calibre9">Item 14</a>).</p>

<p class="author1">Using <code class="calibre18">Partial&lt;Camera&gt;</code> as the parameter type in <code class="calibre18">setCamera</code> would not work here since you do want to allow <code class="calibre18">LngLatLike</code> objects for the <code class="calibre18">center</code> property. And you can’t write "<code class="calibre18">CameraOptions extends Partial&lt;Camera&gt;</code>" since <code class="calibre18">LngLatLike</code> is a superset of <code class="calibre18">LngLat</code>, not a subset (<a href="ch02_split_000.html#types-as-sets" class="calibre9">Item 7</a>). If this seems too complicated, you could also write the type out explicitly at the cost of some repetition:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">CameraOptions</code> <code class="p">{</code>
  <code class="nx">center?</code>: <code class="nx">LngLatLike</code><code class="p">;</code>
  <code class="nx">zoom?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">bearing?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">pitch?</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">In either case, with these new type declarations the <code class="calibre18">focusOnFeature</code> function passes the type checker:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">focusOnFeature</code><code class="p">(</code><code class="nx">f</code>: <code class="nx">Feature</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">bounds</code> <code class="o">=</code> <code class="nx">calculateBoundingBox</code><code class="p">(</code><code class="nx">f</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">camera</code> <code class="o">=</code> <code class="nx">viewportForBounds</code><code class="p">(</code><code class="nx">bounds</code><code class="p">);</code>
  <code class="nx">setCamera</code><code class="p">(</code><code class="nx">camera</code><code class="p">);</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">center</code><code class="o">:</code> <code class="p">{</code><code class="nx">lat</code><code class="p">,</code> <code class="nx">lng</code><code class="p">},</code> <code class="nx">zoom</code><code class="p">}</code> <code class="o">=</code> <code class="nx">camera</code><code class="p">;</code>  <code class="c">// OK</code>
  <code class="nx">zoom</code><code class="p">;</code>  <code class="c">// Type is number</code>
  <code class="nb">window</code><code class="p">.</code><code class="nx">location</code><code class="p">.</code><code class="nx">search</code> <code class="o">=</code> <code class="s">`?v=@</code><code class="si">${</code><code class="nx">lat</code><code class="si">}</code><code class="s">,</code><code class="si">${</code><code class="nx">lng</code><code class="si">}</code><code class="s">z</code><code class="si">${</code><code class="nx">zoom</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This time the type of <code class="calibre18">zoom</code> is <code class="calibre18">number</code>, rather than <code class="calibre18">number|undefined</code>. The <code class="calibre18">viewportForBounds</code> function is now much easier to use. If there were any other functions that produced bounds, you would also need to introduce a canonical form and a distinction between <code class="calibre18">LngLatBounds</code> and <code class="calibre18">LngLatBoundsLike</code>.</p>

<p class="author1">Is allowing 19 possible forms of bounding box a good design? Perhaps not. But if you’re writing type declarations for a library that does this, you need to model its behavior. Just don’t have 19 return types!</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331658026584">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Input types tend to be broader than output types. Optional properties and union types are more common in parameter types than return types.</p>
</li>
<li class="calibre12">
<p class="author1">To reuse types between parameters and return types, introduce a canonical form (for return types) and a looser form (for parameters).<a data-primary="" data-startref="TDrobuts04" data-type="indexterm" id="idm45331658023176" class="calibre9"/><a data-primary="" data-startref="robust04" data-type="indexterm" id="idm45331658022200" class="calibre9"/><a data-primary="" data-startref="postel04" data-type="indexterm" id="idm45331658021256" class="calibre9"/><a data-primary="" data-startref="Frobust04" data-type="indexterm" id="idm45331658020312" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 30: Don’t Repeat Type Information in Documentation" data-type="sect1" class="praise"><div class="praise" id="jsdoc-repeat">
<h1 class="calibre16">Item 30: Don’t Repeat Type Information in Documentation</h1>

<p class="author1">What’s<a data-primary="type design" data-secondary="type information in documentation" data-type="indexterm" id="idm45331658017064" class="calibre9"/><a data-primary="documentation, type information in" data-type="indexterm" id="idm45331658016088" class="calibre9"/> wrong with this code?</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/**</code>
<code class="c"> * Returns a string with the foreground color.</code>
<code class="c"> * Takes zero or one arguments. With no arguments, returns the</code>
<code class="c"> * standard foreground color. With one argument, returns the foreground color</code>
<code class="c"> * for a particular page.</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="nx">getForegroundColor</code><code class="p">(</code><code class="nx">page?</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">page</code> <code class="o">===</code> <code class="s">'login'</code> <code class="o">?</code> <code class="p">{</code><code class="nx">r</code>: <code class="nx">127</code><code class="p">,</code> <code class="nx">g</code>: <code class="nx">127</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">127</code><code class="p">}</code> <code class="o">:</code> <code class="p">{</code><code class="nx">r</code>: <code class="nx">0</code><code class="p">,</code> <code class="nx">g</code>: <code class="nx">0</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">0</code><code class="p">};</code>
<code class="p">}</code></pre>

<p class="author1">The code and the comment disagree! Without more context it’s hard to say which is right, but something is clearly amiss. As a professor of mine used to say, “when your code and your comments disagree, they’re both wrong!”</p>

<p class="author1">Let’s assume that the code represents the desired behavior. There are a few issues with this comment:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">It says that the function returns the color as a <code class="calibre18">string</code> when it actually returns an <code class="calibre18">{r, g, b}</code> object.</p>
</li>
<li class="calibre12">
<p class="author1">It explains that the function takes zero or one arguments, which is already clear from the type signature.</p>
</li>
<li class="calibre12">
<p class="author1">It’s needlessly wordy: the comment is longer than the function declaration <em class="calibre3">and</em> implementation!</p>
</li>
</ul>

<p class="author1">TypeScript’s type annotation system is designed to be compact, descriptive, and readable. Its developers are language experts with decades of experience. It’s almost certainly a better way to express the types of your function’s inputs and outputs than your prose!</p>

<p class="author1">And because your type annotations are checked by the TypeScript compiler, they’ll never get out of sync with the implementation. Perhaps <code class="calibre18">getForegroundColor</code> used to return a string but was later changed to return an object. The person who made the change might have forgotten to update the long comment.</p>

<p class="author1">Nothing stays in sync unless it’s forced to. With type annotations, TypeScript’s type checker is that force! If you put type information in annotations and not in documentation, you greatly increase your confidence that it will remain correct as the code evolves.</p>

<p class="author1">A better comment might look like this:</p>

<pre data-code-language="ts" data-type="programlisting" id="jsdoc-repeat-concise-comment" class="calibre17"><code class="c">/** Get the foreground color for the application or a specific page. */</code>
<code class="kd">function</code> <code class="nx">getForegroundColor</code><code class="p">(</code><code class="nx">page?</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Color</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">If you want to describe a particular parameter, use an <code class="calibre18">@param</code> JSDoc annotation. See <a href="ch06.html#use-tsdoc" class="calibre9">Item 48</a> for more on this.</p>

<p class="author1">Comments about a lack of mutation are also suspect. Don’t just say that you don’t modify a parameter:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/** Does not modify nums */</code>
<code class="kd">function</code> <code class="nx">sort</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

<p class="author1">Instead, declare it <code class="calibre18">readonly</code> (<a href="ch02_split_001.html#readonly" class="calibre9">Item 17</a>) and let TypeScript enforce the contract:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">sort</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">readonly</code> <code class="kt">number</code><code class="p">[])</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

<p class="author1">What’s<a data-primary="variables" data-secondary="including units in variable names" data-type="indexterm" id="idm45331657841128" class="calibre9"/> true for comments is also true for variable names. Avoid putting types in them: rather than naming a variable <code class="calibre18">ageNum</code>, name it <code class="calibre18">age</code> and make sure it’s really a <code class="calibre18">number</code>.</p>

<p class="author1">An exception to this is for numbers with units. If it’s not clear what the units are, you may want to include them in a variable or property name. For instance, <code class="calibre18">timeMs</code> is a much clearer name than just <code class="calibre18">time</code>, and <code class="calibre18">temperatureC</code> is a much clearer name than <code class="calibre18">temperature</code>. <a href="#brands" class="calibre9">Item 37</a> describes “brands,” which provide a more type-safe approach to modeling units.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331657809608">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Avoid repeating type information in comments and variable names. In the best case it is duplicative of type declarations, and in the worst it will lead to conflicting information.</p>
</li>
<li class="calibre12">
<p class="author1">Consider including units in variable names if they aren’t clear from the type (e.g., <code class="calibre18">timeMs</code> or <code class="calibre18">temperatureC</code>).</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 31: Push Null Values to the Perimeter of Your Types" data-type="sect1" class="praise"><div class="praise" id="null-values-to-perimeter">
<h1 class="calibre16">Item 31: Push Null Values to the Perimeter of Your Types</h1>

<p class="author1">When<a data-primary="type design" data-secondary="null values" data-type="indexterm" id="TDnull04" class="calibre9"/><a data-primary="null values" data-type="indexterm" id="null04" class="calibre9"/><a data-primary="values" data-secondary="null values versus non-null values" data-type="indexterm" id="Vnull04" class="calibre9"/><a data-primary="strictNullChecks" data-type="indexterm" id="strict04" class="calibre9"/><a data-primary="non-null values" data-type="indexterm" id="nnull04" class="calibre9"/> you first turn on <code class="calibre18">strictNullChecks</code>, it may seem as though you have to add scores of if statements checking for <code class="calibre18">null</code> and <code class="calibre18">undefined</code> values throughout your code. This is often because the relationships between null and non-null values are implicit: when variable A is non-null, you know that variable B is also non-null and vice versa. These implicit relationships are confusing both for human readers of your code and for the type checker.</p>

<p class="author1">Values are easier to work with when they’re either completely null or completely non-null, rather than a mix. You can model this by pushing the null values out to the perimeter of your structures.</p>

<p class="author1">Suppose you want to calculate the min and max of a list of numbers. We’ll call this the “extent.” Here’s an attempt:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">extent</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">num</code> <code class="nx">of</code> <code class="nx">nums</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">min</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">min</code> <code class="o">=</code> <code class="nx">num</code><code class="p">;</code>
      <code class="nx">max</code> <code class="o">=</code> <code class="nx">num</code><code class="p">;</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">min</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">min</code><code class="p">(</code><code class="nx">min</code><code class="p">,</code> <code class="nx">num</code><code class="p">);</code>
      <code class="nx">max</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">max</code><code class="p">,</code> <code class="nx">num</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">];</code>
<code class="p">}</code></pre>

<p class="author1">The code type checks (without <code class="calibre18">strictNullChecks</code>) and has an inferred return type of <code class="calibre18">number[]</code>, which seems fine. But it has a bug and a design flaw:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">If the min or max is zero, it may get overridden. For example, <code class="calibre18">extent([0, 1, 2])</code> will return <code class="calibre18">[1, 2]</code> rather than <code class="calibre18">[0, 2]</code>.</p>
</li>
<li class="calibre12">
<p class="author1">If the <code class="calibre18">nums</code> array is empty, the function will return <code class="calibre18">[undefined, undefined]</code>. This sort of object with several <code class="calibre18">undefined</code>s will be difficult for clients to work with and is exactly the sort of type that this item discourages. We know from reading the source code that <code class="calibre18">min</code> and <code class="calibre18">max</code> will either both be <code class="calibre18">undefined</code> or neither, but that information isn’t represented in the type system.</p>
</li>
</ul>

<p class="author1">Turning on <code class="calibre18">strictNullChecks</code> makes both of these issues more apparent:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">extent</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">num</code> <code class="nx">of</code> <code class="nx">nums</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">min</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">min</code> <code class="o">=</code> <code class="nx">num</code><code class="p">;</code>
      <code class="nx">max</code> <code class="o">=</code> <code class="nx">num</code><code class="p">;</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">min</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">min</code><code class="p">(</code><code class="nx">min</code><code class="p">,</code> <code class="nx">num</code><code class="p">);</code>
      <code class="nx">max</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">max</code><code class="p">,</code> <code class="nx">num</code><code class="p">);</code>
                  <code class="c">// ~~~ Argument of type 'number | undefined' is not</code>
                  <code class="c">//     assignable to parameter of type 'number'</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">];</code>
<code class="p">}</code></pre>

<p class="author1">The return type of <code class="calibre18">extent</code> is now inferred as <code class="calibre18">(number | undefined)[]</code>, which makes the design flaw more apparent. This is likely to manifest as a type error wherever you call <code class="calibre18">extent</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">]</code> <code class="o">=</code> <code class="nx">extent</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]);</code>
<code class="kd">const</code> <code class="nx">span</code> <code class="o">=</code> <code class="nx">max</code> <code class="o">-</code> <code class="nx">min</code><code class="p">;</code>
          <code class="c">// ~~~   ~~~ Object is possibly 'undefined'</code></pre>

<p class="author1">The error in the implementation of <code class="calibre18">extent</code> comes about because you’ve excluded <code class="calibre18">undefined</code> as a value for <code class="calibre18">min</code> but not <code class="calibre18">max</code>. The two are initialized together, but this information isn’t present in the type system. You could make it go away by adding a check for <code class="calibre18">max</code>, too, but this would be doubling down on the bug.</p>

<p class="author1">A better solution is to put the min and max in the same object and make this object either fully <code class="calibre18">null</code> or fully non-<code class="calibre18">null</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">extent</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">result</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">|</code> <code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">num</code> <code class="nx">of</code> <code class="nx">nums</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">result</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">result</code> <code class="o">=</code> <code class="p">[</code><code class="nx">num</code><code class="p">,</code> <code class="nx">num</code><code class="p">];</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">result</code> <code class="o">=</code> <code class="p">[</code><code class="nb">Math</code><code class="p">.</code><code class="nx">min</code><code class="p">(</code><code class="nx">num</code><code class="p">,</code> <code class="nx">result</code><code class="p">[</code><code class="mi">0</code><code class="p">]),</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">num</code><code class="p">,</code> <code class="nx">result</code><code class="p">[</code><code class="mi">1</code><code class="p">])];</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The return type is now <code class="calibre18">[number, number] | null</code>, which is easier for clients to work with. The min and max can be retrieved with either a non-null assertion:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">]</code> <code class="o">=</code> <code class="nx">extent</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code><code class="o">!</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">span</code> <code class="o">=</code> <code class="nx">max</code> <code class="o">-</code> <code class="nx">min</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">or a single check:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">range</code> <code class="o">=</code> <code class="nx">extent</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]);</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">range</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">]</code> <code class="o">=</code> <code class="nx">range</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">span</code> <code class="o">=</code> <code class="nx">max</code> <code class="o">-</code> <code class="nx">min</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

<p class="author1">By using a single object to track the extent, we’ve improved our design, helped TypeScript understand the relationship between null values, and fixed the bug: the <code class="calibre18">if (!result)</code> check is now problem free.</p>

<p class="author1">A mix of null and non-null values can also lead to problems in classes. For instance, suppose you have a class that represents both a user and their posts on a forum:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">UserPosts</code> <code class="p">{</code>
  <code class="nx">user</code>: <code class="nx">UserInfo</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
  <code class="nx">posts</code>: <code class="nx">Post</code><code class="p">[]</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>

  <code class="kd">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">user</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">posts</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">async</code> <code class="nx">init</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>
      <code class="kd">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kd">this</code><code class="p">.</code><code class="nx">user</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetchUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">),</code>
      <code class="kd">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kd">this</code><code class="p">.</code><code class="nx">posts</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetchPostsForUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">)</code>
    <code class="p">]);</code>
  <code class="p">}</code>

  <code class="nx">getUserName() {</code>
    <code class="c">// ...?</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">While the two network requests are loading, the <code class="calibre18">user</code> and <code class="calibre18">posts</code> properties will be <code class="calibre18">null</code>. At any time, they might both be <code class="calibre18">null</code>, one might be <code class="calibre18">null</code>, or they might both be non-<code class="calibre18">null</code>. There are four possibilities. This complexity will seep into every method on the class. This design is almost certain to lead to confusion, a proliferation of <code class="calibre18">null</code> checks, and bugs.</p>

<p class="author1">A better design would wait until all the data used by the class is available:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">UserPosts</code> <code class="p">{</code>
  <code class="nx">user</code>: <code class="nx">UserInfo</code><code class="p">;</code>
  <code class="nx">posts</code>: <code class="nx">Post</code><code class="p">[];</code>

  <code class="kd">constructor</code><code class="p">(</code><code class="nx">user</code>: <code class="nx">UserInfo</code><code class="p">,</code> <code class="nx">posts</code>: <code class="nx">Post</code><code class="p">[])</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">user</code> <code class="o">=</code> <code class="nx">user</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">posts</code> <code class="o">=</code> <code class="nx">posts</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">static</code> <code class="kd">async</code> <code class="nx">init</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">UserPosts</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">[</code><code class="nx">user</code><code class="p">,</code> <code class="nx">posts</code><code class="p">]</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>
      <code class="nx">fetchUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">),</code>
      <code class="nx">fetchPostsForUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">)</code>
    <code class="p">]);</code>
    <code class="kd">return</code> <code class="kd">new</code> <code class="nx">UserPosts</code><code class="p">(</code><code class="nx">user</code><code class="p">,</code> <code class="nx">posts</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="nx">getUserName() {</code>
    <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">Now the <code class="calibre18">UserPosts</code> class is fully non-<code class="calibre18">null</code>, and it’s easy to write correct methods on it. Of course, if you need to perform operations while data is partially loaded, then you’ll need to deal with the multiplicity of <code class="calibre18">null</code> and non-<code class="calibre18">null</code> states.</p>

<p class="author1">(Don’t be tempted to replace nullable properties<a data-primary="Promises" data-type="indexterm" id="idm45331657055160" class="calibre9"/> with Promises. This tends to lead to even more confusing code and forces all your methods to be async. Promises clarify the code that loads data but tend to have the opposite effect on the class that uses that data.)</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331657054072">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Avoid designs in which one value being <code class="calibre18">null</code> or not <code class="calibre18">null</code> is implicitly related to another value being <code class="calibre18">null</code> or not <code class="calibre18">null</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Push <code class="calibre18">null</code> values to the perimeter of your API by making larger objects either <code class="calibre18">null</code> or fully non-<code class="calibre18">null</code>. This will make code clearer both for human readers and for the type checker.</p>
</li>
<li class="calibre12">
<p class="author1">Consider creating a fully non-<code class="calibre18">null</code> class and constructing it when all values are available.</p>
</li>
<li class="calibre12">
<p class="author1">While <code class="calibre18">strictNullChecks</code> may flag many issues in your code, it’s indispensable for surfacing the behavior of functions with respect to null values.<a data-primary="" data-startref="nnull04" data-type="indexterm" id="idm45331657044936" class="calibre9"/><a data-primary="" data-startref="strict04" data-type="indexterm" id="idm45331657043960" class="calibre9"/><a data-primary="" data-startref="Vnull04" data-type="indexterm" id="idm45331657043016" class="calibre9"/><a data-primary="" data-startref="null04" data-type="indexterm" id="idm45331657042072" class="calibre9"/><a data-primary="" data-startref="TDnull04" data-type="indexterm" id="idm45331657041128" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 32: Prefer Unions of Interfaces to Interfaces of Unions" data-type="sect1" class="praise"><div class="praise" id="union-of-interfaces">
<h1 class="calibre16">Item 32: Prefer Unions of Interfaces to Interfaces of Unions</h1>

<p class="author1">If<a data-primary="type design" data-secondary="unions of interfaces versus interfaces of unions" data-type="indexterm" id="TDunion04" class="calibre9"/><a data-primary="tagged unions" data-secondary="unions of interfaces versus interfaces of unions" data-type="indexterm" id="tunion04" class="calibre9"/><a data-primary="interface construct" data-secondary="unions of interfaces versus interfaces of unions" data-type="indexterm" id="inter04" class="calibre9"/><a data-primary="union types" data-secondary="unions of interfaces versus interfaces of unions" data-type="indexterm" id="union04" class="calibre9"/> you create an interface whose properties are union types, you should ask whether the type would make more sense as a union of more precise interfaces.</p>

<p class="author1">Suppose you’re building a vector drawing program and want to define an interface for layers with specific geometry types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Layer</code> <code class="p">{</code>
  <code class="nx">layout</code>: <code class="nx">FillLayout</code> <code class="o">|</code> <code class="nx">LineLayout</code> <code class="o">|</code> <code class="nx">PointLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">FillPaint</code> <code class="o">|</code> <code class="nx">LinePaint</code> <code class="o">|</code> <code class="nx">PointPaint</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">layout</code> field controls how and where the shapes are drawn (rounded corners? straight?), while the <code class="calibre18">paint</code> field controls styles (is the line blue? thick? thin? dashed?).</p>

<p class="author1">Would it make sense to have a layer whose <code class="calibre18">layout</code> is <code class="calibre18">LineLayout</code> but whose <code class="calibre18">paint</code> property is <code class="calibre18">FillPaint</code>? Probably not. Allowing this possibility makes using the library more error-prone and makes this interface difficult to work with.</p>

<p class="author1">A better way to model this is with separate interfaces for each type of layer:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">FillLayer</code> <code class="p">{</code>
  <code class="nx">layout</code>: <code class="nx">FillLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">FillPaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">LineLayer</code> <code class="p">{</code>
  <code class="nx">layout</code>: <code class="nx">LineLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">LinePaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">PointLayer</code> <code class="p">{</code>
  <code class="nx">layout</code>: <code class="nx">PointLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">PointPaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Layer</code> <code class="o">=</code> <code class="nx">FillLayer</code> <code class="o">|</code> <code class="nx">LineLayer</code> <code class="o">|</code> <code class="nx">PointLayer</code><code class="p">;</code></pre>

<p class="author1">By defining <code class="calibre18">Layer</code> in this way, you’ve excluded the possibility of mixed <code class="calibre18">layout</code> and <code class="calibre18">paint</code> properties. This is an example of following <a href="#valid-states" class="calibre9">Item 28</a>’s advice to prefer types that only represent valid states.</p>

<p class="author1">The most common example of this pattern is the “tagged union” (or “discriminated union”). In this case one of the properties is a union of string literal types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Layer</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'fill'</code> <code class="o">|</code> <code class="s">'line'</code> <code class="o">|</code> <code class="s">'point'</code><code class="p">;</code>
  <code class="nx">layout</code>: <code class="nx">FillLayout</code> <code class="o">|</code> <code class="nx">LineLayout</code> <code class="o">|</code> <code class="nx">PointLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">FillPaint</code> <code class="o">|</code> <code class="nx">LinePaint</code> <code class="o">|</code> <code class="nx">PointPaint</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">As before, would it make sense to have <code class="calibre18">type: 'fill'</code> but then a <code class="calibre18">LineLayout</code> and <code class="calibre18">PointPaint</code>? Certainly not. Convert <code class="calibre18">Layer</code> to a union of interfaces to exclude this possibility:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">FillLayer</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'fill'</code><code class="p">;</code>
  <code class="nx">layout</code>: <code class="nx">FillLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">FillPaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">LineLayer</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'line'</code><code class="p">;</code>
  <code class="nx">layout</code>: <code class="nx">LineLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">LinePaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">PointLayer</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'paint'</code><code class="p">;</code>
  <code class="nx">layout</code>: <code class="nx">PointLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">PointPaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Layer</code> <code class="o">=</code> <code class="nx">FillLayer</code> <code class="o">|</code> <code class="nx">LineLayer</code> <code class="o">|</code> <code class="nx">PointLayer</code><code class="p">;</code></pre>

<p class="author1">The <code class="calibre18">type</code> property is the “tag” and can be used to determine which type of <code class="calibre18">Layer</code> you’re working with at runtime. TypeScript is also able to narrow the type of <code class="calibre18">Layer</code> based on the tag:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">drawLayer</code><code class="p">(</code><code class="nx">layer</code>: <code class="nx">Layer</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">layer</code><code class="p">.</code><code class="nx">type</code> <code class="o">===</code> <code class="s">'fill'</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">paint</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is FillPaint</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">layout</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is FillLayout</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">layer</code><code class="p">.</code><code class="nx">type</code> <code class="o">===</code> <code class="s">'line'</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">paint</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is LinePaint</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">layout</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is LineLayout</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">paint</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is PointPaint</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">layout</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is PointLayout</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">By correctly modeling the relationship between the properties in this type, you help TypeScript check your code’s correctness. The same code involving the initial <code class="calibre18">Layer</code> definition would have been cluttered with type assertions.</p>

<p class="author1">Because they work so well with TypeScript’s type checker, tagged unions are ubiquitous in TypeScript code. Recognize this pattern and apply it when you can. If you can represent a data type in TypeScript with a tagged union, it’s usually a good idea to do so. If you think of optional fields as a union of their type and <code class="calibre18">undefined</code>, then they fit this pattern as well. Consider this type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="c">// These will either both be present or not be present</code>
  <code class="nx">placeOfBirth?</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">dateOfBirth?</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The comment with type information is a strong sign that there might be a problem (<a href="#jsdoc-repeat" class="calibre9">Item 30</a>). There is a relationship between the <code class="calibre18">placeOfBirth</code> and <code class="calibre18">dateOfBirth</code> fields that you haven’t told TypeScript about.</p>

<p class="author1">A better way to model this is to move both of these properties into a single object. This is akin to moving <code class="calibre18">null</code> values to the perimeter (<a href="#null-values-to-perimeter" class="calibre9">Item 31</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">birth</code><code class="o">?:</code> <code class="p">{</code>
    <code class="nx">place</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">date</code>: <code class="nx">Date</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">Now<a data-primary="Turing, Alan" data-type="indexterm" id="idm45331656607208" class="calibre9"/> TypeScript complains about values with a place but no date of birth:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">alanT</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Alan Turing'</code><code class="p">,</code>
  <code class="nx">birth</code><code class="o">:</code> <code class="p">{</code>
<code class="c">// ~~~~ Property 'date' is missing in type</code>
<code class="c">//      '{ place: string; }' but required in type</code>
<code class="c">//      '{ place: string; date: Date; }'</code>
    <code class="nx">place</code><code class="o">:</code> <code class="s">'London'</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">Additionally, a function that takes a <code class="calibre18">Person</code> object only needs to do a single check:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">eulogize</code><code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">birth</code><code class="p">}</code> <code class="o">=</code> <code class="nx">p</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">birth</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">`was born on </code><code class="si">${</code><code class="nx">birth</code><code class="p">.</code><code class="nx">date</code><code class="si">}</code><code class="s"> in </code><code class="si">${</code><code class="nx">birth</code><code class="p">.</code><code class="nx">place</code><code class="si">}</code><code class="s">.`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">If the structure of the type is outside your control (e.g., it’s coming from an API), then you can still model the relationship between these fields using a now-familiar union of interfaces:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Name</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">PersonWithBirth</code> <code class="kd">extends</code> <code class="nx">Name</code> <code class="p">{</code>
  <code class="nx">placeOfBirth</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">dateOfBirth</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="nx">Name</code> <code class="o">|</code> <code class="nx">PersonWithBirth</code><code class="p">;</code></pre>

<p class="author1">Now you get some of the same benefits as with the nested object:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">eulogize</code><code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="s">'placeOfBirth'</code> <code class="kd">in</code> <code class="nx">p</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">p</code> <code class="c">// Type is PersonWithBirth</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">dateOfBirth</code><code class="p">}</code> <code class="o">=</code> <code class="nx">p</code>  <code class="c">// OK, type is Date</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">In both cases, the type definition makes the relationship between the properties more clear.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331656339224">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Interfaces with multiple properties that are union types are often a mistake because they obscure the relationships between these properties.</p>
</li>
<li class="calibre12">
<p class="author1">Unions of interfaces are more precise and can be understood by TypeScript.</p>
</li>
<li class="calibre12">
<p class="author1">Consider adding a “tag” to your structure to facilitate TypeScript’s control flow analysis. Because they are so well supported, tagged unions are ubiquitous in TypeScript code.<a data-primary="" data-startref="union04" data-type="indexterm" id="idm45331656300712" class="calibre9"/><a data-primary="" data-startref="inter04" data-type="indexterm" id="idm45331656299736" class="calibre9"/><a data-primary="" data-startref="tunion04" data-type="indexterm" id="idm45331656298792" class="calibre9"/><a data-primary="" data-startref="TDunion04" data-type="indexterm" id="idm45331656297848" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 33: Prefer More Precise Alternatives to String Types" data-type="sect1" class="praise"><div class="praise" id="avoid-strings">
<h1 class="calibre16">Item 33: Prefer More Precise Alternatives to String Types</h1>

<p class="author1">The<a data-primary="type design" data-secondary="alternatives to string types" data-type="indexterm" id="TDalt04" class="calibre9"/><a data-primary="string types, alternatives to" data-type="indexterm" id="STalt04" class="calibre9"/> domain of the <code class="calibre18">string</code> type is big: <code class="calibre18">"x"</code> and <code class="calibre18">"y"</code> are in it, but so is the complete text of <em class="calibre3">Moby Dick</em> (it starts <code class="calibre18">"Call me Ishmael…"</code> and is about 1.2 million characters long). When you declare a variable of type <code class="calibre18">string</code>, you should ask whether a narrower type would be more appropriate.</p>

<p class="author1">Suppose you’re building a music collection and want to define a type for an album. Here’s an attempt:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Album</code> <code class="p">{</code>
  <code class="nx">artist</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">title</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">releaseDate</code>: <code class="kd">string</code><code class="p">;</code>  <code class="c">// YYYY-MM-DD</code>
  <code class="nx">recordingType</code>: <code class="kd">string</code><code class="p">;</code>  <code class="c">// E.g., "live" or "studio"</code>
<code class="p">}</code></pre>

<p class="author1">The prevalence of <code class="calibre18">string</code> types and the type information in comments (see <a href="#jsdoc-repeat" class="calibre9">Item 30</a>) are strong indications that this <code class="calibre18">interface</code> isn’t quite right. Here’s<a data-primary="Davis, Miles" data-type="indexterm" id="idm45331656238568" class="calibre9"/> what can go wrong:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">kindOfBlue</code>: <code class="nx">Album</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">artist</code><code class="o">:</code> <code class="s">'Miles Davis'</code><code class="p">,</code>
  <code class="nx">title</code><code class="o">:</code> <code class="s">'Kind of Blue'</code><code class="p">,</code>
  <code class="nx">releaseDate</code><code class="o">:</code> <code class="s">'August 17th, 1959'</code><code class="p">,</code>  <code class="c">// Oops!</code>
  <code class="nx">recordingType</code><code class="o">:</code> <code class="s">'Studio'</code><code class="p">,</code>  <code class="c">// Oops!</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">The <code class="calibre18">releaseDate</code> field is incorrectly formatted (according to the comment) and <code class="calibre18">"Studio"</code> is capitalized where it should be lowercase. But these values <em class="calibre3">are</em> both strings, so this object is assignable to <code class="calibre18">Album</code> and the type checker doesn’t complain.</p>

<p class="author1">These broad <code class="calibre18">string</code> types can mask errors for valid <code class="calibre18">Album</code> objects, too. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">recordRelease</code><code class="p">(</code><code class="nx">title</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">date</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="nx">recordRelease</code><code class="p">(</code><code class="nx">kindOfBlue</code><code class="p">.</code><code class="nx">releaseDate</code><code class="p">,</code> <code class="nx">kindOfBlue</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>  <code class="c">// OK, should be error</code></pre>

<p class="author1">The parameters are reversed in the call to <code class="calibre18">recordRelease</code> but both are strings, so the type checker doesn’t complain. Because of the prevalence of <code class="calibre18">string</code> types, code like this is sometimes called “stringly typed.”</p>

<p class="author1">Can you make the types narrower to prevent these sorts of issues? While the complete text of <em class="calibre3">Moby Dick</em> would be a ponderous artist name or album title, it’s at least plausible. So <code class="calibre18">string</code> is appropriate for these fields. For the <code class="calibre18">releaseDate</code> field it’s better to just use a <code class="calibre18">Date</code> object and avoid issues around formatting. Finally, for the <code class="calibre18">recordingType</code> field, you can define a union type with just two values (you could also use an <code class="calibre18">enum</code>, but I generally recommend avoiding these; see <a href="ch07.html#avoid-non-ecma" class="calibre9">Item 53</a>):</p>

<pre data-code-language="ts" data-type="programlisting" id="album-definition" class="calibre17"><code class="kd">type</code> <code class="nx">RecordingType</code> <code class="o">=</code> <code class="s">'studio'</code> <code class="o">|</code> <code class="s">'live'</code><code class="p">;</code>

<code class="kd">interface</code> <code class="nx">Album</code> <code class="p">{</code>
  <code class="nx">artist</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">title</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">releaseDate</code>: <code class="nx">Date</code><code class="p">;</code>
  <code class="nx">recordingType</code>: <code class="nx">RecordingType</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">With these changes TypeScript is able to do a more thorough check for errors:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">kindOfBlue</code>: <code class="nx">Album</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">artist</code><code class="o">:</code> <code class="s">'Miles Davis'</code><code class="p">,</code>
  <code class="nx">title</code><code class="o">:</code> <code class="s">'Kind of Blue'</code><code class="p">,</code>
  <code class="nx">releaseDate</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s">'1959-08-17'</code><code class="p">),</code>
  <code class="nx">recordingType</code><code class="o">:</code> <code class="s">'Studio'</code>
<code class="c">// ~~~~~~~~~~~~ Type '"Studio"' is not assignable to type 'RecordingType'</code>
<code class="p">};</code></pre>

<p class="author1">There are advantages to this approach beyond stricter checking. First, explicitly defining the type ensures that its meaning won’t get lost as it’s passed around. If you wanted to find albums of just a certain recording type, for instance, you might define a function like this:</p>

<pre data-code-language="ts" data-type="programlisting" id="get-albums-of-type" class="calibre17"><code class="kd">function</code> <code class="nx">getAlbumsOfType</code><code class="p">(</code><code class="nx">recordingType</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Album</code><code class="p">[]</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">How does the caller of this function know what <code class="calibre18">recordingType</code> is expected to be? It’s just a <code class="calibre18">string</code>. The comment explaining that it’s <code class="calibre18">"studio"</code> or <code class="calibre18">"live"</code> is hidden in the definition of <code class="calibre18">Album</code>, where the user might not think to look.</p>

<p class="author1">Second, explicitly defining a type allows you attach documentation to it (see <a href="ch06.html#use-tsdoc" class="calibre9">Item 48</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/** What type of environment was this recording made in?  */</code>
<code class="kd">type</code> <code class="nx">RecordingType</code> <code class="o">=</code> <code class="s">'live'</code> <code class="o">|</code> <code class="s">'studio'</code><code class="p">;</code></pre>

<p class="author1">When you change <code class="calibre18">getAlbumsOfType</code> to take a <code class="calibre18">RecordingType</code>, the caller is able to click through and see the documentation (see <a data-type="xref" href="#efts-04in01" class="calibre9">Figure 4-1</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-04in01">
<img alt="efts 04in01" src="assets/efts_04in01.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 4-1. </span>Using a named type instead of string makes it possible to attach documentation to the type that is surfaced in your editor.</h6>
</div></figure>

<p class="author1">Another<a data-primary="named types" data-type="indexterm" id="idm45331655972136" class="calibre9"/> common misuse of <code class="calibre18">string</code> is in function parameters. Say you want to write a function that pulls out all the values for a single field in an array. The<a data-primary="Underscore library" data-type="indexterm" id="idm45331655970712" class="calibre9"/> Underscore library calls this “pluck”:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="p">(</code><code class="nx">records</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">record</code> <code class="o">=&gt;</code> <code class="nx">record</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
<code class="p">}</code></pre>

<p class="author1">How would you type this? Here’s an initial attempt:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">any</code><code class="p">[],</code> <code class="nx">key</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">any</code><code class="p">[]</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
<code class="p">}</code></pre>

<p class="author1">This<a data-primary="any types" data-secondary="versus inaccurate models" data-secondary-sortas="inaccurae models" data-type="indexterm" id="idm45331655891016" class="calibre9"/> type checks but isn’t great. The <code class="calibre18">any</code> types are problematic, particularly on the return value (see <a href="ch05.html#narrowest-any" class="calibre9">Item 38</a>). The first step to improving the type signature is introducing a generic type parameter:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">any</code><code class="p">[]</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
                      <code class="c">// ~~~~~~ Element implicitly has an 'any' type</code>
                      <code class="c">//        because type '{}' has no index signature</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript<a data-primary="keyof T" data-type="indexterm" id="idm45331655758632" class="calibre9"/> is now complaining that the <code class="calibre18">string</code> type for <code class="calibre18">key</code> is too broad. And it’s right to do so: if you pass in an array of <code class="calibre18">Album</code>s then there are only four valid values for <code class="calibre18">key</code> (“artist,” “title,” “releaseDate,” and “recordingType”), as opposed to the vast set of strings. This is precisely what the <code class="calibre18">keyof Album</code> type is:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">K</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="nx">Album</code><code class="p">;</code>
<code class="c">// Type is "artist" | "title" | "releaseDate" | "recordingType"</code></pre>

<p class="author1">So the fix is to replace <code class="calibre18">string</code> with <code class="calibre18">keyof T</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="nx">keyof</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
<code class="p">}</code></pre>

<p class="author1">This passes the type checker. We’ve also let TypeScript infer the return type. How does it do? If you mouse over <code class="calibre18">pluck</code> in your editor, the inferred type is:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="nx">keyof</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">keyof</code> <code class="nx">T</code><code class="p">][]</code></pre>

<p class="author1"><code class="calibre18">T[keyof T]</code> is the type of any possible value in <code class="calibre18">T</code>. If you’re passing in a single string as the <code class="calibre18">key</code>, this is too broad. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">releaseDates</code> <code class="o">=</code> <code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'releaseDate'</code><code class="p">);</code> <code class="c">// Type is (string | Date)[]</code></pre>

<p class="author1">The type should be <code class="calibre18">Date[]</code>, not <code class="calibre18">(string | Date)[]</code>. While <code class="calibre18">keyof T</code> is much narrower than <code class="calibre18">string</code>, it’s <em class="calibre3">still</em> too broad. To narrow it further, we need to introduce a second generic parameter that is a subset of <code class="calibre18">keyof T</code> (probably a single value):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kd">extends</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="nx">K</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">][]</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
<code class="p">}</code></pre>

<p class="author1">(For more on <code class="calibre18">extends</code> in this context, see <a href="ch02_split_001.html#map-between-types" class="calibre9">Item 14</a>.)</p>

<p class="author1">The type signature is now completely correct. We can check this by calling <code class="calibre18">pluck</code> in a few different ways:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'releaseDate'</code><code class="p">);</code> <code class="c">// Type is Date[]</code>
<code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'artist'</code><code class="p">);</code>  <code class="c">// Type is string[]</code>
<code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'recordingType'</code><code class="p">);</code>  <code class="c">// Type is RecordingType[]</code>
<code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'recordingDate'</code><code class="p">);</code>
           <code class="c">// ~~~~~~~~~~~~~~~ Argument of type '"recordingDate"' is not</code>
           <code class="c">//                 assignable to parameter of type ...</code></pre>

<p class="author1">The language service is even able to offer autocomplete on the keys of <code class="calibre18">Album</code> (as shown in <a data-type="xref" href="#efts-04in02" class="calibre9">Figure 4-2</a>).</p>

<figure class="width"><div class="figure" id="efts-04in02">
<img alt="efts 04in02" src="assets/efts_04in02.png" class="calibre49"/>
<h6 class="calibre29"><span class="calibre">Figure 4-2. </span>Using a parameter type of keyof Album instead of string results in better autocomplete in your editor.</h6>
</div></figure>

<p class="author1"><code class="calibre18">string</code> has some of the same problems as <code class="calibre18">any</code>: when used inappropriately, it permits invalid values and hides relationships between types. This thwarts the type checker and can hide real bugs. TypeScript’s ability<a data-primary="type safety" data-secondary="subsets of string and" data-type="indexterm" id="idm45331655501208" class="calibre9"/> to define subsets of <code class="calibre18">string</code> is a powerful way to bring type safety to JavaScript code. Using more precise types will both catch errors and improve the readability of your code.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331655499400">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Avoid “stringly typed” code. Prefer more appropriate types where not every <code class="calibre18">string</code> is a possibility.</p>
</li>
<li class="calibre12">
<p class="author1">Prefer a union of string literal types to <code class="calibre18">string</code> if that more accurately describes the domain of a variable. You’ll get stricter type checking and improve the development experience.</p>
</li>
<li class="calibre12">
<p class="author1">Prefer <code class="calibre18">keyof T</code> to <code class="calibre18">string</code> for function parameters that are expected to be properties of an object.<a data-primary="" data-startref="TDalt04" data-type="indexterm" id="idm45331655493352" class="calibre9"/><a data-primary="" data-startref="STalt04" data-type="indexterm" id="idm45331655492376" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 34: Prefer Incomplete Types to Inaccurate Types" data-type="sect1" class="praise"><div class="praise" id="incomplete-over-innacurate">
<h1 class="calibre16">Item 34: Prefer Incomplete Types to Inaccurate Types</h1>

<p class="author1">In<a data-primary="type design" data-secondary="incomplete versus inaccurate types" data-type="indexterm" id="TDincomplete04" class="calibre9"/> writing type declarations you’ll inevitably find situations where you can model behavior in a more precise or less precise way. Precision in types is generally a good thing because it will help your users catch bugs and take advantage of the tooling that TypeScript provides. But take care as you increase the precision of your type declarations: it’s easy to make mistakes, and incorrect types can be worse than no types at all.</p>

<p class="author1">Suppose<a data-primary="GeoJSON" data-type="indexterm" id="geojsona04" class="calibre9"/> you are writing type declarations for GeoJSON, a format we’ve seen before in <a href="#null-values-to-perimeter" class="calibre9">Item 31</a>. A<a data-primary="Geometry" data-type="indexterm" id="idm45331655485864" class="calibre9"/> GeoJSON Geometry can be one of a few types, each of which have differently shaped coordinate arrays:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Point</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'Point'</code><code class="p">;</code>
  <code class="nx">coordinates</code>: <code class="nx">number</code><code class="p">[];</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">LineString</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'LineString'</code><code class="p">;</code>
  <code class="nx">coordinates</code>: <code class="nx">number</code><code class="p">[][];</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Polygon</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'Polygon'</code><code class="p">;</code>
  <code class="nx">coordinates</code>: <code class="nx">number</code><code class="p">[][][];</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Geometry</code> <code class="o">=</code> <code class="nx">Point</code> <code class="o">|</code> <code class="nx">LineString</code> <code class="o">|</code> <code class="nx">Polygon</code><code class="p">;</code>  <code class="c">// Also several others</code></pre>

<p class="author1">This is fine, but <code class="calibre18">number[]</code> for a coordinate is a bit imprecise. Really these are latitudes and longitudes, so perhaps a tuple type would be better:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">GeoPosition</code> <code class="o">=</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
<code class="kd">interface</code> <code class="nx">Point</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'Point'</code><code class="p">;</code>
  <code class="nx">coordinates</code>: <code class="nx">GeoPosition</code><code class="p">;</code>
<code class="p">}</code>
<code class="c">// Etc.</code></pre>

<p class="author1">You publish your more precise types to the world and wait for the adulation to roll in. Unfortunately, a user complains that your new types have broken everything. Even though you’ve only ever used latitude and longitude, a position in GeoJSON is allowed to have a third element, an elevation, and potentially more. In an attempt to make the type declarations more precise, you’ve gone too far and made the types inaccurate! To continue using your type declarations, your user will have to introduce type assertions or silence the type checker entirely with <code class="calibre18">as any</code>.<a data-primary="" data-startref="geojsona04" data-type="indexterm" id="idm45331655344344" class="calibre9"/></p>

<p class="author1">As another example, consider trying to write type declarations for a Lisp-like language defined in<a data-primary="JSON" data-type="indexterm" id="idm45331655343080" class="calibre9"/> JSON:</p>

<pre data-type="programlisting" class="calibre17">12
"red"
["+", 1, 2]  // 3
["/", 20, 2]  // 10
["case", ["&gt;", 20, 10], "red", "blue"]  // "red"
["rgb", 255, 0, 127]  // "#FF007F"</pre>

<p class="author1">The<a data-primary="Mapbox library" data-type="indexterm" id="idm45331655341000" class="calibre9"/> Mapbox library uses a system like this to determine the appearance of map features across many devices. There’s a whole spectrum of precision with which you could try to type this:</p>
<ol class="calibre50">
<li class="calibre51">
<p class="author1">Allow anything.</p>
</li>
<li class="calibre51">
<p class="author1">Allow strings, numbers, and arrays.</p>
</li>
<li class="calibre51">
<p class="author1">Allow strings, numbers, and arrays starting with known function names.</p>
</li>
<li class="calibre51">
<p class="author1">Make sure each function gets the correct number of arguments.</p>
</li>
<li class="calibre51">
<p class="author1">Make sure each function gets the correct type of arguments.</p>
</li>

</ol>

<p class="author1">The first two options are straightforward:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Expression1</code> <code class="o">=</code> <code class="nx">any</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">Expression2</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">any</code><code class="p">[];</code></pre>

<p class="author1">Beyond this, you should introduce a test set of expressions that are valid and expressions that are not. As you make your types more precise, this will help prevent regressions (see <a href="ch06.html#test-your-types" class="calibre9">Item 52</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">tests</code>: <code class="nx">Expression2</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="mi">10</code><code class="p">,</code>
  <code class="s">"red"</code><code class="p">,</code>
  <code class="kd">true</code><code class="p">,</code>
<code class="c">// ~~~ Type 'true' is not assignable to type 'Expression2'</code>
  <code class="p">[</code><code class="s">"+"</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"case"</code><code class="p">,</code> <code class="p">[</code><code class="s">"&gt;"</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">10</code><code class="p">],</code> <code class="s">"red"</code><code class="p">,</code> <code class="s">"blue"</code><code class="p">,</code> <code class="s">"green"</code><code class="p">],</code>  <code class="c">// Too many values</code>
  <code class="p">[</code><code class="s">"**"</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">31</code><code class="p">],</code>  <code class="c">// Should be an error: no "**" function</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">128</code><code class="p">,</code> <code class="mi">64</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">127</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code>  <code class="c">// Too many values</code>
<code class="p">];</code></pre>

<p class="author1">To go to the next level of precision you can use a union of string literal types as the first element of a tuple:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">FnName</code> <code class="o">=</code> <code class="s">'+'</code> <code class="o">|</code> <code class="s">'-'</code> <code class="o">|</code> <code class="s">'*'</code> <code class="o">|</code> <code class="s">'/'</code> <code class="o">|</code> <code class="s">'&gt;'</code> <code class="o">|</code> <code class="s">'&lt;'</code> <code class="o">|</code> <code class="s">'case'</code> <code class="o">|</code> <code class="s">'rgb'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">CallExpression</code> <code class="o">=</code> <code class="p">[</code><code class="nx">FnName</code><code class="p">,</code> <code class="p">...</code><code class="nx">any</code><code class="p">[]];</code>
<code class="kd">type</code> <code class="nx">Expression3</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">CallExpression</code><code class="p">;</code>

<code class="kd">const</code> <code class="nx">tests</code>: <code class="nx">Expression3</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="mi">10</code><code class="p">,</code>
  <code class="s">"red"</code><code class="p">,</code>
  <code class="kd">true</code><code class="p">,</code>
<code class="c">// ~~~ Type 'true' is not assignable to type 'Expression3'</code>
  <code class="p">[</code><code class="s">"+"</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"case"</code><code class="p">,</code> <code class="p">[</code><code class="s">"&gt;"</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">10</code><code class="p">],</code> <code class="s">"red"</code><code class="p">,</code> <code class="s">"blue"</code><code class="p">,</code> <code class="s">"green"</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"**"</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">31</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~ Type '"**"' is not assignable to type 'FnName'</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">128</code><code class="p">,</code> <code class="mi">64</code><code class="p">]</code>
<code class="p">];</code></pre>

<p class="author1">There’s one new caught error and no regressions. Pretty good!</p>

<p class="author1">What<a data-primary="recursive types" data-type="indexterm" id="idm45331655214504" class="calibre9"/> if you want to make sure that each function gets the correct number of arguments? This gets trickier since the type now needs to be recursive to reach down into all the function calls. As of TypeScript 3.6, to make this work you needed to introduce at least one <code class="calibre18">interface</code>. Since <code class="calibre18">interface</code>s can’t be unions, you’ll have to write the call expressions using <code class="calibre18">interface</code> instead. This is a bit awkward since fixed-length arrays are most easily expressed as tuple types. But you <em class="calibre3">can</em> do it:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Expression4</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">CallExpression</code><code class="p">;</code>

<code class="kd">type</code> <code class="nx">CallExpression</code> <code class="o">=</code> <code class="nx">MathCall</code> <code class="o">|</code> <code class="nx">CaseCall</code> <code class="o">|</code> <code class="nx">RGBCall</code><code class="p">;</code>

<code class="kd">interface</code> <code class="nx">MathCall</code> <code class="p">{</code>
  <code class="mi">0</code><code class="o">:</code> <code class="s">'+'</code> <code class="o">|</code> <code class="s">'-'</code> <code class="o">|</code> <code class="s">'/'</code> <code class="o">|</code> <code class="s">'*'</code> <code class="o">|</code> <code class="s">'&gt;'</code> <code class="o">|</code> <code class="s">'&lt;'</code><code class="p">;</code>
  <code class="nx">1</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">2</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">length</code>: <code class="nx">3</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">CaseCall</code> <code class="p">{</code>
  <code class="mi">0</code><code class="o">:</code> <code class="s">'case'</code><code class="p">;</code>
  <code class="nx">1</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">2</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">3</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">length</code>: <code class="nx">4</code> <code class="o">|</code> <code class="mi">6</code> <code class="o">|</code> <code class="mi">8</code> <code class="o">|</code> <code class="mi">10</code> <code class="o">|</code> <code class="mi">12</code> <code class="o">|</code> <code class="mi">14</code> <code class="o">|</code> <code class="mi">16</code> <code class="c">// etc.</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">RGBCall</code> <code class="p">{</code>
  <code class="mi">0</code><code class="o">:</code> <code class="s">'rgb'</code><code class="p">;</code>
  <code class="nx">1</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">2</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">3</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">length</code>: <code class="nx">4</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">tests</code>: <code class="nx">Expression4</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="mi">10</code><code class="p">,</code>
  <code class="s">"red"</code><code class="p">,</code>
  <code class="kd">true</code><code class="p">,</code>
<code class="c">// ~~~ Type 'true' is not assignable to type 'Expression4'</code>
  <code class="p">[</code><code class="s">"+"</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"case"</code><code class="p">,</code> <code class="p">[</code><code class="s">"&gt;"</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">10</code><code class="p">],</code> <code class="s">"red"</code><code class="p">,</code> <code class="s">"blue"</code><code class="p">,</code> <code class="s">"green"</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code>
<code class="c">//  Type '["case", ["&gt;", ...], ...]' is not assignable to type 'string'</code>
  <code class="p">[</code><code class="s">"**"</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">31</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~~ Type '["**", number, number]' is not assignable to type 'string</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">128</code><code class="p">,</code> <code class="mi">64</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">128</code><code class="p">,</code> <code class="mi">64</code><code class="p">,</code> <code class="mi">73</code><code class="p">]</code>
<code class="c">// ~~~~~~~~~~~~~~~~~~~~~~~~ Type '["rgb", number, number, number, number]'</code>
<code class="c">//                          is not assignable to type 'string'</code>
<code class="p">];</code></pre>

<p class="author1">Now all the invalid expressions produce errors. And it’s interesting that you can express something like “an array of even length” using a TypeScript <code class="calibre18">interface</code>. But these error messages aren’t very good, and the error about <code class="calibre18">**</code> has gotten quite a bit worse since the previous typings.</p>

<p class="author1">Is this an improvement over the previous, less precise types? The fact that you get errors for some incorrect usages is a win, but the errors will make this type more difficult to work with. Language services are as much a part of the TypeScript experience as type checking (see <a href="ch02_split_000.html#editor" class="calibre9">Item 6</a>), so it’s a good idea to look at the error messages resulting from your type declarations and try  autocomplete in situations where it should work. If your new type declarations are more precise but break autocomplete, then they’ll make for a less enjoyable TypeScript development experience.</p>

<p class="author1">The complexity of this type declaration has also increased the odds that a bug will creep in. For example, <code class="calibre18">Expression4</code> requires that all math operators take two parameters, but the<a data-primary="Mapbox library" data-type="indexterm" id="idm45331654860232" class="calibre9"/> Mapbox expression spec says that <code class="calibre18">+</code> and <code class="calibre18">*</code> can take more. Also, <code class="calibre18">-</code> can take a single parameter, in which case it negates its input. <code class="calibre18">Expression4</code> incorrectly flags errors in all of these:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"> <code class="kd">const</code> <code class="nx">okExpressions</code>: <code class="nx">Expression4</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
   <code class="p">[</code><code class="s">'-'</code><code class="p">,</code> <code class="mi">12</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~ Type '["-", number]' is not assignable to type 'string'</code>
   <code class="p">[</code><code class="s">'+'</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~~~~ Type '["+", number, ...]' is not assignable to type 'string'</code>
   <code class="p">[</code><code class="s">'*'</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~~~~ Type '["*", number, ...]' is not assignable to type 'string'</code>
 <code class="p">];</code></pre>

<p class="author1">Once again, in trying to be more precise we’ve overshot and become inaccurate. These inaccuracies can be corrected, but you’ll want to expand your test set to convince yourself that you haven’t missed anything else. Complex code generally requires more tests, and the same is true of types.</p>

<p class="author1">As you refine types, it can be helpful to think of the “uncanny valley” metaphor. Refining very imprecise types like <code class="calibre18">any</code> is usually helpful. But as your types get more precise, the expectation that they’ll also be accurate increases. You’ll start to rely on the types more, and so inaccuracies will produce bigger problems.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331654736600">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Avoid the uncanny valley of type safety: incorrect types are often worse than no types.</p>
</li>
<li class="calibre12">
<p class="author1">If<a data-primary="unknown types" data-secondary="versus inaccurate models" data-secondary-sortas="inaccurate models" data-type="indexterm" id="idm45331654733560" class="calibre9"/> you cannot model a type accurately, do not model it inaccurately! Acknowledge the gaps using <code class="calibre18">any</code> or <code class="calibre18">unknown</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Pay attention to error messages and autocomplete as you make typings increasingly precise. It’s not just about correctness: developer experience matters, too.<a data-primary="" data-startref="TDincomplete04" data-type="indexterm" id="idm45331654730168" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 35: Generate Types from APIs and Specs, Not Data" data-type="sect1" class="praise"><div class="praise" id="consider-codegen">
<h1 class="calibre16">Item 35: Generate Types from APIs and Specs, Not Data</h1>

<p class="author1">The<a data-primary="type design" data-secondary="generating types from specifications" data-type="indexterm" id="TDspec04" class="calibre9"/> other items in this chapter have discussed the many benefits of designing your types well and shown what can go wrong if you don’t. A well-designed type makes TypeScript a pleasure to use, while a poorly designed one can make it miserable. But this does put quite a bit of pressure on type design. Wouldn’t it be nice if you didn’t have to do this yourself?</p>

<p class="author1">At least some of your types are likely to come from outside your program: file formats, APIs, or specs. In these cases you may be able to avoid writing types by generating them instead. If you do this, the key is to generate types from specifications, rather than from example data. When you generate types from a spec, TypeScript will help ensure that you haven’t missed any cases. When you generate types from data, you’re only considering the examples you’ve seen. You might be missing important edge cases that could break your program.</p>

<p class="author1">In <a href="#null-values-to-perimeter" class="calibre9">Item 31</a> we wrote a function to calculate the bounding box of a<a data-primary="GeoJSON" data-type="indexterm" id="geojsonb04" class="calibre9"/> GeoJSON Feature. Here’s what it looked like:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateBoundingBox</code><code class="p">(</code><code class="nx">f</code>: <code class="nx">GeoJSONFeature</code><code class="p">)</code><code class="o">:</code> <code class="nx">BoundingBox</code><code class="o"> | </code><code class="nx">null</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">box</code>: <code class="nx">BoundingBox</code> <code class="o">|</code> <code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>

  <code class="kd">const</code> <code class="nx">helper</code> <code class="o">=</code> <code class="p">(</code><code class="nx">coords</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">};</code>

  <code class="kd">const</code> <code class="p">{</code><code class="nx">geometry</code><code class="p">}</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">helper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">coordinates</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">return</code> <code class="nx">box</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">GeoJSONFeature</code> type was never explicitly defined. You could write it using some of the examples from <a href="#null-values-to-perimeter" class="calibre9">Item 31</a>. But a better approach is to use the formal GeoJSON spec.<sup class="calibre44"><a data-type="noteref" href="ch04.html#idm45331654786008" id="idm45331654786008-marker" class="calibre45">1</a></sup> Fortunately for us, there are already TypeScript type declarations for it on DefinitelyTyped. You can add these in the usual way:</p>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">npm install --save-dev @types/geojson</strong>
+ @types/geojson@7946.0.7</pre>

<p class="author1">When you plug in the GeoJSON declarations, TypeScript immediately flags an error:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">import</code> <code class="p">{</code><code class="nx">Feature</code><code class="p">}</code> <code class="nx">from</code> <code class="s">'geojson'</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">calculateBoundingBox</code><code class="p">(</code><code class="nx">f</code>: <code class="nx">Feature</code><code class="p">)</code><code class="o">:</code> <code class="nx">BoundingBox</code><code class="o"> | </code><code class="nx">null</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">box</code>: <code class="nx">BoundingBox</code> <code class="o">|</code> <code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>

  <code class="kd">const</code> <code class="nx">helper</code> <code class="o">=</code> <code class="p">(</code><code class="nx">coords</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">};</code>

  <code class="kd">const</code> <code class="p">{</code><code class="nx">geometry</code><code class="p">}</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">helper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">coordinates</code><code class="p">);</code>
                 <code class="c">// ~~~~~~~~~~~</code>
                 <code class="c">// Property 'coordinates' does not exist on type 'Geometry'</code>
                 <code class="c">//   Property 'coordinates' does not exist on type</code>
                 <code class="c">//   'GeometryCollection'</code>
  <code class="p">}</code>

  <code class="kd">return</code> <code class="nx">box</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The problem is that your code assumes a geometry will have a <code class="calibre18">coordinates</code> property. This is true for many geometries, including points, lines, and polygons. But a GeoJSON geometry can also be a <code class="calibre18">GeometryCollection</code>, a heterogeneous collection of other geometries. Unlike the other geometry types, it does not have a <code class="calibre18">coordinates</code> property.</p>

<p class="author1">If you call <code class="calibre18">calculateBoundingBox</code> on a Feature whose geometry is a <code class="calibre18">GeometryCollection</code>, it will throw an error about not being able to read property <code class="calibre18">0</code> of <code class="calibre18">undefined</code>. This is a real bug! And we caught it using type definitions from a spec.</p>

<p class="author1">One option for fixing it is to explicitly disallow <code class="calibre18">GeometryCollection</code>s, as shown here:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">geometry</code><code class="p">}</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">type</code> <code class="o">===</code> <code class="s">'GeometryCollection'</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'GeometryCollections are not supported.'</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">helper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">coordinates</code><code class="p">);</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript is able to refine the type of <code class="calibre18">geometry</code> based on the check, so the reference to <code class="calibre18">geometry.coordinates</code> is allowed. If nothing else, this results in a clearer error message for the user.</p>

<p class="author1">But<a data-primary="Geometry" data-type="indexterm" id="idm45331654422824" class="calibre9"/> the better solution is to support all the types of geometry! You can do this by pulling out another helper function:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">geometryHelper</code> <code class="o">=</code> <code class="p">(</code><code class="nx">g</code>: <code class="nx">Geometry</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">type</code> <code class="o">===</code> <code class="s">'GeometryCollection'</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">geometry</code><code class="p">.</code><code class="nx">geometries</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">geometryHelper</code><code class="p">);</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">helper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">coordinates</code><code class="p">);</code>  <code class="c">// OK</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="p">{</code><code class="nx">geometry</code><code class="p">}</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">geometryHelper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">Had you written type declarations for GeoJSON yourself, you would have based them off of your understanding and experience with the format. This might not have included <code class="calibre18">GeometryCollection</code>s and would have led to a false sense of security about your code’s correctness. Using types based on a spec gives you confidence that your code will work with all values, not just the ones you’ve seen.</p>

<p class="author1">Similar considerations apply to API calls: if you can generate types from the specification of an API, then it is usually a good idea to do so. This works particularly well with APIs that are typed themselves, such as GraphQL.</p>

<p class="author1">A GraphQL API comes with a schema that specifies all the possible queries and interfaces using a type system somewhat similar to TypeScript. You write queries that request specific fields in these interfaces. For example, to get information about a repository using the GitHub GraphQL API you might write:</p>

<pre data-type="programlisting" class="calibre17">query {
  repository(owner: "Microsoft", name: "TypeScript") {
    createdAt
    description
  }
}</pre>

<p class="author1">The result is:</p>

<pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"data"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"repository"</code><code class="p">:</code> <code class="p">{</code>
      <code class="nt">"createdAt"</code><code class="p">:</code> <code class="s">"2014-06-17T15:28:39Z"</code><code class="p">,</code>
      <code class="nt">"description"</code><code class="p">:</code>
        <code class="s">"TypeScript is a superset of JavaScript that compiles to JavaScript."</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">The beauty of this approach is that you can generate TypeScript types <em class="calibre3">for your specific query</em>. As with the GeoJSON example, this helps ensure that you model the relationships between types and their nullability accurately.</p>

<p class="author1">Here’s a query to get the open source license for a GitHub repository:</p>

<pre data-type="programlisting" class="calibre17">query getLicense($owner:String!, $name:String!){
  repository(owner:$owner, name:$name) {
    description
    licenseInfo {
      spdxId
      name
    }
  }
}</pre>

<p class="author1"><code class="calibre18">$owner</code> and <code class="calibre18">$name</code> are GraphQL variables which are themselves typed. The type syntax is similar enough to TypeScript that it can be confusing to go back and forth. <code class="calibre18">String</code> is a GraphQL type—it would be <code class="calibre18">string</code> in TypeScript (see <a href="ch02_split_000.html#avoid-object-wrapper-types" class="calibre9">Item 10</a>). And while TypeScript types are not nullable, types in GraphQL are. The <code class="calibre18">!</code> after the type indicates that it is guaranteed to not be null.</p>

<p class="author1">There are many tools to help you go from a GraphQL query to TypeScript types. One is Apollo. Here’s how you use it:</p>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">apollo client:codegen \
    --endpoint https://api.github.com/graphql \
    --includes license.graphql \
    --target typescript</strong>
Loading Apollo Project
Generating query files with 'typescript' target - wrote 2 files</pre>

<p class="author1">You need a GraphQL schema to generate types for a query. Apollo gets this from the <code class="calibre18">api.github.com/graphql</code> endpoint. The output looks like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">export</code> <code class="kd">interface</code> <code class="nx">getLicense_repository_licenseInfo</code> <code class="p">{</code>
  <code class="nx">__typename</code><code class="o">:</code> <code class="s">"License"</code><code class="p">;</code>
  <code class="c">/** Short identifier specified by &lt;https://spdx.org/licenses&gt; */</code>
  <code class="nx">spdxId</code>: <code class="kd">string</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
  <code class="c">/** The license full name specified by &lt;https://spdx.org/licenses&gt; */</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">export</code> <code class="kd">interface</code> <code class="nx">getLicense_repository</code> <code class="p">{</code>
  <code class="nx">__typename</code><code class="o">:</code> <code class="s">"Repository"</code><code class="p">;</code>
  <code class="c">/** The description of the repository. */</code>
  <code class="nx">description</code>: <code class="kd">string</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
  <code class="c">/** The license associated with the repository */</code>
  <code class="nx">licenseInfo</code>: <code class="nx">getLicense_repository_licenseInfo</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">export</code> <code class="kd">interface</code> <code class="nx">getLicense</code> <code class="p">{</code>
  <code class="c">/** Lookup a given repository by the owner and repository name. */</code>
  <code class="nx">repository</code>: <code class="nx">getLicense_repository</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">export</code> <code class="kd">interface</code> <code class="nx">getLicenseVariables</code> <code class="p">{</code>
  <code class="nx">owner</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The important bits to note here are that:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">Interfaces are generated for both the query parameters (<code class="calibre18">getLicenseVariables</code>) and the response (<code class="calibre18">getLicense</code>).</p>
</li>
<li class="calibre12">
<p class="author1">Nullability information is transferred from the schema to the response interfaces. The <code class="calibre18">repository</code>, <code class="calibre18">description</code>, <code class="calibre18">licenseInfo</code>, and <code class="calibre18">spdxId</code> fields are nullable, whereas the license <code class="calibre18">name</code> and the query variables are not.</p>
</li>
<li class="calibre12">
<p class="author1">Documentation is transferred as JSDoc so that it appears in your editor (<a href="ch06.html#use-tsdoc" class="calibre9">Item 48</a>). These comments come from the GraphQL schema itself.</p>
</li>
</ul>

<p class="author1">This type information helps ensure that you use the API correctly. If your queries change, the types will change. If the schema changes, then so will your types. There is no risk that your types and reality diverge since they are both coming from a single source of truth: the GraphQL schema.</p>

<p class="author1">What if there’s no spec or official schema available? Then you’ll have to generate types from data. Tools like <code class="calibre18">quicktype</code> can help with this. But be aware that your types may not match reality: there may be edge cases that you’ve missed.</p>

<p class="author1">Even if you’re not aware of it, you are already benefiting from code generation. TypeScript’s type declarations for the browser DOM API are generated from the official interfaces (see <a href="ch07.html#understand-the-dom" class="calibre9">Item 55</a>). This ensures that they correctly model a complicated system and helps TypeScript catch errors and misunderstandings in your own code.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331654195896">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Consider<a data-primary="type safety" data-secondary="ensuring" data-type="indexterm" id="idm45331654193656" class="calibre9"/> generating types for API calls and data formats to get type safety all the way to the edge of your code.</p>
</li>
<li class="calibre12">
<p class="author1">Prefer generating code from specs rather than data. Rare cases matter!<a data-primary="" data-startref="TDspec04" data-type="indexterm" id="idm45331654191560" class="calibre9"/><a data-primary="" data-startref="geojsonb04" data-type="indexterm" id="idm45331654190584" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 36: Name Types Using the Language of Your Problem Domain" data-type="sect1" class="praise"><div class="praise" id="language-of-domain">
<h1 class="calibre16">Item 36: Name Types Using the Language of Your Problem Domain</h1>
<blockquote class="calibre4 pcalibre pcalibre1">
<p class="calibre5">There are only two hard problems in Computer Science: cache invalidation and naming things.</p>
<p data-type="attribution" class="pcalibre2 calibre6">Phil Karlton</p>
</blockquote>

<p class="author1">This<a data-primary="Karlton, Phil" data-type="indexterm" id="idm45331654185736" class="calibre9"/><a data-primary="type design" data-secondary="naming types" data-type="indexterm" id="TDname04" class="calibre9"/><a data-primary="properties" data-secondary="naming" data-type="indexterm" id="Pname04" class="calibre9"/><a data-primary="variables" data-secondary="naming" data-type="indexterm" id="Vname04" class="calibre9"/><a data-primary="names and naming" data-type="indexterm" id="names04" class="calibre9"/> book has had much to say about the <em class="calibre3">shape</em> of types and the sets of values in their domains, but much less about what you <em class="calibre3">name</em> your types. But this is an important part of type design, too. Well-chosen type, property, and variable names can clarify intent and raise the level of abstraction of your code and types. Poorly chosen types can obscure your code and lead to incorrect mental models.</p>

<p class="author1">Suppose you’re building out a database of animals. You create an interface to represent one:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Animal</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">endangered</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="nx">habitat</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">leopard</code>: <code class="nx">Animal</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Snow Leopard'</code><code class="p">,</code>
  <code class="nx">endangered</code>: <code class="nx">false</code><code class="p">,</code>
  <code class="nx">habitat</code><code class="o">:</code> <code class="s">'tundra'</code><code class="p">,</code>
<code class="p">};</code></pre>

<p class="author1">There are a few issues here:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1"><code class="calibre18">name</code> is a very general term. What sort of name are you expecting? A scientific name? A common name?</p>
</li>
<li class="calibre12">
<p class="author1">The boolean <code class="calibre18">endangered</code> field is also ambiguous. What if an animal is extinct? Is the intent here “endangered or worse?” Or does it literally mean endangered?</p>
</li>
<li class="calibre12">
<p class="author1">The <code class="calibre18">habitat</code> field is very ambiguous, not just because of the overly broad <code class="calibre18">string</code> type (<a href="#avoid-strings" class="calibre9">Item 33</a>) but also because it’s unclear what’s meant by “habitat.”</p>
</li>
<li class="calibre12">
<p class="author1">The variable name is <code class="calibre18">leopard</code>, but the value of the <code class="calibre18">name</code> property is “Snow Leopard.” Is this distinction meaningful?</p>
</li>
</ul>

<p class="author1">Here’s a type declaration and value with less ambiguity:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Animal</code> <code class="p">{</code>
  <code class="nx">commonName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">genus</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">species</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">status</code>: <code class="nx">ConservationStatus</code><code class="p">;</code>
  <code class="nx">climates</code>: <code class="nx">KoppenClimate</code><code class="p">[];</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">ConservationStatus</code> <code class="o">=</code> <code class="s">'EX'</code> <code class="o">|</code> <code class="s">'EW'</code> <code class="o">|</code> <code class="s">'CR'</code> <code class="o">|</code> <code class="s">'EN'</code> <code class="o">|</code> <code class="s">'VU'</code> <code class="o">|</code> <code class="s">'NT'</code> <code class="o">|</code> <code class="s">'LC'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">KoppenClimate</code> <code class="o">=</code> <code class="o">|</code>
  <code class="s">'Af'</code> <code class="o">|</code> <code class="s">'Am'</code> <code class="o">|</code> <code class="s">'As'</code> <code class="o">|</code> <code class="s">'Aw'</code> <code class="o">|</code>
  <code class="s">'BSh'</code> <code class="o">|</code> <code class="s">'BSk'</code> <code class="o">|</code> <code class="s">'BWh'</code> <code class="o">|</code> <code class="s">'BWk'</code> <code class="o">|</code>
  <code class="s">'Cfa'</code> <code class="o">|</code> <code class="s">'Cfb'</code> <code class="o">|</code> <code class="s">'Cfc'</code> <code class="o">|</code> <code class="s">'Csa'</code> <code class="o">|</code> <code class="s">'Csb'</code> <code class="o">|</code> <code class="s">'Csc'</code> <code class="o">|</code> <code class="s">'Cwa'</code> <code class="o">|</code> <code class="s">'Cwb'</code> <code class="o">|</code> <code class="s">'Cwc'</code> <code class="o">|</code>
  <code class="s">'Dfa'</code> <code class="o">|</code> <code class="s">'Dfb'</code> <code class="o">|</code> <code class="s">'Dfc'</code> <code class="o">|</code> <code class="s">'Dfd'</code> <code class="o">|</code>
  <code class="s">'Dsa'</code> <code class="o">|</code> <code class="s">'Dsb'</code> <code class="o">|</code> <code class="s">'Dsc'</code> <code class="o">|</code> <code class="s">'Dwa'</code> <code class="o">|</code> <code class="s">'Dwb'</code> <code class="o">|</code> <code class="s">'Dwc'</code> <code class="o">|</code> <code class="s">'Dwd'</code> <code class="o">|</code>
  <code class="s">'EF'</code> <code class="o">|</code> <code class="s">'ET'</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">snowLeopard</code>: <code class="nx">Animal</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">commonName</code><code class="o">:</code> <code class="s">'Snow Leopard'</code><code class="p">,</code>
  <code class="nx">genus</code><code class="o">:</code> <code class="s">'Panthera'</code><code class="p">,</code>
  <code class="nx">species</code><code class="o">:</code> <code class="s">'Uncia'</code><code class="p">,</code>
  <code class="nx">status</code><code class="o">:</code> <code class="s">'VU'</code><code class="p">,</code>  <code class="c">// vulnerable</code>
  <code class="nx">climates</code><code class="o">:</code> <code class="p">[</code><code class="s">'ET'</code><code class="p">,</code> <code class="s">'EF'</code><code class="p">,</code> <code class="s">'Dfd'</code><code class="p">],</code>  <code class="c">// alpine or subalpine</code>
<code class="p">};</code></pre>

<p class="author1">This makes a number of improvements:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1"><code class="calibre18">name</code> has been replaced with more specific terms: <code class="calibre18">commonName</code>, <code class="calibre18">genus</code>, and <code class="calibre18">species</code>.</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">endangered</code> has become <code class="calibre18">conservationStatus</code> and uses a standard classification system from the IUCN.</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">habitat</code> has become <code class="calibre18">climates</code> and uses another standard taxonomy, the Köppen climate classification.</p>
</li>
</ul>

<p class="author1">If you needed more information about the fields in the first version of this type, you’d have to go find the person who wrote them and ask. In all likelihood, they’ve left the company or don’t remember. Worse yet, you might run <code class="calibre18">git blame</code> to find out who wrote these lousy types, only to find that it was you!</p>

<p class="author1">The situation is much improved with the second version. If you want to learn more about the Köppen climate classification system or track down what the precise meaning of a conservation status is, then there are myriad resources online to help you.</p>

<p class="author1">Every domain has specialized vocabulary to describe its subject. Rather than inventing your own terms, try to reuse terms from the domain of your problem. These vocabularies have often been honed over years, decades, or centuries and are well understood by people in the field. Using these terms will help you communicate with users and increase the clarity of your types.</p>

<p class="author1">Take care to use domain vocabulary accurately: co-opting the language of a domain to mean something different is even more confusing than inventing your own.</p>

<p class="author1">Here are a few other rules to keep in mind as you name types, properties, and variables:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">Make distinctions meaningful. In writing and speech it can be tedious to use the same word over and over. We introduce synonyms to break the monotony. This makes prose more enjoyable to read, but it has the opposite effect on code. If you use two different terms, make sure you’re drawing a meaningful distinction. If not, you should use the same term.</p>
</li>
<li class="calibre12">
<p class="author1">Avoid vague, meaningless names like “data,” “info,” “thing,” “item,” “object,” or the ever-popular “entity.” If Entity has a specific meaning in your domain, fine. But if you’re using it because you don’t want to think of a more meaningful name, then you’ll eventually run into trouble.</p>
</li>
<li class="calibre12">
<p class="author1">Name things for what they are, not for what they contain or how they are computed. <code class="calibre18">Directory</code> is more meaningful than <code class="calibre18">INodeList</code>. It allows you to think about a directory as a concept, rather than in terms of its implementation. Good names can increase your level of abstraction and decrease your risk of inadvertent collisions.</p>
</li>
</ul>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331653898040">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Reuse names from the domain of your problem where possible to increase the readability and level of abstraction of your code.</p>
</li>
<li class="calibre12">
<p class="author1">Avoid using different names for the same thing: make distinctions in names meaningful.<a data-primary="" data-startref="names04" data-type="indexterm" id="idm45331653894792" class="calibre9"/><a data-primary="" data-startref="Vname04" data-type="indexterm" id="idm45331653893816" class="calibre9"/><a data-primary="" data-startref="Pname04" data-type="indexterm" id="idm45331653892872" class="calibre9"/><a data-primary="" data-startref="TDname04" data-type="indexterm" id="idm45331653891928" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 37: Consider “Brands” for Nominal Typing" data-type="sect1" class="praise"><div class="praise" id="brands">
<h1 class="calibre16">Item 37: Consider “Brands” for Nominal Typing</h1>

<p class="author1"><a href="ch01.html#structural" class="calibre9">Item 4</a> discussed<a data-primary="classes" data-secondary="nominal typing" data-type="indexterm" id="idm45331653887560" class="calibre9"/><a data-primary="type design" data-secondary="nominal typing" data-type="indexterm" id="TDnominal04" class="calibre9"/><a data-primary="nominal typing" data-type="indexterm" id="nominal04" class="calibre9"/><a data-primary="brands" data-type="indexterm" id="brand04" class="calibre9"/><a data-primary="TypeScript" data-secondary="structural typing" data-type="indexterm" id="TSstruct04" class="calibre9"/><a data-primary="structural typing" data-type="indexterm" id="struct04" class="calibre9"/><a data-primary="JavaScript" data-secondary="duck typing" data-type="indexterm" id="JSduch04" class="calibre9"/><a data-primary="duck typing" data-type="indexterm" id="duck04" class="calibre9"/><a data-primary="properties" data-secondary="modeling outside of type system" data-type="indexterm" id="Pmodel04" class="calibre9"/> structural (“duck”) typing and how it can sometimes lead to surprising results:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">p</code>: <code class="nx">Vector2D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">p</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code> <code class="o">*</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">calculateNorm</code><code class="p">({</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">});</code>  <code class="c">// OK, result is 5</code>
<code class="kd">const</code> <code class="nx">vec3D</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">1</code><code class="p">};</code>
<code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">vec3D</code><code class="p">);</code>  <code class="c">// OK! result is also 5</code></pre>

<p class="author1">What if you’d like <code class="calibre18">calculateNorm</code> to reject 3D vectors? This goes against the structural typing model of TypeScript but is certainly more mathematically correct.</p>

<p class="author1">One way to achieve this is with <em class="calibre3">nominal typing</em>. With nominal typing, a value is a <code class="calibre18">Vector2D</code> because you say it is, not because it has the right shape. To approximate this in TypeScript, you can introduce a “brand” (think cows, not Coca-Cola):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code>
  <code class="nx">_brand</code><code class="o">:</code> <code class="s">'2d'</code><code class="p">;</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">vec2D</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">Vector2D</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">{</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">_brand</code><code class="o">:</code> <code class="s">'2d'</code><code class="p">};</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">p</code>: <code class="nx">Vector2D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">p</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code> <code class="o">*</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>  <code class="c">// Same as before</code>
<code class="p">}</code>

<code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">vec2D</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">));</code> <code class="c">// OK, returns 5</code>
<code class="kd">const</code> <code class="nx">vec3D</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">1</code><code class="p">};</code>
<code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">vec3D</code><code class="p">);</code>
           <code class="c">// ~~~~~ Property '_brand' is missing in type...</code></pre>

<p class="author1">The brand ensures that the vector came from the right place. Granted there’s nothing stopping you from adding <code class="calibre18">_brand: '2d'</code> to the <code class="calibre18">vec3D</code> value. But this is moving from the accidental into the malicious. This sort of brand is typically enough to catch inadvertent misuses of functions.</p>

<p class="author1">Interestingly, you can get many of the same benefits as explicit brands while operating only in the type system. This removes runtime overhead and also lets you brand built-in types like <code class="calibre18">string</code> or <code class="calibre18">number</code> where you can’t attach additional properties.</p>

<p class="author1">For instance, what if you have a function that operates on the filesystem and requires an absolute (as opposed to a relative) path? This is easy to check at runtime (does the path start with “/”?) but not so easy in the type system.</p>

<p class="author1">Here’s an approach with brands:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">AbsolutePath</code> <code class="o">=</code> <code class="kt">string</code> <code class="o">&amp;</code> <code class="p">{</code><code class="nx">_brand</code><code class="o">:</code> <code class="s">'abs'</code><code class="p">};</code>
<code class="kd">function</code> <code class="nx">listAbsolutePath</code><code class="p">(</code><code class="nx">path</code>: <code class="nx">AbsolutePath</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">isAbsolutePath</code><code class="p">(</code><code class="nx">path</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">path</code> <code class="nx">is</code> <code class="nx">AbsolutePath</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">path</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s">'/'</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">You can’t construct an object that is a <code class="calibre18">string</code> and has a <code class="calibre18">_brand</code> property. This is purely a game with the type system.</p>

<p class="author1">If you have a <code class="calibre18">string</code> path that could be either absolute or relative, you can check using the type guard, which will refine its type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">path</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">isAbsolutePath</code><code class="p">(</code><code class="nx">path</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">listAbsolutePath</code><code class="p">(</code><code class="nx">path</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">listAbsolutePath</code><code class="p">(</code><code class="nx">path</code><code class="p">);</code>
                <code class="c">// ~~~~ Argument of type 'string' is not assignable</code>
                <code class="c">//      to parameter of type 'AbsolutePath'</code>
<code class="p">}</code></pre>

<p class="author1">This sort of approach could be helpful in documenting which functions expect absolute or relative paths and which type of path each variable holds. It is not an ironclad guarantee, though: <code class="calibre18">path as AbsolutePath</code> will succeed for any <code class="calibre18">string</code>. But if you avoid these sorts of assertions, then the only way to get an <code class="calibre18">AbsolutePath</code> is to be given one or to check, which is exactly what you want.</p>

<p class="author1">This approach can be used to model many properties that cannot be expressed within the type system. For example, using binary search to find an element in a list:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">binarySearch</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">xs</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">x</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">low</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">high</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="mi">1</code><code class="p">;</code>
  <code class="kd">while</code> <code class="p">(</code><code class="nx">high</code> <code class="o">&gt;=</code> <code class="nx">low</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">mid</code> <code class="o">=</code> <code class="nx">low</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">((</code><code class="nx">high</code> <code class="o">-</code> <code class="nx">low</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">mid</code><code class="p">];</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">v</code> <code class="o">===</code> <code class="nx">x</code><code class="p">)</code> <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">[</code><code class="nx">low</code><code class="p">,</code> <code class="nx">high</code><code class="p">]</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">v</code> <code class="o">?</code> <code class="p">[</code><code class="nx">mid</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">high</code><code class="p">]</code> <code class="o">:</code> <code class="p">[</code><code class="nx">low</code><code class="p">,</code> <code class="nx">mid</code> <code class="o">-</code> <code class="mi">1</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This works if the list is sorted, but will result in false negatives if it is not. You can’t represent a sorted list in TypeScript’s type system. But you can create a brand:</p>

<pre data-code-language="ts" data-type="programlisting" id="binary-search-sorted-list" class="calibre17"><code class="kd">type</code> <code class="nx">SortedList</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="p">[]</code> <code class="o">&amp;</code> <code class="p">{</code><code class="nx">_brand</code><code class="o">:</code> <code class="s">'sorted'</code><code class="p">};</code>

<code class="kd">function</code> <code class="nx">isSorted</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">xs</code>: <code class="nx">T</code><code class="p">[])</code><code class="o">:</code> <code class="nx">xs</code> <code class="nx">is</code> <code class="nx">SortedList</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">xs</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">xs</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">&gt;</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">i</code> <code class="o">-</code> <code class="mi">1</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">binarySearch</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">xs</code>: <code class="nx">SortedList</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">x</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">In order to call this version of <code class="calibre18">binarySearch</code>, you either need to be given a <code class="calibre18">SortedList</code> (i.e., have a proof that the list is sorted) or prove that it’s sorted yourself using <code class="calibre18">isSorted</code>. The linear scan isn’t great, but at least you’ll be safe!</p>

<p class="author1">This is a helpful perspective to have on the type checker in general. In order to call a method on an object, for instance, you either need to be given a non-<code class="calibre18">null</code> object or prove that it’s non-<code class="calibre18">null</code> yourself with a conditional.</p>

<p class="author1">You can also brand <code class="calibre18">number</code> types—for example, to attach units:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Meters</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">&amp;</code> <code class="p">{</code><code class="nx">_brand</code><code class="o">:</code> <code class="s">'meters'</code><code class="p">};</code>
<code class="kd">type</code> <code class="nx">Seconds</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">&amp;</code> <code class="p">{</code><code class="nx">_brand</code><code class="o">:</code> <code class="s">'seconds'</code><code class="p">};</code>

<code class="kd">const</code> <code class="nx">meters</code> <code class="o">=</code> <code class="p">(</code><code class="nx">m</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">m</code> <code class="kd">as</code> <code class="nx">Meters</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">seconds</code> <code class="o">=</code> <code class="p">(</code><code class="nx">s</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">s</code> <code class="kd">as</code> <code class="nx">Seconds</code><code class="p">;</code>

<code class="kd">const</code> <code class="nx">oneKm</code> <code class="o">=</code> <code class="nx">meters</code><code class="p">(</code><code class="mi">1000</code><code class="p">);</code>  <code class="c">// Type is Meters</code>
<code class="kd">const</code> <code class="nx">oneMin</code> <code class="o">=</code> <code class="nx">seconds</code><code class="p">(</code><code class="mi">60</code><code class="p">);</code>  <code class="c">// Type is Seconds</code></pre>

<p class="author1">This can be awkward in practice since arithmetic operations make the numbers forget their brands:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">tenKm</code> <code class="o">=</code> <code class="nx">oneKm</code> <code class="o">*</code> <code class="mi">10</code><code class="p">;</code>  <code class="c">// Type is number</code>
<code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">oneKm</code> <code class="o">/</code> <code class="nx">oneMin</code><code class="p">;</code>  <code class="c">// Type is number</code></pre>

<p class="author1">If your code involves lots of numbers with mixed units, however, this may still be an attractive approach to documenting the expected types of numeric parameters.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331653089864">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">TypeScript uses structural (“duck”) typing, which can sometimes lead to surprising results. If you need nominal typing, consider attaching “brands” to your values to distinguish them.</p>
</li>
<li class="calibre12">
<p class="author1">In some cases you may be able to attach brands entirely in the type system, rather than at runtime. You can use this technique to model properties outside of TypeScript’s type system.<a data-primary="" data-startref="Pmodel04" data-type="indexterm" id="idm45331653073432" class="calibre9"/><a data-primary="" data-startref="duck04" data-type="indexterm" id="idm45331653072456" class="calibre9"/><a data-primary="" data-startref="JSduch04" data-type="indexterm" id="idm45331653071512" class="calibre9"/><a data-primary="" data-startref="struct04" data-type="indexterm" id="idm45331653070568" class="calibre9"/><a data-primary="" data-startref="TSstruct04" data-type="indexterm" id="idm45331653069624" class="calibre9"/><a data-primary="" data-startref="brand04" data-type="indexterm" id="idm45331653068680" class="calibre9"/><a data-primary="" data-startref="nominal04" data-type="indexterm" id="idm45331653067736" class="calibre9"/><a data-primary="" data-startref="TDnominal04" data-type="indexterm" id="idm45331653066792" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>







<div data-type="footnotes" class="calibre46"><p data-type="footnote" id="idm45331654786008" class="calibre47"><sup class="calibre48"><a href="ch04.html#idm45331654786008-marker" class="calibre45">1</a></sup> GeoJSON is also known as RFC 7946. The very readable spec is at <a href="http://geojson.org" class="calibre9"><em class="calibre3">http://geojson.org</em></a>.</p></div></div></section></body></html>