- en: Chapter 10\. Deployments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。部署（Deployments）
- en: So far, you have seen how to package your applications as containers, create
    replicated sets of containers, and use Ingress controllers to load balance traffic
    to your services. You can use all of these objects (Pods, ReplicaSets, and Services)
    to build a single instance of your application. However, they do little to help
    you manage the daily or weekly cadence of releasing new versions of your application.
    Indeed, both Pods and ReplicaSets are expected to be tied to specific container
    images that don’t change.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了如何将应用程序打包为容器、创建容器的复制集，并使用 Ingress 控制器来负载均衡流量到您的服务。您可以使用所有这些对象（Pods、ReplicaSets
    和 Services）来构建应用程序的单个实例。但是，它们对于帮助您管理每日或每周发布新版本的节奏几乎没有帮助。实际上，Pods 和 ReplicaSets
    都预期与不会更改的特定容器映像绑定。
- en: The Deployment object exists to manage the release of new versions. Deployments
    represent deployed applications in a way that transcends any particular version.
    Additionally, Deployments enable you to easily move from one version of your code
    to the next. This “rollout” process is specifiable and careful. It waits for a
    user-configurable amount of time between upgrading individual Pods. It also uses
    health checks to ensure that the new version of the application is operating correctly
    and stops the deployment if too many failures occur.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment 对象的存在是为了管理新版本的发布。Deployments 以超越任何特定版本的方式表示部署的应用程序。此外，Deployments
    使您能够轻松地从代码的一个版本迁移到下一个版本。这个“滚动更新”过程是可指定的和谨慎的。它在升级单个 Pods 之间等待用户可配置的时间量。它还使用健康检查确保新版本的应用程序正在正确运行，并在发生太多故障时停止部署。
- en: Using Deployments, you can simply and reliably roll out new software versions
    without downtime or errors. The actual mechanics of the software rollout performed
    by a Deployment are controlled by a Deployment controller that runs in the Kubernetes
    cluster itself. This means you can let a Deployment proceed unattended and it
    will still operate correctly and safely. This makes it easy to integrate Deployments
    with numerous continuous delivery tools and services. Further, running server-side
    makes it safe to perform a rollout from places with poor or intermittent internet
    connectivity. Imagine rolling out a new version of your software from your phone
    while riding on the subway. Deployments make this possible and safe!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Deployments，您可以简单而可靠地推出新的软件版本，无需停机或错误。由 Deployment 控制器在 Kubernetes 集群中运行来控制软件推出的实际机制。这意味着您可以让
    Deployment 无人值守地进行，它仍然会正确和安全地操作。这使得将 Deployments 与许多持续交付工具和服务轻松集成成为可能。此外，从服务器端运行可以安全地执行来自网络连接质量较差或间歇性的地方的推出。想象一下，从手机上的地铁上推出软件的新版本。Deployments
    使这成为可能且安全！
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When Kubernetes was first released, one of the most popular demonstrations of
    its power was the “rolling update,” which showed how you could use a single command
    to seamlessly update a running application without any downtime and without losing
    requests. This original demo was based on the `kubectl rolling-update` command,
    which is still available in the command-line tool, although its functionality
    has largely been subsumed by the Deployment object.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Kubernetes 首次发布时，其功能的最受欢迎的演示之一是“滚动更新”，展示了如何使用单个命令无缝更新运行中的应用程序，而无需任何停机并且不会丢失请求。这个最初的演示基于
    `kubectl rolling-update` 命令，尽管其功能大部分已被 Deployment 对象所吸收，但该命令仍然可在命令行工具中使用。
- en: Your First Deployment
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个部署（Your First Deployment）
- en: 'Like all objects in Kubernetes, a Deployment can be represented as a declarative
    YAML object that provides the details about what you want to run. In the following
    case, the Deployment is requesting a single instance of the `kuard` application:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes 中的所有对象一样，Deployment 可以表示为声明性 YAML 对象，提供有关您要运行的内容的详细信息。在以下情况下，Deployment
    正在请求一个 `kuard` 应用程序的单个实例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save this YAML file as *kuard-deployment.yaml*, then you can create it using:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将此 YAML 文件保存为 *kuard-deployment.yaml*，然后可以使用以下命令创建它：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s explore how Deployments actually work. Just as we learned that ReplicaSets
    manage Pods, Deployments manage ReplicaSets. As with all relationships in Kubernetes,
    this relationship is defined by labels and a label selector. You can see the label
    selector by looking at the Deployment object:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨部署（Deployments）的实际工作原理。就像我们学到的 ReplicaSets 管理 Pods 一样，Deployments 管理 ReplicaSets。与
    Kubernetes 中的所有关系一样，这种关系是由标签和标签选择器定义的。您可以通过查看 Deployment 对象来查看标签选择器：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From this you can see that the Deployment is managing a ReplicaSet with the
    label `run=kuard`. You can use this in a label selector query across ReplicaSets
    to find that specific ReplicaSet:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以看出，部署正在管理一个带有标签`run=kuard`的副本集。您可以在副本集之间使用此标签选择器查询，以找到特定的副本集：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let’s look at the relationship between a Deployment and a ReplicaSet in
    action. We can resize the Deployment using the imperative `scale` command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看部署和副本集之间的关系如何运作。我们可以使用命令式`scale`命令调整部署大小：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now if we list that ReplicaSet again, we should see:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们再次列出该副本集，我们应该会看到：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Scaling the Deployment has also scaled the ReplicaSet it controls.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展部署也已扩展了它控制的副本集。
- en: 'Now let’s try the opposite, scaling the ReplicaSet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试相反的操作，扩展副本集：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now `get` that ReplicaSet again:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次`get`该副本集：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s odd. Despite scaling the ReplicaSet to one replica, it still has two
    replicas as its desired state. What’s going on?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这很奇怪。尽管将副本集扩展到一个副本，但其期望状态仍然是两个副本。出了什么问题？
- en: Remember, Kubernetes is an online, self-healing system. The top-level Deployment
    object is managing this ReplicaSet. When you adjust the number of replicas to
    one, it no longer matches the desired state of the Deployment, which has `replicas`
    set to `2`. The Deployment controller notices this and takes action to ensure
    the observed state matches the desired state, in this case readjusting the number
    of replicas back to two.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Kubernetes是一个在线的、自愈的系统。顶级部署对象正在管理此副本集。当您将副本数调整为一个时，它不再匹配部署的期望状态，部署的`replicas`设置为`2`。部署控制器注意到这一点，并采取行动确保观察到的状态与期望状态匹配，本例中重新调整副本数为两个。
- en: If you ever want to manage that ReplicaSet directly, you need to delete the
    Deployment. (Remember to set `--cascade` to `false`, or else it will delete the
    ReplicaSet and Pods as well!)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想直接管理该副本集，您需要删除部署。（记得设置`--cascade`为`false`，否则它将删除副本集和Pod！）
- en: Creating Deployments
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建部署
- en: Of course, as stated in the introduction, you should have a preference for declarative
    management of your Kubernetes configurations. This means maintaining the state
    of your Deployments in YAML or JSON files on disk.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如在介绍中所述，您应该优先考虑在磁盘上使用YAML或JSON文件进行声明式管理您的Kubernetes配置状态。
- en: 'As a starting point, download this Deployment into a YAML file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，将此部署下载到一个YAML文件中：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you look in the file, you will see something like this (note that we’ve
    removed a lot of read-only and default fields for readability). Pay attention
    to the annotations, selector, and strategy fields as they provide insight into
    Deployment-specific functionality:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看文件，您会看到类似于以下内容（请注意，为了可读性，我们已删除了许多只读和默认字段）。注意注释、选择器和策略字段，因为它们提供了部署特定功能的见解：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You also need to run `kubectl replace --save-config`. This adds an annotation
    so that, when applying changes in the future, `kubectl` will know what the last
    applied configuration was for smarter merging of configs. If you always use `kubectl
    apply`, this step is only required after the first time you create a Deployment
    using `kubectl create -f`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要运行`kubectl replace --save-config`。这会添加一个注释，以便在未来应用更改时，`kubectl`将知道上次应用的配置，从而实现更智能的配置合并。如果您始终使用`kubectl
    apply`，则仅在使用`kubectl create -f`创建部署后首次需要执行此步骤。
- en: 'The Deployment spec has a very similar structure to the ReplicaSet spec. There
    is a Pod template, which contains a number of containers that are created for
    each replica managed by the Deployment. In addition to the Pod specification,
    there is also a `strategy` object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 部署规范与副本集规范具有非常相似的结构。有一个Pod模板，其中包含由部署管理的每个副本创建的多个容器。除了Pod规范之外，还有一个`strategy`对象：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `strategy` object dictates the different ways in which a rollout of new
    software can proceed. There are two strategies supported by Deployments: `Recreate`
    and `RollingUpdate`. These are discussed in detail later in this chapter.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`strategy`对象规定了新软件发布可以进行的不同方式。部署支持两种策略：`Recreate`和`RollingUpdate`。这些在本章后面详细讨论。'
- en: Managing Deployments
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理部署
- en: 'As with all Kubernetes objects, you can get detailed information about your
    Deployment via the `kubectl describe` command. This command provides an overview
    of the Deployment configuration, which includes interesting fields like the Selector,
    Replicas, and Events:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有 Kubernetes 对象一样，您可以通过`kubectl describe`命令获取关于您的部署的详细信息。此命令提供了部署配置的概述，其中包括像选择器、副本和事件等有趣的字段：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the output of `describe`, there is a great deal of important information.
    Two of the most important pieces of information in the output are `OldReplicaSets`
    and `NewReplicaSet`. These fields point to the ReplicaSet objects this Deployment
    is currently managing. If a Deployment is in the middle of a rollout, both fields
    will be set to a value. If a rollout is complete, `OldReplicaSets` will be set
    to `<none>`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `describe` 的输出中，有大量重要的信息。输出中最重要的两个信息是 `OldReplicaSets` 和 `NewReplicaSet`。这些字段指向此
    Deployment 当前管理的 ReplicaSet 对象。如果 Deployment 正在进行中的部署，这两个字段都会设置为一个值。如果部署完成，`OldReplicaSets`
    将设置为 `<none>`。
- en: In addition to the `describe` command, there is also the `kubectl rollout` command
    for Deployments. We will go into this command in more detail later on, but for
    now, know that you can use `kubectl rollout history` to obtain the history of
    rollouts associated with a particular Deployment. If you have a current Deployment
    in progress, you can use `kubectl rollout status` to obtain the current status
    of that rollout.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `describe` 命令外，还有 `kubectl rollout` 命令用于处理 Deployments。稍后我们将详细介绍此命令，但现在知道你可以使用
    `kubectl rollout history` 获取与特定 Deployment 关联的部署历史。如果当前有进行中的 Deployment，可以使用 `kubectl
    rollout status` 获取该部署的当前状态。
- en: Updating Deployments
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 Deployments
- en: Deployments are declarative objects that describe a deployed application. The
    two most common operations on a Deployment are scaling and application updates.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Deployments 是描述已部署应用程序的声明性对象。对 Deployment 的两种最常见操作是扩展和应用程序更新。
- en: Scaling a Deployment
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 Deployment
- en: 'Although we previously showed how to imperatively scale a Deployment using
    the `kubectl scale` command, the best practice is to manage your Deployments declaratively
    via the YAML files, then use those files to update your Deployment. To scale up
    a Deployment, you would edit your YAML file to increase the number of replicas:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前展示了如何使用 `kubectl scale` 命令命令式地扩展 Deployment，但最佳实践是通过 YAML 文件声明性地管理您的 Deployments，然后使用这些文件来更新您的
    Deployment。要扩展 Deployment，您应该编辑您的 YAML 文件以增加副本数：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once you have saved and committed this change, you can update the Deployment
    using the `kubectl apply` command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并提交此更改后，您可以使用 `kubectl apply` 命令更新 Deployment：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will update the desired state of the Deployment, causing it to increase
    the size of the ReplicaSet it manages and eventually create a new Pod managed
    by the Deployment:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新 Deployment 的期望状态，导致 ReplicaSet 的大小增加，并最终创建由 Deployment 管理的新 Pod：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Updating a Container Image
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新容器镜像
- en: 'The other common use case for updating a Deployment is to roll out a new version
    of the software running in one or more containers. To do this, you should likewise
    edit the Deployment YAML file, though in this case you are updating the container
    image, rather than the number of replicas:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Deployment 的另一个常见用例是在一个或多个容器中部署新软件版本。为此，您应该同样编辑 Deployment 的 YAML 文件，但这种情况下您更新的是容器镜像，而不是副本数量：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Annotate the template for the Deployment to record some information about the
    update:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Deployment 的模板进行注释，记录有关更新的一些信息：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Caution
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you add this annotation to the template and not the Deployment itself,
    since the `kubectl apply` command uses this field in the Deployment object. Also,
    do not update the `change-cause` annotation when doing simple scaling operations.
    A modification of `change-cause` is a significant change to the template and will
    trigger a new rollout.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将此注释添加到模板而不是 Deployment 本身，因为 `kubectl apply` 命令使用此字段在 Deployment 对象中。在进行简单扩展操作时，请不要更新
    `change-cause` 注释。修改 `change-cause` 是模板的重大更改，并将触发新的部署。
- en: 'Again, you can use `kubectl apply` to update the Deployment:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用 `kubectl apply` 更新 Deployment：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After you update the Deployment, it will trigger a rollout, which you can then
    monitor via the `kubectl rollout` command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Deployment 后，它将触发一个部署，您可以通过 `kubectl rollout` 命令监视该过程：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can see the old and new ReplicaSets managed by the Deployment along with
    the images being used. Both the old and new ReplicaSets are kept around in case
    you want to roll back:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到由 Deployment 管理的旧 ReplicaSet 和新 ReplicaSet，以及正在使用的镜像。旧 ReplicaSet 和新 ReplicaSet
    都会保留下来，以便您可以进行回滚操作：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you are in the middle of a rollout and you want to temporarily pause it
    (e.g., if you start seeing weird behavior in your system that you want to investigate),
    you can use the `pause` command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在进行部署并希望暂时暂停它（例如，如果您开始看到系统中的奇怪行为并希望进行调查），您可以使用 `pause` 命令：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If, after investigation, you believe the rollout can safely proceed, you can
    use the `resume` command to start up where you left off:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调查后认为发布可以安全进行，您可以使用`resume`命令从中断的地方重新开始：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Rollout History
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布历史记录
- en: Kubernetes Deployments maintain a history of rollouts, which can be useful both
    for understanding the previous state of the Deployment and for rolling back to
    a specific version.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes部署维护发布历史记录，这对于了解部署的先前状态以及回滚到特定版本都很有用。
- en: 'You can see the Deployment history by running:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令查看部署历史记录：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The revision history is given in oldest to newest order. A unique revision
    number is incremented for each new rollout. So far we have two: the initial Deployment
    and the update of the image to `kuard:green`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 修订历史记录按从旧到新的顺序给出。每次新发布时都会递增唯一的修订号。到目前为止，我们有两个：初始部署和将图像更新为`kuard:green`。
- en: 'If you are interested in more details about a particular revision, you can
    add the `--revision` flag to view details about that specific revision:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对特定修订版本的详细信息感兴趣，可以添加`--revision`标志以查看该特定修订版本的详细信息：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s do one more update for this example. Update the `kuard` version back
    to `blue` by modifying the container version number and updating the `change-cause`
    annotation. Apply it with `kubectl apply`. The history should now have three entries:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为此示例再做一个更新。通过修改容器版本号并更新`change-cause`注释，将`kuard`版本回退为`blue`。使用`kubectl apply`应用它。现在历史记录应该有三个条目：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s say there is an issue with the latest release and you want to roll back
    while you investigate. You can simply undo the last rollout:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设最新版本存在问题，并且您希望在调查时回滚。您可以简单地撤消上次发布：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `undo` command works regardless of the stage of the rollout. You can undo
    both partially completed and fully completed rollouts. An undo of a rollout is
    actually simply a rollout in reverse (for example from v2 to v1, instead of from
    v1 to v2), and all of the same policies that control the rollout strategy apply
    to the undo strategy as well. You can see that the Deployment object simply adjusts
    the desired replica counts in the managed ReplicaSets:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`undo`命令在发布的任何阶段都有效。您可以撤消部分完成和完全完成的发布。撤消发布实际上只是逆向执行的发布（例如从v2到v1，而不是从v1到v2），同样控制发布策略的所有相同策略也适用于撤消策略。您可以看到部署对象简单地调整了受管ReplicaSet中的期望副本计数：'
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Caution
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When using declarative files to control your production systems, you should,
    as much as possible, ensure that the checked-in manifests match what is actually
    running in your cluster. When you do a `kubectl rollout undo`, you are updating
    the production state in a way that isn’t reflected in your source control.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用声明文件控制生产系统时，尽可能确保签入的清单与实际在集群中运行的内容匹配。当您执行`kubectl rollout undo`时，您正在以未反映在源代码控制中的方式更新生产状态。
- en: An alternative (and perhaps preferable) way to undo a rollout is to revert your
    YAML file and `kubectl apply` the previous version. In this way, your “change
    tracked configuration” more closely tracks what is really running in your cluster.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销发布的另一种（也许更可取的）方法是还原您的YAML文件并`kubectl apply`以前的版本。通过这种方式，您的“变更跟踪配置”更接近实际运行在集群中的情况。
- en: 'Let’s look at the Deployment history again:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看部署历史记录：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Revision 2 is missing! It turns out that when you roll back to a previous revision,
    the Deployment simply reuses the template and renumbers it so that it is the latest
    revision. What was revision 2 before is now revision 4.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失修订版本2！事实证明，当您回滚到先前的修订版本时，部署简单地重用模板并重新编号，使其成为最新修订版本。之前的修订版本2现在成为修订版本4。
- en: 'We previously saw that you can use the `kubectl rollout undo` command to roll
    back to a previous version of a Deployment. Additionally, you can roll back to
    a specific revision in the history using the `--to-revision` flag:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到您可以使用`kubectl rollout undo`命令回滚到部署的先前版本。此外，您还可以使用`--to-revision`标志回滚到历史记录中的特定修订版本：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, the `undo` took revision 3, applied it, and renumbered it as revision
    5.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行`undo`命令采用修订版本3，将其应用并重新编号为修订版本5。
- en: Specifying a revision of `0` is a shorthand way of specifying the previous revision.
    In this way, `kubectl rollout undo` is equivalent to `kubectl rollout undo --to-revision=0`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 指定修订版本`0`是指定上一个修订版本的简写方式。这样，`kubectl rollout undo`相当于`kubectl rollout undo --to-revision=0`。
- en: By default, the last 10 revisions of a Deployment are kept attached to the Deployment
    object itself. It is recommended that if you have Deployments that you expect
    to keep around for a long time, you set a maximum history size for the Deployment
    revision history. For example, if you do a daily update, you may limit your revision
    history to 14, to keep a maximum of two weeks’ worth of revisions (if you don’t
    expect to need to roll back beyond two weeks).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一个部署的最后 10 个修订版本会附加到部署对象本身。建议如果您有长期保留的部署，您可以设置部署修订历史的最大历史大小。例如，如果您每天更新一次，可以将修订历史限制为
    14，以保留两周的修订（如果您不希望在两周之外回滚）。
- en: 'To accomplish this, use the `revisionHistoryLimit` property in the Deployment
    specification:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请在部署规范中使用 `revisionHistoryLimit` 属性：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Deployment Strategies
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署策略
- en: When it comes time to change the version of the software implementing your service,
    a Kubernetes deployment supports two different rollout strategies, `Recreate`
    and `RollingUpdate`. Let’s look at each in turn.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要更改实施服务的软件版本时，Kubernetes 部署支持两种不同的滚动策略，`Recreate` 和 `RollingUpdate`。让我们依次查看每一种。
- en: Recreate Strategy
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重建策略
- en: The `Recreate` strategy is the simpler of the two. It simply updates the ReplicaSet
    it manages to use the new image and terminates all of the Pods associated with
    the Deployment. The ReplicaSet notices that it no longer has any replicas and
    re-creates all Pods using the new image. Once the Pods are re-created, they are
    running the new version.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recreate` 策略是这两种策略中更简单的一种。它只是更新其管理的 ReplicaSet 来使用新镜像，并终止与部署相关联的所有 Pod。ReplicaSet
    注意到它不再有任何副本，并重新创建所有使用新镜像的 Pod。一旦 Pod 重新创建，它们就会运行新版本。'
- en: While this strategy is fast and simple, it will result in workload downtime.
    Because of this, the `Recreate` strategy should be used only for test Deployments
    where a service downtime is acceptable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种策略快速而简单，但会导致工作负载停机。因此，`Recreate` 策略应仅用于可接受服务停机时间的测试部署。
- en: RollingUpdate Strategy
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动更新策略
- en: The `RollingUpdate` strategy is the generally preferable strategy for any user-facing
    service. While it is slower than `Recreate`, it is also significantly more sophisticated
    and robust. Using `RollingUpdate`, you can roll out a new version of your service
    while it is still receiving user traffic, without any downtime.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`RollingUpdate` 策略通常是任何面向用户服务的首选策略。虽然比 `Recreate` 策略更慢，但也显著更复杂和更健壮。使用 `RollingUpdate`，您可以在服务仍在接收用户流量的情况下推出新版本，而无需任何停机时间。'
- en: As you might infer from the name, the `RollingUpdate` strategy works by updating
    a few Pods at a time, moving incrementally until all of the Pods are running the
    new version of your software.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`RollingUpdate` 策略通过逐步更新一部分 Pod 来工作，直到所有 Pod 都运行新版本的软件。
- en: Managing multiple versions of your service
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理多个版本的服务
- en: Importantly, this means that for a while, both the new and the old version of
    your service will be receiving requests and serving traffic. This has important
    implications for how you build your software. Namely, it is critically important
    that each version of your software, and each of its clients, is capable of talking
    interchangeably with both a slightly older and a slightly newer version of your
    software.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这意味着一段时间内，您的服务的新旧版本都将接收请求并提供流量服务。这对您如何构建软件具有重要的影响。特别是，非常重要的是，您的每个软件版本及其客户端都能够与稍旧和稍新的软件版本互换通信。
- en: 'Consider the following scenario: you are in the middle of rolling out your
    frontend software; half of your servers are running version 1, and half are running
    version 2\. A user makes an initial request to your service and downloads a client-side
    JavaScript library that implements your UI. This request is serviced by a version
    1 server, and thus the user receives the version 1 client library. This client
    library runs in the user’s browser and makes subsequent API requests to your service.
    These API requests happen to be routed to a version 2 server; thus, version 1
    of your JavaScript client library is talking to version 2 of your API server.
    If you haven’t ensured compatibility between these versions, your application
    won’t function correctly.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景：您正在部署前端软件的过程中；一半服务器运行版本1，另一半运行版本2。用户向您的服务发出初始请求并下载实现您UI的客户端JavaScript库。此请求由版本1服务器处理，因此用户收到版本1客户端库。此客户端库在用户浏览器中运行，并向您的服务发出后续API请求。这些API请求被路由到版本2服务器；因此，您的JavaScript客户端库的版本1正在与您的API服务器的版本2进行通信。如果您没有确保这些版本之间的兼容性，您的应用程序将无法正确运行。
- en: At first, this might seem like an extra burden. But in truth, you always had
    this problem; you may just not have noticed. Concretely, a user can make a request
    at time `t` just before you initiate an update. This request is serviced by a
    version 1 server. At `t_1`, you update your service to version 2\. At `t_2`, the
    version 1 client code running on the user’s browser runs and hits an API endpoint
    being operated by a version 2 server. No matter how you update your software,
    you have to maintain backward and forward compatibility for reliable updates.
    The nature of the `RollingUpdate` strategy simply makes that more clear and explicit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这可能看起来像是一个额外的负担。但事实上，您始终面临这个问题；只是您可能没有注意到。具体而言，用户可以在时间`t`之前发出请求，就在您启动更新之前。此请求由版本1服务器处理。在`t_1`时，您将服务更新到版本2。在`t_2`时，运行在用户浏览器上的版本1客户端代码运行，并且请求了由版本2服务器操作的API端点。无论您如何更新软件，您都必须保持向后和向前兼容，以确保可靠的更新。`RollingUpdate`策略的本质只是使这一点更加清晰和明确。
- en: This doesn’t just apply to JavaScript clients—it’s true of client libraries
    that are compiled into other services that make calls to your service. Just because
    you updated doesn’t mean they have updated their client libraries. This sort of
    backward compatibility is critical to decoupling your service from systems that
    depend on your service. If you don’t formalize your APIs and decouple yourself,
    you are forced to carefully manage your rollouts with all of the other systems
    that call into your service. This kind of tight coupling makes it extremely hard
    to produce the necessary agility to be able to push out new software every week,
    let alone every hour or every day. In the decoupled architecture shown in [Figure 10-1](#fig1201),
    the frontend is isolated from the backend via an API contract and a load balancer,
    whereas in the coupled architecture, a thick client compiled into the frontend
    is used to connect directly to the backends.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅适用于JavaScript客户端，它也适用于编译到其他服务并调用您服务的客户端库。仅仅因为您更新了，并不意味着它们已经更新了它们的客户端库。这种向后兼容性对于解耦您的服务与依赖于您服务的系统至关重要。如果您不规范化您的API并解耦自己，那么您将被迫仔细管理与调用您服务的所有其他系统的发布。这种紧密耦合使得非常难以产生必要的灵活性，以便每周甚至每小时、每天都能推出新软件。在[图 10-1](#fig1201)中显示的解耦架构中，通过API合同和负载均衡器将前端与后端隔离开来，而在耦合架构中，则是通过编译到前端的厚客户端直接连接到后端。
- en: '![kur3 1001](assets/kur3_1001.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![kur3 1001](assets/kur3_1001.png)'
- en: Figure 10-1\. Diagrams of decoupled (left) and coupled (right) application architectures
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1。解耦（左）和耦合（右）应用架构的图示
- en: Configuring a rolling update
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置滚动更新
- en: '`RollingUpdate` is a fairly generic strategy; it can be used to update a variety
    of applications in a variety of settings. Consequently, the rolling update itself
    is quite configurable; you can tune its behavior to suit your particular needs.
    There are two parameters you can use to tune the rolling update behavior: `maxUnavailable`
    and `maxSurge`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`RollingUpdate`是一种非常通用的策略；它可以用来更新各种设置中的各种应用程序。因此，滚动更新本身是可以配置的；您可以调整其行为以适应您的特定需求。有两个参数可以用来调整滚动更新的行为：`maxUnavailable`和`maxSurge`。'
- en: The `maxUnavailable` parameter sets the maximum number of Pods that can be unavailable
    during a rolling update. It can either be set to an absolute number (e.g., `3`,
    meaning a maximum of three Pods can be unavailable) or to a percentage (e.g.,
    `20%`, meaning a maximum of 20% of the desired number of replicas can be unavailable).
    Generally speaking, using a percentage is a good approach for most services, since
    the value is correctly applied regardless of the desired number of replicas in
    the Deployment. However, there are times when you may want to use an absolute
    number (e.g., limiting the maximum unavailable Pods to one).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxUnavailable`参数设置在滚动更新期间可以不可用的最大Pod数量。它可以设置为绝对数（例如`3`，表示最多可以不可用三个Pod），也可以设置为百分比（例如`20%`，表示最多可以不可用期望副本数的20%）。一般来说，对大多数服务来说，使用百分比是一个好方法，因为该值是正确应用的，无论在部署中期望的副本数是多少。但是，在某些情况下，您可能希望使用绝对数（例如将最大不可用Pod限制为一个）。'
- en: At its core, the `maxUnavailable` parameter helps tune how quickly a rolling
    update proceeds. For example, if you set `maxUnavailable` to `50%`, then the rolling
    update will immediately scale the old ReplicaSet down to 50% of its original size.
    If you have four replicas, it will scale it down to two replicas. The rolling
    update will then replace the removed Pods by scaling the new ReplicaSet up to
    two replicas, for a total of four replicas (two old, two new). It will then scale
    the old ReplicaSet down to zero replicas, for a total size of two new replicas.
    Finally, it will scale the new ReplicaSet up to four replicas, completing the
    rollout. Thus, with `maxUnavailable` set to `50%`, the rollout completes in four
    steps, but with only 50% of the service capacity at times.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，`maxUnavailable`参数帮助调整滚动更新的速度。例如，如果将`maxUnavailable`设置为`50%`，则滚动更新将立即将旧的ReplicaSet缩减到其原始大小的50%。如果有四个副本，则将其缩减为两个副本。然后，滚动更新将通过将新的ReplicaSet扩展到两个副本来替换已删除的Pod，总共四个副本（两个旧的，两个新的）。然后，它将旧的ReplicaSet缩减为零个副本，总大小为两个新副本。最后，它将新的ReplicaSet扩展到四个副本，完成升级。因此，将`maxUnavailable`设置为`50%`，升级在四个步骤中完成，但在某些时候服务容量只有50%。
- en: Consider what happens if we instead set `maxUnavailable` to `25%`. In this situation,
    each step is only performed with a single replica at a time and thus it takes
    twice as many steps for the rollout to complete, but availability only drops to
    a minimum of 75% during the rollout. This illustrates how `maxUnavailable` allows
    us to trade rollout speed for availability.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`maxUnavailable`设置为`25%`会发生什么？在这种情况下，每个步骤仅执行一个副本，因此完成升级需要两倍的步骤，但在升级期间可用性只降到最低的75%。这说明了`maxUnavailable`允许我们在速度和可用性之间进行权衡。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The observant among you will notice that the `Recreate` strategy is identical
    to the `RollingUpdate` strategy with `maxUnavailable` set to `100%`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的人会注意到，`Recreate`策略与将`maxUnavailable`设置为`100%`的`RollingUpdate`策略是相同的。
- en: Using reduced capacity to achieve a successful rollout is useful either when
    your service has cyclical traffic patterns (for example, if there’s much less
    traffic at night) or when you have limited resources, so scaling to larger than
    the current maximum number of replicas isn’t possible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用降低的容量来实现成功的升级在以下情况下非常有用：当您的服务具有周期性流量模式时（例如，在夜间流量较少）或者当您的资源有限，因此无法扩展到比当前最大副本数更大。
- en: However, there are situations where you don’t want to fall below 100% capacity,
    but you are willing to temporarily use additional resources to perform a rollout.
    In these situations, you can set the `maxUnavailable` parameter to `0`, and instead
    control the rollout using the `maxSurge` parameter. Like `maxUnavailable`, `maxSurge`
    can be specified either as a specific number or a percentage.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有些情况下，您不希望低于100%的容量，但愿意临时使用额外的资源来执行滚动升级。在这些情况下，您可以将`maxUnavailable`参数设置为`0`，而是使用`maxSurge`参数来控制升级。与`maxUnavailable`类似，`maxSurge`可以指定为具体的数值或百分比。
- en: The `maxSurge` parameter controls how many extra resources can be created to
    achieve a rollout. To illustrate how this works, imagine a service with 10 replicas.
    We set `maxUnavailable` to `0` and `maxSurge` to `20%`. The first thing the rollout
    will do is scale the new ReplicaSet up by 2 replicas, for a total of 12 (120%)
    in the service. It will then scale the old ReplicaSet down to 8 replicas, for
    a total of 10 (8 old, 2 new) in the service. This process proceeds until the rollout
    is complete. At any time, the capacity of the service is guaranteed to be at least
    100% and the maximum extra resources used for the rollout are limited to an additional
    20% of all resources.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSurge` 参数控制可以创建多少额外资源来实现部署。为了说明其工作原理，想象一个具有 10 个副本的服务。我们将 `maxUnavailable`
    设置为 `0`，将 `maxSurge` 设置为 `20%`。部署首先会将新的 ReplicaSet 扩展 2 个副本，总共达到 12 个副本（120%）在服务中。然后，它会将旧的
    ReplicaSet 缩减到 8 个副本，服务总数为 10 个（8 个旧的，2 个新的）。这个过程一直持续，直到部署完成。在任何时候，服务的容量保证至少为
    100%，并且用于部署的最大额外资源限制为所有资源的额外 20%。'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Setting `maxSurge` to `100%` is equivalent to a blue/green Deployment. The Deployment
    controller first scales the new version up to 100% of the old version. Once the
    new version is healthy, it immediately scales the old version down to 0%.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `maxSurge` 设置为 `100%` 等同于蓝/绿部署。部署控制器首先将新版本扩展到旧版本的 100%。一旦新版本健康，它立即将旧版本缩减到
    0%。
- en: Slowing Rollouts to Ensure Service Health
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减缓部署以确保服务健康
- en: Staged rollouts are meant to ensure that the rollout results in a healthy, stable
    service running the new software version. To do this, the Deployment controller
    always waits until a Pod reports that it is ready before moving on to update the
    next Pod.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段性部署的目的是确保部署结果是一个健康、稳定的服务运行新软件版本。为了做到这一点，部署控制器始终等待一个 Pod 报告其准备就绪，然后再继续更新下一个
    Pod。
- en: Warning
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The Deployment controller examines the Pod’s status as determined by its readiness
    checks. Readiness checks are part of the Pod’s health checks, described in detail
    in [Chapter 5](ch05.xhtml#pods). If you want to use Deployments to reliably roll
    out your software, you *have* to specify readiness health checks for the containers
    in your Pod. Without these checks, the Deployment controller is running without
    knowing the Pod’s status.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 部署控制器检查 Pod 的状态，这由其准备就绪检查确定。准备就绪检查是 Pod 的健康检查的一部分，在第 [5 章](ch05.xhtml#pods)
    中详细描述。如果你希望使用部署来可靠地部署你的软件，*必须* 为 Pod 中的容器指定准备就绪健康检查。如果缺少这些检查，部署控制器在不知道 Pod 状态的情况下运行。
- en: Sometimes, however, simply noticing that a Pod has become ready doesn’t give
    you sufficient confidence that the Pod is actually behaving correctly. Some error
    conditions don’t occur immediately. For example, you could have a serious memory
    leak that takes a few minutes to show up, or you could have a bug that is only
    triggered by 1% of all requests. In most real-world scenarios, you want to wait
    a period of time to have high confidence that the new version is operating correctly
    before you move on to updating the next Pod.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅注意到一个 Pod 已经准备就绪并不足以让你对 Pod 是否实际上表现正确有足够的信心。有些错误条件不会立即发生。例如，你可能有一个严重的内存泄漏需要几分钟才能显示出来，或者你可能有一个只有
    1% 请求触发的 bug。在大多数真实场景中，你希望等待一段时间，以高度确信新版本在正确运行后再继续更新下一个 Pod。
- en: 'For Deployments, this time to wait is defined by the `minReadySeconds` parameter:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于部署，这个等待时间由 `minReadySeconds` 参数定义：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Setting `minReadySeconds` to `60` indicates that the Deployment must wait for
    60 seconds *after* seeing a Pod become healthy before moving on to updating the
    next Pod.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `minReadySeconds` 设置为 `60` 表示部署必须在看到一个 Pod 变为健康后等待 60 秒，*然后* 再继续更新下一个 Pod。
- en: In addition to waiting for a Pod to become healthy, you also want to set a timeout
    that limits how long the system will wait. Suppose, for example, the new version
    of your service has a bug and immediately deadlocks. It will never become ready,
    and in the absence of a timeout, the Deployment controller will stall your rollout
    forever.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了等待 Pod 变为健康状态外，你还需要设置一个超时时间限制系统等待的时间。例如，假设你的服务的新版本有一个 bug 并立即陷入死锁。它将永远无法准备就绪，在没有超时的情况下，部署控制器将永远停滞你的部署。
- en: The correct behavior in such a situation is to time out the rollout. This in
    turn marks the rollout as failed. This failure status can be used to trigger alerting
    that can indicate to an operator that there is a problem with the rollout.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下的正确行为是超时滚动发布。这反过来将发布标记为失败。此失败状态可用于触发警报，指示操作员发布存在问题。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At first blush, timing out a rollout might seem like an unnecessary complication.
    However, increasingly, things like rollouts are being triggered by fully automated
    systems with little to no human involvement. In such a situation, timing out becomes
    a critical exception, which can either trigger an automated rollback of the release
    or create a ticket/event that triggers human intervention.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，超时滚动发布似乎是一个不必要的复杂过程。然而，越来越多的事物，如发布，正被完全自动化的系统触发，几乎没有人类参与。在这种情况下，超时变得至关重要，它可以触发发布的自动回滚，或者创建一个触发人工干预的工单/事件。
- en: 'In order to set the timeout period, you will use the Deployment parameter `progressDeadlineSeconds`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置超时期限，您将使用部署参数`progressDeadlineSeconds`：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example sets the progress deadline to 10 minutes. If any particular stage
    in the rollout fails to progress in 10 minutes, then the Deployment is marked
    as failed, and all attempts to move the Deployment forward are halted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将进度截止期限设置为10分钟。如果在滚动发布的任何特定阶段未能在10分钟内取得进展，则该部署将标记为失败，并且所有推进部署的尝试都将停止。
- en: It is important to note that this timeout is given in terms of Deployment *progress*,
    not the overall length of a Deployment. In this context, progress is defined as
    any time the Deployment creates or deletes a Pod. When that happens, the timeout
    clock is reset to zero. [Figure 10-2](#fig1202) shows the Deployment life cycle.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，此超时是以部署的*进度*而不是部署的整体长度来计算的。在此上下文中，进度被定义为部署创建或删除 Pod 的任何时间。发生这种情况时，超时时钟将重置为零。[图 10-2](#fig1202)
    显示了部署的生命周期。
- en: '![kur3 1002](assets/kur3_1002.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![kur3 1002](assets/kur3_1002.png)'
- en: Figure 10-2\. The Kubernetes Deployment life cycle
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. Kubernetes 部署生命周期
- en: Deleting a Deployment
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除一个部署
- en: 'If you ever want to delete a Deployment, you can do it with the imperative
    command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望删除部署，可以使用以下命令：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also do it using the declarative YAML file you created earlier:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用您之前创建的声明性 YAML 文件来执行此操作：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In either case, by default, deleting a Deployment deletes the entire service.
    The means it will delete not just the Deployment, but also any ReplicaSets it
    manages, as well as any Pods the ReplicaSets manage. As with ReplicaSets, if this
    is not the desired behavior, you can use the `--cascade=false` flag to delete
    only the Deployment object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，默认情况下删除部署将删除整个服务。这意味着不仅会删除部署，还会删除它管理的任何 ReplicaSets，以及 ReplicaSets 管理的任何
    Pods。与 ReplicaSets 一样，如果这不是期望的行为，则可以使用`--cascade=false`标志仅删除部署对象。
- en: Monitoring a Deployment
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控部署
- en: If a Deployment fails to make progress after a specified amount of time, it
    will time out. When this happens, the status of the Deployment will transition
    to a failed state. This status can be obtained from the `status.conditions` array,
    where there will be a `Condition` whose `Type` is `Progressing` and whose `Status`
    is `False`. A Deployment in such a state has failed and will not progress further.
    To set how long the Deployment controller should wait before transitioning into
    this state, use the `spec.progressDeadlineSeconds` field.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果部署在指定时间内未能取得进展，则会超时。发生这种情况时，部署的状态将转换为失败状态。此状态可以从`status.conditions`数组中获取，其中将存在一个`Type`为`Progressing`且`Status`为`False`的`Condition`。处于这种状态的部署已失败，并且将不会进一步推进。要设置部署控制器在转换到此状态之前应等待多长时间，请使用`spec.progressDeadlineSeconds`字段。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Ultimately, the primary goal of Kubernetes is to make it easy for you to build
    and deploy reliable distributed systems. This means not just instantiating the
    application once, but managing the regularly scheduled rollout of new versions
    of that software service. Deployments are a critical piece of reliable rollouts
    and rollout management for your services. In the next chapter we will cover DaemonSets,
    which ensure only a single copy of a Pod is running across a set of nodes in a
    Kubernetes cluster.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的主要目标是使您能够轻松构建和部署可靠的分布式系统。这意味着不仅仅是一次性实例化应用程序，而是管理定期安排的新软件服务版本的滚动发布。部署是可靠发布和发布管理的关键组成部分。在下一章中，我们将介绍
    DaemonSets，它们确保在 Kubernetes 集群中的一组节点上只运行一个 Pod 的副本。
