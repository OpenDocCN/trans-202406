<html><head></head><body><section data-pdf-bookmark="Chapter 2. Getting Started with OpenShift and Kubernetes" data-type="chapter" epub:type="chapter"><div class="chapter" id="getting_started_with_openshift_and_kuber">&#13;
<h1><span class="label">Chapter 2. </span>Getting Started with OpenShift <span class="keep-together">and Kubernetes</span></h1>&#13;
<p>In this chapter, we cover a variety of topics that present a foundational understanding of Kubernetes and OpenShift. We begin with an overview of the Kubernetes architecture and then describe several deployment options that will enable you to get both a basic Kubernetes environment and an OpenShift environment up and running. Next, we give an introduction to the command-line tools <code>kubectl</code> and <code>oc</code>, which are used for interacting with Kubernetes and OpenShift respectively. We then introduce a short review of the fundamental Kubernetes concepts of pods, deployments, and service accounts. In the second half of this chapter, we present several enhancement concepts that OpenShift provides over traditional <span class="keep-together">Kubernetes</span>. We then conclude this chapter with a discussion of more advanced topics that are often used when running Kubernetes or OpenShift in production.</p>&#13;
<section data-pdf-bookmark="Kubernetes Architecture" data-type="sect1"><div class="sect1" id="kubernetes_architecture">&#13;
<h1>Kubernetes Architecture</h1>&#13;
<p>The <a href="https://oreil.ly/QEYUe">Kubernetes architecture</a> at a high level is relatively<a contenteditable="false" data-primary="Kubernetes" data-secondary="architecture" data-type="indexterm" id="ch02-arch"/><a contenteditable="false" data-primary="getting started" data-secondary="architecture of Kubernetes" data-type="indexterm" id="ch02-archx"/><a contenteditable="false" data-primary="architecture" data-secondary="Kubernetes" data-type="indexterm" id="ch02-arch2"/><a contenteditable="false" data-primary="master nodes" data-type="indexterm" id="idm45358202276408"/><a contenteditable="false" data-primary="worker nodes" data-secondary="about" data-type="indexterm" id="idm45358202275304"/> straightforward. It is composed of a <em>master node</em> and a set of <em>worker nodes</em>. The nodes can be either physical servers or VMs. <a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="about" data-type="indexterm" id="idm45358202272936"/><a contenteditable="false" data-primary="getting started" data-secondary="kubectl command-line tool" data-type="indexterm" id="idm45358202271544"/>Users of the Kubernetes environment interact with the master node using either a CLI (<code>kubectl</code>)<a contenteditable="false" data-primary="CLI" data-see="command-line interface" data-type="indexterm" id="idm45358202269608"/>, an API, or a GUI. The master node is responsible for scheduling work across the worker nodes. <a contenteditable="false" data-primary="pods" data-secondary="definition" data-type="indexterm" id="idm45358202267960"/><a contenteditable="false" data-primary="containers" data-secondary="pod networking model" data-type="indexterm" id="idm45358202266584"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="pod networking model" data-type="indexterm" id="idm45358202265208"/>In Kubernetes, the unit of work that is scheduled is called a <em>pod</em>, and a pod can hold one or more containers. <a contenteditable="false" data-primary="kube-scheduler" data-secondary="architecture of Kubernetes" data-type="indexterm" id="ch02-kube2"/><a contenteditable="false" data-primary="kube-controller-manager" data-secondary="architecture of Kubernetes" data-type="indexterm" id="ch02-kube3"/><a contenteditable="false" data-primary="etcd" data-secondary="architecture of Kubernetes" data-type="indexterm" id="ch02-kube4"/>The primary components that exist on the master node are the <em>kube-apiserver</em>, <em>kube-scheduler</em>, <em>kube-controller-manager,</em> and <em>etcd</em>:</p>&#13;
<dl>&#13;
<dt>kube-apiserver</dt>&#13;
<dd>The kube-apiserver makes available the Kubernetes API that is used to operate the Kubernetes environment.<a contenteditable="false" data-primary="kube-apiserver" data-secondary="architecture of Kubernetes" data-type="indexterm" id="idm45358202254840"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="API via kube-apiserver" data-type="indexterm" id="idm45358202253448"/></dd>&#13;
<dt>kube-scheduler</dt>&#13;
<dd>The kube-scheduler component is responsible for selecting the nodes on which pods should be created.<a contenteditable="false" data-primary="" data-startref="ch02-kube2" data-type="indexterm" id="idm45358202251096"/><a contenteditable="false" data-primary="pods" data-secondary="kube-scheduler selecting nodes" data-type="indexterm" id="idm45358202249720"/></dd>&#13;
<dt>kube-controller-manager</dt>&#13;
<dd>Kubernetes provides several high-level abstractions for supporting replicas of pods, managing nodes, and so on. Each of these is implemented with a controller component, which we describe later in this chapter. The kube-controller-manager is responsible for managing and running controller components.<a contenteditable="false" data-primary="" data-startref="ch02-kube3" data-type="indexterm" id="idm45358202247144"/></dd>&#13;
<dt>etcd</dt>&#13;
<dd>The etcd component is a distributed key-value store and is the primary <a contenteditable="false" data-primary="datastore" data-see="etcd" data-type="indexterm" id="idm45358202244680"/><a contenteditable="false" data-primary="control planes" data-secondary="etcd component" data-type="indexterm" id="idm45358202243224"/>datastore of the Kubernetes control plane. This component stores and replicates all the critical information states of your Kubernetes environment. <a contenteditable="false" data-primary="etcd" data-secondary="watches" data-type="indexterm" id="idm45358202241560"/><a contenteditable="false" data-primary="watches of etcd" data-type="indexterm" id="idm45358202240184"/><a contenteditable="false" data-primary="remote procedure calls (RPCs) via watches" data-type="indexterm" id="idm45358202239080"/>The key feature of etcd is its ability to support a watch. A <em>watch</em> is a remote procedure call (RPC) mechanism that allows for callbacks to functions on key-value create, update, or delete operations. <a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="etcd efficiency" data-type="indexterm" id="idm45358202237112"/>Kubernetes’s outstanding performance and scalability characteristics depend on etcd being a highly efficient data storage mechanism.<a contenteditable="false" data-primary="" data-startref="ch02-kube4" data-type="indexterm" id="idm45358202235192"/></dd>&#13;
</dl>&#13;
<p>The worker nodes are responsible for running the pods that are scheduled on them.<a contenteditable="false" data-primary="worker nodes" data-secondary="about" data-type="indexterm" id="idm45358202233304"/><a contenteditable="false" data-primary="kubelet" data-type="indexterm" id="idm45358202231928"/><a contenteditable="false" data-primary="kube-proxy" data-type="indexterm" id="idm45358202230824"/><a contenteditable="false" data-primary="container runtime" data-secondary="components" data-type="indexterm" id="idm45358202229720"/><a contenteditable="false" data-primary="runtime components" data-see="container runtime" data-type="indexterm" id="idm45358202228344"/> The primary Kubernetes components that exist on worker nodes are the <code>kubelet</code>, <em>kube-proxy</em>, and <em>container runtime</em>:</p>&#13;
<dl>&#13;
<dt><code>kubelet</code></dt>&#13;
<dd>The <code>kubelet</code> is responsible for making sure that the containers in each pod are created and stay up and running. The <code>kubelet</code> will restart containers upon recognizing that they have terminated unexpectedly or failed other health checks defined by the user.</dd>&#13;
<dt>kube-proxy</dt>&#13;
<dd>One of Kubernetes’s key strengths is the networking support it implements for containers. The kube-proxy component provides networking support in the form of connection forwarding, load balancing, and mapping of a <a contenteditable="false" data-primary="IP address per pod" data-type="indexterm" id="idm45358202221768"/><a contenteditable="false" data-primary="pods" data-secondary="IP address per pod" data-type="indexterm" id="idm45358202220664"/>single IP address to a pod. Kube-proxy is unique in that it gives a distributed load-balancing capability that is critical to the high availability architecture of Kubernetes.</dd>&#13;
<dt>container runtime</dt>&#13;
<dd>The container runtime component is responsible for running the containers that exist in each pod. Kubernetes supports several container runtime environment options, including Docker, <code>rkt</code>, CRI-O, and containerd.<sup><a data-type="noteref" href="ch02.html#ch01fn14" id="ch01fn14-marker">1</a></sup></dd>&#13;
</dl>&#13;
<p><a data-type="xref" href="#graphical_representation_of_the_kubernet">Figure 2-1</a> shows a <a contenteditable="false" data-primary="architecture" data-secondary="Kubernetes" data-tertiary="graphical representation" data-type="indexterm" id="idm45358202214072"/><a contenteditable="false" data-primary="getting started" data-secondary="architecture of Kubernetes" data-tertiary="graphical representation" data-type="indexterm" id="idm45358202212408"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="architecture" data-tertiary="graphical representation" data-type="indexterm" id="idm45358202210728"/><a contenteditable="false" data-primary="master nodes" data-secondary="graphical representation" data-type="indexterm" id="idm45358202209064"/><a contenteditable="false" data-primary="worker nodes" data-secondary="graphical representation" data-type="indexterm" id="idm45358202207672"/>graphical representation of the Kubernetes architecture encompassing a master node and two worker nodes.</p>&#13;
<figure><div class="figure" id="graphical_representation_of_the_kubernet">&#13;
<img src="assets/hcok_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>Graphical representation of the Kubernetes architecture</h6>&#13;
</div></figure>&#13;
<p>As shown in <a data-type="xref" href="#graphical_representation_of_the_kubernet">Figure 2-1</a>, <a contenteditable="false" data-primary="Kubernetes" data-secondary="API via kube-apiserver" data-tertiary="interacting with" data-type="indexterm" id="idm45358202202376"/><a contenteditable="false" data-primary="kube-apiserver" data-secondary="interacting with" data-type="indexterm" id="idm45358202200696"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="about" data-type="indexterm" id="idm45358202199320"/><a contenteditable="false" data-primary="getting started" data-secondary="kubectl command-line tool" data-type="indexterm" id="idm45358202197976"/>users interact with the Kubernetes API server using either a GUI or by <code>kubectl</code> CLI. Both of these use the Kubernetes API to interact with the kube-apiserver on the Kubernetes master node. The Kubernetes master node’s kube-scheduler component schedules pods to run on different worker nodes. Each pod contains one or more containers and is assigned its own IP address.<a contenteditable="false" data-primary="IP address per pod" data-type="indexterm" id="idm45358202195656"/><a contenteditable="false" data-primary="pods" data-secondary="IP address per pod" data-type="indexterm" id="idm45358202194552"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="autoscaling and replicas" data-type="indexterm" id="idm45358202193176"/><a contenteditable="false" data-primary="replicas" data-secondary="about Kubernetes" data-type="indexterm" id="idm45358202191512"/><a contenteditable="false" data-primary="pods" data-secondary="replicas" data-tertiary="about Kubernetes" data-type="indexterm" id="idm45358202190136"/><a contenteditable="false" data-primary="high availability (HA)" data-secondary="replicas of pods" data-type="indexterm" id="idm45358202188488"/><a contenteditable="false" data-primary="scaling" data-secondary="replicas of pods" data-type="indexterm" id="idm45358202187112"/>In many real-world applications, Kubernetes deploys multiple replicas (running copies) of the same pod to improve scalability and ensure high availability. Pods A1 and A2 are pod replicas that differ only in the IP address they are allocated. Similarly, Pods B1 and B2 are also replica copies of the same pod. <a contenteditable="false" data-primary="pods" data-secondary="container communication within" data-type="indexterm" id="idm45358202185288"/><a contenteditable="false" data-primary="containers" data-secondary="communication within a pod" data-type="indexterm" id="idm45358202183896"/><a contenteditable="false" data-primary="interprocess communication (IPC)" data-type="indexterm" id="idm45358202182504"/>The containers located in the same pod are permitted to communicate with one another using standard interprocess communication (IPC) mechanisms.</p>&#13;
<p>In the next section, we present several approaches to getting OpenShift and Kubernetes environments up and running.<a contenteditable="false" data-primary="" data-startref="ch02-arch" data-type="indexterm" id="idm45358202180840"/><a contenteditable="false" data-primary="" data-startref="ch02-arch2" data-type="indexterm" id="idm45358202179464"/><a contenteditable="false" data-primary="" data-startref="ch02-archx" data-type="indexterm" id="idm45358202178088"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Deployment Options for Kubernetes and OpenShift" data-type="sect1"><div class="sect1" id="deployment_options_for_kubernetes_and_op">&#13;
<h1>Deployment Options for Kubernetes and OpenShift</h1>&#13;
<p>Kubernetes and OpenShift have both reached incredible levels of popularity. As a result, several options are available for deploying either basic Kubernetes or Red Hat’s OpenShift Kubernetes distribution. In the following sections, we summarize the different types of deployment options that are currently available, including Red Hat’s CodeReady Containers, IBM Cloud, and several OpenShift deployment options.</p>&#13;
<section data-pdf-bookmark="Red Hat’s CodeReady Containers" data-type="sect2"><div class="sect2" id="red_hatapostrophes_codeready_containers">&#13;
<h2>Red Hat’s CodeReady Containers</h2>&#13;
<p>Red Hat provides a minimal preconfigured OpenShift version 4 cluster called<a contenteditable="false" data-primary="getting started" data-secondary="deployment of Kubernetes/OpenShift" data-tertiary="CodeReady Containers (Red Hat)" data-type="indexterm" id="idm45358202172808"/><a contenteditable="false" data-primary="deployments" data-secondary="Kubernetes/OpenShift" data-tertiary="CodeReady Containers (Red Hat)" data-type="indexterm" id="idm45358202171128"/><a contenteditable="false" data-primary="CodeReady Containers (Red Hat)" data-type="indexterm" id="idm45358202169464"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="deployment of OpenShift" data-tertiary="CodeReady Containers" data-type="indexterm" id="idm45358202168344"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="deployment of Kubernetes" data-tertiary="CodeReady Containers" data-type="indexterm" id="idm45358202166696"/> <a href="https://oreil.ly/1rI07">CodeReady Containers</a> that you can run on your laptop or desktop computer. The CodeReady OpenShift environment is intended to be used for development and testing purposes. CodeReady Containers provide a fully functional cloud development environment on your local machine and contain all the tooling necessary for you to develop container-based applications.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="IBM Cloud" data-type="sect2"><div class="sect2" id="ibm_cloud">&#13;
<h2>IBM Cloud</h2>&#13;
<p><a href="https://cloud.ibm.com">IBM Cloud</a> gives users their choice of <a contenteditable="false" data-primary="getting started" data-secondary="deployment of Kubernetes/OpenShift" data-tertiary="IBM Cloud" data-type="indexterm" id="idm45358202161416"/><a contenteditable="false" data-primary="deployments" data-secondary="Kubernetes/OpenShift" data-tertiary="IBM Cloud" data-type="indexterm" id="idm45358202159704"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="deployment of OpenShift" data-tertiary="IBM Cloud" data-type="indexterm" id="idm45358202158056"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="deployment of Kubernetes" data-tertiary="IBM Cloud" data-type="indexterm" id="idm45358202156408"/><a contenteditable="false" data-primary="IBM Cloud" data-type="indexterm" id="idm45358202154744"/><a contenteditable="false" data-primary="Kubernetes as a Service" data-secondary="providers" data-type="indexterm" id="idm45358202153640"/><a contenteditable="false" data-primary="IBM Cloud" data-secondary="Kubernetes as a Service" data-type="indexterm" id="idm45358202152264"/>either a traditional Kubernetes cluster or a Red Hat OpenShift cluster. IBM Cloud’s Kubernetes offering is a cloud service providing Kubernetes as a Service that brings all of the standard Kubernetes features, including intelligent scheduling, self-healing, horizontal scaling, service discovery and load balancing, automated rollout and rollbacks, and secret and configuration management. In addition, IBM Cloud’s Kubernetes Service includes automated operations for cluster deployment, updates, and scaling, expert security, optimized configuration, and seamless integration with the IBM Cloud Infrastructure platform. It produces highly available multizone clusters across 6 regions and 35 datacenters. IBM Cloud offers both a free Kubernetes cluster with over 40 free services and pay-as-you-go options.</p>&#13;
<p>IBM Cloud also provides users with highly available, fully managed <a href="https://oreil.ly/qsOdD">OpenShift clusters</a>. IBM’s OpenShift offering implements unique security and productivity capabilities designed to eliminate substantial time spent on updating, scaling, and provisioning. Additionally, IBM Cloud’s OpenShift delivers the resiliency to handle unexpected surges and protects against attacks that can lead to financial and productivity losses. In addition to pay-as-you-go and subscription options, IBM Cloud offers a free preconfigured OpenShift version 4.3 environment that is available for four hours at no charge.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="OpenShift Deployment Options" data-type="sect2"><div class="sect2" id="openshift_deployment_options">&#13;
<h2>OpenShift Deployment Options</h2>&#13;
<p>Several deployment options for OpenShift are defined at <a contenteditable="false" data-primary="getting started" data-secondary="deployment of Kubernetes/OpenShift" data-tertiary="OpenShift Getting Started site" data-type="indexterm" id="idm45358202145976"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="deployment of OpenShift" data-tertiary="Getting Started site options" data-type="indexterm" id="idm45358202144216"/><a contenteditable="false" data-primary="deployments" data-secondary="Kubernetes/OpenShift" data-tertiary="OpenShift Getting Started site" data-type="indexterm" id="idm45358202142552"/><a contenteditable="false" data-primary="online resources" data-secondary="OpenShift" data-tertiary="Getting Started site" data-type="indexterm" id="idm45358202140888"/>the <a href="https://www.openshift.com/try">Getting Started with OpenShift</a> website. The options described include installing OpenShift version 4 on your laptop, deploying it in your datacenter or public cloud, or having Red Hat manage OpenShift for you. In addition, <a contenteditable="false" data-primary="online resources" data-secondary="OpenShift" data-tertiary="tutorials and playground" data-type="indexterm" id="idm45358202138168"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="tutorials and playground" data-type="indexterm" id="idm45358202136488"/>Red Hat offers hands-on OpenShift tutorials and playground OpenShift environments for unstructured learning and experimentation. <a data-type="xref" href="#openshift_deployment_options_available_a">Figure 2-2</a> shows the myriad of OpenShift deployment options available.</p>&#13;
<figure><div class="figure" id="openshift_deployment_options_available_a">&#13;
<img src="assets/hcok_0202.png"/>&#13;
<h6><span class="label">Figure 2-2. </span>OpenShift deployment options available at <a href="https://www.openshift.com/try">Get Started with OpenShift</a></h6>&#13;
</div></figure>&#13;
<p>In the next section, we describe the command-line tools used for interacting with these platforms.</p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Kubernetes and OpenShift Command-Line Tools" data-type="sect1"><div class="sect1" id="kubernetes_and_openshift_command_line_to">&#13;
<h1>Kubernetes and OpenShift Command-Line Tools</h1>&#13;
<p>As discussed in <a data-type="xref" href="ch01.html#kubernetes_and_openshift_overview">Chapter 1</a>, OpenShift provides a 100% conformant Kubernetes platform and supplements it with a variety of tools and capabilities focused on improving the productivity of developers and IT operations. In this section, we begin with an introduction to <a contenteditable="false" data-primary="getting started" data-secondary="oc command-line tool" data-type="indexterm" id="idm45358202127624"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="command line via kubectl" data-seealso="kubectl command-line tool" data-type="indexterm" id="idm45358200825128"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="command line via oc" data-type="indexterm" id="idm45358200823496"/><a contenteditable="false" data-primary="oc command-line tool" data-secondary="about" data-type="indexterm" id="idm45358200822120"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="about" data-type="indexterm" id="idm45358200820744"/><a contenteditable="false" data-primary="command-line interfaces (CLIs)" data-secondary="kubectl" data-see="kubectl command-line tool" data-type="indexterm" id="idm45358200819352"/><a contenteditable="false" data-primary="getting started" data-secondary="kubectl command-line tool" data-type="indexterm" id="idm45358200817672"/><code>kubectl</code> and <code>oc</code>, which are the standard command-line tools used for interacting with Kubernetes and OpenShift respectively. We present several concepts that OpenShift uses to represent the enhancements it serves over traditional Kubernetes. OpenShift concepts that we describe include authentication, projects, applications, security contexts, and image streams.</p>&#13;
<p>After covering some core concepts in Kubernetes, the next sections give several examples in the form of YAML files. <a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="command line via oc" data-tertiary="kubectl for command line" data-type="indexterm" id="idm45358200814408"/>For all Kubernetes environments, the samples included can be run using the standard Kubernetes command-line tool <code>kubectl</code>. Many Kubernetes environments, including the ones mentioned earlier in this chapter, describe how <code>kubectl</code> can be installed. Once you have your Kubernetes environment up and running and <code>kubectl</code> installed, all of the <a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="YAML files run via" data-type="indexterm" id="idm45358200811176"/><a contenteditable="false" data-primary="YAML files" data-secondary="kubectl to run" data-type="indexterm" id="idm45358200809800"/>YAML file samples in the following sections can be run by first saving the YAML to a file (e.g., <em>kubesample1.yaml</em>) and then by running the following <code>kubectl</code> command:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl apply -f kubesample1.yaml</strong></pre>&#13;
<p>As previously discussed, the OpenShift distribution of Kubernetes adds several new <a contenteditable="false" data-primary="oc command-line tool" data-secondary="about" data-type="indexterm" id="idm45358200805832"/>enhancements and capabilities beyond those used by traditional Kubernetes. OpenShift provides access to these features by extending the capabilities of <code>kubectl</code>. <a contenteditable="false" data-primary="oc command-line tool" data-secondary="YAML files run via" data-type="indexterm" id="idm45358200803736"/><a contenteditable="false" data-primary="YAML files" data-secondary="oc to run" data-type="indexterm" id="idm45358200802328"/><a contenteditable="false" data-primary="command-line interfaces (CLIs)" data-secondary="oc" data-see="oc command-line tool" data-type="indexterm" id="idm45358200800952"/>To make it explicit that the OpenShift version of <code>kubectl</code> has extended functionality, OpenShift renamed its version of <code>kubectl</code> to be a new command-line tool called <code>oc.</code> Thus, the following is equivalent to the previous <code>kubectl</code> command:</p>&#13;
<pre data-type="programlisting">$ <strong>oc apply -f kubesample1.yaml</strong></pre>&#13;
<p>In addition to one-for-one matching support for all <code>kubectl</code> commands, <code>oc</code> adds commands for administrative functions like managing roles and role bindings for users and groups.</p>&#13;
<p>For more information on the breadth of commands available from the OpenShift <code>oc</code> CLI, please see the <a href="https://oreil.ly/7NQW3">OpenShift command line documentation</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Kubernetes Fundamentals" data-type="sect1"><div class="sect1" id="kubernetes_fundamentals">&#13;
<h1>Kubernetes Fundamentals</h1>&#13;
<p>Kubernetes has several concepts that are specific to its model for managing containers. In this section we briefly review key Kubernetes concepts, including pods, deployments, and service accounts.</p>&#13;
<section data-pdf-bookmark="What’s a Pod?" data-type="sect2"><div class="sect2" id="whatapostrophes_a_podquestion_mark">&#13;
<h2>What’s a Pod?</h2>&#13;
<p>Because Kubernetes supports the management and orchestration of containers,<a contenteditable="false" data-primary="getting started" data-secondary="fundamentals of Kubernetes" data-tertiary="pod overview" data-type="indexterm" id="idm45358200788872"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="fundamentals" data-tertiary="pod overview" data-type="indexterm" id="idm45358200787256"/><a contenteditable="false" data-primary="pods" data-secondary="about" data-tertiary="fundamentals" data-type="indexterm" id="idm45358200785608"/> you would assume that the smallest deployable unit supported by Kubernetes would be a container. However, the designers of Kubernetes learned from experience<sup><a data-type="noteref" href="ch02.html#ch01fn15" id="ch01fn15-marker">2</a></sup> that it was more optimal to have the smallest deployable unit be something that could hold multiple containers. In Kubernetes, this smallest deployable unit is called a <em>pod</em>. A pod can hold one or more application containers. <a contenteditable="false" data-primary="pods" data-secondary="application containers in same versus different pods" data-type="indexterm" id="idm45358200780216"/><a contenteditable="false" data-primary="containers" data-secondary="applications in same versus different pods" data-type="indexterm" id="idm45358200778808"/>The application containers that are in the same pod have the following benefits:</p>&#13;
<ul>&#13;
<li><p>They share an IP address and port space</p></li>&#13;
<li><p>They share the same hostname</p></li>&#13;
<li><p>They can communicate with one another using native IPC</p></li>&#13;
</ul>&#13;
<p>In contrast, application containers that run in separate pods are guaranteed to have different IP addresses and different hostnames. Essentially, containers in different pods should be viewed as running on different servers even if they ended up on the same node.</p>&#13;
<p>Kubernetes contributes a robust set of features that make pods easy to use:</p>&#13;
<dl>&#13;
<dt>Easy-to-use pod management API</dt>&#13;
<dd>Kubernetes provides the <code>kubectl</code> CLI, which supports a variety of operations on pods, including creating, viewing, deleting, updating, interacting, and scaling pods.</dd>&#13;
<dt>File copy support</dt>&#13;
<dd>Kubernetes makes it very easy to copy files back and forth between your local host machine and your pods running in the cluster.</dd>&#13;
<dt>Connectivity from your local machine to your pod</dt>&#13;
<dd>In many cases, you will want to have network connectivity from your local host machine to your pods running in the cluster.<a contenteditable="false" data-primary="debugging" data-secondary="local machine–pod connectivity" data-type="indexterm" id="idm45358200769928"/><a contenteditable="false" data-primary="port forwarding for pod connectivity" data-type="indexterm" id="idm45358200768488"/> Kubernetes supports port forwarding whereby a network port on your local host machine is connected via a secure tunnel to a port on your pod that is running in the cluster. This is an excellent feature to assist in debugging applications and services without having to expose them publicly.</dd>&#13;
<dt>Volume storage support</dt>&#13;
<dd>Kubernetes pods support the attachment of remote network <a contenteditable="false" data-primary="storage volumes" data-secondary="attachment of remote network volumes" data-type="indexterm" id="idm45358200766072"/>storage volumes to enable the containers in pods to access persistent storage that remains long after the lifetime of the pods and the containers that initially utilized the storage.</dd>&#13;
<dt>Probe-based health-check support</dt>&#13;
<dd>Kubernetes provides health checks in the form of probes to <a contenteditable="false" data-primary="health checking" data-secondary="containers" data-type="indexterm" id="idm45358200763448"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="health checking" data-type="indexterm" id="idm45358200761992"/><a contenteditable="false" data-primary="containers" data-secondary="about" data-tertiary="health checking" data-type="indexterm" id="idm45358200760344"/>ensure that the main processes of your containers are still running. In addition, Kubernetes administers liveness checks that ensure the containers are actually functioning and capable of doing real work. With this health-check support, Kubernetes can recognize if your containers have crashed or become nonfunctional and restart them on your behalf.</dd>&#13;
</dl>&#13;
</div></section>&#13;
<section data-pdf-bookmark="How Do I Describe What’s in My Pod?" data-type="sect2"><div class="sect2" id="how_do_i_describe_whatapostrophes_in_my">&#13;
<h2>How Do I Describe What’s in My Pod?</h2>&#13;
<p>Pods and all other resources managed by Kubernetes are described<a contenteditable="false" data-primary="getting started" data-secondary="fundamentals of Kubernetes" data-tertiary="pod resource descriptions" data-type="indexterm" id="idm45358200756024"/><a contenteditable="false" data-primary="YAML files" data-secondary="pod resource descriptions" data-type="indexterm" id="idm45358200754216"/><a contenteditable="false" data-primary="pods" data-secondary="YAML file descriptions of resources" data-type="indexterm" id="idm45358200752824"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="fundamentals" data-tertiary="pod resource descriptions" data-type="indexterm" id="idm45358200751432"/> using a YAML file. The following is a simple YAML file that describes a rudimentary pod resource:</p>&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
 <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
 <code class="nt">containers</code><code class="p">:</code>&#13;
 <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
   <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx:1.7.9</code>&#13;
   <code class="nt">ports</code><code class="p">:</code>&#13;
   <code class="p-Indicator">-</code> <code class="nt">containerPort</code><code class="p">:</code> <code class="l-Scalar-Plain">80</code></pre>&#13;
<p>This YAML file contains the following fields and sections:</p>&#13;
<dl>&#13;
<dt><code>apiVersion</code></dt>&#13;
<dd>This field is used to declare which version of the Kubernetes API schema<a contenteditable="false" data-primary="YAML files" data-secondary="apiVersion field" data-type="indexterm" id="idm45358198554344"/><a contenteditable="false" data-primary="apiVersion field in YAML files" data-type="indexterm" id="idm45358198611048"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="API via kube-apiserver" data-tertiary="apiVersion field in YAML files" data-type="indexterm" id="idm45358198609976"/><a contenteditable="false" data-primary="kube-apiserver" data-secondary="apiVersion field in YAML files" data-type="indexterm" id="idm45358198608360"/> is being used. Kubernetes continues to experience rapid growth in features and functionality. It manages the complexity that results from its growth in capabilities by supporting multiple versions of its API. By setting the <code>apiVersion</code> field, you can control the API version that your resource uses.</dd>&#13;
<dt><code>kind</code></dt>&#13;
<dd>Use the <code>kind</code> field to identify the type of resource the YAML file is describing.<a contenteditable="false" data-primary="YAML files" data-secondary="kind field" data-type="indexterm" id="idm45358198604792"/><a contenteditable="false" data-primary="kind field in YAML files" data-type="indexterm" id="idm45358198603416"/> In the preceding example, the YAML file declares that it is describing a <code>Pod</code> object.</dd>&#13;
<dt><code>metadata</code></dt>&#13;
<dd>The <code>metadata</code> section contains information about the <a contenteditable="false" data-primary="metadata in YAML files" data-type="indexterm" id="idm45358198864152"/><a contenteditable="false" data-primary="YAML files" data-secondary="metadata" data-type="indexterm" id="idm45358198863160"/>resource that the YAML is defining. In the preceding example, the <code>metadata</code> contains a name field that declares the name of this pod. The <code>metadata</code> section can contain other types of identifying information, such as labels and annotations. We describe these in more detail in <a data-type="xref" href="#deployments">“Deployments”</a>.</dd>&#13;
<dt><code>spec</code></dt>&#13;
<dd>The <code>spec</code> section provides a specification for what the <a contenteditable="false" data-primary="spec section in YAML files" data-type="indexterm" id="idm45358198858152"/><a contenteditable="false" data-primary="YAML files" data-secondary="spec section" data-type="indexterm" id="idm45358198857080"/>desired state for this resource should be. As shown in the example, the desired state for this pod is to have a container with the name <code>nginx</code> that is built from the Docker image identified as <code>nginx:1.7.9</code><em>.</em> The container shares the IP address of the pod it is contained in, and <a contenteditable="false" data-primary="YAML files" data-secondary="containerPort field" data-type="indexterm" id="idm45358199088008"/><a contenteditable="false" data-primary="containerPort field in YAML files" data-type="indexterm" id="idm45358199086632"/><a contenteditable="false" data-primary="network port in containerPort field" data-type="indexterm" id="idm45358199085560"/>the <code>containerPort</code> field is used to allocate this container a network port (in this case, <code>80</code>) that it can use to send and receive network traffic.</dd>&#13;
</dl>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
&#13;
<p>The <code>apply</code> command will either create a resource or update<a contenteditable="false" data-primary="pods" data-secondary="YAML file descriptions of resources" data-tertiary="apply command" data-type="indexterm" id="idm45358199081672"/><a contenteditable="false" data-primary="YAML files" data-secondary="kubectl to run" data-tertiary="apply command" data-type="indexterm" id="idm45358199080056"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="YAML files run via" data-tertiary="apply command" data-type="indexterm" id="idm45358199035928"/><a contenteditable="false" data-primary="apply command in kubectl" data-type="indexterm" id="idm45358199034312"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="YAML files run via" data-tertiary="create command" data-type="indexterm" id="idm45358199033192"/><a contenteditable="false" data-primary="create command in kubectl" data-type="indexterm" id="idm45358199031528"/><a contenteditable="false" data-primary="YAML files" data-secondary="kubectl to run" data-tertiary="create command" data-type="indexterm" id="idm45358199030408"/><a contenteditable="false" data-primary="pods" data-secondary="YAML file descriptions of resources" data-tertiary="create command" data-type="indexterm" id="idm45358199028760"/> any existing matching resources. There is also a supported <code>create</code> command that will assume the resources described by the YAML document do not yet exist. You can typically use <code>apply</code> wherever you use <code>create</code>. <a contenteditable="false" data-primary="create command in kubectl" data-secondary="generateName attribute" data-type="indexterm" id="idm45358199025560"/><a contenteditable="false" data-primary="generateName attribute in create command" data-type="indexterm" id="idm45358198786536"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="YAML files run via" data-tertiary="generateName attribute" data-type="indexterm" id="idm45358198785400"/>In some cases, such as the special <code>generateName</code> attribute, only <code>create</code> is supported.</p>&#13;
</div>&#13;
<p>To run the previous example, save the file as <em>pod.yaml</em>. You can now run it by doing the following:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl apply -f pod.yaml</strong></pre>&#13;
<p>After running this command, you should see the following output:</p>&#13;
<pre data-type="programlisting">pod/nginx created</pre>&#13;
<p>To confirm that your pod is actually running,<a contenteditable="false" data-primary="get command" data-secondary="get pods for status" data-type="indexterm" id="idm45358198779304"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="get pods for status" data-type="indexterm" id="idm45358198777928"/><a contenteditable="false" data-primary="pods" data-secondary="status" data-tertiary="get pods command" data-type="indexterm" id="idm45358198776488"/> use the <code>kubectl get pods</code> command to verify:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl get pods</strong></pre>&#13;
<p>After running this command, you should see output similar to the following:</p>&#13;
<pre data-type="programlisting">NAME  READY STATUS  RESTARTS AGE&#13;
nginx 1/1   Running 0        21s</pre>&#13;
<p>When the pod is running, you can also view the logs of the process <a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="logs command for pod processes" data-type="indexterm" id="idm45358198771704"/><a contenteditable="false" data-primary="pods" data-secondary="process logs via logs command" data-type="indexterm" id="idm45358198770296"/><a contenteditable="false" data-primary="logs command for pod processes" data-type="indexterm" id="idm45358198768904"/>running within the pod with the <code>logs</code> command (if there are multiple containers, select the specific container you want to view with the <code>-c</code> option):</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl logs nginx</strong></pre>&#13;
<p>If you need to debug your running container, you can create an<a contenteditable="false" data-primary="debugging" data-secondary="interactive shell within container" data-type="indexterm" id="idm45358198765256"/><a contenteditable="false" data-primary="containers" data-secondary="debugging via interactive shell" data-type="indexterm" id="idm45358198763816"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="debugging via interactive shell" data-type="indexterm" id="idm45358198476840"/><a contenteditable="false" data-primary="bash shell within container" data-type="indexterm" id="idm45358198475432"/><a contenteditable="false" data-primary="pods" data-secondary="debugging via interactive shell" data-type="indexterm" id="idm45358198474312"/><a contenteditable="false" data-primary="root access in container image" data-type="indexterm" id="idm45358198472920"/> interactive shell that runs within the container by using the following command:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl exec -it nginx – bash</strong></pre>&#13;
<p>This command instructs Kubernetes to run an interactive shell for the container that runs in the pod named <code>nginx</code>. Because this pod has only one container, Kubernetes knows which container you want to connect to even if you have not specified the container name. Accessing the container interactively to modify it at runtime is typically considered a bad practice. However, interactive shells can be useful as you are learning or debugging apps before deploying to production. After you run the preceding command, you can interact with the container’s runtime environment, as shown here:</p>&#13;
<pre data-type="programlisting">root@nginx:/# <strong>ls</strong>&#13;
bin boot dev etc home lib lib64 media mnt opt proc root run sbin selinux &#13;
srv sys tmp usr var&#13;
root@nginx:/# <strong>exit</strong></pre>&#13;
<p>If your pod has multiple containers within it, you will need to include the container name as well in your <code>kubectl exec</code> command. To do this, use the <code>-c</code> option and include the container name in addition to the pod name. Here is an example:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl exec -it nginx -c nginx -- bash</strong>&#13;
root@nginx:/# exit&#13;
<strong>exit</strong></pre>&#13;
<p>To delete the pod that you just created, run the following command:<a contenteditable="false" data-primary="pods" data-secondary="deleting" data-type="indexterm" id="idm45358198464184"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="deleting pod" data-type="indexterm" id="idm45358198462728"/><a contenteditable="false" data-primary="delete" data-secondary="pod" data-type="indexterm" id="idm45358198461288"/></p>&#13;
<pre data-type="programlisting">$ <strong>kubectl delete pod nginx</strong></pre>&#13;
<p>You should see the following confirmation that the pod has been deleted:</p>&#13;
<pre data-type="programlisting">pod "nginx" deleted</pre>&#13;
<p>When using Kubernetes, you can expect to have large numbers of pods running in a cluster. In the next section, we describe how labels and annotations are used to help you keep track of and identify your pods.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Deployments" data-type="sect2"><div class="sect2" id="deployments">&#13;
<h2>Deployments</h2>&#13;
<p><em>Deployments</em> are a high-level Kubernetes abstraction that not <a contenteditable="false" data-primary="Kubernetes" data-secondary="fundamentals" data-tertiary="deployments" data-type="indexterm" id="ch02-dploy2"/><a contenteditable="false" data-primary="getting started" data-secondary="fundamentals of Kubernetes" data-tertiary="deployments" data-type="indexterm" id="ch02-dploy"/><a contenteditable="false" data-primary="deployments" data-secondary="application deployments" data-tertiary="about" data-type="indexterm" id="idm45358198684840"/><a contenteditable="false" data-primary="pods" data-secondary="deployments" data-type="indexterm" id="idm45358198683192"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="rollouts configurable" data-type="indexterm" id="idm45358198681816"/><a contenteditable="false" data-primary="rollouts" data-secondary="deployments of pods" data-type="indexterm" id="idm45358198680168"/><a contenteditable="false" data-primary="upgrades" data-secondary="rolling upgrades of Kubernetes" data-type="indexterm" id="idm45358198678792"/>only allow you to control the number of pod replicas that are instantiated, but also provide support for rolling out new versions of the pods. Deployments are configurable such that they can leverage extra resources for faster rollouts that have no downtime, or they can perform slower rollouts that do canary testing. The advantage of a slower rollout is that it can reduce the risk and validate new software by releasing the software to a small percentage of users, thus ensuring that the new version of the application is stable. <a contenteditable="false" data-primary="ReplicaSet resource" data-type="indexterm" id="idm45358198676728"/><a contenteditable="false" data-primary="deployments" data-secondary="ReplicaSet resource for pod replicas" data-type="indexterm" id="idm45358198675624"/><a contenteditable="false" data-primary="pods" data-secondary="replicas" data-tertiary="deployment using ReplicaSet" data-type="indexterm" id="idm45358198674232"/>Deployments rely on the <code>ReplicaSet</code> resource to manage pod replicas and then add pod version management support on top of this capability. Deployments also enable newly rolled-out versions of pods to be rolled back to previous versions if there is something wrong with the new versions of the pods. Furthermore, deployments support two options for upgrading pods, <code>Recreate</code> and <code>RollingUpdate</code>:</p>&#13;
<dl>&#13;
<dt><code>Recreate</code></dt>&#13;
<dd>The <code>Recreate</code> pod upgrade option is very straightforward. <a contenteditable="false" data-primary="upgrades" data-secondary="Recreate pod upgrade option" data-type="indexterm" id="idm45358198668920"/><a contenteditable="false" data-primary="Recreate pod upgrade option" data-type="indexterm" id="idm45358198667576"/><a contenteditable="false" data-primary="pods" data-secondary="deployments" data-tertiary="Recreate upgrade option" data-type="indexterm" id="idm45358198666456"/><a contenteditable="false" data-primary="deployments" data-secondary="application deployments" data-tertiary="Recreate pod upgrade option" data-type="indexterm" id="idm45358198664808"/><a contenteditable="false" data-primary="ReplicaSet resource" data-secondary="Recreate pod upgrade option" data-type="indexterm" id="idm45358198663144"/><a contenteditable="false" data-primary="deployments" data-secondary="ReplicaSet resource for pod replicas" data-tertiary="Recreate pod upgrade option" data-type="indexterm" id="idm45358198376696"/>In this approach, the deployment resource modifies its associated <code>ReplicaSet</code> to point to the new version of the pod. It then proceeds to terminate all the pods. The <code>ReplicaSet</code> then notices that all the pods have been terminated and thus spawns new pods to ensure that the number of desired replicas are up and running. The <code>Recreate</code> approach will typically result in your pod application not being accessible for a period of time, and thus it is not recommended for applications that need to always be available.</dd>&#13;
<dt><code>RollingUpdate</code></dt>&#13;
<dd>Kubernetes’s deployment resource also provides a <code>RollingUpdate</code> option.<a contenteditable="false" data-primary="RollingUpdate pod upgrade option" data-type="indexterm" id="ch02-rlupd"/><a contenteditable="false" data-primary="pods" data-secondary="deployments" data-tertiary="RollingUpdate upgrade option" data-type="indexterm" id="ch02-rlupd2"/><a contenteditable="false" data-primary="upgrades" data-secondary="RollingUpdate pod upgrade option" data-type="indexterm" id="ch02-rlupd3"/><a contenteditable="false" data-primary="deployments" data-secondary="application deployments" data-tertiary="RollingUpdate pod upgrade option" data-type="indexterm" id="ch02-rlupd4"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="rolling upgrades" data-type="indexterm" id="idm45358198364664"/><a contenteditable="false" data-primary="rolling upgrades" data-secondary="deployment resource of Kubernetes" data-type="indexterm" id="idm45358198363016"/> With the <code>RollingUpdate</code> option, your pods are replaced with the newer versions incrementally over time. This approach results in there being a mixture of both the old version and the new version of the pod running simultaneously and thus avoids having your pod application unavailable during this maintenance period. <a contenteditable="false" data-primary="kube-proxy" data-secondary="RollingUpdate pod upgrades" data-type="indexterm" id="idm45358198360744"/><a contenteditable="false" data-primary="ingress controllers" data-type="indexterm" id="idm45358198359352"/>The readiness of each pod is measured and used to inform kube-proxy and ingress controllers which pod replicas are available to handle network requests to ensure that no requests are dropped during the update process.</dd>&#13;
</dl>&#13;
<p>The following is an example YAML specification for a deployment that uses the <span class="keep-together"><code>RollingUpdate</code></span> option:<a contenteditable="false" data-primary="YAML files" data-secondary="deployment" data-tertiary="RollingUpdate pod upgrade option" data-type="indexterm" id="ch02-rlupd5"/><a contenteditable="false" data-primary="pods" data-secondary="deployments" data-tertiary="RollingUpdate YAML file" data-type="indexterm" id="ch02-rlupd6"/><a contenteditable="false" data-primary="deployments" data-secondary="application deployments" data-tertiary="RollingUpdate YAML file" data-type="indexterm" id="ch02-rlupd7"/><a contenteditable="false" data-primary="RollingUpdate pod upgrade option" data-secondary="YAML file" data-type="indexterm" id="ch02-rlupd8"/></p>&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
 <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
 <code class="nt">labels</code><code class="p">:</code>&#13;
  <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">webserver</code>&#13;
 <code class="nt">annotations</code><code class="p">:</code>&#13;
  <code class="nt">deployment.kubernetes.io/revision</code><code class="p">:</code> <code class="s">"1"</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
 <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">3</code>&#13;
 <code class="nt">selector</code><code class="p">:</code>&#13;
  <code class="nt">matchLabels</code><code class="p">:</code>&#13;
   <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">webserver</code>&#13;
 <code class="nt">strategy</code><code class="p">:</code>&#13;
  <code class="nt">rollingUpdate</code><code class="p">:</code>&#13;
   <code class="nt">maxSurge</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
   <code class="nt">maxUnavailable</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
  <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">RollingUpdate</code>&#13;
 <code class="nt">template</code><code class="p">:</code>&#13;
  <code class="nt">metadata</code><code class="p">:</code>&#13;
   <code class="nt">labels</code><code class="p">:</code>&#13;
    <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">webserver</code>&#13;
  <code class="nt">spec</code><code class="p">:</code>&#13;
   <code class="nt">containers</code><code class="p">:</code>&#13;
   <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
     <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx:1.7.9</code>&#13;
     <code class="nt">ports</code><code class="p">:</code>&#13;
     <code class="p-Indicator">-</code> <code class="nt">containerPort</code><code class="p">:</code> <code class="l-Scalar-Plain">80</code></pre>&#13;
<p>The previous deployment example encompasses many of the characteristics that we have seen in <code>ReplicaSet</code>s and pods.<a contenteditable="false" data-primary="YAML files" data-secondary="metadata" data-tertiary="RollingUpdate YAML file" data-type="indexterm" id="idm45358198346360"/><a contenteditable="false" data-primary="metadata in YAML files" data-secondary="RollingUpdate YAML file" data-type="indexterm" id="idm45358198152744"/><a contenteditable="false" data-primary="annotations" data-secondary="RollingUpdate YAML file" data-type="indexterm" id="idm45358198151368"/> In its metadata it contains labels and annotations. For the deployment, an annotation with <code>deployment.kubernetes.io/​revi⁠sion</code> as the key and <code>1</code> as its value provides information that this is the first revision of the contents in this deployment. Similar to <code>ReplicaSet</code>s, the deployment declares the number of replicas it provides and <a contenteditable="false" data-primary="YAML files" data-secondary="matchLabels field" data-type="indexterm" id="idm45358198148376"/><a contenteditable="false" data-primary="matchLabels field in YAML files" data-type="indexterm" id="idm45358198147000"/>uses a <code>matchLabels</code> field to declare what labels it uses to identify the pods it manages.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
&#13;
<p>Label matching is a very common aspect of Kubernetes API. <a contenteditable="false" data-primary="YAML files" data-secondary="metadata" data-tertiary="labels to organize resources" data-type="indexterm" id="idm45358198144248"/><a contenteditable="false" data-primary="labels to organize resources" data-type="indexterm" id="idm45358198142632"/><a contenteditable="false" data-primary="metadata in YAML files" data-secondary="labels to organize resources" data-type="indexterm" id="idm45358198141512"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="labels in resource queries" data-type="indexterm" id="idm45358198140120"/><a contenteditable="false" data-primary="get command" data-secondary="labels in resource queries" data-type="indexterm" id="idm45358198138712"/>If you need to organize or categorize resources, add descriptive labels that serve as lightweight metadata. You can also query or find resources using the <code>-l</code> option in kubectl like <code>kubectl get</code> or <code>kubectl patch</code>.</p>&#13;
</div>&#13;
<p>Similar to <code>ReplicaSet</code>s, the deployment has both a <code>spec</code> section<a contenteditable="false" data-primary="spec section in YAML files" data-secondary="RollingUpdate deployment" data-type="indexterm" id="idm45358198134200"/><a contenteditable="false" data-primary="YAML files" data-secondary="spec section" data-tertiary="RollingUpdate deployment" data-type="indexterm" id="idm45358198132760"/><a contenteditable="false" data-primary="templates" data-secondary="YAML files" data-tertiary="RollingUpdate deployment" data-type="indexterm" id="idm45358198131096"/><a contenteditable="false" data-primary="pods" data-secondary="replicas" data-tertiary="templates in YAML files" data-type="indexterm" id="idm45358198129432"/><a contenteditable="false" data-primary="replicas" data-secondary="templates in YAML files" data-type="indexterm" id="idm45358198127784"/><a contenteditable="false" data-primary="containers" data-secondary="templates in YAML files" data-type="indexterm" id="idm45358198126408"/><a contenteditable="false" data-primary="YAML files" data-secondary="templates" data-tertiary="RollingUpdate deployment" data-type="indexterm" id="idm45358198125032"/><a contenteditable="false" data-primary="YAML files" data-secondary="templates" data-tertiary="spec section inside" data-type="indexterm" id="idm45358198123368"/> for the deployment and a nested <code>spec</code> section inside a <code>template</code> that is used to describe the containers that comprise the pod replicas managed by this deployment.</p>&#13;
<p>The fields that are new and specific to a deployment resource are <a contenteditable="false" data-primary="strategy field in YAML files" data-secondary="RollingUpdate YAML file" data-type="indexterm" id="idm45358198120104"/><a contenteditable="false" data-primary="YAML files" data-secondary="strategy field" data-tertiary="RollingUpdate YAML file" data-type="indexterm" id="idm45358198118760"/><a contenteditable="false" data-primary="Recreate pod upgrade option" data-secondary="strategy field type field" data-type="indexterm" id="idm45358198117112"/><a contenteditable="false" data-primary="RollingUpdate pod upgrade option" data-secondary="strategy field type field" data-type="indexterm" id="idm45358198115704"/><a contenteditable="false" data-primary="strategy field in YAML files" data-secondary="type field" data-type="indexterm" id="idm45358198114296"/><a contenteditable="false" data-primary="YAML files" data-secondary="strategy field" data-tertiary="type field" data-type="indexterm" id="idm45358198112904"/>the <code>strategy</code> field and its subfields of <code>type</code> and <code>RollingUpdate</code>. The <code>type</code> field is used to declare the deployment strategy being used and can currently be set to <code>Recreate</code> or <span class="keep-together"><code>RollingUpdate</code></span>.</p>&#13;
<p>If the <code>RollingUpdate</code> option is selected, the subfields<a contenteditable="false" data-primary="strategy field in YAML files" data-secondary="maxSurge field" data-type="indexterm" id="idm45358198107000"/><a contenteditable="false" data-primary="maxSurge field in strategy field" data-type="indexterm" id="idm45358198105608"/><a contenteditable="false" data-primary="YAML files" data-secondary="strategy field" data-tertiary="maxSurge field" data-type="indexterm" id="idm45358198104488"/><a contenteditable="false" data-primary="YAML files" data-secondary="strategy field" data-tertiary="maxUnavailable field" data-type="indexterm" id="idm45358198102840"/><a contenteditable="false" data-primary="strategy field in YAML files" data-secondary="maxUnavailable field" data-type="indexterm" id="idm45358198101192"/><a contenteditable="false" data-primary="maxUnavailable field in strategy field" data-type="indexterm" id="idm45358198099800"/><a contenteditable="false" data-primary="RollingUpdate pod upgrade option" data-secondary="strategy field type field" data-tertiary="maxUnavailable RollingUpdate" data-type="indexterm" id="idm45358198098680"/> of <span class="keep-together"><code>maxUnavailable</code></span> and <span class="keep-together"><code>maxSurge</code></span> need to be set as well. The options are used as follows:</p>&#13;
<dl>&#13;
<dt><code>maxSurge</code></dt>&#13;
<dd><p>The <code>maxSurge RollingUpdate</code> option enables <a contenteditable="false" data-primary="RollingUpdate pod upgrade option" data-secondary="strategy field type field" data-tertiary="maxSurge RollingUpdate" data-type="indexterm" id="idm45358198093144"/>extra resources to be allocated during a rollout. The value of this option can be set to a number or a percentage. As a simple example, assume a deployment is supporting three replicas and <code>maxSurge</code> is set to <code>2</code>. In this scenario, there will be a total of five replicas available during the <code>RollingUpdate</code>.</p>&#13;
<p>At the peak of the deployment, there will be three replicas with the old version of the pods running and two with the new version of the pods running. At this point, one of the old version pod replicas will need to be terminated, and then another replica of the new pod version can be created. At this stage, there would be a total of five replicas, three that have the new revision and two that have the old version of the pods. Finally, having reached a point of the correct number of pod replicas being available with the new version, the two pods with the old version can be terminated.</p></dd>&#13;
<dt><code>maxUnavailable</code></dt>&#13;
<dd>This <code>RollingUpdate</code> option is used to declare the number of the deployment replica pods that may be unavailable during the update. It can be set to either a number or a percentage.<a contenteditable="false" data-primary="" data-startref="ch02-rlupd" data-type="indexterm" id="idm45358198087176"/><a contenteditable="false" data-primary="" data-startref="ch02-rlupd2" data-type="indexterm" id="idm45358198085800"/><a contenteditable="false" data-primary="" data-startref="ch02-rlupd3" data-type="indexterm" id="idm45358198084424"/><a contenteditable="false" data-primary="" data-startref="ch02-rlupd4" data-type="indexterm" id="idm45358198083048"/><a contenteditable="false" data-primary="" data-startref="ch02-rlupd5" data-type="indexterm" id="idm45358198081672"/><a contenteditable="false" data-primary="" data-startref="ch02-rlupd6" data-type="indexterm" id="idm45358198080296"/><a contenteditable="false" data-primary="" data-startref="ch02-rlupd7" data-type="indexterm" id="idm45358198040856"/><a contenteditable="false" data-primary="" data-startref="ch02-rlupd8" data-type="indexterm" id="idm45358198039480"/></dd>&#13;
</dl>&#13;
<p>The following YAML example shows a deployment that has been updated to initiate a rollout:<a contenteditable="false" data-primary="YAML files" data-secondary="RollingUpdate pod upgrade option" data-tertiary="updated to initiate rollout" data-type="indexterm" id="idm45358198037576"/><a contenteditable="false" data-primary="RollingUpdate pod upgrade option" data-secondary="YAML file" data-tertiary="updated to initiate rollout" data-type="indexterm" id="idm45358198035944"/></p>&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
 <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
 <code class="nt">labels</code><code class="p">:</code>&#13;
  <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">webserver</code>&#13;
 <code class="nt">annotations</code><code class="p">:</code>&#13;
  <code class="nt">kubernetes.io/change-cause</code><code class="p">:</code> <code class="s">"Update</code><code class="nv"> </code><code class="s">nginx</code><code class="nv"> </code><code class="s">to</code><code class="nv"> </code><code class="s">1.13.10"</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
 <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">3</code>&#13;
 <code class="nt">selector</code><code class="p">:</code>&#13;
  <code class="nt">matchLabels</code><code class="p">:</code>&#13;
   <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">webserver</code>&#13;
 <code class="nt">strategy</code><code class="p">:</code>&#13;
  <code class="nt">rollingUpdate</code><code class="p">:</code>&#13;
   <code class="nt">maxSurge</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
   <code class="nt">maxUnavailable</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
  <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">RollingUpdate</code>&#13;
 <code class="nt">template</code><code class="p">:</code>&#13;
  <code class="nt">metadata</code><code class="p">:</code>&#13;
   <code class="nt">labels</code><code class="p">:</code>&#13;
    <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">webserver</code>&#13;
  <code class="nt">spec</code><code class="p">:</code>&#13;
   <code class="nt">containers</code><code class="p">:</code>&#13;
   <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
     <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx:1.13.10</code>&#13;
     <code class="nt">ports</code><code class="p">:</code>&#13;
     <code class="p-Indicator">-</code> <code class="nt">containerPort</code><code class="p">:</code> <code class="l-Scalar-Plain">80</code></pre>&#13;
<p>Note that a new annotation label with a key of <code>kubernetes.op/change-cause</code> <a contenteditable="false" data-primary="annotations" data-secondary="RollingUpdate YAML file" data-tertiary="updated to initiate rollout" data-type="indexterm" id="idm45358198031944"/><a contenteditable="false" data-primary="metadata in YAML files" data-secondary="RollingUpdate YAML file" data-tertiary="updated to initiate rollout" data-type="indexterm" id="idm45358197948968"/><a contenteditable="false" data-primary="spec section in YAML files" data-secondary="name of image driving new version" data-type="indexterm" id="idm45358197947352"/><a contenteditable="false" data-primary="replicas" data-secondary="name of image in spec section" data-type="indexterm" id="idm45358197945992"/><a contenteditable="false" data-primary="pods" data-secondary="replicas" data-tertiary="name of image in spec section" data-type="indexterm" id="idm45358197944600"/><a contenteditable="false" data-primary="YAML files" data-secondary="spec section" data-tertiary="name of image driving new version" data-type="indexterm" id="idm45358197942936"/>has been added with a value that denotes an update to the version of nginx running in the container. Also notice that the name of the image used by the container in the <code>spec</code> section has changed to <code>nginx:1.13.10</code>. This declaration is what actually drives the pod replicas managed by the deployment to now have a new version of the container images when the upgrade occurs.</p>&#13;
<p>To demonstrate the capabilities of deployments, let’s run the two <a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="YAML files run via" data-tertiary="deployment files" data-type="indexterm" id="idm45358197939432"/><a contenteditable="false" data-primary="YAML files" data-secondary="kubectl to run" data-tertiary="deployment files" data-type="indexterm" id="idm45358197937816"/><a contenteditable="false" data-primary="apply command in deployment YAML files" data-secondary="kubectl" data-type="indexterm" id="idm45358197936168"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="YAML files run via" data-tertiary="apply command" data-type="indexterm" id="idm45358197934776"/><a contenteditable="false" data-primary="deployments" data-secondary="kubectl" data-tertiary="applying deployment files" data-type="indexterm" id="idm45358197933112"/>previous examples. Save the first deployment example as <em>deploymentset.yaml</em> and the second example as <em>deploymentset2.yaml</em>. You can now run the first deployment example by doing the <span class="keep-together">following</span>:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl apply -f deploymentset.yaml</strong></pre>&#13;
<p>After running this command, you should see the following output:</p>&#13;
<pre data-type="programlisting">deployment.apps/nginx created</pre>&#13;
<p>To confirm that your pod replicas managed by the deployment are<a contenteditable="false" data-primary="pods" data-secondary="status" data-tertiary="get pods command" data-type="indexterm" id="idm45358197927352"/><a contenteditable="false" data-primary="get command" data-secondary="get pods for status" data-type="indexterm" id="idm45358197925704"/> actually running, use the <code>kubectl get pods</code> command to verify:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl get pods</strong></pre>&#13;
<p>After running this command, you should see output similar to the following:</p>&#13;
<pre data-type="programlisting">NAME                  READY STATUS  RESTARTS AGE&#13;
nginx-758fbc45d-2znb7 1/1   Running 0        68s&#13;
nginx-758fbc45d-gxf2d 1/1   Running 0        68s&#13;
nginx-758fbc45d-s9f9t 1/1   Running 0        68s</pre>&#13;
<p>With deployments, we have a new command called <code>kubectl get deployments</code> <a contenteditable="false" data-primary="deployments" data-secondary="kubectl" data-tertiary="get deployments for status" data-type="indexterm" id="idm45358197920552"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="get deployments for status" data-type="indexterm" id="idm45358197918808"/><a contenteditable="false" data-primary="get command" data-secondary="get deployments for status" data-type="indexterm" id="idm45358197917400"/>that provides status on the deployments as they update their images. Run this command as follows:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl get deployments</strong></pre>&#13;
<p>After running this command, you should see output similar to the following:</p>&#13;
<pre data-type="programlisting">NAME  READY UP-TO-DATE AVAILABLE AGE&#13;
nginx 3/3   3          3         2m6s</pre>&#13;
<p>Now to make things interesting, let’s update the image in our deployment by applying the second deployment example that we saved in <em>deploymentset2.yaml</em>. Note that we could have just updated the original YAML that we saved in <em>deploymentset.yaml</em> instead of using two separate files. We begin the update by doing the following:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl apply -f deploymentset2.yaml</strong></pre>&#13;
<p>After running this command, you should see the following output:</p>&#13;
<pre data-type="programlisting">deployment.apps/nginx configured</pre>&#13;
<p>Now, when we rerun the <code>kubectl get deployments</code> command, which provides status on the deployments as they update their images, we see a much more interesting result:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl get deployments</strong>&#13;
NAME  READY UP-TO-DATE AVAILABLE AGE&#13;
nginx 2/3   3          2         34s</pre>&#13;
<p>As shown in this output, the deployment currently has three pod replicas running. Three of the pod replicas are up to date, which means they are now running the updated nginx image. In addition, there are three pod replicas in total, and of these three replicas, two are available to handle requests. After some amount of time, when the rolling image update is complete, we reach the desired state of having three updated pod replicas available. We can confirm this by rerunning the <code>kubectl get deployments</code> command and viewing that the output now matches our desired state:</p>&#13;
<pre data-type="programlisting">$ <strong>kubectl get deployments</strong>&#13;
NAME  READY UP-TO-DATE AVAILABLE AGE&#13;
nginx 3/3   3          3         46s</pre>&#13;
<p>To delete the deployment that was just created, run the following command:<a contenteditable="false" data-primary="delete" data-secondary="deployment" data-type="indexterm" id="idm45358197904872"/><a contenteditable="false" data-primary="deployments" data-secondary="kubectl" data-tertiary="deleting deployment" data-type="indexterm" id="idm45358197903304"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="deleting deployment" data-type="indexterm" id="idm45358197901656"/></p>&#13;
<pre data-type="programlisting">$ <strong>kubectl delete deployment nginx</strong></pre>&#13;
<p>You should get the following confirmation that the deployment has been deleted:</p>&#13;
<pre data-type="programlisting">deployment.apps "nginx" deleted</pre>&#13;
<p>Deployments also include commands for pausing rollouts, resuming rollouts, and rolling back the update of an image. The commands are quite helpful if you have some concerns about the new image being rolled out that merits investigation or if you determine that the updated image being rolled out is problematic and needs to be rolled back to a previous version. <a contenteditable="false" data-primary="deployments" data-secondary="kubectl" data-tertiary="documentation online" data-type="indexterm" id="idm45358197897064"/><a contenteditable="false" data-primary="online resources" data-secondary="Kubernetes" data-tertiary="deployment documentation" data-type="indexterm" id="idm45358197895416"/><a contenteditable="false" data-primary="deployments" data-secondary="application deployments" data-tertiary="documentation online" data-type="indexterm" id="idm45358197893752"/>See the <a href="https://oreil.ly/BJ115">Kubernetes Deployment documentation</a> for more information on how to use these deployment <span class="keep-together">capabilities</span>.<a contenteditable="false" data-primary="" data-startref="ch02-dploy" data-type="indexterm" id="idm45358197890600"/><a contenteditable="false" data-primary="" data-startref="ch02-dploy2" data-type="indexterm" id="idm45358197889192"/></p>&#13;
<p>In the next section, we examine the extra steps that are needed to run the previous examples in a secure Kubernetes production-level environment such as OpenShift.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Running the Pod and Deployment Examples in Production on OpenShift" data-type="sect2"><div class="sect2" id="running_the_pod_and_deployment_examples">&#13;
<h2>Running the Pod and Deployment Examples in <span class="keep-together">Production on OpenShift</span></h2>&#13;
<p>The pod and deployment examples presented in the previous sections<a contenteditable="false" data-primary="Kubernetes" data-secondary="fundamentals" data-tertiary="OpenShift environment" data-type="indexterm" id="idm45358197885704"/><a contenteditable="false" data-primary="getting started" data-secondary="fundamentals of Kubernetes" data-tertiary="OpenShift environment" data-type="indexterm" id="idm45358197883592"/><a contenteditable="false" data-primary="pods" data-secondary="deployments" data-tertiary="OpenShift" data-type="indexterm" id="ch02-opnsh4"/><a contenteditable="false" data-primary="deployments" data-secondary="application deployments" data-tertiary="OpenShift environment" data-type="indexterm" id="ch02-opnsh"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="deployment of applications under" data-type="indexterm" id="ch02-opnsh2"/><a contenteditable="false" data-primary="production" data-secondary="deployments in OpenShift" data-type="indexterm" id="ch02-opnsh3"/> are perfect for instructional purposes and for running in a local development environment. When running in production on a highly secure Kubernetes platform such as OpenShift, there are other factors that need to be addressed. First, the nginx container image we used in the previous examples is configured to run as a privileged root user. <a contenteditable="false" data-primary="root access in container image" data-secondary="OpenShift not allowing" data-type="indexterm" id="idm45358197874376"/><a contenteditable="false" data-primary="bash shell within container" data-secondary="OpenShift not allowing root access" data-type="indexterm" id="idm45358197833192"/><a contenteditable="false" data-primary="debugging" data-secondary="interactive shell within container" data-tertiary="OpenShift not allowing root access" data-type="indexterm" id="idm45358197831784"/><a contenteditable="false" data-primary="containers" data-secondary="debugging via interactive shell" data-tertiary="OpenShift not allowing root access" data-type="indexterm" id="idm45358197830104"/><a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="debugging via interactive shell" data-tertiary="OpenShift not allowing root access" data-type="indexterm" id="idm45358197828424"/><a contenteditable="false" data-primary="pods" data-secondary="debugging via interactive shell" data-tertiary="OpenShift not allowing root access" data-type="indexterm" id="idm45358197826728"/><a contenteditable="false" data-primary="security" data-secondary="container image running as root" data-type="indexterm" id="idm45358197825048"/><a contenteditable="false" data-primary="container images" data-secondary="running as root" data-type="indexterm" id="idm45358197823656"/>By default, secure production Kubernetes platforms such as OpenShift are configured to not allow a container image to run as root. This is because running a container image as root increases the risk that malicious code could find a way to cause harm to the host system.<sup><a data-type="noteref" href="ch02.html#ch01fn16" id="ch01fn16-marker">3</a></sup> <a contenteditable="false" data-primary="production" data-secondary="Bitnami nonroot container" data-type="indexterm" id="idm45358197819560"/><a contenteditable="false" data-primary="nginx container from Bitnami" data-type="indexterm" id="idm45358197818168"/><a contenteditable="false" data-primary="Bitnami nonroot container in production" data-type="indexterm" id="idm45358197817048"/>To address this issue, we will replace the nginx container used earlier in this chapter with a version of the image that does not need to run as a privileged root user. The nginx container image from Bitnami runs as a nonroot container and can be used in a production OpenShift environment. The following example is an updated version of our previously created <em>pod.yaml</em>, which uses the Bitnami nonroot nginx container image:<a contenteditable="false" data-primary="YAML files" data-secondary="deployment" data-tertiary="OpenShift" data-type="indexterm" id="idm45358197815000"/><a contenteditable="false" data-primary="Bitnami nonroot container in production" data-secondary="YAML file" data-type="indexterm" id="idm45358197813352"/><a contenteditable="false" data-primary="production" data-secondary="Bitnami nonroot container" data-tertiary="YAML file" data-type="indexterm" id="idm45358197811960"/><a contenteditable="false" data-primary="nginx container from Bitnami" data-secondary="YAML file" data-type="indexterm" id="idm45358197810296"/><a contenteditable="false" data-primary="deployments" data-secondary="application deployments" data-tertiary="OpenShift YAML file" data-type="indexterm" id="idm45358197808904"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="deployment of applications under" data-tertiary="YAML file" data-type="indexterm" id="idm45358197807256"/></p>&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
 <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
 <code class="nt">containers</code><code class="p">:</code>&#13;
 <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
 <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">bitnami/nginx:1.18</code>&#13;
 <code class="nt">ports</code><code class="p">:</code>&#13;
 <code class="p-Indicator">-</code> <code class="nt">containerPort</code><code class="p">:</code> <code class="l-Scalar-Plain">80</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember that all resources are either <em>cluster scoped,</em> <a contenteditable="false" data-primary="scope" data-secondary="resources as cluster versus namespace" data-type="indexterm" id="idm45358197715864"/><a contenteditable="false" data-primary="clusters" data-secondary="cluster-scoped resources" data-type="indexterm" id="idm45358197714552"/><a contenteditable="false" data-primary="namespaces" data-secondary="namespace-scoped resources" data-type="indexterm" id="idm45358197713208"/>meaning that only one resource of that kind can exist within the cluster, or <em>namespace scoped,</em> meaning that the resources are isolated from other similar resources on the cluster. <a contenteditable="false" data-primary="project capability of OpenShift" data-secondary="project synonymous with namespace" data-type="indexterm" id="idm45358197711272"/><a contenteditable="false" data-primary="project synonymous with namespace" data-type="indexterm" id="idm45358197709864"/>Within OpenShift, you may also see the term <em>project,</em> which predated the concept that Red Hat worked with the community to generalize as namespace. <em>Project</em> and <em>namespace</em> are synonymous, and <a contenteditable="false" data-primary="get command" data-secondary="get projects" data-type="indexterm" id="idm45358197707224"/><a contenteditable="false" data-primary="get command" data-secondary="get namespaces" data-type="indexterm" id="idm45358197705816"/>OpenShift will respond to either <code>get projects</code> or <code>get namespaces</code>. <a contenteditable="false" data-primary="namespaces" data-secondary="about" data-type="indexterm" id="idm45358197703448"/>You can think of namespaces as like folders within a filesystem that you use to assign to a group of users who are collaborating on a collection of files. We will talk more about namespaces or projects in <a data-type="xref" href="#openshift_enhancements">“OpenShift Enhancements”</a>.</p>&#13;
</div>&#13;
<p>Another issue with our earlier pod and deployment examples that needs to be addressed is that when they were created, <a contenteditable="false" data-primary="production" data-secondary="namespace isolation of resources" data-type="indexterm" id="idm45358197700056"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="namespace isolation of resources" data-type="indexterm" id="idm45358197698616"/><a contenteditable="false" data-primary="namespaces" data-secondary="isolation of resources" data-type="indexterm" id="idm45358197697224"/>we did not isolate our resources from others by creating a Kubernetes namespace that was specific to our resources. Instead, the earlier examples placed our resources in the Kubernetes default namespace. To encourage proper isolation of applications, secure production Kubernetes platforms such as OpenShift will enforce that your Kubernetes resources are not created in the default namespace but instead are created in a user-defined namespace that provides the required isolation. <a contenteditable="false" data-primary="oc command-line tool" data-secondary="new-project command" data-type="indexterm" id="idm45358197780568"/><a contenteditable="false" data-primary="namespaces" data-secondary="oc new-project command" data-type="indexterm" id="idm45358197779224"/><a contenteditable="false" data-primary="deployments" data-secondary="oc new-project command" data-type="indexterm" id="idm45358197777848"/><a contenteditable="false" data-primary="new-project command in oc" data-type="indexterm" id="idm45358197776472"/><a contenteditable="false" data-primary="project capability of OpenShift" data-secondary="new-project command" data-type="indexterm" id="idm45358197775352"/>To create a properly configured namespace, OpenShift provides the <code>oc new-project</code> command. OpenShift’s project capability is described more thoroughly in <a data-type="xref" href="#openshift_enhancements">“OpenShift Enhancements”</a>. For now, however, we will use the <code>oc new-project</code> command to create a new project called <code>book</code>, which will provide the required isolation to be able to run our pod example. We create our new project by running the following command:<a contenteditable="false" data-primary="YAML files" data-secondary="oc to run" data-tertiary="deployment" data-type="indexterm" id="idm45358197771464"/><a contenteditable="false" data-primary="YAML files" data-secondary="deployment" data-tertiary="OpenShift" data-type="indexterm" id="idm45358197769816"/><a contenteditable="false" data-primary="deployments" data-secondary="application deployments" data-tertiary="OpenShift YAML file" data-type="indexterm" id="idm45358197768168"/><a contenteditable="false" data-primary="apply command in deployment YAML files" data-secondary="oc" data-type="indexterm" id="idm45358197766520"/></p>&#13;
<pre data-type="programlisting">$ <strong>oc new-project book</strong></pre>&#13;
<p>We can then use the <code>oc apply -f</code> command, pass in our updated <em>pod.yaml,</em> and use the <code>-n</code> option to declare that we want our resources created in the <code>book</code> namespace:</p>&#13;
<pre data-type="programlisting">$ <strong>oc apply -f pod.yaml -n book</strong>&#13;
pod/nginx configured</pre>&#13;
<p>Now that we have used a nonroot container image and are no longer using the default namespace, our pod example will be permitted by OpenShift to run in production. We can confirm this is the case by using the <code>oc get pods</code> command:<a contenteditable="false" data-primary="get command" data-secondary="get pods for status" data-type="indexterm" id="idm45358197760056"/></p>&#13;
<pre data-type="programlisting">$ <strong>oc get pods</strong>&#13;
NAME  READY STATUS  RESTARTS AGE&#13;
nginx 1/1   Running 0        63s</pre>&#13;
<p>We can clean up and remove the pod example by using the <code>oc delete pod</code> <span class="keep-together">command</span>:<a contenteditable="false" data-primary="pods" data-secondary="deleting" data-type="indexterm" id="idm45358197755960"/><a contenteditable="false" data-primary="oc command-line tool" data-secondary="deleting pods" data-type="indexterm" id="idm45358197754552"/><a contenteditable="false" data-primary="delete" data-secondary="pod" data-type="indexterm" id="idm45358197753176"/></p>&#13;
<pre data-type="programlisting">$ <strong>oc delete pod nginx</strong>&#13;
pod "nginx" deleted</pre>&#13;
<p>The same techniques we used for the pod example can be applied to the deployment examples as well. Simply update the nginx image that is used in <em>deploymentset.yaml,</em> and make sure to use the <code>book</code> namespace when doing the <code>oc apply</code> command. In the next section, we’ll introduce another fundamental Kubernetes concept called <em>service accounts,</em> which are used to provide authentication for key parts of the Kubernetes platform.<a contenteditable="false" data-primary="" data-startref="ch02-opnsh" data-type="indexterm" id="idm45358202125416"/><a contenteditable="false" data-primary="" data-startref="ch02-opnsh2" data-type="indexterm" id="idm45358202124040"/><a contenteditable="false" data-primary="" data-startref="ch02-opnsh3" data-type="indexterm" id="idm45358202122664"/><a contenteditable="false" data-primary="" data-startref="ch02-opnsh4" data-type="indexterm" id="idm45358202121288"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Service Accounts" data-type="sect2"><div class="sect2" id="service_accounts">&#13;
<h2>Service Accounts</h2>&#13;
<p>When you interact with your cluster, you often represent yourself as a user identity.<a contenteditable="false" data-primary="Kubernetes" data-secondary="fundamentals" data-tertiary="service accounts" data-type="indexterm" id="idm45358202118232"/><a contenteditable="false" data-primary="getting started" data-secondary="fundamentals of Kubernetes" data-tertiary="service accounts" data-type="indexterm" id="idm45358202116488"/><a contenteditable="false" data-primary="service accounts" data-type="indexterm" id="idm45358202114872"/><a contenteditable="false" data-primary="security" data-secondary="service accounts" data-type="indexterm" id="idm45358202113768"/><a contenteditable="false" data-primary="pods" data-secondary="service accounts" data-type="indexterm" id="idm45358202112392"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="service accounts" data-type="indexterm" id="idm45358202111016"/> In the world of Kubernetes, we build intelligence into the system to help it interact with its world. Many times, pods may use the Kubernetes API to interact with other parts of the system or to spawn jobs. When we deploy a pod, it may interact with volume storage, interact with the host filesystem, interact with the host networking, or be sensitive to which operating system user it is given access to use for filesystem access. In most cases, you want to restrict the default permissions for a given pod from doing anything more than the absolute basics. Basically, the less surface area that a pod is given access to in the cluster, the host operating system, the networking layer, and your storage layer, the fewer attack vectors that can be exploited.</p>&#13;
<p>For a pod to interact with the system, it is assigned a service account. Think of this as a functional identity. <a contenteditable="false" data-primary="identities" data-secondary="service accounts" data-type="indexterm" id="idm45358202108200"/><a contenteditable="false" data-primary="kube-apiserver" data-secondary="service accounts" data-type="indexterm" id="idm45358202106824"/><a contenteditable="false" data-primary="authentication" data-secondary="service accounts" data-type="indexterm" id="idm45358202105448"/><a contenteditable="false" data-primary="security" data-secondary="authentication" data-tertiary="service accounts" data-type="indexterm" id="idm45358202104072"/>The service accounts are subjects that can authenticate with kube-apiserver via tokens and are authorized for certain behaviors.</p>&#13;
<p>In some Kubernetes systems, the service account projected into the pod can have identity outside of Kubernetes. <a contenteditable="false" data-primary="Istio service mesh project" data-secondary="identity via service account" data-type="indexterm" id="idm45358202101608"/>A powerful use case is when using the open source <a href="https://istio.io">Istio</a> service mesh project with Kubernetes. In this scenario, the Istio identity is projected via the service account, and this allows one pod to authenticate with another when making service requests. Some cloud providers and other security tools also allow for projection of a service account identity into the pod, and this allows for authentication with these external platforms.</p>&#13;
<p>In OpenShift, service accounts are also used to associate a grouping of <a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="service accounts" data-type="indexterm" id="idm45358202098568"/>security privileges with each pod. The object that OpenShift uses for creating specialized groupings of security privileges is called a <em>security context constraint</em>. In the next section, we provide a more detailed discussion of security context constraints, as well as several other important enhancements that OpenShift delivers to supplement basic Kubernetes.</p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="OpenShift Enhancements" data-type="sect1"><div class="sect1" id="openshift_enhancements">&#13;
<h1>OpenShift Enhancements</h1>&#13;
<p>OpenShift introduces several new concepts that it uses to simplify development and operations. Approaches that are specific to OpenShift include authentication, projects, applications, security contexts, and image streams.</p>&#13;
<section data-pdf-bookmark="Authentication" data-type="sect2"><div class="sect2" id="authentication">&#13;
<h2>Authentication</h2>&#13;
<p>Security is paramount to the OpenShift Kubernetes platform. As a result, <a contenteditable="false" data-primary="identities" data-secondary="OpenShift enhancements" data-type="indexterm" id="idm45358202091880"/><a contenteditable="false" data-primary="getting started" data-secondary="OpenShift enhancements" data-tertiary="authentication" data-type="indexterm" id="idm45358202090504"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="enhancements provided by" data-tertiary="authentication" data-type="indexterm" id="idm45358202088856"/><a contenteditable="false" data-primary="authentication" data-secondary="identities" data-tertiary="OpenShift enhancements" data-type="indexterm" id="idm45358202087240"/><a contenteditable="false" data-primary="security" data-secondary="authentication" data-tertiary="OpenShift enhancements" data-type="indexterm" id="idm45358202085592"/><a contenteditable="false" data-primary="OAuth resource" data-secondary="access tokens" data-type="indexterm" id="idm45358202083944"/><a contenteditable="false" data-primary="X.509 certificates" data-type="indexterm" id="idm45358202082568"/>all users must authenticate with the cluster to be able to access it. OpenShift supports a variety of common authentication methods, including basic authentication with username and password, OAuth access tokens, and X.509 client certificates.<sup><a data-type="noteref" href="ch02.html#ch01fn17" id="ch01fn17-marker">4</a></sup> <a contenteditable="false" data-primary="oc command-line tool" data-secondary="login command" data-type="indexterm" id="idm45358202077528"/><a contenteditable="false" data-primary="login command in oc" data-type="indexterm" id="idm45358202076184"/>OpenShift provides the <code>oc login</code> command for performing authentication, which is run by doing the <span class="keep-together">following</span>:</p>&#13;
<pre data-type="programlisting">$ <strong>oc login</strong></pre>&#13;
<p>In a basic authentication use case, when this command is run, the user will be asked to enter the OpenShift Container Platform server URL and whether or not secure connections are needed, and then the user will be asked to input their username and password. In addition, OpenShift’s configurable OAuth server allows for users to integrate OpenShift identity with external providers, such as LDAP servers.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Projects" data-type="sect2"><div class="sect2" id="projects">&#13;
<h2>Projects</h2>&#13;
<p>Standard Kubernetes provides the concept of <a contenteditable="false" data-primary="identities" data-secondary="project access permissions" data-type="indexterm" id="idm45358202069944"/><a contenteditable="false" data-primary="getting started" data-secondary="OpenShift enhancements" data-tertiary="projects" data-type="indexterm" id="idm45358202068216"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="namespace isolation of resources" data-tertiary="projects" data-type="indexterm" id="idm45358202066568"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="enhancements provided by" data-tertiary="projects" data-type="indexterm" id="idm45358202064952"/><a contenteditable="false" data-primary="project capability of OpenShift" data-secondary="about" data-type="indexterm" id="idm45358202063288"/><a contenteditable="false" data-primary="namespaces" data-secondary="about OpenShift enhancements" data-type="indexterm" id="idm45358202061896"/><a contenteditable="false" data-primary="namespaces" data-secondary="isolation of resources" data-type="indexterm" id="idm45358202060504"/>a <a href="https://oreil.ly/IAiIw"><em>namespace</em></a>, which allows you to define isolation for your Kubernetes resources. Namespaces enable cluster resources to be divided among a large number of users, and the isolation that results from the scoping that they administer keeps users from accidentally using someone else’s resource due to a naming collision. Namespaces are incredibly useful, and <a contenteditable="false" data-primary="annotations" data-secondary="namespace annotations in OpenShift" data-type="indexterm" id="idm45358202057752"/>OpenShift has adapted namespaces for grouping applications. OpenShift accomplishes this by taking a Kubernetes namespace and adding a special standard list of annotations to the namespace. <a contenteditable="false" data-primary="access control" data-secondary="OpenShift project access control" data-type="indexterm" id="idm45358202056056"/><a contenteditable="false" data-primary="project capability of OpenShift" data-secondary="project synonymous with namespace" data-type="indexterm" id="idm45358202054664"/><a contenteditable="false" data-primary="namespaces" data-secondary="project synonymous with namespace" data-type="indexterm" id="idm45358202053256"/><a contenteditable="false" data-primary="namespaces" data-secondary="project synonymous with namespace" data-tertiary="access permissions for projects" data-type="indexterm" id="idm45358202051864"/><a contenteditable="false" data-primary="project capability of OpenShift" data-secondary="project synonymous with namespace" data-tertiary="access permissions for projects" data-type="indexterm" id="idm45358202050184"/><a contenteditable="false" data-primary="authentication" data-secondary="project access permissions" data-type="indexterm" id="idm45358202048488"/><a contenteditable="false" data-primary="security" data-secondary="authentication" data-tertiary="project access permissions" data-type="indexterm" id="idm45358202047096"/><a contenteditable="false" data-primary="access control" data-secondary="role-based" data-tertiary="project access control versus" data-type="indexterm" id="idm45358202045432"/>OpenShift refers to this specific type of namespace as a <em>project.</em> OpenShift uses projects as its mechanism for grouping applications. Projects support the notion of access permissions. This enables you to add one or more users who have access to the project, and role-based access control is used to set the permissions and capabilities that various users have when accessing a project.</p>&#13;
<p>Projects are created using the <code>oc new-project</code> command<a contenteditable="false" data-primary="project capability of OpenShift" data-secondary="new-project command" data-type="indexterm" id="idm45358202042264"/><a contenteditable="false" data-primary="new-project command in oc" data-type="indexterm" id="idm45358202040840"/><a contenteditable="false" data-primary="oc command-line tool" data-secondary="new-project command" data-type="indexterm" id="idm45358202039720"/> and by providing a project name, description, and display name as shown:</p>&#13;
<pre data-type="programlisting">$ <strong>oc new-project firstproject --description=”My first project” </strong>&#13;
<strong>--display-name=”First Project”</strong></pre>&#13;
<p>OpenShift makes it easy to switch between projects by using the <code>oc project</code> command. Here we switch to a different project called <code>secondproject</code>:</p>&#13;
<pre data-type="programlisting">$ <strong>oc project secondproject</strong></pre>&#13;
<p>To view the list of projects that you are authorized to access, you can use the <code>oc get projects</code> command:</p>&#13;
<pre data-type="programlisting">$ <strong>oc get projects</strong></pre>&#13;
<p>For more information on the use of projects, please see <a contenteditable="false" data-primary="project capability of OpenShift" data-secondary="documentation online" data-type="indexterm" id="idm45358202031880"/><a contenteditable="false" data-primary="online resources" data-secondary="OpenShift" data-tertiary="project documentation" data-type="indexterm" id="idm45358202030360"/>the <a href="https://oreil.ly/xXs4d">OpenShift project <span class="keep-together">documentation</span></a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Applications" data-type="sect2"><div class="sect2" id="applications">&#13;
<h2>Applications</h2>&#13;
<p>When using a basic Kubernetes environment, one of the more tedious <a contenteditable="false" data-primary="getting started" data-secondary="OpenShift enhancements" data-tertiary="application creation" data-type="indexterm" id="idm45358202025368"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="enhancements provided by" data-tertiary="application creation" data-type="indexterm" id="idm45358202023640"/><a contenteditable="false" data-primary="container images" data-secondary="application construct in OpenShift" data-type="indexterm" id="idm45358202022024"/><a contenteditable="false" data-primary="applications" data-secondary="application creation in OpenShift" data-type="indexterm" id="idm45358202020632"/>steps that needs to be performed by a cloud native application developer is creating their own container images. Typically, this involves finding the proper base image and creating a <code>Dockerfile</code> with all the necessary commands for taking a base image and adding in the developer’s code to create an assembled image that can be deployed by Kubernetes. OpenShift introduced the <a href="https://oreil.ly/3RpbY">application construct</a> to greatly simplify the process of creating, deploying, and running container images in Kubernetes environments.</p>&#13;
<p>Applications are created using the <code>oc new-app</code> command.<a contenteditable="false" data-primary="oc command-line tool" data-secondary="new-app command" data-type="indexterm" id="idm45358202016264"/><a contenteditable="false" data-primary="new-app command in oc" data-type="indexterm" id="idm45358202014856"/><a contenteditable="false" data-primary="Git repositories" data-secondary="new-app command in oc" data-type="indexterm" id="idm45358202013752"/><a contenteditable="false" data-primary="Docker Hub" data-secondary="new-app command in oc" data-type="indexterm" id="idm45358202012376"/> This command supports a variety of options that enable container images to be built many ways. For example, with the <code>new-app</code> command, application images can be built from local or remote Git repositories, or the application image can be pulled from a Docker Hub or private image registry. In addition, the <code>new-app</code> command supports the creation of application images by inspecting the root directory of the repository to determine the proper way to create the application image. <a contenteditable="false" data-primary="JenkinsFile for application image" data-type="indexterm" id="idm45358202009544"/>For example, the OpenShift <code>new-app</code> command will look for a <code>JenkinsFile</code> in the root directory of your repository, and if it finds this file, it will use it to create the application image. Furthermore, if the <code>new-app</code> command does not find a <code>JenkinsFile</code>, it will attempt to detect the programming language that your application is built in by looking at the files in your repository. If it is able to determine the programming language that was used, the <code>new-app</code> command will locate an acceptable base image for the programming language you are using and will use this to build your application image.</p>&#13;
<p>The following example illustrates using the the <code>oc new-app</code> command to create a new application image from an OpenShift example ruby hello world application:</p>&#13;
<pre data-type="programlisting">$ <strong>oc new-app https://github.com/openshift/ruby-hello-world.git</strong></pre>&#13;
<p>This command will create the application as part of whichever OpenShift project was most recently selected to be the current context for the user. <a contenteditable="false" data-primary="online resources" data-secondary="OpenShift" data-tertiary="application creation documentation" data-type="indexterm" id="idm45358202003288"/>For more information on the application image creation options supported by the <code>new-app</code> command, see the <a href="https://oreil.ly/3RpbY">OpenShift application creation documentation</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Security Context Constraints" data-type="sect2"><div class="sect2" id="security_context_constraints">&#13;
<h2>Security Context Constraints</h2>&#13;
<p>Security is always at the forefront in OpenShift. But with added security can come extra complexity and aggravation.<a contenteditable="false" data-primary="getting started" data-secondary="OpenShift enhancements" data-tertiary="security context constraints" data-type="indexterm" id="idm45358201998104"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="enhancements provided by" data-tertiary="security context constraints" data-type="indexterm" id="ch02-sec"/><a contenteditable="false" data-primary="security" data-secondary="security context constraints" data-type="indexterm" id="ch02-sec2"/><a contenteditable="false" data-primary="pods" data-secondary="security context constraints" data-type="indexterm" id="ch02-sec3"/><a contenteditable="false" data-primary="containers" data-secondary="security" data-tertiary="security context constraints" data-type="indexterm" id="ch02-sec4"/> If enhanced security is used and a container is not given the proper security options, it will fail. If security is relaxed to avoid issues, then vulnerabilities can result. In an effort to enable users to leverage enhanced security with less aggravation, OpenShift includes a security construct called <em>security context constraints</em>.</p>&#13;
<p>The security context constraints identify a set of security privileges that a pod’s container is guaranteed to execute with. Thus, before the pod’s container begins execution, it knows what security privileges it will get. The following is a list of the common security privilege options that are provided by security context constraints:</p>&#13;
<dl>&#13;
<dt>Allow pods to run privileged containers</dt>&#13;
<dd>Security context constraints can declare if a pod is permitted to run privileged containers or if it can run only nonprivileged containers.</dd>&#13;
<dt>Require Security-Enhanced Linux (SELinux)</dt>&#13;
<dd><a href="https://oreil.ly/SlHNy">SELinux</a> is a <a contenteditable="false" data-primary="Security-Enhanced Linux (SELinux)" data-type="indexterm" id="idm45358201984616"/><a contenteditable="false" data-primary="security" data-secondary="Security-Enhanced Linux (SELinux)" data-type="indexterm" id="idm45358201983416"/><a contenteditable="false" data-primary="Linux operating system" data-secondary="Security-Enhanced Linux" data-type="indexterm" id="idm45358201982024"/>security architecture for Linux that defines access controls for applications, processes, and files on a system. SELinux presents extra protections beyond what standard Linux uses. Security context constraints provide the <code>MustRunAs</code> attribute value for declaring if SELinux must be run by a pod’s container and a <code>RunAsAny</code> attribute value for declaring if the pod’s container can run either standard Linux or SELinux.</dd>&#13;
<dt>Run the pod’s container as a specific user or as nonroot</dt>&#13;
<dd>Containers running as root have a bigger vulnerability footprint than <a contenteditable="false" data-primary="security" data-secondary="container image running as root" data-tertiary="security context constraints" data-type="indexterm" id="idm45358201978104"/><a contenteditable="false" data-primary="container images" data-secondary="running as root" data-tertiary="security context constraints" data-type="indexterm" id="idm45358201976392"/><a contenteditable="false" data-primary="root access in container image" data-secondary="OpenShift not allowing" data-tertiary="security context constraints" data-type="indexterm" id="idm45358201974728"/><a contenteditable="false" data-primary="MustRunAsNonRoot attribute" data-type="indexterm" id="idm45358201973048"/><a contenteditable="false" data-primary="RunAsAny attribute" data-type="indexterm" id="idm45358201971928"/><a contenteditable="false" data-primary="MustRunAsRange attribute" data-type="indexterm" id="idm45358201970824"/>containers running as a nonroot. Security context constraints provide a <code>MustRunAsNonRoot</code> attribute value to denote that a Pod’s container is not permitted to run as root. Additionally, the security context constraints use a <code>RunAsAny</code> attribute value that permits a pod’s container to run as either a root or nonroot user. Finally, the security context constraint administers a <code>MustRunAsRange</code> attribute value that allows a pod’s container to run if the user ID is within a specific range of user IDs.</dd>&#13;
<dt>Allow the pod’s container access to File System Group block storage</dt>&#13;
<dd>Security context constraints can be used to limit the block storage<a contenteditable="false" data-primary="storage volumes" data-secondary="File System Group block storage" data-type="indexterm" id="idm45358201967096"/> that a pod’s container has access to. Block storage portions are identified through the use of a File System Group identifier. Security context constraints provide a <code>RunAsAny</code> attribute value that permits a pod’s container to access any File System Group of block storage, as well as a <code>MustRunAs</code> attribute value, which is used to denote that the pod’s block storage must be in the range of File System Group IDs listed in the security context constraint.</dd>&#13;
</dl>&#13;
<p>OpenShift includes several built-in security context constraint profiles that can be reused.<a contenteditable="false" data-primary="pods" data-secondary="security context constraints" data-tertiary="profiles" data-type="indexterm" id="idm45358201963592"/><a contenteditable="false" data-primary="security" data-secondary="security context constraints of OpenShift" data-tertiary="profiles" data-type="indexterm" id="idm45358201961976"/> To view the list of projects that you are authorized to access, you can use the <code>oc get scc</code> command:<a contenteditable="false" data-primary="get command" data-secondary="get scc for project access authorization" data-type="indexterm" id="idm45358201959592"/><a contenteditable="false" data-primary="project capability of OpenShift" data-secondary="access authorization via get scc" data-type="indexterm" id="idm45358201958152"/><a contenteditable="false" data-primary="oc command-line tool" data-secondary="security context constraint profiles" data-type="indexterm" id="idm45358201956744"/></p>&#13;
<pre data-type="programlisting">$ <strong>oc get scc</strong>&#13;
 &#13;
NAME             AGE&#13;
anyuid           182d&#13;
hostaccess       182d&#13;
hostmount-anyuid 182d&#13;
hostnetwork      182d&#13;
node-exporter    182d&#13;
nonroot          182d&#13;
privileged       182d&#13;
restricted       182d</pre>&#13;
<p>As shown, OpenShift contributes security context constraint profiles for common scenarios, such as privileged, restricted, or running as nonroot. <a contenteditable="false" data-primary="oc command-line tool" data-secondary="security context constraint profiles" data-tertiary="describe scc command" data-type="indexterm" id="idm45358201953432"/><a contenteditable="false" data-primary="describe command in oc" data-secondary="security context constraint" data-type="indexterm" id="idm45358201951768"/><a contenteditable="false" data-primary="oc command-line tool" data-secondary="describe command" data-tertiary="security context constraint" data-type="indexterm" id="idm45358201950376"/>To see all the individual capability settings for the security constraint profile, use the <code>oc describe scc</code> command and pass in the name of the profile that you want more details on. For example, if you wanted more details on how powerful the privileged constraint profile is, you would invoke the <code>oc describe scc</code> command as follows:<a contenteditable="false" data-primary="privileged profile of security context constraint" data-type="indexterm" id="idm45358201947432"/></p>&#13;
<pre data-type="programlisting">$ <strong>oc describe scc privileged</strong></pre>&#13;
<p>Running this command will list a large number of constraint attributes associated with this profile. Here are a few of the more interesting ones:</p>&#13;
<pre data-type="programlisting">Settings:&#13;
 Allow Privileged: true&#13;
 Allow Privilege Escalation: true&#13;
 Default Add Capabilities: &lt;none&gt;&#13;
 Required Drop Capabilities: &lt;none&gt;&#13;
 Allowed Capabilities: *&#13;
 Allowed Seccomp Profiles: *&#13;
 Allowed Volume Types: *&#13;
 Allowed Flexvolumes: &lt;all&gt;&#13;
 Allowed Unsafe Sysctls: *&#13;
 Forbidden Sysctls: &lt;none&gt;&#13;
 Allow Host Network: true&#13;
 Allow Host Ports: true&#13;
 Allow Host PID: true&#13;
 Allow Host IPC: true&#13;
 Read Only Root Filesystem: false&#13;
 Run As User Strategy: RunAsAny&#13;
 SELinux Context Strategy: RunAsAny&#13;
 FSGroup Strategy: RunAsAny&#13;
 Supplemental Groups Strategy: RunAsAny</pre>&#13;
<p>For comparison purposes, we can run the same command for the restricted profile.<a contenteditable="false" data-primary="restricted profile of security context constraint" data-type="indexterm" id="idm45358201943032"/> As shown in the following output, the constraint attribute values are much more restrictive than those in the privileged profile:</p>&#13;
<pre data-type="programlisting">$ <strong>oc describe scc restricted</strong>&#13;
 &#13;
Settings:&#13;
 Allow Privileged: false&#13;
 Allow Privilege Escalation: true&#13;
 Default Add Capabilities: &lt;none&gt;&#13;
 Required Drop Capabilities: KILL,MKNOD,SETUID,SETGID&#13;
 Allowed Capabilities: &lt;none&gt;&#13;
 Allowed Seccomp Profiles: &lt;none&gt;&#13;
 Allowed Volume Types: configMap,downwardAPI,emptyDir,persistentVolumeClaim,&#13;
projected,secret&#13;
 Allowed Flexvolumes: &lt;all&gt;&#13;
 Allowed Unsafe Sysctls: &lt;none&gt;&#13;
 Forbidden Sysctls: &lt;none&gt;&#13;
 Allow Host Network: false&#13;
 Allow Host Ports: false&#13;
 Allow Host PID: false&#13;
 Allow Host IPC: false&#13;
 Read Only Root Filesystem: false&#13;
 Run As User Strategy: MustRunAsRange&#13;
 SELinux Context Strategy: MustRunAs&#13;
 FSGroup Strategy: MustRunAs&#13;
 Supplemental Groups Strategy: RunAsAny</pre>&#13;
<p>The key point here is that security context constraint profiles are able to group and encapsulate large groups of capability attributes and ensure that all the attributes are met before a pod is permitted to execute. This reduces the chance of improperly setting the capability attributes and reduces the chance of an unexpected pod failure due to an incorrect security setting.</p>&#13;
<p>Security context constraint profiles are associated with pods by using the Kubernetes service account object. For more information on the use of security context constraints, see the <a href="https://oreil.ly/W41Sq">OpenShift security context constraints documentation</a>.<a contenteditable="false" data-primary="" data-startref="ch02-sec" data-type="indexterm" id="idm45358201937560"/><a contenteditable="false" data-primary="" data-startref="ch02-sec2" data-type="indexterm" id="idm45358201936184"/><a contenteditable="false" data-primary="" data-startref="ch02-sec3" data-type="indexterm" id="idm45358201934808"/><a contenteditable="false" data-primary="" data-startref="ch02-sec4" data-type="indexterm" id="idm45358201933432"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Image Streams" data-type="sect2"><div class="sect2" id="image_streams">&#13;
<h2>Image Streams</h2>&#13;
<p>One of the key steps in deploying a cloud native application is retrieving the <a contenteditable="false" data-primary="getting started" data-secondary="OpenShift enhancements" data-tertiary="image streams" data-type="indexterm" id="idm45358201930088"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="enhancements provided by" data-tertiary="image streams" data-type="indexterm" id="idm45358201928344"/><a contenteditable="false" data-primary="image streams in OpenShift" data-type="indexterm" id="idm45358201926680"/><a contenteditable="false" data-primary="container images" data-secondary="image streams in OpenShift" data-type="indexterm" id="idm45358201925560"/><a contenteditable="false" data-primary="production" data-secondary="container application image from repository" data-type="indexterm" id="idm45358201924168"/><a contenteditable="false" data-primary="deployments" data-secondary="container application image from repository" data-type="indexterm" id="idm45358201922760"/>correct container application image from a repository. When running in production, there are several possible pitfalls with this retrieval process. First, container images are retrieved by a tag identifier, but it is possible that container images can be overwritten, and thus the image that is referenced by the tag can change. If this change goes unnoticed, it could result in introducing unexpected errors into the cloud native application that is deployed. Second, when running in production, the image retrieval process also needs to be supplemented with support for automating builds and deployments, and many image repositories are limited in their ability to support this automation. <a contenteditable="false" data-primary="tags" data-secondary="container images" data-type="indexterm" id="idm45358201920520"/>Third, in some cases a container image needs to have multiple tags associated with it because the container image is used for different purposes in different environments. Unfortunately, many image repositories do not support the ability to associate multiple tags with a container application image.</p>&#13;
<p>To address all of these issues, OpenShift introduced the concept of <em>image streams</em>.<sup><a data-type="noteref" href="ch02.html#ch01fn18" id="ch01fn18-marker">5</a></sup> <a contenteditable="false" data-primary="tags" data-secondary="container images" data-tertiary="image streams" data-type="indexterm" id="idm45358201912744"/>Image streams are intended to provide a more stable pointer for tagged images. The image stream maintains an SHA-256 secure hash function to the image it points to in order to ensure that the image is not mistakenly changed. Image streams also support multiple tags for images to better support using them in multiple environments. <a contenteditable="false" data-primary="builds" data-secondary="image stream update triggering" data-type="indexterm" id="idm45358201910616"/><a contenteditable="false" data-primary="deployments" data-secondary="triggered by image stream updates" data-type="indexterm" id="idm45358201909176"/>In addition, image streams include triggers that enable builds and deployments to be started automatically when the image stream is updated. Furthermore, image streams can not only reference container images from external repositories, but can also be scheduled to periodically reimport the external container image to ensure that they always have the most recently updated copy of the container image they are referencing in the external repository.</p>&#13;
<p>Creating and updating image streams is relatively straightforward. The <code>oc import-image</code> command<a contenteditable="false" data-primary="oc command-line tool" data-secondary="import-image command" data-type="indexterm" id="idm45358201906056"/><a contenteditable="false" data-primary="import-image command for image stream" data-type="indexterm" id="idm45358201904648"/><a contenteditable="false" data-primary="image streams in OpenShift" data-secondary="import-image command to create" data-type="indexterm" id="idm45358201903576"/> is used to create an image stream. In the following example, the <code>oc import-image</code> command is used to create an initial image stream called <code>nginx</code> with an initial image stream tag for the imported image that has the value <code>1.12</code>:</p>&#13;
<pre data-type="programlisting">$ <strong>oc import-image nginx:1.12 --from=centos/nginx-112-centos7 --confirm</strong></pre>&#13;
<p>As shown in this example, the initial container image that is being imported into the <code>nginx</code> image stream is the image that is located at <code>centos/nginx-112-centos7</code>. The <code>confirm</code> option states that the image stream should be created if it doesn’t already exist.</p>&#13;
<p>Once the image stream is created, we can examine<a contenteditable="false" data-primary="oc command-line tool" data-secondary="describe command" data-tertiary="image stream" data-type="indexterm" id="idm45358201897208"/><a contenteditable="false" data-primary="image streams in OpenShift" data-secondary="oc describe command" data-type="indexterm" id="idm45358201895560"/><a contenteditable="false" data-primary="describe command in oc" data-secondary="image stream" data-type="indexterm" id="idm45358201894216"/> it using the <code>oc describe</code> command. In the following example, the <code>is</code> value is the short name for an input stream resource. The specific input stream that we want described is the one with the name <code>nginx</code>:</p>&#13;
<pre data-type="programlisting">$ <strong>oc describe is/nginx</strong></pre>&#13;
<p>The output from this command looks like this:</p>&#13;
<pre data-type="programlisting">&#13;
Name: nginx&#13;
Namespace: default&#13;
Created: 52 seconds ago&#13;
Labels: &lt;none&gt;&#13;
Annotations: openshift.io/image.dockerRepositoryCheck=2020-06-12T20:16:15Z&#13;
Image Repository: default-route-openshift-image-registry.apps-&#13;
crc.testing/default/nginx&#13;
Image Lookup: local=false&#13;
Unique Images: 1&#13;
Tags: 1&#13;
 &#13;
1.12&#13;
 tagged from centos/nginx-112-centos7&#13;
 &#13;
*centos/nginx-112-&#13;
centos7@sha256:af171c38298e64664a9f999194480ce7e392858e773904df22f7585a1731ad0d</pre>&#13;
<p>We can add an extra tag for this image by using the <code>oc tag</code> command.<a contenteditable="false" data-primary="oc command-line tool" data-secondary="tag command" data-type="indexterm" id="idm45358201887704"/><a contenteditable="false" data-primary="tags" data-secondary="tag command in oc" data-type="indexterm" id="idm45358201886296"/> We add an <code>nginx:latest</code> tag to the existing <code>nginx:1.12</code> tag by doing the following:</p>&#13;
<pre data-type="programlisting">$ <strong>oc tag nginx:1.12 nginx:latest</strong></pre>&#13;
<p>Finally, we can tag an image from an external repository and schedule this image to be periodically reimported by calling the <code>oc tag</code> command. As shown in the following example, we reference the image from the external repository, associate it with an image stream tag, and then add the scheduled option to denote that the tag should be periodically updated:<sup><a data-type="noteref" href="ch02.html#ch01fn19" id="ch01fn19-marker">6</a></sup></p>&#13;
<pre data-type="programlisting">$ <strong>oc tag docker.io/nginx:1.14 nginx:1.14 --scheduled</strong></pre>&#13;
<p>For more information on the use of image streams, <a contenteditable="false" data-primary="image streams in OpenShift" data-secondary="documentation online" data-type="indexterm" id="idm45358201877912"/><a contenteditable="false" data-primary="online resources" data-secondary="OpenShift" data-tertiary="image streams documentation" data-type="indexterm" id="idm45358201876472"/>please see the documentation on <a href="https://oreil.ly/YMfdZ">managing image streams</a>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Kubernetes and OpenShift Advanced Topics" data-type="sect1"><div class="sect1" id="kubernetes_and_openshift_advanced_topics">&#13;
<h1>Kubernetes and OpenShift Advanced Topics</h1>&#13;
<p>Several advanced concepts are frequently used when running Kubernetes or OpenShift in production.<a contenteditable="false" data-primary="getting started" data-secondary="advanced topics" data-type="indexterm" id="ch02-adv"/> In this section, we discuss these advanced topics, including webhooks, admission controllers, role-based access control, and operators.</p>&#13;
<section data-pdf-bookmark="Webhooks" data-type="sect2"><div class="sect2" id="webhooks">&#13;
<h2>Webhooks</h2>&#13;
<p>A <em>webhook</em> is an HTTP callback.<sup><a data-type="noteref" href="ch02.html#ch01fn20" id="ch01fn20-marker">7</a></sup> Essentially, a webhook enables information to be pushed to an external entity when an interesting event is occurring. Typically, an HTTP Post operation is used to push the event information, and the event information is most commonly represented as a JSON payload. In Kubernetes, webhooks are used for a variety of security-related operations. For example, Kubernetes can use a webhook to query an external service to determine if a user has the correct privileges to perform a specific operation.</p>&#13;
<p>Webhooks are also used by OpenShift as <a href="https://oreil.ly/bmfyW">a mechanism for triggering builds</a>.<a contenteditable="false" data-primary="builds" data-secondary="webhooks triggering" data-type="indexterm" id="idm45358201861944"/><a contenteditable="false" data-primary="GitHub" data-secondary="webhooks triggering builds" data-type="indexterm" id="idm45358201860568"/><a contenteditable="false" data-primary="deployments" data-secondary="triggered by webhooks" data-type="indexterm" id="idm45358201859128"/> With webhooks, you can configure your GitHub repository to send an alert whenever there is a change in the repository. This alert can be used to kick off a new build and, if the build succeeds, perform a deployment as well.</p>&#13;
<p>Webhooks are also used heavily by Kubernetes admission controllers, which are described in the next section. For more information on the use of webhooks in Kubernetes, see <a href="https://oreil.ly/Aiw7t">Webhook Mode in the Kubernetes documentation</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Admission Controllers" data-type="sect2"><div class="sect2" id="admission_controllers">&#13;
<h2>Admission Controllers</h2>&#13;
<p>The key to keeping your Kubernetes platform secure is to protect it from <a contenteditable="false" data-primary="resource management" data-secondary="admission controllers" data-type="indexterm" id="idm45358201854296"/><a contenteditable="false" data-primary="admission controllers" data-secondary="about" data-type="indexterm" id="idm45358201852920"/><a contenteditable="false" data-primary="security" data-secondary="admission controllers" data-type="indexterm" id="idm45358201851544"/><a contenteditable="false" data-primary="resource requests" data-secondary="admission controllers and" data-type="indexterm" id="idm45358201850168"/>requests that can cause harm. <em>Admission controllers</em> are one of the mechanisms that Kubernetes uses to protect the platform from harmful requests. In some cases, an admission controller will prevent a request from creating the Kubernetes object at all. In other cases, the admission controller will allow the request to be processed, but it will modify the request to make it safer. As an example, if a request comes in to start a pod and the request does not specify whether the pod should be started in privileged or nonprivileged mode, the admission controller could change the request such that in this situation the pod is requested to be started in nonprivileged mode.</p>&#13;
<p>A number of admission controllers are embedded in the kube-controller-manager,<a contenteditable="false" data-primary="kube-controller-manager" data-secondary="admission controllers" data-type="indexterm" id="idm45358201847224"/> and many are enabled in Kubernetes by default to keep the Kubernetes platform secure. In some cases, the admin needs enforcement beyond the scope of the included admission controllers. Kubernetes allows the admin to add additional admission controllers via registration of webhooks to process requests on Kubernetes objects. We will go into more detail regarding admission controllers in <a data-type="xref" href="ch03.html#advanced_resource_management">Chapter 3</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Role-Based Access Control" data-type="sect2"><div class="sect2" id="role_based_access_control">&#13;
<h2>Role-Based Access Control</h2>&#13;
<p>Authorization in Kubernetes is integrated into the platform. Kubernetes <a contenteditable="false" data-primary="role-based access control (RBAC)" data-secondary="authorization in Kubernetes" data-type="indexterm" id="idm45358201842088"/><a contenteditable="false" data-primary="authorization in Kubernetes" data-seealso="role-based access control" data-type="indexterm" id="idm45358201840680"/><a contenteditable="false" data-primary="access control" data-secondary="role-based" data-tertiary="authorization in Kubernetes" data-type="indexterm" id="idm45358201839272"/><a contenteditable="false" data-primary="security" data-secondary="role-based access control" data-type="indexterm" id="idm45358201837608"/><a contenteditable="false" data-primary="ClusterRole object" data-type="indexterm" id="idm45358201836216"/><a contenteditable="false" data-primary="Role object" data-type="indexterm" id="idm45358201835112"/>authorization uses a role-based access control (RBAC) model and provides a fully featured authorization platform that allows operators to define various roles via the Kubernetes objects <code>ClusterRole</code> and <code>Role</code> and to bind them to users and groups using <code>Cluster​Ro⁠leBinding</code> and <code>RoleBinding</code>. <a contenteditable="false" data-primary="RBAC" data-see="role-based access control" data-type="indexterm" id="idm45358201831912"/>Think of RBAC as a way of setting permissions on a file system, but in the case of Kubernetes, it’s setting permissions on the Kubernetes object model. We’ll cover the details of how to use RBAC and how best to build a multitenancy model around it in <a data-type="xref" href="ch04.html#single_cluster_availability">Chapter 4</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Operators" data-type="sect2"><div class="sect2" id="operators">&#13;
<h2>Operators</h2>&#13;
<p>Kubernetes has built-in abstractions like deployments that are extremely well-suited stateless applications. <a contenteditable="false" data-primary="operators" data-secondary="operator construct" data-tertiary="operators explained" data-type="indexterm" id="idm45358201826968"/><a contenteditable="false" data-primary="operators" data-secondary="about operators" data-type="indexterm" id="idm45358201825320"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="declarative programming model" data-type="indexterm" id="idm45358201823944"/><a contenteditable="false" data-primary="operators" data-secondary="custom resource creation" data-type="indexterm" id="idm45358201822552"/><a contenteditable="false" data-primary="custom resource definition (CRD)" data-secondary="operators for custom resource creation" data-type="indexterm" id="idm45358201821160"/>In addition, Kubernetes has a very elegant design based on control loops that enables it to support a declarative programming model and allows the platform to execute robustly at large scale even when failures are common.</p>&#13;
<p>To support complex stateful applications, Kubernetes needed an extensibility model that would enable users to add custom resources and perform life-cycle management for those resources. Additionally, it would be ideal if the extensibility model could also support the control loop architecture that is used extensively inside the Kubernetes platform. Kubernetes includes <a contenteditable="false" data-primary="operators" data-secondary="custom resource creation" data-tertiary="documentation online" data-type="indexterm" id="idm45358201818584"/>the <a href="https://oreil.ly/OujZb">operator pattern</a>, which provides an extensibility model for custom resources that meet all of these requirements.</p>&#13;
<p>Operators support the creation of custom resources. What this means is that <a contenteditable="false" data-primary="etcd" data-secondary="custom resources" data-type="indexterm" id="idm45358201815544"/>you can define a new resource type in Kubernetes by creating a custom resource definition, and this new resource can be stored in the Kubernetes etcd database just like any standard Kubernetes resource. <a contenteditable="false" data-primary="controllers" data-secondary="custom controllers" data-type="indexterm" id="idm45358201813720"/>Additionally, you can create a custom controller for your resource that performs the same type of control loop behavior that the standard Kubernetes controllers perform. The custom controller can then monitor the actual state of your stateful application, compare it to the desired state, and then take actions to attempt to achieve the desired state for the application. For example, let’s say you create an operator for a special type of database, which is a stateful application. The operator and its controller can make sure that the actual number of replicas of the database that are running matches the desired number of copies. Furthermore, since the operator has a custom controller, any custom life-cycle management code that is needed for starting up new copies of the database or updating existing copies of the database can be added to the controller.</p>&#13;
<p>The operator pattern is well-designed, and a key advantage is that it is seamless. <a contenteditable="false" data-primary="kubectl command-line tool" data-secondary="custom resource management" data-type="indexterm" id="idm45358201810696"/>The custom resources associated with an operator are managed using the <code>kubectl</code> command-line tool and look just like a standard Kubernetes resource from a management perspective. To ease the creation of operators, an operator software development kit exists to generate the custom resource definitions and a large portion of the controller code required to run the operator’s control loop. As a result of the clean architectural design of the operator framework and also due to extensive tooling available, creating new operators as the means of adding stateful applications continues to grow in popularity. <a contenteditable="false" data-primary="operators" data-secondary="OperatorHub" data-type="indexterm" id="idm45358201808168"/><a contenteditable="false" data-primary="OperatorHub" data-type="indexterm" id="idm45358201806792"/><a contenteditable="false" data-primary="operators" data-secondary="custom resource creation" data-tertiary="OperatorHub" data-type="indexterm" id="idm45358201805688"/>There is now an <a href="https://operatorhub.io">Operator Hub</a> that hosts a large number of existing and reusable operators for managing a variety of applications for the Kubernetes platform. We will go into more detail about operators and their consumption within Kubernetes in <a data-type="xref" href="ch07.html#multicluster_policy_configuration">Chapter 7</a>.<a contenteditable="false" data-primary="" data-startref="ch02-adv" data-type="indexterm" id="idm45358201801960"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45358201800584">&#13;
<h1>Summary</h1>&#13;
<p>In this chapter, we covered a wide range of topics to give you a broad foundation and solid introduction to Kubernetes and OpenShift. We touched upon several topics that are critical for running in production, and we will explore many of these topics in greater detail in subsequent chapters of this book. In addition, this chapter helps to illustrate how the Kubernetes and OpenShift ecosystems have matured into platforms that provide a lot of enterprise-level functionality and flexibility. In <a data-type="xref" href="ch03.html#advanced_resource_management">Chapter 3</a>, we cover a crucial production topic: advanced management of Kubernetes resources while running in production.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch01fn14"><sup><a href="ch02.html#ch01fn14-marker">1</a></sup> Lantao Liu and Mike Brown, “Kubernetes Containerd Integration Goes GA,” Kubernetes Blog (May 24, 2018), <a href="https://oreil.ly/SlHmh"><em class="hyperlink">https://oreil.ly/SlHmh</em></a>.</p><p data-type="footnote" id="ch01fn15"><sup><a href="ch02.html#ch01fn15-marker">2</a></sup> Brendan Burns et al., “Borg, Omega, and Kubernetes: Lessons Learned from Three Container-Management Systems over a Decade,” <em>ACM Queue</em> 14 (2016): 70–93, <a href="http://bit.ly/2vIrL4S"><em class="hyperlink">http://bit.ly/2vIrL4S</em></a>.</p><p data-type="footnote" id="ch01fn16"><sup><a href="ch02.html#ch01fn16-marker">3</a></sup> Tomas Pizarro Moreno, “Running Non-root Containers on OpenShift,” Bitnami Engineering (October 27, 2017), <a href="https://oreil.ly/pxSGf"><em class="hyperlink">https://oreil.ly/pxSGf</em></a>.</p><p data-type="footnote" id="ch01fn17"><sup><a href="ch02.html#ch01fn17-marker">4</a></sup> The<a contenteditable="false" data-primary="online resources" data-secondary="OpenShift" data-tertiary="authentication documentation" data-type="indexterm" id="idm45358202080248"/> <a href="https://oreil.ly/23ON5">OpenShift authentication documentation</a> provides more detail on supported authentication methods.</p><p data-type="footnote" id="ch01fn18"><sup><a href="ch02.html#ch01fn18-marker">5</a></sup> The <a href="https://oreil.ly/T7vSF">documentation on image streams</a> <a contenteditable="false" data-primary="image streams in OpenShift" data-secondary="documentation online" data-type="indexterm" id="idm45358201916104"/><a contenteditable="false" data-primary="online resources" data-secondary="OpenShift" data-tertiary="image streams documentation" data-type="indexterm" id="idm45358201914664"/>provides more information.</p><p data-type="footnote" id="ch01fn19"><sup><a href="ch02.html#ch01fn19-marker">6</a></sup> Maciej Szulik, “How to Simplify Container Image Management in Kubernetes with OpenShift Image Streams,” Red Hat OpenShift Blog (March 23, 2017), <a href="https://oreil.ly/JEV4u"><em class="hyperlink">https://oreil.ly/JEV4u</em></a>.</p><p data-type="footnote" id="ch01fn20"><sup><a href="ch02.html#ch01fn20-marker">7</a></sup> Wikipedia provides an <a href="https://oreil.ly/PLH43">overview of webhooks</a>.<a contenteditable="false" data-primary="webhooks" data-type="indexterm" id="idm45358201866168"/><a contenteditable="false" data-primary="security" data-secondary="webhooks" data-type="indexterm" id="idm45358201865032"/></p></div></div></section></body></html>