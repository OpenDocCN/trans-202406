["```\nconst https = require('https')\n\nmodule.exports = twitterOptions => {\n\n return {\n\n  search: async (query, count) => {\n    // TODO\n  }\n }\n\n}\n```", "```\nconst twitter = require('./lib/twitter')({\n  consumerApiKey: credentials.twitter.consumerApiKey,\n  apiSecretKey: credentials.twitter.apiSecretKey,\n})\n\nconst tweets = await twitter.search('#Oregon #travel', 10)\n// tweets will be in result.statuses\n```", "```\nconst https = require('https')\n\nmodule.exports = function(twitterOptions) {\n\n  // this variable will be invisible outside of this module\n  let accessToken = null\n\n  // this function will be invisible outside of this module\n  const getAccessToken = async () => {\n    if(accessToken) return accessToken\n    // TODO: get access token\n  }\n\n  return {\n    search: async (query, count) => {\n      // TODO\n    }\n  }\n\n}\n```", "```\nconst getAccessToken = async () => {\n  if(accessToken) return accessToken\n\n  const bearerToken = Buffer(\n    encodeURIComponent(twitterOptions.consumerApiKey) + ':' +\n    encodeURIComponent(twitterOptions.apiSecretKey)\n  ).toString('base64')\n\n  const options = {\n    hostname: 'api.twitter.com',\n    port: 443,\n    method: 'POST',\n    path: '/oauth2/token?grant_type=client_credentials',\n    headers: {\n      'Authorization': 'Basic ' + bearerToken,\n    },\n  }\n\n  return new Promise((resolve, reject) =>\n    https.request(options, res => {\n      let data = ''\n      res.on('data', chunk => data += chunk)\n      res.on('end', () => {\n        const auth = JSON.parse(data)\n        if(auth.token_type !== 'bearer')\n          return reject(new Error('Twitter auth failed.'))\n        accessToken = auth.access_token\n        return resolve(accessToken)\n      })\n    }).end()\n  )\n}\n```", "```\nsearch: async (query, count) => {\n  const accessToken = await getAccessToken()\n  const options = {\n    hostname: 'api.twitter.com',\n    port: 443,\n    method: 'GET',\n    path: '/1.1/search/tweets.json?q=' +\n      encodeURIComponent(query) +\n      '&count=' + (count || 10),\n    headers: {\n      'Authorization': 'Bearer ' + accessToken,\n    },\n  }\n  return new Promise((resolve, reject) =>\n    https.request(options, res => {\n      let data = ''\n      res.on('data', chunk => data += chunk)\n      res.on('end', () => resolve(JSON.parse(data)))\n    }).end()\n  )\n},\n```", "```\nembed: async (url, options = {}) => {\n  options.url = url\n  const accessToken = await getAccessToken()\n  const requestOptions = {\n    hostname: 'api.twitter.com',\n    port: 443,\n    method: 'GET',\n    path: '/1.1/statuses/oembed.json?' + qs.stringify(options),\n    headers: {\n      'Authorization': 'Bearer ' + accessToken,\n    },\n  }\n  return new Promise((resolve, reject) =>\n    https.request(requestOptions, res => {\n      let data = ''\n      res.on('data', chunk => data += chunk)\n      res.on('end', () => resolve(JSON.parse(data)))\n    }).end()\n  )\n},\n```", "```\nconst twitterClient = createTwitterClient(credentials.twitter)\n\nconst getTopTweets = ((twitterClient, search) => {\n  const topTweets = {\n    count: 10,\n    lastRefreshed: 0,\n    refreshInterval: 15 * 60 * 1000,\n    tweets: [],\n  }\n  return async () => {\n    if(Date.now() > topTweets.lastRefreshed + topTweets.refreshInterval) {\n      const tweets =\n       await twitterClient.search('#Oregon #travel', topTweets.count)\n      const formattedTweets = await Promise.all(\n        tweets.statuses.map(async ({ id_str, user }) => {\n          const url = `https://twitter.com/${user.id_str}/statuses/${id_str}`\n          const embeddedTweet =\n           await twitterClient.embed(url, { omit_script: 1 })\n          return embeddedTweet.html\n        })\n      )\n      topTweets.lastRefreshed = Date.now()\n      topTweets.tweets = formattedTweets\n    }\n    return topTweets.tweets\n  }\n})(twitterClient, '#Oregon #travel')\n```", "```\n<h2>Oregon Travel in Social Media</h2>\n\n<script id=\"twitter-wjs\" type=\"text/javascript\"\n  async defer src=\"//platform.twitter.com/widgets.js\"></script>\n\n{{{tweets}}}\n```", "```\napp.get('/social', async (req, res) => {\n  res.render('social', { tweets: await getTopTweets() })\n})\n```", "```\n\"google\": {\n  \"apiKey\": \"<YOUR API KEY>\"\n}\n```", "```\nconst https = require('https')\nconst { credentials } = require('../config')\n\nmodule.exports = async query => {\n\n  const options = {\n    hostname: 'maps.googleapis.com',\n    path: '/maps/api/geocode/json?address=' +\n      encodeURIComponent(query) + '&key=' +\n      credentials.google.apiKey,\n  }\n\n  return new Promise((resolve, reject) =>\n    https.request(options, res => {\n      let data = ''\n      res.on('data', chunk => data += chunk)\n      res.on('end', () => {\n        data = JSON.parse(data)\n        if(!data.results.length)\n          return reject(new Error(`no results for \"${query}\"`))\n        resolve(data.results[0].geometry.location)\n      })\n    }).end()\n  )\n\n}\n```", "```\nmodule.exports = {\n  //...\n  updateVacationBySku: async (sku, data) => Vacation.updateOne({ sku }, data),\n  close: () => mongoose.connection.close(),\n}\n```", "```\nconst db = require('./db')\nconst geocode = require('./lib/geocode')\n\nconst geocodeVacations = async () => {\n  const vacations = await db.getVacations()\n  const vacationsWithoutCoordinates = vacations.filter(({ location }) =>\n    !location.coordinates || typeof location.coordinates.lat !== 'number')\n  console.log(`geocoding ${vacationsWithoutCoordinates.length} ` +\n    `of ${vacations.length} vacations:`)\n  return Promise.all(vacationsWithoutCoordinates.map(async ({ sku, location }) => {\n    const { search } = location\n    if(typeof search !== 'string' || !/\\w/.test(search))\n      return console.log(`  SKU ${sku} FAILED: does not have location.search`)\n    try {\n      const coordinates = await geocode(search)\n      await db.updateVacationBySku(sku, { location: { search, coordinates } })\n      console.log(`  SKU ${sku} SUCCEEDED: ${coordinates.lat}, ${coordinates.lng}`)\n    } catch(err) {\n      return console.log(`  SKU {sku} FAILED: ${err.message}`)\n    }\n  }))\n}\n\ngeocodeVacations()\n  .then(() => {\n    console.log('DONE')\n    db.close()\n  })\n  .catch(err => {\n    console.error('ERROR: ' + err.message)\n    db.close()\n  })\n```", "```\n<div id=\"map\" style=\"width: 100%; height: 60vh;\"></div>\n<script>\n  let map = undefined\n  async function initMap() {\n    map = new google.maps.Map(document.getElementById('map'), {\n      // approximate geographic center of oregon\n      center: { lat: 44.0978126, lng: -120.0963654 },\n      // this zoom level covers most of the state\n      zoom: 7,\n    })\n  }\n</script>\n<script src=\"https://maps.googleapis.com/maps/api/js?key={{googleApiKey}}&callback=initMap\"\n    async defer></script>\n```", "```\nasync function initMap() {\n  map = new google.maps.Map(document.getElementById('map'), {\n    // approximate geographic center of oregon\n    center: { lat: 44.0978126, lng: -120.0963654 },\n    // this zoom level covers most of the state\n    zoom: 7,\n  })\n  const vacations = await fetch('/api/vacations').then(res => res.json())\n  vacations.forEach(({ name, location }) => {\n    const marker = new google.maps.Marker({\n      position: location.coordinates,\n      map,\n      title: name,\n    })\n  })\n}\n```", "```\nconst https = require('https')\nconst { URL } = require('url')\n\nconst _fetch = url => new Promise((resolve, reject) => {\n  const { hostname, pathname, search } = new URL(url)\n  const options = {\n    hostname,\n    path: pathname + search,\n    headers: {\n      'User-Agent': 'Meadowlark Travel'\n    },\n  }\n  https.get(options, res => {\n    let data = ''\n    res.on('data', chunk => data += chunk)\n    res.on('end', () => resolve(JSON.parse(data)))\n  }).end()\n})\n\nmodule.exports = locations => {\n\n  const cache = {\n    refreshFrequency: 15 * 60 * 1000,\n    lastRefreshed: 0,\n    refreshing: false,\n    forecasts: locations.map(location => ({ location })),\n  }\n\n  const updateForecast = async forecast => {\n    if(!forecast.url) {\n      const { lat, lng } = forecast.location.coordinates\n      const path = `/points/${lat.toFixed(4)},${lng.toFixed(4)}`\n      const points = await _fetch('https://api.weather.gov' + path)\n      forecast.url = points.properties.forecast\n    }\n    const { properties: { periods } } = await _fetch(forecast.url)\n    const currentPeriod = periods[0]\n    Object.assign(forecast, {\n      iconUrl: currentPeriod.icon,\n      weather: currentPeriod.shortForecast,\n      temp: currentPeriod.temperature + ' ' + currentPeriod.temperatureUnit,\n    })\n    return forecast\n  }\n\n  const getForecasts = async () => {\n    if(Date.now() > cache.lastRefreshed + cache.refreshFrequency) {\n      console.log('updating cache')\n      cache.refreshing = true\n      cache.forecasts = await Promise.all(cache.forecasts.map(updateForecast))\n      cache.refreshing = false\n    }\n    return cache.forecasts\n  }\n\n  return getForecasts\n\n}\n```", "```\nconst weatherData = require('../weather')\n\nconst getWeatherData = weatherData([\n  {\n    name: 'Portland',\n    coordinates: { lat: 45.5154586, lng: -122.6793461 },\n  },\n  {\n    name: 'Bend',\n    coordinates: { lat: 44.0581728, lng: -121.3153096 },\n  },\n  {\n    name: 'Manzanita',\n    coordinates: { lat: 45.7184398, lng: -123.9351354 },\n  },\n])\n```"]