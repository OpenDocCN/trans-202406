<html><head></head><body><section data-pdf-bookmark="Chapter 5. Working with Services" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_services">&#13;
<h1><span class="label">Chapter 5. </span>Working with Services</h1>&#13;
&#13;
&#13;
<p>In this chapter, we discuss how pods communicate within the cluster, how applications discover each other, and how to expose pods so that they can be accessed from outside of the cluster.<a data-primary="services" data-type="indexterm" id="ix_srvs"/></p>&#13;
&#13;
<p>The resource we will be using here is called a Kubernetes <a href="https://oreil.ly/BGn9e"><em>service</em></a>, as depicted in <a data-type="xref" href="#svc-concept">Figure 5-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="svc-concept">&#13;
<img alt="The service concept" src="assets/kcb2_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>The Kubernetes service concept</h6>&#13;
</div></figure>&#13;
&#13;
<p>A service provides a stable virtual IP (VIP) address for a set of pods.<a data-primary="virtual IP (VIP) address" data-type="indexterm" id="id740"/><a data-primary="pods" data-secondary="virtual IP (VIP) address" data-type="indexterm" id="id741"/> Though pods may come and go, services allow clients to reliably discover and connect to the containers running in the pods by using the VIP. The “virtual” in VIP means it’s not an actual IP address connected to a network interface; its purpose is purely to forward traffic to one or more pods. Keeping the mapping between the VIPs and the pods up to date is the job of <code>kube-proxy</code>, a process that runs on every node on the cluster.<a data-primary="kube-proxy" data-type="indexterm" id="id742"/> This <code>kube-proxy</code> process queries the API server to learn about new services in the cluster and updates the node’s iptables rules (iptables) accordingly to provide the necessary routing information.<a data-primary="iptables" data-type="indexterm" id="id743"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.1 Creating a Service to Expose Your Application" data-type="sect1"><div class="sect1" id="simple_service">&#13;
<h1>5.1 Creating a Service to Expose Your Application</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id191">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to provide a stable and reliable way to discover and access your application within the cluster.<a data-primary="services" data-secondary="creating service to expose your application" data-type="indexterm" id="ix_srvscr"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id48">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a Kubernetes service for the pods that make up your application.</p>&#13;
&#13;
<p>Assuming you created an <code>nginx</code> deployment with <code>kubectl create deployment nginx --image nginx:1.25.2</code>, you can automatically create a <code>Service</code> object using the <code>kubectl expose</code> command, <a data-primary="NGINX" data-secondary="deployments created with kubectl create, exposing service on" data-type="indexterm" id="id744"/><a data-primary="kubectl" data-secondary="expose command" data-type="indexterm" id="id745"/><a data-primary="expose command (kubectl)" data-type="indexterm" id="id746"/>like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl expose deploy/nginx --port 80</strong>&#13;
service "nginx" exposed&#13;
&#13;
$ <strong>kubectl describe svc/nginx</strong>&#13;
Name:              nginx&#13;
Namespace:         default&#13;
Labels:            app=nginx&#13;
Annotations:       &lt;none&gt;&#13;
Selector:          app=nginx&#13;
Type:              ClusterIP&#13;
IP Family Policy:  SingleStack&#13;
IP Families:       IPv4&#13;
IP:                10.97.137.240&#13;
IPs:               10.97.137.240&#13;
Port:              &lt;unset&gt;  80/TCP&#13;
TargetPort:        80/TCP&#13;
Endpoints:         172.17.0.3:80&#13;
Session Affinity:  None&#13;
Events:            &lt;none&gt;&#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">You will then see the object appear when you list the <code>Service</code>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get svc nginx</strong>&#13;
NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE&#13;
nginx        ClusterIP   10.97.137.240   &lt;none&gt;        80/TCP    2s&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id49">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>To access this service via your browser, run <a data-primary="kubectl" data-secondary="proxy command" data-type="indexterm" id="id747"/><a data-primary="proxy command (kubectl)" data-type="indexterm" id="id748"/>a proxy in a separate terminal, like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl proxy</strong>&#13;
Starting to serve on 127.0.0.1:8001&#13;
</pre>&#13;
&#13;
<p>Then open your browser with this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>open http://localhost:8001/api/v1/namespaces/default/services/nginx/proxy/</strong>&#13;
</pre>&#13;
&#13;
<p>You should see the NGINX default page.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If your service does not seem to be working properly, check the labels used in the selector and verify that a set of endpoints is being populated with <code>kubectl get endpoints</code> <code><em>&lt;service-name&gt;</em></code>. If not, this most likely means that your selector is not finding any matching pods.<a data-primary="endpoints for service, getting" data-type="indexterm" id="id749"/><a data-primary="kubectl" data-secondary="get command" data-tertiary="get endpoints" data-type="indexterm" id="id750"/></p>&#13;
</div>&#13;
&#13;
<p>If you wanted to <a data-primary="Service object" data-secondary="writing by hand" data-type="indexterm" id="id751"/>create a <code>Service</code> object by hand for the same <code>nginx</code> deployment, you would write the following YAML file:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w">  </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/></pre>&#13;
&#13;
<p>The one thing to pay attention to in this YAML file is the <em>selector</em>, which is used to select all the pods that make up this microservice abstraction.<a data-primary="selector" data-type="indexterm" id="id752"/><a data-primary="microservices" data-type="indexterm" id="id753"/> Kubernetes uses the <code>Service</code> object to dynamically configure the iptables on all the nodes to be able to send the network traffic to the containers that make up the microservice.<a data-primary="Service object" data-secondary="dynamic configuration of iptables on nodes" data-type="indexterm" id="id754"/><a data-primary="iptables" data-secondary="dynamic configuration by Service object" data-type="indexterm" id="id755"/> The selection is done as a label query (see <a data-type="xref" href="ch07.html#labels">Recipe 7.6</a>) and results in a list of endpoints.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Pod supervisors, such as <code>Deployments</code> or <code>ReplicationSets</code>, operate orthogonally to <code>Services</code>. <a data-primary="pods" data-secondary="supervisors, services and" data-type="indexterm" id="id756"/><a data-primary="labels" data-type="indexterm" id="id757"/>Both supervisors and <code>Services</code> find the pods they’re looking after by using labels, but they have different jobs to do: supervisors monitor the health of and restart pods, and <code>Services</code> make them accessible in a reliable way.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id758">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes <a href="https://oreil.ly/BGn9e"><code>Service</code> documentation</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Kubernetes tutorial <a href="https://oreil.ly/NVOhU">“Using a Service to Expose Your App”</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.2 Verifying the DNS Entry of a Service" data-type="sect1"><div class="sect1" id="dns_service">&#13;
<h1>5.2 Verifying the DNS Entry of a Service</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id192">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You have created a service (see <a data-type="xref" href="#simple_service">Recipe 5.1</a>) and want to verify that your Domain Name System (DNS) registration is working properly.<a data-primary="services" data-secondary="creating service to expose your application" data-startref="ix_srvscr" data-type="indexterm" id="id759"/><a data-primary="DNS" data-secondary="verifying registration for service" data-type="indexterm" id="id760"/><a data-primary="Domain Name System" data-see="DNS" data-type="indexterm" id="id761"/><a data-primary="services" data-secondary="verifying DNS entry for" data-type="indexterm" id="id762"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id50">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>By default Kubernetes uses <code>ClusterIP</code> as the service type, and that exposes the service on a cluster-internal IP. <a data-primary="fully qualified domain name (FQDN)" data-type="indexterm" id="id763"/><a data-primary="ClusterIP type" data-type="indexterm" id="id764"/>If the DNS cluster add-on is available and working properly, you can access the service via a fully qualified domain name (FQDN) in the form of <code>$SERVICENAME.$NAMESPACE.svc.cluster.local</code>.</p>&#13;
&#13;
<p>To verify that this is working as expected, get an interactive shell within a container in your cluster. The easiest way to do this is to use <code>kubectl run</code> with the <code>busybox</code> image, like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl run busybox --rm -it --image busybox:1.36 -- /bin/sh</strong>&#13;
If you don't see a command prompt, try pressing enter.&#13;
&#13;
/ # nslookup nginx&#13;
Server:		10.96.0.10&#13;
Address:	10.96.0.10:53&#13;
&#13;
Name:	nginx.default.svc.cluster.local&#13;
Address: 10.100.34.223&#13;
</pre>&#13;
&#13;
<p>The IP address returned for the service should correspond to its cluster IP.</p>&#13;
&#13;
<p>Type <code>exit</code> and hit Enter to leave the container.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id193">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>By default, a DNS query will be scoped to the same namespace as the pod making the request. If, in the previous example, you run the <code>busybox</code> pod in a different namespace from the one running <code>nginx</code>, by default the lookup won’t return any results.<a data-primary="namespaces" data-secondary="specifying for services" data-type="indexterm" id="id765"/> To specify the correct namespace, use the syntax <code><em>&lt;service-name&gt;</em></code><code>.</code><code><em>&lt;namespace&gt;</em></code>; for example, <code>nginx.staging</code>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.3 Changing the Type of a Service" data-type="sect1"><div class="sect1" id="changing_service_type">&#13;
<h1>5.3 Changing the Type of a Service</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id194">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You have an existing service, say of type <code>ClusterIP</code>, as discussed in <a data-type="xref" href="#dns_service">Recipe 5.2</a>, and you want to change its type so that you can expose your application as a <code>NodePort</code> or via a cloud provider load balancer using the <code>LoadBalancer</code> service type.<a data-primary="ClusterIP type" data-secondary="changing service to another type" data-type="indexterm" id="id766"/><a data-primary="services" data-secondary="changing type of" data-type="indexterm" id="ix_srvschtyp"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id51">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>kubectl edit</code> command along with your preferred editor to change the service type.<a data-primary="kubectl" data-secondary="edit command" data-type="indexterm" id="id767"/><a data-primary="edit command (kubectl)" data-type="indexterm" id="id768"/> Suppose you have a manifest file called <em>simple-nginx-svc.yaml</em> with this <span class="keep-together">content</span>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webserver</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/></pre>&#13;
&#13;
<p>Create the <code>webserver</code> service and query for it:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f simple-nginx-svc.yaml</strong>&#13;
&#13;
$ <strong>kubectl get svc/webserver</strong>&#13;
NAME        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE&#13;
webserver   ClusterIP   10.98.223.206   &lt;none&gt;        80/TCP    11s&#13;
</pre>&#13;
&#13;
<p>Next, change the service type to, say, <code>NodePort</code>, like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl edit svc/webserver</strong>&#13;
</pre>&#13;
&#13;
<p>This command will download the current spec the API server has of the service and open it in your default editor. Notice the area in bold toward the end, where we’ve changed the type from <code>ClusterIP</code> to <code>NodePort</code>:</p>&#13;
<pre data-type="programlisting">&#13;
# Please edit the object below. Lines beginning with a '#' will be ignored,&#13;
# and an empty file will abort the edit. If an error occurs while saving this...&#13;
# reopened with the relevant failures.&#13;
#&#13;
apiVersion: v1&#13;
kind: Service&#13;
metadata:&#13;
  annotations:&#13;
    kubectl.kubernetes.io/last-applied-configuration: |&#13;
      {"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"name"...&#13;
  creationTimestamp: "2023-03-01T14:07:55Z"&#13;
  name: webserver&#13;
  namespace: default&#13;
  resourceVersion: "1128"&#13;
  uid: 48daed0e-a16f-4923-bd7e-1d879dc2221f&#13;
spec:&#13;
  clusterIP: 10.98.223.206&#13;
  clusterIPs:&#13;
  - 10.98.223.206&#13;
  externalTrafficPolicy: Cluster&#13;
  internalTrafficPolicy: Cluster&#13;
  ipFamilies:&#13;
  - IPv4&#13;
  ipFamilyPolicy: SingleStack&#13;
  ports:&#13;
  - nodePort: 31275&#13;
    port: 80&#13;
    protocol: TCP&#13;
    targetPort: 80&#13;
  selector:&#13;
    app: nginx&#13;
  sessionAffinity: None&#13;
  <strong>type: NodePort</strong>&#13;
status:&#13;
  loadBalancer: {}&#13;
</pre>&#13;
&#13;
<p>Once you’ve saved the edits (changing <code>type</code> to <code>NodePort</code>), you can verify the updated service, like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get svc/webserver</strong>&#13;
NAME        TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE&#13;
webserver   NodePort   10.98.223.206   &lt;none&gt;        80:31275/TCP   4m&#13;
&#13;
$ <strong>kubectl get svc/webserver -o yaml</strong>&#13;
apiVersion: v1&#13;
kind: Service&#13;
metadata:&#13;
  annotations:&#13;
    kubectl.kubernetes.io/last-applied-configuration: |&#13;
      {"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"name"...&#13;
  creationTimestamp: "2023-03-01T14:07:55Z"&#13;
  name: webserver&#13;
  namespace: default&#13;
  resourceVersion: "1128"&#13;
  uid: 48daed0e-a16f-4923-bd7e-1d879dc2221f&#13;
spec:&#13;
  clusterIP: 10.98.223.206&#13;
  clusterIPs:&#13;
  - 10.98.223.206&#13;
  externalTrafficPolicy: Cluster&#13;
  internalTrafficPolicy: Cluster&#13;
  ipFamilies:&#13;
  - IPv4&#13;
  ipFamilyPolicy: SingleStack&#13;
  ports:&#13;
  - nodePort: 31275&#13;
    port: 80&#13;
    protocol: TCP&#13;
    targetPort: 80&#13;
  selector:&#13;
    app: nginx&#13;
  sessionAffinity: None&#13;
  type: NodePort&#13;
status:&#13;
  loadBalancer: {}&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id52">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Note that you can change the service type to whatever suits your use case; however, be aware of the implications of certain types, like <code>LoadBalancer</code>, which may trigger the provisioning of public cloud infrastructure components that can be costly if used without awareness and/or monitoring.<a data-primary="LoadBalancer object" data-type="indexterm" id="id769"/><a data-primary="services" data-secondary="changing type of" data-startref="ix_srvschtyp" data-type="indexterm" id="id770"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id771">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Details on the different types of <a href="https://oreil.ly/r63eA">Kubernetes services</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.4 Deploying an Ingress Controller" data-type="sect1"><div class="sect1" id="ingress_controller">&#13;
<h1>5.4 Deploying an Ingress Controller</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id195">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to deploy an<a data-primary="services" data-secondary="deploying ingress controller" data-type="indexterm" id="id772"/><a data-primary="ingress" data-secondary="deploying ingress controller" data-type="indexterm" id="id773"/> ingress controller  to learn about <code>Ingress</code> objects. <code>Ingress</code> objects are of interest to you because you want to provide access to your applications running in Kubernetes from outside your Kubernetes cluster; however, you do not want to create a <code>NodePort</code>- or <code>LoadBalancer</code>-type service.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id196">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>An ingress controller acts as a reverse proxy and load balancer. It routes traffic from outside the cluster and load-balances it to the pods running inside the platform, allowing  you deploy multiple applications on the cluster, each addressable by hostname and/or URI path.</p>&#13;
&#13;
<p>For <code>Ingress</code> objects (discussed in <a data-type="xref" href="#ingress">Recipe 5.5</a>) to take effect and provide a route from outside the cluster to your pods, you need to deploy an ingress controller:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/&#13;
controller-v1.8.1/deploy/static/provider/cloud/deploy.yaml</strong>&#13;
</pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>On Minikube, you can <a data-primary="Minikube" data-secondary="enabling ingress add-on" data-type="indexterm" id="id774"/>simply enable the <code>ingress</code> add-on like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>minikube addons enable ingress</strong>&#13;
</pre>&#13;
</div>&#13;
&#13;
<p>After a minute or less, a new pod will start <a data-primary="NGINX" data-secondary="ingress controller" data-type="indexterm" id="id775"/>in the newly created <code>ingress-nginx</code> namespace:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get pods -n ingress-nginx</strong>&#13;
NAME                                       READY   STATUS      RESTARTS   AGE&#13;
ingress-nginx-admission-create-xpqbt       0/1     Completed   0          3m39s&#13;
ingress-nginx-admission-patch-r7cnf        0/1     Completed   1          3m39s&#13;
ingress-nginx-controller-6cc5ccb977-l9hvz  1/1     Running     0          3m39s&#13;
</pre>&#13;
&#13;
<p>You are now ready to create <code>Ingress</code> objects.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id197">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>NGINX is one of the ingress controllers officially supported by the Kubernetes project, but there are many other <a href="https://oreil.ly/eukmq">open source and commercial solutions</a> that support the ingress specification, many of which provide broader API management capabilities.</p>&#13;
&#13;
<p>At the time of writing, the new Kubernetes <a href="https://oreil.ly/Y27m-">Gateway API specification</a> is emerging as a future replacement for the ingress specification and is already supported by many third-party gateway providers. If you are just starting out with ingress, it is worth considering the Gateway API as a more future-proof starting point.<a data-primary="APIs" data-secondary="API Gateway as future replacement for ingress" data-type="indexterm" id="id776"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id777">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/9xoks">Kubernetes <code>Ingress</code> documentation</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/691Lx">NGINX-based ingress controller</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/To14r">Minikube’s <code>ingress-dns</code> add-on</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.5 Making Services Accessible from Outside the Cluster" data-type="sect1"><div class="sect1" id="ingress">&#13;
<h1>5.5 Making Services Accessible from Outside the Cluster</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id198">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to access a Kubernetes service by URI path from outside of the cluster.<a data-primary="services" data-secondary="making available from outside the cluster" data-type="indexterm" id="ix_srvsouts"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id53">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use an ingress controller (see <a data-type="xref" href="#ingress_controller">Recipe 5.4</a>), configured by creating <code>Ingress</code> objects.<a data-primary="ingress" data-secondary="using ingress controller to make services available from outside the cluster" data-type="indexterm" id="ix_ingsrvc"/></p>&#13;
&#13;
<p>Suppose you want to deploy a simple service that can be invoked and returns “Hello, world!” Start by creating the deployment:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create deployment web --image=gcr.io/google-samples/hello-app:2.0</strong>&#13;
</pre>&#13;
&#13;
<p>Then expose the service:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl expose deployment web --port=8080</strong>&#13;
</pre>&#13;
&#13;
<p>Verify that all these resources were correctly created with the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get all -l app=web</strong>&#13;
NAME                       READY   STATUS    RESTARTS   AGE&#13;
pod/web-79b7b8f988-95tjv   1/1     Running   0          47s&#13;
&#13;
NAME          TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE&#13;
service/web   ClusterIP   10.100.87.233   &lt;none&gt;        8080/TCP   8s&#13;
&#13;
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE&#13;
deployment.apps/web   1/1     1            1           47s&#13;
&#13;
NAME                             DESIRED   CURRENT   READY   AGE&#13;
replicaset.apps/web-79b7b8f988   1         1         1       47s&#13;
</pre>&#13;
&#13;
<p>The following is the manifest of an <code>Ingress</code> object that configures<a data-primary="NGINX" data-secondary="Ingress object created for" data-type="indexterm" id="id778"/> the URI path <code>/web</code> to the <code>hello-app</code> service:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>cat nginx-ingress.yaml</strong>&#13;
apiVersion: networking.k8s.io/v1&#13;
kind: Ingress&#13;
metadata:&#13;
  name: nginx-public&#13;
  annotations:&#13;
    nginx.ingress.kubernetes.io/rewrite-target: /&#13;
spec:&#13;
  ingressClassName: nginx&#13;
  rules:&#13;
  - host:&#13;
    http:&#13;
      paths:&#13;
      - path: /web&#13;
        pathType: Prefix&#13;
        backend:&#13;
          service:&#13;
            name: web&#13;
            port:&#13;
              number: 8080&#13;
&#13;
$ <strong>kubectl apply -f nginx-ingress.yaml</strong>&#13;
</pre>&#13;
&#13;
<p>Now you can see the <code>Ingress</code> object created for NGINX in your Kubernetes &#13;
<span class="keep-together">dashboard</span> (<a data-type="xref" href="#nginx-ingress-screenshot">Figure 5-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="nginx-ingress-screenshot">&#13;
<img alt="Screenshot of the nginx ingress object" src="assets/kcb2_0502.png"/>&#13;
<h6><span class="label">Figure 5-2. </span>NGINX <code>Ingress</code> object</h6>&#13;
</div></figure>&#13;
&#13;
<p>From the Kubernetes dashboard, you can see that NGINX will be available via the IP address 192.168.49.2 (yours may differ).<a data-primary="NGINX" data-secondary="accessing from outside the cluster" data-type="indexterm" id="id779"/> Based on this information, you can access NGINX from outside the cluster at the <code>/web</code> URI path as follows:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl https://192.168.49.2/web</strong>&#13;
Hello, world!&#13;
Version: 1.0.0&#13;
Hostname: web-68487bc957-v9fj8&#13;
</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id780">&#13;
<h1>Known Issue with Minikube</h1>&#13;
<p>Because of known networking limitations when using Minikube with the Docker driver (for example with Docker Desktop), you might not be able to access your service externally using the IP address provided by the <code>Ingress</code> object, as shown earlier.<a data-primary="Docker" data-secondary="limitations using Minikube with Docker driver" data-type="indexterm" id="id781"/><a data-primary="Minikube" data-secondary="service command" data-type="indexterm" id="id782"/><a data-primary="service command (Minikube)" data-type="indexterm" id="id783"/> In this case, the recommended work-around is to create a tunnel to the cluster using the <code>minikube service</code> command. For instance, to expose the service <code>web</code> that we created in this recipe, use the following command:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>minikube service web</strong>&#13;
</pre>&#13;
&#13;
<p>By default this command will open the service in your default browser. Append the <code>--url</code> option, and the tunnel URL will be printed out in the terminal. Note that the <code>minikube service</code> command will block your terminal while it runs, so we recommend that you run it in a dedicated terminal window.</p>&#13;
&#13;
<p>In <a href="https://oreil.ly/2V4Ln">the Minikube documentation</a> you can read more about this limitation.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id54">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>An alternative to using the <a data-primary="kubectl" data-secondary="describe ingress command" data-type="indexterm" id="id784"/>dashboard to see your service IPs is to use the following command:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl describe ingress</strong>&#13;
</pre>&#13;
&#13;
<p>In general, ingress works as depicted in <a data-type="xref" href="#ingress-concept">Figure 5-3</a>: the ingress controller listens to the <code>/ingresses</code> endpoint of the API server, learning about new rules. It then configures the routes so that external traffic lands at a specific (cluster-internal) service—<code class="keep-together">service1</code> on port 9876 in the depicted example.<a data-primary="services" data-secondary="making available from outside the cluster" data-startref="ix_srvsouts" data-type="indexterm" id="id785"/><a data-primary="services" data-startref="ix_srvs" data-type="indexterm" id="id786"/></p>&#13;
&#13;
<figure><div class="figure" id="ingress-concept">&#13;
<img alt="Ingress concept" src="assets/kcb2_0503.png"/>&#13;
<h6><span class="label">Figure 5-3. </span>Ingress concept</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id787">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <em>kubernetes/ingress-nginx</em> repo on <a href="https://oreil.ly/guulG">GitHub</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>