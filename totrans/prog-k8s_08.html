<html><head></head><body><section data-pdf-bookmark="Chapter 8. Custom API Servers" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_custom-api-servers">&#13;
<h1><span class="label">Chapter 8. </span>Custom API Servers</h1>&#13;
&#13;
&#13;
<p>As<a data-primary="extension patterns" data-secondary="aggregated API servers" data-type="indexterm" id="EPaggapi08"/><a data-primary="API servers" data-see="custom API servers" data-type="indexterm" id="idm46336853186504"/><a data-primary="aggregated API server" data-see="aggregation" data-type="indexterm" id="idm46336853185560"/><a data-primary="aggregator" data-see="aggregation" data-type="indexterm" id="idm46336853184616"/> an alternative to CustomResourceDefinitions, you can use a custom API server. Custom API servers can serve API groups with resources the same way the main Kubernetes API server does. In contrast to CRDs, there are hardly any limits to what you can do with a custom API server.</p>&#13;
&#13;
<p>This chapter begins by listing a number of reasons why CRDs might not be the right solution for your use case. It describes the<a data-primary="aggregation" data-type="indexterm" id="idm46336853182728"/> aggregation pattern that makes it possible to extend the Kubernetes API surface with a custom API server. Finally, you’ll learn to actually implement a custom API server using Golang.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Use Cases for Custom API Servers" data-type="sect1"><div class="sect1" id="uc-custom-api-server">&#13;
<h1>Use Cases for Custom API Servers</h1>&#13;
&#13;
<p>A<a data-primary="custom API servers" data-secondary="CRD drawbacks" data-type="indexterm" id="idm46336853179784"/><a data-primary="custom resource definitions (CRDs)" data-secondary="limits of" data-type="indexterm" id="idm46336853178776"/> custom API server can be used in place of CRDs. It can do everything that CRDs can do and offers nearly infinite flexibility. Of course, this comes at a cost: complexity of both development and operation.</p>&#13;
&#13;
<p>Let’s look at some limits of CRDs as of the time of this writing (when Kubernetes 1.14 was the stable release). CRDs:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use <code>etcd</code> as their storage medium (or whatever the Kubernetes API server uses).</p>&#13;
</li>&#13;
<li>&#13;
<p>Do not support protobuf, only JSON.</p>&#13;
</li>&#13;
<li>&#13;
<p>Support only two kinds of subresources: <em>/status</em> and <em>/scale</em> (see <a data-type="xref" href="ch04.html#crd-subresources">“Subresources”</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Do not support graceful deletion.<sup><a data-type="noteref" href="ch08.html#idm46336853170760" id="idm46336853170760-marker">1</a></sup> Finalizers can simulate this but do not allow a custom graceful deletion time.</p>&#13;
</li>&#13;
<li>&#13;
<p>Add significantly to the Kubernetes API server’s CPU load, because all algorithms are implemented in a generic way (for example, validation).</p>&#13;
</li>&#13;
<li>&#13;
<p>Implement only standard CRUD semantics for the API endpoints.</p>&#13;
</li>&#13;
<li>&#13;
<p>Do<a data-primary="cohabitation" data-type="indexterm" id="idm46336853166536"/> not support cohabitation of resources (i.e., resources in different API groups or resources of different names that share storage).<sup><a data-type="noteref" href="ch08.html#idm46336853165528" id="idm46336853165528-marker">2</a></sup></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>A<a data-primary="custom API servers" data-secondary="benefits of" data-type="indexterm" id="idm46336853163400"/> custom API server, in contrast, does not have these restrictions. A custom API server:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Can use any storage medium. There are custom API servers, such as:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <a href="http://bit.ly/2FvgfAV">metrics API server</a>, which stores data in memory for maximum <span class="keep-together">performance</span></p>&#13;
</li>&#13;
<li>&#13;
<p>API servers mirroring a Docker registry in <a href="http://redhat.com/openshift">OpenShift</a></p>&#13;
</li>&#13;
<li>&#13;
<p>API servers writing to a time series database</p>&#13;
</li>&#13;
<li>&#13;
<p>API servers mirroring cloud APIs</p>&#13;
</li>&#13;
<li>&#13;
<p>API servers mirroring other API objects, like projects in <a href="http://redhat.com/openshift">OpenShift</a> that mirror Kubernetes namespaces</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Can provide protobuf support like all native Kubernetes resources do. For this you must create a <em>.proto</em> file by using <a href="http://bit.ly/31OLSie">go-to-protobuf</a> and then using the protobuf compiler <code>protoc</code> to generate serializers, which are then compiled into the binary.</p>&#13;
</li>&#13;
<li>&#13;
<p>Can provide any custom subresource; for example, the Kubernetes API server provides <em>/exec</em>, <em>/logs</em>, <em>/port-forward</em>, and more, most of which use very custom protocols like WebSockets or HTTP/2 streaming.</p>&#13;
</li>&#13;
<li>&#13;
<p>Can implement graceful deletion as Kubernetes does for pods. <code>kubectl</code> waits for the deletion, and the user can even provide a<a data-primary="graceful termination" data-type="indexterm" id="idm46336853147192"/> custom graceful termination period.</p>&#13;
</li>&#13;
<li>&#13;
<p>Can implement all operations like validation, admission, and conversion in the most efficient way using Golang, without a roundtrip through webhooks, which add further latency. This can matter for high performance use cases or if there is a large number of objects. Think about pod objects in a huge cluster with thousands of nodes, and two magnitudes more pods.</p>&#13;
</li>&#13;
<li>&#13;
<p>Can implement custom semantics, like the atomic reservation of a service IP in the core v1 <code>Service</code> kind. At the moment the service is created, a unique service IP is assigned and directly returned. To a limited degree, special semantics like this can of course be implemented with admission webhooks (see <a data-type="xref" href="ch09.html#admission-webhooks">“Admission Webhooks”</a>), though those webhooks can never reliably know whether the passed object was actually created or updated: they are called optimistically, but a later step in the request pipeline might cancel the request. In other words: side  effects in webhooks are tricky because there is no undo trigger if a request fails.</p>&#13;
</li>&#13;
<li>&#13;
<p>Can serve resources that have a common storage mechanism (i.e., a common <code>etcd</code> key path prefix) but live in different API groups or are named differently. For example, Kubernetes stores deployments and other resources in the API group <code>extensions/v1</code> and then moves them to more specific API groups like <code>apps/v1</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In other words, custom API servers are a solution for situations where CRDs are still limited. In transitional scenarios where it is important to not break resource compatibility when moving to new semantics, custom API servers are often much more <span class="keep-together">flexible</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example: A Pizza Restaurant" data-type="sect1"><div class="sect1" id="aggregation-example">&#13;
<h1>Example: A Pizza Restaurant</h1>&#13;
&#13;
<p>To<a data-primary="custom API servers" data-secondary="example of" data-type="indexterm" id="idm46336853136248"/> learn how custom API servers are implemented, in this section we will look at an example project: a custom API server implementing a pizza restaurant API. Let’s take a look at the requirements.</p>&#13;
&#13;
<p>We want to create two kinds in the <code>restaurant.programming-kubernetes.info</code> API group:</p>&#13;
<dl>&#13;
<dt><code>Topping</code></dt>&#13;
<dd>&#13;
<p>Pizza toppings (e.g., salami, mozzarella, or tomato)</p>&#13;
</dd>&#13;
<dt><code>Pizza</code></dt>&#13;
<dd>&#13;
<p>The type of pizza offered in the restaurant</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The toppings are cluster-wide resources and hold only a floating-point value for the cost of one unit of the topping. An instance is as simple as:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">restaurant.programming-kubernetes.info/v1alpha1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Topping</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">mozzarella</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">cost</code><code class="p">:</code> <code class="l-Scalar-Plain">1.0</code></pre>&#13;
&#13;
<p>Each pizza can have an arbitrary number of toppings; for example:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">restaurant.programming-kubernetes.info/v1alpha1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pizza</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">margherita</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">toppings</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">mozzarella</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">tomato</code></pre>&#13;
&#13;
<p>The list of toppings is ordered (like any list in YAML or JSON), but the order does not really matter for the semantics of the type. The customer will get the same pizza in any case. We want to allow duplicates in the list in order to allow, say, a pizza with extra cheese.</p>&#13;
&#13;
<p>All this can be implemented easily with CRDs. Now let’s add some requirements that go beyond the basic CRD capabilities:<sup><a data-type="noteref" href="ch08.html#idm46336853099640" id="idm46336853099640-marker">3</a></sup></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We want to allow only toppings in a pizza specification that have a corresponding <code>Topping</code> object.</p>&#13;
</li>&#13;
<li>&#13;
<p>We also want to assume that we first introduced this API as a <code>v1alpha1</code> version but eventually learned that we want another representation of the toppings in the <code>v1beta1</code> version of the same API.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In other words, we want to have two versions and convert seamlessly between them.</p>&#13;
&#13;
<p>The full implementation of this API as a custom API server can be found at <a href="http://bit.ly/2x9C3gR">the book’s GitHub repository</a>. In the rest of this chapter, we will go through all the major parts of that project and learn how it works. In the process, you’ll see a lot of the concepts presented in the previous chapter in a different light: namely, the Golang implementation that is also behind the Kubernetes API server. A number of design decisions highlighted in CRDs also  will become clearer.</p>&#13;
&#13;
<p>Hence, we highly recommend you read through this chapter even if you don’t plan to go the route of a custom API server. Maybe the concepts presented here will be made available for CRDs as well in the future, in which case having knowledge of custom API servers will be useful to you.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Architecture: Aggregation" data-type="sect1"><div class="sect1" id="custom-api-server-aggregation">&#13;
<h1>The Architecture: Aggregation</h1>&#13;
&#13;
<p>Before<a data-primary="custom API servers" data-secondary="architecture" data-type="indexterm" id="CASarch08"/><a data-primary="custom API servers" data-secondary="architecture" data-tertiary="aggregation" data-type="indexterm" id="idm46336853032152"/> going into the technical implementation details, we want to take a higher-level view of the custom API server architecture in the context of a Kubernetes cluster.</p>&#13;
&#13;
<p>Custom API servers are processes serving API groups, usually built using the generic API server library <a href="http://bit.ly/2X3joNX"><em>k8s.io/apiserver</em></a>. These processes can run inside or outside of the cluster. In the former case, they run inside pods, with a service in front.</p>&#13;
&#13;
<p>The<a data-primary="kube-apiserver" data-type="indexterm" id="idm46336853028424"/> main Kubernetes API server, called <code>kube-apiserver</code>, is always the first point of contact for <code>kubectl</code> and other API clients. API groups served by a custom API server are proxied by the <code>kube-apiserver</code> process to the custom API server process. In other words, the <code>kube-apiserver</code> process knows about all of the custom API servers and the API groups they serve, in order to be able to proxy the right requests to them.</p>&#13;
&#13;
<p>The<a data-primary="kube-aggregator" data-type="indexterm" id="idm46336853025480"/> component doing this proxying is inside the <code>kube-apiserver</code> process and is called <a href="http://bit.ly/2X10C9W"><code>kube-aggregator</code></a>. The process of proxying API requests to the custom API server is called <em>API aggregation</em>.</p>&#13;
&#13;
<p>Let’s look a bit more into the  path of requests targeted at a custom API server, but coming in at the Kubernetes API server TCP socket (see <a data-type="xref" href="#aggregation-kube-apiserver">Figure 8-1</a>):</p>&#13;
<ol>&#13;
<li>&#13;
<p>Requests are received by the Kubernetes API server.</p>&#13;
</li>&#13;
<li>&#13;
<p>They pass the handler chain consisting of authentication, audit logging, impersonation, max-in-flight throttling, authorization, and more (the figure is just a sketch and is not complete).</p>&#13;
</li>&#13;
<li>&#13;
<p>As the Kubernetes API server knows the aggregated APIs, it can intercept requests to the HTTP path <em>/apis/<code>aggregated-API-group-name</code></em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Kubernetes API server forwards the request to the custom API server.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<figure><div class="figure" id="aggregation-kube-apiserver">&#13;
<img alt="Kubernetes main API server `kube-apiserver` with an integrated `kube-aggregator`" src="assets/prku_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>Kubernetes main API server kube-apiserver with an integrated kube-aggregator</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>kube-aggregator</code> proxies requests under the HTTP path for an API group version (i.e., everything under <em>/apis/<code>group-name</code>/<code>version</code></em>). It does not have to know the actual served resources in the API group version.</p>&#13;
&#13;
<p>In contrast, the <code>kube-aggregator</code> serves the discovery endpoints <em>/apis</em> and <em>/apis/<code>group-name</code></em> of all aggregated custom API servers itself (it uses the defined order explained in the following section) and returns the results without talking to the aggregated custom API servers. Instead it uses the information from the <code>APIService</code> resource. Let’s look at this process in detail.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="API Services" data-type="sect2"><div class="sect2" id="aggregation-apiservices">&#13;
<h2>API Services</h2>&#13;
&#13;
<p>For<a data-primary="API Services" data-type="indexterm" id="idm46336852987560"/><a data-primary="custom API servers" data-secondary="architecture" data-tertiary="API services" data-type="indexterm" id="idm46336852986824"/> the Kubernetes API server to know about the API groups a custom API server serves, one <code>APIService</code> object must be created in the <code>apiregistration.k8s.io/v1</code> API group. These objects list only the API groups and versions, not resources or any further details:</p>&#13;
<pre data-code-language="yaml" data-type="programlisting">&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">apiregistration.k8s.io/v1beta1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">APIService</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">name</code></em><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">group</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">API-group-name</code></em><code>&#13;
</code><code>  </code><code class="nt">version</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">API-group-version</code></em><code>&#13;
</code><code>  </code><code class="nt">service</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">namespace</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">custom-API-server-service-namespace</code></em><code>&#13;
</code><code>    </code><code class="nt">name</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">-API-server-service</code></em><code>&#13;
</code><code>  </code><code class="nt">caBundle</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">base64-caBundle</code></em><code>&#13;
</code><code>  </code><code class="nt">insecureSkipTLSVerify</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">bool</code></em><code>&#13;
</code><code>  </code><code class="nt">groupPriorityMinimum</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">2000</code><code>&#13;
</code><code>  </code><code class="nt">versionPriority</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">20</code><code>&#13;
</code></pre>&#13;
&#13;
<p>The name is arbitrary, but for clarity we suggest you use a name that identifies the API group name and version—e.g., <em><code>group-name-version</code></em>.</p>&#13;
&#13;
<p>The service can be a normal <a href="http://bit.ly/2X0zEEu"><code>ClusterIP</code> service</a> in the cluster, or it can be an <code>ExternalName</code> service with a given DNS name for out-of-cluster custom API servers. In both cases, the port must be 443. No other service port is supported (at the time of this writing). Service target port mapping allows any chosen, preferably nonrestricted, higher port to be used for the custom API server pods, so this is not a major <span class="keep-together">restriction</span>.</p>&#13;
&#13;
<p>The certificate authority (CA) bundle is used for the Kubernetes API server to trust the contacted service. Note that API requests can contain confidential data. To avoid man-in-the-middle attacks, it is highly recommended that you set the <code>caBundle</code> field and not use the <code>insecureSkipTLSVerify</code> alternative. This is especially important for any production cluster, including a mechanism for certificate rotation.</p>&#13;
&#13;
<p>Finally, there are two priorities in the <code>APIService</code> object. These have some tricky semantics, described in the Golang code documentation for the <code>APIService</code> type:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// GroupPriorityMininum is the priority this group should have at least. Higher</code>&#13;
<code class="c1">// priority means that the group is preferred by clients over lower priority ones.</code>&#13;
<code class="c1">// Note that other versions of this group might specify even higher</code>&#13;
<code class="c1">// GroupPriorityMinimum values such that the whole group gets a higher priority.</code>&#13;
<code class="c1">//</code>&#13;
<code class="c1">// The primary sort is based on GroupPriorityMinimum, ordered highest number to</code>&#13;
<code class="c1">// lowest (20 before 10). The secondary sort is based on the alphabetical</code>&#13;
<code class="c1">// comparison of the name of the object (v1.bar before v1.foo). We'd recommend</code>&#13;
<code class="c1">// something like: *.k8s.io (except extensions) at 18000 and PaaSes</code>&#13;
<code class="c1">// (OpenShift, Deis) are recommended to be in the 2000s</code>&#13;
<code class="nx">GroupPriorityMinimum</code> <code class="kt">int32</code> <code class="s">`json:"groupPriorityMinimum"`</code>&#13;
&#13;
<code class="c1">// VersionPriority controls the ordering of this API version inside of its</code>&#13;
<code class="c1">// group. Must be greater than zero. The primary sort is based on</code>&#13;
<code class="c1">// VersionPriority, ordered highest to lowest (20 before 10). Since it's inside</code>&#13;
<code class="c1">// of a group, the number can be small, probably in the 10s. In case of equal</code>&#13;
<code class="c1">// version priorities, the version string will be used to compute the order</code>&#13;
<code class="c1">// inside a group. If the version string is "kube-like", it will sort above non</code>&#13;
<code class="c1">// "kube-like" version strings, which are ordered lexicographically. "Kube-like"</code>&#13;
<code class="c1">// versions start with a "v", then are followed by a number (the major version),</code>&#13;
<code class="c1">// then optionally the string "alpha" or "beta" and another number (the minor</code>&#13;
<code class="c1">// version). These are sorted first by GA &gt; beta &gt; alpha (where GA is a version</code>&#13;
<code class="c1">// with no suffix such as beta or alpha), and then by comparing major version,</code>&#13;
<code class="c1">// then minor version. An example sorted list of versions:</code>&#13;
<code class="c1">// v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.</code>&#13;
<code class="nx">VersionPriority</code> <code class="kt">int32</code> <code class="s">`json:"versionPriority"`</code></pre>&#13;
&#13;
<p>In other words, the <code>GroupPriorityMinimum</code> value determines where the group is prioritized. If multiple <code>APIService</code> objects for different versions differ, the highest value rules.</p>&#13;
&#13;
<p>The second priority just orders the versions among each other to define the preferred version to be used by dynamic clients.</p>&#13;
&#13;
<p>Here is a list of the <code>GroupPriorityMinimum</code> values for the native Kubernetes API groups:</p>&#13;
<pre class="small" data-code-language="go" data-type="programlisting">&#13;
<code class="kd">var</code> <code class="nx">apiVersionPriorities</code> <code class="p">=</code> <code class="kd">map</code><code class="p">[</code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersion</code><code class="p">]</code><code class="nx">priority</code><code class="p">{</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">""</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code> <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">18000</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"extensions"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code> <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17900</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"apps"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>                         <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17800</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"apps"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta2"</code><code class="p">}:</code>                         <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17800</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"apps"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>                              <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17800</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"events.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>                <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17750</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">5</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"authentication.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>             <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17700</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"authentication.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>        <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17700</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"authorization.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>              <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17600</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"authorization.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>         <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17600</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"autoscaling"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>                       <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17500</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"autoscaling"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v2beta1"</code><code class="p">}:</code>                  <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17500</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"autoscaling"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v2beta2"</code><code class="p">}:</code>                  <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17500</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"batch"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>                             <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17400</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"batch"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>                        <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17400</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"batch"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v2alpha1"</code><code class="p">}:</code>                       <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17400</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"certificates.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>          <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17300</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"networking.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>                 <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17200</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"networking.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>            <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17200</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"policy"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>                       <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17100</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"rbac.authorization.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>         <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17000</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"rbac.authorization.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>    <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17000</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">12</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"rbac.authorization.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1alpha1"</code><code class="p">}:</code>   <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">17000</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"settings.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1alpha1"</code><code class="p">}:</code>             <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16900</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"storage.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>                    <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16800</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"storage.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>               <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16800</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"storage.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1alpha1"</code><code class="p">}:</code>              <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16800</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"apiextensions.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>         <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16700</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"admissionregistration.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>      <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16700</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"admissionregistration.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code> <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16700</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">12</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"scheduling.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>                 <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16600</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"scheduling.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>            <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16600</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">12</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"scheduling.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1alpha1"</code><code class="p">}:</code>           <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16600</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"coordination.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}:</code>               <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16500</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">15</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"coordination.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>          <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16500</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"auditregistration.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1alpha1"</code><code class="p">}:</code>    <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16400</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"node.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1alpha1"</code><code class="p">}:</code>                 <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16300</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">"node.k8s.io"</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1beta1"</code><code class="p">}:</code>                  <code class="p">{</code><code class="nx">group</code><code class="p">:</code> <code class="mi">16300</code><code class="p">,</code> <code class="nx">version</code><code class="p">:</code> <code class="mi">9</code><code class="p">},</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>So using <code>2000</code> for PaaS-like APIs means that they are placed at the end of this list.<sup><a data-type="noteref" href="ch08.html#idm46336852602264" id="idm46336852602264-marker">4</a></sup></p>&#13;
&#13;
<p>The order of the API groups plays a role during the REST mapping process in <code>kubectl</code> (see <a data-type="xref" href="ch03.html#RESTMapping">“REST Mapping”</a>). This means it has actual influence on the user experience. If there are conflicting resource names or short names, the one with the highest <code>GroupPriorityMinimum</code> value wins.</p>&#13;
&#13;
<p>Also, in the special case of replacing of an API group version using a custom API server, this priority ordering might be of use. For example, you could replace a native Kubernetes API group with a modified one (for whatever reason) by placing the custom API service at a position with a lower <code>GroupPriorityMinimum</code> value than the one in the upper table.</p>&#13;
&#13;
<p>Note again that the Kubernetes API server does not need to know the list of resources for either of the discovery endpoints <em>/apis</em>, and <em>/apis/<code>group-name</code></em>, or for proxying. The list of resources is returned only via the third discovery endpoint, <em>/apis/<code>group-name</code>/<code>version</code></em>. But as we have seen in the previous section, this endpoint is served by the aggregated custom API server, not by <code>kube-aggregator</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inner Structure of a Custom API Server" data-type="sect2"><div class="sect2" id="idm46336852988872">&#13;
<h2>Inner Structure of a Custom API Server</h2>&#13;
&#13;
<p>A<a data-primary="custom API servers" data-secondary="architecture" data-tertiary="inner structure of" data-type="indexterm" id="idm46336852593128"/> custom API server resembles most of the parts that make up the Kubernetes API server, though of course with different API group implementations, and without an embedded <code>kube-aggregator</code> or an embedded <code>apiextension-apiserver</code> (which serves CRDs). This leads to nearly the same architectural picture (shown in  <a data-type="xref" href="#aggregation-aggregated-apiserver">Figure 8-2</a>) as the one in <a data-type="xref" href="#aggregation-kube-apiserver">Figure 8-1</a>:</p>&#13;
&#13;
<figure><div class="figure" id="aggregation-aggregated-apiserver">&#13;
<img alt="An aggregated custom API server based on k8s.io/apiserver" src="assets/prku_0802.png"/>&#13;
<h6><span class="label">Figure 8-2. </span>An aggregated custom API server based on k8s.io/apiserver</h6>&#13;
</div></figure>&#13;
&#13;
<p>We observe a number of things. An aggregated API server:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Has the same basic internal structure as the Kubernetes API server.</p>&#13;
</li>&#13;
<li>&#13;
<p>Has its own<a data-primary="handler chain" data-type="indexterm" id="idm46336852157992"/> handler chain, including authentication, audit, <a data-primary="impersonation" data-type="indexterm" id="idm46336852157128"/>impersonation, max-in-flight throttling, and authorization (we will explain throughout this chapter why this is necessary; see, for example, <a data-type="xref" href="#aggregated-authorization">“Delegated Authorization”</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Has its own resource handler pipeline, including<a data-primary="decoding" data-type="indexterm" id="idm46336852154472"/> decoding, <a data-primary="conversion" data-type="indexterm" id="idm46336852153640"/>conversion, admission, REST mapping, and<a data-primary="encoding" data-type="indexterm" id="idm46336852152744"/> encoding.</p>&#13;
</li>&#13;
<li>&#13;
<p>Calls admission webhooks.</p>&#13;
</li>&#13;
<li>&#13;
<p>Might write to <code>etcd</code> (it can use a different storage backend, though). The <code>etcd</code> cluster does not have to be the same as the one used by the Kubernetes API server.</p>&#13;
</li>&#13;
<li>&#13;
<p>Has its own scheme and registry implementation for custom API groups. The registry implementation might differ and be customized to any degree.</p>&#13;
</li>&#13;
<li>&#13;
<p>Does authentication again. It usually does client certificate authentication and token-based authentication, calling back to the Kubernetes API server with a <code>TokenAccessReview</code> request. We will discuss the authentication and trust architecture in more detail shortly.</p>&#13;
</li>&#13;
<li>&#13;
<p>Does its own auditing. This means the Kubernetes API server audits certain fields, but only on the meta level. Object-level auditing is done in the aggregated custom API server.</p>&#13;
</li>&#13;
<li>&#13;
<p>Does its own authentication using <code>SubjectAccessReview</code> requests to the Kubernetes API server. We will discuss authorization in more detail shortly.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Delegated Authentication and Trust" data-type="sect2"><div class="sect2" id="aggregated-authentication">&#13;
<h2>Delegated Authentication and Trust</h2>&#13;
&#13;
<p>An<a data-primary="delegated authentication" data-type="indexterm" id="idm46336852141912"/><a data-primary="custom API servers" data-secondary="architecture" data-tertiary="delegated authentication and trust" data-type="indexterm" id="idm46336852141112"/><a data-primary="authentication" data-type="indexterm" id="idm46336852139880"/> aggregated custom API server (based on <a href="http://bit.ly/2X3joNX"><em>k8s.io/apiserver</em></a>) is built on the same authentication library as the Kubernetes API server. It can use client certificates or tokens to authenticate a user.</p>&#13;
&#13;
<p>Because an aggregated custom API server is architecturally placed behind the Kubernetes API server (i.e., the Kubernetes API server receives requests and proxies them to the aggregated custom API server), requests are already authenticated by the Kubernetes API server. The Kubernetes API server stores the result of the authentication—that is, the username and group membership—in HTTP request headers, usually <code>X-Remote-User</code> and <code>X-Remote-Group</code> (these can be configured with the <code>--requestheader-username-headers</code> and <code>--requestheader-group-headers</code> flags).</p>&#13;
&#13;
<p>The aggregated custom API server has to know when to trust these headers; otherwise, any other caller could claim to have done authentication and could set these headers. This is handled by a special request header client CA. It is stored in the config map <em>kube-system/extension-apiserver-authentication</em> (filename <em>requestheader-client-ca-file</em>). Here is an example:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ConfigMap</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">extension-apiserver-authentication</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">kube-system</code>&#13;
<code class="nt">data</code><code class="p">:</code>&#13;
  <code class="nt">client-ca-file</code><code class="p">:</code> <code class="p-Indicator">|</code>&#13;
    <code class="no">-----BEGIN CERTIFICATE-----</code>&#13;
    <code class="no">...</code>&#13;
    <code class="no">-----END CERTIFICATE-----</code>&#13;
  <code class="nt">requestheader-allowed-names</code><code class="p">:</code> <code class="s">'["aggregator"]'</code>&#13;
  <code class="nt">requestheader-client-ca-file</code><code class="p">:</code> <code class="p-Indicator">|</code>&#13;
    <code class="no">-----BEGIN CERTIFICATE-----</code>&#13;
    <code class="no">...</code>&#13;
    <code class="no">-----END CERTIFICATE-----</code>&#13;
  <code class="nt">requestheader-extra-headers-prefix</code><code class="p">:</code> <code class="s">'["X-Remote-Extra-"]'</code>&#13;
  <code class="nt">requestheader-group-headers</code><code class="p">:</code> <code class="s">'["X-Remote-Group"]'</code>&#13;
  <code class="nt">requestheader-username-headers</code><code class="p">:</code> <code class="s">'["X-Remote-User"]'</code></pre>&#13;
&#13;
<p>With this information, an aggregated custom API server with default settings will authenticate:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Clients using client certificates matching the given <em>client-ca-file</em></p>&#13;
</li>&#13;
<li>&#13;
<p>Clients preauthenticated by the Kubernetes API server whose requests are forwarded using the given <em>requestheader-client-ca-file</em> and whose username and group memberships are stored in the given HTTP headers <code>X-Remote-Group</code> and <code>X-Remote-User</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Last but not least, there is a mechanism called <code>TokenAccessReview</code> that forwards<a data-primary="bearer tokens" data-type="indexterm" id="idm46336852088872"/> bearer tokens (received via the HTTP header <code>Authorization: bearer <em>token</em></code>) back to the Kubernetes API server in order to verify whether they are valid. The token access review mechanism is disabled by default but can optionally be enabled; see <a data-type="xref" href="#aggregated-apiserver-development-options-config">“Options and Config Pattern and Startup Plumbing”</a>.</p>&#13;
&#13;
<p>We will see in the following sections how delegated authentication is actually set up. While we’ve gone into detail about this mechanism here, inside an aggregated custom API server this is mostly done automatically by the <em>k8s.io/apiserver</em> library. But knowing what is going on behind the curtain is certainly valuable, especially where security is involved.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Delegated Authorization" data-type="sect2"><div class="sect2" id="aggregated-authorization">&#13;
<h2>Delegated Authorization</h2>&#13;
&#13;
<p>After<a data-primary="custom API servers" data-secondary="architecture" data-tertiary="delegated authorization" data-type="indexterm" id="idm46336852082968"/><a data-primary="delegated authorization" data-type="indexterm" id="idm46336852081688"/><a data-primary="authorization" data-type="indexterm" id="idm46336852081016"/> authentication has been done, each request must be authorized. Authorization is based on the username and group list. The<a data-primary="access control" data-secondary="role-based access control (RBAC)" data-type="indexterm" id="idm46336852080072"/><a data-primary="role-based access control (RBAC)" data-type="indexterm" id="idm46336852079112"/> default authorization mechanism in Kubernetes is role-based access control (RBAC).</p>&#13;
&#13;
<p>RBAC maps identities to roles, and roles to authorization rules, which finally accept or reject requests. We won’t go into all the details here about RBAC authorization objects like roles and cluster roles, or role bindings and cluster role bindings (see <a data-type="xref" href="ch07.html#crds-rbac">“Getting the Permissions Right”</a> for more). From an architectural point of view it is enough to know that an aggregated custom API server authorizes requests using delegated authorization via <code>SubjectAccessReview</code>s. It does not evaluate RBAC rules itself but instead delegates evaluation to the Kubernetes API server.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336852075992">&#13;
<h5>Why Aggregated API Servers Always Have to Do Another Authorization Step</h5>&#13;
<p>Each request received by the Kubernetes API server and forwarded to an aggregated custom API server passes authentication and authorization (see <a data-type="xref" href="#aggregation-kube-apiserver">Figure 8-1</a>). This means an aggregated custom API server could skip the delegated authorization part for such requests.</p>&#13;
&#13;
<p>But<a data-primary="kube-aggregator" data-type="indexterm" id="idm46336852073176"/><a data-primary="kube-apiserver" data-type="indexterm" id="idm46336852072440"/> this preauthorization is not guaranteed and might go away at any time (there are plans to split <code>kube-aggregator</code> from <code>kube-apiserver</code> for better security and more scalability in the future). In addition, requests going directly to the aggregated custom API server (e.g., authenticated via client certificates or token access review) do not pass the Kubernetes API server and therefore are not preauthorized.</p>&#13;
&#13;
<p>In other words, skipping delegated authorization opens up a security hole and is therefore highly discouraged.</p>&#13;
</div></aside>&#13;
&#13;
<p>Let’s look at delegated authorization in more detail now.</p>&#13;
&#13;
<p>A<a data-primary="subject access review" data-type="indexterm" id="idm46336852068904"/> subject access review is sent from the aggregated custom API server to the Kubernetes API server on a request (if it does not find an answer in its authorization cache). Here is an example of such a review object:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">SubjectAccessReview</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">resourceAttributes</code><code class="p">:</code>&#13;
    <code class="nt">group</code><code class="p">:</code> <code class="l-Scalar-Plain">apps</code>&#13;
    <code class="nt">resource</code><code class="p">:</code> <code class="l-Scalar-Plain">deployments</code>&#13;
    <code class="nt">verb</code><code class="p">:</code> <code class="l-Scalar-Plain">create</code>&#13;
    <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>&#13;
    <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
    <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">example</code>&#13;
  <code class="nt">user</code><code class="p">:</code> <code class="l-Scalar-Plain">michael</code>&#13;
  <code class="nt">groups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">system:authenticated</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">admins</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">authors</code></pre>&#13;
&#13;
<p>The Kubernetes API server receives this from the aggregated custom API server, evaluates the RBAC rules in the cluster, and makes a decision, returning a <code>SubjectAccessReview</code> object with a status field set; for example:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">SubjectAccessReview</code>&#13;
<code class="nt">status</code><code class="p">:</code>&#13;
  <code class="nt">allowed</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
  <code class="nt">denied</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code>&#13;
  <code class="nt">reason</code><code class="p">:</code> <code class="s">"rule</code><code class="nv"> </code><code class="s">foo</code><code class="nv"> </code><code class="s">allowed</code><code class="nv"> </code><code class="s">this</code><code class="nv"> </code><code class="s">request"</code></pre>&#13;
&#13;
<p>Note here that it is possible that both <code>allowed</code> and <code>denied</code> are <code>false</code>. This means that the Kubernetes API server could not make a decision, in which case another <span class="keep-together">authorizer</span> inside an aggregated custom API server can make a decision (API servers implement an authorization chain that is queried one by one, with delegated authorization being one of the authorizers in that chain). This can be used to model nonstandard authorization logic—that is, if in certain cases there are no RBAC rules but an external authorization system is used instead.</p>&#13;
&#13;
<p>Note that for performance reasons, the delegated authorization mechanism maintains a local cache in each aggregated custom API server. By default, it caches 1,024 authorization entries with:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>5</code> minutes expiry for allowed authorization requests</p>&#13;
</li>&#13;
<li>&#13;
<p><code>30</code> seconds expiry for denied authorization requests</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>These values can be customized via <code>--authorization-webhook-cache-authorized-ttl</code> and <code>--authorization-webhook-cache-unauthorized-ttl</code>.</p>&#13;
&#13;
<p>We’ll see in the following sections how delegated authorization is set up in code. Again, as with authentication, inside an aggregated custom API server delegated authorization is mostly done automatically by the <em>k8s.io/apiserver</em> library.<a data-primary="" data-startref="CASarch08" data-type="indexterm" id="idm46336851961592"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing Custom API Servers" data-type="sect1"><div class="sect1" id="aggregated-apiserver-development">&#13;
<h1>Writing Custom API Servers</h1>&#13;
&#13;
<p>In<a data-primary="custom API servers" data-secondary="writing" data-type="indexterm" id="CASwrit08"/> the previous sections we looked at the architecture of aggregated API servers. In this section we want to look at the implementation of an aggregated custom API server in Golang.</p>&#13;
&#13;
<p>The main Kubernetes API server is implemented via the <em>k8s.io/apiserver</em> library. A custom API server will use the very same code. The main difference is that our custom API server will run in-cluster. This means that it can assume that a <code>kube-apiserver</code> is available in the cluster and use it to do delegated authorization and to retrieve other kube-native resources.</p>&#13;
&#13;
<p>We also assume that an <code>etcd</code> cluster is available and ready to be used by the aggregated custom API server. It is not important whether this <code>etcd</code> is dedicated or shared with the Kubernetes API server. Our custom API server will use a different <code>etcd</code> key space to avoid conflicts.</p>&#13;
&#13;
<p>The code examples in this chapter refer to <a href="http://bit.ly/2x9C3gR">the example code on GitHub</a>, so look there for the complete source code. We will show only the most interesting excerpt here, but you can always go to the complete example project, experiment with it, and—very important for learning—run it in a real cluster.</p>&#13;
&#13;
<p>This <code>pizza-apiserver</code> project implements the example API shown in <a data-type="xref" href="#aggregation-example">“Example: A Pizza Restaurant”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Options and Config Pattern and Startup Plumbing" data-type="sect2"><div class="sect2" id="aggregated-apiserver-development-options-config">&#13;
<h2>Options and Config Pattern and Startup Plumbing</h2>&#13;
<ol>&#13;
<li>&#13;
<p>The <em>k8s.io/apiserver</em> library<a data-primary="custom API servers" data-secondary="writing" data-tertiary="options and config pattern" data-type="indexterm" id="idm46336851946328"/> uses an <em>options and config pattern</em> to create a running API server.<a data-primary="option-config pattern" data-type="indexterm" id="idm46336851944488"/></p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>We’ll start with a couple of option structs that are bound to flags. Take them from <em>k8s.io/apiserver</em> and add our custom options. Option structs from <em>k8s.io/apiserver</em> can be tweaked in-code for special use cases, and the provided flags can be applied to a flag set in order to be accessible to the user.</p>&#13;
&#13;
<p>In the <a href="http://bit.ly/2x9C3gR">example</a> we start very simply by basing everything on the <code>RecommendedOptions</code>. These recommended options set up everything as needed for a “normal” aggregated custom API server for simple APIs, like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="o">...</code>&#13;
    <code class="nx">informers</code> <code class="s">"github.com/programming-kubernetes/pizza-apiserver/pkg/</code>&#13;
<code class="s">    generated/informers/externalversions"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">const</code> <code class="nx">defaultEtcdPathPrefix</code> <code class="p">=</code> <code class="s">"/registry/restaurant.programming-kubernetes.info"</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">CustomServerOptions</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">RecommendedOptions</code> <code class="o">*</code><code class="nx">genericoptions</code><code class="p">.</code><code class="nx">RecommendedOptions</code>&#13;
    <code class="nx">SharedInformerFactory</code> <code class="nx">informers</code><code class="p">.</code><code class="nx">SharedInformerFactory</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">NewCustomServerOptions</code><code class="p">(</code><code class="nx">out</code><code class="p">,</code> <code class="nx">errOut</code> <code class="nx">io</code><code class="p">.</code><code class="nx">Writer</code><code class="p">)</code> <code class="o">*</code><code class="nx">CustomServerOptions</code> <code class="p">{</code>&#13;
    <code class="nx">o</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">CustomServerOptions</code><code class="p">{</code>&#13;
        <code class="nx">RecommendedOptions</code><code class="p">:</code> <code class="nx">genericoptions</code><code class="p">.</code><code class="nx">NewRecommendedOptions</code><code class="p">(</code>&#13;
            <code class="nx">defaultEtcdPathPrefix</code><code class="p">,</code>&#13;
            <code class="nx">apiserver</code><code class="p">.</code><code class="nx">Codecs</code><code class="p">.</code><code class="nx">LegacyCodec</code><code class="p">(</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">SchemeGroupVersion</code><code class="p">),</code>&#13;
            <code class="nx">genericoptions</code><code class="p">.</code><code class="nx">NewProcessInfo</code><code class="p">(</code><code class="s">"pizza-apiserver"</code><code class="p">,</code> <code class="s">"pizza-apiserver"</code><code class="p">),</code>&#13;
        <code class="p">),</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">o</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>CustomServerOptions</code> embed <code>RecommendedOptions</code> and add one field on top. <code>NewCustomServerOptions</code> is the constructor that fills the <code>CustomServerOptions</code> struct with default values.</p>&#13;
&#13;
<p>Let’s look into some of the more interesting details:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>defaultEtcdPathPrefix</code> is the <code>etcd</code> prefix for all of our keys. As a key space, we use <em>/registry/pizza-apiserver.programming-kubernetes.info</em>, clearly distinct from Kubernetes keys.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>SharedInformerFactory</code> is the process-wide shared informer factory for our own CRs to avoid unnecessary informers for the same resources (see <a data-type="xref" href="ch03.html#informers-figure">Figure 3-5</a>). Note that it is imported from the generated informer code in our project and not from <code>client-go</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>NewRecommendedOptions</code> sets everything up for an aggregated custom API server with default values.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s take a quick look at <code>NewRecommendedOptions</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="k">return</code> <code class="o">&amp;</code><code class="nx">RecommendedOptions</code><code class="p">{</code>&#13;
    <code class="nx">Etcd</code><code class="p">:</code>           <code class="nx">NewEtcdOptions</code><code class="p">(</code><code class="nx">storagebackend</code><code class="p">.</code><code class="nx">NewDefaultConfig</code><code class="p">(</code><code class="nx">prefix</code><code class="p">,</code> <code class="nx">codec</code><code class="p">)),</code>&#13;
    <code class="nx">SecureServing</code><code class="p">:</code>  <code class="nx">sso</code><code class="p">.</code><code class="nx">WithLoopback</code><code class="p">(),</code>&#13;
    <code class="nx">Authentication</code><code class="p">:</code> <code class="nx">NewDelegatingAuthenticationOptions</code><code class="p">(),</code>&#13;
    <code class="nx">Authorization</code><code class="p">:</code>  <code class="nx">NewDelegatingAuthorizationOptions</code><code class="p">(),</code>&#13;
    <code class="nx">Audit</code><code class="p">:</code>          <code class="nx">NewAuditOptions</code><code class="p">(),</code>&#13;
    <code class="nx">Features</code><code class="p">:</code>       <code class="nx">NewFeatureOptions</code><code class="p">(),</code>&#13;
    <code class="nx">CoreAPI</code><code class="p">:</code>        <code class="nx">NewCoreAPIOptions</code><code class="p">(),</code>&#13;
    <code class="nx">ExtraAdmissionInitializers</code><code class="p">:</code>&#13;
      <code class="kd">func</code><code class="p">(</code><code class="nx">c</code> <code class="o">*</code><code class="nx">server</code><code class="p">.</code><code class="nx">RecommendedConfig</code><code class="p">)</code> <code class="p">([]</code><code class="nx">admission</code><code class="p">.</code><code class="nx">PluginInitializer</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
          <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="kc">nil</code>&#13;
      <code class="p">},</code>&#13;
    <code class="nx">Admission</code><code class="p">:</code>      <code class="nx">NewAdmissionOptions</code><code class="p">(),</code>&#13;
    <code class="nx">ProcessInfo</code><code class="p">:</code>    <code class="nx">processInfo</code><code class="p">,</code>&#13;
    <code class="nx">Webhook</code><code class="p">:</code>        <code class="nx">NewWebhookOptions</code><code class="p">(),</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>All of these can be tweaked if necessary. For example, if a custom default serving port is desired, <code>RecommendedOptions.SecureServing.SecureServingOptions.BindPort</code> can be set.</p>&#13;
&#13;
<p>Let’s briefly go through the existing<a data-primary="custom API servers" data-secondary="writing" data-tertiary="existing option structs" data-type="indexterm" id="idm46336851504824"/> option structs:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>Etcd</code> configures the storage stack that reads and write to <code>etcd</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>SecureServing</code> configures everything around HTTPS (i.e., ports, certificates, etc.)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Authentication</code> sets up delegated authentication as described in <a data-type="xref" href="#aggregated-authentication">“Delegated Authentication and Trust”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Authorization</code> sets up delegated authorization as described in <a data-type="xref" href="#aggregated-authorization">“Delegated Authorization”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Audit</code> sets up the auditing output stack. This is disabled by default, but can be set to output an audit log file or to send audit events to an external backend.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Features</code> configures<a data-primary="feature gate" data-type="indexterm" id="idm46336851381208"/> feature gates of alpha and beta features.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>CoreAPI</code> holds a path to a kubeconfig file to access the main API server. This defaults to using the in-cluster configuration.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Admission</code> is a stack of mutating and validating admission plug-ins that execute for every incoming API request. This can be extended with custom in-code admission plug-ins, or the default admission chain can be tweaked for the custom API server.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>ExtraAdmissionInitializers</code> allows us to add<a data-primary="admission" data-secondary="initializers" data-type="indexterm" id="idm46336851376472"/> more initializers for admission. Initializers implement the plumbing of, for example, informers or clients through the custom API server. See <a data-type="xref" href="#aggregated-apiserver-development-admission">“Admission”</a> for more about custom admission.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>ProcessInfo</code> holds information for event object creation (i.e., a process name and a namespace). We have set it to <code>pizza-apiserver</code> for both values.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Webhook</code> configures how webhooks operate (e.g., general setting for authentication and admission webhook). It is set up with good defaults for a custom API server that runs inside of a cluster. For API servers outside of the cluster, this would be the place to configure how it can reach the webhook.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Options are coupled with flags; that is, they are conventionally on the same abstraction level as flags. As a rule of thumb, options do not hold “running” data structures. They are used during startup and then converted to configuration or server objects, which are then run.</p>&#13;
&#13;
<p>Options can be validated via the <code>Validate() error</code> method. This method will also check that the user-provided flag values make logical sense.</p>&#13;
&#13;
<p>Options can be completed in order to set default values, which should not show up in the flags’ help text but which are necessary to get a complete set of options.</p>&#13;
&#13;
<p>Options are converted to a server configuration (“config”) by the <code>Config() (*apiserver.Config, error)</code> method. This is done by starting with a recommended default configuration and then applying the options to it:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">o</code> <code class="o">*</code><code class="nx">CustomServerOptions</code><code class="p">)</code> <code class="nx">Config</code><code class="p">()</code> <code class="p">(</code><code class="o">*</code><code class="nx">apiserver</code><code class="p">.</code><code class="nx">Config</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">err</code> <code class="o">:=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">RecommendedOptions</code><code class="p">.</code><code class="nx">SecureServing</code><code class="p">.</code><code class="nx">MaybeDefaultWithSelfSignedCerts</code><code class="p">(</code>&#13;
        <code class="s">"localhost"</code><code class="p">,</code> <code class="kc">nil</code><code class="p">,</code> <code class="p">[]</code><code class="nx">net</code><code class="p">.</code><code class="nx">IP</code><code class="p">{</code><code class="nx">net</code><code class="p">.</code><code class="nx">ParseIP</code><code class="p">(</code><code class="s">"127.0.0.1"</code><code class="p">)},</code>&#13;
    <code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"error creating self-signed cert: %v"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="p">[</code><code class="o">...</code> <code class="nx">omitted</code> <code class="nx">o</code><code class="p">.</code><code class="nx">RecommendedOptions</code><code class="p">.</code><code class="nx">ExtraAdmissionInitializers</code> <code class="o">...</code><code class="p">]</code>&#13;
&#13;
    <code class="nx">serverConfig</code> <code class="o">:=</code> <code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">NewRecommendedConfig</code><code class="p">(</code><code class="nx">apiserver</code><code class="p">.</code><code class="nx">Codecs</code><code class="p">)</code>&#13;
    <code class="nx">err</code> <code class="p">=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">RecommendedOptions</code><code class="p">.</code><code class="nx">ApplyTo</code><code class="p">(</code><code class="nx">serverConfig</code><code class="p">,</code> <code class="nx">apiserver</code><code class="p">.</code><code class="nx">Scheme</code><code class="p">);</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">config</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">apiserver</code><code class="p">.</code><code class="nx">Config</code><code class="p">{</code>&#13;
        <code class="nx">GenericConfig</code><code class="p">:</code> <code class="nx">serverConfig</code><code class="p">,</code>&#13;
        <code class="nx">ExtraConfig</code><code class="p">:</code>   <code class="nx">apiserver</code><code class="p">.</code><code class="nx">ExtraConfig</code><code class="p">{},</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="nx">config</code><code class="p">,</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The config created here contains runnable data structures; in other words, configs are runtime objects, in contrast to the options, which correspond to flags. The line <code>o.RecommendedOptions.SecureServing.MaybeDefaultWithSelfSignedCerts</code> creates self-signed certificates in case the user has not passed flags for pregenerated certificates.</p>&#13;
&#13;
<p>As we’ve described, <code>genericapiserver.NewRecommendedConfig</code> returns a default recommended configuration, and <code>RecommendedOptions.ApplyTo</code> changes it according to flags (and other customized options).</p>&#13;
&#13;
<p>The config struct of the <code>pizza-apiserver</code> project itself is just a wrapper around the <code>RecommendedConfig</code> for our example custom API server:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">ExtraConfig</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// Place your custom config here.</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">Config</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">GenericConfig</code> <code class="o">*</code><code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">RecommendedConfig</code>&#13;
    <code class="nx">ExtraConfig</code>   <code class="nx">ExtraConfig</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// CustomServer contains state for a Kubernetes custom api server.</code>&#13;
<code class="kd">type</code> <code class="nx">CustomServer</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">GenericAPIServer</code> <code class="o">*</code><code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">GenericAPIServer</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">completedConfig</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">GenericConfig</code> <code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">CompletedConfig</code>&#13;
    <code class="nx">ExtraConfig</code>   <code class="o">*</code><code class="nx">ExtraConfig</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">CompletedConfig</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// Embed a private pointer that cannot be instantiated outside of</code>&#13;
    <code class="c1">// this package.</code>&#13;
    <code class="o">*</code><code class="nx">completedConfig</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If more state for a running custom API server is necessary, <code>ExtraConfig</code> is the place to put it.</p>&#13;
&#13;
<p>Similarly to option structs, the config has a <code>Complete() CompletedConfig</code> method that sets default values. Because it is necessary to actually call <code>Complete()</code> for the underlying configuration, it is common to enforce that via the type system by introducing the unexported <code>completedConfig</code> data type. The idea here is that only a call to <code>Complete()</code> can turn a <code>Config</code> into a <code>completeConfig</code>. The compiler will complain if this call is not done:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">cfg</code> <code class="o">*</code><code class="nx">Config</code><code class="p">)</code> <code class="nx">Complete</code><code class="p">()</code> <code class="nx">completedConfig</code> <code class="p">{</code>&#13;
    <code class="nx">c</code> <code class="o">:=</code> <code class="nx">completedConfig</code><code class="p">{</code>&#13;
        <code class="nx">cfg</code><code class="p">.</code><code class="nx">GenericConfig</code><code class="p">.</code><code class="nx">Complete</code><code class="p">(),</code>&#13;
        <code class="o">&amp;</code><code class="nx">cfg</code><code class="p">.</code><code class="nx">ExtraConfig</code><code class="p">,</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">c</code><code class="p">.</code><code class="nx">GenericConfig</code><code class="p">.</code><code class="nx">Version</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">version</code><code class="p">.</code><code class="nx">Info</code><code class="p">{</code>&#13;
        <code class="nx">Major</code><code class="p">:</code> <code class="s">"1"</code><code class="p">,</code>&#13;
        <code class="nx">Minor</code><code class="p">:</code> <code class="s">"0"</code><code class="p">,</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">completedConfig</code><code class="p">{</code><code class="o">&amp;</code><code class="nx">c</code><code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Finally, the completed config can be turned into a <code>CustomServer</code> runtime struct via the <code>New()</code> constructor:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// New returns a new instance of CustomServer from the given config.</code>&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">c</code> <code class="nx">completedConfig</code><code class="p">)</code> <code class="nx">New</code><code class="p">()</code> <code class="p">(</code><code class="o">*</code><code class="nx">CustomServer</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">genericServer</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">c</code><code class="p">.</code><code class="nx">GenericConfig</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code>&#13;
        <code class="s">"pizza-apiserver"</code><code class="p">,</code>&#13;
        <code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">NewEmptyDelegate</code><code class="p">(),</code>&#13;
    <code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">s</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">CustomServer</code><code class="p">{</code>&#13;
        <code class="nx">GenericAPIServer</code><code class="p">:</code> <code class="nx">genericServer</code><code class="p">,</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="p">[</code> <code class="o">...</code> <code class="nx">omitted</code> <code class="nx">API</code> <code class="nx">installation</code> <code class="o">...</code><code class="p">]</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">s</code><code class="p">,</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that we have intentionally omitted the API installation part here. We’ll come back to this in <a data-type="xref" href="#aggregated-apiserver-development-api-install">“API Installation”</a> (i.e., how you wire the <em>registries</em> into the custom API server during startup). A registry<a data-primary="registry" data-type="indexterm" id="idm46336850959640"/> implements the API and storage semantics of an API group. We will see this for the restaurant API group in <a data-type="xref" href="#aggregated-apiserver-development-registry">“Registry and Strategy”</a>.</p>&#13;
&#13;
<p>The <code>CustomServer</code> object can finally be started with the <code>Run(stopCh &lt;-chan struct{}) error</code> method. This is called by the <code>Run</code> method of the options in our example. That is, <code>CustomServerOptions.Run</code>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Creates the config</p>&#13;
</li>&#13;
<li>&#13;
<p>Completes the config</p>&#13;
</li>&#13;
<li>&#13;
<p>Creates the <code>CustomServer</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Calls <code>CustomServer.Run</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This is the code:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">o</code> <code class="nx">CustomServerOptions</code><code class="p">)</code> <code class="nx">Run</code><code class="p">(</code><code class="nx">stopCh</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kd">struct</code><code class="p">{})</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="nx">config</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">Config</code><code class="p">()</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">server</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">config</code><code class="p">.</code><code class="nx">Complete</code><code class="p">().</code><code class="nx">New</code><code class="p">()</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">server</code><code class="p">.</code><code class="nx">GenericAPIServer</code><code class="p">.</code><code class="nx">AddPostStartHook</code><code class="p">(</code><code class="s">"start-pizza-apiserver-informers"</code><code class="p">,</code>&#13;
        <code class="kd">func</code><code class="p">(</code><code class="nx">context</code> <code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">PostStartHookContext</code><code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
            <code class="nx">config</code><code class="p">.</code><code class="nx">GenericConfig</code><code class="p">.</code><code class="nx">SharedInformerFactory</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">StopCh</code><code class="p">)</code>&#13;
            <code class="nx">o</code><code class="p">.</code><code class="nx">SharedInformerFactory</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">StopCh</code><code class="p">)</code>&#13;
            <code class="k">return</code> <code class="kc">nil</code>&#13;
        <code class="p">},</code>&#13;
    <code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">server</code><code class="p">.</code><code class="nx">GenericAPIServer</code><code class="p">.</code><code class="nx">PrepareRun</code><code class="p">().</code><code class="nx">Run</code><code class="p">(</code><code class="nx">stopCh</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>PrepareRun()</code> call wires up the OpenAPI specification and might do other post-API-installation operations. After calling it, the <code>Run</code> method starts the actual server. It blocks until <code>stopCh</code> is closed.</p>&#13;
&#13;
<p>This<a data-primary="post-start hook" data-type="indexterm" id="idm46336850769384"/> example also wires a <em>post-start hook</em> named <code>start-pizza-apiserver-informers</code>. As the name suggests, a post-start hook is called after the HTTPS server is up and listening. Here, it starts the shared informer factories.</p>&#13;
&#13;
<p>Note that even local in-process informers of resources provided by the custom API server itself speak via HTTPS to the localhost interface. So it makes sense to start them after the server is up and the HTTPS port is listening.</p>&#13;
&#13;
<p>Also note that the <em>/healthz</em> endpoint returns success only after all post-start hooks have finished successfully.</p>&#13;
&#13;
<p>With all the little plumbing pieces in place, the <code>pizza-apiserver</code> project wraps everything up into a <code>cobra</code> command:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// NewCommandStartCustomServer provides a CLI handler for 'start master' command</code>&#13;
<code class="c1">// with a default CustomServerOptions.</code>&#13;
<code class="kd">func</code> <code class="nx">NewCommandStartCustomServer</code><code class="p">(</code>&#13;
    <code class="nx">defaults</code> <code class="o">*</code><code class="nx">CustomServerOptions</code><code class="p">,</code>&#13;
    <code class="nx">stopCh</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kd">struct</code><code class="p">{},</code>&#13;
<code class="p">)</code> <code class="o">*</code><code class="nx">cobra</code><code class="p">.</code><code class="nx">Command</code> <code class="p">{</code>&#13;
    <code class="nx">o</code> <code class="o">:=</code> <code class="o">*</code><code class="nx">defaults</code>&#13;
    <code class="nx">cmd</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">cobra</code><code class="p">.</code><code class="nx">Command</code><code class="p">{</code>&#13;
        <code class="nx">Short</code><code class="p">:</code> <code class="s">"Launch a custom API server"</code><code class="p">,</code>&#13;
        <code class="nx">Long</code><code class="p">:</code>  <code class="s">"Launch a custom API server"</code><code class="p">,</code>&#13;
        <code class="nx">RunE</code><code class="p">:</code> <code class="kd">func</code><code class="p">(</code><code class="nx">c</code> <code class="o">*</code><code class="nx">cobra</code><code class="p">.</code><code class="nx">Command</code><code class="p">,</code> <code class="nx">args</code> <code class="p">[]</code><code class="kt">string</code><code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
            <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">Complete</code><code class="p">();</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
                <code class="k">return</code> <code class="nx">err</code>&#13;
            <code class="p">}</code>&#13;
            <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">Validate</code><code class="p">();</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
                <code class="k">return</code> <code class="nx">err</code>&#13;
            <code class="p">}</code>&#13;
            <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">Run</code><code class="p">(</code><code class="nx">stopCh</code><code class="p">);</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
                <code class="k">return</code> <code class="nx">err</code>&#13;
            <code class="p">}</code>&#13;
            <code class="k">return</code> <code class="kc">nil</code>&#13;
        <code class="p">},</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">flags</code> <code class="o">:=</code> <code class="nx">cmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">()</code>&#13;
    <code class="nx">o</code><code class="p">.</code><code class="nx">RecommendedOptions</code><code class="p">.</code><code class="nx">AddFlags</code><code class="p">(</code><code class="nx">flags</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">cmd</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With <code>NewCommandStartCustomServer</code> the <code>main()</code> method of the process is pretty <span class="keep-together">simple</span>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">logs</code><code class="p">.</code><code class="nx">InitLogs</code><code class="p">()</code>&#13;
    <code class="k">defer</code> <code class="nx">logs</code><code class="p">.</code><code class="nx">FlushLogs</code><code class="p">()</code>&#13;
&#13;
    <code class="nx">stopCh</code> <code class="o">:=</code> <code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">SetupSignalHandler</code><code class="p">()</code>&#13;
    <code class="nx">options</code> <code class="o">:=</code> <code class="nx">server</code><code class="p">.</code><code class="nx">NewCustomServerOptions</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Stdout</code><code class="p">,</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Stderr</code><code class="p">)</code>&#13;
    <code class="nx">cmd</code> <code class="o">:=</code> <code class="nx">server</code><code class="p">.</code><code class="nx">NewCommandStartCustomServer</code><code class="p">(</code><code class="nx">options</code><code class="p">,</code> <code class="nx">stopCh</code><code class="p">)</code>&#13;
    <code class="nx">cmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">().</code><code class="nx">AddGoFlagSet</code><code class="p">(</code><code class="nx">flag</code><code class="p">.</code><code class="nx">CommandLine</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">cmd</code><code class="p">.</code><code class="nx">Execute</code><code class="p">();</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">klog</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note especially the call to <code>SetupSignalHandler</code>: it wires Unix signal handling. On <code>SIGINT</code> (triggered when you press Ctrl-C in a terminal) and <code>SIGKILL</code>, the stop channel is closed. The stop channel is passed to the running custom API server, and it shuts down when the stop channel is closed. Hence, the main loop will initiate a shutdown when one of the signals is received. This shutdown is graceful in the sense that running requests are finished (for up to 60 seconds by default) before termination. It also makes sure that all requests are sent to the audit backend and no audit data is dropped. After all that, <code>cmd.Execute()</code> will return and the process will terminate.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The First Start" data-type="sect2"><div class="sect2" id="aggregated-apiserver-development-first-start">&#13;
<h2>The First Start</h2>&#13;
&#13;
<p>Now<a data-primary="custom API servers" data-secondary="writing" data-tertiary="first start" data-type="indexterm" id="idm46336850418104"/> we have everything in place to start the custom API server for the first time. Assuming you have a cluster configured in <em>~/.kube/config</em>, you can use it for delegated authentication and authorization:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code><code class="nb">cd</code> <code class="nv">$GOPATH</code>/src/github.com/programming-kubernetes/pizza-apiserver&#13;
<code class="nv">$ </code>etcd <code class="p">&amp;</code>&#13;
<code class="nv">$ </code>go run . --etcd-servers localhost:2379 <code class="se">\</code>&#13;
    --authentication-kubeconfig ~/.kube/config <code class="se">\</code>&#13;
    --authorization-kubeconfig ~/.kube/config <code class="se">\</code>&#13;
    --kubeconfig ~/.kube/config&#13;
I0331 11:33:25.702320   <code class="m">64244</code> plugins.go:158<code class="o">]</code>&#13;
  Loaded <code class="m">3</code> mutating admission controller<code class="o">(</code>s<code class="o">)</code> successfully in the following order:&#13;
     NamespaceLifecycle,MutatingAdmissionWebhook,PizzaToppings.&#13;
I0331 11:33:25.702344   <code class="m">64244</code> plugins.go:161<code class="o">]</code>&#13;
  Loaded <code class="m">1</code> validating admission controller<code class="o">(</code>s<code class="o">)</code> successfully in the following order:&#13;
     ValidatingAdmissionWebhook.&#13;
I0331 11:33:25.714148   <code class="m">64244</code> secure_serving.go:116<code class="o">]</code> Serving securely on <code class="o">[</code>::<code class="o">]</code>:443</pre>&#13;
&#13;
<p>It will start up and start serving the generic API endpoints:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>curl -k https://localhost:443/healthz&#13;
ok</pre>&#13;
&#13;
<p>We can also list the<a data-primary="discovery" data-secondary="endpoint" data-type="indexterm" id="idm46336850313912"/> discovery endpoint, but the result is not very satisfying yet—we have not created an API, so the discovery is empty:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>curl -k https://localhost:443/apis&#13;
<code class="o">{</code>&#13;
  <code class="s2">"kind"</code>: <code class="s2">"APIGroupList"</code>,&#13;
  <code class="s2">"groups"</code>: <code class="o">[]</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Let’s take a look from a higher level:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We have started a custom API server with the recommended options and config.</p>&#13;
</li>&#13;
<li>&#13;
<p>We have a standard handler chain that includes delegated authentication, delegated authorization, and auditing.</p>&#13;
</li>&#13;
<li>&#13;
<p>We have an HTTPS server running and serving requests for the generic endpoints: <em>/logs</em>, <em>/metrics</em>, <em>/version</em>, <em>/healthz</em>, and <em>/apis</em>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="#aggregation-kube-apiserver_without">Figure 8-3</a> shows this from 10,000 feet.</p>&#13;
&#13;
<figure><div class="figure" id="aggregation-kube-apiserver_without">&#13;
<img alt="The custom API server without APIs" src="assets/prku_0803.png"/>&#13;
<h6><span class="label">Figure 8-3. </span>The custom API server without APIs</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Internal Types and Conversion" data-type="sect2"><div class="sect2" id="aggregated-apiserver-development-internal-types">&#13;
<h2>Internal Types and Conversion</h2>&#13;
&#13;
<p>Now<a data-primary="custom API servers" data-secondary="writing" data-tertiary="internal types and conversion" data-type="indexterm" id="idm46336850296824"/> that we’ve set up a running custom API server, it’s time to actually implement APIs. Before doing so, we have to understand API versions and how they are handled inside of an API server.</p>&#13;
&#13;
<p>Every API server serves a number of resources and versions (see <a data-type="xref" href="ch02.html#gvr">Figure 2-3</a>). Some resources have multiple versions. To make multiple versions of a resource possible, the API server<a data-primary="conversion" data-type="indexterm" id="idm46336850293896"/> converts between versions.</p>&#13;
&#13;
<p>To avoid quadratic growth of necessary conversions between versions, API servers use an<a data-primary="internal version" data-type="indexterm" id="idm46336850292488"/> <em>internal version</em> when implementing the actual API logic. The internal version is also often called<a data-primary="hub version" data-type="indexterm" id="idm46336850291240"/> <em>hub version</em> because it is a kind of hub that every other version is converted to and from (see <a data-type="xref" href="#aggregation-version-star">Figure 8-4</a>). The internal API logic is implemented just once for that hub version.</p>&#13;
&#13;
<figure><div class="figure" id="aggregation-version-star">&#13;
<img alt="Conversion from and to the hub version" src="assets/prku_0804.png"/>&#13;
<h6><span class="label">Figure 8-4. </span>Conversion from and to the hub version</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#aggregation-conversions-figure">Figure 8-5</a> shows how the API servers make use of the internal version in the life-cycle of an API request:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The user sends a request using a specific version (e.g., <code>v1</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>The API server decodes the payload and converts it to the internal version.</p>&#13;
</li>&#13;
<li>&#13;
<p>The API server passes the internal version through admission and validation.</p>&#13;
</li>&#13;
<li>&#13;
<p>The API logic is implemented for internal versions in the registry.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>etcd</code> reads and writes the versioned object (e.g., <code>v2</code>—the storage version); that is, it converts from and to the internal version.</p>&#13;
</li>&#13;
<li>&#13;
<p>Finally, the result is converted to the request version, in this case, <code>v1</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="aggregation-conversions-figure">&#13;
<img alt="Conversion of API objects during the life-cycle of a request" src="assets/prku_0805.png"/>&#13;
<h6><span class="label">Figure 8-5. </span>Conversion of API objects during the lifecycle of a request</h6>&#13;
</div></figure>&#13;
&#13;
<p>On each edge between the internal hub version and the<a data-primary="external version" data-type="indexterm" id="idm46336850259608"/> external version, a conversion takes place. In <a data-type="xref" href="#aggregation-conversions-points">Figure 8-6</a>, you can count the number of conversions per request handler. In a writing operation (like creation and update), at least four conversions are done, and even more if admission webhooks are deployed in the cluster. As you can see, conversion is a crucial operation in every API implementation.</p>&#13;
&#13;
<figure><div class="figure" id="aggregation-conversions-points">&#13;
<img alt="Conversions and Defaulting during the life-cycle of a request" src="assets/prku_0806.png"/>&#13;
<h6><span class="label">Figure 8-6. </span>Conversions and defaulting during the lifecycle of a request</h6>&#13;
</div></figure>&#13;
&#13;
<p>In<a data-primary="defaulting" data-type="indexterm" id="idm46336850255144"/> addition to conversion, <a data-type="xref" href="#aggregation-conversions-points">Figure 8-6</a> also shows when <em>defaulting</em> takes place. Defaulting is the process of filling in unspecified field values. Defaulting is highly coupled with conversion, and is always done on the external version when it comes in from the user’s request, from <code>etcd</code> or from an admission webhook, but never when converted from the hub to the external version.</p>&#13;
<div data-type="warning" epub:type="warning" id="aggregation-warning-conversion-is-hard"><h6>Warning</h6>&#13;
<p>Conversion<a data-primary="roundtrippable conversion" data-type="indexterm" id="idm46336850250712"/> is crucial for the API server mechanics. It is also crucial that all conversions (back and forth) must be correct in the sense of being <em>roundtrippable</em>. Roundtrippable means that we can convert back and forth in the version graph (<a data-type="xref" href="#aggregation-version-star">Figure 8-4</a>) starting with random values, and we never lose any information; that is, conversions are bijective, or one-to-one. For example, we must be able to go from a random (but valid) <code>v1</code> object to the internal hub type, then to <code>v1alpha1</code>, back to the internal hub type, and then back to <code>v1</code>. The resulting object must be equivalent to the original.</p>&#13;
&#13;
<p>Making types roundtrippable often requires a lot of thought; it nearly always drives the API design of new versions and also influences the extension of old types in order to store the information that new versions carry.</p>&#13;
&#13;
<p>In short: getting roundtripping right is hard—very hard at times. See <a data-type="xref" href="#aggregated-apiserver-roundtrip">“Roundtrip Testing”</a> to learn how roundtripping can be tested effectively.</p>&#13;
</div>&#13;
&#13;
<p>Defaulting logic can changed during the lifecycle of an API server. Imagine you add a new field to a type. The user might have old objects stored on disk, or the <code>etcd</code> may have old objects. If that new field has a default, this field value is set when the old, stored objects are sent to the API server, or when the user retrieves one of the old objects from <code>etcd</code>. It looks like the new field has existed forever, while in reality the defaulting process in the API server sets the field values during the processing of the request.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing the API Types" data-type="sect2"><div class="sect2" id="aggregated-apiserver-defining-API">&#13;
<h2>Writing the API Types</h2>&#13;
&#13;
<p>As<a data-primary="custom API servers" data-secondary="writing" data-tertiary="writing API types" data-type="indexterm" id="idm46336850241176"/> we have seen, to add an API to the custom API server, we have to write the internal hub version types and the external version types and convert between them. This is what we’ll look at now for the <a href="http://bit.ly/2x9C3gR">pizza example project</a>.</p>&#13;
&#13;
<p>API types are traditionally placed into the <em>pkg/apis/<code>group-name</code></em> package of the project with <em>pkg/apis/<code>group-name</code>/types.go</em> for internal types and <em>pkg/apis/<code>group-name</code>/<code>version</code>/types.go</em> for the external versions). So, for our example, <em>pkg/apis/restaurant</em>, <em>pkg/apis/restaurant/v1alpha1/types.go</em>, and <em>pkg/apis/restaurant/v1beta1/types.go</em>.</p>&#13;
&#13;
<p>Conversions will be created at <em>pkg/apis/<code>group-name</code>/<code>version</code>/zz_generated.conversion.go</em> (for <code>conversion-gen</code> output) and <em>pkg/apis/<code>group-name</code>/<code>version</code>/conversion.go</em> for custom conversions written by the developer.</p>&#13;
&#13;
<p>In a similar way, defaulting code will be created for <code>defaulter-gen</code> output at <em>pkg/apis/<code>group-name</code>/<code>version</code>/zz_generated.defaults.go</em> and at <em>pkg/apis/<code>group-name</code><span class="keep-together">/<code>version</code>/defaults.go</span></em> for custom defaulting code written by the developer. We have both <em>pkg/apis/restaurant/v1alpha1/defaults.go</em> and <em>pkg/apis/restaurant/v1beta1/defaults.go</em> in our example.</p>&#13;
&#13;
<p>We go into more detail about conversion and defaulting in <a data-type="xref" href="#aggregated-apiserver-conversion">“Conversions”</a> and <a data-type="xref" href="#aggregated-apiserver-defaulting">“Defaulting”</a>.</p>&#13;
&#13;
<p>With the exception of conversion and defaulting, we’ve seen most of this process already for CustomResourceDefinitions in <a data-type="xref" href="ch04.html#anatomy-of-CRD-types">“Anatomy of a type”</a>. Native types for the external versions in our custom API server are defined exactly the same way.</p>&#13;
&#13;
<p>In addition, we have <em>pkg/apis/<code>group-name</code>/types.go</em> for the internal types, the hub types. The main difference is that in the latter the <code>SchemeGroupVersion</code> in the <em>register.go</em> file references <code>runtime.APIVersionInternal</code> (which is a shortcut for <code>"__internal"</code>).</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// SchemeGroupVersion is group version used to register these objects</code>&#13;
<code class="kd">var</code> <code class="nx">SchemeGroupVersion</code> <code class="p">=</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersion</code><code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="nx">GroupName</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code>&#13;
<code class="nx">runtime</code><code class="p">.</code><code class="nx">APIVersionInternal</code><code class="p">}</code></pre>&#13;
&#13;
<p>Another difference between <code>pkg/apis/<em>group-name</em>/types.go</code> and the external type files is the lack of JSON and protobuf tags.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>JSON tags are used by some generators to detect whether a <em>types.go</em> file is for an external version or the internal version. So always drop those tags when copying and pasting external types in order to create or update the internal types.</p>&#13;
</div>&#13;
&#13;
<p>Last but not least, there is a helper to install all versions of an API group into a scheme. This helper is traditionally placed in <em>pkg/apis/<code>group-name</code>/install/install.go</em>. For our custom API server <em>pkg/apis/restaurant/install/install.go</em>, it looks as simple as this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Install registers the API group and adds types to a scheme</code>&#13;
<code class="kd">func</code> <code class="nx">Install</code><code class="p">(</code><code class="nx">scheme</code> <code class="o">*</code><code class="nx">runtime</code><code class="p">.</code><code class="nx">Scheme</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">utilruntime</code><code class="p">.</code><code class="nx">Must</code><code class="p">(</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">AddToScheme</code><code class="p">(</code><code class="nx">scheme</code><code class="p">))</code>&#13;
    <code class="nx">utilruntime</code><code class="p">.</code><code class="nx">Must</code><code class="p">(</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">AddToScheme</code><code class="p">(</code><code class="nx">scheme</code><code class="p">))</code>&#13;
    <code class="nx">utilruntime</code><code class="p">.</code><code class="nx">Must</code><code class="p">(</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">AddToScheme</code><code class="p">(</code><code class="nx">scheme</code><code class="p">))</code>&#13;
    <code class="nx">utilruntime</code><code class="p">.</code><code class="nx">Must</code><code class="p">(</code><code class="nx">scheme</code><code class="p">.</code><code class="nx">SetVersionPriority</code><code class="p">(</code>&#13;
        <code class="nx">v1beta1</code><code class="p">.</code><code class="nx">SchemeGroupVersion</code><code class="p">,</code>&#13;
        <code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">SchemeGroupVersion</code><code class="p">,</code>&#13;
    <code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because we have multiple versions, the priority has to be defined. This order will be used to determine the default storage version of the resource. It used to also play a role in version selection in internal clients (clients that return internal version objects; refer back to the note <a data-type="xref" href="ch03.html#internal-clients">“Versioned Clients and Internal Clients in the Past”</a>). But internal clients are deprecated and are going away. Even code inside an API server will use an external version client in the future.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conversions" data-type="sect2"><div class="sect2" id="aggregated-apiserver-conversion">&#13;
<h2>Conversions</h2>&#13;
&#13;
<p>Conversion<a data-primary="custom API servers" data-secondary="writing" data-tertiary="conversions" data-type="indexterm" id="idm46336850093512"/><a data-primary="conversion" data-secondary="conversion-gen" data-type="indexterm" id="idm46336850092232"/><a data-primary="generator" data-secondary="conversion-gen" data-type="indexterm" id="idm46336850091288"/> takes an object in one version and converts it into an object in another version. Conversion is implemented through conversion functions, some of them manually written (placed into <em>pkg/apis/<code>group-name</code>/<code>version</code>/conversion.go</em> by convention), and others autogenerated by <a href="http://bit.ly/31RewiP"><code>conversion-gen</code></a> (placed by convention into <em>pkg/apis/<code>group-name</code>/<code>version</code>/zz_generated.conversion.go</em>).</p>&#13;
&#13;
<p>Conversion is initiated via a scheme (see <a data-type="xref" href="ch03.html#scheme">“Scheme”</a>) using the <code>Convert()</code> method, passing the source object <code>in</code> and the target object <code>out</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">s</code> <code class="o">*</code><code class="nx">Scheme</code><code class="p">)</code> <code class="nx">Convert</code><code class="p">(</code><code class="nx">in</code><code class="p">,</code> <code class="nx">out</code> <code class="kd">interface</code><code class="p">{},</code> <code class="nx">context</code> <code class="kd">interface</code><code class="p">{})</code> <code class="kt">error</code></pre>&#13;
&#13;
<p>The <code>context</code> is described as follows:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting" id="aggregated-apiserver-conversion-context"><code class="c1">// ...an optional field that callers may use to pass info to conversion functions.</code></pre>&#13;
&#13;
<p>It is used only in very special cases and is usually <code>nil</code>. Later in the chapter we will look at the conversion function scope, which allows us to access this context from within conversion functions.</p>&#13;
&#13;
<p>To do the actual conversion, the scheme knows about all the Golang API types, their<a data-primary="GroupVersionKind (GVK)" data-type="indexterm" id="idm46336849998680"/> GroupVersionKinds, and the conversion functions between GroupVersionKinds. For this, <code>conversion-gen</code> registers generated conversion functions via the local scheme builder. In our example custom API server, the <em>zz_generated.conversion.go</em> file starts like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">localSchemeBuilder</code><code class="p">.</code><code class="nx">Register</code><code class="p">(</code><code class="nx">RegisterConversions</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// RegisterConversions adds conversion functions to the given scheme.</code>&#13;
<code class="c1">// Public to allow building arbitrary schemes.</code>&#13;
<code class="kd">func</code> <code class="nx">RegisterConversions</code><code class="p">(</code><code class="nx">s</code> <code class="o">*</code><code class="nx">runtime</code><code class="p">.</code><code class="nx">Scheme</code><code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">s</code><code class="p">.</code><code class="nx">AddGeneratedConversionFunc</code><code class="p">(</code>&#13;
        <code class="p">(</code><code class="o">*</code><code class="nx">Topping</code><code class="p">)(</code><code class="kc">nil</code><code class="p">),</code>&#13;
        <code class="p">(</code><code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">Topping</code><code class="p">)(</code><code class="kc">nil</code><code class="p">),</code>&#13;
        <code class="kd">func</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code> <code class="kd">interface</code><code class="p">{},</code> <code class="nx">scope</code> <code class="nx">conversion</code><code class="p">.</code><code class="nx">Scope</code><code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
            <code class="k">return</code> <code class="nx">Convert_v1alpha1_Topping_To_restaurant_Topping</code><code class="p">(</code>&#13;
                <code class="nx">a</code><code class="p">.(</code><code class="o">*</code><code class="nx">Topping</code><code class="p">),</code>&#13;
                <code class="nx">b</code><code class="p">.(</code><code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">Topping</code><code class="p">),</code>&#13;
                <code class="nx">scope</code><code class="p">,</code>&#13;
            <code class="p">)</code>&#13;
        <code class="p">},</code>&#13;
    <code class="p">);</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
    <code class="o">...</code>&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="o">...</code></pre>&#13;
&#13;
<p>The function <code>Convert_v1alpha1_Topping_To_restaurant_Topping()</code> is generated. It takes a <code>v1alpha1</code> object and converts it to the internal type.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The preceding complicated type conversion turns<a data-primary="conversion" data-secondary="function" data-type="indexterm" id="idm46336849886024"/> the typed conversion function into a uniformly typed <code>func(a, b interface{}, scope conversion.Scope) error</code>. The scheme uses the latter types because it can call them without the use of reflection. Reflection is slow due to the many necessary allocations.</p>&#13;
</div>&#13;
&#13;
<p>The manually written conversions in <em>conversion.go</em> take precedence during generation in the sense that <code>conversion-gen</code> skips generation for types if it finds a manually written function in the packages with the <em>Convert_<code>source-package-basename_Kind</code>To_<code>target-package-basename</code>_Kind</em> conversion function<a data-primary="conversion" data-secondary="function" data-tertiary="naming pattern" data-type="indexterm" id="idm46336849881448"/> naming pattern. For example:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">Convert_v1alpha1_PizzaSpec_To_restaurant_PizzaSpec</code><code class="p">(</code>&#13;
    <code class="nx">in</code> <code class="o">*</code><code class="nx">PizzaSpec</code><code class="p">,</code>&#13;
    <code class="nx">out</code> <code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">PizzaSpec</code><code class="p">,</code>&#13;
    <code class="nx">s</code> <code class="nx">conversion</code><code class="p">.</code><code class="nx">Scope</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="o">...</code>&#13;
&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the simplest case, conversion functions just copy over values from the source to the target object. But for the previous example, which converts a <code>v1alpha1</code> pizza specification to the internal type, simple copying is not enough. We have to adapt the different structure, which actually looks like the following:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">Convert_v1alpha1_PizzaSpec_To_restaurant_PizzaSpec</code><code class="p">(</code>&#13;
    <code class="nx">in</code> <code class="o">*</code><code class="nx">PizzaSpec</code><code class="p">,</code>&#13;
    <code class="nx">out</code> <code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">PizzaSpec</code><code class="p">,</code>&#13;
    <code class="nx">s</code> <code class="nx">conversion</code><code class="p">.</code><code class="nx">Scope</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="nx">idx</code> <code class="o">:=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{}</code>&#13;
    <code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">top</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">in</code><code class="p">.</code><code class="nx">Toppings</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">duplicate</code> <code class="o">:=</code> <code class="nx">idx</code><code class="p">[</code><code class="nx">top</code><code class="p">];</code> <code class="nx">duplicate</code> <code class="p">{</code>&#13;
            <code class="nx">out</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Quantity</code><code class="o">++</code>&#13;
            <code class="k">continue</code>&#13;
        <code class="p">}</code>&#13;
        <code class="nx">idx</code><code class="p">[</code><code class="nx">top</code><code class="p">]</code> <code class="p">=</code> <code class="nb">len</code><code class="p">(</code><code class="nx">out</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">)</code>&#13;
        <code class="nx">out</code><code class="p">.</code><code class="nx">Toppings</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">out</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">,</code> <code class="nx">restaurant</code><code class="p">.</code><code class="nx">PizzaTopping</code><code class="p">{</code>&#13;
            <code class="nx">Name</code><code class="p">:</code> <code class="nx">top</code><code class="p">,</code>&#13;
            <code class="nx">Quantity</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
        <code class="p">})</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Clearly, no code generation can be so clever as to foresee what the user intended when defining these different types.</p>&#13;
&#13;
<p>Note that during conversion the source object must never be mutated. But it is completely normal and, often for performance reasons, highly recommended to reuse data structures of the source in the target object if the types match.</p>&#13;
&#13;
<p>This is so important that we reiterate it in a warning, because it has implications not only for the implementation of conversion but also for callers of conversions and consumers of conversion output.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Conversion functions must not mutate the source object, but the output is allowed to share data structures with the source. This means that consumers of conversion output have to make sure not to mutate an object if the original object must not be mutated.</p>&#13;
&#13;
<p>For example, assume you have a <code>pod *core.Pod</code> in the internal version, and you convert it to <code>v1</code> as <code>podv1 *corev1.Pod</code>, and mutate the resulting <code>podv1</code>. This might also mutate the original <code>pod</code>. If the <code>pod</code> came from an informer, this is highly dangerous because informers have a shared cache and mutating <code>pod</code> makes the cache <span class="keep-together">inconsistent</span>.</p>&#13;
&#13;
<p>So, be aware of this property of conversion and do deep copies if necessary to avoid undesired and potentially dangerous mutations.</p>&#13;
</div>&#13;
&#13;
<p>While this sharing of data structures leads to some risk, it also can avoid unnecessary allocations in many situations. Generated code goes so far that the generator compares source and target structs and uses Golang’s <code>unsafe</code> packages to convert pointers to structs of the same memory layout via a simple type conversion. Because the internal type and the <code>v1beta1</code> types for a pizza in our example have the same memory layout, we get this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">autoConvert_restaurant_PizzaSpec_To_v1beta1_PizzaSpec</code><code class="p">(</code>&#13;
    <code class="nx">in</code> <code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">PizzaSpec</code><code class="p">,</code>&#13;
    <code class="nx">out</code> <code class="o">*</code><code class="nx">PizzaSpec</code><code class="p">,</code>&#13;
    <code class="nx">s</code> <code class="nx">conversion</code><code class="p">.</code><code class="nx">Scope</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="nx">out</code><code class="p">.</code><code class="nx">Toppings</code> <code class="p">=</code> <code class="o">*</code><code class="p">(</code><code class="o">*</code><code class="p">[]</code><code class="nx">PizzaTopping</code><code class="p">)(</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Pointer</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">in</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">))</code>&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>On the machine language level, this is a NOOP and therefore as fast as it can get. It avoids allocating a slice in this case and copying item by item from <code>in</code> to <code>out</code>.</p>&#13;
&#13;
<p id="aggregated-apiserver-conversion-scope">Last but not least, some words about the third argument of conversion functions: the conversion scope <code>conversion.Scope</code>.</p>&#13;
&#13;
<p>The conversion scope provides access to a number of conversion metalevel values. For example, it allows us to access the <code>context</code> value that is passed to the scheme’s <code>Convert(in, out interface{}, context interface{}) error</code> method via:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">s</code><code class="p">.</code><code class="nx">Meta</code><code class="p">().</code><code class="nx">Context</code></pre>&#13;
&#13;
<p>It also allows us to call the scheme conversion for subtypes via <code>s.Convert</code>, or without considering the registered conversion functions at all via <code>s.DefaultConvert</code>.</p>&#13;
&#13;
<p>In most conversion cases, though, there is no need to use the scope at all. You can just ignore its existence for the sake of simplicity until you hit a tricky situation where more context than the source and target object is necessary.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defaulting" data-type="sect2"><div class="sect2" id="aggregated-apiserver-defaulting">&#13;
<h2>Defaulting</h2>&#13;
&#13;
<p>Defaulting<a data-primary="custom API servers" data-secondary="writing" data-tertiary="defaulting" data-type="indexterm" id="idm46336849639864"/><a data-primary="defaulting" data-type="indexterm" id="idm46336849637000"/> is the step in an API request’s lifecycle that sets default values for omitted fields in incoming objects (from the client or from <code>etcd</code>). For example, a pod has a <code>restartPolicy</code> field. If the user does not specify it, a value will default to <code>Always</code>.</p>&#13;
&#13;
<p>Imagine we are using a very old Kubernetes version around the year 2014. The field <code>restartPolicy</code> was just introduced to the system in the latest release at that time. After an upgrade of your cluster, there is a pod in <code>etcd</code> without the <code>restartPolicy</code> field. A <code>kubectl get pod</code> would<a data-primary="kubectl get pod" data-type="indexterm" id="idm46336849632296"/> read the old pod from <code>etcd</code> and the defaulting code would add the default value <code>Always</code>. From the user’s point of view, magically the old pod suddenly has the new <code>restartPolicy</code> field.</p>&#13;
&#13;
<p>Refer back to <a data-type="xref" href="#aggregation-conversions-points">Figure 8-6</a> to see where defaulting takes place today in the Kubernetes request pipeline. Note that defaulting is done only for external types, not internal types.</p>&#13;
&#13;
<p>Now let’s look at the code that does defaulting. Defaulting is initiated by the <em><span class="keep-together">k8s.io/apiserver</span></em> code via the scheme, similarly to conversion. Hence, we have to register defaulting functions into the scheme for our custom types.</p>&#13;
&#13;
<p>Again, similarly to conversions, most defaulting code is just generated with the <a href="http://bit.ly/2J108vK"><code>defaulter-gen</code></a> binary. It traverses API types and creates defaulting functions in <em>pkg/apis/<code>group-name</code>/<code>version</code>/zz_generated.defaults.go</em>. The code doesn’t do anything by default other than calling defaulting functions for the substructures.</p>&#13;
&#13;
<p>You can define your own defaulting logic by following the defaulting function naming pattern <code>SetDefaults<em>Kind</em></code>:</p>&#13;
<pre data-code-language="go" data-type="programlisting">&#13;
<code class="kd">func</code><code> </code><code class="nx">SetDefaults</code><em><code class="nx">Kind</code></em><code class="p">(</code><code class="nx">obj</code><code> </code><code class="o">*</code><em><code class="nx">Type</code></em><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="o">...</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>In addition, and unlike with conversions, we have to call the registration of the generated function on the local scheme builder manually. This is unfortunately not done automatically:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">localSchemeBuilder</code><code class="p">.</code><code class="nx">Register</code><code class="p">(</code><code class="nx">RegisterDefaults</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, <code>RegisterDefaults</code> is generated inside package  <em>pkg/apis/<code>group-name</code>/<code>version</code><span class="keep-together">/zz_generated.defaults.go</span></em>.</p>&#13;
&#13;
<p>For defaulting code, it is crucial to know when a field was set by the user and when it wasn’t. This is not that clear in many cases.</p>&#13;
&#13;
<p>Golang has zero values for every type and sets them if a field is not found in the passed JSON or protobuf. Imagine a default of <code>true</code> for a boolean field <code>foo</code>. The zero value is <code>false</code>. Unfortunately, it is not clear whether <code>false</code> was set due to the user’s input or because <code>false</code> is just the zero value of booleans.</p>&#13;
&#13;
<p>To avoid this situation, often a pointer type must be used in the Golang API types (e.g., <code>*bool</code> in the preceding case). A user-provided <code>false</code> would lead to a non-<code>nil</code> boolean pointer to a <code>false</code> value, and a user-provided <code>true</code> would lead to the non-<code>nil</code> boolean pointer and a <code>true</code> value. A not-provided field leads to <code>nil</code>. This can be detected in the defaulting code:</p>&#13;
<pre data-code-language="go" data-type="programlisting">&#13;
<code class="kd">func</code><code> </code><code class="nx">SetDefaults</code><em><code class="nx">Kind</code></em><code class="p">(</code><code class="nx">obj</code><code> </code><code class="o">*</code><em><code class="nx">Type</code></em><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">if</code><code> </code><code class="nx">obj</code><code class="p">.</code><code class="nx">Foo</code><code> </code><code class="o">==</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="nx">x</code><code> </code><code class="o">:=</code><code> </code><code class="kc">true</code><code>&#13;
</code><code>        </code><code class="nx">obj</code><code class="p">.</code><code class="nx">Foo</code><code> </code><code class="p">=</code><code> </code><code class="o">&amp;</code><code class="nx">x</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>This gives the desired semantics: “foo defaults to true.”</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>This trick of using a pointer works for primitive types like strings. For maps and arrays, it is often hard to reach roundtrippability without identifying <code>nil</code> maps/arrays and empty maps/arrays. Most defaulters for maps and arrays in Kubernetes therefore apply the default in both cases, working around encoding and decoding bugs.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Roundtrip Testing" data-type="sect2"><div class="sect2" id="aggregated-apiserver-roundtrip">&#13;
<h2>Roundtrip Testing</h2>&#13;
&#13;
<p>Getting conversions<a data-primary="custom API servers" data-secondary="writing" data-tertiary="roundtrip testing" data-type="indexterm" id="idm46336849403896"/><a data-primary="roundtrippable conversion" data-type="indexterm" id="idm46336849402616"/> right is hard. Roundtrip tests are an essential tool to check automatically in a randomized test that conversions behave as planned and do not lose data when converting from and to all known group versions.</p>&#13;
&#13;
<p>Roundtrip tests are usually placed with the <em>install.go</em> file (for example, into <em>pkg/apis/restaurant/install/roundtrip_test.go</em>) and just call the roundtrip test functions from API Machinery:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="o">...</code>&#13;
    <code class="s">"k8s.io/apimachinery/pkg/api/apitesting/roundtrip"</code>&#13;
    <code class="nx">restaurantfuzzer</code> <code class="s">"github.com/programming-kubernetes/pizza-apiserver/pkg/apis/</code>&#13;
<code class="s">    restaurant/fuzzer"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">TestRoundTripTypes</code><code class="p">(</code><code class="nx">t</code> <code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">T</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">roundtrip</code><code class="p">.</code><code class="nx">RoundTripTestForAPIGroup</code><code class="p">(</code><code class="nx">t</code><code class="p">,</code> <code class="nx">Install</code><code class="p">,</code> <code class="nx">restaurantfuzzer</code><code class="p">.</code><code class="nx">Funcs</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Internally, the <code>RoundTripTestForAPIGroup</code> call installs the API group into a temporary scheme using the <code>Install</code> functions. Then it creates random objects in the <span class="keep-together">internal</span> version using the given fuzzer, and then converts them to some external version and back to internal. The resulting objects must be equivalent to the original. This test is done hundreds or thousand of times with all external versions.</p>&#13;
&#13;
<p>A <em>fuzzer</em> is<a data-primary="fuzzers" data-type="indexterm" id="idm46336849347448"/> a function that return a slice of randomizer functions for the internal types and their subtypes. In our example, the fuzzer is placed into the package <span class="keep-together"><em>pkg/apis/restaurant/fuzzer/fuzzer.go</em></span> and contains a randomizer for the spec struct:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Funcs returns the fuzzer functions for the restaurant api group.</code>&#13;
<code class="kd">var</code> <code class="nx">Funcs</code> <code class="p">=</code> <code class="kd">func</code><code class="p">(</code><code class="nx">codecs</code> <code class="nx">runtimeserializer</code><code class="p">.</code><code class="nx">CodecFactory</code><code class="p">)</code> <code class="p">[]</code><code class="kd">interface</code><code class="p">{}</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">[]</code><code class="kd">interface</code><code class="p">{}{</code>&#13;
        <code class="kd">func</code><code class="p">(</code><code class="nx">s</code> <code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">PizzaSpec</code><code class="p">,</code> <code class="nx">c</code> <code class="nx">fuzz</code><code class="p">.</code><code class="nx">Continue</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="nx">c</code><code class="p">.</code><code class="nx">FuzzNoCustom</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="c1">// fuzz first without calling this function again</code>&#13;
&#13;
            <code class="c1">// avoid empty Toppings because that is defaulted</code>&#13;
            <code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code> <code class="p">{</code>&#13;
                <code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code> <code class="p">=</code> <code class="p">[]</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">PizzaTopping</code><code class="p">{</code>&#13;
                    <code class="p">{</code><code class="s">"salami"</code><code class="p">,</code> <code class="mi">1</code><code class="p">},</code>&#13;
                    <code class="p">{</code><code class="s">"mozzarella"</code><code class="p">,</code> <code class="mi">1</code><code class="p">},</code>&#13;
                    <code class="p">{</code><code class="s">"tomato"</code><code class="p">,</code> <code class="mi">1</code><code class="p">},</code>&#13;
                <code class="p">}</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="nx">seen</code> <code class="o">:=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">bool</code><code class="p">{}</code>&#13;
            <code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code> <code class="p">{</code>&#13;
                <code class="c1">// make quantity strictly positive and of reasonable size</code>&#13;
                <code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Quantity</code> <code class="p">=</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">c</code><code class="p">.</code><code class="nx">Intn</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>&#13;
&#13;
                <code class="c1">// remove duplicates</code>&#13;
                <code class="k">for</code> <code class="p">{</code>&#13;
                    <code class="k">if</code> <code class="p">!</code><code class="nx">seen</code><code class="p">[</code><code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Name</code><code class="p">]</code> <code class="p">{</code>&#13;
                        <code class="k">break</code>&#13;
                    <code class="p">}</code>&#13;
                    <code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Name</code> <code class="p">=</code> <code class="nx">c</code><code class="p">.</code><code class="nx">RandString</code><code class="p">()</code>&#13;
                <code class="p">}</code>&#13;
                <code class="nx">seen</code><code class="p">[</code><code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Name</code><code class="p">]</code> <code class="p">=</code> <code class="kc">true</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">},</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If no randomizer function is given, the underlying library <a href="http://bit.ly/2KJrb27"><em>github.com/google/gofuzz</em></a> will generically try to fuzz the object by setting random values for base types and diving recursively into pointers, structs, maps, and slices, eventually calling custom randomizer functions if they are given by the developer.</p>&#13;
&#13;
<p>When writing a randomizer function for one of the types, it is convenient to call <code>c.FuzzNoCustom(s)</code> first. It randomizes the given object <code>s</code> and also calls custom functions for substructures, but not for <code>s</code> itself. Then the developer can restrict and fix the random values to make the object valid.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>It is important to make fuzzers as general as possible in order to cover as many valid objects as possible. If the fuzzer is too restrictive, the test coverage will be bad. In many cases during the development of Kubernetes, regressions were not caught because the fuzzers in place were not good.</p>&#13;
&#13;
<p>On the other hand, a fuzzer only has to consider objects that validate and are the projection of actual objects definable in the external versions. Often you have to restrict the random values set by <code>c.FuzzNoCustom(s)</code> in a way that the randomized object becomes valid. For example, a string holding a URL does not have to roundtrip for arbitrary values if validation will reject arbitrary strings anyway.</p>&#13;
</div>&#13;
&#13;
<p>Our preceding <code>PizzaSpec</code> example first calls <code>c.FuzzNoCustom(s)</code> and then fixes up the object by:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Defaulting the <code>nil</code> case for toppings</p>&#13;
</li>&#13;
<li>&#13;
<p>Setting a reasonable quantity for each topping (without that, the conversion to <code>v1alpha1</code> will explode in complexity, introducing high quantities into a string list)</p>&#13;
</li>&#13;
<li>&#13;
<p>Normalizing the topping names, as we know that duplicated toppings in a pizza spec will never roundtrip (for the internal types, note that v1alpha1 types have duplication)</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Validation" data-type="sect2"><div class="sect2" id="aggregated-apiserver-development-validation">&#13;
<h2>Validation</h2>&#13;
&#13;
<p>Incoming objects<a data-primary="custom API servers" data-secondary="writing" data-tertiary="validation" data-type="indexterm" id="idm46336849106792"/><a data-primary="validation" data-type="indexterm" id="idm46336849105512"/> are validated shortly after they have been deserialized, defaulted, and converted to the internal version. <a data-type="xref" href="#aggregation-conversions-figure">Figure 8-5</a> showed earlier how validation is done between<a data-primary="admission" data-secondary="mutating" data-type="indexterm" id="idm46336849103816"/> mutating admission plug-ins and validating<a data-primary="admission" data-secondary="validating" data-type="indexterm" id="idm46336849102680"/> admission plug-ins, long before the actual creation or update logic is executed.</p>&#13;
&#13;
<p>This means validation has to be implemented only once for the internal version, not for all external versions. This has the advantage that it obviously saves implementation work and also ensures consistency between versions. On the other hand, it means that validation errors do not refer to the external version. This can actually be observed with Kubernetes resources, but in practice it is no big deal.</p>&#13;
&#13;
<p>In this section, we’ll look at the implementation of validation functions. The wiring into the custom API server—namely, calling validation from the strategy that configures the generic registry—will be covered in the next section. In other words, <a data-type="xref" href="#aggregation-conversions-figure">Figure 8-5</a> is slightly misleading in favor of visual simplicity.</p>&#13;
&#13;
<p>For now it should be enough to look at the entry point into the validation inside the strategy:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">pizzaStrategy</code><code class="p">)</code> <code class="nx">Validate</code><code class="p">(</code>&#13;
    <code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">obj</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="nx">field</code><code class="p">.</code><code class="nx">ErrorList</code> <code class="p">{</code>&#13;
    <code class="nx">pizza</code> <code class="o">:=</code> <code class="nx">obj</code><code class="p">.(</code><code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">Pizza</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="nx">validation</code><code class="p">.</code><code class="nx">ValidatePizza</code><code class="p">(</code><code class="nx">pizza</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This calls out to the <code>Validate<em>Kind</em>(obj</code> <code>*<em>Kind</em>) field.ErrorList</code> validation function in the validation package of the API group <code>pkg/apis/<em>group</em>/<em>validation</em></code>.</p>&#13;
&#13;
<p>The validation functions return an error list. They are usually written in the same style, appending return values to an error list while recursively diving into the type, one validation function per struct:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// ValidatePizza validates a Pizza.</code>&#13;
<code class="kd">func</code> <code class="nx">ValidatePizza</code><code class="p">(</code><code class="nx">f</code> <code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">Pizza</code><code class="p">)</code> <code class="nx">field</code><code class="p">.</code><code class="nx">ErrorList</code> <code class="p">{</code>&#13;
    <code class="nx">allErrs</code> <code class="o">:=</code> <code class="nx">field</code><code class="p">.</code><code class="nx">ErrorList</code><code class="p">{}</code>&#13;
&#13;
    <code class="nx">errs</code> <code class="o">:=</code> <code class="nx">ValidatePizzaSpec</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">f</code><code class="p">.</code><code class="nx">Spec</code><code class="p">,</code> <code class="nx">field</code><code class="p">.</code><code class="nx">NewPath</code><code class="p">(</code><code class="s">"spec"</code><code class="p">))</code>&#13;
    <code class="nx">allErrs</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">allErrs</code><code class="p">,</code> <code class="nx">errs</code><code class="o">...</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">allErrs</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// ValidatePizzaSpec validates a PizzaSpec.</code>&#13;
<code class="kd">func</code> <code class="nx">ValidatePizzaSpec</code><code class="p">(</code>&#13;
    <code class="nx">s</code> <code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">PizzaSpec</code><code class="p">,</code>&#13;
    <code class="nx">fldPath</code> <code class="o">*</code><code class="nx">field</code><code class="p">.</code><code class="nx">Path</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="nx">field</code><code class="p">.</code><code class="nx">ErrorList</code> <code class="p">{</code>&#13;
    <code class="nx">allErrs</code> <code class="o">:=</code> <code class="nx">field</code><code class="p">.</code><code class="nx">ErrorList</code><code class="p">{}</code>&#13;
&#13;
    <code class="nx">prevNames</code> <code class="o">:=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">bool</code><code class="p">{}</code>&#13;
    <code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Quantity</code> <code class="o">&lt;=</code> <code class="mi">0</code> <code class="p">{</code>&#13;
            <code class="nx">allErrs</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">allErrs</code><code class="p">,</code> <code class="nx">field</code><code class="p">.</code><code class="nx">Invalid</code><code class="p">(</code>&#13;
                <code class="nx">fldPath</code><code class="p">.</code><code class="nx">Child</code><code class="p">(</code><code class="s">"toppings"</code><code class="p">).</code><code class="nx">Index</code><code class="p">(</code><code class="nx">i</code><code class="p">).</code><code class="nx">Child</code><code class="p">(</code><code class="s">"quantity"</code><code class="p">),</code>&#13;
                <code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Quantity</code><code class="p">,</code>&#13;
                <code class="s">"cannot be negative or zero"</code><code class="p">,</code>&#13;
            <code class="p">))</code>&#13;
        <code class="p">}</code>&#13;
        <code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Name</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code> <code class="p">{</code>&#13;
            <code class="nx">allErrs</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">allErrs</code><code class="p">,</code> <code class="nx">field</code><code class="p">.</code><code class="nx">Invalid</code><code class="p">(</code>&#13;
                <code class="nx">fldPath</code><code class="p">.</code><code class="nx">Child</code><code class="p">(</code><code class="s">"toppings"</code><code class="p">).</code><code class="nx">Index</code><code class="p">(</code><code class="nx">i</code><code class="p">).</code><code class="nx">Child</code><code class="p">(</code><code class="s">"name"</code><code class="p">),</code>&#13;
                <code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Name</code><code class="p">,</code>&#13;
                <code class="s">"cannot be empty"</code><code class="p">,</code>&#13;
            <code class="p">))</code>&#13;
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
            <code class="k">if</code> <code class="nx">prevNames</code><code class="p">[</code><code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Name</code><code class="p">]</code> <code class="p">{</code>&#13;
                <code class="nx">allErrs</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">allErrs</code><code class="p">,</code> <code class="nx">field</code><code class="p">.</code><code class="nx">Invalid</code><code class="p">(</code>&#13;
                    <code class="nx">fldPath</code><code class="p">.</code><code class="nx">Child</code><code class="p">(</code><code class="s">"toppings"</code><code class="p">).</code><code class="nx">Index</code><code class="p">(</code><code class="nx">i</code><code class="p">).</code><code class="nx">Child</code><code class="p">(</code><code class="s">"name"</code><code class="p">),</code>&#13;
                    <code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Name</code><code class="p">,</code>&#13;
                    <code class="s">"must be unique"</code><code class="p">,</code>&#13;
                <code class="p">))</code>&#13;
            <code class="p">}</code>&#13;
            <code class="nx">prevNames</code><code class="p">[</code><code class="nx">s</code><code class="p">.</code><code class="nx">Toppings</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Name</code><code class="p">]</code> <code class="p">=</code> <code class="kc">true</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">allErrs</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note how the field path is maintained using <code>Child</code> and <code>Index</code> calls. The field path is the JSON path, which is printed in case of errors.</p>&#13;
&#13;
<p>Often there is an additional set of validation functions that differs slightly for updates (while the preceding set is used for creation). In our example API server, this could look like the following:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">pizzaStrategy</code><code class="p">)</code> <code class="nx">ValidateUpdate</code><code class="p">(</code>&#13;
    <code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code>&#13;
    <code class="nx">obj</code><code class="p">,</code> <code class="nx">old</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="nx">field</code><code class="p">.</code><code class="nx">ErrorList</code> <code class="p">{</code>&#13;
    <code class="nx">objPizza</code> <code class="o">:=</code> <code class="nx">obj</code><code class="p">.(</code><code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">Pizza</code><code class="p">)</code>&#13;
    <code class="nx">oldPizza</code> <code class="o">:=</code> <code class="nx">old</code><code class="p">.(</code><code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">Pizza</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="nx">validation</code><code class="p">.</code><code class="nx">ValidatePizzaUpdate</code><code class="p">(</code><code class="nx">objPizza</code><code class="p">,</code> <code class="nx">oldPizza</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This can be used to verify that no read-only fields are changed. Often an update validation calls the normal validation functions as well and only adds checks relevant for the update.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Validation is the right place to restrict object names on creation—for example, to be single-word only, or to not include any non-alpha-numeric characters.</p>&#13;
&#13;
<p>Actually, any <code>ObjectMeta</code> field can technically be restricted in a custom way, though that’s not desirable for many fields because it might break core API machinery behavior. A number of resources restrict the names because, for example, the name will show up in other systems or in other contexts that require a specially formatted name.</p>&#13;
&#13;
<p>But even if there are special <code>ObjectMeta</code> validations in place in a custom API server, the generic registry will validate against generic rules in any case, after the custom validation has passed. This allows us to return more specific error messages from the custom code first.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Registry and Strategy" data-type="sect2"><div class="sect2" id="aggregated-apiserver-development-registry">&#13;
<h2>Registry and Strategy</h2>&#13;
&#13;
<p>So far, we<a data-primary="custom API servers" data-secondary="writing" data-tertiary="registry and strategy" data-type="indexterm" id="idm46336848631880"/> have seen how API types are defined and validate. The next step is the implementation of the REST logic for those API types. <a data-type="xref" href="#aggregated-registry-figure">Figure 8-7</a> shows the registry as a central part of the implementation of an API group. The generic REST request handler code in <em>k8s.io/apiserver</em> calls out to the registry.</p>&#13;
&#13;
<figure><div class="figure" id="aggregated-registry-figure">&#13;
<img alt="Resource storage and generic registry" src="assets/prku_0807.png"/>&#13;
<h6><span class="label">Figure 8-7. </span>Resource storage and generic registry</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generic registry" data-type="sect3"><div class="sect3" id="idm46336848626968">&#13;
<h3>Generic registry</h3>&#13;
&#13;
<p>The<a data-primary="generic registry" data-type="indexterm" id="idm46336848625400"/> REST logic is usually implemented by what is called the <em>generic registry</em>. It is—as the name suggests—a generic implementation of the registry interfaces in the package <em>k8s.io/apiserver/pkg/registry/rest</em>.</p>&#13;
&#13;
<p>The generic registry implements the default REST behavior for “normal” resources. Nearly all Kubernetes resources use this implementation. Only a few, specifically those that do not<a data-primary="subject access review" data-type="indexterm" id="idm46336848622952"/> persist objects (e.g., <code>SubjectAccessReview</code>; see <a data-type="xref" href="#aggregated-authorization">“Delegated Authorization”</a>), have custom implementations.</p>&#13;
&#13;
<p>In <em>k8s.io/apiserver/pkg/registry/rest/rest.go</em> you will find many interfaces, loosely corresponding to HTTP verbs and certain API functionalities. If an interface is implemented by a registry, the API endpoint code will offer certain REST features. Because the generic registry implements most of the <em>k8s.io/apiserver/pkg/registry/rest</em> interfaces, resources that use it will support all the default Kubernetes HTTP verbs (see <a data-type="xref" href="ch02.html#api-server-http-interface">“The HTTP Interface of the API Server”</a>). Here is a list of those interfaces that are implemented, with the GoDoc description from the Kubernetes source code:</p>&#13;
<dl>&#13;
<dt><code>CollectionDeleter</code></dt>&#13;
<dd>&#13;
<p>An object that can delete a collection of RESTful resources</p>&#13;
</dd>&#13;
<dt><code>Creater</code></dt>&#13;
<dd>&#13;
<p>An object that can create an instance of a RESTful object</p>&#13;
</dd>&#13;
<dt><code>CreaterUpdater</code></dt>&#13;
<dd>&#13;
<p>A storage object that must support both create and update operations</p>&#13;
</dd>&#13;
<dt><code>Exporter</code></dt>&#13;
<dd>&#13;
<p>An object that knows how to strip a RESTful resource for export</p>&#13;
</dd>&#13;
<dt><code>Getter</code></dt>&#13;
<dd>&#13;
<p>An object that can retrieve a named RESTful resource</p>&#13;
</dd>&#13;
<dt><code>GracefulDeleter</code></dt>&#13;
<dd>&#13;
<p>An object that knows how to pass deletion options to allow delayed deletion of a RESTful object</p>&#13;
</dd>&#13;
<dt><code>Lister</code></dt>&#13;
<dd>&#13;
<p>An object that can retrieve resources that match the provided field and label <span class="keep-together">criteria</span></p>&#13;
</dd>&#13;
<dt><code>Patcher</code></dt>&#13;
<dd>&#13;
<p>A storage object that supports both get and update</p>&#13;
</dd>&#13;
<dt><code>Scoper</code></dt>&#13;
<dd>&#13;
<p>An object that must be specified and indicates what scope the resource</p>&#13;
</dd>&#13;
<dt><code>Updater</code></dt>&#13;
<dd>&#13;
<p>An object that can update an instance of a RESTful object</p>&#13;
</dd>&#13;
<dt><code>Watcher</code></dt>&#13;
<dd>&#13;
<p>An object that should be implemented by all storage objects that want to offer the ability to watch for changes through the <code>Watch</code> API</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Let’s look at one of the interfaces, <code>Creater</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Creater is an object that can create an instance of a RESTful object.</code>&#13;
<code class="kd">type</code> <code class="nx">Creater</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="c1">// New returns an empty object that can be used with Create after request</code>&#13;
    <code class="c1">// data has been put into it.</code>&#13;
    <code class="c1">// This object must be a pointer type for use with Codec.DecodeInto([]byte,</code>&#13;
    <code class="c1">// runtime.Object)</code>&#13;
    <code class="nx">New</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code>&#13;
&#13;
    <code class="c1">// Create creates a new version of a resource.</code>&#13;
    <code class="nx">Create</code><code class="p">(</code>&#13;
        <code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code>&#13;
        <code class="nx">obj</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code><code class="p">,</code>&#13;
        <code class="nx">createValidation</code> <code class="nx">ValidateObjectFunc</code><code class="p">,</code>&#13;
        <code class="nx">options</code> <code class="o">*</code><code class="nx">metav1</code><code class="p">.</code><code class="nx">CreateOptions</code><code class="p">,</code>&#13;
    <code class="p">)</code> <code class="p">(</code><code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A registry implementing this interface will be able to create objects. In contrast to <code>NamedCreater</code>, the name of the new object either comes from <code>ObjectMeta.Name</code> or is generated via <code>ObjectMeta.GenerateName</code>. If a registry implements <code>NamedCreater</code>, the name can also be passed through the HTTP path.</p>&#13;
&#13;
<p>It is important to understand that the implemented interfaces determine which verbs will be supported by the API endpoint that is created while installing the API into the custom API server. See <a data-type="xref" href="#aggregated-apiserver-development-api-install">“API Installation”</a> for how this is done in the code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Strategy" data-type="sect3"><div class="sect3" id="idm46336848528696">&#13;
<h3>Strategy</h3>&#13;
&#13;
<p>The<a data-primary="strategy" data-type="indexterm" id="idm46336848527000"/> generic registry can be customized to a certain degree using an object called a <em>strategy</em>. The strategy provides callbacks to functionality like validation, as we saw in <a data-type="xref" href="#aggregated-apiserver-development-validation">“Validation”</a>.</p>&#13;
&#13;
<p>The strategy implements the REST strategy interfaces listed here with their GoDoc description (see <em>k8s.io/apiserver/pkg/registry/rest</em> for their definitions):</p>&#13;
<dl>&#13;
<dt><code>RESTCreateStrategy</code></dt>&#13;
<dd>&#13;
<p>Defines the minimum validation, accepted input, and name generation behavior to create an object that follows Kubernetes API conventions.</p>&#13;
</dd>&#13;
<dt><code>RESTDeleteStrategy</code></dt>&#13;
<dd>&#13;
<p>Defines deletion behavior on an object that follows Kubernetes API conventions.</p>&#13;
</dd>&#13;
<dt><code>RESTGracefulDeleteStrategy</code></dt>&#13;
<dd>&#13;
<p>Must be implemented by the registry that supports graceful deletion.</p>&#13;
</dd>&#13;
<dt><code>GarbageCollectionDeleteStrategy</code></dt>&#13;
<dd>&#13;
<p>Must be implemented by the registry that wants to orphan dependents by default.</p>&#13;
</dd>&#13;
<dt><code>RESTExportStrategy</code></dt>&#13;
<dd>&#13;
<p>Defines how to export a Kubernetes object.</p>&#13;
</dd>&#13;
<dt><code>RESTUpdateStrategy</code></dt>&#13;
<dd>&#13;
<p>Defines the minimum validation, accepted input, and name generation behavior to update an object that follows Kubernetes API conventions.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Let’s look again at the strategy for the creation case:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">RESTCreateStrategy</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">runtime</code><code class="p">.</code><code class="nx">ObjectTyper</code>&#13;
    <code class="c1">// The name generator is used when the standard GenerateName field is set.</code>&#13;
    <code class="c1">// The NameGenerator will be invoked prior to validation.</code>&#13;
    <code class="nx">names</code><code class="p">.</code><code class="nx">NameGenerator</code>&#13;
&#13;
    <code class="c1">// NamespaceScoped returns true if the object must be within a namespace.</code>&#13;
    <code class="nx">NamespaceScoped</code><code class="p">()</code> <code class="kt">bool</code>&#13;
    <code class="c1">// PrepareForCreate is invoked on create before validation to normalize</code>&#13;
    <code class="c1">// the object. For example: remove fields that are not to be persisted,</code>&#13;
    <code class="c1">// sort order-insensitive list fields, etc. This should not remove fields</code>&#13;
    <code class="c1">// whose presence would be considered a validation error.</code>&#13;
    <code class="c1">//</code>&#13;
    <code class="c1">// Often implemented as a type check and an initailization or clearing of</code>&#13;
    <code class="c1">// status. Clear the status because status changes are internal. External</code>&#13;
    <code class="c1">// callers of an api (users) should not be setting an initial status on</code>&#13;
    <code class="c1">// newly created objects.</code>&#13;
    <code class="nx">PrepareForCreate</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">obj</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code><code class="p">)</code>&#13;
    <code class="c1">// Validate returns an ErrorList with validation errors or nil. Validate</code>&#13;
    <code class="c1">// is invoked after default fields in the object have been filled in</code>&#13;
    <code class="c1">// before the object is persisted. This method should not mutate the</code>&#13;
    <code class="c1">// object.</code>&#13;
    <code class="nx">Validate</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">obj</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code><code class="p">)</code> <code class="nx">field</code><code class="p">.</code><code class="nx">ErrorList</code>&#13;
    <code class="c1">// Canonicalize allows an object to be mutated into a canonical form. This</code>&#13;
    <code class="c1">// ensures that code that operates on these objects can rely on the common</code>&#13;
    <code class="c1">// form for things like comparison. Canonicalize is invoked after</code>&#13;
    <code class="c1">// validation has succeeded but before the object has been persisted.</code>&#13;
    <code class="c1">// This method may mutate the object. Often implemented as a type check or</code>&#13;
    <code class="c1">// empty method.</code>&#13;
    <code class="nx">Canonicalize</code><code class="p">(</code><code class="nx">obj</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The<a data-primary="ObectTyper" data-type="indexterm" id="idm46336848512136"/> embedded <code>ObjectTyper</code> recognizes objects; that is, it checks whether an object in a request is supported by the registry. This is important to create the right kind of objects (e.g., via a “foo” resource, only “Foo” resources should be created).</p>&#13;
&#13;
<p>The <code>NameGenerator</code> obviously generates names from the <code>ObjectMeta.GenerateName</code> field.</p>&#13;
&#13;
<p>Via <code>NamespaceScoped</code> the strategy can support cluster-wide or namespaced resources by returning either <code>false</code> or <code>true</code>.</p>&#13;
&#13;
<p>The <code>PrepareForCreate</code> method is called with the incoming object before validation.</p>&#13;
&#13;
<p>The <code>Validate</code> method we’ve seen before in <a data-type="xref" href="#aggregated-apiserver-development-validation">“Validation”</a>: it’s the entry point to the validation functions.</p>&#13;
&#13;
<p>Finally, the <code>Canonicalize</code> method does normalization (e.g., sorting of slices).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Wiring a strategy into the generic registry" data-type="sect3"><div class="sect3" id="idm46336848528104">&#13;
<h3>Wiring a strategy into the generic registry</h3>&#13;
&#13;
<p>The strategy object is plugged into a generic registry instance. Here is the REST storage constructor for our custom API server on <a href="http://bit.ly/2Y0Mtyn">GitHub</a>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// NewREST returns a RESTStorage object that will work against API services.</code>&#13;
<code class="kd">func</code> <code class="nx">NewREST</code><code class="p">(</code>&#13;
    <code class="nx">scheme</code> <code class="o">*</code><code class="nx">runtime</code><code class="p">.</code><code class="nx">Scheme</code><code class="p">,</code>&#13;
    <code class="nx">optsGetter</code> <code class="nx">generic</code><code class="p">.</code><code class="nx">RESTOptionsGetter</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">registry</code><code class="p">.</code><code class="nx">REST</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">strategy</code> <code class="o">:=</code> <code class="nx">NewStrategy</code><code class="p">(</code><code class="nx">scheme</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">store</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">genericregistry</code><code class="p">.</code><code class="nx">Store</code><code class="p">{</code>&#13;
        <code class="nx">NewFunc</code><code class="p">:</code>       <code class="kd">func</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code> <code class="p">{</code> <code class="k">return</code> <code class="o">&amp;</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">Pizza</code><code class="p">{}</code> <code class="p">},</code>&#13;
        <code class="nx">NewListFunc</code><code class="p">:</code>   <code class="kd">func</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code> <code class="p">{</code> <code class="k">return</code> <code class="o">&amp;</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">PizzaList</code><code class="p">{}</code> <code class="p">},</code>&#13;
        <code class="nx">PredicateFunc</code><code class="p">:</code> <code class="nx">MatchPizza</code><code class="p">,</code>&#13;
&#13;
        <code class="nx">DefaultQualifiedResource</code><code class="p">:</code> <code class="nx">restaurant</code><code class="p">.</code><code class="nx">Resource</code><code class="p">(</code><code class="s">"pizzas"</code><code class="p">),</code>&#13;
&#13;
        <code class="nx">CreateStrategy</code><code class="p">:</code> <code class="nx">strategy</code><code class="p">,</code>&#13;
        <code class="nx">UpdateStrategy</code><code class="p">:</code> <code class="nx">strategy</code><code class="p">,</code>&#13;
        <code class="nx">DeleteStrategy</code><code class="p">:</code> <code class="nx">strategy</code><code class="p">,</code>&#13;
    <code class="p">}</code>&#13;
    <code class="nx">options</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">generic</code><code class="p">.</code><code class="nx">StoreOptions</code><code class="p">{</code>&#13;
        <code class="nx">RESTOptions</code><code class="p">:</code> <code class="nx">optsGetter</code><code class="p">,</code>&#13;
        <code class="nx">AttrFunc</code><code class="p">:</code> <code class="nx">GetAttrs</code><code class="p">,</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">store</code><code class="p">.</code><code class="nx">CompleteWithOptions</code><code class="p">(</code><code class="nx">options</code><code class="p">);</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="o">&amp;</code><code class="nx">registry</code><code class="p">.</code><code class="nx">REST</code><code class="p">{</code><code class="nx">store</code><code class="p">},</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It instantiates the generic registry object <code>genericregistry.Store</code> and sets a few fields. Many of these fields are optional and <code><span class="keep-together">store.CompleteWithOptions</span></code> will default them if they are not set by the developer.</p>&#13;
&#13;
<p>You can see how the custom strategy is first instantiated via the <code>NewStrategy</code> constructor and then plugged into the registry for <code>create</code>, <code>update</code>, and <code>delete</code> operators.</p>&#13;
&#13;
<p>In addition, the <code>NewFunc</code> is set to create a new object instance, and the <code>NewListFunc</code> field is set to create a new object list. The <code>PredicateFunc</code> translates a selector (which could be passed to a list request) into a predicate function, filtering runtime objects.</p>&#13;
&#13;
<p>The returned object is a REST registry, just a simple wrapper in <a href="http://bit.ly/2Rxcv6G">our example project</a> around the generic registry object to make the type our own:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">REST</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
  <code class="o">*</code><code class="nx">genericregistry</code><code class="p">.</code><code class="nx">Store</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With this we have everything to instantiate our API and wire it into the custom API server. In the following section we’ll see how to create an HTTP handler out of it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="API Installation" data-type="sect2"><div class="sect2" id="aggregated-apiserver-development-api-install">&#13;
<h2>API Installation</h2>&#13;
&#13;
<p>To activate<a data-primary="custom API servers" data-secondary="writing" data-tertiary="API installation" data-type="indexterm" id="idm46336848136040"/> an API in an API server, two steps are necessary:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The API version must be installed into the API type’s<a data-primary="conversion" data-type="indexterm" id="idm46336848133544"/><a data-primary="defaulting" data-type="indexterm" id="idm46336848132840"/> (and conversion and defaulting functions’) server scheme.</p>&#13;
</li>&#13;
<li>&#13;
<p>The API version must be installed into the server HTTP multiplexer (mux).</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The first step is usually done using <code>init</code> functions somewhere centrally in the API server bootstrapping. This is done in <em>pkg/apiserver/apiserver.go</em> in our example custom API server, where the <code>serverConfig</code> and <code>CustomServer</code> objects are defined (see <a data-type="xref" href="#aggregated-apiserver-development-options-config">“Options and Config Pattern and Startup Plumbing”</a>):</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="o">...</code>&#13;
    <code class="s">"k8s.io/apimachinery/pkg/runtime"</code>&#13;
    <code class="s">"k8s.io/apimachinery/pkg/runtime/serializer"</code>&#13;
&#13;
    <code class="s">"github.com/programming-kubernetes/pizza-apiserver/pkg/apis/restaurant/install"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">var</code> <code class="p">(</code>&#13;
    <code class="nx">Scheme</code> <code class="p">=</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">NewScheme</code><code class="p">()</code>&#13;
    <code class="nx">Codecs</code> <code class="p">=</code> <code class="nx">serializer</code><code class="p">.</code><code class="nx">NewCodecFactory</code><code class="p">(</code><code class="nx">Scheme</code><code class="p">)</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>Then for each API group that should be served, we call the <code>Install()</code> function:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">install</code><code class="p">.</code><code class="nx">Install</code><code class="p">(</code><code class="nx">Scheme</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For technical reasons, we also have to add some discovery-related types to the scheme (this will probably go away in future versions of <em>k8s.io/apiserver</em>):</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// we need to add the options to empty v1</code>&#13;
    <code class="c1">// TODO: fix the server code to avoid this</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">AddToGroupVersion</code><code class="p">(</code><code class="nx">Scheme</code><code class="p">,</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersion</code><code class="p">{</code><code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">})</code>&#13;
    <code class="c1">// TODO: keep the generic API server from wanting this</code>&#13;
    <code class="nx">unversioned</code> <code class="o">:=</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersion</code><code class="p">{</code><code class="nx">Group</code><code class="p">:</code> <code class="s">""</code><code class="p">,</code> <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">}</code>&#13;
    <code class="nx">Scheme</code><code class="p">.</code><code class="nx">AddUnversionedTypes</code><code class="p">(</code><code class="nx">unversioned</code><code class="p">,</code>&#13;
        <code class="o">&amp;</code><code class="nx">metav1</code><code class="p">.</code><code class="nx">Status</code><code class="p">{},</code>&#13;
        <code class="o">&amp;</code><code class="nx">metav1</code><code class="p">.</code><code class="nx">APIVersions</code><code class="p">{},</code>&#13;
        <code class="o">&amp;</code><code class="nx">metav1</code><code class="p">.</code><code class="nx">APIGroupList</code><code class="p">{},</code>&#13;
        <code class="o">&amp;</code><code class="nx">metav1</code><code class="p">.</code><code class="nx">APIGroup</code><code class="p">{},</code>&#13;
        <code class="o">&amp;</code><code class="nx">metav1</code><code class="p">.</code><code class="nx">APIResourceList</code><code class="p">{},</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With this we have registered our API types in the global scheme, including conversion and defaulting functions. In other words, the empty scheme of <a data-type="xref" href="#aggregation-kube-apiserver_without">Figure 8-3</a> now knows everything about our types.</p>&#13;
&#13;
<p>The second step is to add the API group to the HTTP mux. The generic API server code embedded into our <code>CustomServer</code> struct provides the <code>InstallAPIGroup(apiGroupInfo *APIGroupInfo) error</code> method, which sets up the whole request pipeline for an API group.</p>&#13;
&#13;
<p>The only thing we have to do is to provide a properly filled <code>APIGroupInfo</code> struct. We do this in the constructor <code>New()</code> <code>(*CustomServer, error)</code> of the <code>completedConfig</code> type:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// New returns a new instance of CustomServer from the given config.</code>&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">c</code> <code class="nx">completedConfig</code><code class="p">)</code> <code class="nx">New</code><code class="p">()</code> <code class="p">(</code><code class="o">*</code><code class="nx">CustomServer</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">genericServer</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">c</code><code class="p">.</code><code class="nx">GenericConfig</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"pizza-apiserver"</code><code class="p">,</code>&#13;
      <code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">NewEmptyDelegate</code><code class="p">())</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">s</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">CustomServer</code><code class="p">{</code>&#13;
        <code class="nx">GenericAPIServer</code><code class="p">:</code> <code class="nx">genericServer</code><code class="p">,</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">apiGroupInfo</code> <code class="o">:=</code> <code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">NewDefaultAPIGroupInfo</code><code class="p">(</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">GroupName</code><code class="p">,</code>&#13;
      <code class="nx">Scheme</code><code class="p">,</code> <code class="nx">metav1</code><code class="p">.</code><code class="nx">ParameterCodec</code><code class="p">,</code> <code class="nx">Codecs</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">v1alpha1storage</code> <code class="o">:=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="nx">rest</code><code class="p">.</code><code class="nx">Storage</code><code class="p">{}</code>&#13;
&#13;
    <code class="nx">pizzaRest</code> <code class="o">:=</code> <code class="nx">pizzastorage</code><code class="p">.</code><code class="nx">NewREST</code><code class="p">(</code><code class="nx">Scheme</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">GenericConfig</code><code class="p">.</code><code class="nx">RESTOptionsGetter</code><code class="p">)</code>&#13;
    <code class="nx">v1alpha1storage</code><code class="p">[</code><code class="s">"pizzas"</code><code class="p">]</code> <code class="p">=</code> <code class="nx">customregistry</code><code class="p">.</code><code class="nx">RESTInPeace</code><code class="p">(</code><code class="nx">pizzaRest</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">toppingRest</code> <code class="o">:=</code> <code class="nx">toppingstorage</code><code class="p">.</code><code class="nx">NewREST</code><code class="p">(</code>&#13;
        <code class="nx">Scheme</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">GenericConfig</code><code class="p">.</code><code class="nx">RESTOptionsGetter</code><code class="p">,</code>&#13;
    <code class="p">)</code>&#13;
    <code class="nx">v1alpha1storage</code><code class="p">[</code><code class="s">"toppings"</code><code class="p">]</code> <code class="p">=</code> <code class="nx">customregistry</code><code class="p">.</code><code class="nx">RESTInPeace</code><code class="p">(</code><code class="nx">toppingRest</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">apiGroupInfo</code><code class="p">.</code><code class="nx">VersionedResourcesStorageMap</code><code class="p">[</code><code class="s">"v1alpha1"</code><code class="p">]</code> <code class="p">=</code> <code class="nx">v1alpha1storage</code>&#13;
&#13;
    <code class="nx">v1beta1storage</code> <code class="o">:=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="nx">rest</code><code class="p">.</code><code class="nx">Storage</code><code class="p">{}</code>&#13;
&#13;
    <code class="nx">pizzaRest</code> <code class="p">=</code> <code class="nx">pizzastorage</code><code class="p">.</code><code class="nx">NewREST</code><code class="p">(</code><code class="nx">Scheme</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">GenericConfig</code><code class="p">.</code><code class="nx">RESTOptionsGetter</code><code class="p">)</code>&#13;
    <code class="nx">v1beta1storage</code><code class="p">[</code><code class="s">"pizzas"</code><code class="p">]</code> <code class="p">=</code> <code class="nx">customregistry</code><code class="p">.</code><code class="nx">RESTInPeace</code><code class="p">(</code><code class="nx">pizzaRest</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">apiGroupInfo</code><code class="p">.</code><code class="nx">VersionedResourcesStorageMap</code><code class="p">[</code><code class="s">"v1beta1"</code><code class="p">]</code> <code class="p">=</code> <code class="nx">v1beta1storage</code>&#13;
&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">s</code><code class="p">.</code><code class="nx">GenericAPIServer</code><code class="p">.</code><code class="nx">InstallAPIGroup</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">apiGroupInfo</code><code class="p">);</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">s</code><code class="p">,</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>APIGroupInfo</code> has references to the generic registry that we customized in <a data-type="xref" href="#aggregated-apiserver-development-registry">“Registry and Strategy”</a> via a strategy. For each group version and resource, we create an instance of the registry using the implemented constructors.</p>&#13;
&#13;
<p>The <code>customregistry.RESTInPeace</code> wrapper is just a helper that panics when the registry constructors return an error:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">RESTInPeace</code><code class="p">(</code><code class="nx">storage</code> <code class="nx">rest</code><code class="p">.</code><code class="nx">StandardStorage</code><code class="p">,</code> <code class="nx">err</code> <code class="kt">error</code><code class="p">)</code> <code class="nx">rest</code><code class="p">.</code><code class="nx">StandardStorage</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">err</code> <code class="p">=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"unable to create REST storage: %v"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
        <code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="nx">storage</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The registry itself is version-independent, as it operates on internal objects; refer back to <a data-type="xref" href="#aggregation-conversions-figure">Figure 8-5</a>. Hence, we call the same registry constructor for each version.</p>&#13;
&#13;
<p>The call to <code>InstallAPIGroup</code> finally leads us to a complete custom API server ready to serve our custom API group, as shown earlier in <a data-type="xref" href="#aggregated-registry-figure">Figure 8-7</a>.</p>&#13;
&#13;
<p>After all this heavy plumbing, it is time to see our new API groups in action. For this we start up the server as shown in <a data-type="xref" href="#aggregated-apiserver-development-first-start">“The First Start”</a>. But this time the discovery info is not empty but instead shows our newly registered resource:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>curl -k https://localhost:443/apis&#13;
<code class="o">{</code>&#13;
  <code class="s2">"kind"</code>: <code class="s2">"APIGroupList"</code>,&#13;
  <code class="s2">"groups"</code>: <code class="o">[</code>&#13;
    <code class="o">{</code>&#13;
      <code class="s2">"name"</code>: <code class="s2">"restaurant.programming-kubernetes.info"</code>,&#13;
      <code class="s2">"versions"</code>: <code class="o">[</code>&#13;
        <code class="o">{</code>&#13;
          <code class="s2">"groupVersion"</code>: <code class="s2">"restaurant.programming-kubernetes.info/v1beta1"</code>,&#13;
          <code class="s2">"version"</code>: <code class="s2">"v1beta1"</code>&#13;
        <code class="o">}</code>,&#13;
        <code class="o">{</code>&#13;
          <code class="s2">"groupVersion"</code>: <code class="s2">"restaurant.programming-kubernetes.info/v1alpha1"</code>,&#13;
          <code class="s2">"version"</code>: <code class="s2">"v1alpha1"</code>&#13;
        <code class="o">}</code>&#13;
      <code class="o">]</code>,&#13;
      <code class="s2">"preferredVersion"</code>: <code class="o">{</code>&#13;
        <code class="s2">"groupVersion"</code>: <code class="s2">"restaurant.programming-kubernetes.info/v1beta1"</code>,&#13;
        <code class="s2">"version"</code>: <code class="s2">"v1beta1"</code>&#13;
      <code class="o">}</code>,&#13;
      <code class="s2">"serverAddressByClientCIDRs"</code>: <code class="o">[</code>&#13;
        <code class="o">{</code>&#13;
          <code class="s2">"clientCIDR"</code>: <code class="s2">"0.0.0.0/0"</code>,&#13;
          <code class="s2">"serverAddress"</code>: <code class="s2">":443"</code>&#13;
        <code class="o">}</code>&#13;
      <code class="o">]</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">]</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>With this, we have nearly reached our goal to serve the restaurant API. We have wired the API group versions, conversions are in place, and validation is working.</p>&#13;
&#13;
<p>What’s missing is a check that a topping mentioned in a pizza actually exists in the cluster. We could add this in the validation functions. But traditionally these are just format validation functions, which are static and do not need other resources to run.</p>&#13;
&#13;
<p>In contrast, more complex checks are implemented in admission—the topic of the next section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Admission" data-type="sect2"><div class="sect2" id="aggregated-apiserver-development-admission">&#13;
<h2>Admission</h2>&#13;
&#13;
<p>Every<a data-primary="custom API servers" data-secondary="writing" data-tertiary="admission" data-type="indexterm" id="idm46336847396440"/><a data-primary="admission" data-secondary="plug-in" data-type="indexterm" id="idm46336847395160"/><a data-primary="mutating plug-ins" data-type="indexterm" id="idm46336847394216"/><a data-primary="validating plug-ins" data-type="indexterm" id="idm46336847393544"/><a data-primary="admission" data-secondary="mutating" data-type="indexterm" id="idm46336847392872"/><a data-primary="admission" data-secondary="validating" data-type="indexterm" id="idm46336847551400"/> request passes the chain of admission plug-ins after being unmarshaled, defaulted, and converted to internal types; refer back to&#13;
<a data-type="xref" href="#aggregation-aggregated-apiserver">Figure 8-2</a>. More precisely, requests pass admission twice:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The mutating plug-ins</p>&#13;
</li>&#13;
<li>&#13;
<p>The validating plug-ins</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Admission plug-ins can be both mutating and validating and therefore can potentially get called twice by the admission mechanism:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Once in the mutation phase, called for all mutating plug-ins sequentially</p>&#13;
</li>&#13;
<li>&#13;
<p>Once in the validation phase, called (potentially parallelized) for all validating plug-ins</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>More precisely, a plug-in can implement both the mutating and the validating admission interface, with two different methods for both cases.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Before the separation into mutating and validating, there was just one call to each plug-in. It was nearly impossible to keep an eye on which mutation each plug-in did and which<a data-primary="admission" data-secondary="order" data-type="indexterm" id="idm46336847542584"/> admission plug-in order therefore made sense to lead to consistent behavior for the user.</p>&#13;
&#13;
<p>This two-step architecture at least ensures that a validation is done at the end for all plug-ins, which guarantees consistency.</p>&#13;
</div>&#13;
&#13;
<p>In addition, the<a data-primary="admission" data-secondary="chain" data-type="indexterm" id="idm46336847540296"/> chain (i.e., the order of plug-ins for both admission phases) is the same. Plug-ins are always enabled or disabled for both phases at the same time.</p>&#13;
&#13;
<p>Admission plug-ins, at least those implemented in Golang as described in this chapter, work with internal types. In contrast, webhook admission plug-ins (see <a data-type="xref" href="ch09.html#admission-webhooks">“Admission Webhooks”</a>) are based on external types and involve conversion on the way to the webhook and back (in case of mutating webhooks).</p>&#13;
&#13;
<p>But after all this theory, let’s get into the code.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Implementation" data-type="sect3"><div class="sect3" id="admission-plug-in-implementation">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p>An admission plug-in is a type implementing:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The admission plug-in interface <code>Interface</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Optionally the <code>MutatingInterface</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Optionally the <code>ValidatingInterface</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>All three can be found in the package <em>k8s.io/apiserver/pkg/admission</em>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Operation is the type of resource operation being checked for</code>&#13;
<code class="c1">// admission control</code>&#13;
<code class="kd">type</code> <code class="nx">Operation</code> <code class="kt">string</code><code class="p">.</code>&#13;
&#13;
<code class="c1">// Operation constants</code>&#13;
<code class="kd">const</code> <code class="p">(</code>&#13;
    <code class="nx">Create</code>  <code class="nx">Operation</code> <code class="p">=</code> <code class="s">"CREATE"</code>&#13;
    <code class="nx">Update</code>  <code class="nx">Operation</code> <code class="p">=</code> <code class="s">"UPDATE"</code>&#13;
    <code class="nx">Delete</code>  <code class="nx">Operation</code> <code class="p">=</code> <code class="s">"DELETE"</code>&#13;
    <code class="nx">Connect</code> <code class="nx">Operation</code> <code class="p">=</code> <code class="s">"CONNECT"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// Interface is an abstract, pluggable interface for Admission Control</code>&#13;
<code class="c1">// decisions.</code>&#13;
<code class="kd">type</code> <code class="nx">Interface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="c1">// Handles returns true if this admission controller can handle the given</code>&#13;
    <code class="c1">// operation where operation can be one of CREATE, UPDATE, DELETE, or</code>&#13;
    <code class="c1">// CONNECT.</code>&#13;
    <code class="nx">Handles</code><code class="p">(</code><code class="nx">operation</code> <code class="nx">Operation</code><code class="p">)</code> <code class="kt">bool</code><code class="p">.</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">MutationInterface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Interface</code>&#13;
&#13;
    <code class="c1">// Admit makes an admission decision based on the request attributes.</code>&#13;
    <code class="nx">Admit</code><code class="p">(</code><code class="nx">a</code> <code class="nx">Attributes</code><code class="p">,</code> <code class="nx">o</code> <code class="nx">ObjectInterfaces</code><code class="p">)</code> <code class="p">(</code><code class="nx">err</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// ValidationInterface is an abstract, pluggable interface for Admission Control</code>&#13;
<code class="c1">// decisions.</code>&#13;
<code class="kd">type</code> <code class="nx">ValidationInterface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Interface</code>&#13;
&#13;
    <code class="c1">// Validate makes an admission decision based on the request attributes.</code>&#13;
    <code class="c1">// It is NOT allowed to mutate.</code>&#13;
    <code class="nx">Validate</code><code class="p">(</code><code class="nx">a</code> <code class="nx">Attributes</code><code class="p">,</code> <code class="nx">o</code> <code class="nx">ObjectInterfaces</code><code class="p">)</code> <code class="p">(</code><code class="nx">err</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You see that the <code>Interface</code> method <code>Handles</code> is responsible for filtering on the operation. The mutating plug-ins are called via <code>Admit</code> and the validating plug-ins are called via <code>Validate</code>.</p>&#13;
&#13;
<p>The <code>ObjectInterfaces</code> gives access to helpers usually implemented by a scheme:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">ObjectInterfaces</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="c1">// GetObjectCreater is the ObjectCreater for the requested object.</code>&#13;
    <code class="nx">GetObjectCreater</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">ObjectCreater</code>&#13;
    <code class="c1">// GetObjectTyper is the ObjectTyper for the requested object.</code>&#13;
    <code class="nx">GetObjectTyper</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">ObjectTyper</code>&#13;
    <code class="c1">// GetObjectDefaulter is the ObjectDefaulter for the requested object.</code>&#13;
    <code class="nx">GetObjectDefaulter</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">ObjectDefaulter</code>&#13;
    <code class="c1">// GetObjectConvertor is the ObjectConvertor for the requested object.</code>&#13;
    <code class="nx">GetObjectConvertor</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">ObjectConvertor</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The attributes passed to the plug-in (via <code>Admit</code> or <code>Validate</code> or both) basically contain all the information extractable from a request that is important to implementing advanced checks:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Attributes is an interface used by AdmissionController to get information</code>&#13;
<code class="c1">// about a request that is used to make an admission decision.</code>&#13;
<code class="kd">type</code> <code class="nx">Attributes</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="c1">// GetName returns the name of the object as presented in the request.</code>&#13;
    <code class="c1">// On a CREATE operation, the client may omit name and rely on the</code>&#13;
    <code class="c1">// server to generate the name. If that is the case, this method will</code>&#13;
    <code class="c1">// return the empty string.</code>&#13;
    <code class="nx">GetName</code><code class="p">()</code> <code class="kt">string</code>&#13;
    <code class="c1">// GetNamespace is the namespace associated with the request (if any).</code>&#13;
    <code class="nx">GetNamespace</code><code class="p">()</code> <code class="kt">string</code>&#13;
    <code class="c1">// GetResource is the name of the resource being requested. This is not the</code>&#13;
    <code class="c1">// kind. For example: pods.</code>&#13;
    <code class="nx">GetResource</code><code class="p">()</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionResource</code>&#13;
    <code class="c1">// GetSubresource is the name of the subresource being requested. This is a</code>&#13;
    <code class="c1">// different resource, scoped to the parent resource, but it may have a</code>&#13;
    <code class="c1">// different kind.</code>&#13;
    <code class="c1">// For instance, /pods has the resource "pods" and the kind "Pod", while</code>&#13;
    <code class="c1">// /pods/foo/status has the resource "pods", the sub resource "status", and</code>&#13;
    <code class="c1">// the kind "Pod" (because status operates on pods). The binding resource for</code>&#13;
    <code class="c1">// a pod, though, may be /pods/foo/binding, which has resource "pods",</code>&#13;
    <code class="c1">// subresource "binding", and kind "Binding".</code>&#13;
    <code class="nx">GetSubresource</code><code class="p">()</code> <code class="kt">string</code>&#13;
    <code class="c1">// GetOperation is the operation being performed.</code>&#13;
    <code class="nx">GetOperation</code><code class="p">()</code> <code class="nx">Operation</code>&#13;
    <code class="c1">// IsDryRun indicates that modifications will definitely not be persisted for</code>&#13;
    <code class="c1">// this request. This is to prevent admission controllers with side effects</code>&#13;
    <code class="c1">// and a method of reconciliation from being overwhelmed.</code>&#13;
    <code class="c1">// However, a value of false for this does not mean that the modification will</code>&#13;
    <code class="c1">// be persisted, because it could still be rejected by a subsequent</code>&#13;
    <code class="c1">// validation step.</code>&#13;
    <code class="nx">IsDryRun</code><code class="p">()</code> <code class="kt">bool</code>&#13;
    <code class="c1">// GetObject is the object from the incoming request prior to default values</code>&#13;
    <code class="c1">// being applied.</code>&#13;
    <code class="nx">GetObject</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code>&#13;
    <code class="c1">// GetOldObject is the existing object. Only populated for UPDATE requests.</code>&#13;
    <code class="nx">GetOldObject</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code>&#13;
    <code class="c1">// GetKind is the type of object being manipulated. For example: Pod.</code>&#13;
    <code class="nx">GetKind</code><code class="p">()</code> <code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionKind</code>&#13;
    <code class="c1">// GetUserInfo is information about the requesting user.</code>&#13;
    <code class="nx">GetUserInfo</code><code class="p">()</code> <code class="nx">user</code><code class="p">.</code><code class="nx">Info</code>&#13;
&#13;
    <code class="c1">// AddAnnotation sets annotation according to key-value pair. The key</code>&#13;
    <code class="c1">// should be qualified, e.g., podsecuritypolicy.admission.k8s.io/admit-policy,</code>&#13;
    <code class="c1">//  where "podsecuritypolicy" is the name of the plugin, "admission.k8s.io"</code>&#13;
    <code class="c1">// is the name of the organization, and "admit-policy" is the key</code>&#13;
    <code class="c1">// name. An error is returned if the format of key is invalid. When</code>&#13;
    <code class="c1">// trying to overwrite annotation with a new value, an error is</code>&#13;
    <code class="c1">// returned. Both ValidationInterface and MutationInterface are</code>&#13;
    <code class="c1">// allowed to add Annotations.</code>&#13;
    <code class="nx">AddAnnotation</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code> <code class="kt">string</code><code class="p">)</code> <code class="kt">error</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the mutating case—that is, in the implementation of the <code>Admit(a Attributes) error</code> method—the attributes can be mutated, or more precisely, the object returned from <code>GetObject() runtime.Object</code> can.</p>&#13;
&#13;
<p>In the validating case, mutation is not allowed.</p>&#13;
&#13;
<p>Both cases permit the call to <code>AddAnnotation(key, value string) error</code>, which allows us to add annotations that end up in the audit output of the API server. This can be helpful in order to understand why an admission plug-in mutated or rejected a request.</p>&#13;
&#13;
<p>Rejection is signaled by returning a non-<code>nil</code> error from <code>Admit</code> or <code>Validate</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>It is good practice for mutating admission plug-ins to also validate the changes in the validating admission phase. The reason is that other plug-ins, including webhook admission plug-ins, might add further changes. If an admission plug-in guarantees that certain invariants are fulfilled, only the validation step can make sure this is really the case.</p>&#13;
</div>&#13;
&#13;
<p>Admission plug-ins have to implement the <code>Handles(operation Operation) bool</code> method from the <code>admission.Interface</code> interfaces. There is a helper in the same package called <code>Handler</code>. It can be instantiated using <code>NewHandler(ops ...Operation) *Handler</code> and implements the <code>Handles</code> method by embedding <code>Handler</code> into the custom admission plug-in:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">CustomAdmissionPlugin</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="o">*</code><code class="nx">admission</code><code class="p">.</code><code class="nx">Handler</code>&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Admission plug-ins should always<a data-primary="GroupVersionKind (GVK)" data-type="indexterm" id="idm46336847041960"/> check the GroupVersionKind of the passed object first:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">d</code> <code class="o">*</code><code class="nx">PizzaToppingsPlugin</code><code class="p">)</code> <code class="nx">Admit</code><code class="p">(</code>&#13;
    <code class="nx">a</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">Attributes</code><code class="p">,</code>&#13;
    <code class="nx">o</code> <code class="nx">ObjectInterfaces</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="c1">// we are only interested in pizzas</code>&#13;
    <code class="k">if</code> <code class="nx">a</code><code class="p">.</code><code class="nx">GetKind</code><code class="p">().</code><code class="nx">GroupKind</code><code class="p">()</code> <code class="o">!=</code> <code class="nx">restaurant</code><code class="p">.</code><code class="nx">Kind</code><code class="p">(</code><code class="s">"Pizza"</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>and similarly for the validating case:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">d</code> <code class="o">*</code><code class="nx">PizzaToppingsPlugin</code><code class="p">)</code> <code class="nx">Validate</code><code class="p">(</code>&#13;
    <code class="nx">a</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">Attributes</code><code class="p">,</code>&#13;
    <code class="nx">o</code> <code class="nx">ObjectInterfaces</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="c1">// we are only interested in pizzas</code>&#13;
    <code class="k">if</code> <code class="nx">a</code><code class="p">.</code><code class="nx">GetKind</code><code class="p">().</code><code class="nx">GroupKind</code><code class="p">()</code> <code class="o">!=</code> <code class="nx">restaurant</code><code class="p">.</code><code class="nx">Kind</code><code class="p">(</code><code class="s">"Pizza"</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
<aside class="pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336846889496">&#13;
<h5>Why the API Server Plumbing Does Not Prefilter Objects</h5>&#13;
<p>For native admission plug-ins there is no registration mechanism that makes the information of supported objects available for the API server machinery in order to call plug-ins only for objects they support. One reason is that many plug-ins in the Kubernetes API server (where the admission mechanism was invented) support a large number of objects.</p>&#13;
</div></aside>&#13;
&#13;
<p>The full example admission implementation looks like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Admit ensures that the object in-flight is of kind Pizza.</code>&#13;
<code class="c1">// In addition checks that the toppings are known.</code>&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">d</code> <code class="o">*</code><code class="nx">PizzaToppingsPlugin</code><code class="p">)</code> <code class="nx">Validate</code><code class="p">(</code>&#13;
    <code class="nx">a</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">Attributes</code><code class="p">,</code>&#13;
    <code class="nx">_</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">ObjectInterfaces</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="c1">// we are only interested in pizzas</code>&#13;
    <code class="k">if</code> <code class="nx">a</code><code class="p">.</code><code class="nx">GetKind</code><code class="p">().</code><code class="nx">GroupKind</code><code class="p">()</code> <code class="o">!=</code> <code class="nx">restaurant</code><code class="p">.</code><code class="nx">Kind</code><code class="p">(</code><code class="s">"Pizza"</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">if</code> <code class="p">!</code><code class="nx">d</code><code class="p">.</code><code class="nx">WaitForReady</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">NewForbidden</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"not yet ready"</code><code class="p">))</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">obj</code> <code class="o">:=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">GetObject</code><code class="p">()</code>&#13;
    <code class="nx">pizza</code> <code class="o">:=</code> <code class="nx">obj</code><code class="p">.(</code><code class="o">*</code><code class="nx">restaurant</code><code class="p">.</code><code class="nx">Pizza</code><code class="p">)</code>&#13;
    <code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">top</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">pizza</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">Toppings</code> <code class="p">{</code>&#13;
        <code class="nx">err</code> <code class="o">:=</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">d</code><code class="p">.</code><code class="nx">toppingLister</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="nx">top</code><code class="p">.</code><code class="nx">Name</code><code class="p">)</code>&#13;
        <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="o">&amp;&amp;</code> <code class="nx">errors</code><code class="p">.</code><code class="nx">IsNotFound</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">return</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">NewForbidden</code><code class="p">(</code>&#13;
                <code class="nx">a</code><code class="p">,</code>&#13;
                <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"unknown topping: %s"</code><code class="p">,</code> <code class="nx">top</code><code class="p">.</code><code class="nx">Name</code><code class="p">),</code>&#13;
            <code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It takes the following steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Checks that the passed object is of the right kind</p>&#13;
</li>&#13;
<li>&#13;
<p>Forbids access before the informers are ready</p>&#13;
</li>&#13;
<li>&#13;
<p>Verifies via the toppings informer lister that each topping mentioned in the pizza specification actually exists as a <code>Topping</code> object in the cluster</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Note here that the lister is just an interface to the informer in-memory store. So these <code>Get</code> calls will be fast.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Registering" data-type="sect3"><div class="sect3" id="idm46336847535960">&#13;
<h3>Registering</h3>&#13;
&#13;
<p>Admission<a data-primary="admission" data-secondary="register" data-type="indexterm" id="idm46336846686264"/> plug-ins must be registered. This is done through a <code>Register</code> function:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">Register</code><code class="p">(</code><code class="nx">plugins</code> <code class="o">*</code><code class="nx">admission</code><code class="p">.</code><code class="nx">Plugins</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">plugins</code><code class="p">.</code><code class="nx">Register</code><code class="p">(</code>&#13;
        <code class="s">"PizzaTopping"</code><code class="p">,</code>&#13;
        <code class="kd">func</code><code class="p">(</code><code class="nx">config</code> <code class="nx">io</code><code class="p">.</code><code class="nx">Reader</code><code class="p">)</code> <code class="p">(</code><code class="nx">admission</code><code class="p">.</code><code class="nx">Interface</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">return</code> <code class="nx">New</code><code class="p">()</code>&#13;
        <code class="p">},</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This function is added to the plug-in list in the <code>RecommendedOptions</code> (see <a data-type="xref" href="#aggregated-apiserver-development-options-config">“Options and Config Pattern and Startup Plumbing”</a>):</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">o</code> <code class="o">*</code><code class="nx">CustomServerOptions</code><code class="p">)</code> <code class="nx">Complete</code><code class="p">()</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="c1">// register admission plugins</code>&#13;
    <code class="nx">pizzatoppings</code><code class="p">.</code><code class="nx">Register</code><code class="p">(</code><code class="nx">o</code><code class="p">.</code><code class="nx">RecommendedOptions</code><code class="p">.</code><code class="nx">Admission</code><code class="p">.</code><code class="nx">Plugins</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// add admisison plugins to the RecommendedPluginOrder</code>&#13;
    <code class="nx">oldOrder</code> <code class="o">:=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">RecommendedOptions</code><code class="p">.</code><code class="nx">Admission</code><code class="p">.</code><code class="nx">RecommendedPluginOrder</code>&#13;
    <code class="nx">o</code><code class="p">.</code><code class="nx">RecommendedOptions</code><code class="p">.</code><code class="nx">Admission</code><code class="p">.</code><code class="nx">RecommendedPluginOrder</code> <code class="p">=</code>&#13;
        <code class="nb">append</code><code class="p">(</code><code class="nx">oldOrder</code><code class="p">,</code> <code class="s">"PizzaToppings"</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, the <code>RecommendedPluginOrder</code> list is prepopulated with the generic admission plug-ins, which every API server should keep enabled to be a good API convention citizen in the cluster.</p>&#13;
&#13;
<p>It is best practice not to touch the order. One reason is that getting the order right is far from trivial. Of course, adding a custom plug-in at a location other than the end of the list is fine, if it is strictly necessary for the plug-in behavior.</p>&#13;
&#13;
<p>The user of the custom API server will be able to disable a custom admission plug-in with the usual admission<a data-primary="admission" data-secondary="chain" data-type="indexterm" id="idm46336846619480"/> chain configuration flags (<code>--disable-admission-plugins</code>, for example). By default our own plug-in is enabled, because we don’t explicitly disable it.</p>&#13;
&#13;
<p>Admission<a data-primary="admission" data-secondary="configuration" data-type="indexterm" id="idm46336846617496"/><a data-primary="admission" data-secondary="plug-in" data-type="indexterm" id="idm46336846616488"/> plug-ins can be configured using a configuration file. To do so, we parse the output of the <code>io.Reader</code> in the <code>Register</code> function shown previously. The <code><span class="keep-together">--admission-control-config-file</span></code> allows us to pass a configuration file to the plug-in, like so:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">AdmissionConfiguration</code>&#13;
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiserver.k8s.io/v1alpha1</code>&#13;
<code class="nt">plugins</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">CustomAdmissionPlugin</code>&#13;
  <code class="nt">path</code><code class="p">:</code> <code class="l-Scalar-Plain">custom-admission-plugin.yaml</code></pre>&#13;
&#13;
<p>Alternatively, we can do inline configuration to have all our admission configuration in one place:</p>&#13;
<pre data-code-language="yaml" data-type="programlisting">&#13;
<code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">AdmissionConfiguration</code><code>&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">apiserver.k8s.io/v1alpha1</code><code>&#13;
</code><code class="nt">plugins</code><code class="p">:</code><code>&#13;
</code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">CustomAdmissionPlugin</code><code>&#13;
</code><code>  </code><code class="nt">configuration</code><code class="p">:</code><code>&#13;
</code><code>    </code><em><code class="l-Scalar-Plain">your-custom-yaml-inline-config</code></em><code>&#13;
</code></pre>&#13;
&#13;
<p>We briefly mentioned that our admission plug-in uses the toppings informer to check for the existence of toppings mentioned in the pizza. We have not talked about how to wire that into the admission plug-in. Let’s do this now.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Plumbing resources" data-type="sect3"><div class="sect3" id="idm46336846687240">&#13;
<h3>Plumbing resources</h3>&#13;
&#13;
<p>Admission plug-ins often need clients and informers or other resources to implement their behavior. We can do this resource plumbing using plug-in initializers.</p>&#13;
&#13;
<p>There are a number of standard<a data-primary="admission" data-secondary="initializers" data-type="indexterm" id="idm46336846429880"/> plug-in initializers. If your plug-in wants to be called by them, it has to implement certain interfaces with callback methods (for more on this, see <em>k8s.io/apiserver/pkg/admission/initializer</em>):</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// WantsExternalKubeClientSet defines a function that sets external ClientSet</code>&#13;
<code class="c1">// for admission plugins that need it.</code>&#13;
<code class="kd">type</code> <code class="nx">WantsExternalKubeClientSet</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">SetExternalKubeClientSet</code><code class="p">(</code><code class="nx">kubernetes</code><code class="p">.</code><code class="nx">Interface</code><code class="p">)</code>&#13;
    <code class="nx">admission</code><code class="p">.</code><code class="nx">InitializationValidator</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// WantsExternalKubeInformerFactory defines a function that sets InformerFactory</code>&#13;
<code class="c1">// for admission plugins that need it.</code>&#13;
<code class="kd">type</code> <code class="nx">WantsExternalKubeInformerFactory</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">SetExternalKubeInformerFactory</code><code class="p">(</code><code class="nx">informers</code><code class="p">.</code><code class="nx">SharedInformerFactory</code><code class="p">)</code>&#13;
    <code class="nx">admission</code><code class="p">.</code><code class="nx">InitializationValidator</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// WantsAuthorizer defines a function that sets Authorizer for admission</code>&#13;
<code class="c1">// plugins that need it.</code>&#13;
<code class="kd">type</code> <code class="nx">WantsAuthorizer</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">SetAuthorizer</code><code class="p">(</code><code class="nx">authorizer</code><code class="p">.</code><code class="nx">Authorizer</code><code class="p">)</code>&#13;
    <code class="nx">admission</code><code class="p">.</code><code class="nx">InitializationValidator</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// WantsScheme defines a function that accepts runtime.Scheme for admission</code>&#13;
<code class="c1">// plugins that need it.</code>&#13;
<code class="kd">type</code> <code class="nx">WantsScheme</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">SetScheme</code><code class="p">(</code><code class="o">*</code><code class="nx">runtime</code><code class="p">.</code><code class="nx">Scheme</code><code class="p">)</code>&#13;
    <code class="nx">admission</code><code class="p">.</code><code class="nx">InitializationValidator</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Implement some of these and the plug-in gets called during launch, in order to get access to, say, Kubernetes resources or the API server global scheme.</p>&#13;
&#13;
<p>In addition, the <code>admission.InitializationValidator</code> interface is supposed to be implemented to do a final check that the plug-in is properly set up:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// InitializationValidator holds ValidateInitialization functions, which are</code>&#13;
<code class="c1">// responsible for validation of initialized shared resources and should be</code>&#13;
<code class="c1">// implemented on admission plugins.</code>&#13;
<code class="kd">type</code> <code class="nx">InitializationValidator</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">ValidateInitialization</code><code class="p">()</code> <code class="kt">error</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Standard initializers are great, but we need access to the toppings informer. So, let’s look at how to add our own initializers. An initializer consists of:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A <code>Wants*</code> interface (e.g., <code>WantsRestaurantInformerFactory</code>), which should be implemented by an admission plug-in:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// WantsRestaurantInformerFactory defines a function that sets</code>&#13;
<code class="c1">// InformerFactory for admission plugins that need it.</code>&#13;
<code class="kd">type</code> <code class="nx">WantsRestaurantInformerFactory</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">SetRestaurantInformerFactory</code><code class="p">(</code><code class="nx">informers</code><code class="p">.</code><code class="nx">SharedInformerFactory</code><code class="p">)</code>&#13;
    <code class="nx">admission</code><code class="p">.</code><code class="nx">InitializationValidator</code>&#13;
<code class="p">}</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>The initializer struct, implementing <code>admission.PluginInitializer</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">i</code> <code class="nx">restaurantInformerPluginInitializer</code><code class="p">)</code> <code class="nx">Initialize</code><code class="p">(</code>&#13;
    <code class="nx">plugin</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">Interface</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="nx">wants</code><code class="p">,</code> <code class="nx">ok</code> <code class="o">:=</code> <code class="nx">plugin</code><code class="p">.(</code><code class="nx">WantsRestaurantInformerFactory</code><code class="p">);</code> <code class="nx">ok</code> <code class="p">{</code>&#13;
        <code class="nx">wants</code><code class="p">.</code><code class="nx">SetRestaurantInformerFactory</code><code class="p">(</code><code class="nx">i</code><code class="p">.</code><code class="nx">informers</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In other words, the <code>Initialize()</code> method checks that the passed plug-in implements the corresponding custom initializer <code>Wants*</code> interface. If that is the case, the initializer will call the method on the plug-in.</p>&#13;
</li>&#13;
<li>&#13;
<p>Plumbing of the initializer constructor into <code>RecommendedOptions.Extra\<span class="keep-together">AdmissionInitializers</span></code> (see <a data-type="xref" href="#aggregated-apiserver-development-options-config">“Options and Config Pattern and Startup Plumbing”</a>):</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">o</code> <code class="o">*</code><code class="nx">CustomServerOptions</code><code class="p">)</code> <code class="nx">Config</code><code class="p">()</code> <code class="p">(</code><code class="o">*</code><code class="nx">apiserver</code><code class="p">.</code><code class="nx">Config</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="o">...</code>&#13;
    <code class="nx">o</code><code class="p">.</code><code class="nx">RecommendedOptions</code><code class="p">.</code><code class="nx">ExtraAdmissionInitializers</code> <code class="p">=</code>&#13;
        <code class="kd">func</code><code class="p">(</code><code class="nx">c</code> <code class="o">*</code><code class="nx">genericapiserver</code><code class="p">.</code><code class="nx">RecommendedConfig</code><code class="p">)</code> <code class="p">(</code>&#13;
            <code class="p">[]</code><code class="nx">admission</code><code class="p">.</code><code class="nx">PluginInitializer</code><code class="p">,</code> <code class="kt">error</code><code class="p">,</code>&#13;
        <code class="p">)</code> <code class="p">{</code>&#13;
            <code class="nx">client</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientset</code><code class="p">.</code><code class="nx">NewForConfig</code><code class="p">(</code><code class="nx">c</code><code class="p">.</code><code class="nx">LoopbackClientConfig</code><code class="p">)</code>&#13;
            <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
                <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">err</code>&#13;
            <code class="p">}</code>&#13;
            <code class="nx">informerFactory</code> <code class="o">:=</code> <code class="nx">informers</code><code class="p">.</code><code class="nx">NewSharedInformerFactory</code><code class="p">(</code>&#13;
                <code class="nx">client</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">LoopbackClientConfig</code><code class="p">.</code><code class="nx">Timeout</code><code class="p">,</code>&#13;
            <code class="p">)</code>&#13;
            <code class="nx">o</code><code class="p">.</code><code class="nx">SharedInformerFactory</code> <code class="p">=</code> <code class="nx">informerFactory</code>&#13;
            <code class="k">return</code> <code class="p">[]</code><code class="nx">admission</code><code class="p">.</code><code class="nx">PluginInitializer</code><code class="p">{</code>&#13;
                <code class="nx">custominitializer</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="nx">informerFactory</code><code class="p">),</code>&#13;
            <code class="p">},</code> <code class="kc">nil</code>&#13;
        <code class="p">}</code>&#13;
&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This code creates a<a data-primary="clients" data-secondary="loopback client" data-type="indexterm" id="idm46336846181096"/> loopback client for the restaurant API group, creates a corresponding informer factory, stores it in the options <code>o</code>, and returns a plug-in initializer for it.</p>&#13;
</li>&#13;
</ul>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336846029448">&#13;
<h5>Syncing Informers</h5>&#13;
<p>If<a data-primary="informers" data-secondary="syncing" data-type="indexterm" id="idm46336846027880"/> informers are used in admission plug-ins, always check first that the informers are synced before using them in the actual <code>Admit()</code> or <code>Validate()</code> functions. Reject requests with a <code>Forbidden</code> error before that is the case.</p>&#13;
&#13;
<p>Using the <code>Handler</code> helper struct described in <a data-type="xref" href="#admission-plug-in-implementation">“Implementation”</a>, we can do this using the <code>Handler.WaitForReady()</code> function easily:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="k">if</code> <code class="p">!</code><code class="nx">d</code><code class="p">.</code><code class="nx">WaitForReady</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">NewForbidden</code><code class="p">(</code>&#13;
        <code class="nx">a</code><code class="p">,</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"not yet ready to handle request"</code><code class="p">),</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To include a custom informer <code>HasSynced()</code> method in this <code>WaitForReady()</code> method, add it to the ready functions from the initializer implementation, like so:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">d</code> <code class="o">*</code><code class="nx">PizzaToppingsPlugin</code><code class="p">)</code> <code class="nx">SetRestaurantInformerFactory</code><code class="p">(</code>&#13;
<code class="nx">f</code> <code class="nx">informers</code><code class="p">.</code><code class="nx">SharedInformerFactory</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">d</code><code class="p">.</code><code class="nx">toppingLister</code> <code class="p">=</code> <code class="nx">f</code><code class="p">.</code><code class="nx">Restaurant</code><code class="p">().</code><code class="nx">V1Alpha1</code><code class="p">().</code><code class="nx">Toppings</code><code class="p">().</code><code class="nx">Lister</code><code class="p">()</code>&#13;
    <code class="nx">d</code><code class="p">.</code><code class="nx">SetReadyFunc</code><code class="p">(</code><code class="nx">f</code><code class="p">.</code><code class="nx">Restaurant</code><code class="p">().</code><code class="nx">V1Alpha1</code><code class="p">().</code><code class="nx">Toppings</code><code class="p">().</code><code class="nx">Informer</code><code class="p">().</code><code class="nx">HasSynced</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>As promised, admission is the last step in the implementation to complete our custom API server for the restaurant API group. Now we want to see it in action, but not artificially on the local machine, but rather in a real Kubernetes cluster. This means we have to take a look at the deployment of an aggregated custom API server.<a data-primary="" data-startref="CASwrit08" data-type="indexterm" id="idm46336845901112"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploying Custom API Servers" data-type="sect1"><div class="sect1" id="aggregated-apiserver-deployment">&#13;
<h1>Deploying Custom API Servers</h1>&#13;
&#13;
<p>In <a data-type="xref" href="#aggregation-apiservices">“API Services”</a>, we<a data-primary="custom API servers" data-secondary="deploying" data-type="indexterm" id="CASdeploy08"/> saw the <code>APIService</code> object, which is used to register the custom API server API group versions with the<a data-primary="aggregation" data-type="indexterm" id="idm46336845896072"/> aggregator inside the Kubernetes API server:</p>&#13;
<pre data-code-language="yaml" data-type="programlisting">&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">apiregistration.k8s.io/v1beta1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">APIService</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">name</code></em><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">group</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">API-group-name</code></em><code>&#13;
</code><code>  </code><code class="nt">version</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">API-group-version</code></em><code>&#13;
</code><code>  </code><code class="nt">service</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">namespace</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">custom-API-server-service-namespace</code></em><code>&#13;
</code><code>    </code><code class="nt">name</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">custom-API-server-service</code></em><code>&#13;
</code><code>  </code><code class="nt">caBundle</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">base64-caBundle</code></em><code>&#13;
</code><code>  </code><code class="nt">insecureSkipTLSVerify</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">bool</code></em><code>&#13;
</code><code>  </code><code class="nt">groupPriorityMinimum</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">2000</code><code>&#13;
</code><code>  </code><code class="nt">versionPriority</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">20</code><code>&#13;
</code></pre>&#13;
&#13;
<p>The <code>APIService</code> object points to a service. Usually, this service will be a normal cluster IP service: that is, the custom API server is deployed into the cluster using pods. The service forwards the requests to the pods.</p>&#13;
&#13;
<p>Let’s look at the Kubernetes manifest to implement this.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deployment Manifests" data-type="sect2"><div class="sect2" id="idm46336845799976">&#13;
<h2>Deployment Manifests</h2>&#13;
&#13;
<p>We<a data-primary="custom API servers" data-secondary="deploying" data-tertiary="deployment manifests" data-type="indexterm" id="idm46336845812776"/><a data-primary="deployment (custom API servers)" data-secondary="deployment manifests" data-type="indexterm" id="idm46336845811496"/> have the following manifests (found in <a href="http://bit.ly/2J6CVIz">the example code on GitHub</a>) that will be part of an in-cluster deployment of a custom API service:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An <code>APIService</code> for both versions <code>v1alpha1</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiregistration.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">APIService</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">v1alpha1.restaurant.programming-kubernetes.info</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">insecureSkipTLSVerify</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
  <code class="nt">group</code><code class="p">:</code> <code class="l-Scalar-Plain">restaurant.programming-kubernetes.info</code>&#13;
  <code class="nt">groupPriorityMinimum</code><code class="p">:</code> <code class="l-Scalar-Plain">1000</code>&#13;
  <code class="nt">versionPriority</code><code class="p">:</code> <code class="l-Scalar-Plain">15</code>&#13;
  <code class="nt">service</code><code class="p">:</code>&#13;
    <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">api</code>&#13;
    <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code>&#13;
  <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">v1alpha1</code></pre>&#13;
&#13;
<p>…and <code>v1beta1</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiregistration.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">APIService</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">v1alpha1.restaurant.programming-kubernetes.info</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">insecureSkipTLSVerify</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
  <code class="nt">group</code><code class="p">:</code> <code class="l-Scalar-Plain">restaurant.programming-kubernetes.info</code>&#13;
  <code class="nt">groupPriorityMinimum</code><code class="p">:</code> <code class="l-Scalar-Plain">1000</code>&#13;
  <code class="nt">versionPriority</code><code class="p">:</code> <code class="l-Scalar-Plain">15</code>&#13;
  <code class="nt">service</code><code class="p">:</code>&#13;
    <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">api</code>&#13;
    <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code>&#13;
  <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">v1alpha1</code></pre>&#13;
&#13;
<p>Note here that we set <code>insecureSkipTLSVerify</code>. This is OK for development but inadequate for any production deployment. We’ll see how to fix this in <a data-type="xref" href="#aggregated-apiserver-certs">“Certificates and Trust”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <code>Service</code> in front of the custom API server instances running in the cluster:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Service</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">api</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">ports</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">port</code><code class="p">:</code> <code class="l-Scalar-Plain">443</code>&#13;
    <code class="nt">protocol</code><code class="p">:</code> <code class="l-Scalar-Plain">TCP</code>&#13;
    <code class="nt">targetPort</code><code class="p">:</code> <code class="l-Scalar-Plain">8443</code>&#13;
  <code class="nt">selector</code><code class="p">:</code>&#13;
    <code class="nt">apiserver</code><code class="p">:</code> <code class="s">"true"</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>A <code>Deployment</code> (as shown here) or <code>DaemonSet</code> for the custom API server pods:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code>&#13;
  <code class="nt">labels</code><code class="p">:</code>&#13;
    <code class="nt">apiserver</code><code class="p">:</code> <code class="s">"true"</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
  <code class="nt">selector</code><code class="p">:</code>&#13;
    <code class="nt">matchLabels</code><code class="p">:</code>&#13;
      <code class="nt">apiserver</code><code class="p">:</code> <code class="s">"true"</code>&#13;
  <code class="nt">template</code><code class="p">:</code>&#13;
    <code class="nt">metadata</code><code class="p">:</code>&#13;
      <code class="nt">labels</code><code class="p">:</code>&#13;
        <code class="nt">apiserver</code><code class="p">:</code> <code class="s">"true"</code>&#13;
    <code class="nt">spec</code><code class="p">:</code>&#13;
      <code class="nt">serviceAccountName</code><code class="p">:</code> <code class="l-Scalar-Plain">apiserver</code>&#13;
      <code class="nt">containers</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">apiserver</code>&#13;
        <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">quay.io/programming-kubernetes/pizza-apiserver:latest</code>&#13;
        <code class="nt">imagePullPolicy</code><code class="p">:</code> <code class="l-Scalar-Plain">Always</code>&#13;
        <code class="nt">command</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"/pizza-apiserver"</code><code class="p-Indicator">]</code>&#13;
        <code class="nt">args</code><code class="p">:</code>&#13;
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--etcd-servers=http://localhost:2379</code>&#13;
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--cert-dir=/tmp/certs</code>&#13;
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--secure-port=8443</code>&#13;
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--v=4</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd</code>&#13;
        <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">quay.io/coreos/etcd:v3.2.24</code>&#13;
        <code class="nt">workingDir</code><code class="p">:</code> <code class="l-Scalar-Plain">/tmp</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>A namespace for the service and the deployment to live in:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Namespace</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code>&#13;
<code class="nt">spec</code><code class="p">:</code> <code class="p-Indicator">{}</code></pre>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Often, the aggregated API server<a data-primary="masters" data-type="indexterm" id="idm46336845476968"/> is deployed to some nodes reserved for control plane pods, usually called <em>masters</em>. In that case, a <code>DaemonSet</code> is a good choice to run one custom API server instance per master node. This leads to a high availability setup. Note, that API servers are stateless, which means they can easily be deployed multiple times and no leader election is necessary.</p>&#13;
&#13;
<p>With these manifests, we are nearly done. As is so often the case, though, a secure deployment needs some more thought. You might have noticed that the pods (defined via the preceding deployment) use a custom<a data-primary="service account" data-type="indexterm" id="idm46336845424776"/> service account, <code>apiserver</code>. This can be created via another manifest:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ServiceAccount</code>&#13;
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">apiserver</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code></pre>&#13;
&#13;
<p>This service account needs a number of permissions, which we can add via RBAC objects.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Up RBAC" data-type="sect2"><div class="sect2" id="aggregated-apiserver-rbac">&#13;
<h2>Setting Up RBAC</h2>&#13;
&#13;
<p>The<a data-primary="deployment (custom API servers)" data-secondary="RBAC setup" data-type="indexterm" id="idm46336845412200"/><a data-primary="custom API servers" data-secondary="deploying" data-tertiary="RBAC setup" data-type="indexterm" id="idm46336845362968"/><a data-primary="role-based access control (RBAC)" data-type="indexterm" id="idm46336845361752"/> service account of an API service first needs some generic permissions to participate in:</p>&#13;
<dl>&#13;
<dt>namespace lifecycle</dt>&#13;
<dd>&#13;
<p>Objects can be created only in an existing namespace, and are deleted when the namespace is deleted. For this the API server has to get, list, and watch <span class="keep-together">namespaces</span>.</p>&#13;
</dd>&#13;
<dt>admission webhooks</dt>&#13;
<dd>&#13;
<p>Admission webhooks configured via <code>MutatingWebhookConfigurations</code> and <code><span class="keep-together">ValidatedWebhookConfigurations</span></code> are called from each API server independently. For this the admission mechanism in our custom API server has to get, list, and watch these resources.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>We configure both by creating an RBAC cluster role:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>&#13;
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">aggregated-apiserver-clusterrole</code>&#13;
<code class="nt">rules</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">resources</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"namespaces"</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code> <code class="s">"watch"</code><code class="p-Indicator">,</code> <code class="s">"list"</code><code class="p-Indicator">]</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"admissionregistration.k8s.io"</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">resources</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"mutatingwebhookconfigurations"</code><code class="p-Indicator">,</code> <code class="s">"validatingwebhookconfigurations"</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code> <code class="s">"watch"</code><code class="p-Indicator">,</code> <code class="s">"list"</code><code class="p-Indicator">]</code></pre>&#13;
&#13;
<p>and binding it to our service account <code>apiserver</code> via a <code>ClusterRoleBinding</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRoleBinding</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver-clusterrolebinding</code>&#13;
<code class="nt">roleRef</code><code class="p">:</code>&#13;
  <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">aggregated-apiserver-clusterrole</code>&#13;
<code class="nt">subjects</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ServiceAccount</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">apiserver</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code></pre>&#13;
&#13;
<p>For delegated authentication and authorization, the service account has to be bound to the preexisting RBAC role <code>extension-apiserver-authentication-reader</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">RoleBinding</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver-auth-reader</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">kube-system</code>&#13;
<code class="nt">roleRef</code><code class="p">:</code>&#13;
  <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Role</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">extension-apiserver-authentication-reader</code>&#13;
<code class="nt">subjects</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ServiceAccount</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">apiserver</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code></pre>&#13;
&#13;
<p>and the preexisting RBAC cluster role <code>system:auth-delegator</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRoleBinding</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver:system:auth-delegator</code>&#13;
<code class="nt">roleRef</code><code class="p">:</code>&#13;
  <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">system:auth-delegator</code>&#13;
<code class="nt">subjects</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ServiceAccount</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">apiserver</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">pizza-apiserver</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running the Custom API Server Insecurely" data-type="sect2"><div class="sect2" id="aggregated-apiserver-running">&#13;
<h2>Running the Custom API Server Insecurely</h2>&#13;
&#13;
<p>Now<a data-primary="custom API servers" data-secondary="deploying" data-tertiary="running insecurely" data-type="indexterm" id="idm46336845083592"/><a data-primary="deployment (custom API servers)" data-secondary="running insecurely" data-type="indexterm" id="idm46336845082344"/> with all manifests in place and RBAC set up, let’s deploy the API server to a real cluster.</p>&#13;
&#13;
<p>From a checkout of <a href="http://bit.ly/2x9C3gR">the GitHub repository</a>, and with configured <code>kubectl</code> with <code>cluster-admin</code> privileges (this is needed because RBAC rules can never escalate access):</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code><code class="nb">cd</code> <code class="nv">$GOPATH</code>/src/github.com/programming-kubernetes/pizza-apiserver&#13;
<code class="nv">$ </code><code class="nb">cd </code>artifacts/deployment&#13;
<code class="nv">$ </code>kubectl apply -f ns.yaml <code class="c"># create the namespace first</code>&#13;
<code class="nv">$ </code>kubectl apply -f .       <code class="c"># creating all manifests described above</code></pre>&#13;
&#13;
<p>Now the custom API server is launching:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get pods -A&#13;
NAMESPACE       NAME                            READY STATUS            AGE&#13;
pizza-apiserver pizza-apiserver-7779f8d486-8fpgj 0/2  ContainerCreating 1s&#13;
<code class="nv">$ </code><code class="c"># some moments later</code>&#13;
<code class="nv">$ </code>kubectl get pods -A&#13;
pizza-apiserver pizza-apiserver-7779f8d486-8fpgj 2/2  Running           75s</pre>&#13;
&#13;
<p>When<a data-primary="kubectl get apiservices" data-type="indexterm" id="idm46336845071960"/> it is running, we double-check that the Kubernetes API server does aggregation (i.e., proxying of requests). First check via <code>APIService</code>s whether the Kubernetes API server thinks that our custom API server is available:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get apiservices v1alpha1.restaurant.programming-kubernetes.info&#13;
NAME                                            SERVICE             AVAILABLE&#13;
v1alpha1.restaurant.programming-kubernetes.info pizza-apiserver/api True</pre>&#13;
&#13;
<p>This looks good. Let’s try to list pizzas, with logging enabled to see whether something goes wrong:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get pizzas --v<code class="o">=</code>7&#13;
...&#13;
... GET https://localhost:58727/apis?timeout<code class="o">=</code>32s&#13;
...&#13;
... GET https://localhost:58727/apis/restaurant.programming-kubernetes.info/&#13;
                                v1alpha1?timeout<code class="o">=</code>32s&#13;
...&#13;
... GET https://localhost:58727/apis/restaurant.programming-kubernetes.info/&#13;
                                v1beta1/namespaces/default/pizzas?limit<code class="o">=</code>500&#13;
... Request Headers:&#13;
...  Accept: application/json<code class="p">;</code><code class="nv">as</code><code class="o">=</code>Table<code class="p">;</code><code class="nv">v</code><code class="o">=</code>v1beta1<code class="p">;</code><code class="nv">g</code><code class="o">=</code>meta.k8s.io, application/json&#13;
...  User-Agent: kubectl/v1.15.0 <code class="o">(</code>darwin/amd64<code class="o">)</code> kubernetes/f873d2a&#13;
... Response Status: <code class="m">200</code> OK in <code class="m">6</code> milliseconds&#13;
No resources found.</pre>&#13;
&#13;
<p>This looks very good. We see that <code>kubectl</code> queries the discovery information to find out what a pizza is. It queries the <em>restaurant.programming-kubernetes.info/v1beta1</em> API to list the pizzas. Unsurprisingly, there aren’t any yet. But we can of course change that:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code><code class="nb">cd</code> ../examples&#13;
<code class="nv">$ </code><code class="c"># install toppings first</code>&#13;
<code class="nv">$ </code>ls topping* <code class="p">|</code> xargs -n <code class="m">1</code> kubectl create -f&#13;
<code class="nv">$ </code>kubectl create -f pizza-margherita.yaml&#13;
pizza.restaurant.programming-kubernetes.info/margherita created&#13;
<code class="nv">$ </code>kubectl get pizza -o yaml margherita&#13;
apiVersion: restaurant.programming-kubernetes.info/v1beta1&#13;
kind: Pizza&#13;
metadata:&#13;
  creationTimestamp: <code class="s2">"2019-05-05T13:39:52Z"</code>&#13;
  name: margherita&#13;
  namespace: default&#13;
  resourceVersion: <code class="s2">"6"</code>&#13;
  pizzas/margherita&#13;
  uid: 42ab6e88-6f3b-11e9-8270-0e37170891d3&#13;
spec:&#13;
  toppings:&#13;
  - name: mozzarella&#13;
    quantity: 1&#13;
  - name: tomato&#13;
    quantity: 1&#13;
status: <code class="o">{}</code></pre>&#13;
&#13;
<p>This looks awesome. But the margherita pizza was easy. Let’s try defaulting in action by creating an empty pizza that does not list any toppings:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting">apiVersion: restaurant.programming-kubernetes.info/v1alpha1&#13;
kind: Pizza&#13;
metadata:&#13;
  name: salami&#13;
spec:</pre>&#13;
&#13;
<p>Our<a data-primary="kubectl create -f" data-type="indexterm" id="idm46336844930520"/> defaulting should turn this into a salami pizza with a salami topping. Let’s try:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl create -f empty-pizza.yaml&#13;
pizza.restaurant.programming-kubernetes.info/salami created&#13;
<code class="nv">$ </code>kubectl get pizza -o yaml salami&#13;
apiVersion: restaurant.programming-kubernetes.info/v1beta1&#13;
kind: Pizza&#13;
metadata:&#13;
  creationTimestamp: <code class="s2">"2019-05-05T13:42:42Z"</code>&#13;
  name: salami&#13;
  namespace: default&#13;
  resourceVersion: <code class="s2">"8"</code>&#13;
  pizzas/salami&#13;
  uid: a7cb7af2-6f3b-11e9-8270-0e37170891d3&#13;
spec:&#13;
  toppings:&#13;
  - name: salami&#13;
    quantity: 1&#13;
  - name: mozzarella&#13;
    quantity: 1&#13;
  - name: tomato&#13;
    quantity: 1&#13;
status: <code class="o">{}</code></pre>&#13;
&#13;
<p>This looks like a delicious salami pizza.</p>&#13;
&#13;
<p>Now<a data-primary="kubectl delete" data-type="indexterm" id="idm46336844934472"/> let’s check whether our custom admission plug-in is working. We first delete all pizzas and toppings, and then try to re-create the pizzas:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl delete pizzas --all&#13;
pizza.restaurant.programming-kubernetes.info <code class="s2">"margherita"</code> deleted&#13;
pizza.restaurant.programming-kubernetes.info <code class="s2">"salami"</code> deleted&#13;
<code class="nv">$ </code>kubectl delete toppings --all&#13;
topping.restaurant.programming-kubernetes.info <code class="s2">"mozzarella"</code> deleted&#13;
topping.restaurant.programming-kubernetes.info <code class="s2">"salami"</code> deleted&#13;
topping.restaurant.programming-kubernetes.info <code class="s2">"tomato"</code> deleted&#13;
<code class="nv">$ </code>kubectl create -f pizza-margherita.yaml&#13;
Error from server <code class="o">(</code>Forbidden<code class="o">)</code>: error when creating <code class="s2">"pizza-margherita.yaml"</code>:&#13;
 pizzas.restaurant.programming-kubernetes.info <code class="s2">"margherita"</code> is forbidden:&#13;
   unknown topping: mozzarella</pre>&#13;
&#13;
<p>No margherita without mozzarella, like in any good Italian restaurant.</p>&#13;
&#13;
<p>Looks like we are done implementing what we described in <a data-type="xref" href="#aggregation-example">“Example: A Pizza Restaurant”</a>. But not quite. Security. Again. We have not taken care of the proper certificates. A malicious pizza seller could try to get between our users and the custom API server because the Kubernetes API server just accepts any serving certificates without checking them. Let’s fix this.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Certificates and Trust" data-type="sect2"><div class="sect2" id="aggregated-apiserver-certs">&#13;
<h2>Certificates and Trust</h2>&#13;
&#13;
<p>The <code>APIService</code> object<a data-primary="deployment (custom API servers)" data-secondary="certificates and trust" data-type="indexterm" id="idm46336844900328"/><a data-primary="custom API servers" data-secondary="deploying" data-tertiary="certificates and trust" data-type="indexterm" id="idm46336844899352"/><a data-primary="certificates and trust" data-type="indexterm" id="idm46336844898136"/> contains the <code>caBundle</code> field. This configures how the<a data-primary="aggregation" data-type="indexterm" id="idm46336844896920"/> aggregator (inside the Kubernetes API server) trusts the custom API server. This CA bundle contains the certificate (and intermediate certificates) used to verify that the aggregated API server has the identity it claims to have. For any serious deployment, put the corresponding CA bundle into this field.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>While <code>insecureSkipTLSVerify</code> is allowed in an <code>APIService</code> in order to disable certification verification, it is a bad idea to use this in a production setup. The Kubernetes API server sends requests to a trusted aggregated API server. Setting <code>insecureSkipTLSVerify</code> to <code>true</code> means that any other actor can claim to be the aggregated API server. This is obviously insecure and should not be used in production environments.</p>&#13;
</div>&#13;
&#13;
<p>The reverse trust from the custom API server to the Kubernetes API server, and its preauthentication of requests, is described in <a data-type="xref" href="#aggregated-authentication">“Delegated Authentication and Trust”</a>. We don’t have to do anything extra.</p>&#13;
&#13;
<p>Back to the pizza example: to make it secure, we need a serving certificate and a key for the custom API server in the deployment. We put both into a <code>serving-cert</code> secret and mount it into the pod at <em>/var/run/apiserver/serving-cert/tls.{crt,key}</em>. Then we use the <em>tls.crt</em> file as CA in the <code>APIService</code>. This can all be found in <a href="http://bit.ly/2XxtJWP">the example code on GitHub</a>.</p>&#13;
&#13;
<p>The certificate-generation logic is scripted in a <a href="http://bit.ly/2KGn0nw">Makefile</a>.</p>&#13;
&#13;
<p>Note that in a real-world scenario we’d probably have some kind of cluster or company CA we can plug into the <code>APIService</code>.</p>&#13;
&#13;
<p>To see it in action, either start with a new cluster or just reuse the previous one and apply the new, secure manifests:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code><code class="nb">cd</code> ../deployment-secure&#13;
<code class="nv">$ </code>make&#13;
openssl req -new -x509 -subj <code class="s2">"/CN=api.pizza-apiserver.svc"</code>&#13;
  -nodes -newkey rsa:4096&#13;
  -keyout tls.key -out tls.crt -days 365&#13;
Generating a <code class="m">4096</code> bit RSA private key&#13;
......................++&#13;
................................................................++&#13;
writing new private key to <code class="s1">'tls.key'</code>&#13;
...&#13;
<code class="nv">$ </code>ls *.yaml <code class="p">|</code> xargs -n <code class="m">1</code> kubectl apply -f&#13;
clusterrolebinding.rbac.authorization.k8s.io/pizza-apiserver:system:auth-delegator unchanged&#13;
rolebinding.rbac.authorization.k8s.io/pizza-apiserver-auth-reader unchanged&#13;
deployment.apps/pizza-apiserver configured&#13;
namespace/pizza-apiserver unchanged&#13;
clusterrolebinding.rbac.authorization.k8s.io/pizza-apiserver-clusterrolebinding unchanged&#13;
clusterrole.rbac.authorization.k8s.io/aggregated-apiserver-clusterrole unchanged&#13;
serviceaccount/apiserver unchanged&#13;
service/api unchanged&#13;
secret/serving-cert created&#13;
apiservice.apiregistration.k8s.io/v1alpha1.restaurant.programming-kubernetes.info configured&#13;
apiservice.apiregistration.k8s.io/v1beta1.restaurant.programming-kubernetes.info configured</pre>&#13;
&#13;
<p>Note here the correct common name <code>CN=api.pizza-apiserver.svc</code> in the certificate. The Kubernetes API server proxies the  request to the <em>api/pizza-apiserver</em> service and hence its DNS name must be put into the certificate.</p>&#13;
&#13;
<p>We double-check that we really have disabled the <code>insecureSkipTLSVerify</code> flag in the <code>APIService</code>:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get apiservices v1alpha1.restaurant.programming-kubernetes.info -o yaml&#13;
apiVersion: apiregistration.k8s.io/v1&#13;
kind: APIService&#13;
metadata:&#13;
  name: v1alpha1.restaurant.programming-kubernetes.info&#13;
  ...&#13;
spec:&#13;
  caBundle: LS0tLS1C...&#13;
  group: restaurant.programming-kubernetes.info&#13;
  groupPriorityMinimum: 1000&#13;
  service:&#13;
    name: api&#13;
    namespace: pizza-apiserver&#13;
  version: v1alpha1&#13;
  versionPriority: 15&#13;
status:&#13;
  conditions:&#13;
  - lastTransitionTime: <code class="s2">"2019-05-05T14:07:07Z"</code>&#13;
    message: all checks passed&#13;
    reason: Passed&#13;
    status: <code class="s2">"True"</code>&#13;
    <code class="nb">type</code>: Available&#13;
artifacts/deploymen</pre>&#13;
&#13;
<p>This looks as expected: <code>insecureSkipTLSVerify</code> is gone and the <code>caBundle</code> field is filled with a base64 value of our certificate And: the service is still available.</p>&#13;
&#13;
<p>Now let’s see whether <code>kubectl</code> can still query the API:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get pizzas&#13;
No resources found.&#13;
<code class="nv">$ </code><code class="nb">cd</code> ../examples&#13;
<code class="nv">$ </code>ls topping* <code class="p">|</code> xargs -n <code class="m">1</code> kubectl create -f&#13;
topping.restaurant.programming-kubernetes.info/mozzarella created&#13;
topping.restaurant.programming-kubernetes.info/salami created&#13;
topping.restaurant.programming-kubernetes.info/tomato created&#13;
<code class="nv">$ </code>kubectl create -f pizza-margherita.yaml&#13;
pizza.restaurant.programming-kubernetes.info/margherita created</pre>&#13;
&#13;
<p>The margherita pizza is back. This time it is perfectly secured. No chance for a malicious pizza seller to start a man-in-the-middle attack. Buon appetito!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sharing etcd" data-type="sect2"><div class="sect2" id="aggregated-apiserver-etcd">&#13;
<h2>Sharing etcd</h2>&#13;
&#13;
<p>Aggregated API<a data-primary="deployment (custom API servers)" data-secondary="sharing etcd" data-type="indexterm" id="idm46336844741864"/><a data-primary="custom API servers" data-secondary="deploying" data-tertiary="sharing etcd" data-type="indexterm" id="idm46336844740888"/> servers using the <code>RecommendOptions</code> (see <a data-type="xref" href="#aggregated-apiserver-development-options-config">“Options and Config Pattern and Startup Plumbing”</a>) use <code>etcd</code> for storage. This means that any deployment of a custom API server requires an <code>etcd</code> cluster to be available.</p>&#13;
&#13;
<p>This cluster can be in-cluster—for example, deployed using the <a href="http://bit.ly/2JTz8SK"><code>etcd</code> operator</a>. This operator allows us to launch and administrate an <code>etcd</code> cluster in a declarative way. The operator will do updates, up and down scaling, and backup. This reduces the operational overhead a lot.</p>&#13;
&#13;
<p>Alternatively, the <code>etcd</code> of the cluster control plane<a data-primary="kube-apiserver" data-type="indexterm" id="idm46336844752104"/> (i.e., that of <code>kube-apiserver</code>) can be used. Depending on the environment—self-deployed, on-premise, or hosted services like Google Container Engine (GKE)—this might be viable, or it might be impossible because the user has no access to the cluster at all (as is the case with GKE). In the viable cases, the custom API server has to use a key path that is distinct from the one used by the Kubernetes API server or other <code>etcd</code> consumers. In our example custom API server, it looks like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">const</code> <code class="nx">defaultEtcdPathPrefix</code> <code class="p">=</code>&#13;
    <code class="s">"/registry/pizza-apiserver.programming-kubernetes.github.com"</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">NewCustomServerOptions</code><code class="p">()</code> <code class="o">*</code><code class="nx">CustomServerOptions</code> <code class="p">{</code>&#13;
    <code class="nx">o</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">CustomServerOptions</code><code class="p">{</code>&#13;
        <code class="nx">RecommendedOptions</code><code class="p">:</code> <code class="nx">genericoptions</code><code class="p">.</code><code class="nx">NewRecommendedOptions</code><code class="p">(</code>&#13;
            <code class="nx">defaultEtcdPathPrefix</code><code class="p">,</code>&#13;
            <code class="o">...</code>&#13;
        <code class="p">),</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">o</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This <code>etcd</code> path prefix is different from Kubernetes API server paths, which use different group API names.</p>&#13;
&#13;
<p>Last but not least, <code>etcd</code> can be proxied. The project <a href="http://bit.ly/2Na2VrN">etcdproxy-controller</a> implements this mechanism using the operator pattern; that is, <code>etcd</code> proxies can be deployed automatically to the cluster and configured using <code>EtcdProxy</code> objects.</p>&#13;
&#13;
<p>The <code>etcd</code> proxies will automatically do key mapping, so it is guaranteed that <code>etcd</code> key prefixes will not conflict. This allows us to share <code>etcd</code> clusters for multiple aggregated API servers without worrying that one aggregated API server reads or changes the data of another one. This will improve security in an environment where shared <code>etcd</code> clusters are required, for example, due to resource constraints or to avoid operational overhead.</p>&#13;
&#13;
<p>Depending on the context, one of these options must be chosen. Finally, aggregated API servers can of course also use other storage backends, at least in theory, as it requires a lot of custom code to implement the <em>k8s.io/apiserver</em> storage interfaces.<a data-primary="" data-startref="CASdeploy08" data-type="indexterm" id="idm46336844640744"/><a data-primary="" data-startref="EPaggapi08" data-type="indexterm" id="idm46336844639736"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46336845900136">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This was a pretty large chapter, and you made it to the end. You’ve gotten a lot of background about APIs in Kubernetes and how they are implemented.</p>&#13;
&#13;
<p>We saw how aggregation of custom API servers fits into the architecture of a Kubernetes cluster. We saw how a custom API server receives requests that are proxies from the Kubernetes API server. We have seen how the Kubernetes API server preauthenticates these requests, and how API groups are implemented, with external versions and internal versions. We learned how objects are decoded into the Golang structs, how they are defaulted, how they are converted to internal types, and how they go through admission and validation and finally reach the registry. We saw how a strategy is plugged into a generic registry to implement “normal” Kubernetes-like REST resources, how we can add custom admissions, and how to configure a custom admission plug-in with a custom initializer. We now know how to do all the plumbing to start up a custom API server with a multiversion API group, and how to deploy the API group in a cluster with <code>APIServices</code>. We saw how to configure RBAC rules to allow the custom API server to do its job. We discussed how <code>kubectl</code> queries API groups. Finally, we learned how to secure the connection to our custom API server with certificates.</p>&#13;
&#13;
<p>This was a lot. Now you have a much better understanding of what APIs are in Kubernetes and how they are implemented, and hopefully you are motivated to do one or more of the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Implement your own custom API server</p>&#13;
</li>&#13;
<li>&#13;
<p>Learn about the inner workings of Kubernetes</p>&#13;
</li>&#13;
<li>&#13;
<p>Contribute to Kubernetes in the future</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We hope that you have found this a good starting point.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46336853170760"><sup><a href="ch08.html#idm46336853170760-marker">1</a></sup> Graceful deletion means that the client can pass a graceful deletion period as part of the deletion call. The actual deletion is done by a controller asynchronously (the <code>kubelet</code> does that for pods) by doing a forced deletion. This way pods have time to cleanly shut down.</p><p data-type="footnote" id="idm46336853165528"><sup><a href="ch08.html#idm46336853165528-marker">2</a></sup> Kubernetes uses cohabitation to migrate resources (e.g., deployments from the <code>extensions/v1beta1</code> API group) to subject-specific API groups (e.g., <code>apps/v1</code>). CRDs have no concept of shared storage.</p><p data-type="footnote" id="idm46336853099640"><sup><a href="ch08.html#idm46336853099640-marker">3</a></sup> We’ll see in <a data-type="xref" href="ch09.html#ch_advanced-topics">Chapter 9</a> that CRD conversion and admission webhooks available in the latest Kubernetes versions also allow us to add these features to CRDs.</p><p data-type="footnote" id="idm46336852602264"><sup><a href="ch08.html#idm46336852602264-marker">4</a></sup> PaaS stands for Platform as a Service.</p></div></div></section></body></html>