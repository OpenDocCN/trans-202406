- en: Chapter 6\. Server-Side React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React has evolved considerably since its inception. Although it started as a
    client-side library, the demand for server-side rendering (SSR) has grown over
    time for reasons we will come to understand in this chapter. Together, we will
    explore server-side React and understand how it differs from client-only React,
    and how it can be used to level up our React applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve discussed in earlier chapters, React was initially developed by Meta
    to address the need for efficient and scalable UIs. In [Chapter 3](ch03.html#ch03)
    we looked at how it does this through the virtual DOM, which enables developers
    to create and manage UI components with ease. React’s client-side approach unlocked
    fast, responsive user experiences across the web. However, as the web continued
    to evolve, the limitations of client-side rendering became more apparent.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Client-Side Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: user interfaces with React since it was first released as open source software
    in 2013. Eventually, a number of limitations with this approach started to appear.
    These limitations eventually led to us moving more and more concerns to the server
    side.
  prefs: []
  type: TYPE_NORMAL
- en: SEO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the significant limitations of client-side rendering is that search engine
    crawlers may not correctly index the content, as some of them do not execute JavaScript,
    or those that do execute JavaScript may not execute it as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Given the wide variety of search engine crawler implementations, along with
    the fact that a lot of them are proprietary and unknowable to the public, this
    makes client-only rendering somewhat questionable with regard to the reach of
    a given website or application.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, an article from [Search Engine Land in 2015](https://oreil.ly/r5hF2)
    described some experiments to test how various search engines work with client-only
    applications, and this is what they mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: We ran a series of tests that verified Google is able to execute and index JavaScript
    with a multitude of implementations. We also confirmed Google is able to render
    the entire page and read the DOM, thereby indexing dynamically generated content.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This article found that at the time of writing, Google and Bing were advanced
    enough to index client-only websites, but ultimately this is just one research
    project in an otherwise vast and unknowable proprietary ocean.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, while client-only applications may work well with modern search engines,
    there is an inherent risk in not having a server-based counterpart. In traditional
    web applications, when a user or a search engine crawler requests a page, the
    server renders the HTML for the page and sends it back. The HTML contains all
    the content, links, and data, making it easy for search engine crawlers to read
    and index the content for search engine results since all the content of the page
    is nothing more than text, i.e., markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in a client-side rendered application, often built with libraries
    or frameworks like React, the server sends back a near-empty HTML file whose sole
    job is to load JavaScript from a separate JavaScript file on the same or an alternate
    server. The JavaScript file then downloads and executes in the browser, rendering
    the page content dynamically. This approach provides a smooth user experience,
    resembling that of a native application, but it has a downside when it comes to
    search engine optimization (SEO) and performance: we don’t download anything useful
    for human readers on the first request, but instead have to do another request
    immediately after the page loads for the JavaScript that will power the entire
    site. This is known as a network waterfall.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, another downside of client-only rendering is performance. Let’s talk about
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Client-side rendered applications may suffer from performance issues, especially
    on slow networks or less powerful devices. The need to download, parse, and execute
    JavaScript before rendering the content can lead to significant delays in content
    rendering. This “time to interactive” is a crucial metric as it directly impacts
    user engagement and bounce rates (bounce as in the rate at which users abandon
    a page). Users might leave a page if it takes too long to load, and this behavior
    can further negatively impact the SEO ranking of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if a device is low-powered with minimal CPU availability, client-only
    rendering also creates a poor user experience. This is because the device may
    not have enough processing power to execute the JavaScript quickly, resulting
    in a slow and unresponsive application. This can lead to frustrated users and
    a poor user experience. If we executed this JavaScript on the server and sent
    minimal data or markup to the client, low-power clients don’t have to do much
    work and thus the user experience is better.
  prefs: []
  type: TYPE_NORMAL
- en: On a broader spectrum, the issues of SEO and performance in client-side rendered
    applications highlight the importance of adhering to web standards and best practices.
    They also underline the need for server-side rendering or static site generation
    as more reliable alternatives for delivering content in a performant and accessible
    manner, especially for content-heavy sites or applications.
  prefs: []
  type: TYPE_NORMAL
- en: The principle of progressive enhancement, where basic content and functionality
    are delivered to all browsers, while advanced features are considered as an enhancement,
    aligns well with these alternatives. By rendering the core content server-side,
    you ensure that all users and search engines have access to the fundamental content
    and functionality, regardless of JavaScript execution. Then, client-side JavaScript
    can enhance the user experience by adding interactivity, richer animations, and
    other advanced features for the browsers and devices that can support them. It
    does not make any sense to have *the entire experience* be client-side JavaScript
    only, as this is not the original design of the web. JavaScript’s role is to *enhance*
    a web page, not *be* a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are fetching data from an API and rendering it on the client
    side. We can tell it’s the client side because we are using the `useEffect` hook
    to fetch the data, and the `useState` hook to store the data in state. The `useEffect`
    hook executes inside a browser (a client) only.
  prefs: []
  type: TYPE_NORMAL
- en: A serious limitation with this is that some search engine crawlers may not be
    able to see this content unless we implement server-side rendering. Instead, there
    is a risk that they see a blank screen or a fallback message, which can result
    in poor SEO.
  prefs: []
  type: TYPE_NORMAL
- en: Another common problem with client-only applications is network waterfalls,
    wherein the initial page load is blocked by the amount of JavaScript that needs
    to be downloaded, parsed, and executed by the browser before the website or web
    app becomes visible. In cases where network connectivity is a limited resource,
    this would render a website or application completely unresponsive for significant
    amounts of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we’re initiating a data fetch request to an external API endpoint
    (`https://api.example.com/data`) to retrieve some data. This fetch happens *after*
    our initial JavaScript bundle is downloaded, parsed, and executed, and that happens
    only *after* the initial HTML loads. This is a network waterfall and leads to
    less-than-optimal performance. If we visualize it, it would look like [Figure 6-1](#figure6-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![frea 0601](assets/frea_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Data fetch request
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Yuck. With server-side rendering, we can do better and enable our users to
    see useful content immediately, altering the diagram to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, the first load is already packed with information that is useful to
    the user because we fetched our data and rendered our component on the server.
    There is no waterfall here, and the user gets all their information immediately.
    This is the value of server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: As of React 18, the bundle sizes of React and React DOM are 6.4 kB and 130.2
    kB, respectively. These sizes are for the latest version of React at the time
    of writing and may vary depending on the version and configuration of React that
    you are using today. This means that even in production environments, our users
    have to download around 136 kB of JavaScript just for React alone (i.e., React
    + React DOM), before downloading, parsing, and executing the rest of our application’s
    code. This can result in a slower initial page load, especially on slower devices
    and networks, and potentially frustrated users. Moreover, because React essentially
    owns the DOM and we have no user interface without React in client-only applications,
    our users have no choice but to wait for React and React DOM to load *first* before
    the rest of our application does.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, a server rendered application would stream rendered HTML to the
    client before any JavaScript downloads, enabling users to get meaningful content
    immediately. It would then load relevant JavaScript after the initial page renders,
    probably while the user is still orienting themselves with a user interface through
    a process called “hydration.” More on this in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially streaming rendered HTML and then hydrating the DOM with JavaScript
    allows users to interact with the application sooner, resulting in a better user
    experience: it is immediately available to the user without them having to wait
    for any extras—that they may or may not even need—to load.'
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Client-only rendering can also have security issues, especially when dealing
    with sensitive data. This is because all of the application’s code is downloaded
    to the client’s browser, making it vulnerable to attacks such as cross-site request
    forgery (CSRF).
  prefs: []
  type: TYPE_NORMAL
- en: Without getting too much into the weeds about CSRF, a common way to mitigate
    against it is to have control of the server that serves the website or web app
    to your users. If we have control of this server, we can send appropriate anti-CSRF
    tokens from the server as a trusted source to the client, and then the client
    submits the tokens via a form or similar back to the server, which can verify
    that the request is coming from the correct client. This is a common way to mitigate
    against CSRF.
  prefs: []
  type: TYPE_NORMAL
- en: While it is technically possible to serve client-only applications from a static
    site server we control, and mitigate against CSRF that way, it’s still not the
    best way to serve a website in general because of the other trade-offs we’ve discussed
    so far. If we do have control of a server, then why not add SSR to it from there?
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, here’s what we’re saying:'
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t have access to the server side but work in a team where it’s just
    `git push` frontend client-only code and then it’s magically deployed somewhere,
    there are inherent CSRF risks here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have access to the server side and if our website or web app is still
    client only, we can mitigate against CSRF quite well already and the security
    risks around it go away.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have access to the server side and if our website or web app is still
    client only, there’s a strong argument to be made to add server-side rendering
    to it, since we have access to the server, enabling the other benefits around
    SEO and performance that we’ve already covered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s get a little bit practical and consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `handleWithdrawal` sends a `POST` request to a hypothetical server-side
    endpoint `/withdraw` to process the withdrawal. A CSRF risk could occur if this
    endpoint does not properly validate the origin of the request and doesn’t require
    any form of anti-CSRF token.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker could create a malicious webpage that tricks a user into clicking
    a button, which then sends a `POST` request to the `/withdraw` endpoint on the
    user’s behalf, possibly leading to unauthorized withdrawals from the user’s account.
    This is because the browser automatically includes cookies in the request, which
    the server uses to authenticate the user. If the server does not validate the
    origin of the request, it could be tricked into processing the request and sending
    the funds to the attacker’s account.
  prefs: []
  type: TYPE_NORMAL
- en: If this component is rendered on the client side, it could be vulnerable to
    CSRF attacks because the server and client do not have a shared common secret
    or contract between them. To speak poetically, the client and server don’t know
    each other. This could allow an attacker to steal funds or manipulate the application’s
    data.
  prefs: []
  type: TYPE_NORMAL
- en: If we used server rendering, we could mitigate these security issues by rendering
    the component on the server with a special secret token generated by the server,
    and then sending HTML containing the secret token to the client. The client would
    then send this token back to the server that issued it, establishing a secure
    bidirectional contract. This would allow the server to verify that the request
    is coming from the correct client that it has preauthorized and not an unknown
    one, which could possibly be a malicious attacker.
  prefs: []
  type: TYPE_NORMAL
- en: The Rise of Server Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For these reasons, server-side rendering has emerged as an arguably superior
    technique for improving the performance and user experience of web applications.
    With server rendering, applications can be optimized for speed and accessibility,
    resulting in faster load times, better SEO, and improved user engagement.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Server Rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s dive deeper into the benefits of server rendering. These should become
    immediately clear as we further understand the limitations of client-only rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: The time to first meaningful paint is faster with server rendering.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the server can render the initial HTML markup and send it to
    the client, which can then be displayed immediately. This is in contrast to client-only
    rendering, where the client must wait for the JavaScript to be downloaded, parsed,
    and executed before the application can be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Server rendering improves the accessibility of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Users with slow internet connections or low-power devices may have a better
    experience if they receive fully rendered HTML instead of waiting for client-side
    JavaScript to load and render the page.
  prefs: []
  type: TYPE_NORMAL
- en: Server rendering can improve the SEO of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: When search engine crawlers index your site, they can see the fully rendered
    HTML, making it easier for them to understand the content and structure of your
    site.
  prefs: []
  type: TYPE_NORMAL
- en: Server rendering can also improve the security of web applications.
  prefs: []
  type: TYPE_NORMAL
- en: By rendering the core content server-side, you ensure that all users and search
    engines have access to the fundamental content and functionality, regardless of
    JavaScript execution. Then, client-side JavaScript can enhance the user experience
    by adding interactivity, richer animations, and other advanced features for the
    browsers and devices that can support them.
  prefs: []
  type: TYPE_NORMAL
- en: However, server rendered HTML is static and lacks interactivity as it does not
    have any JavaScript initially loaded. It includes no event listeners or other
    dynamic functionality attached. To enable user interactions and other dynamic
    features, the static HTML must be “hydrated” with the necessary JavaScript code.
    Let’s understand the concept of hydration a little better.
  prefs: []
  type: TYPE_NORMAL
- en: Hydration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hydration* is a term used to describe the process of attaching event listeners
    and other JavaScript functionality to static HTML that is generated on the server
    and sent to the client. The goal of hydration is to enable a server rendered application
    to become fully interactive after being loaded in the browser, providing users
    with a fast and smooth experience.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a React application, hydration happens after a client downloads a server
    rendered React application. Then, the following steps occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading the client bundle
  prefs: []
  type: TYPE_NORMAL
- en: While the browser is rendering the static HTML, it also downloads and parses
    the JavaScript bundle that contains the application’s code. This bundle includes
    the React components and any other code that is necessary for the application’s
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching event listener
  prefs: []
  type: TYPE_NORMAL
- en: Once the JavaScript bundle is loaded, React “hydrates” the static HTML by attaching
    event listeners and other dynamic functionality to the DOM elements. This is typically
    done using the `hydrateRoot` function from `react-dom`, which takes the root React
    component and the DOM container as arguments. Hydration essentially transforms
    the static HTML into a fully interactive React application.
  prefs: []
  type: TYPE_NORMAL
- en: After the hydration process is complete, the application is fully interactive
    and can respond to user input, fetch data, and update the DOM, as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: During hydration, React matches the structure of the DOM elements in the static
    HTML to the structure defined by the React components via JSX. It is crucial that
    the structure generated by the React components matches the structure of the static
    HTML. If there is a mismatch, React will not be able to correctly attach event
    listeners and will not be aware of what React element directly maps to what DOM
    element, which results in the application not behaving as expected.
  prefs: []
  type: TYPE_NORMAL
- en: By combining server-side rendering and hydration, developers can create web
    applications that load quickly and provide a smooth, interactive user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Hydration Considered Harmful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While hydration is a great way to take server rendered HTML and make it interactive,
    some criticize hydration for being slower than necessary, often citing resumability
    as a superior alternative (see [Figure 6-2](#figure6-2)). Let’s explore this a
    little bit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hydration](assets/frea_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Hydration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With hydration, we render a React application on the server and then pass the
    rendered output to a client. However, at this point in time, nothing is interactive.
    From here, our browser needs to download the client bundle, attach event listeners,
    and effectively “rerender” the client. This is a lot of work, and sometimes presents
    a delay between when content appears to a user and when the user can actually
    use the site.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, resumability works slightly differently, as shown in [Figure 6-3](#figure6-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Resumability](assets/frea_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. Resumability
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With resumability, the entire application is rendered on the server and streamed
    to a browser. Along with the initial markup, all interactive behavior is serialized
    and also sent to the client. From there, the client already has all the information
    on how to become interactive on demand and thus *resume* where the server left
    off. It does not need to hydrate (that is, attach event listeners and render the
    page on the client side), but instead can deserialize the stuff the server gave
    it and react accordingly. Skipping the hydration step can result in a faster time
    to interactive (TTI) and a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there is measurable benefit to resumability, the engineering community
    questions whether the complexity of implementing it is worth the benefit. Indeed,
    it is a more complex approach than hydration, and it is not yet clear whether
    the benefits outweigh the costs: yes, time to interactive is faster by a few milliseconds,
    but is it worth the complexity of implementing resumability? This is a question
    that is still being debated in the React community.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Server Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have an existing client-only React app, you may be wondering how to add
    server rendering to it. Fortunately, it’s relatively straightforward to add server
    rendering to an existing React app. One approach is to use a server rendering
    framework, such as Next.js or Remix. While these frameworks are indeed the best
    way to server rendered React applications, abstractions like this can leave the
    more curious of us hungry to understand the underlying mechanisms used to accomplish
    this.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a curious person and are interested in how you would add server rendering
    to a client-only React app manually, or if you’re interested in how frameworks
    do it, read on. Once again, this is stuff you’d probably not use in production,
    but is more for educational purposes for the curious.
  prefs: []
  type: TYPE_NORMAL
- en: Manually Adding Server Rendering to a Client-Only React App
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’ve got a client-only application, this is how you’d add server rendering
    to it. First, you’d create a *server.js* file in the root of your project. This
    file will contain the code for your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re using Express to create a server that serves static files
    from the *./build* directory and then renders our React app on the server. We’re
    also using `ReactDOMServer` to render our React app to an HTML string and then
    inject it into the response sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, we’re assuming our client-only React app has some type of
    `build` script that would output a client-only JavaScript bundle into a directory
    called *build* that we reference in the snippet. This is important for hydration.
    With all these pieces in order, let’s go ahead and start our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Running this command should start our server on port 3000 and should output
    `Server listening on port 3000`.
  prefs: []
  type: TYPE_NORMAL
- en: With these steps, we now have a server rendered React app. By taking this “peek
    under the hood” approach to server rendering, we gain a deeper understanding of
    how server rendering works and how it can benefit our React applications.
  prefs: []
  type: TYPE_NORMAL
- en: If we open a browser and visit *[*http://localhost:3000*](http://localhost:3000)*,
    we should see a server rendered application. We can confirm that it is in fact
    server rendered by viewing the source code of this page, which should reveal actual
    HTML markup instead of a blank document.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completion, this is what the HTML markup should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the HTML markup that is sent to the client. It contains the fully rendered
    HTML for our React app, which can be indexed by search engines and more efficiently
    accessed by users with slow or unreliable internet connections. This can result
    in better SEO and improved accessibility for our React app.
  prefs: []
  type: TYPE_NORMAL
- en: Hydrating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With server rendered output making it to users, hydration happens when we load
    our client bundle with the `<script>` tag toward the end of the file. As discussed,
    hydration is the process of attaching event listeners and other JavaScript functionality
    to static HTML that is generated on the server and sent to the client. The goal
    of hydration is to enable a server rendered application to become fully interactive
    after being loaded in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to explore the hydration step of the client-side bundle of our app,
    it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With server rendering and client hydration, our app is fully interactive and
    can respond to user input, fetch data, and update the DOM, as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Server Rendering APIs in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we manually added server rendering to a client-only
    React app using Express and `ReactDOMServer`. Specifically, we used `ReactDOMServer.renderToString()`
    to render our React app to an HTML string. This is the most basic way to add server
    rendering to a React app. However, there are other ways to add server rendering
    to React apps. Let’s take a deeper look at server rendering APIs exposed by React
    and understand when and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the `renderToString` API in detail, exploring its usage, advantages,
    disadvantages, and when it is appropriate to use it in a React application. Specifically,
    let’s look into:'
  prefs: []
  type: TYPE_NORMAL
- en: What it is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it fits into our everyday usage of React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start with this, let’s talk about what it is.
  prefs: []
  type: TYPE_NORMAL
- en: renderToString
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`renderToString` is a server-side rendering API provided by React that enables
    you to render a React component into an HTML string on the server. This API is
    synchronous and returns a fully rendered HTML string, which can then be sent to
    the client as a response. `renderToString` is commonly used in server rendered
    React applications to improve performance, SEO, and accessibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use `renderToString`, you’d need to import the `renderToString` function
    from the `react-dom/server` package. Then, you can call the function with a React
    component as its argument. It will then return the fully rendered HTML as a string.
    Here’s an example of using `renderToString` to render a simple React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a simple App component and call `renderToString`
    with the component as its argument. The function returns the fully rendered HTML,
    which can be sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function traverses the tree of React elements, converts them to a string
    representation of real DOM elements, and finally outputs a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth recalling here that in React, `<div>` is converted to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'whose output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve covered this in prior chapters, but it’s worth recalling here for the
    discussion we’re about to have. Fundamentally, JSX turns into HTML with the following
    flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`renderToString` as an API is synchronous and blocking, meaning it cannot be
    interrupted or paused. If a component tree from the root is many levels deep,
    it can require quite a bit of processing. Since a server typically services multiple
    clients, `renderToString` could be called for each client unless there’s some
    type of cache preventing this, and quickly block the event loop and overload the
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, `renderToString` converts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because React is declarative and React elements are declarative abstractions,
    a tree of them can be turned into a tree of anything else—in this case, a tree
    of React elements is turned into a string-representation of a tree of HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While `renderToString` offers several advantages, it also has some downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs: []
  type: TYPE_NORMAL
- en: One of the main disadvantages of `renderToString` is that it can be slow for
    large React applications. Because it is synchronous, it can block the event loop
    and make the server unresponsive. This can be especially problematic if you have
    a high-traffic application with many concurrent users.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, `renderToString` returns a fully rendered HTML string, which can be
    memory intensive for large applications. This can lead to increased memory usage
    on your server and potentially slower response times, or a panic that kills the
    server process under heavy load.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of streaming support
  prefs: []
  type: TYPE_NORMAL
- en: '`renderToString` does not support streaming, which means that the entire HTML
    string must be generated before it can be sent to the client. This can result
    in a slower time to first byte (TTFB) and a longer time for the client to start
    receiving the HTML. This limitation can be particularly problematic for large
    applications with lots of content, as the client must wait for the entire HTML
    string to be generated before any content can be displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: For larger applications or situations where the downsides of `renderToString`
    become problematic, React offers alternative APIs for server-side rendering, such
    as `renderToPipeableStream` and `renderToReadableStream`. These APIs return a
    Node.js stream and a browser stream, respectively, instead of a fully rendered
    HTML string, which can provide better performance and support for streaming. We
    will cover these more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: renderToPipeableStream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`renderToPipeableStream` is a server-side rendering API introduced in React
    18\. It provides a more efficient and flexible way to render large React applications
    to a Node.js stream. It returns a stream that can be piped to a response object.
    `renderTo​Pi⁠peableStream` provides more control over how the HTML is rendered
    and allows for better integration with other Node.js streams.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it fully supports React’s concurrent features, including Suspense,
    which unlocks better handling of asynchronous data fetching during server-side
    rendering. Because it is a stream, it is also streamable over the network, where
    chunks of HTML can be asynchronously and cumulatively sent to clients over the
    network without blocking. This leads to faster TTFB measures and generally better
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To rewrite our earlier server using `renderToPipeableStream`, we’d do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let’s dive deep into `renderToPipeableStream`, discussing its features, advantages,
    and use cases. We’ll also provide code snippets and examples to help you better
    understand how to implement this API in your React applications.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to `renderToString`, `renderToPipeableStream` takes a declaratively
    described tree of React elements and, instead of turning them into a string of
    HTML, turns the tree into a Node.js stream. A Node.js stream is a fundamental
    concept in the Node.js runtime environment that enables efficient data processing
    and manipulation. Streams provide a way to handle data incrementally in chunks,
    rather than loading the entire data set into memory at once. This approach is
    particularly useful when dealing with large strings or data streams that cannot
    fit entirely in memory or over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js streams
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At its core, a Node.js stream represents a flow of data between a source and
    a destination. It can be thought of as a pipeline through which data flows, with
    various operations applied to transform or process the data along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js streams are categorized into four types based on their nature and direction
    of data flow:'
  prefs: []
  type: TYPE_NORMAL
- en: Readable streams
  prefs: []
  type: TYPE_NORMAL
- en: A readable stream represents a source of data from which you can read. It emits
    events like `data`, `end`, and `error`. Examples of readable streams include reading
    data from a file, receiving data from an HTTP request, or generating data using
    a custom generator.
  prefs: []
  type: TYPE_NORMAL
- en: React’s `renderToPipeableStream` function returns a readable stream where you
    can read a stream of HTML and output it to a writable stream like the `res` response
    object from Express.
  prefs: []
  type: TYPE_NORMAL
- en: Writable streams
  prefs: []
  type: TYPE_NORMAL
- en: A writable stream represents a destination where you can write data. It provides
    methods like `write()` and `end()` to send data into the stream. Writable streams
    emit events like `drain` when the destination can handle more data, and `error`
    when an error occurs during writing. Examples of writable streams include the
    Express `res` response object.
  prefs: []
  type: TYPE_NORMAL
- en: Duplex streams
  prefs: []
  type: TYPE_NORMAL
- en: A duplex stream represents both a readable and writable stream simultaneously.
    It allows bidirectional data flow, meaning you can both read from and write to
    the stream. Duplex streams are commonly used for network sockets or communication
    channels where data needs to flow in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Transform streams
  prefs: []
  type: TYPE_NORMAL
- en: A transform stream is a special type of duplex stream that performs data transformations
    while data flows through it. It reads input data, processes it, and provides the
    processed data as output. Transform streams can be used to perform tasks such
    as compression, encryption, decompression, or data parsing.
  prefs: []
  type: TYPE_NORMAL
- en: One of the powerful features of Node.js streams is the ability to pipe data
    between streams. Piping allows you to connect the output of a readable stream
    directly to the input of a writable stream, creating a seamless flow of data.
    This greatly simplifies the process of handling data and reduces memory usage.
    Indeed, this is how streaming server-side rendering in React works.
  prefs: []
  type: TYPE_NORMAL
- en: Streams in Node.js also support backpressure handling. Backpressure is a problem
    that occurs during data handling and describes a buildup of data behind a buffer
    during data transfer. When the writable stream is unable to handle data quickly
    enough, the readable stream will pause emitting `data` events, preventing data
    loss. Once the writable stream is ready to consume more data, it emits a `drain`
    event, signaling the readable stream to resume emitting data.
  prefs: []
  type: TYPE_NORMAL
- en: Without diving too deep and digressing too much here, Node.js streams are a
    powerful abstraction for handling data in a scalable and memory-efficient manner.
    By breaking data into manageable chunks and allowing incremental processing, streams
    enable efficient handling of large data sets, file I/O operations, network communication,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: React’s renderToPipeableStream
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In React, the purpose of streaming React components to a writable stream is
    to enhance the TTFB performance of server rendered applications. Instead of waiting
    for the entire HTML markup to be generated before sending it to the client, these
    methods enable the server to start sending chunks of the HTML response as they
    are ready, thus reducing the overall latency.
  prefs: []
  type: TYPE_NORMAL
- en: The `renderToPipeableStream` function is a part of React’s server renderer,
    which is designed to support streaming rendering of a React application to a Node.js
    stream. It’s a part of the server renderer architecture called “Fizz.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’re about to dive super deep into React implementation details that are prone
    to change over time. Once again, this is for educational purposes and to satisfy
    the curiosity of the reader. It may not perfectly match the implementation details
    of React at the time of reading, but it’s close enough to get a good idea of how
    this works at the time of writing. This stuff is probably not something you’d
    use in production and is nonessential to knowing how to use React, but is just
    for education and curiosity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without distracting from our context of server rendering too much, here’s a
    simplified explanation of the flow of how server rendering works:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a request
  prefs: []
  type: TYPE_NORMAL
- en: The function `renderToPipeableStream` takes as input the React elements to be
    rendered and an optional options object. It then creates a request object using
    a `createRequestImpl` function. This request object encapsulates the React elements,
    resources, response state, and format context.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the work
  prefs: []
  type: TYPE_NORMAL
- en: After creating the request, the `startWork` function is called with the request
    as an argument. This function initiates the rendering process. The rendering process
    is asynchronous and can be paused and resumed as needed, which is where React
    Suspense comes in. If a component is wrapped in a Suspense boundary and it initiates
    some asynchronous operation (like data fetching), the rendering of that component
    (and possibly its siblings) can be “suspended” until the operation finishes.
  prefs: []
  type: TYPE_NORMAL
- en: While a component is suspended, it can be rendered in a “fallback” state, which
    is typically a loading indicator or a placeholder. Once the operation finishes,
    the component is “resumed” and rendered in its final state. Suspense is a powerful
    feature that enables React to handle asynchronous data fetching and lazy loading
    more effectively during server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits are that we are able to serve the user a meaningful page immediately,
    and then progressively enhance it with more data as it becomes available. This
    is a powerful technique that can be used to improve the user experience of React
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a pipeable stream
  prefs: []
  type: TYPE_NORMAL
- en: '`renderToPipeableStream` then returns an object that includes a `pipe` method
    and an `abort` method. The `pipe` method is used to pipe the rendered output to
    a writable stream (like an HTTP response object in Node.js). The `abort` method
    can be used to cancel any pending I/O and put anything remaining into client-rendered
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Piping to a destination
  prefs: []
  type: TYPE_NORMAL
- en: When the `pipe` method is called with a destination stream, it checks if the
    data has already started flowing. If not, it sets `hasStartedFlowing` to `true`
    and calls the `startFlowing` function with the request and the destination. It
    also sets up handlers for the `drain`, `error`, and `close` events of the destination
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: Handling stream events
  prefs: []
  type: TYPE_NORMAL
- en: The `drain` event handler calls `startFlowing` again to resume the flow of data
    when the destination stream is ready to receive more data. The `error` and `close`
    event handlers call the `abort` function to stop the rendering process if an error
    occurs in the destination stream or if the stream is closed prematurely.
  prefs: []
  type: TYPE_NORMAL
- en: Aborting the rendering
  prefs: []
  type: TYPE_NORMAL
- en: The `abort` method on the returned object can be called with a reason to stop
    the rendering process. It calls the `abort` function from the `react-server` module
    with the request and the reason.
  prefs: []
  type: TYPE_NORMAL
- en: The actual implementation of these functions involves more complex logic to
    handle things like progressive rendering, error handling, and integration with
    the rest of the React server renderer. The code for these functions can be found
    in the `react-server` and `react-dom` packages of the React source code.
  prefs: []
  type: TYPE_NORMAL
- en: Features of renderToPipeableStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`renderToPipeableStream` features include:'
  prefs: []
  type: TYPE_NORMAL
- en: Streaming
  prefs: []
  type: TYPE_NORMAL
- en: '`renderToPipeableStream` returns a pipeable Node.js stream, which can be piped
    to a response object. This allows the server to start sending the HTML to the
    client before the entire page is rendered, providing a faster user experience
    and better performance for large applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility
  prefs: []
  type: TYPE_NORMAL
- en: '`renderToPipeableStream` offers more control over how the HTML is rendered.
    It can be easily integrated with other Node.js streams, allowing developers to
    customize the rendering pipeline and create more efficient server-side rendering
    solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Suspense support
  prefs: []
  type: TYPE_NORMAL
- en: '`renderToPipeableStream` fully supports React’s concurrent features, including
    Suspense. This allows developers to manage asynchronous data fetching and lazy
    loading more effectively during server-side rendering, ensuring that data-dependent
    components are only rendered once the necessary data is available.'
  prefs: []
  type: TYPE_NORMAL
- en: How it fits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at some code that illustrates the benefits of this API. We
    have an application that displays a list of dog breeds. The list is populated
    by fetching data from an API endpoint. The application is rendered on the server
    using `renderTo​Pi⁠peableStream` and then sent to the client. Let’s start by looking
    at our dog list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at our overall `App` that contains the `DogBreeds` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice, we’re using `React.lazy` here as mentioned in prior chapters, just
    so we have another Suspense boundary to demonstrate how `renderToPipeableStream`
    handles Suspense. OK, let’s tie this all together with an Express server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What we’re doing in this code snippet is responding to a request with a stream
    of HTML. We’re using `renderToPipeableStream` to render our `App` component to
    a stream, and then piping that stream to our response object. We’re also using
    the `onShellReady` option to pipe the stream to the response object once the shell
    is ready. The shell is the HTML that is rendered before the React application
    is hydrated, and before data dependencies wrapped in Suspense boundaries are resolved.
    In our case, the shell is the HTML that is rendered before the dog breeds are
    fetched from the API. Let’s take a look at what happens when we run this code.
  prefs: []
  type: TYPE_NORMAL
- en: If we visit *[*http://localhost:3000*](http://localhost:3000)*, we get a page
    with a heading “Dog Breeds,” and our Suspense fallback “Loading Dog Breeds….”
    This is the shell that is rendered before the dog breeds are fetched from the
    API. The really cool thing is that even if we don’t include React on the client
    side in our HTML and hydrate the page, the Suspense fallback is replaced with
    the actual dog breeds once they are fetched from the API. This swapping of DOM
    when data becomes available happens entirely from the server side, without client-side
    React!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand how this works in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once again, we are about to dive deep into React implementation details here
    that are quite likely to change over time. The point of this exercise (and this
    book) is not to obsess over single implementation details, but instead to understand
    the underlying mechanism so we can learn and reason about React better. This isn’t
    required to *use* React, but understanding the mechanism can give us hints and
    practical tools to use in our day-to-day working with React. With that, let’s
    move forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we visit *[*http://localhost:3000*](http://localhost:3000)*, the server
    responds with the HTML shell, which includes the heading “Dog Breeds” and the
    Suspense fallback “Loading Dog Breeds….” This HTML looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What we see here is quite interesting. There’s a `<template>` element with a
    generated ID (`B:0` in this case), and some HTML comments. The HTML comments are
    used to mark the start and end of the shell. These are markers or “holes” where
    resolved data will go once Suspense is resolved. `<template>` elements in HTML
    provide a way to construct document subtrees and hold nodes without introducing
    an additional wrapping level of the DOM hierarchy. They serve as lightweight containers
    for managing groups of nodes, improving performance by reducing the amount of
    work done during DOM manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also a `<script>` element. This `<script>` tag contains a function
    called `$RC` that is used to replace the shell with the actual content. The `$RC`
    function takes two arguments: the ID of the `<template>` element that contains
    the marker, and the ID of the `<div>` element that contains the fallback. The
    function then fills the marker with rendered UI after data is available, while
    removing the fallback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s pretty unfortunate that this function is minified, but let’s try to unminify
    it and understand what it does. If we do, this is what we observe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break this down further.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function takes two arguments: `reactMarkerId` and `siblingId`. Effectively,
    the marker is a hole where rendered components will go once they’re available,
    and the sibling is the Suspense fallback.'
  prefs: []
  type: TYPE_NORMAL
- en: The function then removes the sibling element (the fallback) from the DOM using
    the `removeChild` method on its parent node when data is available.
  prefs: []
  type: TYPE_NORMAL
- en: If the `reactMarker` element exists, the function runs. It sets the `reactMarker`
    variable to the previous sibling of the current `reactMarker` element. The function
    also initializes the variables `parentNode`, `nextSibling`, and `nestedLevel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `do...while` loop is used to traverse the DOM tree, starting with the `nextSibling`
    element. The loop continues as long as the `nextSibling` element exists. Inside
    the loop, the function checks whether the `nextSibling` element is a comment node
    (indicated by a `nodeType` value of `8`):'
  prefs: []
  type: TYPE_NORMAL
- en: If the `nextSibling` element is a comment node, the function inspects its data
    (i.e., the text content of the comment). It checks whether the data is equal to
    `"/$"`, which signifies the end of a nested structure. If the `nestedLevel` value
    is `0`, the loop breaks, indicating that the desired end of the structure has
    been reached. If the `nestedLevel` value is not `0`, it means that the current
    `"/$"` comment node is part of a nested structure, and the `nestedLevel` value
    is decremented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the comment node data is not equal to `"/$"`, the function checks whether
    it is equal to `"$"`, `"$?"`, or `"$!"`. These values indicate the beginning of
    a new nested structure. If any of these values are encountered, the `nestedLevel`
    value is incremented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During each iteration of the loop, the `nextSibling` element (that is, the Suspense
    boundary) is removed from the DOM using the `removeChild` method on its parent
    node. The loop continues with the next sibling element in the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: Once the loop has completed, the function moves all child elements of the sibling
    element to the location immediately before the `nextSibling` element in the DOM
    tree using the `insertBefore` method. This process effectively restructures the
    DOM around the `reactMarker` element and replaces a Suspense fallback with the
    component it wraps.
  prefs: []
  type: TYPE_NORMAL
- en: The function then sets the data of the `reactMarker` element to `"$"`, which
    is likely used to mark the component for future processing or reference. If a
    `reactRetry` property exists on the `reactMarker` element and it is a function,
    the function invokes this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If some of this was difficult to follow, don’t worry about it. We can summarize
    all of this here: essentially, this function waits for data-dependent React components
    to be ready, and when they are, swaps out Suspense fallbacks for the server rendered
    components. It uses comment nodes with specific data values to determine the structure
    of the components, and manipulates the DOM accordingly. Since this is inlined
    in our HTML from the server, we can stream data like this using `renderToPipeableStream`
    and have the browser render the UI as it becomes available without even including
    React in the browser bundle or hydrating.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `renderToPipeableStream` gives us quite a bit more control and power compared
    to `renderToString` when server rendering.
  prefs: []
  type: TYPE_NORMAL
- en: renderToReadableStream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous API we covered, `renderToPipeableStream`, makes use of Node.js
    streams under the hood. However, browsers also have support for streams and browser
    streams slightly differ from Node.js streams. Node.js streams are primarily designed
    to operate in a server-side environment, where they deal with file I/O, network
    I/O, or any kind of end-to-end streaming. They follow a custom API defined by
    the Node.js environment and have been a core part of Node.js for a long time.
    Node.js streams have distinct classes for readable, writable, duplex, and transform
    streams, and utilize events like `data`, `end`, and `error` to manage stream flow
    and handle data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browser streams are designed to operate in a client-side environment within
    web browsers. They often deal with streaming data from network requests, media
    streaming, or other data-processing tasks in the browser. Browser streams follow
    the Streams standard defined by the WHATWG (Web Hypertext Application Technology
    Working Group), aiming to standardize APIs across the web. Unlike Node.js streams,
    browser streams use methods like `read()`, `write()`, and `pipeThrough()` to control
    the flow of data and then process that streamed data. They provide a more standardized
    and promise-based API. Here is an example of a readable stream in a browser environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While both Node.js streams and browser streams serve the purpose of handling
    streaming data, they operate in different environments with slightly different
    APIs and standards. Node.js streams are event driven and are well suited for server-side
    operations, whereas browser streams are promise based, aligning with modern web
    standards, and are tailored for client-side operations.
  prefs: []
  type: TYPE_NORMAL
- en: To support both environments, React has `renderToPipeableStream` for Node.js
    streams, and `renderToReadableStream` for browser streams. The `renderToReadableStream`
    API is similar to `renderToPipeableStream`, but it returns a readable stream for
    the browser instead of a Node.js-native stream.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use What
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`renderToString` isn’t ideal because it is synchronous. This is quite problematic
    for a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Network I/O is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any data fetching we do depends on retrieving data from somewhere: a database,
    a web service, the filesystem, etc. These operations are often asynchronous: meaning
    that they start and end at discrete points in time, not at the same time. Because
    `renderToString` is synchronous, it cannot wait for asynchronous requests to complete
    and *must* send a string instantly to the browser. This means that the server
    cannot complete things, the client gets a shell before any data has loaded, and
    the client ideally picks up where the server left off after hydration. This presents
    performance problems by way of network waterfalls.'
  prefs: []
  type: TYPE_NORMAL
- en: Servers serve multiple clients.
  prefs: []
  type: TYPE_NORMAL
- en: If your server that calls `renderToString` is busy rendering to a string and
    30 clients have sent new requests to it, those new clients will have to wait for
    it to finish its current work. Because `renderToString` is synchronous, it blocks
    until it’s done. In the one-to-many relationship between servers and clients,
    blocking means your clients wait longer than they should.
  prefs: []
  type: TYPE_NORMAL
- en: Newer alternatives like `renderToPipeableStream` and `renderToReadableStream`
    are asynchronous stream-based approaches that solve for both of these problems,
    with `renderToReadableStream` being browser native and `renderToPipeableStream`
    being server native. Thus, if the question is “what’s the best API to use on the
    server?” the answer is clearly either `renderToPipeableStream` or `renderToReadableStream`,
    depending on the environment.
  prefs: []
  type: TYPE_NORMAL
- en: That said, while `renderTo*Stream` appears to be a superior set of APIs, there
    is currently no “full user story” around these APIs at the time of writing. Many
    third-party libraries that are currently around will not work with them, especially
    considering data fetching or CSS libraries. This is because they conceptually
    need a “full run” on the server, then need to create data, and then rerender the
    application with that data to actually stream from the server. They don’t support
    scenarios where an app hasn’t finished rendering on the server yet, but needs
    to start partially hydrating in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a React problem: there are no APIs in React 18 (the latest release
    at the time of writing) that would allow for support of any kind of streaming
    or partial rehydration of third-party data. The React team has recently added
    a bunch of new APIs to `react-dom`, like `prefetchDNS`, `preconnect`, `preload`,
    etc., to address that, but those will only ship with React 19\. Even with these
    APIs, there are still a few important APIs missing to make `renderToPipeableStream`
    a viable option.'
  prefs: []
  type: TYPE_NORMAL
- en: The only really viable option to use `renderToPipeableStream` right now would
    be to prefetch all required data (or in the case of a CSS library, render the
    full application with `renderToString` to “prerecord” all classes that need rendering)
    before calling `renderToPipeableStream` in the first place—which would pretty
    much eliminate most of its benefits over `renderToString`, essentially making
    it a synchronous API again.
  prefs: []
  type: TYPE_NORMAL
- en: All things considered, these are complex topics that require a good amount of
    forethought, careful planning, and further consideration around which APIs to
    use that equally depend on your current projects and use cases. Thus, the answer
    is once again “it depends,” or “just use a framework” and defer the decision to
    the broader community.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Roll Your Own
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a custom server rendering implementation for a React application can
    be a challenging and time-consuming task. While React does provide some APIs for
    server rendering, building a custom solution from scratch can lead to various
    issues and inefficiencies. In this section, we’ll explore the reasons why it’s
    better to rely on established frameworks like Next.js and Remix, rather than building
    your own server rendering solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling edge cases and complexities
  prefs: []
  type: TYPE_NORMAL
- en: React applications can become quite complex, and implementing server rendering
    requires addressing various edge cases and complexities. These can include handling
    asynchronous data fetching, code splitting, and managing various React lifecycle
    events. By using a framework like Next.js or Remix, you can avoid the need to
    handle these complexities yourself, as these frameworks have built-in solutions
    for many common edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: One such edge case is security. As the server processes numerous client requests,
    it’s crucial to ensure that sensitive data from one client doesn’t inadvertently
    leak to another. This is where frameworks like Next.js, Remix, and Gatsby can
    provide invaluable assistance in handling these concerns. Imagine a scenario where
    client A accesses the server, and their data is cached by the server. If the server
    accidentally serves this cached data to client B, sensitive information could
    be exposed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the given code, `cachedUserData` is intended to cache the user data, but
    it’s shared across all requests regardless of the `userId`. Every time a request
    is made to `/user/:userId`, the server checks `cachedUserData` to see if there’s
    cached data. If there is, it returns the cached data regardless of whether the
    `userId` matches the `userId` of the cached data. If there isn’t, it fetches the
    data, caches it, and returns it. This means that if two requests are made in sequence
    to `/user/1` and `/user/2`, the second request would receive the data of the first
    user, which is a significant security issue.
  prefs: []
  type: TYPE_NORMAL
- en: A more secure caching strategy would be to cache the data in a way that’s associated
    with the `userId` so that each user has their own cache. One way to do this would
    be to use an object to hold the cached data, with the `userId` as the key.
  prefs: []
  type: TYPE_NORMAL
- en: If we roll our own, the risk of human error is ever present. If we lean on frameworks
    built by large communities, this risk is mitigated. These frameworks are designed
    with security in mind and ensure that sensitive data is handled properly. They
    prevent potential data leakage scenarios by using secure and isolated data-fetching
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimizations
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks come with numerous performance optimizations out of the box. These
    optimizations can include automatic code splitting, server rendering, and caching.
    Building a custom server rendering solution might not include these optimizations
    by default, and implementing them can be a challenging and time-consuming task.
  prefs: []
  type: TYPE_NORMAL
- en: One such optimization Next.js makes, for example, is route-based code splitting
    for the pages router that was the default for Next.js 13 and earlier. Each page
    in this case is automatically code split into its own bundle, which is then loaded
    only when the page is requested. This can significantly improve performance by
    reducing the initial bundle size and improving the TTFB.
  prefs: []
  type: TYPE_NORMAL
- en: Developer experience and productivity
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom server rendering implementation can be a complex and time-consuming
    endeavor. By using a framework like Next.js or Remix, developers can focus on
    building features and functionality for their application instead of worrying
    about the underlying server rendering infrastructure. This can lead to increased
    productivity and a better overall developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and conventions
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a framework like Next.js or Remix can help enforce best practices and
    conventions in your project. These frameworks have been designed with best practices
    in mind, and by following their conventions, you can ensure that your application
    is built on a solid foundation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Considering the benefits and optimizations provided by established frameworks
    like Next.js and Remix, it becomes evident that building a custom server rendering
    solution for a React application is not an ideal approach. By leveraging these
    frameworks, you can save development time, ensure that best practices are followed,
    and benefit from the ongoing improvements and support provided by their respective
    communities.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, server-side rendering and hydration are powerful techniques that
    can significantly improve the performance, user experience, and SEO of web applications.
    React provides a rich set of APIs for server rendering, such as `renderToString`
    and `renderToPipeableStream`, each with its own strengths and trade-offs. By understanding
    these APIs and selecting the right one based on factors such as application size,
    server environment, and developer experience, you can optimize your React application
    for both server- and client-side performance.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen throughout this chapter, `renderToString` is a simple and straightforward
    API for server rendering that is suitable for smaller applications. However, it
    may not be the most efficient option for larger applications due to its synchronous
    nature and potential to block the event loop. On the other hand, `renderToPipeableStream`
    is a more advanced and flexible API that allows for better control over the rendering
    process and improved integration with other Node.js streams, making it a more
    suitable choice for larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve gained a solid understanding of server-side rendering and hydration
    in React, it’s time to test your knowledge with some review questions. If you
    can confidently answer these, it’s a good sign that you’ve got a solid understanding
    of mechanism in React and can comfortably move forward. If you cannot, we’d suggest
    reading through things a little more, although this will not hurt your experience
    as you continue through the book.
  prefs: []
  type: TYPE_NORMAL
- en: What is the main advantage of using server-side rendering in a React application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does hydration work in React, and why is it important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is resumability? How does it claim to be superior to hydration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the key benefits and weaknesses of client-only rendering?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the key differences between the `renderToReadableStream` and `renderToPipeableStream`
    APIs in React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Up Next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you’ve mastered server-side rendering and hydration, you’re ready to explore
    even more advanced topics in React development. In the next chapter, we’ll dive
    into concurrent React. As web applications become more complex, handling asynchronous
    actions becomes increasingly important for creating smooth user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: By learning how to leverage concurrent React, you’ll be able to create highly
    performant, scalable, and user-friendly applications that can handle complex data
    interactions with ease. So, stay tuned and get ready to level up your React skills
    as we continue our journey into the world of concurrent React!
  prefs: []
  type: TYPE_NORMAL
