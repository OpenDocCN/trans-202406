<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 1. Combining Commands"><div class="chapter" id="ch_combining_commands">
<h1><span class="label">Chapter 1. </span>Combining Commands</h1>


<p><a data-type="indexterm" data-primary="combining commands with pipes" data-seealso="commands; pipes" id="idm46586656933088"/>
When you work in Windows, macOS, and most other operating systems, you
probably spend your time running applications like web browsers, word
processors, spreadsheets, and games. A typical application is packed
with features: everything that the designers thought their users would
need. So, most applications are self-sufficient. They don’t rely on
other apps. You might copy and paste between applications from time to
time, but for the most part, they’re separate.</p>

<p>The Linux command line is different. Instead of big applications with
tons of features, Linux supplies thousands of small commands with very
few features. The command <code>cat</code><a data-type="indexterm" data-primary="cat command" id="idm46586656931296"/>, for example, prints files on the
screen and that’s about it. <code>ls</code> lists the files in a directory, <code>mv</code><a data-type="indexterm" data-primary="mv command" id="idm46586656929792"/>
renames files, and so on. Each command has a simple, fairly
well-defined purpose.</p>

<p>What if you need to do something more complicated? Don’t worry. Linux
makes it easy to <em>combine commands</em> so their individual features work
together to accomplish your goal. This way of working yields a very
different mindset about computing. Instead of asking “Which app should
I launch?” to achieve some result, the question becomes “Which
commands should I combine?”</p>

<p>In this chapter, you’ll learn how to arrange and run commands in
different combinations to do what you need. To keep things simple,
I’ll introduce just six Linux commands and their most basic uses so
you can focus on the more complex and interesting part—combining
them—without a huge learning curve. It’s a bit like learning to
cook with six ingredients, or learning carpentry with just a hammer
and a saw. (I’ll add more commands to your Linux toolbox in
<a data-type="xref" href="ch05.xhtml#ch_toolbox">Chapter 5</a>.)</p>

<p>You’ll combine commands using <em>pipes<a data-type="indexterm" data-primary="pipes" id="idm46586656835584"/></em>, a Linux feature that connects
the output of one command to the input of another. As I introduce
each command (<code>wc</code>, <code>head</code>, <code>cut</code>, <code>grep</code>, <code>sort</code>, and <code>uniq</code>), I’ll
immediately demonstrate its use with pipes. Some 
<span class="keep-together">examples</span> will be
practical for daily Linux use, while others are just toy examples to
demonstrate an important feature.</p>






<section data-type="sect1" data-pdf-bookmark="Input, Output, and Pipes"><div class="sect1" id="idm46586656831184">
<h1>Input, Output, and Pipes</h1>

<p>Most Linux commands read input from the keyboard, write output to the
screen, or both. Linux has fancy names for this reading and writing:</p>
<dl>
<dt>stdin<a data-type="indexterm" data-primary="stdin" id="idm46586656828592"/><a data-type="indexterm" data-primary="standard input" data-see="stdin" id="idm46586656827856"/> (pronounced “standard input” or “standard in”)</dt>
<dd>
<p>The stream of input that Linux reads from your keyboard. When you type
any command at a prompt, you’re supplying data on stdin.</p>
</dd>
<dt>stdout<a data-type="indexterm" data-primary="stdout" id="idm46586656825440"/><a data-type="indexterm" data-primary="standard output" data-see="stdout" id="idm46586656824704"/> (pronounced “standard output” or “standard out”)</dt>
<dd>
<p>The stream of output that Linux writes to your display. When you run the
<code>ls</code> command to print filenames, the results appear on stdout.</p>
</dd>
</dl>

<p>Now comes the cool part. You can connect the stdout of one command to
the stdin of another, so the first command feeds the second. Let’s
begin with the familiar <code>ls -l</code> command to list a large directory,
such as <em>/bin</em>, in long format:<a data-type="indexterm" data-primary="ls command" data-secondary="long listing (-l option)" id="idm46586656820656"/></p>

<pre data-type="programlisting">$ <strong>ls -l /bin</strong>
total 12104
-rwxr-xr-x 1 root root 1113504 Jun  6  2019 bash
-rwxr-xr-x 1 root root  170456 Sep 21  2019 bsd-csh
-rwxr-xr-x 1 root root   34888 Jul  4  2019 bunzip2
-rwxr-xr-x 1 root root 2062296 Sep 18  2020 busybox
-rwxr-xr-x 1 root root   34888 Jul  4  2019 bzcat
⋮
-rwxr-xr-x 1 root root    5047 Apr 27  2017 znew</pre>

<p>This directory contains far more files than your display has lines, so
the output quickly scrolls off-screen. It’s a shame that <code>ls</code> can’t
print the information one screenful at a time, pausing until you press
a key to continue. But wait: another Linux command has that
feature. The <code>less</code><a data-type="indexterm" data-primary="less command" id="idm46586656817360"/> command displays a file one screenful at a time:<a data-type="indexterm" data-primary="viewing files" data-secondary="one screenful at a time" id="idm46586656816528"/></p>

<pre data-type="programlisting">$ <strong>less myfile</strong>                        <em>View the file; press q to quit</em></pre>

<p>You can connect these two commands because <code>ls</code> writes to stdout and
<code>less</code> can read from stdin. Use a pipe to send the output of <code>ls</code> to
the input of <code>less</code>:<a data-type="indexterm" data-primary="stdin" data-secondary="pipes" id="idm46586656986336"/><a data-type="indexterm" data-primary="stdout" data-secondary="pipes" id="idm46586656985328"/><a data-type="indexterm" data-primary="pipes" data-secondary="stdin" id="idm46586656984384"/><a data-type="indexterm" data-primary="pipes" data-secondary="stdout" id="idm46586656983440"/><a data-type="indexterm" data-primary="less command" data-secondary="keystrokes" id="idm46586656982496"/></p>

<pre data-type="programlisting">$ <strong>ls -l /bin | less</strong></pre>

<p>This combined command displays the directory’s contents one screenful
at a time. The vertical bar
(<code>|</code>)<a data-type="indexterm" data-primary="| (vertical bar)" data-secondary="pipe symbol" data-seealso="pipes" id="idm46586656979408"/><a data-type="indexterm" data-primary="vertical bar (|)" data-secondary="pipe symbol" data-seealso="pipes" id="idm46586656978128"/>
between the commands is the Linux
pipe symbol.<sup><a data-type="noteref" id="idm46586656976720-marker" href="ch01.xhtml#idm46586656976720">1</a></sup> It connects the
first command’s stdout to the next command’s stdin. Any command line
containing pipes is called a <em>pipeline</em><a data-type="indexterm" data-primary="pipes" data-secondary="pipelines" id="idm46586656975072"/>.</p>

<p>Commands generally are not aware that they’re part of a pipeline.<a data-type="indexterm" data-primary="pipes" data-secondary="transparency" id="idm46586656973456"/> <code>ls</code>
believes it’s writing to the display, when in fact its output has been
redirected to <code>less</code>. And <code>less</code> believes it’s reading from the keyboard
when it’s actually reading the output of <code>ls</code>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46586656970464">
<h5>What’s a Command?</h5>
<p>The word <em>command</em> has<a data-type="indexterm" data-primary="command" data-secondary="definition" id="idm46586656968416"/><a data-type="indexterm" data-primary="command" data-secondary="meanings of word" id="idm46586656967408"/> three different meanings in Linux, shown in
<a data-type="xref" href="#fig_commands">Figure 1-1</a>:</p>
<dl>
<dt>A program<a data-type="indexterm" data-primary="program" id="idm46586656964576"/></dt>
<dd>
<p>An executable program named<a data-type="indexterm" data-primary="command" data-secondary="program as" id="idm46586656962912"/> and executed by a single word, such as
<code>ls</code>, or a similar feature built into the shell, such as <code>cd</code> (called
a <em>shell builtin</em>)<a data-type="indexterm" data-primary="shell" data-secondary="builtin" data-seealso="builtins" id="idm46586652537520"/><a data-type="indexterm" data-primary="builtins" id="idm46586652536240"/><sup><a data-type="noteref" id="idm46586652535568-marker" href="ch01.xhtml#idm46586652535568">2</a></sup></p>
</dd>
<dt>A simple command</dt>
<dd>
<p>A program name<a data-type="indexterm" data-primary="simple commands" id="idm46586652531760"/> (or shell builtin) <a data-type="indexterm" data-primary="command" data-secondary="simple commands" id="idm46586652530896"/>optionally followed by arguments,
such as 
<span class="keep-together"><code>ls -l /bin</code></span></p>
</dd>
<dt>A combined command<a data-type="indexterm" data-primary="combined command" id="idm46586652528528"/></dt>
<dd>
<p>Several simple commands<a data-type="indexterm" data-primary="command" data-secondary="combined command" id="idm46586652527088"/> treated as a unit, such as the
pipeline <code>ls -l /bin | less</code></p>
</dd>
</dl>

<figure><div id="fig_commands" class="figure">
<img src="Images/elcl_0101.png" alt="Different meanings of the word 'command'" width="564" height="367"/>
<h6><span class="label">Figure 1-1. </span>Programs, simple commands, and combined commands are all referred to as “commands”</h6>
</div></figure>

<p>In this book, I’ll use the word <em>command</em> in all these ways.  Usually
the surrounding context will make clear which one I mean, but if not,
I’ll use one of the more specific terms.</p>
</div></aside>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Six Commands to Get You Started"><div class="sect1" id="idm46586652522192">
<h1>Six Commands to Get You Started</h1>

<p>Pipes are an essential part of Linux expertise. Let’s dive into
building your piping skills with a small set of Linux commands so no matter
which ones you encounter later, you’re ready to combine them.</p>

<p>The six commands—<code>wc</code>, <code>head</code>, <code>cut</code>, <code>grep</code>, <code>sort</code>, and <code>uniq</code>—have
numerous options and modes of operation that I’ll largely skip
for now to focus on pipes. To learn more about any command,
run the <code>man</code> command to display full documentation. For 
<span class="keep-together">example:</span></p>

<pre data-type="programlisting">$ <strong>man wc</strong></pre>

<p>To demonstrate our six commands in action, I’ll use a file named
<em>animals.txt</em> that lists some O’Reilly book information, shown in
<a data-type="xref" href="#example_animals.txt">Example 1-1</a>.<a data-type="indexterm" data-primary="animals.txt file (running example)" id="idm46586653991008"/></p>
<div id="example_animals.txt" data-type="example">
<h5><span class="label">Example 1-1. </span>Inside the file <em>animals.txt</em></h5>

<pre data-type="programlisting">python	Programming Python	2010	Lutz, Mark
snail	SSH, The Secure Shell	2005	Barrett, Daniel
alpaca	Intermediate Perl	2012	Schwartz, Randal
robin	MySQL High Availability	2014	Bell, Charles
horse	Linux in a Nutshell	2009	Siever, Ellen
donkey	Cisco IOS in a Nutshell	2005	Boney, James
oryx	Writing Word Macros	1999	Roman, Steven</pre></div>

<p>Each line contains four facts about an O’Reilly book, separated by a
single tab character: the animal on the front cover, the book title,
the year of publication, and the name of the first author.</p>








<section data-type="sect2" data-pdf-bookmark="Command #1: wc"><div class="sect2" id="idm46586653987568">
<h2>Command #1: wc</h2>

<p><a data-type="indexterm" data-primary="wc command" id="wc"/><a data-type="indexterm" data-primary="counting characters, words, and lines" id="idm46586653984720"/>
The <code>wc</code> command prints the number of lines, words, and characters in
a file:</p>

<pre data-type="programlisting">$ <strong>wc animals.txt</strong>
  7  51 325 animals.txt</pre>

<p><code>wc</code> reports that the file <em>animals.txt</em> has 7 lines, 51 words, and
325 characters.  If you count the characters by eye, including spaces
and tabs, you’ll find only 318 characters, but <code>wc</code> also includes
the invisible newline character that ends each line.</p>

<p>The options <code>-l</code>,<a data-type="indexterm" data-primary="wc command" data-secondary="line counting (-l option)" id="idm46586653979376"/> <code>-w</code>,<a data-type="indexterm" data-primary="wc command" data-secondary="word counting (-w option)" id="idm46586653977808"/> and <code>-c</code><a data-type="indexterm" data-primary="wc command" data-secondary="character counting (-c option)" id="idm46586653976368"/> instruct <code>wc</code> to print only the
number of lines, words, and characters, respectively:</p>

<pre data-type="programlisting">$ <strong>wc -l animals.txt</strong>
7 animals.txt
$ <strong>wc -w animals.txt</strong>
51 animals.txt
$ <strong>wc -c animals.txt</strong>
325 animals.txt</pre>

<p>Counting is such a useful, general-purpose task that the authors of
<code>wc</code> designed the command to work with pipes. It reads from stdin<a data-type="indexterm" data-primary="wc command" data-secondary="reading from stdin" id="idm46586653971984"/> if
you omit the filename, and it writes to stdout. Let’s use <code>ls</code> to
list the contents of the current directory and pipe them to <code>wc</code> to
count lines. This pipeline answers the question, “How many files are
visible in my current directory?”</p>

<pre data-type="programlisting">$ <strong>ls -1</strong>
animals.txt
myfile
myfile2
test.py
$ <strong>ls -1 | wc -l</strong>
4</pre>

<p>The option <code>-1</code>,<a data-type="indexterm" data-primary="ls command" data-secondary="single column output (-1 option)" id="idm46586653967264"/> which tells <code>ls</code> to print its results in a single
column, is not strictly necessary here. To learn why I used it, see
the sidebar <a data-type="xref" href="#ls_behavior">“ls Changes Its Behavior When Redirected”</a>.</p>

<p><code>wc</code> is the first command you’ve seen in this chapter, so you’re a bit
limited in what you can do with pipes. Just for fun, pipe the output
of <code>wc</code> to itself, demonstrating that the same command can appear more
than once in a pipeline. This combined command reports that the number
of words in the output of <code>wc</code> is four: three integers and a 
<span class="keep-together">filename:</span></p>

<pre data-type="programlisting">$ <strong>wc animals.txt</strong>
  7  51 325 animals.txt
$ <strong>wc animals.txt | wc -w</strong>
4</pre>

<p>Why stop there? Add a third <code>wc</code> to the pipeline and count lines,
words, and characters in the output “4”:</p>

<pre data-type="programlisting">$ <strong>wc animals.txt | wc -w | wc</strong>
      1       1       2</pre>

<p>The output indicates one line (containing the number 4), one word (the
number 4 itself), and two characters. Why two? Because the line “4”
ends with an invisible newline character.<a data-type="indexterm" data-primary="newline character" data-secondary="counting with wc" id="idm46586655514896"/></p>

<p>That’s enough silly pipelines with <code>wc</code>. As you gain more commands,
the pipelines will become more practical.</p>
<aside data-type="sidebar" epub:type="sidebar" class="nobreakinside"><div class="sidebar" id="ls_behavior">
<h5>ls Changes Its Behavior When Redirected</h5>
<p>Unlike <a data-type="indexterm" data-primary="ls command" data-secondary="redirection behavior" id="idm46586655510544"/><a data-type="indexterm" data-primary="ls command" data-secondary="column control" id="idm46586655509536"/>virtually every other Linux command, <code>ls</code> is aware of whether
stdout is the screen or whether it’s been redirected (to a pipe or
otherwise). The reason is user-friendliness. When stdout is the
screen, <code>ls</code> arranges its output in multiple columns for convenient
reading:</p>

<pre data-type="programlisting">$ <strong>ls /bin</strong>
bash        dir         kmod      networkctl       red     tar
bsd-csh     dmesg       less      nisdomainname    rm      tempfile
⋮</pre>

<p>When stdout is redirected, however, <code>ls</code> produces a single
column. I’ll demonstrate this by piping the output of <code>ls</code> to a
command that simply reproduces its input, such as <code>cat</code>:<sup><a data-type="noteref" id="idm46586655504608-marker" href="ch01.xhtml#idm46586655504608">3</a></sup></p>

<pre data-type="programlisting">$ <strong>ls /bin | cat</strong>
bash
bsd-csh
bunzip2
busybox
⋮</pre>

<p>This behavior can lead to strange-looking results, as in the following
example:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
animals.txt   myfile   myfile2    test.py
$ <strong>ls | wc -l</strong>
4</pre>

<p>The first <code>ls</code> command prints all filenames on one line, but the second
command reports that <code>ls</code> produced four lines. If you aren’t aware of
the quirky behavior of <code>ls</code>, you might find this discrepancy
confusing.</p>

<p><code>ls</code> has options to override its default behavior. Force <code>ls</code>
to print a single column with the <code>-1</code> option,<a data-type="indexterm" data-primary="ls command" data-secondary="single column output (-1 option)" id="idm46586655496336"/> or force
multiple columns with the <code>-C</code> option.<a data-type="indexterm" data-primary="ls command" data-secondary="multicolumn output (-C option)" id="idm46586655494752"/></p>
</div></aside>
</div></section>













<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Command #2: head"><div class="sect2" id="idm46586653987072">
<h2>Command #2: head</h2>

<p><a data-type="indexterm" data-primary="head command" data-seealso="tail command" id="head"/><a data-type="indexterm" data-primary="first lines of a file" id="idm46586655490896"/><a data-type="indexterm" data-primary="file" data-secondary="first lines of a file" id="idm46586655490224"/>
The <code>head</code> command prints the first lines of a file.
Print the first three lines of 
<span class="keep-together"><em>animals.txt</em></span> with <code>head</code>
using the option <code>-n</code>:<a data-type="indexterm" data-primary="head command" data-secondary="number of lines (-n option)" id="idm46586654320272"/></p>

<pre data-type="programlisting">$ <strong>head -n3 animals.txt</strong>
python	Programming Python	2010	Lutz, Mark
snail	SSH, The Secure Shell	2005	Barrett, Daniel
alpaca	Intermediate Perl	2012	Schwartz, Randal</pre>

<p>If you request more lines than the file contains, <code>head</code> prints the
whole file (like <code>cat</code> does). If you omit the <code>-n</code> option, <code>head</code> defaults
to 10 lines (<code>-n10</code>).</p>

<p>By itself, <code>head</code> is handy for peeking at the top of a file when you
don’t care about the rest of the contents. It’s a speedy and
efficient command, even for very large files, because it needn’t read
the whole file. In addition, <code>head</code> writes
to stdout, making it useful in pipelines. Count the number of words in
the first three lines of <em>animals.txt</em>:</p>

<pre data-type="programlisting">$ <strong>head -n3 animals.txt | wc -w</strong>
20</pre>

<p><code>head</code> can also read from stdin<a data-type="indexterm" data-primary="head command" data-secondary="reading from stdin" id="idm46586654311712"/> for more pipeline fun. A common use is
to reduce the output from another command when you don’t care to see
all of it, like a long directory listing. For example, list the first five
filenames in the <em>/bin</em> directory:<a data-type="indexterm" data-startref="head" id="idm46586654310224"/></p>

<pre data-type="programlisting">$ <strong>ls /bin | head -n5</strong>
bash
bsd-csh
bunzip2
busybox
bzcat</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Command #3: cut"><div class="sect2" id="idm46586654308256">
<h2>Command #3: cut</h2>

<p><a data-type="indexterm" data-primary="cut command" data-seealso="paste command" id="cut"/><a data-type="indexterm" data-primary="columns from a file" id="idm46586654305408"/><a data-type="indexterm" data-primary="extract columns from a file" id="idm46586654304736"/>
The <code>cut</code> command prints one or more columns from a file. For example,
print all book titles from <em>animals.txt</em>, which appear in the second
column:</p>

<pre data-type="programlisting">$ <strong>cut -f2 animals.txt</strong>
Programming Python
SSH, The Secure Shell
Intermediate Perl
MySQL High Availability
Linux in a Nutshell
Cisco IOS in a Nutshell
Writing Word Macros</pre>

<p class="pagebreak-after"><code>cut</code> provides two ways to define what a “column” is.<a data-type="indexterm" data-primary="cut command" data-secondary="column, definition of" id="idm46586654300512"/> The first is
to cut by field (<code>-f</code>),<a data-type="indexterm" data-primary="cut command" data-secondary="field-based columns (-f option)" id="idm46586654298976"/> when the input consists of strings
(fields) each separated by a single tab character. Conveniently,
that is exactly the format of the file <em>animals.txt</em>. The preceding
<code>cut</code> command prints the second field of each line, thanks to the
option <code>-f2</code>.</p>

<p>To shorten the output, pipe it to <code>head</code> to print only the first three
lines:</p>

<pre data-type="programlisting">$ <strong>cut -f2 animals.txt | head -n3</strong>
Programming Python
SSH, The Secure Shell
Intermediate Perl</pre>

<p>You can also cut multiple fields, either by separating their field
numbers with 
<span class="keep-together">commas:</span></p>

<pre data-type="programlisting">$ <strong>cut -f1,3 animals.txt | head -n3</strong>
python	2010
snail	2005
alpaca	2012</pre>

<p>or by numeric range:</p>

<pre data-type="programlisting">$ <strong>cut -f2-4 animals.txt | head -n3</strong>
Programming Python	2010	Lutz, Mark
SSH, The Secure Shell	2005	Barrett, Daniel
Intermediate Perl	2012	Schwartz, Randal</pre>

<p>The second way to define a “column” for <code>cut</code> is by character
position, using the <code>-c</code> option.<a data-type="indexterm" data-primary="cut command" data-secondary="character-based columns (-c option)" id="idm46586655487056"/> Print the first three characters from
each line of the file, which you can specify either with commas (<code>1,2,3</code>) or
as a range (<code>1-3</code>):<a data-type="indexterm" data-primary="- (dash)" data-secondary="cut command" id="idm46586655484896"/><a data-type="indexterm" data-primary="dash (-)" data-secondary="cut command" id="idm46586655483888"/></p>

<pre data-type="programlisting">$ <strong>cut -c1-3 animals.txt</strong>
pyt
sna
alp
rob
hor
don
ory</pre>

<p>Now that you’ve seen the basic functionality, try something more
practical with <code>cut</code> and pipes. Imagine that the <em>animals.txt</em> file is
thousands of lines long, and you need to extract just the authors’
last names. First, isolate the fourth field, author name:</p>

<pre data-type="programlisting">$ <strong>cut -f4 animals.txt</strong>
Lutz, Mark
Barrett, Daniel
Schwartz, Randal
⋮</pre>

<p>Then pipe the results to <code>cut</code> again, using the option <code>-d</code><a data-type="indexterm" data-primary="cut command" data-secondary="separator (-d option)" id="idm46586655477952"/> (meaning
“delimiter”)<a data-type="indexterm" data-primary="delimiter" data-seealso="separator" id="idm46586655476800"/> to change the separator character<a data-type="indexterm" data-primary="separator" data-secondary="cut command" id="idm46586655475680"/> to a
comma instead of a tab, to isolate the authors’ last names:<a data-type="indexterm" data-startref="cut" id="idm46586655474608"/></p>

<pre data-type="programlisting">$ <strong>cut -f4 animals.txt | cut -d, -f1</strong>
Lutz
Barrett
Schwartz
⋮</pre>
<div data-type="tip"><h1>Save Time with Command History and Editing</h1>
<p>Are you retyping a lot of commands? Press the up arrow key instead, repeatedly,
to scroll through commands you’ve run before. (This shell feature is
called <em>command history<a data-type="indexterm" data-primary="command history" id="idm46586655471152"/></em>.) When you reach the desired command, press
Enter to run it immediately, or edit it first using the left and right
arrow keys to position the cursor and the Backspace key to delete.
(This feature is <em>command-line editing</em>.)<a data-type="indexterm" data-primary="command-line editing" id="idm46586655469904"/></p>

<p>I’ll discuss much more powerful features for command history and
editing in <a data-type="xref" href="ch03.xhtml#ch_history">Chapter 3</a>.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Command #4: grep"><div class="sect2" id="idm46586654307632">
<h2>Command #4: grep</h2>

<p><a data-type="indexterm" data-primary="grep command" id="grep"/><a data-type="indexterm" data-primary="lines that match a string" id="idm46586655464960"/><a data-type="indexterm" data-primary="strings" data-secondary="lines that match" id="idm46586655464272"/>
<code>grep</code> is an extremely powerful command, but for now I’ll hide most
of its capabilities and say it prints lines that match a given
string. (More detail will come in <a data-type="xref" href="ch05.xhtml#ch_toolbox">Chapter 5</a>.) For example, the
following command displays lines from <em>animals.txt</em> that
contain the string <code>Nutshell</code>:</p>

<pre data-type="programlisting">$ <strong>grep Nutshell animals.txt</strong>
horse	Linux in a <strong>Nutshell</strong>	2009	Siever, Ellen
donkey	Cisco IOS in a <strong>Nutshell</strong>	2005	Boney, James</pre>

<p>You can also print lines that <em>don’t</em> match a given string, with the
<code>-v</code><a data-type="indexterm" data-primary="grep command" data-secondary="inverting the match (-v option)" id="idm46586655457776"/> option. Notice the lines containing “Nutshell” are absent:</p>

<pre data-type="programlisting">$ <strong>grep -v Nutshell animals.txt</strong>
python	Programming Python	2010	Lutz, Mark
snail	SSH, The Secure Shell	2005	Barrett, Daniel
alpaca	Intermediate Perl	2012	Schwartz, Randal
robin	MySQL High Availability	2014	Bell, Charles
oryx	Writing Word Macros	1999	Roman, Steven</pre>

<p>In general, <code>grep</code> is useful for finding text in a
collection of files. The following command prints lines that contain the
string <code>Perl</code> in files with names ending in <em>.txt</em>:</p>
<pre data-type="programlisting">$ <strong>grep Perl *.txt</strong>
animals.txt:alpaca      Intermediate <strong>Perl</strong>       2012    Schwartz, Randal
essay.txt:really love the <strong>Perl</strong> programming language, which is
essay.txt:languages such as <strong>Perl</strong>, Python, PHP, and Ruby</pre>

<p>In this case, <code>grep</code> found three matching lines, one in <em>animals.txt</em>
and two in <em>essay.txt</em>.</p>

<p><code>grep</code> reads stdin and writes stdout, making it great for pipelines.
Suppose you want to know how many subdirectories are in the large
directory <em>/usr/lib</em>. There is no single Linux command to provide that
answer, so construct a pipeline. Begin with the <code>ls -l</code> command:</p>

<pre data-type="programlisting">$ <strong>ls -l /usr/lib</strong>
drwxrwxr-x  12 root root    4096 Mar  1  2020 4kstogram
drwxr-xr-x   3 root root    4096 Nov 30  2020 GraphicsMagick-1.4
drwxr-xr-x   4 root root    4096 Mar 19  2020 NetworkManager
-rw-r--r--   1 root root   35568 Dec  1  2017 attica_kde.so
-rwxr-xr-x   1 root root     684 May  5  2018 cnf-update-db
⋮</pre>

<p>Notice that <code>ls -l</code> marks directories with a <code>d</code> at the beginning of
the line.  Use <code>cut</code> to isolate the first column, which may or may not
be a <code>d</code>:</p>

<pre data-type="programlisting">$ <strong>ls -l /usr/lib | cut -c1</strong>
d
d
d
-
-
⋮</pre>

<p>Then use <code>grep</code> to keep only the lines containing <code>d</code>:</p>

<pre data-type="programlisting">$ <strong>ls -l /usr/lib | cut -c1 | grep d</strong>
d
d
d
⋮</pre>

<p>Finally, count lines with <code>wc</code>, and you have your answer, produced
by a four-command pipeline—<em>/usr/lib</em> contains 145 subdirectories:<a data-type="indexterm" data-startref="grep" id="idm46586655896976"/></p>

<pre data-type="programlisting">$ <strong>ls -l /usr/lib | cut -c1 | grep d | wc -l</strong>
145</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Command #5: sort"><div class="sect2" id="section_sort">
<h2>Command #5: sort</h2>

<p><a data-type="indexterm" data-primary="sort command" id="sort"/><a data-type="indexterm" data-primary="sorting lines of a file" id="idm46586655892096"/>
The <code>sort</code> command reorders the lines of a file into ascending order
(the default):</p>

<pre data-type="programlisting">$ <strong>sort animals.txt</strong>
alpaca	Intermediate Perl	2012	Schwartz, Randal
donkey	Cisco IOS in a Nutshell	2005	Boney, James
horse	Linux in a Nutshell	2009	Siever, Ellen
oryx	Writing Word Macros	1999	Roman, Steven
python	Programming Python	2010	Lutz, Mark
robin	MySQL High Availability	2014	Bell, Charles
snail	SSH, The Secure Shell	2005	Barrett, Daniel</pre>

<p>or descending order (with the <code>-r</code> option)<a data-type="indexterm" data-primary="sort command" data-secondary="reverse direction (-r option)" id="idm46586655888816"/>:</p>

<pre data-type="programlisting">$ <strong>sort -r animals.txt</strong>
snail	SSH, The Secure Shell	2005	Barrett, Daniel
robin	MySQL High Availability	2014	Bell, Charles
python	Programming Python	2010	Lutz, Mark
oryx	Writing Word Macros	1999	Roman, Steven
horse	Linux in a Nutshell	2009	Siever, Ellen
donkey	Cisco IOS in a Nutshell	2005	Boney, James
alpaca	Intermediate Perl	2012	Schwartz, Randal</pre>

<p><code>sort</code> can order the lines alphabetically (the default) or numerically
(with the <code>-n</code> option).<a data-type="indexterm" data-primary="sort command" data-secondary="numeric (-n option)" id="idm46586655885264"/> I’ll demonstrate this with pipelines that cut
the third field in <em>animals.txt</em>, the year of publication:</p>

<pre data-type="programlisting">$ <strong>cut -f3 animals.txt</strong>                         <em>Unsorted</em>
2010
2005
2012
2014
2009
2005
1999
$ <strong>cut -f3 animals.txt | sort -n</strong>               <em>Ascending</em>
1999
2005
2005
2009
2010
2012
2014
$ <strong>cut -f3 animals.txt | sort -nr</strong>              <em>Descending</em>
2014
2012
2010
2009
2005
2005
1999</pre>

<p>To learn the year of the most recent book in <em>animals.txt</em>, pipe the
output of <code>sort</code> to the input of <code>head</code> and print just the first line:</p>

<pre data-type="programlisting">$ <strong>cut -f3 animals.txt | sort -nr | head -n1</strong>
2014</pre>
<div data-type="tip"><h1>Maximum and Minimum Values</h1>
<p><code>sort</code> and <code>head</code> are powerful partners<a data-type="indexterm" data-primary="maximum value in a file" id="idm46586656811632"/><a data-type="indexterm" data-primary="minimum value in a file" id="idm46586656810896"/><a data-type="indexterm" data-primary="largest value in a file" id="idm46586656810224"/><a data-type="indexterm" data-primary="smallest value in a file" id="idm46586656809552"/> when working
with numeric data, one value per line. You can print the maximum
value by piping the data to:</p>

<pre data-type="programlisting">... | sort -nr | head -n1</pre>

<p>and print the minimum value with:</p>

<pre data-type="programlisting">... | sort -n | head -n1</pre>
</div>

<p>As another example, let’s play with the file <em>/etc/passwd</em>,<a data-type="indexterm" data-primary="/etc/passwd file" id="idm46586656805856"/><a data-type="indexterm" data-primary="/etc/passwd file" data-primary-sortas="etc password" id="idm46586656805120"/> which
lists the users that can run processes on the system.<sup><a data-type="noteref" id="idm46586656804048-marker" href="ch01.xhtml#idm46586656804048">4</a></sup> You’ll generate a
list of all users in alphabetical order. Peeking at the first five
lines, you see something like this:</p>

<pre data-type="programlisting">$ <strong>head -n5 /etc/passwd</strong>
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
smith:x:1000:1000:Aisha Smith,,,:/home/smith:/bin/bash
jones:x:1001:1001:Bilbo Jones,,,:/home/jones:/bin/bash</pre>

<p>Each line consists of strings separated by colons, and the first
string is the username, so you can isolate the usernames with the
<code>cut</code> command:</p>

<pre data-type="programlisting">$ <strong>head -n5 /etc/passwd | cut -d: -f1</strong>
root
daemon
bin
smith
jones</pre>

<p>and sort them:</p>

<pre data-type="programlisting">$ <strong>head -n5 /etc/passwd | cut -d: -f1 | sort</strong>
bin
daemon
jones
root
smith</pre>

<p>To produce the sorted list of all usernames, not just the first five,
replace <code>head</code> with <code>cat</code>:</p>

<pre data-type="programlisting">$ <strong>cat /etc/passwd | cut -d: -f1 | sort</strong></pre>

<p>To detect if a given user has an account on your system, match their
username with <code>grep</code>. Empty output means no account:</p>

<pre data-type="programlisting">$ <strong>cut -d: -f1 /etc/passwd | grep -w jones</strong>
jones
$ <strong>cut -d: -f1 /etc/passwd | grep -w rutabaga</strong>         <em>(produces no output)</em></pre>

<p>The <code>-w</code> option<a data-type="indexterm" data-primary="grep command" data-secondary="full word matching (-w option)" id="idm46586656791936"/> instructs <code>grep</code> to match full words only, not partial
words, in case your system also has a username that contains “jones”,
such as <code>sallyjones2</code>.<a data-type="indexterm" data-startref="sort" id="idm46586656789760"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Command #6: uniq"><div class="sect2" id="section_uniq">
<h2>Command #6: uniq</h2>

<p><a data-type="indexterm" data-primary="uniq command" id="uniq"/><a data-type="indexterm" data-primary="detecting duplicates" data-see="duplicate detection" id="idm46586656785952"/><a data-type="indexterm" data-primary="lines adjacent that repeat" id="idm46586656785008"/><a data-type="indexterm" data-primary="duplicate detection" data-secondary="lines" id="idm46586656784320"/>
The <code>uniq</code> command detects repeated, adjacent lines in a file.  By
default, it removes the repeats. I’ll demonstrate this with a simple
file containing capital letters:</p>

<pre data-type="programlisting">$ <strong>cat letters</strong>
A
A
A
B
B
A
C
C
C
C
$ <strong>uniq letters</strong>
A
B
A
C</pre>

<p>Notice that <code>uniq</code> reduced the first three <code>A</code> lines to a single <code>A</code>, but
it left the last <code>A</code> in place because it wasn’t <em>adjacent</em> to the
first three.</p>

<p>You can also count occurrences with the <code>-c</code> option:<a data-type="indexterm" data-primary="uniq command" data-secondary="counting occurrences (-c option)" id="idm46586656777488"/></p>

<pre data-type="programlisting">$ <strong>uniq -c letters</strong>
      3 A
      2 B
      1 A
      4 C</pre>

<p>I’ll admit, when I first encountered the <code>uniq</code> command, I didn’t see
much use in it, but it quickly became one of my favorites. Suppose you
have a tab-separated file of students’ final grades for a university
course, ranging from <code>A</code> (best) to <code>F</code> (worst):</p>

<pre data-type="programlisting">$ <strong>cat grades</strong>
C	Geraldine
B	Carmine
A	Kayla
A	Sophia
B	Haresh
C	Liam
B	Elijah
B	Emma
A	Olivia
D	Noah
F	Ava</pre>

<p>You’d like to print the grade with the most occurrences. (If there’s a
tie, print just one of the winners.) Begin by isolating the grades
with <code>cut</code> and sorting them:</p>

<pre data-type="programlisting">$ <strong>cut -f1 grades | sort</strong>
A
A
A
B
B
B
B
C
C
D
F</pre>

<p>Next, use <code>uniq</code> to count adjacent lines:</p>

<pre data-type="programlisting">$ <strong>cut -f1 grades | sort | uniq -c</strong>
      3 A
      4 B
      2 C
      1 D
      1 F</pre>

<p>Then sort the lines in reverse order, numerically, to move the
most frequently occurring grade to the top line:</p>

<pre data-type="programlisting">$ <strong>cut -f1 grades | sort | uniq -c | sort -nr</strong>
      4 B
      3 A
      2 C
      1 F
      1 D</pre>

<p>and keep just the first line with <code>head</code>:</p>

<pre data-type="programlisting">$ <strong>cut -f1 grades | sort | uniq -c | sort -nr | head -n1</strong>
      4 B</pre>

<p>Finally, since you want just the letter grade, not the count, isolate
the grade with <code>cut</code>:</p>

<pre data-type="programlisting">$ <strong>cut -f1 grades | sort | uniq -c | sort -nr | head -n1 | cut -c9</strong>
B</pre>

<p>and there’s your answer, thanks to a six-command pipeline—our
longest yet. This sort of step-by-step pipeline construction is
not just an educational exercise. It’s how Linux experts actually
work. <a data-type="xref" href="ch08.xhtml#ch_one_liner">Chapter 8</a> is devoted to this technique.<a data-type="indexterm" data-startref="uniq" id="idm46586652446304"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Detecting Duplicate Files"><div class="sect1" id="sec_duplicate_files">
<h1>Detecting Duplicate Files</h1>

<p><a data-type="indexterm" data-primary="duplicate detection" data-secondary="files" id="idm46586652443728"/>
Let’s combine what you’ve learned with a larger example. Suppose
you’re in a directory full of JPEG files and you want to know if any
are duplicates:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
image001.jpg  image005.jpg  image009.jpg  image013.jpg  image017.jpg
image002.jpg  image006.jpg  image010.jpg  image014.jpg  image018.jpg
⋮</pre>

<p>You can answer this question with a pipeline. You’ll need another
command, <code>md5sum</code>,<a data-type="indexterm" data-primary="md5sum command" id="idm46586652440432"/> which examines a file’s contents and computes a
32-character string called <a data-type="indexterm" data-primary="checksum" id="idm46586652439568"/>a 
<span class="keep-together"><em>checksum</em>:</span></p>

<pre data-type="programlisting">$ <strong>md5sum image001.jpg</strong>
146b163929b6533f02e91bdf21cb9563  image001.jpg</pre>

<p>A given file’s checksum, for mathematical reasons, is very, very
likely to be unique. If two files have the same checksum, therefore,
they are almost certainly duplicates. Here, <code>md5sum</code> indicates the
first and third files are duplicates:</p>

<pre data-type="programlisting">$ <strong>md5sum image001.jpg image002.jpg image003.jpg</strong>
146b163929b6533f02e91bdf21cb9563  image001.jpg
63da88b3ddde0843c94269638dfa6958  image002.jpg
146b163929b6533f02e91bdf21cb9563  image003.jpg</pre>

<p>Duplicate checksums are easy to detect by eye when there are only
three files, but what if you have three thousand? It’s pipes to the
rescue. Compute all the checksums, use <code>cut</code> to isolate the first 32
characters of each line, and sort the lines to make any duplicates
adjacent:</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg | cut -c1-32 | sort</strong>
1258012d57050ef6005739d0e6f6a257
146b163929b6533f02e91bdf21cb9563
146b163929b6533f02e91bdf21cb9563
17f339ed03733f402f74cf386209aeb3
⋮</pre>

<p>Now add <code>uniq</code> to count repeated lines:</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg | cut -c1-32 | sort | uniq -c</strong>
      1 1258012d57050ef6005739d0e6f6a257
      2 146b163929b6533f02e91bdf21cb9563
      1 17f339ed03733f402f74cf386209aeb3
      ⋮</pre>

<p>If there are no duplicates, all of the counts produced by <code>uniq</code> will
be 1. Sort the results numerically from high to low, and any counts
greater than 1 will appear at the top of the output:</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg | cut -c1-32 | sort | uniq -c | sort -nr</strong>
      3 f6464ed766daca87ba407aede21c8fcc
      2 c7978522c58425f6af3f095ef1de1cd5
      2 146b163929b6533f02e91bdf21cb9563
      1 d8ad913044a51408ec1ed8a204ea9502
      ⋮</pre>

<p>Now let’s remove the nonduplicates. Their checksums are preceded by
six spaces, the number one, and a single space. We’ll use <code>grep -v</code> to
remove these lines:<sup><a data-type="noteref" id="idm46586652426688-marker" href="ch01.xhtml#idm46586652426688">5</a></sup></p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg | cut -c1-32 | sort | uniq -c | sort -nr | grep -v "      1 "</strong>
      3 f6464ed766daca87ba407aede21c8fcc
      2 c7978522c58425f6af3f095ef1de1cd5
      2 146b163929b6533f02e91bdf21cb9563</pre>

<p>Finally, you have your list of duplicate checksums, sorted by the
number of occurrences, produced by a beautiful six-command
pipeline. If it produces no output, there are no duplicate files.</p>

<p>This command would be even more useful if it displayed the filenames
of the duplicates, but that operation requires features we haven’t
discussed yet. (You’ll learn them in <a data-type="xref" href="ch05.xhtml#sec_awk_arrays">“Improving the duplicate file detector”</a>.) For now,
identify the files having a given checksum by searching with <code>grep</code>:</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg | grep 146b163929b6533f02e91bdf21cb9563</strong>
146b163929b6533f02e91bdf21cb9563  image001.jpg
146b163929b6533f02e91bdf21cb9563  image003.jpg</pre>

<p>and cleaning up the output with <code>cut</code>:</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg | grep 146b163929b6533f02e91bdf21cb9563 | cut -c35-</strong>
image001.jpg
image003.jpg</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586652444720">
<h1>Summary</h1>

<p>You’ve now seen the power of stdin, stdout, and pipes. They turn a
small handful of commands into a collection of composable tools,
proving that the whole is greater than the sum of the parts. <em>Any</em>
command that reads stdin or writes stdout can participate in
pipelines.<sup><a data-type="noteref" id="idm46586652416784-marker" href="ch01.xhtml#idm46586652416784">6</a></sup> As you learn more
commands, you can apply the general concepts from this chapter to
forge your own powerful combinations.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586656976720"><sup><a href="ch01.xhtml#idm46586656976720-marker">1</a></sup> On US keyboards, the pipe symbol is on the same key as the backslash (<code>\</code>), usually located between the Enter and Backspace keys or between the left Shift key and Z.</p><p data-type="footnote" id="idm46586652535568"><sup><a href="ch01.xhtml#idm46586652535568-marker">2</a></sup> The POSIX standard<a data-type="indexterm" data-primary="POSIX standard" id="idm46586652535040"/> calls this form of command a <em>utility<a data-type="indexterm" data-primary="utility" id="idm46586652533744"/></em>.</p><p data-type="footnote" id="idm46586655504608"><sup><a href="ch01.xhtml#idm46586655504608-marker">3</a></sup> Depending on your setup, <code>ls</code> may also use other formatting features, such as color, when printing to the screen but not when redirected.</p><p data-type="footnote" id="idm46586656804048"><sup><a href="ch01.xhtml#idm46586656804048-marker">4</a></sup> Some Linux systems store the user information elsewhere.</p><p data-type="footnote" id="idm46586652426688"><sup><a href="ch01.xhtml#idm46586652426688-marker">5</a></sup> Technically, you don’t need the final <code>sort -nr</code> in this pipeline to isolate duplicates because <code>grep</code> removes all the nonduplicates.</p><p data-type="footnote" id="idm46586652416784"><sup><a href="ch01.xhtml#idm46586652416784-marker">6</a></sup> Some commands do not use stdin/stdout and therefore cannot read from pipes or write to pipes. Examples are <code>mv</code> and <code>rm</code>. Pipelines may incorporate these commands in other ways, however; you’ll see examples in <a data-type="xref" href="ch08.xhtml#ch_one_liner">Chapter 8</a>.</p></div></div></section></div></body></html>