- en: Chapter 6\. Table Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers topics that relate to creating and populating tables, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying from one table to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using temporary tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating unique table names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining what storage engine a table uses or converting it from one storage
    engine to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many of the examples in this chapter use a table named `mail` containing rows
    that track mail message traffic between users on a set of hosts (see [Recipe 5.0](ch05.xhtml#nch-select-select-intro)).
    To create and load this table, change location into the *tables* directory of
    the `recipes` distribution and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 6.1 Cloning a Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a table that has exactly the same structure as an existing
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `CREATE` `TABLE` … `LIKE` to clone the table structure. To also copy some
    or all of the rows from the original table to the new one, use `INSERT` `INTO`
    … `SELECT`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new table that is just like an existing table, use this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of the new table is the same as that of the original table, with
    a few exceptions: `CREATE` `TABLE` … `LIKE` does not copy foreign key definitions,
    and it doesn’t copy any `DATA` `DIRECTORY` or `INDEX` `DIRECTORY` table options
    that the table might use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new table is empty. If you also want the contents to be the same as the
    original table, copy the rows using an `INSERT` `INTO` … `SELECT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy only part of the table, add an appropriate `WHERE` clause that identifies
    which rows to copy. For example, these statements create a copy of the `mail`
    table named `mail2`, populated only with the rows for mail sent by `barb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Selecting everything from the large table could be slow and not recommended
    on the production servers. We discuss how to copy huge tables in [Recipe 6.7](#nch-tblmgmt-tblmgmt-copy-tablespaces)
    and [Recipe 6.8](#nch-tblmgmt-tblmgmt-copy-myisam-sdi)
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about `INSERT` … `SELECT`, see [Recipe 6.2](#nch-tblmgmt-tblmgmt-into-table).
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Saving a Query Result in a Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to save the result from a `SELECT` statement to a table rather than
    display it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the table exists, retrieve rows into it using `INSERT` `INTO` … `SELECT`.
    If the table does not exist, create it on the fly using `CREATE` `TABLE` … `SELECT`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MySQL server normally returns the result of a `SELECT` statement to the
    client that executed the statement. For example, when you execute a statement
    from within the *mysql* program, the server returns the result to *mysql*, which
    in turn displays it on the screen. It’s possible to save the results of a `SELECT`
    statement in a table instead, which is useful in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily create a complete or partial copy of a table. If you’re developing
    an algorithm for your application that modifies a table, it’s safer to work with
    a copy of a table so that you need not worry about the consequences of mistakes.
    If the original table is large, creating a partial copy can speed the development
    process because queries run against it take less time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a data-loading operation based on information that might be malformed, load
    new rows into a test temporary table, perform some preliminary checks, and correct
    the rows as necessary. When you’re satisfied that the new rows are okay, copy
    them from the temporary table to your main table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some applications maintain a large repository table and a smaller working table
    into which rows are inserted on a regular basis, copying the working table rows
    to the repository periodically and clearing the working table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To perform summary operations on a large table more efficiently, avoid running
    expensive summary operations repeatedly on it. Instead, select summary information
    once into a second table and use that for further analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe shows how to retrieve a result set into a table. The table names
    `src_tbl` and `dst_tbl` in the examples refer to the source table from which rows
    are selected and the destination table into which they are stored, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the destination table already exists, use `INSERT` … `SELECT` to copy the
    result set into it. For example, if `dst_tbl` contains an integer column `i` and
    a string column `s`, the following statement copies rows from `src_tbl` into `dst_tbl`,
    assigning column `val` to `i` and column `name` to `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of columns to be inserted must match the number of selected columns,
    with the correspondence between columns based on position rather than name. To
    copy all columns, you can shorten the statement to this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy only certain rows, add a `WHERE` clause that selects those rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SELECT` statement can produce values from expressions, too. For example,
    the following statement counts the number of times each name occurs in `src_tbl`
    and stores both the counts and the names in `dst_tbl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the destination table does not exist, create it first with a `CREATE` `TABLE`
    statement, then copy rows into it with `INSERT` … `SELECT`. Alternatively, use
    `CREATE` `TABLE` … `SELECT` to create the destination table directly from the
    result of the `SELECT`. For example, to create `dst_tbl` and copy the entire contents
    of `src_tbl` into it, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: does not copy indexes from the source table. If you use this syntax and destination
    table should have indexes add them after the statement completes. We discuss indexes
    in [Recipe 21.1](ch21.xhtml#nch-queryperf-queryperf-create-index).
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL creates the columns in `dst_tbl` based on the name, number, and type
    of the columns in `src_tbl`. To copy only certain rows, add an appropriate `WHERE`
    clause. To create an empty table, use a `WHERE` clause that selects no rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy only some of the columns, name the ones you want in the `SELECT` part
    of the statement. For example, if `src_tbl` contains columns `a`, `b`, `c`, and
    `d`, copy just `b` and `d` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To create columns in an order different from that in which they appear in the
    source table, name them in the desired order. If the source table contains columns
    `a`, `b`, and `c` that should appear in the destination table in the order `c`,
    `a`, `b`, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To create columns in the destination table in addition to those selected from
    the source table, provide appropriate column definitions in the `CREATE` `TABLE`
    part of the statement. The following statement creates `id` as an `AUTO_INCREMENT`
    column in `dst_tbl` and adds columns `a`, `b`, and `c` from `src_tbl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The resulting table contains four columns in the order `id`, `a`, `b`, `c`.
    Defined columns are assigned their default values. This means that `id`, being
    an `AUTO_INCREMENT` column, is assigned successive sequence numbers starting from
    1 (see [Recipe 15.1](ch15.xhtml#nch-sequences-seq-create-col)).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you derive a column’s values from an expression, its default name is the
    expression itself, which can be difficult to work with later. In this case, it’s
    prudent to give the column a better name by providing an alias (see [Recipe 5.2](ch05.xhtml#nch-select-select-column-alias)).
    Suppose that `src_tbl` contains invoice information that lists items in each invoice.
    The following statement generates a summary that lists each invoice named in the
    table and the total cost of its items, using an alias for the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`CREATE` `TABLE` … `SELECT` is extremely convenient, but has some limitations
    that arise from the fact that the information available from a result set is not
    as extensive as what you can specify in a `CREATE` `TABLE` statement. For example,
    MySQL has no idea whether a result set column should be indexed or what its default
    value is. If it’s important to include this information in the destination table,
    use the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: To make the destination table an *exact* copy of the source table, use the cloning
    technique described in [Recipe 6.1](#nch-tblmgmt-tblmgmt-clone).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To include indexes in the destination table, specify them explicitly. For example,
    if `src_tbl` has a `PRIMARY` `KEY` on the `id` column, and a multiple-column index
    on `state` and `city`, specify them for `dst_tbl` as well:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Column attributes such as `AUTO_INCREMENT` and a column’s default value are
    not copied to the destination table. To preserve these attributes, create the
    table, then use `ALTER` `TABLE` to apply the appropriate modifications to the
    column definition. For example, if `src_tbl` has an `id` column that is not only
    a `PRIMARY` `KEY` but also an `AUTO_INCREMENT` column, copy the table and modify
    the copy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 6.3 Creating Temporary Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a table only for a short time, after which you want it to disappear
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a table using the `TEMPORARY` keyword, and let MySQL take care of removing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some operations require a table that exists only temporarily and that should
    disappear when it’s no longer needed. You can, of course, execute a `DROP` `TABLE`
    statement explicitly to remove a table when you’re done with it. Another option
    is to use `CREATE` `TEMPORARY` `TABLE`. This statement is like `CREATE` `TABLE`
    but creates a transient table that disappears when your session with the server
    ends, if you haven’t already removed it yourself. This is extremely useful behavior
    because MySQL drops the table for you automatically; you need not remember to
    do it. `TEMPORARY` can be used with the usual table-creation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the table from explicit column definitions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the table from an existing table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the table on the fly from a result set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Temporary tables are session-specific, so multiple clients can each create a
    temporary table having the same name without interfering with each other. This
    makes it easier to write applications that use transient tables because you need
    not ensure that the tables have unique names for each client. (For further discussion
    of table-naming issues, see [Recipe 6.4](#nch-tblmgmt-tblmgmt-unique-name).)
  prefs: []
  type: TYPE_NORMAL
- en: 'A temporary table can have the same name as a permanent table. In this case,
    the temporary table <q>hides</q> the permanent table for the duration of its existence,
    which can be useful for making a copy of a table that you can modify without affecting
    the original by mistake. The `DELETE` statement in the following example removes
    rows from a temporary `mail` table, leaving the original permanent table unaffected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Although temporary tables created with `CREATE` `TEMPORARY` `TABLE` have the
    benefits just discussed, keep the following caveats in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: To reuse a temporary table within a given session, you must still drop it explicitly
    before re-creating it. Attempting to create a second temporary table with the
    same name results in an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you modify a temporary table that <q>hides</q> a permanent table with the
    same name, be sure to test for errors resulting from dropped connections if you
    use a programming interface that has reconnect capability enabled. If a client
    program automatically reconnects after detecting a dropped connection, modifications
    affect the permanent table after the reconnect, not the temporary table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some APIs support persistent connections or connection pools. These prevent
    temporary tables from being dropped as you expect when your script ends because
    the connection remains open for reuse by other scripts. Your script has no control
    over when the connection closes. This means it can be prudent to execute the following
    statement prior to creating a temporary table, just in case it’s still in existence
    from a previous execution of the script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TEMPORARY` keyword is useful here if the temporary table has already been
    dropped, to avoid dropping any permanent table that has the same name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 6.4 Generating Unique Table Names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to create a table with a name guaranteed not to exist.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generate a value that is unique to your client program and incorporate it into
    the table name.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL is a multiple-client database server, so if a given script that creates
    a transient table might be invoked by several clients simultaneously, take care
    that multiple invocations of the script do not fight over the same table name.
    If the script creates tables using `CREATE` `TEMPORARY` `TABLE`, there is no problem
    because different clients can create temporary tables having the same name without
    clashing.
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot or do not want to use a `TEMPORARY` table, make sure that each
    invocation of the script creates a uniquely named table and drops the table when
    it is no longer needed. To accomplish this, incorporate into the name some value
    guaranteed to be unique per invocation. A timestamp won’t work if it’s possible
    for two instances of a script to be invoked within the timestamp resolution. A
    random number may be better, but random numbers only reduce the possibility of
    name clashes, not eliminate it. Values, generated bu function `UUID` are a better
    source for unique values. Function `UUID` returns a Universal Unique Identifier
    (UUID) generated according to [RFC 4122, “A Universally Unique IDentifier (UUID)
    URN Namespace](http://www.ietf.org/rfc/rfc4122.txt) and designed to produce 128
    bits string that is unique in space and time. While the value generated by this
    function, is not necessary unique, it is enough to generate unique temporary table
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to incorporate a `UUID` into a table name within SQL by using
    prepared statements. The following example illustrates this, referring to the
    table name in the `CREATE` `TABLE` statement and a precautionary `DROP` `TABLE`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 6.5 Checking or Changing a Table Storage Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check which storage engine a table uses so that you can determine
    what engine capabilities are applicable. Or you need to change a table’s storage
    engine because you realize that the capabilities of another engine are more suitable
    for the way you use the table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To determine a table’s storage engine, you can use any of several statements.
    To change the table’s engine, use `ALTER` `TABLE` with an `ENGINE` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL supports multiple storage engines, which have differing characteristics.
    For example, the InnoDB engine supports transactions, whereas Memory does not.
    If you need to know whether a table supports transactions, check which storage
    engine it uses. If the table’s engine does not support transactions, you can convert
    the table to use a transaction-capable engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the current engine for a table, check `INFORMATION_SCHEMA` or
    use the `SHOW` `TABLE` `STATUS` or `SHOW` `CREATE` `TABLE` statement. For the
    `mail` table, obtain engine information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the storage engine for a table, use `ALTER` `TABLE` with an `ENGINE`
    specifier. For example, to convert the `mail` table to use the Memory storage
    engine, use this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that converting a large table to a different storage engine might take
    a long time and be expensive in terms of CPU and I/O activity.
  prefs: []
  type: TYPE_NORMAL
- en: To determine which storage engines your MySQL server supports, check the output
    from the `SHOW` `ENGINES` statement or query the `INFORMATION_SCHEMA` `ENGINES`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Copying a Table Using mysqldump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to copy a table or tables, either among the databases managed by a
    MySQL server, or from one server to another.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *mysqldump* program.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *mysqldump* program makes a backup file that can be reloaded to re-create
    the original table or tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output file *mail.sql* consists of a `CREATE` `TABLE` statement to create
    the `mail` table and a set of `INSERT` statements to insert its rows. You can
    reload the file to re-create the table should the original be lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This method also makes it easy to deal with any triggers the table has. By default,
    *mysqldump* writes the triggers to the dump file, so reloading the file copies
    the triggers along with the table with no special handling.
  prefs: []
  type: TYPE_NORMAL
- en: By default *mysqldump* includes statement `DROP TABLE IF EXISTS` before `CREATE
    TABLE`. If you do not want to drop the table when loading the dump and prefer
    the operation to fail instead run *mysqldump* with option `--skip-add-drop-table`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to restoring tables, *mysqldump* can be used to make copies of them,
    by reloading the output into a different database. (If the destination database
    does not exist, create it first.) The following examples show some useful table-copying
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Copying tables within a single MySQL server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Copy a single table to a different database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To dump multiple tables, name them all following the database name argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Copy all tables in a database to a different database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you name no tables after the database name, *mysqldump* dumps them all.
    To also include stored routines and events, add the `--routines` and `--events`
    options to the *mysqldump* command. (There is also a `--triggers` option, but
    it’s unneeded because, as mentioned previously, *mysqldump* dumps triggers with
    their associated tables by default.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Copy a table, using a different name for the copy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dump the table:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the table into a different database that does *not* contain a table
    with that name:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Rename the table:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, to move the table into another database at the same time, qualify the new
    name with the database name:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To perform a table-copying operation without an intermediary file, use a pipe
    to connect the *mysqldump* and *mysql* commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may consider using newer tool *mysqlpump* that works similarly to *mysqldump*,
    but supports smarter filters and parallel processing. We discuss *mysqlpump* in
    [Recipe 13.13](ch13.xhtml#nch-xfer-xfer-export-sql).
  prefs: []
  type: TYPE_NORMAL
- en: Copying tables between MySQL servers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding commands use *mysqldump* to copy tables among the databases managed
    by a single MySQL server. Output from *mysqldump* can also be used to copy tables
    from one server to another. Suppose that you want to copy the `mail` table from
    the `cookbook` database on the local host to the `other_db` database on the host
    *other-host.example.com*. One way to do this is to dump the output into a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then copy *mail.sql* to *other-host.example.com*, and run the following command
    there to load the table into that MySQL server’s `other_db` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To accomplish this without an intermediary file, use a pipe to send the output
    of *mysqldump* directly over the network to the remote MySQL server. If you can
    connect to both servers from your local host, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The *mysqldump* half of the command connects to the local server and writes
    the dump output to the pipe. The *mysql* half of the command connects to the remote
    MySQL server on *other-host.example.com*. It reads the pipe for input and sends
    each statement to the *other-host.example.com* server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you cannot connect directly to the remote server using *mysql* from your
    local host, send the dump output into a pipe that uses *ssh* to invoke *mysql*
    remotely on *other-host.example.com*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*ssh* connects to *other-host.example.com* and launches *mysql* there. It then
    reads the *mysqldump* output from the pipe and passes it to the remote *mysql*
    process. *ssh* can be useful to send a dump over the network to a machine that
    has the MySQL port blocked by a firewall but that permits connections on the SSH
    port.'
  prefs: []
  type: TYPE_NORMAL
- en: Regarding which table or tables to copy, similar principles apply as for local
    copies. To copy multiple tables over the network, name them all following the
    database argument of the *mysqldump* command. To copy an entire database, don’t
    specify any table names after the database name; *mysqldump* dumps all its tables.
    To copy all databases that reside on your MySQL instance specify option `--all-databases`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7 Copying an InnoDB Table Using Transportable Tablespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to copy an InnoDB table, but the table is too big, and dumping data
    from it in human-readable format takes long time. Reload is not fast either.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use transportable tablespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tools like *mysqldump* or *mysqlpump* are good when you work with comparatively
    small table or if you want to examine resulting SQL dump yourself before applying
    it to the target server. However, copying in such a way a table that occupies
    few gigabytes on the disk will take high amount of time. It will also create additional
    load on the server. To make things worse protection mechanisms will affect other
    connections that use the same table.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve such an issue binary backup and restore methods exist. These methods
    work on the binary table files without doing any additional data manipulations,
    therefore performance is the same as if you run command *cp* on Linux or *copy*
    on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: As of version 8.0 MySQL stores table definitions in the data dictionary while
    data is stored in the separate files. Format and name of such files depend from
    the storage engine. In case of InnoDB they are individual, general and system
    tablespaces. Individual tablespace files store data for each table individually
    and could be used for the method we describe in this section. If your tables are
    stored in the system or general tablespaces you first need to convert them to
    use individual tablespace format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out if your table resides in the system or general tablespaces, query
    table `INNODB_TABLES` in the Information Schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are ready to copy the tablespace login into the *mysql* client and
    execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This command will prepare tablespace file for being copied and additionally
    create configuation file with extension `.cfg` that will contain table metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Keep the MySQL client open and in the another terminal window copy the tablespace
    and configuation files into the desired location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Once copy finishes unlock the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now you can import the tablespace into remote server or into a different database
    on the same local server.
  prefs: []
  type: TYPE_NORMAL
- en: First step would be to create a table with the exactly same definition as the
    original one. You can find the table definition if run command *SHOW CREATE TABLE*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Once you obtained it connect to the destination database and create a table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]limbs[PRE45]thing[PRE46]legs[PRE47]arms[PRE48]'
  prefs: []
  type: TYPE_NORMAL
- en: 'After new empty table is created discard its tablespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`DISCARD TABLESPACE` removes tablespace files. Be very carefull with this command.
    If you make a typo and discard a tablespace for the wrong table it could not be
    restored.'
  prefs: []
  type: TYPE_NORMAL
- en: After tablespace discarded copy table files into the new database directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Then import the tablespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about exchanging tablespace files between MySQL databases
    and servers, see [Importing InnoDB Tables](https://dev.mysql.com/doc/refman/8.0/en/innodb-table-import.html).
  prefs: []
  type: TYPE_NORMAL
- en: 6.8 Copying a MyISAM Table Using an sdi File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to copy a large MyISAM table on MySQL 8.0.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `IMPORT TABLE` command.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tables which use MyISAM storage engine support import of the raw table files
    with help of the *IMPORT TABLE* statement. To export MyISAM tables without risk
    to corrupt data during migration open a MySQL connection first and flush the table
    files to the disk with read lock.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then copy table data, index and metadata files into the backup location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Unlock the original table.
  prefs: []
  type: TYPE_NORMAL
- en: Table metadata file with the extension `.sdi` has random sequence of digits
    in its name, therefore use *sudo* to copy it to allow shell process to expand
    the file glob pattern.
  prefs: []
  type: TYPE_NORMAL
- en: To copy MyISAM table into the desired destination put the table metadata file
    with extension `sdi` into the directory, specified by the option `--secure-file-priv`,
    or into any directory, readable by the target MySQL server if such an option is
    not set. Then copy index and data file into the target database directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Then connect to the database and import the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you are copying the table into a database with different name you need to
    edit the `sdi` file manually and replace value of the `schema_ref` with the target
    database name.
  prefs: []
  type: TYPE_NORMAL
