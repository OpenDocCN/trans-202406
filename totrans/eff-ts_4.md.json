["```\ninterface State {\n  pageText: string;\n  isLoading: boolean;\n  error?: string;\n}\n```", "```\nfunction renderPage(state: State) {\n  if (state.error) {\n    return `Error! Unable to load ${currentPage}: ${state.error}`;\n  } else if (state.isLoading) {\n    return `Loading ${currentPage}...`;\n  }\n  return `<h1>${currentPage}</h1>\\n${state.pageText}`;\n}\n```", "```\nasync function changePage(state: State, newPage: string) {\n  state.isLoading = true;\n  try {\n    const response = await fetch(getUrlForPage(newPage));\n    if (!response.ok) {\n      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);\n    }\n    const text = await response.text();\n    state.isLoading = false;\n    state.pageText = text;\n  } catch (e) {\n    state.error = '' + e;\n  }\n}\n```", "```\ninterface RequestPending {\n  state: 'pending';\n}\ninterface RequestError {\n  state: 'error';\n  error: string;\n}\ninterface RequestSuccess {\n  state: 'ok';\n  pageText: string;\n}\ntype RequestState = RequestPending | RequestError | RequestSuccess;\n\ninterface State {\n  currentPage: string;\n  requests: {[page: string]: RequestState};\n}\n```", "```\nfunction renderPage(state: State) {\n  const {currentPage} = state;\n  const requestState = state.requests[currentPage];\n  switch (requestState.state) {\n    case 'pending':\n      return `Loading ${currentPage}...`;\n    case 'error':\n      return `Error! Unable to load ${currentPage}: ${requestState.error}`;\n    case 'ok':\n      return `<h1>${currentPage}</h1>\\n${requestState.pageText}`;\n  }\n}\n\nasync function changePage(state: State, newPage: string) {\n  state.requests[newPage] = {state: 'pending'};\n  state.currentPage = newPage;\n  try {\n    const response = await fetch(getUrlForPage(newPage));\n    if (!response.ok) {\n      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);\n    }\n    const pageText = await response.text();\n    state.requests[newPage] = {state: 'ok', pageText};\n  } catch (e) {\n    state.requests[newPage] = {state: 'error', error: '' + e};\n  }\n}\n```", "```\ninterface CockpitControls {\n  /** Angle of the left side stick in degrees, 0 = neutral, + = forward */\n  leftSideStick: number;\n  /** Angle of the right side stick in degrees, 0 = neutral, + = forward */\n  rightSideStick: number;\n}\n```", "```\nfunction getStickSetting(controls: CockpitControls) {\n  return controls.leftSideStick;\n}\n```", "```\nfunction getStickSetting(controls: CockpitControls) {\n  const {leftSideStick, rightSideStick} = controls;\n  if (leftSideStick === 0) {\n    return rightSideStick;\n  }\n  return leftSideStick;\n}\n```", "```\nfunction getStickSetting(controls: CockpitControls) {\n  const {leftSideStick, rightSideStick} = controls;\n  if (leftSideStick === 0) {\n    return rightSideStick;\n  } else if (rightSideStick === 0) {\n    return leftSideStick;\n  }\n  // ???\n}\n```", "```\nfunction getStickSetting(controls: CockpitControls) {\n  const {leftSideStick, rightSideStick} = controls;\n  if (leftSideStick === 0) {\n    return rightSideStick;\n  } else if (rightSideStick === 0) {\n    return leftSideStick;\n  }\n  if (Math.abs(leftSideStick - rightSideStick) < 5) {\n    return (leftSideStick + rightSideStick) / 2;\n  }\n  // ???\n}\n```", "```\nfunction getStickSetting(controls: CockpitControls) {\n  return (controls.leftSideStick + controls.rightSideStick) / 2;\n}\n```", "```\ninterface CockpitControls {\n  /** Angle of the stick in degrees, 0 = neutral, + = forward */\n  stickAngle: number;\n}\n```", "```\ndeclare function setCamera(camera: CameraOptions): void;\ndeclare function viewportForBounds(bounds: LngLatBounds): CameraOptions;\n```", "```\ninterface CameraOptions {\n  center?: LngLat;\n  zoom?: number;\n  bearing?: number;\n  pitch?: number;\n}\ntype LngLat =\n  { lng: number; lat: number; } |\n  { lon: number; lat: number; } |\n  [number, number];\n```", "```\ntype LngLatBounds =\n  {northeast: LngLat, southwest: LngLat} |\n  [LngLat, LngLat] |\n  [number, number, number, number];\n```", "```\nfunction focusOnFeature(f: Feature) {\n  const bounds = calculateBoundingBox(f);\n  const camera = viewportForBounds(bounds);\n  setCamera(camera);\n  const {center: {lat, lng}, zoom} = camera;\n               // ~~~      Property 'lat' does not exist on type ...\n               //      ~~~ Property 'lng' does not exist on type ...\n  zoom;  // Type is number | undefined\n  window.location.search = `?v=@${lat},${lng}z${zoom}`;\n}\n```", "```\ninterface LngLat { lng: number; lat: number; };\ntype LngLatLike = LngLat | { lon: number; lat: number; } | [number, number];\n\ninterface Camera {\n  center: LngLat;\n  zoom: number;\n  bearing: number;\n  pitch: number;\n}\ninterface CameraOptions extends Omit<Partial<Camera>, 'center'> {\n  center?: LngLatLike;\n}\ntype LngLatBounds =\n  {northeast: LngLatLike, southwest: LngLatLike} |\n  [LngLatLike, LngLatLike] |\n  [number, number, number, number];\n\ndeclare function setCamera(camera: CameraOptions): void;\ndeclare function viewportForBounds(bounds: LngLatBounds): Camera;\n```", "```\ninterface CameraOptions {\n  center?: LngLatLike;\n  zoom?: number;\n  bearing?: number;\n  pitch?: number;\n}\n```", "```\nfunction focusOnFeature(f: Feature) {\n  const bounds = calculateBoundingBox(f);\n  const camera = viewportForBounds(bounds);\n  setCamera(camera);\n  const {center: {lat, lng}, zoom} = camera;  // OK\n  zoom;  // Type is number\n  window.location.search = `?v=@${lat},${lng}z${zoom}`;\n}\n```", "```\n/**\n * Returns a string with the foreground color.\n * Takes zero or one arguments. With no arguments, returns the\n * standard foreground color. With one argument, returns the foreground color\n * for a particular page.\n */\nfunction getForegroundColor(page?: string) {\n  return page === 'login' ? {r: 127, g: 127, b: 127} : {r: 0, g: 0, b: 0};\n}\n```", "```\n/** Get the foreground color for the application or a specific page. */\nfunction getForegroundColor(page?: string): Color {\n  // ...\n}\n```", "```\n/** Does not modify nums */\nfunction sort(nums: number[]) { /* ... */ }\n```", "```\nfunction sort(nums: readonly number[]) { /* ... */ }\n```", "```\nfunction extent(nums: number[]) {\n  let min, max;\n  for (const num of nums) {\n    if (!min) {\n      min = num;\n      max = num;\n    } else {\n      min = Math.min(min, num);\n      max = Math.max(max, num);\n    }\n  }\n  return [min, max];\n}\n```", "```\nfunction extent(nums: number[]) {\n  let min, max;\n  for (const num of nums) {\n    if (!min) {\n      min = num;\n      max = num;\n    } else {\n      min = Math.min(min, num);\n      max = Math.max(max, num);\n                  // ~~~ Argument of type 'number | undefined' is not\n                  //     assignable to parameter of type 'number'\n    }\n  }\n  return [min, max];\n}\n```", "```\nconst [min, max] = extent([0, 1, 2]);\nconst span = max - min;\n          // ~~~   ~~~ Object is possibly 'undefined'\n```", "```\nfunction extent(nums: number[]) {\n  let result: [number, number] | null = null;\n  for (const num of nums) {\n    if (!result) {\n      result = [num, num];\n    } else {\n      result = [Math.min(num, result[0]), Math.max(num, result[1])];\n    }\n  }\n  return result;\n}\n```", "```\nconst [min, max] = extent([0, 1, 2])!;\nconst span = max - min;  // OK\n```", "```\nconst range = extent([0, 1, 2]);\nif (range) {\n  const [min, max] = range;\n  const span = max - min;  // OK\n}\n```", "```\nclass UserPosts {\n  user: UserInfo | null;\n  posts: Post[] | null;\n\n  constructor() {\n    this.user = null;\n    this.posts = null;\n  }\n\n  async init(userId: string) {\n    return Promise.all([\n      async () => this.user = await fetchUser(userId),\n      async () => this.posts = await fetchPostsForUser(userId)\n    ]);\n  }\n\n  getUserName() {\n    // ...?\n  }\n}\n```", "```\nclass UserPosts {\n  user: UserInfo;\n  posts: Post[];\n\n  constructor(user: UserInfo, posts: Post[]) {\n    this.user = user;\n    this.posts = posts;\n  }\n\n  static async init(userId: string): Promise<UserPosts> {\n    const [user, posts] = await Promise.all([\n      fetchUser(userId),\n      fetchPostsForUser(userId)\n    ]);\n    return new UserPosts(user, posts);\n  }\n\n  getUserName() {\n    return this.user.name;\n  }\n}\n```", "```\ninterface Layer {\n  layout: FillLayout | LineLayout | PointLayout;\n  paint: FillPaint | LinePaint | PointPaint;\n}\n```", "```\ninterface FillLayer {\n  layout: FillLayout;\n  paint: FillPaint;\n}\ninterface LineLayer {\n  layout: LineLayout;\n  paint: LinePaint;\n}\ninterface PointLayer {\n  layout: PointLayout;\n  paint: PointPaint;\n}\ntype Layer = FillLayer | LineLayer | PointLayer;\n```", "```\ninterface Layer {\n  type: 'fill' | 'line' | 'point';\n  layout: FillLayout | LineLayout | PointLayout;\n  paint: FillPaint | LinePaint | PointPaint;\n}\n```", "```\ninterface FillLayer {\n  type: 'fill';\n  layout: FillLayout;\n  paint: FillPaint;\n}\ninterface LineLayer {\n  type: 'line';\n  layout: LineLayout;\n  paint: LinePaint;\n}\ninterface PointLayer {\n  type: 'paint';\n  layout: PointLayout;\n  paint: PointPaint;\n}\ntype Layer = FillLayer | LineLayer | PointLayer;\n```", "```\nfunction drawLayer(layer: Layer) {\n  if (layer.type === 'fill') {\n    const {paint} = layer;  // Type is FillPaint\n    const {layout} = layer;  // Type is FillLayout\n  } else if (layer.type === 'line') {\n    const {paint} = layer;  // Type is LinePaint\n    const {layout} = layer;  // Type is LineLayout\n  } else {\n    const {paint} = layer;  // Type is PointPaint\n    const {layout} = layer;  // Type is PointLayout\n  }\n}\n```", "```\ninterface Person {\n  name: string;\n  // These will either both be present or not be present\n  placeOfBirth?: string;\n  dateOfBirth?: Date;\n}\n```", "```\ninterface Person {\n  name: string;\n  birth?: {\n    place: string;\n    date: Date;\n  }\n}\n```", "```\nconst alanT: Person = {\n  name: 'Alan Turing',\n  birth: {\n// ~~~~ Property 'date' is missing in type\n//      '{ place: string; }' but required in type\n//      '{ place: string; date: Date; }'\n    place: 'London'\n  }\n}\n```", "```\nfunction eulogize(p: Person) {\n  console.log(p.name);\n  const {birth} = p;\n  if (birth) {\n    console.log(`was born on ${birth.date} in ${birth.place}.`);\n  }\n}\n```", "```\ninterface Name {\n  name: string;\n}\n\ninterface PersonWithBirth extends Name {\n  placeOfBirth: string;\n  dateOfBirth: Date;\n}\n\ntype Person = Name | PersonWithBirth;\n```", "```\nfunction eulogize(p: Person) {\n  if ('placeOfBirth' in p) {\n    p // Type is PersonWithBirth\n    const {dateOfBirth} = p  // OK, type is Date\n  }\n}\n```", "```\ninterface Album {\n  artist: string;\n  title: string;\n  releaseDate: string;  // YYYY-MM-DD\n  recordingType: string;  // E.g., \"live\" or \"studio\"\n}\n```", "```\nconst kindOfBlue: Album = {\n  artist: 'Miles Davis',\n  title: 'Kind of Blue',\n  releaseDate: 'August 17th, 1959',  // Oops!\n  recordingType: 'Studio',  // Oops!\n};  // OK\n```", "```\nfunction recordRelease(title: string, date: string) { /* ... */ }\nrecordRelease(kindOfBlue.releaseDate, kindOfBlue.title);  // OK, should be error\n```", "```\ntype RecordingType = 'studio' | 'live';\n\ninterface Album {\n  artist: string;\n  title: string;\n  releaseDate: Date;\n  recordingType: RecordingType;\n}\n```", "```\nconst kindOfBlue: Album = {\n  artist: 'Miles Davis',\n  title: 'Kind of Blue',\n  releaseDate: new Date('1959-08-17'),\n  recordingType: 'Studio'\n// ~~~~~~~~~~~~ Type '\"Studio\"' is not assignable to type 'RecordingType'\n};\n```", "```\nfunction getAlbumsOfType(recordingType: string): Album[] {\n  // ...\n}\n```", "```\n/** What type of environment was this recording made in?  */\ntype RecordingType = 'live' | 'studio';\n```", "```\nfunction pluck(records, key) {\n  return record.map(record => record[key]);\n}\n```", "```\nfunction pluck(record: any[], key: string): any[] {\n  return record.map(r => r[key]);\n}\n```", "```\nfunction pluck<T>(record: T[], key: string): any[] {\n  return record.map(r => r[key]);\n                      // ~~~~~~ Element implicitly has an 'any' type\n                      //        because type '{}' has no index signature\n}\n```", "```\ntype K = keyof Album;\n// Type is \"artist\" | \"title\" | \"releaseDate\" | \"recordingType\"\n```", "```\nfunction pluck<T>(record: T[], key: keyof T) {\n  return record.map(r => r[key]);\n}\n```", "```\nfunction pluck<T>(record: T[], key: keyof T): T[keyof T][]\n```", "```\nconst releaseDates = pluck(albums, 'releaseDate'); // Type is (string | Date)[]\n```", "```\nfunction pluck<T, K extends keyof T>(record: T[], key: K): T[K][] {\n  return record.map(r => r[key]);\n}\n```", "```\npluck(albums, 'releaseDate'); // Type is Date[]\npluck(albums, 'artist');  // Type is string[]\npluck(albums, 'recordingType');  // Type is RecordingType[]\npluck(albums, 'recordingDate');\n           // ~~~~~~~~~~~~~~~ Argument of type '\"recordingDate\"' is not\n           //                 assignable to parameter of type ...\n```", "```\ninterface Point {\n  type: 'Point';\n  coordinates: number[];\n}\ninterface LineString {\n  type: 'LineString';\n  coordinates: number[][];\n}\ninterface Polygon {\n  type: 'Polygon';\n  coordinates: number[][][];\n}\ntype Geometry = Point | LineString | Polygon;  // Also several others\n```", "```\ntype GeoPosition = [number, number];\ninterface Point {\n  type: 'Point';\n  coordinates: GeoPosition;\n}\n// Etc.\n```", "```\n12\n\"red\"\n[\"+\", 1, 2]  // 3\n[\"/\", 20, 2]  // 10\n[\"case\", [\">\", 20, 10], \"red\", \"blue\"]  // \"red\"\n[\"rgb\", 255, 0, 127]  // \"#FF007F\"\n```", "```\ntype Expression1 = any;\ntype Expression2 = number | string | any[];\n```", "```\nconst tests: Expression2[] = [\n  10,\n  \"red\",\n  true,\n// ~~~ Type 'true' is not assignable to type 'Expression2'\n  [\"+\", 10, 5],\n  [\"case\", [\">\", 20, 10], \"red\", \"blue\", \"green\"],  // Too many values\n  [\"**\", 2, 31],  // Should be an error: no \"**\" function\n  [\"rgb\", 255, 128, 64],\n  [\"rgb\", 255, 0, 127, 0]  // Too many values\n];\n```", "```\ntype FnName = '+' | '-' | '*' | '/' | '>' | '<' | 'case' | 'rgb';\ntype CallExpression = [FnName, ...any[]];\ntype Expression3 = number | string | CallExpression;\n\nconst tests: Expression3[] = [\n  10,\n  \"red\",\n  true,\n// ~~~ Type 'true' is not assignable to type 'Expression3'\n  [\"+\", 10, 5],\n  [\"case\", [\">\", 20, 10], \"red\", \"blue\", \"green\"],\n  [\"**\", 2, 31],\n// ~~~~~~~~~~~ Type '\"**\"' is not assignable to type 'FnName'\n  [\"rgb\", 255, 128, 64]\n];\n```", "```\ntype Expression4 = number | string | CallExpression;\n\ntype CallExpression = MathCall | CaseCall | RGBCall;\n\ninterface MathCall {\n  0: '+' | '-' | '/' | '*' | '>' | '<';\n  1: Expression4;\n  2: Expression4;\n  length: 3;\n}\n\ninterface CaseCall {\n  0: 'case';\n  1: Expression4;\n  2: Expression4;\n  3: Expression4;\n  length: 4 | 6 | 8 | 10 | 12 | 14 | 16 // etc.\n}\n\ninterface RGBCall {\n  0: 'rgb';\n  1: Expression4;\n  2: Expression4;\n  3: Expression4;\n  length: 4;\n}\n\nconst tests: Expression4[] = [\n  10,\n  \"red\",\n  true,\n// ~~~ Type 'true' is not assignable to type 'Expression4'\n  [\"+\", 10, 5],\n  [\"case\", [\">\", 20, 10], \"red\", \"blue\", \"green\"],\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//  Type '[\"case\", [\">\", ...], ...]' is not assignable to type 'string'\n  [\"**\", 2, 31],\n// ~~~~~~~~~~~~ Type '[\"**\", number, number]' is not assignable to type 'string\n  [\"rgb\", 255, 128, 64],\n  [\"rgb\", 255, 128, 64, 73]\n// ~~~~~~~~~~~~~~~~~~~~~~~~ Type '[\"rgb\", number, number, number, number]'\n//                          is not assignable to type 'string'\n];\n```", "```\n const okExpressions: Expression4[] = [\n   ['-', 12],\n// ~~~~~~~~~ Type '[\"-\", number]' is not assignable to type 'string'\n   ['+', 1, 2, 3],\n// ~~~~~~~~~~~~~~ Type '[\"+\", number, ...]' is not assignable to type 'string'\n   ['*', 2, 3, 4],\n// ~~~~~~~~~~~~~~ Type '[\"*\", number, ...]' is not assignable to type 'string'\n ];\n```", "```\nfunction calculateBoundingBox(f: GeoJSONFeature): BoundingBox | null {\n  let box: BoundingBox | null = null;\n\n  const helper = (coords: any[]) => {\n    // ...\n  };\n\n  const {geometry} = f;\n  if (geometry) {\n    helper(geometry.coordinates);\n  }\n\n  return box;\n}\n```", "```\n$ npm install --save-dev @types/geojson\n+ @types/geojson@7946.0.7\n```", "```\nimport {Feature} from 'geojson';\n\nfunction calculateBoundingBox(f: Feature): BoundingBox | null {\n  let box: BoundingBox | null = null;\n\n  const helper = (coords: any[]) => {\n    // ...\n  };\n\n  const {geometry} = f;\n  if (geometry) {\n    helper(geometry.coordinates);\n                 // ~~~~~~~~~~~\n                 // Property 'coordinates' does not exist on type 'Geometry'\n                 //   Property 'coordinates' does not exist on type\n                 //   'GeometryCollection'\n  }\n\n  return box;\n}\n```", "```\nconst {geometry} = f;\nif (geometry) {\n  if (geometry.type === 'GeometryCollection') {\n    throw new Error('GeometryCollections are not supported.');\n  }\n  helper(geometry.coordinates);  // OK\n}\n```", "```\nconst geometryHelper = (g: Geometry) => {\n  if (geometry.type === 'GeometryCollection') {\n    geometry.geometries.forEach(geometryHelper);\n  } else {\n    helper(geometry.coordinates);  // OK\n  }\n}\n\nconst {geometry} = f;\nif (geometry) {\n  geometryHelper(geometry);\n}\n```", "```\nquery {\n  repository(owner: \"Microsoft\", name: \"TypeScript\") {\n    createdAt\n    description\n  }\n}\n```", "```\n{\n  \"data\": {\n    \"repository\": {\n      \"createdAt\": \"2014-06-17T15:28:39Z\",\n      \"description\":\n        \"TypeScript is a superset of JavaScript that compiles to JavaScript.\"\n    }\n  }\n}\n```", "```\nquery getLicense($owner:String!, $name:String!){\n  repository(owner:$owner, name:$name) {\n    description\n    licenseInfo {\n      spdxId\n      name\n    }\n  }\n}\n```", "```\n$ apollo client:codegen \\\n    --endpoint https://api.github.com/graphql \\\n    --includes license.graphql \\\n    --target typescript\nLoading Apollo Project\nGenerating query files with 'typescript' target - wrote 2 files\n```", "```\nexport interface getLicense_repository_licenseInfo {\n  __typename: \"License\";\n  /** Short identifier specified by <https://spdx.org/licenses> */\n  spdxId: string | null;\n  /** The license full name specified by <https://spdx.org/licenses> */\n  name: string;\n}\n\nexport interface getLicense_repository {\n  __typename: \"Repository\";\n  /** The description of the repository. */\n  description: string | null;\n  /** The license associated with the repository */\n  licenseInfo: getLicense_repository_licenseInfo | null;\n}\n\nexport interface getLicense {\n  /** Lookup a given repository by the owner and repository name. */\n  repository: getLicense_repository | null;\n}\n\nexport interface getLicenseVariables {\n  owner: string;\n  name: string;\n}\n```", "```\ninterface Animal {\n  name: string;\n  endangered: boolean;\n  habitat: string;\n}\n\nconst leopard: Animal = {\n  name: 'Snow Leopard',\n  endangered: false,\n  habitat: 'tundra',\n};\n```", "```\ninterface Animal {\n  commonName: string;\n  genus: string;\n  species: string;\n  status: ConservationStatus;\n  climates: KoppenClimate[];\n}\ntype ConservationStatus = 'EX' | 'EW' | 'CR' | 'EN' | 'VU' | 'NT' | 'LC';\ntype KoppenClimate = |\n  'Af' | 'Am' | 'As' | 'Aw' |\n  'BSh' | 'BSk' | 'BWh' | 'BWk' |\n  'Cfa' | 'Cfb' | 'Cfc' | 'Csa' | 'Csb' | 'Csc' | 'Cwa' | 'Cwb' | 'Cwc' |\n  'Dfa' | 'Dfb' | 'Dfc' | 'Dfd' |\n  'Dsa' | 'Dsb' | 'Dsc' | 'Dwa' | 'Dwb' | 'Dwc' | 'Dwd' |\n  'EF' | 'ET';\nconst snowLeopard: Animal = {\n  commonName: 'Snow Leopard',\n  genus: 'Panthera',\n  species: 'Uncia',\n  status: 'VU',  // vulnerable\n  climates: ['ET', 'EF', 'Dfd'],  // alpine or subalpine\n};\n```", "```\ninterface Vector2D {\n  x: number;\n  y: number;\n}\nfunction calculateNorm(p: Vector2D) {\n  return Math.sqrt(p.x * p.x + p.y * p.y);\n}\n\ncalculateNorm({x: 3, y: 4});  // OK, result is 5\nconst vec3D = {x: 3, y: 4, z: 1};\ncalculateNorm(vec3D);  // OK! result is also 5\n```", "```\ninterface Vector2D {\n  _brand: '2d';\n  x: number;\n  y: number;\n}\nfunction vec2D(x: number, y: number): Vector2D {\n  return {x, y, _brand: '2d'};\n}\nfunction calculateNorm(p: Vector2D) {\n  return Math.sqrt(p.x * p.x + p.y * p.y);  // Same as before\n}\n\ncalculateNorm(vec2D(3, 4)); // OK, returns 5\nconst vec3D = {x: 3, y: 4, z: 1};\ncalculateNorm(vec3D);\n           // ~~~~~ Property '_brand' is missing in type...\n```", "```\ntype AbsolutePath = string & {_brand: 'abs'};\nfunction listAbsolutePath(path: AbsolutePath) {\n  // ...\n}\nfunction isAbsolutePath(path: string): path is AbsolutePath {\n  return path.startsWith('/');\n}\n```", "```\nfunction f(path: string) {\n  if (isAbsolutePath(path)) {\n    listAbsolutePath(path);\n  }\n  listAbsolutePath(path);\n                // ~~~~ Argument of type 'string' is not assignable\n                //      to parameter of type 'AbsolutePath'\n}\n```", "```\nfunction binarySearch<T>(xs: T[], x: T): boolean {\n  let low = 0, high = xs.length - 1;\n  while (high >= low) {\n    const mid = low + Math.floor((high - low) / 2);\n    const v = xs[mid];\n    if (v === x) return true;\n    [low, high] = x > v ? [mid + 1, high] : [low, mid - 1];\n  }\n  return false;\n}\n```", "```\ntype SortedList<T> = T[] & {_brand: 'sorted'};\n\nfunction isSorted<T>(xs: T[]): xs is SortedList<T> {\n  for (let i = 1; i < xs.length; i++) {\n    if (xs[i] > xs[i - 1]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction binarySearch<T>(xs: SortedList<T>, x: T): boolean {\n  // ...\n}\n```", "```\ntype Meters = number & {_brand: 'meters'};\ntype Seconds = number & {_brand: 'seconds'};\n\nconst meters = (m: number) => m as Meters;\nconst seconds = (s: number) => s as Seconds;\n\nconst oneKm = meters(1000);  // Type is Meters\nconst oneMin = seconds(60);  // Type is Seconds\n```", "```\nconst tenKm = oneKm * 10;  // Type is number\nconst v = oneKm / oneMin;  // Type is number\n```"]