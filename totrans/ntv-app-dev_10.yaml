- en: Chapter 9\. Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it’s certainly possible to have a largely self-contained app—perhaps it
    only makes HTTP requests to update its version using built-in, automagic Play
    update infrastructure—it’s rare in our connected world. Whether you need to authenticate
    users, post usage metrics to your analytics account, read content or media, download
    or upload files, listen for push notifications, or just sync up with a time server,
    you’ll want to know how to make an HTTP request and understand an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the HTTP spec has a very simple rules set, and most people find
    it easy to understand and learn. At the risk of being too simplistic, imagine
    an HTTP transaction consists of two parts: a request and a response. Both are
    represented as simple (and often human-readable) text files. The first line of
    each describes some basic attributes about the file (like the URL for a request,
    and the status for a response). The next lines are header information in traditional
    key-value-pair syntax: `header-name: Header Value`. Then a “blank” (empty) line,
    and you’re at the body. That’s it! For more info, check out [“HTTP Made Really
    Easy”](https://oreil.ly/Qh4ZZ).'
  prefs: []
  type: TYPE_NORMAL
- en: From high-level authentication protocols to streaming encrypted video data to
    uploading every image on your phone in the background, all of these operations
    use the same basic tenets described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Read and print a text file from a remote server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make an HTTP POST request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download a binary file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the fantastically open nature of Android development, some really terrific
    third-party libraries have come up around potentially complex tasks like networking.
    The most popular is probably OkHttp, developed by a well-known and trusted Android
    developer named Jake Wharton, who wrote a ton of great open source software while
    working for a company called Square and continues to contribute now directly from
    Google. If you check the links in the notes block at the end of this Android section,
    you’ll see a disproportionate number of links are from Square’s GitHub account.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that any time you’re dealing with anything other than main memory (RAM),
    you should probably be working on a background thread. Reading a local file, querying
    a database, and even saving preferences should all happen off the main UI thread.
    *This is especially important when dealing with network requests and responses*.
    Imagine that a small file probably only takes a few milliseconds to touch, open,
    read, close, and convert to a `String` value—but even that few milliseconds can
    make the fling of a `RecyclerView` stutter or a `NavigationDrawer` seem to open
    fully and immediately. Now, imagine this along the lines of a network request.
    I’m sure we’ve all seen requests that take 10 seconds or 20 seconds or even longer
    to resolve—some servers won’t even timeout for a minute! Imagine blocking the
    drawing thread that whole time with a spinning for loop just waiting for data.
    *When preforming network operations, in almost all cases, you should be working
    on a background thread*.
  prefs: []
  type: TYPE_NORMAL
- en: Read and Print a Text File on a Remote Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'That said, making a network request with straight Java is really not that complicated—here
    are six lines (just counting statements) of magic that’ll print out any publicly
    accessible remote file:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break this down line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a `URL` instance. A `URL` instance represents a *resource*, not
    the *location* of that resource, despite the name. The location is most accurately
    represented by the `String` passed in to the `URL` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: By upping our game from `String` to `URL`, we get a ton of standard library
    goodies out of the box—like an `HttpUrlConnection` via the `openConnection` method.
    While there’s a lot that can be done with the connection, the most straightforward
    thing we can do with it happens on the next few lines—grab its `InputStream` and
    read it out! This may look a lot like how we dealt with stream data back in the
    [Chapter 6](ch06.html#topics_files) section—check that out for a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! Pretty simple, right? Well, let’s dress it up a little.
  prefs: []
  type: TYPE_NORMAL
- en: Make an HTTP POST Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll make use of the publicly available *jsonplaceholder.typicode.com* free
    service to emulate POSTing data so that we can see that our code really is sending
    up data that we can read back out later. We’ll use the [Create A Resource](https://oreil.ly/2iZxz)
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our reader example with a simple, empty post:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closely, you’ll see only a couple very minor things changed:'
  prefs: []
  type: TYPE_NORMAL
- en: We cast the return of `openConnection` to `HttpsUrlConnection`, rather than
    `HttpUrlConnection`, simply because the location used the HTTPS scheme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the request method of the connection to POST, instead of the default,
    GET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While this does in fact work and your output should give you some new ID for
    the object you created, there’s not a lot more going on. In a slightly closer
    to real-life example, we’d probably want to add some data to the request. This
    might happen in the form of query parameters, headers, or the post body. For this
    service, we’ll use a JSON post body.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the connection object has a built-in `InputStream` to read from, it
    also handily has an `OutputStream` to write to. However, that requires a little
    extra housekeeping—we have to call `connection.setDoOutput(true)` in order to
    be able to write to that `OutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the example again:'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re sending some data that the server can handle however it likes. Again,
    with each extension of functionality, there’s a little more work and a little
    more consideration required, but if you start at the fundamentals (the first example),
    you can get a pretty good idea of how the whole thing works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers will find that when working with networking libraries, a lot of
    the work is very similar, even if the libraries use dramatically different operations
    behind the scenes. When we first wrote our binary downloader for my current employer,
    I used all standard libraries. Later, we wanted to use a single HTTP client for
    all our network requests (images, REST, downloads, etc), so I sat down with a
    cup o’ joe and planned on spending the afternoon refitting our downloader to work
    with OkHttp. I don’t remember exactly how long it took, or exactly how many lines
    where changed, but I’ll say I was writing tests by lunch and in QA before EOD
    (read: it was a simple task).'
  prefs: []
  type: TYPE_NORMAL
- en: Download a Binary File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll combine the information presented so far with some of the things we learned
    in [Chapter 6](ch06.html#topics_files) to download a binary file. Don’t worry,
    it’s not a heck of a lot different from what we’ve already done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the URL to the header image I use on my personal site: *[*http://moagrius.com/assets/images/hero-trips.png*](http://moagrius.com/assets/images/hero-trips.png)*.
    It’s just an image, but it is binary data—the same logic would work for a video
    or an executable, or even just a couple bits of arbitrary binary data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s think what we’ll need to do differently. We know we’ll get back an `InputStream`
    with the bytes that make up the image, so what do we do with them? Well, if we
    remember the lessons in [Chapter 6](ch06.html#topics_files) on files, we know
    we’ll want a `FileOutputStream` on our local device to save those bytes to. That’s
    really about the only difference! Let’s give it a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: After running this method, you should find a fully decoded, visually accurate
    copy of the file on my site—congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Networking really includes a lot more than we can cover in this chapter, but
    we’ll point you in the right direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[OkHttp](https://oreil.ly/_Lk9z) and [Volley](https://oreil.ly/1fSIz) both
    provide additional networking APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Picasso](https://oreil.ly/0VyGt), [Glide](https://oreil.ly/_D3HE), and [Volley](https://oreil.ly/2gaY5)
    all offer very simple APIs for loading and displaying remote images, combining
    the network, and decoding layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Gson](https://oreil.ly/RRhOS) and [Jackson](https://oreil.ly/e95wK) are great
    JSON parsers for reading from REST APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Retrofit](https://oreil.ly/lT-5Z) combines OkHttp for the network request
    and Gson for JSON parsing to allow for some simple API readers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking has historically been a strength of macOS and, in turn, iOS. The
    suite of objects purpose-built and provided by the system are comprehensive and
    well thought out. In fact, most of the third-party networking libraries available
    sit lightly on top of the classes provided by the operating system. There are
    some very strong choices available, Alamofire for one, but for a large percentage
    of apps the built-in tools are the best choice. As such, in this chapter, we’ll
    use those very objects to demonstrate the powerful tools available right at your
    fingertips within iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in!
  prefs: []
  type: TYPE_NORMAL
- en: Read and Print a Text File on a Remote Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading data from a web server somewhere in the world is, at its root, the
    simplest thing you can do with networking. In iOS, you can request information
    from a server with the following naive example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through what’s happening here.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a `URL` that points to a specific file, website, or API—the
    O’Reilly Media homepage in this example. Next, we use a shared `URLSession` object
    to generate a `URLSessionDataTask` for our URL and give it a completion handler
    as a trailing closure. Inside the completion handler, we convert the raw data
    (passed in as a `Data` object) to a `String` instance and then `print` that data,
    which just happens to be the HTML normally displayed by a web browser. Finally,
    we call `resume()` on the task that was created to kickstart the whole process.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might notice in the example code we’re using an HTTPS URL. Since iOS 9,
    all HTTP requests need to be HTTPS, unless they are explicitly allowed (or fully
    disabled) within an app’s *Info.plist* file via the `NSAppTransportSecurity` key.
  prefs: []
  type: TYPE_NORMAL
- en: There are some new classes that have shown up in this example. The first of
    these new classes is `URLSession`. This is the class that drives most of the functionality
    within the top-level networking APIs within iOS. At its most basic function, each
    `URLSession` is a coordinator of different network tasks; the tasks are associated
    directly with a `URLSession` object during creation. The session objects themselves
    can have their behavior configured by passing in a `URLSessionConfiguration` object
    in the initializer. You can create multiple sessions or, for simple needs, just
    use the shared session that is accessible by the aptly named `URLSession.shared`
    property as used previously.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`URLSession` instances can be configured in a variety of ways. `URLSessionConfiguration`
    also has some standard configurations provided for convenience. These include
    `default`, `ephemeral`, and `background(with:)`. Check out the [Apple developer
    docs](https://oreil.ly/_ldvZ) for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: A `URLSession` instance is the originator of the tasks too. It’s easy to think
    of a network task as an operation; they provide all the actual functionality of
    a network request and response. Like operations, they also typically run asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`URLSessionDataTask`, which is used for receiving data (returned as a `Data`
    object) from a server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URLSessionDownloadTask`, which is primarily used for retrieving files from
    a server and can be paused and resumed, as well as provide updates on download
    progress (this will be covered later in the chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URLSessionUploadTask`, which *sends* data or files to a server (this is covered
    in the next section in this chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to know when to use one task over another. Rarely would a developer
    use a data task to download a large file. In addition, it would be unwise (and
    quite cumbersome) to use a download task to receive a simple JSON response from
    an endpoint. Tasks are specialized to make your job, as a developer, easier and
    the logic simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the preceding example is somewhat sparse and a bit naive in its approach.
    Here is a much fuller and complete example that checks for any client errors,
    for valid server response status codes, and for empty data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Receiving data from a server is useful, and certainly the majority of network
    calls made are requests for data. However, if you spend any time with a REST API,
    you’ll quickly need to learn how to send data as well as receive data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how it works in iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Make an HTTP POST Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to get started sending data to the server is to send a bit
    of text to a URL. This can be accomplished with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple example, but usually data that we wanted to send to a server
    isn’t unstructured text strings. Often it’s JSON or key-value form data. Luckily,
    there is a helpful object one can use called `URLComponents` to create a percent-encoded
    key-value data string from a set of values. You can use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an instance of `URLComponents`. Next, we add query items to
    the `queryItems` property that consist of key-value objects of the type `URLQueryItem`.
    These objects are then transformed into a percent-encoded text string whenever
    the `httpBody` property is assigned to the `URLRequest` created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often we might want to send more than just key-value data, though. Here is
    an example of how a file might be uploaded to a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Walking through this code, we first create a string of data representing our
    mock file, “file data,” that is converted to a `Data` object in preparation for
    being sent later. Next, we define a URL pointing to *http://www.example.com* as
    a placeholder. This is then passed to a new object type called `URLRequest` that
    we used in our simple `POST` example. A `URLRequest` is an abstraction of the
    request we are making. It’s done this way so we can specify some changes to the
    way we are sending this request to the server. In the preceding example, we’re
    specifying the HTTP method used: `POST`. This maps directly to the standard REST
    verbs available, with the default being `GET`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, within this example, similar to our examples in the previous section,
    we are creating a `URLSessionTask` using the shared URL session; in this case,
    however, we are creating a `URLSessionUploadTask` with the `uploadTask` method.
    To kick off the task and perform the request, we call `resume()` to send the `data`
    object passed in off to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple example. It’s likely data will be returned from the server
    about the request sent, including information about whether the outcome was successful
    or if it failed. However, it’s possible to keep the simplicity of this example
    by using an overloaded method of `uploadTask` to pass in a completion handler
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Most modern APIs take structured data, like JSON, as input and return JSON
    as output. Our simplistic string of data example actually scales somewhat easily
    without changing much except creating a structure to provide the structure for
    our data. Here’s a complete example of how to post JSON up to an endpoint and
    handle the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That’s a big example, but if you look closely, there are really only a few lines
    that have changed much. First, at the top of the example, we’re defining a structure
    to hold our data. Soon after, we use `JSONEncoder` to transform this object into
    a raw `Data` object. `JSONEncoder` is part of the Swift Standard Library and provides
    an easy-to-use method to serialize and deserialize JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a whole chapter dedicated to “transport data” like JSON. You can check
    it out for more information about functionality and available methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important change to note is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This command sets the HTTP header `Content-Type` on the request to equal `application/json`.
    You can set other HTTP headers this way, but for most APIs, you’ll need to specify
    explicitly if you’re using JSON as the transport structure for the data you’re
    sending.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the preceding example probably looks familiar when compared with
    the other examples until you dive into the completion handler used. We perform
    some validation checks for client errors, server errors, or missing data. Then,
    we use a new object type, `JSONDecoder`, to take the raw `data` object returned
    (which is really just JSON) and deserialize it directly into an instance of `Book`.
    From there, we do things like `print`ing the book’s `title` and `isbn` properties
    out to the command line.
  prefs: []
  type: TYPE_NORMAL
- en: There are similarities and patterns in most network operations within the `URLSession`
    library of objects. Downloading files from a server requires additional logic
    to handle a slightly different set of requirements, however. Let’s see how this
    plays out in the next section on downloading binary files.
  prefs: []
  type: TYPE_NORMAL
- en: Download a Binary File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Downloading files is similar, in code, to requesting data from a server. Here’s
    an example of how to execute a download request from a server to retrieve a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are requesting a file at a specific URL. One main
    difference is that instead of using `dataTask(with:)` to create our request, we’re
    using `downloadTask(with:)`. The completion handler has a slightly different signature—instead
    of a `Data` instance being passed in, we have a `Url` instance passed in that
    we’ve named `fileUrl` in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Download tasks differ from data tasks in that while data tasks store the content
    of the request in memory, download tasks store a buffer of the response into a
    temporary file as the download completes. For short downloads, this could be instantaneous,
    but for larger downloads, the task writes a little bit of the file at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Our completion handler is executed whenever the file is finished downloading
    and contains the temporary location where that file was written. These files are
    ephemeral in nature and will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s important to remember to move the file somewhere else, such as the *Documents*
    directory. Our previous example just `print`s the path of the file. See [Chapter 6](ch06.html#topics_files)
    on file basics for information on how to copy a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For larger downloads, it’s generally preferable to present some type of user
    interface to your users indicating how much of the file has been downloaded and
    how much is left. Our simplistic completion handler example doesn’t provide a
    mechanism to do that. Within the `URLSession` subsystem, however, there is a way
    to handle this: the `URLSessionDownloadDelegate` protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: URLSessionDownloadDelegate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`URLSessionDownloadDelegate` contains a few optional methods for objects to
    implement in order to handle download events for a request as they come in. Here’s
    an example of how to implement a delegate, assign it to a `URLSession`, and create
    a download task, complete with progress updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through this code.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are creating a new class called `NetworkClient` that inherits from
    `NSObject`, the base class for Objective-C objects. This class has an extension
    where it implements the `URLSessionDownloadDelegate` protocol. The first method,
    `urlSession(_:downloadTask:didFinishDownloadingTo:)`, is required. This is because
    download tasks store the files they download as temporary files in the filesystem;
    whenever a file finishes downloading, this method is called on the delegate to
    tell you where to access the downloaded file. We can also handle server errors
    in the body of this method by checking the `downloadTask`’s `response` object’s
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: The next method, `urlSession(_:task:didCompleteWithError:)`, is optional, but
    probably something that should be implemented in production apps. You can handle
    client errors here and check if there are issues that came up that prevented the
    file from being downloaded successfully. In our example, we’re printing out a
    description of the error to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wondering how the progress of the download is communicated to the app? The
    final method in the extension is the place to look: `urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)`.
    This method is called periodically at an interval determined by the networking
    subsystems within iOS. We can use the values of `totalBytesWritten` and `totalBytesExpectedToWrite`
    to calculate a `percent` value. This value could be used to update everything
    from text labels to custom drawing routines to `UIProgressView`s. In our example,
    we’re `print`ing out the value to the console, but use your imagination to see
    what’s possible!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This class we’ve created is instantiated further down and passed to a custom
    `URLSession` initializer as the `delegate` argument. It’s important to note the
    following two lines where this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we create the `URLSession` instance. In the next line, we use that object
    to create the `downloadTask` for the given URL. We are *not* using the `URLSession.shared`
    instance that previous examples have been using. This is because we need to have
    some place to set the delegate, and in `URLSession`, that’s in the initializer.
  prefs: []
  type: TYPE_NORMAL
- en: Pause and resume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With long-running downloads, progress updates are not the only desirable thing
    your users might need. It’s possible partially completed downloads can fail. Or,
    maybe your user wants to pause the download and resume it mid-process in order
    to switch to a WiFi network. Whatever the case, pausing and resuming using `URLSession`
    is possible, but a bit odd to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check out an example and then discuss what’s going on after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have a class, `PauseableClient`, that has three methods:
    `startDownload()`, `pauseDownload()`, and `resumeDownload()`. Inside the first
    of these, `startDownload()`, we kick off a download task with a URL. Presumably,
    this is a long-running download. We also return the `task` object created for
    use later. Further down the screen, we call `startDownload()`, and the client’s
    `pauseDownload(for:)` method is called and the `task` is passed in.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `pauseDownload()` method, we take the `task` object passed in and
    call `cancel(byProducingResumeData:)`. This method takes a closure as its only
    argument. Once the task is canceled, the closure is called and a token, given
    as a `Data` instance, used for resuming the download is passed in. Storing this
    token for future use allows the code to potentially resume the download again
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can potentially store resume data if there are client errors reported in
    the `urlSession(_:task:didCompleteWithError:)` delegate method. Check `userInfo[NSURLSessionDownloadTaskResumeData]`
    on the `error` object passed in as a parameter. Now, there are limitations about
    where resume data can be generated. For more information on these, it’s best to
    the consult [Apple’s developer docs](https://oreil.ly/GITHH) on `URLSessionTask`.
  prefs: []
  type: TYPE_NORMAL
- en: For all intents and purposes, the task we created to download the file is gone
    at this point. Calling `cancel` doesn’t actually pause the download—it *cancels*
    it. That said, we’ve got a way to bring this request back to life without having
    to redownload the data we’ve already received.
  prefs: []
  type: TYPE_NORMAL
- en: This is done in our example within the `resumeDownload()` method. This method
    checks for resume data and then calls `URLSession` to create a new `URLSessionDownloadTask`
    via the method `downloadTask(withResumeData:)`. The resume data passed in is the
    same `resumeData` that was saved in `pauseDownload(for:)` by our previous task.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once this task is created from the `URLSession`, `resume()` is called
    to kick off the download again, hopefully at the previous completion state it
    was in whenever we paused it (or canceled it) before.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are even more delegates and delegate methods in the `URLSession` subsystem
    than demonstrated in the code in this chapter. Objects should also implement some
    or all of the methods in the `URLSessionTaskDelegate`, `URLSessionDataDelegate`,
    or `URLSessionDownloadDelegate` protocols to handle task-level events. These include
    events like the beginning and end of individual requests, and periodic progress
    updates from data or download tasks similar to what was shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Background threads and updating the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`URLSessionTask` operates on its own background threads asynchronously without
    blocking the current thread without having to specify anything special. However,
    closures being called will not return on the main thread, so it’s important to
    dispatch any UI updates or model synchronization code on the main thread (or using
    whatever synchronization methods are used in other parts of your app).'
  prefs: []
  type: TYPE_NORMAL
- en: App transport security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To call nonsecure URLs such as ones that start with *http://*, it’s necessary
    to specify a special configuration in an app’s *Info.plist* file for the `NSAppTransportSecurity`
    key. The recommendation is to specify that certain domains are insecure but trusted
    by excluding them using the key `NSExceptionDomains`. It’s possible to turn off
    App Transport Security altogether by setting its `NSAllowsArbitraryLoads` key
    to `true`, but that is not a recommended approach unless absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: What We’ve Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve learned a lot about how networking functions in both Android and iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to make a simple request in both platforms. The processes for
    both were similar, but differed in the use of streams for Android.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to send data up to a server in a way that allowed the developer
    full control of the request and response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We talked about the nature of downloading binary files and what kind of processing
    was necessary to store them to the filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security controls embedded into iOS requires the use of HTTPS by default. This
    is in contrast to Android, which is a little more freewheeling, open, and less
    restrictive with regard to the defaults for networking security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oftentimes networks are unavailable or requests fail. In the next chapter, we’ll
    look at providing users feedback when issues crop up or you just want to keep
    them informed of some other operation happening. Let’s head over!
  prefs: []
  type: TYPE_NORMAL
