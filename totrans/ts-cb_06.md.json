["```\ntype StringLabel = {\n  name: string;\n};\n\ntype NumberLabel = {\n  id: number;\n};\n```", "```\nfunction createLabel(input: number | string): NumberLabel | StringLabel {\n  if (typeof input === \"number\") {\n    return { id: input };\n  } else {\n    return { name: input };\n  }\n}\n```", "```\nfunction createLabel(input: number): NumberLabel;\nfunction createLabel(input: string): StringLabel;\nfunction createLabel(input: number | string): NumberLabel | StringLabel {\n  if (typeof input === \"number\") {\n    return { id: input };\n  } else {\n    return { name: input };\n  }\n}\n```", "```\nfunction inputToLabel(input: string | number) {\n  return createLabel(input);\n  //                    ^\n  // No overload matches this call. (2769)\n}\n```", "```\nfunction createLabel(input: number): NumberLabel;\nfunction createLabel(input: string): StringLabel;\nfunction createLabel(input: number | string): NumberLabel | StringLabel;\nfunction createLabel(input: number | string): NumberLabel | StringLabel {\n  if (typeof input === \"number\") {\n    return { id: input };\n  } else {\n    return { name: input };\n  }\n}\n```", "```\nfunction createLabel(input: number): NumberLabel;\nfunction createLabel(input: string): StringLabel;\nfunction createLabel(input: StringLabel): StringLabel;\nfunction createLabel(input: NumberLabel): NumberLabel;\nfunction createLabel(input: string | StringLabel): StringLabel;\nfunction createLabel(input: number | NumberLabel): NumberLabel;\nfunction createLabel(\n  input: number | string | StringLabel | NumberLabel\n): NumberLabel | StringLabel;\nfunction createLabel(\n  input: number | string | StringLabel | NumberLabel\n): NumberLabel | StringLabel {\n  if (typeof input === \"number\") {\n    return { id: input };\n  } else if (typeof input === \"string\") {\n    return { name: input };\n  } else if (\"id\" in input) {\n    return { id: input.id };\n  } else {\n    return { name: input.name };\n  }\n}\n```", "```\ntype IsString<T> = T extends string ? T : never;\n\ntype A = IsString<string>; // string\ntype B = IsString<\"hello\" | \"world\">; // string\ntype C = IsString<1000>; // never\n```", "```\ntype GetLabel<T> = T extends string | StringLabel ? StringLabel : NumberLabel;\n```", "```\ntype GetLabel<T> = T extends string | StringLabel\n  ? StringLabel\n  : T extends number | NumberLabel\n  ? NumberLabel\n  : never;\n```", "```\nfunction createLabel<T extends number | string | StringLabel | NumberLabel>(\n  input: T\n): GetLabel<T> {\n  if (typeof input === \"number\") {\n    return { id: input } as GetLabel<T>;\n  } else if (typeof input === \"string\") {\n    return { name: input } as GetLabel<T>;\n  } else if (\"id\" in input) {\n    return { id: input.id } as GetLabel<T>;\n  } else {\n    return { name: input.name } as GetLabel<T>;\n  }\n}\n```", "```\nfunction createLabel<T extends number | string | StringLabel | NumberLabel>(\n  input: T\n): GetLabel<T>;\nfunction createLabel(\n  input: number | string | StringLabel | NumberLabel\n): NumberLabel | StringLabel {\n  if (typeof input === \"number\") {\n    return { id: input };\n  } else if (typeof input === \"string\") {\n    return { name: input };\n  } else if (\"id\" in input) {\n    return { id: input.id };\n  } else {\n    return { name: input.name };\n  }\n}\n```", "```\ntype ElementList = {\n  addClass: (className: string) => ElementList;\n  removeClass: (className: string) => ElementList;\n  on: (event: string, callback: (ev: Event) => void) => ElementList;\n  length: number;\n  [x: number]: HTMLElement;\n};\n```", "```\n// begin excerpt\n  addClass: function (className: string): ElementList {\n    for (let i = 0; i < this.length; i++) {\n      this[i].classList.add(className);\n    }\n    return this;\n  },\n  removeClass: function (className: string): ElementList {\n    for (let i = 0; i < this.length; i++) {\n      this[i].classList.remove(className);\n    }\n    return this;\n  },\n  on: function (event: string, callback: (ev: Event) => void): ElementList {\n    for (let i = 0; i < this.length; i++) {\n      this[i].addEventListener(event, callback);\n    }\n    return this;\n  },\n// end excerpt\n```", "```\ndeclare const myCollection: ElementList;\n\nmyCollection\n  .addClass(\"toggle-off\")\n  .removeClass(\"toggle-on\")\n  .on(\"click\", (e) => {});\n```", "```\nmyCollection[1].classList.toggle(\"toggle-on\");\n```", "```\nconst safeAccessCollection = new Proxy(myCollection, {\n  get(target, property) {\n    if (\n      typeof property === \"string\" &&\n      property in target &&\n      \"\" + parseInt(property) !== property\n    ) {\n      return target[property as keyof typeof target];\n    }\n    return undefined;\n  },\n});\n```", "```\n// Works in TypeScript throws in JavaScript\nsafeAccessCollection[0].classList.toggle(\"toggle-on\");\n```", "```\n// resolves to \"addClass\" | \"removeClass\" | \"on\" | \"length\" | number\ntype ElementListKeys = keyof ElementList;\n```", "```\ntype JustStrings<T> = T extends string ? T : never;\n```", "```\ntype JustElementListStrings =\n  | \"addClass\" extends string ? \"addClass\" : never\n  | \"removeClass\" extends string ? \"removeClass\" : never\n  | \"on\" extends string ? \"on\" : never\n  | \"length\" extends string ? \"length\" : never\n  | number extends string ? number : never;\n```", "```\ntype JustElementListStrings =\n  | \"addClass\"\n  | \"removeClass\"\n  | \"on\"\n  | \"length\"\n  | never;\n```", "```\ntype JustElementListStrings =\n  | \"addClass\"\n  | \"removeClass\"\n  | \"on\"\n  | \"length\";\n```", "```\ntype SafeAccess = Pick<ElementList, JustStrings<keyof ElementList>>;\n```", "```\ntype SafeAccess = {\n  addClass: (className: string) => ElementList;\n  removeClass: (className: string) => ElementList;\n  on: (event: string, callback: (ev: Event) => void) => ElementList;\n  length: number;\n};\n```", "```\nconst safeAccessCollection: Pick<\n  ElementList,\n  JustStrings<keyof ElementList>\n> = new Proxy(myCollection, {\n  get(target, property) {\n    if (\n      typeof property === \"string\" &&\n      property in target &&\n      \"\" + parseInt(property) !== property\n    ) {\n      return target[property as keyof typeof target];\n    }\n    return undefined;\n  },\n});\n```", "```\nsafeAccessCollection[1].classList.toggle(\"toggle-on\");\n// ^ Element implicitly has an 'any' type because expression of\n// type '1' can't be used to index type\n// 'Pick<ElementList, \"addClass\" | \"removeClass\" | \"on\" | \"length\">'.\n```", "```\ntype ToyBase = {\n  name: string;\n  description: string;\n  minimumAge: number;\n};\n\ntype BoardGame = ToyBase & {\n  kind: \"boardgame\";\n  players: number;\n};\n\ntype Puzzle = ToyBase & {\n  kind: \"puzzle\";\n  pieces: number;\n};\n\ntype Doll = ToyBase & {\n  kind: \"doll\";\n  material: \"plush\" | \"plastic\";\n};\n\ntype Toy = Doll | Puzzle | BoardGame;\n```", "```\ntype GroupedToys = {\n  [k in Toy[\"kind\"]]?: Toy[];\n};\n```", "```\ntype Group<\n  Collection extends Record<string, any>,\n  Selector extends keyof Collection\n> = {\n  [K in Collection[Selector]]: Collection[];\n};\n\ntype GroupedToys = Partial<Group<Toy, \"kind\">>;\n```", "```\ntype GroupedToys = {\n  boardgame?: Toy[] | undefined;\n  puzzle?: Toy[] | undefined;\n  doll?: Toy[] | undefined;\n};\n```", "```\ntype GroupedToys = {\n  boardgame?: BoardGame[] | undefined;\n  puzzle?: Puzzle[] | undefined;\n  doll?: Doll[] | undefined;\n};\n```", "```\ntype Extract<T, U> = T extends U ? T : never;\n```", "```\ntype ExtractedDoll = Extract<Toy, { kind: \"doll\" }>;\n```", "```\ntype ExtractedDoll =\n  BoardGame extends { kind: \"doll\" } ? BoardGame : never |\n  Puzzle extends { kind: \"doll\" } ? Puzzle : never |\n  Doll extends { kind: \"doll\" } ? Doll : never;\n```", "```\ntype ExtractedDoll = never | never | Doll;\n```", "```\ntype ExtractedDoll = Doll;\n```", "```\ntype Group<\n  Collection extends Record<string, any>,\n  Selector extends keyof Collection\n> = {\n  [K in Collection[Selector]]: Extract<Collection, { [P in Selector]: K }>[];\n};\n```", "```\ntype GroupedToys = Partial<Group<Toy, \"kind\">>;\n// resolves to:\ntype GroupedToys = {\n  boardgame?: BoardGame[] | undefined;\n  puzzle?: Puzzle[] | undefined;\n  doll?: Doll[] | undefined;\n};\n```", "```\nfunction groupToys(toys: Toy[]): GroupedToys {\n  const groups: GroupedToys = {};\n  for (let toy of toys) {\n    groups[toy.kind] = groups[toy.kind] ?? [];\n//  ^ Type 'BoardGame[] | Doll[] | Puzzle[]' is not assignable to\n//    type '(BoardGame[] & Puzzle[] & Doll[]) | undefined'. (2322)\n    groups[toy.kind]?.push(toy);\n//                         ^\n//  Argument of type 'Toy' is not assignable to\n//  parameter of type 'never'.  (2345)\n  }\n  return groups;\n}\n```", "```\nfunction groupToys(toys: Toy[]): GroupedToys {\n  const groups: GroupedToys = {};\n  for (let toy of toys) {\n    switch (toy.kind) {\n      case \"boardgame\":\n        groups[toy.kind] = groups[toy.kind] ?? [];\n        groups[toy.kind]?.push(toy);\n        break;\n      case \"doll\":\n        groups[toy.kind] = groups[toy.kind] ?? [];\n        groups[toy.kind]?.push(toy);\n        break;\n      case \"puzzle\":\n        groups[toy.kind] = groups[toy.kind] ?? [];\n        groups[toy.kind]?.push(toy);\n        break;\n    }\n  }\n  return groups;\n}\n```", "```\nfunction groupToys(toys: Toy[]): GroupedToys {\n  const groups: GroupedToys = {};\n  for (let toy of toys) {\n    (groups[toy.kind] as Toy[]) = groups[toy.kind] ?? [];\n    (groups[toy.kind] as Toy[])?.push(toy);\n  }\n  return groups;\n}\n```", "```\nfunction groupToys(toys: Toy[]): GroupedToys {\n  const groups: GroupedToys = {};\n  for (let toy of toys) {\n    assign(groups, toy.kind, toy);\n  }\n  return groups;\n}\n\nfunction assign<T extends Record<string, K[]>, K>(\n  groups: T,\n  key: keyof T,\n  value: K\n) {\n  // Initialize when not available\n  groups[key] = groups[key] ?? [];\n  groups[key]?.push(value);\n}\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n  profession?: string;\n};\n```", "```\ntype PersonStrings = {\n  name: string;\n  profession?: string;\n};\n```", "```\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n}\n\n// Only includes \"name\"\ntype PersonName = Pick<Person, \"name\">;\n\n// Includes \"name\" and \"profession\"\ntype PersonStrings = Pick<Person, \"name\" | \"profession\">;\n```", "```\ntype Omit<T, K extends string | number | symbol> = {\n  [P in Exclude<keyof T, K>]: T[P];\n}\n\n// Omits age, thus includes \"name\" and \"profession\"\ntype PersonWithoutAge = Omit<Person, \"age\">;\n```", "```\n// Not there yet\ntype PersonStrings = {\n  [K in keyof Person]: Person[K] extends string ? Person[K] : never;\n};\n```", "```\ntype PersonStrings = {\n  [K in keyof Person as Person[K] extends string ? K : never]: Person[K];\n};\n```", "```\ntype PersonStrings = {\n  [K in keyof Person as Person[K] extends string | undefined\n    ? K\n    : never]: Person[K];\n};\n```", "```\ntype Select<O, T> = {\n  [K in keyof O as O[K] extends T | undefined ? K : never]: O[K];\n};\n```", "```\ntype PersonStrings = Select<Person, string>;\ntype PersonNumbers = Select<Person, number>;\n```", "```\ntype StringFnsReturningNumber = Select<String, (...args: any[]) => number>;\n```", "```\ntype Remove<O, T> = {\n  [K in keyof O as O[K] extends T | undefined ? never : K]: O[K];\n};\n\ntype PersonWithoutStrings = Remove<Person, string>;\n```", "```\ntype User = {\n  name: string;\n  age: number;\n  profession?: string;\n  posts(): string[];\n  greeting(): string;\n};\n\ntype SerializeableUser = Remove<User, Function>;\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n  hello: () => string;\n};\n```", "```\nclass Serializer {\n  constructor() {}\n  serialize<T>(obj: T): Serialize<T> {\n    // tbd...\n  }\n}\n```", "```\ntype Remove<O, T> = {\n  [K in keyof O as O[K] extends T | undefined ? never : K]: O[K];\n};\n\ntype Serialize<T> = Remove<T, Function>;\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n  profession: {\n    title: string;\n    level: number;\n    printProfession: () => void;\n  };\n  hello: () => string;\n};\n```", "```\ntype NestSerialization<T> = {\n  [K in keyof T]: T[K] extends object ? Serialize<T[K]> : T[K];\n};\n```", "```\ntype Serialize<T> = NestSerialization<Remove<T, Function>>;\n```", "```\nclass Serializer {\n  constructor() {}\n  serialize<T>(obj: T): Serialize<T> {\n    const ret: Record<string, any> = {};\n\n    for (let k in obj) {\n      if (typeof obj[k] === \"object\") {\n        ret[k] = this.serialize(obj[k]);\n      } else if (typeof obj[k] !== \"function\") {\n        ret[k] = obj[k];\n      }\n    }\n    return ret as Serialize<T>;\n  }\n}\n```", "```\nconst person: Person = {\n  name: \"Stefan\",\n  age: 40,\n  profession: {\n    title: \"Software Developer\",\n    level: 5,\n    printProfession() {\n      console.log(`${this.title}, Level ${this.level}`);\n    },\n  },\n  hello() {\n    return `Hello ${this.name}`;\n  },\n};\n\nconst serializer = new Serializer();\nconst serializedPerson = serializer.serialize(person);\nconsole.log(serializedPerson);\n```", "```\n[LOG]: {\n  \"name\": \"Stefan\",\n  \"age\": 40,\n  \"profession\": {\n    \"title\": \"Software Developer\",\n    \"level\": 5\n  }\n}\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n  profession: {\n    title: string;\n    level: number;\n    printProfession: () => void;\n  };\n  hello: () => string;\n  serialize: () => string;\n};\n\nconst person: Person = {\n  name: \"Stefan\",\n  age: 40,\n  profession: {\n    title: \"Software Developer\",\n    level: 5,\n    printProfession() {\n      console.log(`${this.title}, Level ${this.level}`);\n    },\n  },\n  hello() {\n    return `Hello ${this.name}`;\n  },\n  serialize() {\n    return `${this.name}: ${this.profession.title} L${this.profession.level}`;\n  },\n};\n```", "```\ntype Serialize<T> = T extends { serialize(): infer R }\n  ? R\n  : NestSerialization<Remove<T, Function>>;\n```", "```\nclass Serializer {\n  constructor() {}\n  serialize<T>(obj: T): Serialize<T> {\n    if (\n      // is an object\n      typeof obj === \"object\" &&\n      // not null\n      obj &&\n      // serialize is available\n      \"serialize\" in obj &&\n      // and a function\n      typeof obj.serialize === \"function\"\n    ) {\n      return obj.serialize();\n    }\n\n    const ret: Record<string, any> = {};\n\n    for (let k in obj) {\n      if (typeof obj[k] === \"object\") {\n        ret[k] = this.serialize(obj[k]);\n      } else if (typeof obj[k] !== \"function\") {\n        ret[k] = obj[k];\n      }\n    }\n    return ret as Serialize<T>;\n  }\n}\n```", "```\n[LOG]: \"Stefan: Software Developer L5\"\n```"]