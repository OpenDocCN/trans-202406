- en: 'Chapter 17\. Make a Connection: Networking and Threads'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0587-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Connect with the outside world.** Your Java program can talk to a program
    on another machine. It’s easy. All the low-level networking details are taken
    care of by the built-in Java libraries. One of Java’s big benefits is that sending
    and receiving data over a network can be just I/O with a slightly different connection
    at the end of the I/O chain. In this chapter we’ll connect to the outside world
    with *channels*. We’ll make *client* channels. We’ll make *server* channels. We’ll
    make *clients* and *servers*, and we’ll make them talk to each other. And we’ll
    also have to learn how to do more than one thing at once. Before the chapter’s
    done, you’ll have a fully functional, multithreaded chat client. Did we just say
    *multithreaded*? Yes, now you *will* learn the secret of how to talk to Bob while
    simultaneously listening to Suzy.'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time BeatBox chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0588-01.png)![image](Images/f0588-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You’re working on a computer game. You and your team are doing the sound design
    for each part of the game. Using a “chat” version of the BeatBox, your team can
    collaborate—you can send a beat pattern along with your chat message, and everybody
    in the BeatBox Chat gets it. So you don’t just get to *read* the other participants’
    messages; you get to load and *play* a beat pattern simply by clicking the message
    in the incoming messages area.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’re going to learn what it takes to make a chat client like
    this. We’re even going to learn a little about making a chat *server*. We’ll save
    the full BeatBox Chat for the Code Kitchen, but in this chapter you *will* write
    a Ludicrously Simple Chat Client and Very Simple Chat Server that send and receive
    text messages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chat program overview**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each Client has to know about the Server.
  prefs: []
  type: TYPE_NORMAL
- en: The Server has to know about ALL the Clients.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0589-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**How it works:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circle.png) Client connects to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0589-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2circle.png) The server makes a connection and adds the client
    to the list of participants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0589-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3circle.png) Another client connects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0589-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4circle.png) Client A sends a message to the chat service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0589-05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/5circle.png) The server distributes the message to ALL participants
    (including the original sender)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![image](Images/f0589-06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Connecting, sending, and receiving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The three things we have to learn to get the client working are:'
  prefs: []
  type: TYPE_NORMAL
- en: How to establish the initial **connection** between the client and server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to **receive** messages *from* the server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to **send** messages *to* the server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s a lot of low-level stuff that has to happen for these things to work.
    But we’re lucky, because the Java APIs make it a piece of cake for programmers.
    You’ll see a lot more GUI code than networking and I/O code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s not all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lurking within the simple chat client is a problem we haven’t faced so far
    in this book: doing two things at the same time. Establishing a connection is
    a one-time operation (that either works or fails). But after that, a chat participant
    wants to *send outgoing messages* and **simultaneously** *receive incoming messages*
    from the other participants (via the server). Hmm...that one’s going to take a
    little thought, but we’ll get there in just a few pages.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circle.png) **Connect**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client **connects** to the server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0590-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2circle.png) **Receive**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client **reads** a message from the server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0590-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3circle.png) **Send**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client **writes** a message to the server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0590-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 1\. Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To talk to another machine, we need an object that represents a network connection
    between two machines. We can open a java.nio.channels.SocketChannel to give us
    this connection object.
  prefs: []
  type: TYPE_NORMAL
- en: What’s a connection? A *relationship* between two machines, where **two pieces
    of software know about each other**. Most importantly, those two pieces of software
    know how to *communicate* with each other. In other words, how to send *bits*
    to each other.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t care about the low-level details, thankfully, because they’re handled
    at a much lower place in the “networking stack.” If you don’t know what the “networking
    stack” is, don’t worry about it. It’s just a way of looking at the layers that
    information (bits) must travel through to get from a Java program running in a
    JVM on some OS, to physical hardware (Ethernet cables, for example), and back
    again on some other machine.
  prefs: []
  type: TYPE_NORMAL
- en: The part that you have to worry about is high-level. You just have to create
    an object for the server’s address and then open a channel to that server. Ready?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To make a connection, you need to know two things about the server: where it
    is and which port it’s running on.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words,
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**IP address and TCP port number.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0591-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A connection means the two machines have information about each other, including
    network location (IP address) and TCP port.
  prefs: []
  type: TYPE_NORMAL
- en: '**A TCP port is just a number... a 16-bit number that identifies a specific
    program on the server**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Your internet web (HTTP) server runs on port 80\. That’s a standard. If you’ve
    got a Telnet server, its running on port 23\. FTP? 20\. POP3 mail server? 110\.
    SMTP? 25\. The Time server sits at 37\. Think of port numbers as unique identifiers.
    They represent a logical connection to a particular piece of software running
    on the server. That’s it. You can’t spin your hardware box around and find a TCP
    port. For one thing, you have 65,536 of them on a server (0–65535). So they obviously
    don’t represent a place to plug in physical devices. They’re just a number representing
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well-known TCP port numbers for common server applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0592-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Without port numbers, the server would have no way of knowing which application
    a client wanted to connect to. And since each application might have its own unique
    protocol, think of the trouble you’d have without these identifiers. What if your
    web browser, for example, landed at the POP3 mail server instead of the HTTP server?
    The mail server won’t know how to parse an HTTP request! And even if it did, the
    POP3 server doesn’t know anything about servicing the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: When you write a server program, you’ll include code that tells the program
    which port number you want it to run on (you’ll see how to do this in Java a little
    later in this chapter). In the Chat program we’re writing in this chapter, we
    picked 5000\. Just because we wanted to. And because it met the criteria that
    it be a number between 1024 and 65535\. Why 1024? Because 0 through 1023 are reserved
    for the well-known services like the ones we just talked about.
  prefs: []
  type: TYPE_NORMAL
- en: And if you’re writing services (server programs) to run on a company network,
    you should check with the sysadmins to find out which ports are already taken.
    Your sysadmins might tell you, for example, that you can’t use any port number
    below, say, 3000\. In any case, if you value your limbs, you won’t assign port
    numbers with abandon. Unless it’s your *home* network. In which case you just
    have to check with your *kids*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The TCP port numbers from 0 to 1023 are reserved for well-known services. Don’t
    use them for your own server programs!*
  prefs: []
  type: TYPE_NORMAL
- en: The chat server we’re writing uses port 5000\. We just picked a number between
    1024 and 65535.
  prefs: []
  type: TYPE_NORMAL
- en: '*Well, you *might* be able to use one of these, but the sysadmin where you
    work will write you a strongly worded message and CC your boss.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0593-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 2\. Receive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To communicate over a remote connection, you can use regular old I/O streams,
    just like we used in the previous chapter. One of the coolest features in Java
    is that most of your I/O work won’t care what your high-level chain stream is
    actually connected to. In other words, you can use a **BufferedReader** just like
    you did when you were reading from a file; the difference is that the underlying
    connection stream is connected to a *Channel* rather than a *File*!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0594-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading from the network with BufferedReader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0594-02.png)![image](Images/f0594-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 3\. Send
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we used BufferedWriter. We have a choice here, but
    when you’re writing one String at a time, **PrintWriter** is a standard choice.
    And you’ll recognize the two key methods in PrintWriter, print() and println()!
    Just like good ol’ System.out.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the network with PrintWriter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0595-01.png)'
  prefs: []
  type: TYPE_IMG
- en: There’s more than one way to make a connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0596-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If you look at real life code that talks to a remote machine, you’ll probably
    see a number of different ways to make connections and to read from and write
    to a remote computer.
  prefs: []
  type: TYPE_NORMAL
- en: Which approach you use depends on a number of things, including (but not limited
    to) the version of Java you’re using and the needs of the application (for example,
    how many clients connect at once, the size of messages sent, frequency or message,
    etc). One of the simplest approaches is to use a **java.net.Socket** instead of
    a Channel.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Socket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can get an *InputStream* or *OutputStream* from a Socket, and read and write
    from it in a very similar way to what we’ve already seen.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0596-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The java.net.Socket class is available in all versions of Java.
  prefs: []
  type: TYPE_NORMAL
- en: It supports simple network I/O via the I/O streams we’ve already used for file
    I/O.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0597-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**As we’ve become an increasingly connected world, Java has evolved to offer
    more ways to work with remote machines.**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Channels are in the java.**nio**.channels package? The java.nio
    package (NIO) was introduced in Java 1.4, and there were more changes and additions
    made (sometimes called NIO.2) in Java 7.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to use Channels and NIO to get better performance when you’re
    working with lots of network connections, or lots of data coming over those connections.
  prefs: []
  type: TYPE_NORMAL
- en: '**In this chapter, we’re using Channels to provide the same very basic connection
    functionality we could get from Sockets**. However, if our application needed
    to work well with a very busy network connection (or lots of them!), we could
    configure our Channels differently and use them to their full potential, and our
    program would cope better with a high network I/O load.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve chosen to teach you the **simplest way to get started** with network I/O
    using *Channels* so that if you need to “level up” to working with more advanced
    features, it shouldn’t be such a big step.
  prefs: []
  type: TYPE_NORMAL
- en: If you do want to learn more about NIO, read *Java NIO* by Ron Hitchens and
    *Java I/O, NIO and NIO.2* by Jeff Friesen.
  prefs: []
  type: TYPE_NORMAL
- en: The DailyAdviceClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start building the Chat app, let’s start with something a little smaller.
    The Advice Guy is a server program that offers up practical, inspirational tips
    to get you through those long days of coding.
  prefs: []
  type: TYPE_NORMAL
- en: We’re building a client for The Advice Guy program, which pulls a message from
    the server each time it connects.
  prefs: []
  type: TYPE_NORMAL
- en: What are you waiting for? Who *knows* what opportunities you’ve missed without
    this app.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0598-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. The Advice Guy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Images](Images/1circle.png) **Connect**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client connects to the server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0598-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2circle.png) **Read**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client gets a Reader for the Channel, and reads a message from the server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0598-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: DailyAdviceClient code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program makes a SocketChannel, makes a BufferedReader (with the help of
    the channel’s Reader), and reads a single line from the server application (whatever
    is running at port 5000).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0599-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing a simple server application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what’s it take to write a server application? Just a couple of Channels.
    Yes, a couple as in two. A ServerSocketChannel, which waits for client requests
    (when a client connects) and a SocketChannel to use for communication with the
    client. If there’s more than one client, we’ll need more than one channel, but
    we’ll get to that later.
  prefs: []
  type: TYPE_NORMAL
- en: '**How it works:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circle.png) Server application makes a ServerSocketChannel
    and binds it to a specific port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This starts the server application listening for client requests coming in for
    port 5000.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0601-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2circle.png) Client makes a SocketChannel connected to the
    server application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**SocketChannel svr = SocketChannel.open(new InetSocketAddress("190.165.1.103",
    5000));**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Client knows the IP address and port number (published or given to them by whomever
    configures the server app to be on that port).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0601-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3circle.png) Server makes a new SocketChannel to communicate
    with this client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**SocketChannel clientChannel = serverChannel.accept();**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The accept() method blocks (just sits there) while it’s waiting for a client
    connection. When a client finally connects, the method returns a SocketChannel
    that knows how to communicate with this client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The ServerSocketChannel can go back to waiting for other clients. The server
    has just one ServerSocketChannel, and a SocketChannel per client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0601-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: DailyAdviceServer code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program makes a ServerSocketChannel and waits for client requests. When
    it gets a client request (i.e., client created a new SocketChannel to this server),
    the server makes a new SocketChannel to that client. The server makes a PrintWriter
    (using a Writer created from the SocketChannel) and sends a message to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0602-01.png)![image](Images/f0603-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Yes, that’s right, **the server can’t accept a request from a client until it
    has finished with the current client.** At which point, it starts the next iteration
    of the infinite loop, sitting, waiting, at the accept() call until a new request
    comes in, at which point it makes a SocketChannel to send data to the new client
    and starts the process over again.
  prefs: []
  type: TYPE_NORMAL
- en: To get this to work with multiple clients *at the same time*, we need to use
    separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: We’d give each new client’s SocketChannel to a new thread, and each thread can
    work independently.
  prefs: []
  type: TYPE_NORMAL
- en: We’re just about to learn how to do that!
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Chat Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll write the Chat Client application in two stages. First we’ll make a send-only
    version that sends messages to the server but doesn’t get to read any of the messages
    from other participants (an exciting and mysterious twist to the whole chat room
    concept).
  prefs: []
  type: TYPE_NORMAL
- en: Then we’ll go for the full chat monty and make one that both sends *and* receives
    chat messages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Version One: send-only**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0604-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Code outline**'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an outline of the main functionality the chat client needs to provide.
    The full code is on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0605-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The really, really simple Chat Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0606-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use this server code for all versions of the Chat Client. Every possible
    disclaimer ever disclaimed is in effect here. To keep the code stripped down to
    the bare essentials, we took out a lot of parts that you’d need to make this a
    real server. In other words, it works, but there are at least a hundred ways to
    break it. If you want to really sharpen your skills after you’ve finished this
    book, come back and make this server code more robust.
  prefs: []
  type: TYPE_NORMAL
- en: After you finish this chapter, you should be able to annotate this code yourself.
    You’ll understand it much better if *you* work out what’s happening than if we
    explained it to you. Then again, this is Ready-Bake Code, so you really don’t
    have to understand it at all. It’s here just to support the two versions of the
    Chat Client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0607-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Version Two: send and receive**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0608-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Big Question: *HOW* do you get messages from the server?**'
  prefs: []
  type: TYPE_NORMAL
- en: Should be easy; when you set up the networking, make a Reader as well. Then
    read messages using `**readLine**`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bigger Question: *WHEN* do you get messages from the server?**'
  prefs: []
  type: TYPE_NORMAL
- en: Think about that. What are the options?
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Option One: Read something in from the server each
    time the user sends a message.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros:** Doable, very easy.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Cons:** Stupid. Why choose such an arbitrary time to check for messages?
    What if a user is a lurker and doesn’t send anything?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **Option Two: Poll the server every 20 seconds.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros:** It’s doable, and it fixes the lurker problem.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Cons:** How does the server know what you’ve seen and what you haven’t? The
    server would have to store the messages, rather than just doing a distribute-and-forget
    each time it gets one. And why 20 seconds? A delay like this affects usability,
    but as you reduce the delay, you risk hitting your server needlessly. Inefficient.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/3.png) **Option Three: Read messages as soon as they’re sent
    from the server.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pros:** Most efficient, best usability.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Cons:** How do you do two things at the same time? Where would you put this
    code? You’d need a loop somewhere that was always waiting to read from the server.
    But where would that go? Once you launch the GUI, nothing happens until an event
    is fired by a GUI component.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0609-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Java you really CAN walk and chew gum at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '**You know by now that we’re going with option three**'
  prefs: []
  type: TYPE_NORMAL
- en: We want something to run continuously, checking for messages from the server,
    but *without interrupting the user’s ability to interact with the GUI!* So while
    the user is happily typing new messages or scrolling through the incoming messages,
    we want something *behind the scenes* to keep reading in new input from the server.
  prefs: []
  type: TYPE_NORMAL
- en: That means we finally need a new thread. A new, separate stack.
  prefs: []
  type: TYPE_NORMAL
- en: We want everything we did in the Send-Only version (version one) to work the
    same way, while a new *process* runs alongside that reads information from the
    server and displays it in the incoming text area.
  prefs: []
  type: TYPE_NORMAL
- en: Well, not quite. Each new Java thread is not actually a separate process running
    on the OS. But it almost *feels* as though it is.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to take a break from the chat application for a bit while we explore
    how this works. Then we’ll come back and add it to our chat client at the end
    of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multithreading in Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java has support for multiple threads built right into the fabric of the language.
    And it’s a snap to make a new thread of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That’s it. By creating a new Thread *object*, you’ve launched a separate *thread
    of execution*, with its very own call stack.
  prefs: []
  type: TYPE_NORMAL
- en: '***Except for one problem.***'
  prefs: []
  type: TYPE_NORMAL
- en: That thread doesn’t actually *do* anything, so the thread “dies” virtually the
    instant it’s born. When a thread dies, its new stack disappears again. End of
    story.
  prefs: []
  type: TYPE_NORMAL
- en: So we’re missing one key component—the thread’s *job*. In other words, we need
    the code that you want to have run by a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple threading in Java means we have to look at both the *thread* and the
    *job* that’s *run* by the thread. In fact, **there’s more than one way to run
    multiple jobs in Java**, not just with the Thread *class* in the java.lang package.
    (Remember, java.lang is the package you get imported for free, implicitly, and
    it’s where the classes most fundamental to the language live, including String
    and System.)
  prefs: []
  type: TYPE_NORMAL
- en: Java has multiple threads but only one Thread class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can talk about *thread* with a lowercase “t” and **Thread** with a capital
    “T.” When you see *thread*, we’re talking about a separate thread of execution.
    In other words, a separate call stack. When you see **Thread**, think of the Java
    naming convention. What, in Java, starts with a capital letter? Classes and interfaces.
    In this case, **Thread** is a class in the java.lang package. A **Thread** object
    represents a *thread of execution*. In older versions of Java, you always had
    to create an instance of class **Thread** each time you wanted to start up a new
    *thread* of execution. Java has evolved over time, and now using the **Thread**
    class directly is not the only way. We’ll see this in more detail as we go through
    the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**A thread is a separate “thread of execution,” a separate call stack.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Thread is a Java class that represents a thread.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the Thread class is not the only way to do multithreading in Java.**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **thread** | **Thread** |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](Images/f0610-01.png) | ![image](Images/f0610-02.png) |'
  prefs: []
  type: TYPE_TB
- en: '| A *thread* (lowercase “t”) is a separate thread of execution. That means
    a separate call stack. Every Java application starts up a main thread—the thread
    that puts the main() method on the bottom of the stack. The JVM is responsible
    for starting the main thread (and other threads, as it chooses, including the
    garbage collection thread). As a programmer, you can write code to start other
    threads of your own. | `**Thread**` (capital “T”) is a class that represents a
    thread of execution. It has methods for starting a thread, joining one thread
    with another, putting a thread to sleep, and more. |'
  prefs: []
  type: TYPE_TB
- en: What does it mean to have more than one call stack?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With more than one call stack, you can have multiple things happen at the same
    time. If you’re running on a multiprocessor system (like most modern computers
    and phones), you can actually do more than one thing at a time. With Java threads,
    even if you’re not running on a multiprocessor system or if you’re running more
    processes than available cores, it can *appear* that you’re doing all these things
    simultaneously. In other words, execution can move back and forth between stacks
    so rapidly that you feel as though all stacks are executing at the same time.
    Remember, Java is just a process running on your underlying OS. So first, Java
    *itself* has to be “the currently executing process” on the OS. But once Java
    gets its turn to execute, exactly *what* does the JVM *run*? Which bytecodes execute?
    Whatever is on the top of the currently running stack! And in 100 milliseconds,
    the currently executing code might switch to a *different* method on a *different*
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things a thread must do is keep track of which statement (of which
    method) is currently executing on the thread’s stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0611-01.png)'
  prefs: []
  type: TYPE_IMG
- en: To create a new call stack you need a job to run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0612-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Runnable is to a thread what a job is to a worker. A Runnable is the job
    a thread is supposed to run.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Runna ble holds t he method t hat goes on the bottom of the new call stack:
    run().**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a new call stack the thread needs a job—a job the thread will run
    when it’s started. That job is actually the first method that goes on the new
    thread’s stack, and it must always be a method that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How does the thread know which method to put at the bottom of the stack? Because
    Runnable defines a contract. Because Runnable is an interface. A thread’s job
    can be defined in any class that implements the Runnable interface, or a lambda
    expression that is the right shape for the run method.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a Runnable class or lambda expression, you can tell the JVM to
    run this code in a separate thread; you’re giving the thread its job.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Runnable interface defines only one method, public void run(). Since it
    has only a single method, it’s a SAM type, a Functional Interface, and you can
    use a lambda instead of creating a whole class that implements Runnable if you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: To make a job for your thread, implement the Runnable interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0613-01.png)'
  prefs: []
  type: TYPE_IMG
- en: How NOT to run the Runnable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may be tempting to create a new instance of the Runnable and call the run
    method, but that’s **not enough to create a new call stack**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This will NOT do what we want!
  prefs: []
  type: TYPE_NORMAL
- en: '**The run() method was called directly from inside the main() method, so it’s
    part of the call stack of the main thread.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0613-02.png)'
  prefs: []
  type: TYPE_IMG
- en: How we used to launch a new thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to launch a new thread is with the Thread class that we mentioned
    earlier. This method has been around in Java since the very beginning, but **it
    is no longer the recommended approach to use**. We’re showing it here because
    a) it’s simple, and b) you’ll see it in the Real World. We will talk later about
    why it might not be the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0614-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A better alternative: don’t manage the Threads at all'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and starting a new Thread gives you a lot of control over that Thread,
    but the downside is you *have* to control it. You have to keep track of all the
    Threads and make sure they’re shut down at the end. Wouldn’t it be better to have
    something else that starts, stops, and even reuses the Threads so you don’t have
    to?
  prefs: []
  type: TYPE_NORMAL
- en: Allow us to introduce an interface in java.util.concurrent, **`ExecutorService`**.
    Implementations of this interface will *execute* jobs (Runnables). Behind the
    scenes the ExecutorService will create, reuse, and kill threads in order to run
    these jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Static factory methods can be used instead of constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Factory methods return exactly the implementation of an interface that we need.
    We don’t need to know the concrete classes or how to create them.
  prefs: []
  type: TYPE_NORMAL
- en: The **`java.util.concurrent.Executors`** class has *factory methods* to create
    the ExecutorService instances we’ll need.
  prefs: []
  type: TYPE_NORMAL
- en: Executors have been around since Java 5 and so should be available to you even
    if you’re working with quite an old version of Java. There’s no real need to use
    Thread directly at all these days.
  prefs: []
  type: TYPE_NORMAL
- en: Running one job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the simple cases we’re going to get started with, we’ll want to run only
    one job in addition to our main class. There’s a *single thread executor* that
    we can use to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0615-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The three states of a new thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you create a new Thread and pass it the Runnable, or use an Executor
    to execute the Runnable, the job will still be running on a Thread. A Thread will
    move through a number of different states during its life, and understanding these
    states, and the transitions between them, helps us to better understand multithreaded
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0616-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**But there’s more. Once the thread becomes runnable, it can move back and
    forth between runnable, running, and an additional state: *temporarily not runnable*.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Typical runnable/running loop**'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a thread moves back and forth between runnable and running, as the
    JVM thread scheduler selects a thread to run and then kicks it back out so another
    thread gets a chance.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0617-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A thread can be made temporarily not-runnable**'
  prefs: []
  type: TYPE_NORMAL
- en: The thread scheduler can move a running thread into a blocked state, for a variety
    of reasons. For example, the thread might be executing code to read from an input
    stream, but there isn’t any data to read. The scheduler will move the thread out
    of the running state until something becomes available. Or the executing code
    might have told the thread to put itself to sleep (sleep()). Or the thread might
    be waiting because it tried to call a method on an object, and that object was
    “locked.” In that case, the thread can’t continue until the object’s lock is freed
    by the thread that has it.
  prefs: []
  type: TYPE_NORMAL
- en: All of those conditions (and more) cause a thread to become temporarily not-runnable.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0617-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The thread scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The thread scheduler makes all the decisions about who moves from runnable to
    running, and about when (and under what circumstances) a thread leaves the running
    state. The scheduler decides who runs, for how long, and where the threads go
    when it decides to kick them out of the currently running state.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0618-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You can’t control the scheduler. There is no API for calling methods on the
    scheduler. Most importantly, there are no guarantees about scheduling! (There
    are a few *almost*-guarantees, but even those are a little fuzzy.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is this: ***do not base your program’s correctness on the scheduler
    working in a particular way!*** The scheduler implementations are different for
    different JVMs, and even running the same program on the same machine can give
    you different results. One of the worst mistakes new Java programmers make is
    to test their multithreaded program on a single machine, and assume the thread
    scheduler will always work that way, regardless of where the program runs.'
  prefs: []
  type: TYPE_NORMAL
- en: So what does this mean for write-once-run-anywhere? It means that to write platform-independent
    Java code, your multithreaded program must work no matter *how* the thread scheduler
    behaves. That means you can’t be dependent on, for example, the scheduler making
    sure all the threads take nice, perfectly fair, and equal turns at the running
    state. Although highly unlikely today, your program might end up running on a
    JVM with a scheduler that says, “OK, thread five, you’re up, and as far as I’m
    concerned, you can stay here until you’re done, when your run() method completes.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The thread scheduler makes all the decisions about who runs and who doesn’t.
    It usually makes the threads take turns, nicely. But there’s no guarantee about
    that. It might let one thread run to its heart’s content while the other threads
    “starve.”**'
  prefs: []
  type: TYPE_NORMAL
- en: '**An example of how unpredictable the scheduler can be...**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0619-01.png)'
  prefs: []
  type: TYPE_IMG
- en: How did we end up with different results?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multithreaded programs are *not deterministic*; they don’t run the same way
    every time. The thread scheduler can schedule each thread differently each time
    the program runs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sometimes it runs like this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0620-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**And sometimes it runs like this:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0620-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Even if the new thread is tiny, if it has only one line of code to run like
    our lambda expression, it can still be interrupted by the thread scheduler.**'
  prefs: []
  type: TYPE_NORMAL
- en: Putting a thread to sleep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0622-01.png)'
  prefs: []
  type: TYPE_IMG
- en: One way to help your threads take turns is to put them to sleep periodically.
    All you need to do is call the static sleep() method, passing it the amount of
    time you want the thread to sleep for, in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: will knock a thread out of the running state and keep it out of the runnable
    state for two seconds. The thread *can’t* become the running thread again until
    after at least two seconds have passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit unfortunately, the sleep method throws an InterruptedException, a checked
    exception, so all calls to sleep must be wrapped in a try/catch (or declared).
    So a sleep call really looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now you know that your thread won’t wake up *before* the specified duration,
    but is it possible that it will wake up some time *after* the “timer” has expired?
    Effectively, yes. The thread won’t automatically wake up at the designated time
    and become the currently running thread. When a thread wakes up, the thread is
    once again at the mercy of the thread scheduler; therefore, there are no guarantees
    about how long the thread will be out of action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Putting a thread to sleep gives the other threads a chance to run.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**When the thread wakes up, it always goes back to the runnable state and waits
    for the thread scheduler to choose it to run again.**'
  prefs: []
  type: TYPE_NORMAL
- en: Using sleep to make our program more predictable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember our earlier example that kept giving us different results each time
    we ran it? Look back and study the code and the sample output. Sometimes main
    had to wait until the new thread finished (and printed “top o’ the stack”), while
    other times the new thread would be sent back to runnable before it was finished,
    allowing the main thread to come back in and print out “back in main.” How can
    we fix that? Stop for a moment and answer this question: “Where can you put a
    sleep() call, to make sure that “back in main” always prints before “top o’ the
    stack”?'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0623-01.png)![image](Images/f0623-02.png)'
  prefs: []
  type: TYPE_IMG
- en: There are downsides to forcing the thread to sleep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **The program has to wait for at least that amount
    of time.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we put the thread to sleep for two seconds, the thread will be non-runnable
    for that time. When it wakes up, it won’t automatically become the currently running
    thread. When a thread wakes up, the thread is once again at the mercy of the thread
    scheduler. Our application is going to be hanging around for at least those two
    seconds, probably more. This might not sound like a big deal, but imagine a bigger
    program full of these pauses *intentionally* slowing down the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **How do you know the other job will finish in that
    time?**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We put the new thread to sleep for two seconds, assuming that the main thread
    would be the running thread, and complete its work in that time. But what if the
    main thread took longer to finish than that? What if another thread, running a
    longer job, was scheduled instead? One of the ways people deal with this is to
    set sleep times that are much longer than they’d expect a job to take, but then
    our first problem becomes even more of a problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0624-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A better alternative: wait for the perfect time.**'
  prefs: []
  type: TYPE_NORMAL
- en: What we really wanted in our example was to wait until a specific thing had
    happened in our main thread before carrying on with our new thread. Java supports
    a number of different mechanisms to do this, like Future, CyclicBarrier, Semaphore,
    and CountDownLatch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**To coordinate events happening on multiple threads, one thread may need to
    wait for a specific signal from another thread before it can continue.**'
  prefs: []
  type: TYPE_NORMAL
- en: Counting down until ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can make threads *count down* when significant events have happened. A thread
    (or threads) can wait for all these events to complete before continuing. You
    might be counting down until a minimum number of clients have connected, or a
    number of services have been started.
  prefs: []
  type: TYPE_NORMAL
- en: This is what `**java.util.concurrent.CountDownLatch**` is for. You set a number
    to count down from. Then any thread can tell the latch to count down when a relevant
    event has happened.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have only one thing we want to count—our new thread should
    wait until the main thread has printed “back in main” before it can continue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**CountDownLatch is a barrier synchronizer. Barriers are mechanisms to allow
    threads to coordinate with each other.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Other examples are CyclicBarrier and Phaser.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0625-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The code is really similar to the code that performs a sleep; the main difference
    is the latch.countDown in the main method. The performance difference is significant,
    though. Instead of having to wait *at least* two seconds to make sure main has
    printed its message, the new thread waits only until the main method has printed
    its “back in main” message.
  prefs: []
  type: TYPE_NORMAL
- en: To get an idea of the performance difference this might make on a real system,
    when this latch code was run on a MacBook 100 times, it took around 50 milliseconds
    to finish *all* one hundred runs, and the output was in the correct order *every
    time*. If running the sleep() version just one time takes over 2 seconds (2000
    milliseconds), imagine how long it took to run 100 times*....
  prefs: []
  type: TYPE_NORMAL
- en: Making and starting two threads (or more!)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if we want to start more than one job in addition to our main thread?
    Clearly, we can’t use Executors.newSingleThreadExecutor() if we want to run more
    than one thread. What else is available?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0626-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**These ExecutorServices use some form of Thread Pool. This is a collection
    of Thread instances that can be used (and reused) to perform jobs.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**How many threads are in the pool, and what to do if there are more jobs to
    run than threads available, depends on the ExecutorService implementation.**'
  prefs: []
  type: TYPE_NORMAL
- en: Pooling Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a pool of resources, especially ones that are expensive to create like
    Threads or database connections, is a common pattern in application code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0627-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When you create a new ExecutorService, its pool may be started with some threads
    to begin with, or the pool may be empty.
  prefs: []
  type: TYPE_NORMAL
- en: You can create an ExecutorService with a thread pool using one of the helper
    methods from the Executors class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0627-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use the pool’s threads to run your job by giving the job to the ExecutorService.
    The ExecutorService can then figure out if there’s a free Thread to run the job.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This means an ExecutorService can **reuse** threads; it doesn’t just create
    and destroy them.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0627-03.png)'
  prefs: []
  type: TYPE_IMG
- en: As you give the ExecutorService more jobs to run, it *may* create and start
    new Threads to handle the jobs. It *may* store the jobs in a queue if there are
    more jobs than Threads.
  prefs: []
  type: TYPE_NORMAL
- en: How an ExecutorService deals with additional jobs depends on how it is set up.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The ExecutorService may also **terminate** Threads that have been idle for some
    period of time. This can help to minimize the amount of hardware resources (CPU,
    memory) your application needs.
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example runs two jobs, and uses a fixed-sized thread pool to
    create two threads to run the jobs. Each thread has the same job: run in a loop,
    printing the currently running thread’s name with each iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0628-01.png)'
  prefs: []
  type: TYPE_IMG
- en: What will happen?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Will the threads take turns? Will you see the thread names alternating? How
    often will they switch? With each iteration? After five iterations?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0628-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You already know the answer: *we don’t know!* It’s up to the scheduler. And
    on your OS, with your particular JVM, on your CPU, you might get very different
    results.'
  prefs: []
  type: TYPE_NORMAL
- en: Running this on a modern multicore system, the two jobs will likely run in parallel,
    but there’s no guarantee that this means they will complete in the same amount
    of time or output values at the same rate.
  prefs: []
  type: TYPE_NORMAL
- en: Closing time at the thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that our examples have a `**threadPool.shutdown**()` at
    the end of the main methods. Although the thread pools will take care of our individual
    Threads, we do need to be responsible adults and close the pool when we’re finished
    with it. That way, the pool can empty its job queue and shut down all of its threads
    to free up system resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'ExecutorService has two shutdown methods. You can use either, but to be safe
    we’d use both:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **ExecutorService.shutdown()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling shutdown() asks the ExecutorService nicely if it wouldn’t mind awfully
    wrapping things up so everyone can go home.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All of the Threads that are currently running jobs are allowed to finish those
    jobs, and any jobs waiting in the queue will also be finished off. The ExecutorService
    will reject any new jobs too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you need your code to wait until all of those things are finished, you can
    use `**awaitTermination**` to sit and wait until it’s finished. You give awaitTermination
    a maximum amount of time to wait for everything to end, so awaitTermination will
    hang around until either the ExecutorService has finished everything or the timeout
    has been reached, whichever is earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **ExecutorService.shutdownNow()**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everybody out! When this is called, the ExecutorService will try to stop any
    Threads that are running, will not run any waiting jobs, and definitely won’t
    let anyone else into the pool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use this if you need to put a stop to everything. This is sometimes used after
    first calling shutdown() to give the jobs a chance to finish before pulling the
    plug entirely.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0629-01.png)![image](Images/f0630-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Um, yes. There IS a dark side. Multithreading can lead to concurrency “issues.”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency issues lead to race conditions. Race conditions lead to data corruption.
    Data corruption leads to fear...you know the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'It all comes down to one potentially deadly scenario: two or more threads have
    access to a single object’s *data*. In other words, methods executing on two different
    stacks are both calling, say, getters or setters on a single object on the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a whole “left-hand-doesn’t-know-what-the-right-hand-is-doing” thing. Two
    threads, without a care in the world, humming along executing their methods, each
    thread thinking that he is the One True Thread. The only one that matters. After
    all, when a thread is not running, and in runnable (or blocked) it’s essentially
    knocked unconscious. When it becomes the currently running thread again, it doesn’t
    know that it ever stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: Who Am I?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Exercise”](#exercise-id000027))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/eye1.png)'
  prefs: []
  type: TYPE_IMG
- en: A bunch of Java and network terms, in full costume, are playing a party game,
    “Who am I?” They’ll give you a clue—you try to guess who they are based on what
    they say. Assume they always tell the truth about themselves. If they happen to
    say something that could be true for more than one attendee, then write down all
    for whom that sentence applies. Fill in the blanks next to the sentence with the
    names of one or more attendees.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tonight’s attendees:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetSocketAddress, SocketChannel, IP address, host name, port, Socket, ServerSocketChannel,
    Thread, thread pool, Executors, ExecutorService, CountDownLatch, Runnable, InterruptedException,
    Thread.sleep()**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **I need to be shut down or I might live forever** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **I let you talk to a remote machine** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **I might be thrown by sleep() and await()** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **If you want to reuse Threads, you should use me** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **You need to know me if you want to connect to another machine** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **I’m like a separate process running on the machine** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **I can give you the ExecutorService you need** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **You need one of me if you want clients to connect to me** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **I can help you make your multithreaded code more predictable** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **I represent a job to run** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **I store the IP address and port of the server** | ______________________________________________
    |'
  prefs: []
  type: TYPE_TB
- en: '![Images](Images/arr.png) **Answers in [“Who Am I?”](#who_am_iquestion_mark_left_par).**'
  prefs: []
  type: TYPE_NORMAL
- en: New and improved SimpleChatClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Way back near the beginning of the chapter, we built the SimpleChatClient that
    could *send* outgoing messages to the server but couldn’t receive anything. Remember?
    That’s how we got onto this whole thread topic in the first place, because we
    needed a way to do two things at once: send messages *to* the server (interacting
    with the GUI) while simultaneously reading incoming messages *from* the server,
    displaying them in the scrolling text area.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the New Improved chat client that can both send and receive messages,
    thanks to the power of multithreading! Remember, you need to run the chat server
    first to run this code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0632-01.png)![image](Images/f0633-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: Code Magnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/common-1.png)'
  prefs: []
  type: TYPE_IMG
- en: A working Java program is scrambled up on the fridge (see the next page). Can
    you reconstruct the code snippets on the next page to make a working Java program
    that produces the output listed below?
  prefs: []
  type: TYPE_NORMAL
- en: To get it to work, you will need to be running the `**SimpleChatServer**` from
    [“The really, really simple Chat Server”](#the_reallycomma_really_simple_chat_serve).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0634-02.png)![image](Images/f0634-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Answers in [“Code Magnets”](#code_magnets_left_parenthesisfrom_p-idd).**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0635-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: Who Am I?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| I need to be shut down or I might live forever | *ExecutorService* |'
  prefs: []
  type: TYPE_TB
- en: '| I let you talk to a remote machine | *SocketChannel, Socket* |'
  prefs: []
  type: TYPE_TB
- en: '| I might be thrown by sleep() and await() | *InterruptedException* |'
  prefs: []
  type: TYPE_TB
- en: '| If you want to reuse Threads, you should use me | *Thread pool, ExecutorService*
    |'
  prefs: []
  type: TYPE_TB
- en: '| You need to know me if you want to connect to another machine | *IP Address,
    Host name, port* |'
  prefs: []
  type: TYPE_TB
- en: '| I’m like a separate process running on the machine | *Thread* |'
  prefs: []
  type: TYPE_TB
- en: '| I can give you the ExecutorService you need | *Executors* |'
  prefs: []
  type: TYPE_TB
- en: '| You need one of me if you want clients to connect to me | *ServerSocketChannel*
    |'
  prefs: []
  type: TYPE_TB
- en: '| I can help you make your multithreaded code more predictable | *Thread.sleep(),
    CountDownLatch* |'
  prefs: []
  type: TYPE_TB
- en: '| I represent a job to run | *Runnable* |'
  prefs: []
  type: TYPE_TB
- en: '| I store the IP address and port of the server | *InetSocketAddress* |'
  prefs: []
  type: TYPE_TB
- en: Code Magnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Code Magnets”](#code_magnets-id000007))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0636-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Code Kitchen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0637-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Now you’ve seen how to build a chat client, we have the last version of the
    BeatBox!**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**It connects to a simple MusicServer so that you can send and receive beat
    patterns with other clients.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**The code is really long, so the complete listing is actually in [Appendix A](app01.xhtml#appendix_a_final_code_kitchen).**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
