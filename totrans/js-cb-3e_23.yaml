- en: Chapter 20\. Remote Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data surrounds us. We create and interact with data throughout our daily lives,
    often in interesting and unexpected ways. When building Node applications, we
    often interact with data. At times, that data may be something that we’ve created
    for the application, or data that the user has entered into our system. However,
    it’s also common to need to interact with data that comes from outside of our
    applications. This chapter covers best practices and techniques for working with
    remote data in Node applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Remote Data
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make a request to a remote server within your Node application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `node-fetch`, one of the most popular and widely used modules, which brings
    the browser’s `window.fetch` to Node. It’s installed with npm:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'and can be used as simply as:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Discussion
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`node-fetch` provides an API that closely mirrors the browser’s `window.fetch`,
    allowing our Node programs to access remote resources. Like `window.fetch`, it
    offers support for the HTTP methods of GET, POST, DELETE, and PUT. In the case
    of GET, if the response indicates success (a status code of 200), you can then
    process the returned data (formatted as HTML in this instance) however you would
    like.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make a request for a JSON resource:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It’s also possible to use the `async/await` syntax, including a `try/catch`
    block for error handling:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also stream a result to a file using the filesystem module:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`node-fetch` can also handle POST, DELETE, and PUT methods, allowing you to
    send data to a server. In the following example, we make a `POST` request:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`node-fetch` is a common and useful library for fetching remote data, but it
    is not the only one. Popular alternatives include Request (which, though still
    popular, is no longer actively maintained), Got, Axios, and Superagent.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Screen Scraping
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access specific content from a web resource from within your Node
    application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `node-fetch` and Cheerio modules to *screen scrape* a website.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'First install the required modules:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To scrape the page, make use of `node-fetch` to retrieve the content and then
    query the retrieved content with Cheerio:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Discussion
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interesting use of Node is to *scrape* a website or resource and then use
    other functionality to query for specific information within the returned material.
    A popular module to use for querying is Cheerio, which is a tiny implementation
    of jQuery core intended for use in the server. In the following example, a simple
    application is created to pull in all of the post titles on the O’Reilly Radar
    blog page. To select these titles, we use Cheerio to find links (`a`) contained
    within `h2` elements that are within the `main` content. We then list the text
    of the link to a separate output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After the successful request is made, the HTML returned is passed to Cheerio
    via the `load()` method, and the result is assigned to a dollar sign variable
    (`$`), so we can select elements in the result in a manner similar to the jQuery
    library.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The element pattern of `main h2 a` is then used to query for all matches, and
    the result is processed using the `each` method, accessing the text for each heading.
    The output to the console should be the titles of all the articles on the main
    page of the blog.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use case is to download data when an API is not provided. In the following
    example, we’re locating specific links on the page and piping the linked resource
    to a local file. I’m also using the `async/await` syntax to demonstrate how it
    may be used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We first fetch the page at the specific URL, which in this instance is a United
    States government website containing several linked CSV files. We then use Cheerio
    to locate all links on the page that contain the word “state.” Finally, we fetch
    the linked-to file and pipe it to a local file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Screen scraping can be a useful tool to have in your toolbox, but proceed with
    caution. Before scraping a website for use in a production application, be sure
    to consult its Terms of Service (ToS) or seek out permission from the site owner.
    Also be careful not to accidentally perform a denial-of-service attack (DDoS)
    by overloading the host’s servers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Accessing JSON-Formatted Data via a RESTful API
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access data formatted as JSON from a service through its API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Node application, the simplest technique for accessing JSON-formatted data
    from an API is to use an HTTP request library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I’ll again use `node-fetch`, much like in [“Fetching
    Remote Data”](#fetching-remote):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The npm module `got` is a popular alternative to `node-fetch`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Discussion
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A RESTful API is one that is stateless, meaning that each client request contains
    everything necessary for the server to respond (doesn’t imply any stored state
    between requests); it uses HTTP methods explicitly. It supports a directory-like
    URI structure, and transfers data formatted a certain way (typically XML or JSON).
    The HTTP methods are:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'GET: To get resource data'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PUT: To update a resource'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DELETE: To delete a resource'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'POST: To create a resource'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we’re focusing on getting data, the only method of interest at this
    time is GET. And because we’re focused on JSON, we’re using client methods that
    can access JSON-formatted data and convert the data into objects we can manipulate
    in our JavaScript applications.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The [Open Exchange Rate](https://openexchangerates.org) provides an API that
    we can use to get current exchange rates, name-to-acronym for the different types
    of currencies, and the exchange rates for a specific date. It has a [Forever Free
    plan](https://oreil.ly/TjhFo) that provides limited access to the API without
    cost.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to make two queries of the system (for current currency rate
    and name-to-acronyms), and when both queries finish, to get the acronyms as keys,
    and use these to look up the long name and rate in the results, printing the pairs
    out to the console:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对系统进行两次查询（当前货币汇率和名称到缩写），当两个查询都完成时，将缩写作为键获取，并使用这些键在结果中查找长名称和汇率，然后将这些配对打印到控制台：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `id` value will need to be replaced with your unique ID, assigned
    by the API provider when you create an account. In the example, I’ve used the
    `dotenv` module to load the stored value from a *.env* file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`id` 值需要用您在创建账户时API提供商分配的唯一ID替换。在这个例子中，我使用 `dotenv` 模块从 *.env* 文件中加载存储的值。
- en: 'The base currency is “USD” or the US dollar, and a here’s a sampling of the
    results:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基础货币是“USD”或美元，以下是结果的样本：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the code snippet, I use `async/await` to make the queries, and then process
    the results when both queries are finished. In a production system, we’d most
    likely cache the results for however long our plan allows (hourly for the free
    API access).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我使用 `async/await` 进行查询，并在两个查询都完成后处理结果。在生产系统中，我们很可能会根据我们的计划允许的时间（免费API访问每小时一次）缓存结果。
- en: See Also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The examples didn’t need to *escape* the values used as parameters in the API
    requests, but if you do need to escape values, you can use Node’s built-in `querystring.escape()`
    method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中不需要 *转义* 用作API请求参数的值，但如果需要转义值，可以使用Node的内置 `querystring.escape()` 方法。
