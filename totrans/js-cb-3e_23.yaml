- en: Chapter 20\. Remote Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data surrounds us. We create and interact with data throughout our daily lives,
    often in interesting and unexpected ways. When building Node applications, we
    often interact with data. At times, that data may be something that we’ve created
    for the application, or data that the user has entered into our system. However,
    it’s also common to need to interact with data that comes from outside of our
    applications. This chapter covers best practices and techniques for working with
    remote data in Node applications.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Remote Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make a request to a remote server within your Node application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `node-fetch`, one of the most popular and widely used modules, which brings
    the browser’s `window.fetch` to Node. It’s installed with npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'and can be used as simply as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`node-fetch` provides an API that closely mirrors the browser’s `window.fetch`,
    allowing our Node programs to access remote resources. Like `window.fetch`, it
    offers support for the HTTP methods of GET, POST, DELETE, and PUT. In the case
    of GET, if the response indicates success (a status code of 200), you can then
    process the returned data (formatted as HTML in this instance) however you would
    like.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make a request for a JSON resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also possible to use the `async/await` syntax, including a `try/catch`
    block for error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also stream a result to a file using the filesystem module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`node-fetch` can also handle POST, DELETE, and PUT methods, allowing you to
    send data to a server. In the following example, we make a `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`node-fetch` is a common and useful library for fetching remote data, but it
    is not the only one. Popular alternatives include Request (which, though still
    popular, is no longer actively maintained), Got, Axios, and Superagent.'
  prefs: []
  type: TYPE_NORMAL
- en: Screen Scraping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access specific content from a web resource from within your Node
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `node-fetch` and Cheerio modules to *screen scrape* a website.
  prefs: []
  type: TYPE_NORMAL
- en: 'First install the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To scrape the page, make use of `node-fetch` to retrieve the content and then
    query the retrieved content with Cheerio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interesting use of Node is to *scrape* a website or resource and then use
    other functionality to query for specific information within the returned material.
    A popular module to use for querying is Cheerio, which is a tiny implementation
    of jQuery core intended for use in the server. In the following example, a simple
    application is created to pull in all of the post titles on the O’Reilly Radar
    blog page. To select these titles, we use Cheerio to find links (`a`) contained
    within `h2` elements that are within the `main` content. We then list the text
    of the link to a separate output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After the successful request is made, the HTML returned is passed to Cheerio
    via the `load()` method, and the result is assigned to a dollar sign variable
    (`$`), so we can select elements in the result in a manner similar to the jQuery
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The element pattern of `main h2 a` is then used to query for all matches, and
    the result is processed using the `each` method, accessing the text for each heading.
    The output to the console should be the titles of all the articles on the main
    page of the blog.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use case is to download data when an API is not provided. In the following
    example, we’re locating specific links on the page and piping the linked resource
    to a local file. I’m also using the `async/await` syntax to demonstrate how it
    may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We first fetch the page at the specific URL, which in this instance is a United
    States government website containing several linked CSV files. We then use Cheerio
    to locate all links on the page that contain the word “state.” Finally, we fetch
    the linked-to file and pipe it to a local file.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Screen scraping can be a useful tool to have in your toolbox, but proceed with
    caution. Before scraping a website for use in a production application, be sure
    to consult its Terms of Service (ToS) or seek out permission from the site owner.
    Also be careful not to accidentally perform a denial-of-service attack (DDoS)
    by overloading the host’s servers.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing JSON-Formatted Data via a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access data formatted as JSON from a service through its API.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Node application, the simplest technique for accessing JSON-formatted data
    from an API is to use an HTTP request library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I’ll again use `node-fetch`, much like in [“Fetching
    Remote Data”](#fetching-remote):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The npm module `got` is a popular alternative to `node-fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A RESTful API is one that is stateless, meaning that each client request contains
    everything necessary for the server to respond (doesn’t imply any stored state
    between requests); it uses HTTP methods explicitly. It supports a directory-like
    URI structure, and transfers data formatted a certain way (typically XML or JSON).
    The HTTP methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GET: To get resource data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PUT: To update a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DELETE: To delete a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'POST: To create a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we’re focusing on getting data, the only method of interest at this
    time is GET. And because we’re focused on JSON, we’re using client methods that
    can access JSON-formatted data and convert the data into objects we can manipulate
    in our JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another example.
  prefs: []
  type: TYPE_NORMAL
- en: The [Open Exchange Rate](https://openexchangerates.org) provides an API that
    we can use to get current exchange rates, name-to-acronym for the different types
    of currencies, and the exchange rates for a specific date. It has a [Forever Free
    plan](https://oreil.ly/TjhFo) that provides limited access to the API without
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to make two queries of the system (for current currency rate
    and name-to-acronyms), and when both queries finish, to get the acronyms as keys,
    and use these to look up the long name and rate in the results, printing the pairs
    out to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that the `id` value will need to be replaced with your unique ID, assigned
    by the API provider when you create an account. In the example, I’ve used the
    `dotenv` module to load the stored value from a *.env* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base currency is “USD” or the US dollar, and a here’s a sampling of the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the code snippet, I use `async/await` to make the queries, and then process
    the results when both queries are finished. In a production system, we’d most
    likely cache the results for however long our plan allows (hourly for the free
    API access).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples didn’t need to *escape* the values used as parameters in the API
    requests, but if you do need to escape values, you can use Node’s built-in `querystring.escape()`
    method.
  prefs: []
  type: TYPE_NORMAL
