- en: Chapter 4\. Writing MySQL-Based Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses how to use MySQL from within the context of a general-purpose
    programming language. It covers basic application programming interface (API)
    operations that are fundamental to and form the basis for the programming recipes
    developed in later chapters. These operations include connecting to the MySQL
    server, executing statements, and retrieving the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL-based client programs can be written using many languages. This book
    covers the languages and interfaces shown in the [Table 4-1](#nch-api-api-intro-langs)
    (for information on obtaining the interface software, see the [Preface](preface01.xhtml#nch-preface)):'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Languages and interfaces, covered in this book
  prefs: []
  type: TYPE_NORMAL
- en: '| Language | Interface |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Perl | Perl DBI |'
  prefs: []
  type: TYPE_TB
- en: '| Ruby | Mysql2 gem |'
  prefs: []
  type: TYPE_TB
- en: '| PHP | PDO |'
  prefs: []
  type: TYPE_TB
- en: '| Python | DB API |'
  prefs: []
  type: TYPE_TB
- en: '| Go | Go sql |'
  prefs: []
  type: TYPE_TB
- en: '| Java | JDBC |'
  prefs: []
  type: TYPE_TB
- en: 'MySQL client APIs provide the following capabilities, each covered in a section
    of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the MySQL server, selecting a database, and disconnecting from
    the server
  prefs: []
  type: TYPE_NORMAL
- en: Every program that uses MySQL must first establish a connection to the server.
    Most programs also select a default database, and well-behaved MySQL programs
    close the connection to the server when they’re done with it.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for errors
  prefs: []
  type: TYPE_NORMAL
- en: Any database operation can fail. If you know how to find out when that occurs
    and why, you can take appropriate action such as terminating the program or informing
    the user of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Executing SQL statements and retrieving results
  prefs: []
  type: TYPE_NORMAL
- en: The point of connecting to a database server is to execute SQL statements. Each
    API provides at least one way to do this, as well as methods for processing statement
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Handling special characters and `NULL` values in statements
  prefs: []
  type: TYPE_NORMAL
- en: Data values can be embedded directly in statement strings. However, some characters
    such as quotes and backslashes have special meaning, and their use requires certain
    precautions. The same is true for `NULL` values. If you handle these improperly,
    your programs will generate SQL statements that are erroneous or yield unexpected
    results. If you incorporate data from external sources into queries, your program
    might become subject to SQL injection attacks. Most APIs enable you to avoid these
    problems by using placeholders, which refer to data values symbolically in a statement
    to be executed and supply those values separately. The API inserts data into the
    statement string after properly encoding any special characters or `NULL` values.
    Placeholders are also known as parameter markers.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying `NULL` values in result sets
  prefs: []
  type: TYPE_NORMAL
- en: '`NULL` values are special not only when you construct statements, but also
    in results returned from them. Each API provides a convention for recognizing
    and dealing with them.'
  prefs: []
  type: TYPE_NORMAL
- en: No matter which programming language you use, it’s necessary to know how to
    perform each of the fundamental database API operations just described, so this
    chapter shows each operation in all five languages. Seeing how each API handles
    a given operation should help you see the correspondences between APIs more easily
    and better understand the recipes shown in the following chapters, even if they’re
    written in a language you don’t use much. (Later chapters usually implement recipes
    using only one or two languages.)
  prefs: []
  type: TYPE_NORMAL
- en: It may seem overwhelming to see each recipe in several languages if your interest
    is in only one particular API. If so, we advise you to read just the introductory
    recipe part that provides the general background, then go directly to the section
    for the language in which you’re interested. Skip the other languages; should
    you develop an interest in them later, come back and read about them then.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter also discusses the following topics, which are not directly part
    of the MySQL APIs but help you use them more easily:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing library files
  prefs: []
  type: TYPE_NORMAL
- en: As you write program after program, you find that you carry out certain operations
    repeatedly. Library files enable encapsulating code for those operations so they
    can be performed easily from multiple scripts without repeating the code in each
    one. This reduces code duplication and makes your programs more portable. This
    chapter shows how to write a library file for each API that includes a routine
    for connecting to the server—one operation that every program that uses MySQL
    must perform. Later chapters develop additional library routines for other operations.
  prefs: []
  type: TYPE_NORMAL
- en: Additional techniques for obtaining connection parameters
  prefs: []
  type: TYPE_NORMAL
- en: An early section on establishing connections to the MySQL server relies on connection
    parameters hardwired into the code. However, there are other (and better) ways
    to obtain parameters, ranging from storing them in a separate file to enabling
    the user to specify them at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid manually typing in the example programs, get a copy of the `recipes`
    source distribution (see the [Preface](preface01.xhtml#nch-preface)). Then, when
    an example says something like <q>create a file named *xyz* that contains the
    following information ...,</q> you can use the corresponding file from the `recipes`
    distribution. Most scripts for this chapter are located under the *api* directory;
    library files are located in the *lib* directory.
  prefs: []
  type: TYPE_NORMAL
- en: The primary table used for examples in this chapter is named `profile`. It first
    appears in [Recipe 4.4](#nch-api-api-statement), which you should know in case
    you skip around in the chapter and wonder where it came from. See also the section
    at the very end of the chapter about resetting the `profile` table to a known
    state for use in other chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The programs discussed here can be run from the command line. For instructions
    on invoking programs for each language covered here, read `cmdline.pdf` in the
    recipes distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Assumptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the material in this chapter most effectively, make sure to satisfy
    these requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Install MySQL programming support for any languages that you plan to use (see
    the [Preface](preface01.xhtml#nch-preface)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should already have set up a MySQL user account for accessing the server
    and a database for executing SQL statements. As described in [Recipe 1.1](ch01.xhtml#nch-mysql-mysql-account),
    the examples in this book use a MySQL account that has a username and password
    of `cbuser` and `cbpass`, and we’ll connect to a MySQL server running on the local
    host to access a database named `cookbook`. To create the account or the database,
    see the instructions in that recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The discussion here shows how to use each API language to perform database operations,
    but assumes a basic understanding of the language itself. If a recipe uses programming
    constructs with which you’re unfamiliar, consult a general reference for the language
    of interest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper execution of some of the programs might require that you set certain
    environment variables. General syntax for doing so is covered in `cmdline.pdf`
    in the recipes distribution (see the [Preface](preface01.xhtml#nch-preface)).
    For details about environment variables that apply specifically to library file
    locations, see [Recipe 4.3](#nch-api-api-library).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL Client API Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each MySQL programming interface covered in this book uses a two-level architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The upper level provides database-independent methods that implement database
    access in a portable way that’s the same whether you use MySQL, PostgreSQL, Oracle,
    or whatever.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lower level consists of a set of drivers, each of which implements the details
    for a single database system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This two-level architecture enables application programs to use an abstract
    interface not tied to details specific to any particular database server. This
    enhances portability of your programs: to use a different database system, just
    select a different lower-level driver. However, perfect portability is elusive:'
  prefs: []
  type: TYPE_NORMAL
- en: The interface methods provided by the upper level of the architecture are consistent
    regardless of the driver you use, but it’s still possible to write SQL statements
    that use constructs supported only by a particular server. For example, MySQL
    has `SHOW` statements that provide information about database and table structure,
    but using `SHOW` with a non-MySQL server likely will produce an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower-level drivers often extend the abstract interface to make it more convenient
    to access database-specific features. For example, the MySQL driver for Perl DBI
    makes the most recent `AUTO_INCREMENT` value available as a database handle attribute
    accessible as `$dbh->{mysql_insertid}`. Such features make a program easier to
    write, but less portable. To use the program with another database system will
    require some rewriting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite these factors that compromise portability to some extent, the general
    portability characteristics of the two-level architecture provide significant
    benefits for MySQL developers.
  prefs: []
  type: TYPE_NORMAL
- en: Another characteristic common to the APIs used in this book is that they are
    object oriented. Whether you write in Perl, Ruby, PHP, Python, Java or Go, the
    operation that connects to the MySQL server returns an object that enables you
    to process statements in an object-oriented manner. For example, when you connect
    to the database server, you get a database connection object with which to further
    interact with the server. The interfaces also provide objects for statements,
    result sets, metadata, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how to use these programming interfaces to perform the most fundamental
    MySQL operations: connecting to and disconnecting from the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Connecting, Selecting a Database, and Disconnecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to establish a connection to the database server and shut down the
    connection when you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each API provides routines for connecting and disconnecting. The connection
    routines require that you provide parameters specifying the host on which the
    MySQL server is running and the MySQL account to use. You can also select a default
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section shows how to perform some fundamental operations common to most
    MySQL programs:'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a connection to the MySQL server
  prefs: []
  type: TYPE_NORMAL
- en: Every program that uses MySQL does this, no matter which API you use. The details
    on specifying connection parameters vary between APIs, and some APIs provide more
    flexibility than others. However, there are many common parameters, such as the
    host on which the server is running, and the username and password of the MySQL
    account to use for accessing the server.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a database
  prefs: []
  type: TYPE_NORMAL
- en: Most MySQL programs select a default database.
  prefs: []
  type: TYPE_NORMAL
- en: Disconnecting from the server
  prefs: []
  type: TYPE_NORMAL
- en: Each API provides a way to close an open connection. It’s best to do so as soon
    as you’re done using the server. If your program holds the connection open longer
    than necessary, the server cannot free up resources allocated to servicing the
    connection. It’s also preferable to close the connection explicitly. If a program
    simply terminates, the MySQL server eventually notices, but an explicit close
    on the user end enables the server to perform an immediate orderly close on its
    end.
  prefs: []
  type: TYPE_NORMAL
- en: This section includes example programs that show how to use each API to connect
    to the server, select the `cookbook` database, and disconnect. The discussion
    for each API also indicates how to connect without selecting any default database.
    This might be the case if you plan to execute a statement that doesn’t require
    a default database, such as `SHOW` `VARIABLES` or `SELECT` `VERSION()`. Or perhaps
    you’re writing a program that enables the user to specify the database after the
    connection has been made.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The scripts shown here use `localhost` as the hostname. If they produce a connection
    error indicating that a socket file cannot be found, try changing `localhost`
    to `127.0.0.1`, the TCP/IP address of the local host. This tip applies throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To write MySQL scripts in Perl, the DBI module must be installed, as well as
    the MySQL-specific driver module, DBD::mysql. To obtain these modules if they’re
    not already installed, see the [Preface](preface01.xhtml#nch-preface).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Perl script, *connect.pl*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To try *connect.pl*, locate it under the *api* directory of the `recipes` distribution
    and run it from the command line. The program should print two lines indicating
    that it connected and disconnected successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the rest of the section we will walk through the code and explain how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you get `Access Denied` error when connect to MySQL 8.0 ensure that the version
    of DBD::MySQL is linked with the MySQL 8.0 client library or use authentication
    plugin `mysql_native_password` instead of default `caching_sha2_password` plugin.
    We discuss authentication plugins in [Recipe 24.2](ch24.xhtml#nch-security-account-management)
  prefs: []
  type: TYPE_NORMAL
- en: For background on running Perl programs, read `cmdline.pdf` in the recipes distribution
    (see the [Preface](preface01.xhtml#nch-preface)).
  prefs: []
  type: TYPE_NORMAL
- en: The `use` `strict` line turns on strict variable checking and causes Perl to
    complain about any variables that are used without having been declared first.
    This precaution helps find errors that might otherwise go undetected.
  prefs: []
  type: TYPE_NORMAL
- en: The `use` `warnings` line turns on warning mode so that Perl produces warnings
    for any questionable constructs. Our example script has none, but it’s a good
    idea to get in the habit of enabling warnings to catch problems that occur during
    the script development process. `use` `warnings` is similar to specifying the
    Perl `-w` command-line option, but provides more control over which warnings to
    display. (For more information, execute a *perldoc* *warnings* command.)
  prefs: []
  type: TYPE_NORMAL
- en: The `use` `DBI` statement tells Perl to load the DBI module. It’s unnecessary
    to load the MySQL driver module (DBD::mysql) explicitly. DBI does that itself
    when the script connects to the database server.
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines establish the connection to MySQL by setting up a data source
    name (DSN) and calling the DBI `connect()` method. The arguments to `connect()`
    are the DSN, the MySQL username and password, and any connection attributes you
    want to specify. The DSN is required. The other arguments are optional, although
    usually it’s necessary to supply a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: The DSN specifies which database driver to use and other options that indicate
    where to connect. For MySQL programs, the DSN has the format ``DBI:mysql:*`options`*``.
    The second colon in the DSN is required even if you specify no following options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the DSN components as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first component is always `DBI`. It’s not case sensitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second component tells DBI which database driver to use, and it *is* case
    sensitive. For MySQL, the name must be `mysql`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third component, if present, is a semicolon-separated list of *`name`*`=`*`value`*
    pairs that specify additional connection options, in any order. For our purposes,
    the two most relevant options are `host` and `database`, to specify the hostname
    where the MySQL server is running and the default database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on that information, the DSN for connecting to the `cookbook` database
    on the local host *localhost* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the `host` option, its default value is `localhost`. These two
    DSNs are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To select no default database, omit the `database` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second and third arguments of the `connect()` call are your MySQL username
    and password. Following the password, you can also provide a fourth argument to
    specify attributes that control DBI’s behavior when errors occur. With no attributes,
    DBI by default prints error messages when errors occur but does not terminate
    your script. That’s why *connect.pl* checks whether `connect()` returns `undef`,
    which indicates failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Other error-handling strategies are possible. For example, to tell DBI to terminate
    the script if an error occurs in any DBI call, disable the `PrintError` attribute
    and enable `RaiseError` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then you need not check for errors yourself. The trade-off is that you also
    lose the ability to decide how your program recovers from errors. [Recipe 4.2](#nch-api-api-error)
    discusses error handling further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common attribute is `AutoCommit`, which sets the connection’s auto-commit
    mode for transactions. MySQL enables this by default for new connections, but
    we’ll set it from this point on to make the initial connection state explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, the fourth argument to `connect()` is a reference to a hash of attribute
    name/value pairs. An alternative way of writing this code follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Use whichever style you prefer. Scripts in this book use the `$conn_attr` hashref
    to make `connect()` calls simpler to read.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that `connect()` succeeds, it returns a database handle that contains
    information about the state of the connection. (In DBI parlance, references to
    objects are called handles.) Later we’ll see other handles such as statement handles,
    which are associated with particular statements. Perl DBI scripts in this book
    conventionally use `$dbh` and `$sth` to signify database and statement handles.
  prefs: []
  type: TYPE_NORMAL
- en: Additional connection parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To specify the path to a socket file for *localhost* connections on Unix, provide
    a `mysql_socket` option in the DSN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify the port number for non-*localhost* (TCP/IP) connections, provide
    a `port` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To write MySQL scripts in Ruby, the Mysql2 gem must be installed. To obtain
    this gem if it is not already installed, see the [Preface](preface01.xhtml#nch-preface).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Ruby script, *connect.rb*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To try *connect.rb*, locate it under the *api* directory of the `recipes` distribution
    and run it from the command line. The program should print two lines indicating
    that it connected and disconnected successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For background on running Ruby programs, read `cmdline.pdf` in the recipes distribution
    (see the [Preface](preface01.xhtml#nch-preface)).
  prefs: []
  type: TYPE_NORMAL
- en: The `-w` option turns on warning mode so that Ruby produces warnings for any
    questionable constructs. Our example script has no such constructs, but it’s a
    good idea to get in the habit of using `-w` to catch problems that occur during
    the script development process.
  prefs: []
  type: TYPE_NORMAL
- en: The `require` statement tells Ruby to load the Mysql2 module.
  prefs: []
  type: TYPE_NORMAL
- en: To establish the connection, create a `Mysql2::Client` object. Pass connection
    parameters as named arguments for the method `new`.
  prefs: []
  type: TYPE_NORMAL
- en: To select no default database, omit the `database` option.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the `Mysql2::Client` object successfully created, it will act
    as a database handle that contains information about the state of the connection.
    Ruby scripts in this book conventionally use `client` to signify a database handle
    object.
  prefs: []
  type: TYPE_NORMAL
- en: If the `new()` method fails, it raises an exception. To handle exceptions, put
    the statements that might fail inside a `begin` block, and use a `rescue` clause
    that contains the error-handling code. Exceptions that occur at the top level
    of a script (that is, outside of any `begin` block) are caught by the default
    exception handler, which prints a stack trace and exits. [Recipe 4.2](#nch-api-api-error)
    discusses error handling further.
  prefs: []
  type: TYPE_NORMAL
- en: Additional connection parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To specify the path to a socket file for *localhost* connections on Unix, provide
    a `socket` option for the method `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify the port number for non-*localhost* (TCP/IP) connections, provide
    a `port` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To write PHP scripts that use MySQL, your PHP interpreter must have MySQL support
    compiled in. If your scripts are unable to connect to your MySQL server, check
    the instructions included with your PHP distribution to see how to enable MySQL
    support.
  prefs: []
  type: TYPE_NORMAL
- en: PHP actually has multiple extensions that enable the use of MySQL, such as `mysql`,
    the original (and now deprecated) MySQL extension; `mysqli`, the <q>MySQL improved</q>
    extension; and, more recently, the MySQL driver for the PDO (PHP Data Objects)
    interface. PHP scripts in this book use PDO. To obtain PHP and PDO if they’re
    not already installed, see the [Preface](preface01.xhtml#nch-preface).
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP scripts usually are written for use with a web server. I assume that if
    you use PHP that way, you can copy PHP scripts into your server’s document tree,
    request them from your browser, and they will execute. For example, if you run
    Apache as the web server on the host *localhost* and you install a PHP script
    named *myscript.php* at the top level of the Apache document tree, you should
    be able to access the script by requesting this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This book uses the *.php* extension (suffix) for PHP script filenames, so your
    web server must be configured to recognize the *.php* extension. Otherwise, when
    you request a PHP script from your browser, the server simply sends the literal
    text of the script and that’s what appears in your browser window. You don’t want
    this to happen, particularly if the script contains the username and password
    for connecting to MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP scripts often are written as a mixture of HTML and PHP code, with the PHP
    code embedded between the special `<?php` and `?>` tags. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For brevity in examples consisting entirely of PHP code, typically I’ll omit
    the enclosing `<?php` and `?>` tags. If you see no tags in a PHP example, assume
    that `<?php` and `?>` surround the entire block of code that is shown. Examples
    that switch between HTML and PHP code do include the tags, to make it clear what
    is PHP code and what is not.
  prefs: []
  type: TYPE_NORMAL
- en: PHP can be configured to recognize <q>short</q> tags as well, written as `<?`
    and `?>`. This book does not assume that you have short tags enabled and does
    not use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following PHP script, *connect.php*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To try *connect.php*, locate it under the *api* directory of the `recipes`
    distribution, copy it to your web server’s document tree, and request it using
    your browser. Alternatively, if you have a standalone version of the PHP interpreter
    for use from the command line, execute the script directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For background on running PHP programs, read `cmdline.pdf` in the recipes distribution
    (see the [Preface](preface01.xhtml#nch-preface)).
  prefs: []
  type: TYPE_NORMAL
- en: '`$dsn` is the data source name (DSN) that indicates how to connect to the database
    server. It has this general syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The *`driver`* value is the PDO driver type. For MySQL, this is `mysql`.
  prefs: []
  type: TYPE_NORMAL
- en: Following the driver name, semicolon-separated *`name`*`=`*`value`* pairs specify
    connection parameters, in any order. For our purposes, the two most relevant options
    are `host` and `dbname`, to specify the hostname where the MySQL server is running
    and the default database. To select no default database, omit the `dbname` option.
  prefs: []
  type: TYPE_NORMAL
- en: To establish the connection, invoke the `new` `PDO()` class constructor, passing
    to it the appropriate arguments. The DSN is required. The other arguments are
    optional, although usually it’s necessary to supply a username and password. If
    the connection attempt succeeds, `new` `PDO()` returns a database-handle object
    that is used to access other MySQL-related methods. PHP scripts in this book conventionally
    use `$dbh` to signify a database handle.
  prefs: []
  type: TYPE_NORMAL
- en: If the connection attempt fails, PDO raises an exception. To handle this, put
    the connection attempt within a `try` block and use a `catch` block that contains
    the error-handling code, or just let the exception terminate your script. [Recipe
    4.2](#nch-api-api-error) discusses error handling further.
  prefs: []
  type: TYPE_NORMAL
- en: To disconnect, set the database handle to `NULL`. There is no explicit disconnect
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Additional connection parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To specify the path to a socket file for *localhost* connections on Unix, provide
    a `unix_socket` option in the DSN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify the port number for non-*localhost* (TCP/IP) connections, provide
    a `port` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To write MySQL programs in Python, a module must be installed that provides
    MySQL connectivity for the Python DB API, also known as Python Database API Specification
    v2.0 (PEP 249). This book uses MySQL Connector/Python. To obtain it if it’s not
    already installed, see the [Preface](preface01.xhtml#nch-preface).
  prefs: []
  type: TYPE_NORMAL
- en: To use the DB API, import the database driver module that you want to use (which
    is `mysql.connector` for MySQL programs that use Connector/Python). Then create
    a database connection object by calling the driver’s `connect()` method. This
    object provides access to other DB API methods, such as the `close()` method that
    serves the connection to the database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python script, *connect.py*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To try *connect.py*, locate it under the *api* directory of the `recipes` distribution
    and run it from the command line. The program should print two lines indicating
    that it connected and disconnected successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For background on running Python programs, read `cmdline.pdf` in the recipes
    distribution (see the [Preface](preface01.xhtml#nch-preface)).
  prefs: []
  type: TYPE_NORMAL
- en: The `import` line tells Python to load the `mysql.connector` module. Then the
    script attempts to establish a connection to the MySQL server by calling `connect()`
    to obtain a connection object. Python scripts in this book conventionally use
    `conn` to signify connection objects.
  prefs: []
  type: TYPE_NORMAL
- en: If the `connect()` method fails, Connector/Python raises an exception. To handle
    exceptions, put the statements that might fail inside a `try` statement and use
    an `except` clause that contains the error-handling code. Exceptions that occur
    at the top level of a script (that is, outside of any `try` statement) are caught
    by the default exception handler, which prints a stack trace and exits. [Recipe
    4.2](#nch-api-api-error) discusses error handling further.
  prefs: []
  type: TYPE_NORMAL
- en: The `else` clause contains statements that execute if the `try` clause produces
    no exception. It’s used here to close the successfully opened connection.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `connect()` call uses named arguments, their order does not matter.
    If you omit the `host` argument from the `connect()` call, its default value is
    `127.0.0.1`. To select no default database, omit the `database` argument or pass
    a `database` value of `""` (the empty string) or `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to connect is to specify the parameters using a Python dictionary
    and pass the dictionary to `connect()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This book generally uses that style from now on.
  prefs: []
  type: TYPE_NORMAL
- en: Additional connection parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To specify the path to a socket file for local host connections on Unix, omit
    the `host` parameter and provide a `unix_socket` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify the port number for TCP/IP connections, include the `host` parameter
    and provide an integer-valued `port` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To write MySQL programs in Go, a Go SQL Driver must be installed. This book
    uses [Go-MySQL-Driver](https://github.com/go-sql-driver/mysql). To obtain it if
    it’s not already installed, install *Git*, then issue the following command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To use the Go SQL interface, import `database/sql` package and your driver package.
    Then create a database connection object by calling the `sql.Open()` function.
    This object provides access to other `database/sql` package functions, such as
    the `db.Close()` that closes the connection to the database server. We also use
    `defer` statement to call the `db.Close()` to make sure the function call is performed
    later in the program execution. You will see this usage throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Go package `database/sql` and the Go-MySQL-Driver support context cancellation.
    This means that you can cancel database operations, such as running a query, if
    cancel the context. To use this feature you need to call context-aware functions
    of the `sql` interface. For the brevity we would not use `Context` in our examples
    in this chapter. We will have example of using `Context` when discuss transaction
    handling in [Recipe 20.9](ch20.xhtml#nch-xact-xact-go-context).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Go script, *connect.go*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To try *connect.go*, locate it under the *api/01_connect* directory of the
    `recipes` distribution and run it from the command line. The program should print
    single line indicating that it connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `import` line tells Go to load the `go-sql-driver/mysql` package. Then the
    script validates connection parameters and obtains a connection object by calling
    `sql.Open()`. *No MySQL connection established yet!*
  prefs: []
  type: TYPE_NORMAL
- en: If the `sql.Open()` method fails, `go-sql-driver/mysql` returns an error. To
    handle the error, store it into a variable (in our example `err`) and use an `if`
    block that contains the error-handling code. [Recipe 4.2](#nch-api-api-error)
    discusses error handling further.
  prefs: []
  type: TYPE_NORMAL
- en: The `db.Ping()` call establishes the database connection. Only at this moment
    we can say that we connected to the MySQL server successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Additional connection parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To specify the path to a socket file for local host connections on Unix, omit
    the `tcp` parameter in the DSN and provide a `unix` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify the port number for TCP/IP connections, include the `tcp` parameter
    into the DSN and provide an integer-valued `port` port number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Go accepts DSN (Data Source Name) in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Where `protocol` could be either `tcp` or `unix`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A DSN in its fullest form is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Database programs in Java use the JDBC interface, together with a driver for
    the particular database engine you want to access. That is, the JDBC architecture
    provides a generic interface used in conjunction with a database-specific driver.
  prefs: []
  type: TYPE_NORMAL
- en: Java programming requires a Java Development Kit (JDK), and you must set your
    `JAVA_HOME` environment variable to the location where your JDK is installed.
    To write MySQL-based Java programs, you’ll also need a MySQL-specific JDBC driver.
    Programs in this book use MySQL Connector/J. To obtain it if it’s not already
    installed, see the Preface. For information about obtaining a JDK and setting
    `JAVA_HOME`, read `cmdline.pdf` in the recipes distribution (see the [Preface](preface01.xhtml#nch-preface)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Java program, *Connect.java*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To try *Connect.java*, locate it under the *api* directory of the `recipes`
    distribution, compile it, and execute it. The `class` statement indicates the
    program’s name, which in this case is `Connect`. The name of the file containing
    the program must match this name and include a *.java* extension, so the filename
    for the program is *Connect.java*. Compile the program using *javac*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer a different Java compiler, substitute its name for *javac*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java compiler generates compiled byte code to produce a class file named
    *Connect.class*. Use the *java* program to run the class file (specified without
    the *.class* extension). The program should print two lines indicating that it
    connected and disconnected successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You might need to set your `CLASSPATH` environment variable before the example
    program will compile and run. The value of `CLASSPATH` should include at least
    your current directory (`.`) and the path to the Connector/J JDBC driver. For
    background on running Java programs or setting `CLASSPATH`, read `cmdline.pdf`
    in the recipes distribution (see the [Preface](preface01.xhtml#nch-preface)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Starting from Java 11, you can skip *javac* call for a single-file program
    and run it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `import` `java.sql.*` statement references the classes and interfaces that
    provide access to the data types used to manage different aspects of your interaction
    with the database server. These are required for all JDBC programs.
  prefs: []
  type: TYPE_NORMAL
- en: To connect to the server call `DriverManager.getConnection()` to initiate the
    connection and obtain a `Connection` object that maintains information about the
    state of the connection. Java programs in this book conventionally use `conn`
    to signify connection objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`DriverManager.getConnection()` takes three arguments: a URL that describes
    where to connect and the database to use, the MySQL username, and the password.
    The URL string has this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This format follows the Java convention that the URL for connecting to a network
    resource begins with a protocol designator. For JDBC programs, the protocol is
    `jdbc`, and you’ll also need a subprotocol designator that specifies the driver
    name (`mysql`, for MySQL programs). Many parts of the connection URL are optional,
    but the leading protocol and subprotocol designators are not. If you omit *`host_name`*,
    the default host value is `localhost`. To select no default database, omit the
    database name. However, you should not omit any of the slashes in any case. For
    example, to connect to the local host without selecting a default database, the
    URL is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In JDBC, you don’t test method calls for return values that indicate an error.
    Instead, provide handlers to be called when exceptions are thrown. [Recipe 4.2](#nch-api-api-error)
    discusses error handling further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some JDBC drivers (Connector/J among them) permit you to specify the username
    and password as parameters at the end of the URL. In this case, omit the second
    and third arguments of the `getConnection()` call. Using that URL style, write
    the code that establishes the connection in the example program like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The character that separates the `user` and `password` parameters should be
    `&`, not `;`.
  prefs: []
  type: TYPE_NORMAL
- en: Additional connection parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Connector/J does not natively support Unix domain socket file connections,
    so even connections for which the hostname is *localhost* are made via TCP/IP.
    To specify an explicit port number, add `:`*`port_num`* to the hostname in the
    connection URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: However, you can use 3rd-party libraries that provide support for connections
    via socket. See [Connecting Using Unix Domain Sockets](https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-unix-socket.html)
    user reference manual page for details.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Checking for Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something went wrong with your program, and you don’t know what.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everyone has problems getting programs to work correctly. But if you don’t anticipate
    problems by checking for errors, the job becomes much more difficult. Add some
    error-checking code so your programs can help you figure out what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After working through [Recipe 4.1](#nch-api-api-connect), you know how to connect
    to the MySQL server. It’s also a good idea to know how to check for errors and
    how to retrieve specific error information from the API, so we cover that next.
    You’re probably anxious to do more interesting things (such as executing statements
    and getting back the results), but error checking is fundamentally important.
    Programs sometimes fail, especially during development, and if you can’t determine
    why failures occur, you’re flying blind. Plan for failure by checking for errors
    so that you can take appropriate action.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an error occurs, MySQL provides three values:'
  prefs: []
  type: TYPE_NORMAL
- en: A MySQL-specific error number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A MySQL-specific descriptive text error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A five-character SQLSTATE error code defined according to the ANSI and ODBC
    standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe show how to access this information. The example programs are deliberately
    designed to fail, so that the error-handling code executes. That’s why they attempt
    to connect using a username and password of `baduser` and `badpass`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A general debugging aid not specific to any API is to use the available logs.
    Check the MySQL server’s general query log to see what statements the server is
    receiving. (This requires that log to be enabled; see [Recipe 22.3](ch22.xhtml#nch-admin-server-logs).)
    The general query log might show that your program is not constructing the SQL
    statement string you expect. Similarly, if you run a script under a web server
    and it fails, check the web server’s error log.
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DBI module provides two attributes that control what happens when DBI method
    invocations fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintError`, if enabled, causes DBI to print an error message using `warn()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RaiseError`, if enabled, causes DBI to print an error message using `die()`.
    This terminates your script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, `PrintError` is enabled and `RaiseError` is disabled, so a script
    continues executing after printing a message if an error occurs. Either or both
    attributes can be specified in the `connect()` call. Setting an attribute to 1
    or 0 enables or disables it, respectively. To specify either or both attributes,
    pass them in a hash reference as the fourth argument to the `connect()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sets only the `AutoCommit` attribute and uses the default
    settings for the error-handling attributes. If the `connect()` call fails, a warning
    message results, but the script continues to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Because you really can’t do much if the connection attempt fails, it’s often
    prudent to exit instead after DBI prints a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To print your own error messages, leave `RaiseError` disabled and disable `PrintError`
    as well. Then test the results of DBI method calls yourself. When a method fails,
    the `$DBI::err`, `$DBI::errstr`, and `$DBI::state` variables contain the MySQL
    error number, a descriptive error string, and the SQLSTATE value, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If no error occurs, `$DBI::err` is 0 or `undef`, `$DBI::errstr` is the empty
    string or `undef`, and `$DBI::state` is empty or `00000`.
  prefs: []
  type: TYPE_NORMAL
- en: When you check for errors, access these variables immediately after invoking
    the DBI method that sets them. If you invoke another method before using them,
    DBI resets their values.
  prefs: []
  type: TYPE_NORMAL
- en: If you print your own messages, the default settings (`PrintError` enabled,
    `RaiseError` disabled) are not so useful. DBI prints a message automatically,
    then your script prints its own message. This is redundant, as well as confusing
    to the person using the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you enable `RaiseError`, you can call DBI methods without checking for return
    values that indicate errors. If a method fails, DBI prints an error and terminates
    your script. If the method returns, you can assume it succeeded. This is the easiest
    approach for script writers: let DBI do all the error checking! However, if both
    `PrintError` and `RaiseError` are enabled, DBI may call `warn()` and `die()` in
    succession, resulting in error messages being printed twice. To avoid this problem,
    disable `PrintError` whenever you enable `RaiseError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This book generally uses that approach. If you don’t want the all-or-nothing
    behavior of enabling `RaiseError` for automatic error checking versus having to
    do all your own checking, adopt a mixed approach. Individual handles have `PrintError`
    and `RaiseError` attributes that can be enabled or disabled selectively. For example,
    you can enable `RaiseError` globally by turning it on when you call `connect()`,
    and then disable it selectively on a per-handle basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that a script reads the username and password from the command-line
    arguments, and then loops while the user enters statements to be executed. In
    this case, you’d probably want DBI to die and print the error message automatically
    if the connection fails (you cannot proceed to the statement-execution loop in
    that case). After connecting, however, you wouldn’t want the script to exit just
    because the user enters a syntactically invalid statement. Instead, print an error
    message and loop to get the next statement. The following code shows how to do
    this. The `do()` method used in the example executes a statement and returns `undef`
    to indicate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If `RaiseError` is enabled, you can execute code within an `eval` block to
    trap errors without terminating your program. If an error occurs, `eval` returns
    a message in the `$@` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This `eval` technique is commonly used to perform transactions (see [Recipe
    20.4](ch20.xhtml#nch-xact-xact-perl)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `RaiseError` in combination with `eval` differs from using `RaiseError`
    alone:'
  prefs: []
  type: TYPE_NORMAL
- en: Errors terminate only the `eval` block, not the entire script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any error terminates the `eval` block, whereas `RaiseError` applies only to
    DBI-related errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you use `eval` with `RaiseError` enabled, disable `PrintError`. Otherwise,
    in some versions of DBI, an error may simply cause `warn()` to be called without
    terminating the `eval` block as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to using the error-handling attributes `PrintError` and `RaiseError`,
    lots of information about your script’s execution is available using DBI’s tracing
    mechanism. Invoke the `trace()` method with an argument indicating the trace level.
    Levels 1 to 9 enable tracing with increasingly more verbose output, and level
    0 disables tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Individual database and statement handles also have `trace()` methods, so you
    can localize tracing to a single handle if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trace output normally goes to your terminal (or, in the case of a web script,
    to the web server’s error log). To write trace output to a specific file, provide
    a second argument that indicates the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If the trace file already exists, its contents are not cleared first; trace
    output is appended to the end. Beware of turning on a file trace while developing
    a script, but forgetting to disable the trace when you put the script into production.
    You’ll eventually find to your chagrin that the trace file has become quite large.
    Or worse, a filesystem will fill up, and you’ll have no idea why!
  prefs: []
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ruby signals errors by raising exceptions and Ruby programs handle errors by
    catching exceptions in a `rescue` clause of a `begin` block. Ruby Mysql2 methods
    raise exceptions when they fail and provide error information by means of a `Mysql2::Error`
    object. To get the MySQL error number, error message, and SQLSTATE value, access
    the `errno`, `message`, and `sql_state` methods of this object. The following
    example shows how to trap exceptions and access error information in a Ruby script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `new` `PDO()` constructor raises an exception if it fails, but other PDO
    methods by default indicate success or failure by their return value. To cause
    all PDO methods to raise exceptions for errors, use the database handle resulting
    from a successful connection attempt to set the error-handling mode. This enables
    uniform handling of all PDO errors without checking the result of every call.
    The following example shows how to set the error mode if the connection attempt
    succeeds and how to handle exceptions if it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When PDO raises an exception, the resulting `PDOException` object provides error
    information. The `getCode()` method returns the SQLSTATE value. The `getMessage()`
    method returns a string containing the SQLSTATE value, MySQL error number, and
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Database and statement handles also provide information when an error occurs.
    For either type of handle, `errorCode()` returns the SQLSTATE value and `errorInfo()`
    returns a three-element array containing the SQLSTATE value and a driver-specific
    error code and message. For MySQL, the latter two values are the error number
    and message string. The following example demonstrates how to get information
    from the exception object and the database handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python signals errors by raising exceptions, and Python programs handle errors
    by catching exceptions in the `except` clause of a `try` statement. To obtain
    MySQL-specific error information, name an exception class, and provide a variable
    to receive the information. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If an exception occurs, the `errno`, `msg`, and `sqlstate` members of the exception
    object contain the error number, error message, and SQLSTATE values, respectively.
    Note that access to the `Error` class is through the driver module name.
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go does not support exceptions. Instead, its multi-value returns make it easy
    to pass error when needed. To handle errors in Go, store returned value of the
    type `Error` into a variable (we use variable name `err` here) and handle it accordingly.
    To handle errors Go offers `defer` statement, `Panic()` and `Recover()` built-in
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. Error handling in Go
  prefs: []
  type: TYPE_NORMAL
- en: '| Function or statement | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `defer` | Defers statement execution until the calling function returns.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Panic()` | The calling function normal execution stops, all deferred functions
    are executed, then the function returns a call to panic up the stack. The process
    continues. Finally, the program crashes. |'
  prefs: []
  type: TYPE_TB
- en: '| `Recover()` | Allows to regain control in the panicking goroutine, so the
    program would not crash and continue executing. Only works in the deferred functions.
    If called in the function that is not deferred, does nothing and returns `nil`.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If an error occurs, the function returns an object of the type `error`. Its
    function `Error()` returns MySQL error code and message for the errors, raised
    by the `Go-MySQL-Driver`.
  prefs: []
  type: TYPE_NORMAL
- en: There is exceptional case for the function `QueryRow()` with subsequent `Scan()`
    call. By default `Scan()` returns `nil` if there is no error and `error` if there
    is any error. However, in case if the query run successfully but returned no rows
    this function returns `sql.ErrNoRows`.
  prefs: []
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Java programs handle errors by catching exceptions. To do the minimum amount
    of work, print a stack trace to inform the user where the problem lies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The stack trace shows the location of the problem but not necessarily what
    the problem was. Also, it may not be meaningful except to you, the program’s developer.
    To be more specific, print the error message and code associated with an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: All `Exception` objects support the `getMessage()` method. JDBC methods may
    throw exceptions using `SQLException` objects; these are like `Exception` objects
    but also support `getErrorCode()` and `getSQLState()` methods. `getErrorCode()`
    and `getMessage()` return the MySQL-specific error number and message string,
    and `getSQLState()` returns a string containing the SQLSTATE value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some methods generate `SQLWarning` objects to provide information about nonfatal
    warnings. `SQLWarning` is a subclass of `SQLException`, but warnings are accumulated
    in a list rather than thrown immediately. They don’t interrupt your program, and
    you can print them at your leisure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example program, *Error.java*, demonstrates how to access error
    messages by printing all the error information available to it. It attempts to
    connect to the MySQL server and prints exception information if the attempt fails.
    Then it executes a statement and prints exception and warning information if the
    statement fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 4.3 Writing Library Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You notice that you’re repeating code to perform common operations in multiple
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write routines to perform those operations, put them in a library file, and
    arrange for your programs to access the library. This enables you to write the
    code only once. You might need to set an environment variable so that your scripts
    can find the library.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section describes how to put code for common operations in library files.
    Encapsulation (or modularization) isn’t really a <q>recipe</q> so much as a programming
    technique. Its principal benefit is that you need not repeat code in each program
    you write. Instead, simply call a routine that’s in the library. For example,
    by putting the code for connecting to the `cookbook` database into a library routine,
    you need not write out all the parameters associated with making that connection.
    Simply invoke the routine from your program, and you’re connected.
  prefs: []
  type: TYPE_NORMAL
- en: Connection establishment isn’t the only operation you can encapsulate, of course.
    Later sections in this book develop other utility functions to be placed in library
    files. All such files, including those shown in this section, are located under
    the *lib* directory of the `recipes` distribution. As you write your own programs,
    be on the lookout for operations that you perform often and that are good candidates
    for inclusion in a library. Use the techniques in this section to write your own
    library files.
  prefs: []
  type: TYPE_NORMAL
- en: Library files have other benefits besides making it easier to write programs,
    such as promoting portability. If you write connection parameters directly into
    each program that connects to the MySQL server, you must change all those programs
    if you move them to another machine that uses different parameters. If instead
    you write your programs to connect to the database by calling a library routine,
    it’s necessary only to modify the affected library routine, not all the programs
    that use it.
  prefs: []
  type: TYPE_NORMAL
- en: Code encapsulation can also improve security. If you make a private library
    file readable only to yourself, only scripts run by you can execute routines in
    the file. Or suppose that you have some scripts located in your web server’s document
    tree. A properly configured server executes the scripts and sends their output
    to remote clients. But if the server becomes misconfigured somehow, the result
    can be that it sends your scripts to clients as plain text, thus displaying your
    MySQL username and password. If you place the code for establishing a connection
    to the MySQL server in a library file located outside the document tree, those
    parameters won’t be exposed to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be aware that if you install a library file to be readable by your web server,
    you don’t have much security if other developers use the same server. Any of those
    developers can write a web script to read and display your library file because,
    by default, the script runs with the permissions of the web server and thus will
    have access to the library.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes that follow demonstrate how to write, for each API, a library file
    that contains a routine for connecting to the `cookbook` database on the MySQL
    server. The calling program can use the error-checking techniques discussed in
    [Recipe 4.2](#nch-api-api-error) to determine whether a connection attempt fails.
    The connection routine for each language returns a database handle or connection
    object when it succeeds or raises an exception if the connection cannot be established.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries are of no utility in themselves, so the following discussion illustrates
    each one’s use by a short [<q>test harness</q>](https://en.wikipedia.org/wiki/Test_harness)
    program. To use any of these harness programs as the basis for creating new programs,
    make a copy of the file and add your own code between the connect and disconnect
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Library-file writing involves not only the question of what to put in the file
    but also subsidiary issues such as where to install the file so it is accessible
    by your programs, and (on multiuser systems such as Unix) how to set its access
    privileges so its contents aren’t exposed to people who shouldn’t see it.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a library-file installation location
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you install a library file in a directory that a language processor searches
    by default, programs written in that language need do nothing special to access
    the library. However, if you install a library file in a directory that the language
    processor does not search by default, you must tell your scripts how to find it.
    There are two common ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Most languages provide a statement that can be used within a script to add directories
    to the language processor search path. This requires that you modify each script
    that needs the library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set an environment or configuration variable that changes the language
    processor search path. With this approach, each user who executes scripts that
    require the library must set the appropriate variable. Alternatively, if the language
    processor has a configuration file, you might be able to set a parameter in the
    file that affects scripts globally for all users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll use the second approach. For our API languages, the [Table 4-3](#nch-api-api-library-path)
    shows the relevant variables. In each case, the variable value is a directory
    or list of directories:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3\. Default Library Paths
  prefs: []
  type: TYPE_NORMAL
- en: '| Language | Variable name | Variable type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Perl | `PERL5LIB` | Environment variable |'
  prefs: []
  type: TYPE_TB
- en: '| Ruby | `RUBYLIB` | Environment variable |'
  prefs: []
  type: TYPE_TB
- en: '| PHP | `include_path` | Configuration variable |'
  prefs: []
  type: TYPE_TB
- en: '| Python | `PYTHONPATH` | Environment variable |'
  prefs: []
  type: TYPE_TB
- en: '| Go | `GOPATH` | Environment variable |'
  prefs: []
  type: TYPE_TB
- en: '| Java | `CLASSPATH` | Environment variable |'
  prefs: []
  type: TYPE_TB
- en: For general information on setting environment variables, read `cmdline.pdf`
    in the recipes distribution (see the [Preface](preface01.xhtml#nch-preface)).
    You can use those instructions to set environment variables to the values in the
    following discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that you want to install library files in a directory that language
    processors do not search by default. For purposes of illustration, let’s use */usr/local/lib/mcb*
    on Unix and *C:\lib\mcb* on Windows. (To put the files somewhere else, adjust
    the pathnames in the variable settings accordingly. For example, you might want
    to use a different directory, or you might want to put libraries for each language
    in separate directories.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Unix, if you put Perl library files in the */usr/local/lib/mcb* directory,
    set the `PERL5LIB` environment variable appropriately. For a shell in the Bourne
    shell family (*sh*, *bash*, *ksh*), set the variable like this in the appropriate
    startup file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For the original Bourne shell, *sh*, you may need to split this into two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For a shell in the C shell family (*csh*, *tcsh*), set `PERL5LIB` like this
    in your *.login* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Under Windows, if you put Perl library files in *C:\lib\mcb*, set `PERL5LIB`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In each case, the variable value tells Perl to look in the specified directory
    for library files, in addition to any other directories it searches by default.
    If you set `PERL5LIB` to name multiple directories, the separator character between
    directory pathnames is colon (`:`) on Unix or semicolon (`;`) on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Specify the other environment variables (`RUBYLIB`, `PYTHONPATH`, and `CLASSPATH`)
    using the same syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Setting these environment variables as just discussed should suffice for scripts
    that you run from the command line. For scripts intended to be executed by a web
    server, you likely must configure the server as well so that it can find the library
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For PHP, the search path is defined by the value of the `include_path` variable
    in the *php.ini* PHP initialization file. On Unix, the file’s pathname is likely
    */usr/lib/php.ini* or */usr/local/lib/php.ini*. Under Windows, the file is likely
    found in the Windows directory or under the main PHP installation directory. To
    determine the location, run this commmand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the value of `include_path` in *php.ini* with a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify *`value`* using the same syntax as for environment variables that name
    directories. That is, it’s a list of directory names, with the names separated
    by colons on Unix or semicolons on Windows. On Unix, if you want PHP to look for
    include files in the current directory and in */usr/local/lib/mcb*, set `include_path`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, to search the current directory and *C:\lib\mcb*, set `include_path`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If PHP is running as an Apache module, restart Apache to make *php.ini* changes
    take effect.
  prefs: []
  type: TYPE_NORMAL
- en: Setting library-file access privileges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use a multiple-user system such as Unix, you must make decisions about
    library-file ownership and access mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a library file is private and contains code to be used only by you, place
    the file under your own account and make it accessible only to you. Assuming that
    a library file named *mylib* is already owned by you, you can make it private
    like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the library file is to be used only by your web server, install it in a
    server library directory and make it owned by and accessible only to the server
    user ID. You may need to be `root` to do this. For example, if the web server
    runs as `wwwusr`, the following commands make the file private to that user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the library file is public, you can place it in a location that your programming
    language searches automatically when it looks for libraries. (Most language processors
    search for libraries in some default set of directories, although this set can
    be influenced by setting environment variables as described previously.) You may
    need to be `root` to install files in one of these directories. Then you can make
    the file world readable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let’s construct a library for each API. Each section here demonstrates how
    to write the library file itself and discusses how to use the library from within
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Perl, library files are called modules and typically have an extension of
    *.pm* (<q>Perl module</q>). It’s conventional for the basename of a module file
    to be the same as the identifier on the `package` line in the file. The following
    file, *Cookbook.pm*, implements a module named `Cookbook`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The module encapsulates the code for establishing a connection to the MySQL
    server into a `connect()` method, and the `package` identifier establishes a `Cookbook`
    namespace for the module. To invoke the `connect()` method, use the module name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The final line of the module file is a statement that trivially evaluates to
    true. (If the module doesn’t return a true value, Perl assumes that something
    is wrong with it and exits.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Perl locates library files by searching the list of directories named in its
    `@INC` array. To check the default value of this variable on your system, invoke
    Perl as follows at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The last part of the output from the command shows the directories listed in
    `@INC`. If you install a library file in one of those directories, your scripts
    will find it automatically. If you install the module somewhere else, tell your
    scripts where to find it by setting the `PERL5LIB` environment variable, as discussed
    in the introductory part of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the *Cookbook.pm* module, try it from a test harness script,
    *harness.pl*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '*harness.pl* has no `use` `DBI` statement. It’s unnecessary because the `Cookbook`
    module itself imports DBI; any script that uses `Cookbook` also gains access to
    DBI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t catch connection errors explicitly with `eval`, you can write
    the script body more simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Perl catches any connection exception and terminates the script
    after printing the error message generated by the `connect()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following Ruby library file, *Cookbook.rb*, defines a `Cookbook` class
    that implements a `connect` class method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The `connect` method is defined in the library as `Cookbook.connect` because
    Ruby class methods are defined as *`class_name.method_name`*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby locates library files by searching the list of directories named in its
    `$LOAD_PATH` variable (also known as `$:`), which is an array. To check the default
    value of this variable on your system, use interactive Ruby to execute this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: If you install a library file in one of those directories, your scripts will
    find it automatically. If you install the file somewhere else, tell your scripts
    where to find it by setting the `RUBYLIB` environment variable, as discussed in
    the introductory part of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the *Cookbook.rb* library file, try it from a test harness
    script, *harness.rb*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '*harness.rb* has no `require` statement for the Mysql2 module. It’s unnecessary
    because the `Cookbook` module itself imports Mysql2; any script that imports `Cookbook`
    also gains access to Mysql2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a script to die if an error occurs without checking for an exception
    yourself, write the script body like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHP library files are written like regular PHP scripts. A *Cookbook.php* file
    that implements a `Cookbook` class with a `connect()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `connect()` routine within the class is declared using the `static` keyword
    to make it a class method rather than an instance method. This designates it as
    directly callable without instantiating an object through which to invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: The `new` `PDO()` constructor raises an exception if the connection attempt
    fails. Following a successful attempt, `connect()` sets the error-handling mode
    so that other PDO calls raise exceptions for failure as well. This way, individual
    calls need not be tested for an error return value.
  prefs: []
  type: TYPE_NORMAL
- en: Although most PHP examples throughout this book don’t show the `<?php` and `?>`
    tags, I’ve shown them as part of *Cookbook.php* here to emphasize that library
    files must enclose all PHP code within those tags. The PHP interpreter makes no
    assumptions about the contents of a library file when it begins parsing it because
    you might include a file that contains nothing but HTML. Therefore, you must use
    `<?php` and `?>` to specify explicitly which parts of the library file should
    be considered as PHP code rather than as HTML, just as you do in the main script.
  prefs: []
  type: TYPE_NORMAL
- en: PHP looks for libraries by searching the directories named in the `include_path`
    variable in the PHP initialization file, as described in the introductory part
    of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: PHP scripts often are placed in the document tree of your web server, and clients
    can request them directly. For PHP library files, we recommend that you place
    them somewhere outside the document tree, especially if (like *Cookbook.php*)
    they contain a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing *Cookbook.php* in one of the `include_path` directories, try
    it from a test harness script, *harness.php*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `require_once` statement accesses the *Cookbook.php* file that is required
    to use the `Cookbook` class. `require_once` is one of several PHP file-inclusion
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`require` and `include` instruct PHP to read the named file. They are similar,
    but `require` terminates the script if the file cannot be found; `include` produces
    only a warning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require_once` and `include_once` are like `require` and `include` except that
    if the file has already been read, its contents are not processed again. This
    is useful for avoiding multiple-declaration problems that can easily occur when
    library files include other library files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python libraries are written as modules and referenced from scripts using `import`
    statements. To create a method for connecting to MySQL, write a module file, *cookbook.py*
    (Python module names should be lowercase):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The filename basename determines the module name, so the module is called `cookbook`.
    Module methods are accessed through the module name; thus, import the `cookbook`
    module and invoke its `connect()` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python interpreter searches for modules in directories named in the `sys.path`
    variable. To check the default value of `sys.path` on your system, run Python
    interactively and enter a few commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: If you install *cookbook.py* in one of the directories named by `sys.path`,
    your scripts will find it with no special handling. If you install *cookbook.py*
    somewhere else, you must set the `PYTHONPATH` environment variable, as discussed
    in the introductory part of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the *cookbook.py* library file, try it from a test harness
    script, *harness.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The *cookbook.py* file imports the `mysql.connector` module, but a script that
    imports `cookbook` does not thereby gain access to `mysql.connector`. If the script
    needs Connector/Python-specific information (such as `mysql.connector.Error`),
    the script itself must import `mysql.connector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a script to die if an error occurs without checking for an exception
    yourself, write the script body like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go programs are organized into packages that are a collection of the source
    files, located in the same directory. Packages, in their turn, are organized into
    modules that are collections of Go packages that are released together. Modules
    belong to a Go repository. A typical Go repository contains only one module, but
    you may have several modules in the same repository.
  prefs: []
  type: TYPE_NORMAL
- en: The Go interpreter searches for packages in directories named in the `$GOPATH/src/{domain}/{project}`
    variable. However, when using modules, Go is no longer uses `GOPATH`. You do not
    need to change this variable no matter where your module is installed. We will
    use modules for our examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a method for connecting to MySQL, write a package file, *cookbook.go*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The filename basename does not determine the package name: Go searches through
    all files in the import path until it finds the one with the required package
    declaration. Package methods are accessed via the package name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the package you can specify relative path to the directory where the
    package file is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This is very easy way to quickly test your libraries but such commands, as *go
    install* would not work for packages, imported this way. As a result, your program
    will be rebuilt from scratch each time you access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Better way to work with packages is to publish them as part of modules. To
    do it, run following in the directory where you store `cookbook.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This will create file `go.mod` that will have your module name and version of
    Go. You can name the module as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: You can publish your module on the Internet and access it from the local program
    as you would do with any other module. However, during development, it would be
    useful to have the module only locally. In this case you need to make few adjustments
    in the program directory that will use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a program that will call the package, `harness.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the directory, there the package is installed, initialize the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the module is initialized and `go.mod` is created edit it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Replace URL and the local path with the ones, valid in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: This command will tell Go to replace remote module path with local directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, you can test your connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Java library files are similar to Java programs in most ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The `class` line in the source file indicates a class name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file should have the same name as the class (with a *.java* extension).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the *.java* file to produce a *.class* file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java library files also differ from Java programs in some ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike regular program files, Java library files have no `main()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A library file should begin with a `package` identifier that specifies the position
    of the class within the Java namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A common convention for Java package identifiers is to use the domain of the
    code author as a prefix; this helps make identifiers unique and avoids conflict
    with classes written by other authors. Domain names proceed right to left from
    more general to more specific within the domain namespace, whereas the Java class
    namespace proceeds left to right from general to specific. Thus, to use a domain
    as the prefix for a package name within the Java class namespace, it’s necessary
    to reverse it. For example, Paul’s domain is *kitebird.com*, so if he writes a
    library file and places it under `mcb` within his domain’s namespace, the library
    begins with a `package` statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Java packages developed for this book are placed within the `com.kitebird.mcb`
    namespace to ensure their uniqueness in the package namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following library file, *Cookbook.java*, defines a `Cookbook` class that
    implements a `connect()` method for connecting to the `cookbook` database. `connect()`
    returns a `Connection` object if it succeeds and throws an exception otherwise.
    To help the caller deal with failures, the `Cookbook` class also defines `getErrorMessage()`
    and `printErrorMessage()` utility methods that return the error message as a string
    and print it to `System.err`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The routines within the class are declared using the `static` keyword, which
    makes them class methods rather than instance methods. That is done here because
    the class is used directly rather than creating an object from it and invoking
    the methods through the object.
  prefs: []
  type: TYPE_NORMAL
- en: To use the *Cookbook.java* file, compile it to produce *Cookbook.class*, then
    install the class file in a directory that corresponds to the package identifier.
  prefs: []
  type: TYPE_NORMAL
- en: This means that *Cookbook.class* should be installed in a directory named *com/kitebird/mcb*
    (Unix) or *com\kitebird\mcb* (Windows) that is located under some directory named
    in your `CLASSPATH` setting. For example, if `CLASSPATH` includes */usr/local/lib/mcb*
    under Unix, you can install *Cookbook.class* in the */usr/local/lib/mcb/com/kitebird/mcb*
    directory. (For more information about the `CLASSPATH` variable, see the Java
    discussion in [Recipe 4.1](#nch-api-api-connect).)
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `Cookbook` class from within a Java program, import it and invoke
    the `Cookbook.connect()` method. The following test harness program, *Harness.java*,
    shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '*Harness.java* also shows how to use the error message utility methods from
    the `Cookbook` class when a MySQL-related exception occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`printErrorMessage()` takes the exception object and uses it to print an error
    message to `System.err`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getErrorMessage()` returns the error message as a string. You can display
    the message yourself, write it to a logfile, or whatever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.4 Executing Statements and Retrieving Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a program to send an SQL statement to the MySQL server and retrieve
    its result.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some statements return only a status code; others return a result set (a set
    of rows). Some APIs provide different methods for executing each type of statement.
    If so, use the appropriate method for the statement to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can execute two general categories of SQL statements. Some retrieve information
    from the database; others change that information or the database itself. Statements
    in the two categories are handled differently. In addition, some APIs provide
    multiple routines for executing statements, complicating matters further. Before
    we get to examples demonstrating how to execute statements from within each API,
    we’ll describe the database table the examples use, and then further discuss the
    two statement categories and outline a general strategy for processing statements
    in each category.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.xhtml#nch-mysql), we created a table named `limbs` to try
    some sample statements. In this chapter, we’ll use a different table named `profile`.
    It’s based on the idea of a <q>buddy list,</q> that is, the set of people we like
    to keep in touch with while we’re online. The table definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `profile` table indicates the things that are important to us about each
    buddy: name, age, favorite color, favorite foods, and number of cats. Additionally,
    the table uses several different data types for its columns, and these come in
    handy to illustrate how to solve problems that pertain to specific data types.'
  prefs: []
  type: TYPE_NORMAL
- en: The table also includes an `id` column containing unique values so that we can
    distinguish one row from another, even if two buddies have the same name. `id`
    and `name` are declared as `NOT` `NULL` because they’re each required to have
    a value. The other columns are implicitly permitted to be `NULL` (and that is
    also their default value) because we might not know the value to assign them for
    any given individual. That is, `NULL` signifies <q>unknown.</q>
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that although we want to keep track of age, there is no `age` column
    in the table. Instead, there is a `birth` column of `DATE` type. Ages change,
    so if we store age values, we’d have to keep updating them. Storing birth dates
    is better: they don’t change and can be used to calculate age any time (see [Recipe
    8.14](ch08.xhtml#nch-dates-dates-age)). `color` is an `ENUM` column; color values
    can be any one of the listed values. `foods` is a `SET`, which permits the value
    to be any combination of the individual set members. That way we can record multiple
    favorite foods for any buddy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the table, use the *profile.sql* script in the *tables* directory
    of the `recipes` distribution. Change location into that directory, then run this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The script also loads sample data into the table. You can experiment with the
    table, then restore it if you change its contents by running the script again.
    (See the final section of this chapter on the importance of restoring the `profile`
    table after modifying it.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the `profile` table as loaded by the *profile.sql* script look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Although most of the columns in the `profile` table permit `NULL` values, none
    of the rows in the sample dataset actually contain `NULL` yet. (We want to defer
    the complications of `NULL` value processing to [Recipe 4.5](#nch-api-api-quoting)
    and [Recipe 4.7](#nch-api-api-null).)
  prefs: []
  type: TYPE_NORMAL
- en: SQL statement categories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQL statements can be grouped into two broad categories, depending on whether
    they return a result set (a set of rows):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Statements that return no result set, such as `INSERT`, `DELETE`, or `UPDATE`.
    As a general rule, statements of this type generally change the database in some
    way. There are some exceptions, such as `USE` *`db_name`*, which changes the default
    (current) database for your session without making any changes to the database
    itself. The example data-modifying statement used in this section is an `UPDATE`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll cover how to execute this statement and determine the number of rows that
    it affects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Statements that return a result set, such as `SELECT`, `SHOW`, `EXPLAIN`, or
    `DESCRIBE`. I refer to such statements generically as `SELECT` statements, but
    you should understand that category to include any statement that returns rows.
    The example row-retrieval statement used in this section is a `SELECT`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll cover how to execute this statement, fetch the rows in the result set,
    and determine the number of rows and columns in the result set. (To get information
    such as the column names or data types, access the result set metadata. That’s
    [Recipe 12.2](ch12.xhtml#nch-meta-meta-result).)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first step in processing an SQL statement is to send it to the MySQL server
    for execution. Some APIs (those for Perl, and Java, for example) recognize a distinction
    between the two categories of statements and provide separate calls for executing
    them. Other APIs (such as the one for Python or Ruby) have a single call used
    for all statements. However, one thing all APIs have in common is that no special
    character indicates the end of the statement. No terminator is necessary because
    the end of the statement string terminates it. This differs from executing statements
    in the *mysql* program, where you terminate statements using a semicolon (`;`)
    or `\g`. (It also differs from how this book usually includes semicolons in examples
    to make it clear where statements end.)
  prefs: []
  type: TYPE_NORMAL
- en: When you send a statement to the server, be prepared to handle errors if it
    did not execute successfully. If a statement fails and you proceed on the basis
    that it succeeded, your program won’t work. For the most part, this section does
    not show error-checking code, but that is for brevity. Production code always
    should include error handling. The sample scripts in the `recipes` distribution
    from which the examples are taken do include error handling, based on the techniques
    illustrated in [Recipe 4.2](#nch-api-api-error).
  prefs: []
  type: TYPE_NORMAL
- en: If a statement does execute without error, your next step depends on the statement
    type. If it’s one that returns no result set, there’s nothing else to do, unless
    you want to check how many rows were affected. If the statement does return a
    result set, fetch its rows, then close the result set. In a context where you
    don’t know whether a statement returns a result set, [Recipe 12.2](ch12.xhtml#nch-meta-meta-result)
    discusses how to tell.
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Perl DBI module provides two basic approaches to SQL statement execution,
    depending on whether you expect to get back a result set. For a statement such
    as `INSERT` or `UPDATE` that returns no result set, use the database handle `do()`
    method. It executes the statement and returns the number of rows affected by it,
    or `undef` if an error occurs. If Sybil gets a new cat, the following statement
    increments her `cats` count by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'If the statement executes successfully but affects no rows, `do()` returns
    a special value, `"0E0"` (the value zero in scientific notation, expressed as
    a string). `"0E0"` can be used for testing the execution status of a statement
    because it is true in Boolean contexts (unlike `undef`). For successful statements,
    it can also be used when counting how many rows were affected because it is treated
    as the number zero in numeric contexts. Of course, if you print that value as
    is, you’ll print `"0E0"`, which might look odd to people who use your program.
    The preceding example makes sure that doesn’t happen by adding zero to the value
    to coerce it to numeric form so that it displays as `0`. Alternatively, use `printf`
    with a `%d` format specifier to cause an implicit numeric conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'If `RaiseError` is enabled, your script terminates automatically for DBI-related
    errors, so you need not check `$count` to find out whether `do()` failed and consequently
    can simplify the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'To process a statement such as `SELECT` that does return a result set, use
    a different approach that involves these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the statement to be executed by calling `prepare()` using the database
    handle. `prepare()` returns a statement handle to use with all subsequent operations
    on the statement. (If an error occurs, the script terminates if `RaiseError` is
    enabled; otherwise, `prepare()` returns `undef`.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `execute()` to execute the statement and generate the result set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop to fetch the rows returned by the statement. DBI provides several methods
    for this; we cover them shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don’t fetch the entire result set, release resources associated with
    it by calling `finish()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example illustrates these steps, using `fetchrow_array()` as
    the row-fetching method and assuming that `RaiseError` is enabled so that errors
    terminate the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The row array size indicates the number of columns in the result set.
  prefs: []
  type: TYPE_NORMAL
- en: The row-fetching loop just shown is followed by a call to `finish()`, which
    closes the result set and tells the server to free any resources associated with
    it. If you fetch every row in the set, DBI notices when you reach the end and
    releases the resources for you. Thus, the example could omit the `finish()` call
    without ill effect.
  prefs: []
  type: TYPE_NORMAL
- en: As the example illustrates, to determine how many rows a result set contains,
    count them while fetching them. Do not use the DBI `rows()` method for this purpose.
    The DBI documentation discourages this practice because `rows()` is not necessarily
    reliable for `SELECT` statements—due to differences in behavior among database
    engines and drivers.
  prefs: []
  type: TYPE_NORMAL
- en: DBI has several methods that fetch a row at a time. The one used in the preceding
    example, `fetchrow_array()`, returns an array containing the next row, or an empty
    list when there are no more rows. Array elements are present in the order named
    in the `SELECT` statement. Access them as `$val[0]`, `$val[1]`, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetchrow_array()` method is most useful for statements that explicitly
    name the columns to select. (With `SELECT` `*`, there are no guarantees about
    the positions of columns within the array.)
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchrow_arrayref()` is like `fetchrow_array()`, except that it returns a
    reference to the array, or `undef` when there are no more rows. As with `fetchrow_array()`,
    array elements are present in the order named in the statement. Access them as
    `$ref->[0]`, `$ref->[1]`, and so forth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '`fetchrow_hashref()` returns a reference to a hash structure, or `undef` when
    there are no more rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: To access the elements of the hash, use the names of the columns selected by
    the statement (`$ref->{id}`, `$ref->{name}`, and so forth). `fetchrow_hashref()`
    is particularly useful for `SELECT` `*` statements because you can access elements
    of rows without knowing anything about the order in which columns are returned.
    You need know only their names. On the other hand, it’s more expensive to set
    up a hash than an array, so `fetchrow_hashref()` is slower than `fetchrow_array()`
    or `fetchrow_arrayref()`. It’s also possible to <q>lose</q> row elements if they
    have the same name because column names must be unique. Same-name columns are
    not uncommon for joins between tables. For solutions to this problem, see [Recipe
    16.11](ch16.xhtml#nch-multi-multi-api-col-names).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the statement execution methods just described, DBI provides
    several high-level retrieval methods that execute a statement and return the result
    set in a single operation. All are database-handle methods that create and dispose
    of the statement handle internally before returning the result set. The methods
    differ in the form in which they return the result. Some return the entire result
    set, others return a single row or column of the set, as summarized in the [Table 4-4](#nch-api-api-statement-select):'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4\. Perl methods to retrieve results
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Return value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `selectrow_array()` | First row of result set as an array |'
  prefs: []
  type: TYPE_TB
- en: '| `selectrow_arrayref()` | First row of result set as a reference to an array
    |'
  prefs: []
  type: TYPE_TB
- en: '| `selectrow_hashref()` | First row of result set as a reference to a hash
    |'
  prefs: []
  type: TYPE_TB
- en: '| `selectcol_arrayref()` | First column of result set as a reference to an
    array |'
  prefs: []
  type: TYPE_TB
- en: '| `selectall_arrayref()` | Entire result set as a reference to an array of
    array references |'
  prefs: []
  type: TYPE_TB
- en: '| `selectall_hashref()` | Entire result set as a reference to a hash of hash
    references |'
  prefs: []
  type: TYPE_TB
- en: 'Most of these methods return a reference. The exception is `selectrow_array()`,
    which selects the first row of the result set and returns an array or a scalar,
    depending on how you call it. In array context, `selectrow_array()` returns the
    entire row as an array (or the empty list if no row was selected). This is useful
    for statements from which you expect to obtain only a single row. The return value
    can be used to determine the result set size. The column count is the number of
    elements in the array, and the row count is 1 or 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '`selectrow_arrayref()` and `selectrow_hashref()` select the first row of the
    result set and return a reference to it, or `undef` if no row was selected. To
    access the column values, treat the reference the same way you treat the return
    value from `fetchrow_arrayref()` or `fetchrow_hashref()`. The reference also provides
    the row and column counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '`selectcol_arrayref()` returns a reference to a single-column array representing
    the first column of the result set. Assuming a non-`undef` return value, access
    elements of the array as `$ref->[`*`i`*`]` for the value from row *`i`*. The number
    of rows is the number of elements in the array, and the column count is 1 or 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '`selectall_arrayref()` returns a reference to an array containing an element
    for each row of the result. Each element is a reference to an array. To access
    row *`i`* of the result set, use `$ref->[`*`i`*`]` to get a reference to the row.
    Then treat the row reference the same way as a return value from `fetchrow_arrayref()`
    to access individual column values in the row. The result set row and column counts
    are available as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '`selectall_hashref()` returns a reference to a hash, each element of which
    is a hash reference to a row of the result. To call it, specify an argument that
    indicates which column to use for hash keys. For example, if you retrieve rows
    from the `profile` table, the primary key is the `id` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Access rows using the keys of the hash. For a row that has a key column value
    of `12`, the hash reference for the row is `$ref->{12}`. That row value is keyed
    on column names, which you can use to access individual column elements (for example,
    `$ref->{12}->{name}`). The result set row and column counts are available as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The `selectall_`*`XXX`*`()` methods are useful when you need to process a result
    set more than once because Perl DBI provides no way to <q>rewind</q> a result
    set. By assigning the entire result set to a variable, you can iterate through
    its elements multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take care when using the high-level methods if you have `RaiseError` disabled.
    In that case, a method’s return value may not enable you to distinguish an error
    from an empty result set. For example, if you call `selectrow_array()` in scalar
    context to retrieve a single value, an `undef` return value is ambiguous because
    it may indicate any of three things: an error, an empty result set, or a result
    set consisting of a single `NULL` value. To test for an error, check the value
    of `$DBI::errstr`, `$DBI::err`, or `$DBI::state`.'
  prefs: []
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ruby Mysql2 API uses the same calls for SQL statements that do not return
    a result set and those that do. To process a statement in Ruby use method `query`.
    If the statement fails with an error, `query` raises an exception. Otherwise,
    method `affected_rows` returns number of rows changed for the last statement that
    modify data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: For statements such as `SELECT` that return a result set, method `query` returns
    the result set as an instance of the class `Mysql2::Result`. Method `affected_rows`
    will return number of rows in the result set for such statements. You may also
    obtain number of rows in the result set by using method `count` of the `Mysql2::Result`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '`result.fields` contains the names of the columns in the result set.'
  prefs: []
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PDO has two connection-object methods to execute SQL statements: `exec()` for
    statements that do not return a result set and `query()` for those that do. If
    you have PDO exceptions enabled, both methods raise an exception if statement
    execution fails. (Another approach couples the `prepare()` and `execute()` methods;
    see [Recipe 4.5](#nch-api-api-quoting).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute statements such as `INSERT` or `UPDATE` that don’t return rows,
    use `exec()`. It returns a count to indicate how many rows were changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'For statements such as `SELECT` that return a result set, the `query()` method
    returns a statement handle. Generally, you use this object to call a row-fetching
    method in a loop, and count the rows if you need to know how many there are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: To determine the number of columns in the result set, call the statement handle
    `columnCount()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The example demonstrates the statement handle `fetch()` method, which returns
    the next row of the result set or `FALSE` when there are no more. `fetch()` takes
    an optional argument that indicates what type of value it should return. As shown,
    with an argument of `PDO::FETCH_NUM`, `fetch()` returns an array with elements
    accessed using numeric subscripts, beginning with 0\. The array size indicates
    the number of result set columns.
  prefs: []
  type: TYPE_NORMAL
- en: With an argument of `PDO::FETCH_ASSOC`, `fetch()` returns an associative array
    containing values accessed by column name (`$row["id"]`, `$row["name"]`, `$row["cats"]`).
  prefs: []
  type: TYPE_NORMAL
- en: With an argument of `PDO::FETCH_OBJ`, `fetch()` returns an object having members
    accessed using the column names (`$row->id`, `$row->name`, `$row->cats`).
  prefs: []
  type: TYPE_NORMAL
- en: '`fetch()` uses the default fetch mode if you invoke it with no argument. Unless
    you have changed the mode, it’s `PDO::FETCH_BOTH`, which is like a combination
    of `PDO::FETCH_NUM` and `PDO::FETCH_ASSOC`. To set the default fetch mode for
    all statements executed within a connection, use the `setAttribute` database-handle
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the mode for a given statement, call its `setFetchMode()` method after
    executing the statement and before fetching the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also possible to use a statement handle as an iterator. The handle uses
    the current default fetch mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fetchAll()` method fetches and returns the entire result set as an array
    of rows. It permits an optional fetch-mode argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the row count is the number of elements in `$rows`.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Python DB API uses the same calls for SQL statements that do not return
    a result set and those that do. To process a statement in Python, use your database
    connection object to get a cursor object. Then use the cursor’s `execute()` method
    to send the statement to the server. If the statement fails with an error, `execute()`
    raises an exception. Otherwise, if there is no result set, statement execution
    is complete, and the cursor’s `rowcount` attribute indicates how many rows were
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Python DB API specification indicates that database connections should begin
    with auto-commit mode *disabled*, so Connector/Python disables auto-commit when
    it connects to the MySQL server. If you use transactional tables, modifications
    to them are rolled back when you close the connection unless you commit the changes
    first, which is why the preceding example invokes the `commit()` method. For more
    information on auto-commit mode, see [Chapter 20](ch20.xhtml#nch-xact), particularly
    [Recipe 20.7](ch20.xhtml#nch-xact-xact-python)).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the statement returns a result set, fetch its rows, then close the cursor.
    The `fetchone()` method returns the next row as a sequence, or `None` when there
    are no more rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding example, the `rowcount` attribute is useful
    for `SELECT` statements, too; it indicates the number of rows in the result set.
  prefs: []
  type: TYPE_NORMAL
- en: '`len(row)` tells you the number of columns in the result set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, use the cursor itself as an iterator that returns each row in
    turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fetchall()` method returns the entire result set as a list of tuples.
    Iterate through the list to access the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: DB API provides no way to rewind a result set, so `fetchall()` can be convenient
    when you must iterate through the rows of the result set more than once or access
    individual values directly. For example, if `rows` holds the result set, you can
    access the value of the third column in the second row as `rows[1][2]` (indexes
    begin at 0, not 1).
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Go `sql` interface has two connection-object functions to execute SQL statements:
    `Exec()` for statements that do not return result set and `Query()` for the statements
    that do. Both return `error` if the statement fails.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a statement that does not return any row, such as `INSERT`, `UPDATE`
    or `DELETE`, use the function `Exec()`. It’s return values can have one of the
    types: `Result` or `error`. Interface `Result` has a function `RowsAffected()`
    that indicates how many rows were changed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: For the satements that return a result set, typically `SELECT`, use the function
    `Query()`. This function returns cursor to the object of type `Rows` that holds
    the result of the query. Call the function `Next()` to iterate through the result
    and store returned values in the variables using function `Scan()`. If `Next()`
    returns `false` this means that there is no result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: If `Next()` is called and returns `false` the `Rows` are closed automatically.
    Otherwise you need to close them using function `Close()`.
  prefs: []
  type: TYPE_NORMAL
- en: For the queries that expect to return at most one row exists a special function
    `QueryRow()` that returns a `Row` object that could be immediately scanned. `QueryRow()`
    never returns error until `Scan()` is called. If the query returns no row, `Scan()`
    returns `ErrNoRows`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JDBC interface provides specific object types for the various phases of
    SQL statement processing. Statements are executed in JDBC using Java objects of
    one type. The results, if any, are returned as objects of another type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a statement, first get a `Statement` object by calling the `createStatement()`
    method of your `Connection` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the `Statement` object to send the statement to the server. JDBC provides
    several methods for doing this. Choose the one that’s appropriate for the type
    of statement: `executeUpdate()` for statements that don’t return a result set,
    `executeQuery()` for statements that do, and `execute()` when you don’t know.
    Each method raises an exception if the statement fails.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `executeUpdate()` method sends a statement that generates no result set
    to the server and returns a count indicating the number of affected rows. When
    you’re done with the statement object, close it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'For statements that return a result set, use `executeQuery()`. Then get a result
    set object, and use it to retrieve the row values. When you’re done, close the
    result set and statement objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The `ResultSet` object returned by the `getResultSet()` method of your `Statement`
    object has its own methods, such as `next()` to fetch rows and various `get`*`XXX`*`()`
    methods that access columns of the current row. Initially, the result set is positioned
    just before the first row of the set. Call `next()` to fetch each row in succession
    until it returns false. To determine the number of rows in a result set, count
    them yourself, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For queries that return single result set it is not necessary to call *getResultSet*.
    Code above could be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: . Separate call is needed when your query can return multiple result sets, for
    example, if you call a stored routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access column values, use methods such as `getInt()`, `getString()`, `getFloat()`,
    and `getDate()`. To obtain the column value as a generic object, use `getObject()`.
    The argument to a `get`*`XXX`*`()` call can indicate either column position (beginning
    at 1, not 0) or column name. The previous example shows how to retrieve the `id`,
    `name`, and `cats` columns by position. To access columns by name instead, write
    the row-fetching loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve a given column value, use any `get`*`XXX`*`()` call that makes
    sense for the data type. For example, `getString()` retrieves any column value
    as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use `getObject()` to retrieve values as generic objects and convert the
    values as necessary. The following example uses `toString()` to convert object
    values to printable form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine the number of columns in the result set, access its metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The third JDBC statement-execution method, `execute()`, works for either type
    of statement. It’s particularly useful when you receive a statement string from
    an external source and don’t know whether it generates a result set or returns
    multiple result sets. The return value from `execute()` indicates the statement
    type so that you can process it appropriately: if `execute()` returns true, there
    is a result set, otherwise not. Typically, you’d use it something like this, where
    `stmtStr` represents an arbitrary SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 4.5 Handling Special Characters and NULL Values in Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to construct SQL statements that refer to data values containing special
    characters such as quotes or backslashes, or special values such as `NULL`. Or
    you are constructing statements using data obtained from external sources and
    want to prevent SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use your API’s placeholder mechanism or quoting function to make data safe for
    insertion.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to this point in the chapter, our statements have used <q>safe</q> data
    values that require no special treatment. For example, we can easily construct
    the following SQL statements from within a program by writing the data values
    literally in the statement strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: However, some data values are not so easily handled and cause problems if you
    are not careful. Statements might use values that contain special characters such
    as quotes, backslashes, binary data, or values that are `NULL`. The following
    discussion describes the difficulties these values cause and the proper techniques
    for handling them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want to execute this `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s nothing unusual about that. But if you change the `name` column value
    to something like `De''Mont` that contains a single quote, the statement becomes
    syntactically invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is the single quote inside a single-quoted string. To make the
    statement legal by escaping the quote, precede it with either a single quote or
    a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, quote the `name` value itself within double quotes rather than
    within single quotes (assuming that the `ANSI_QUOTES` SQL mode is not enabled):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: If you are writing a statement literally in your program, you can escape or
    quote the `name` value by hand because you know what the value is. But if the
    name is stored in a variable, you don’t necessarily know what the variable’s value
    is. Worse yet, single quote isn’t the only character you must be prepared to deal
    with; double quotes and backslashes cause problems, too. And if the database stores
    binary data such as images or sound clips, a value might contain anything—not
    only quotes or backslashes, but other characters such as nulls (zero-valued bytes).
    The need to handle special characters properly is particularly acute in a web
    environment where statements are constructed using form input (for example, if
    you search for rows that match search terms entered by the remote user). You must
    be able to handle any kind of input in a general way because you can’t predict
    in advance what kind of information a user will supply. It is not uncommon for
    malicious users to enter garbage values containing problematic characters in a
    deliberate attempt to compromise the security of your server and even execute
    fatal commands, such as `DROP TABLE`. That is a standard technique for exploiting
    insecure scripts, called [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL `NULL` value is not a special character, but it too requires special
    treatment. In SQL, `NULL` indicates <q>no value.</q> This can have several meanings
    depending on context, such as <q>unknown,</q> <q>missing,</q> <q>out of range,</q>
    and so forth. Our statements thus far have not used `NULL` values, to avoid dealing
    with the complications that they introduce, but now it’s time to address these
    issues. For example, if you don’t know De’Mont’s favorite color, you can set the
    `color` column to `NULL`—but not by writing the statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, the `NULL` value must have no enclosing quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Were you writing the statement literally in your program, you’d simply write
    the word <q>NULL</q> without enclosing quotes. But if the `color` value comes
    from a variable, the proper action is not so obvious. You must know whether the
    variable’s value represents `NULL` to determine whether to enclose it within quotes
    when you construct the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two means at your disposal for dealing with special characters such
    as quotes and backslashes, and with special values such as `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: Use placeholders in the statement string to refer to data values symbolically,
    then bind the data values to the placeholders when you execute the statement.
    This is the preferred method because the API itself does all or most of the work
    for you of providing quotes around values as necessary, quoting or escaping special
    characters within the data value, and possibly interpreting a special value to
    map onto `NULL` without enclosing quotes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a quoting function (if your API provides one) for converting data values
    to a safe form that is suitable for use in statement strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section shows how to use these techniques to handle special characters
    and `NULL` values for each API. One of the examples demonstrated here shows how
    to insert a `profile` table row that contains `De'Mont` for the `name` value and
    `NULL` for the `color` value. However, the principles shown here have general
    utility and handle any special characters, including those found in binary data.
    Also, the principles are not limited to `INSERT` statements. They work for other
    kinds of statements as well, such as `SELECT`. One of the other examples shown
    here demonstrates how to execute a `SELECT` statement using placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing of special characters and `NULL` values comes up in other contexts
    covered elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: The placeholder and quoting techniques described here are *only* for data values
    and not for identifiers such as database or table names. For discussion of identifier
    quoting, refer to [Recipe 4.6](#nch-api-api-ident-quoting).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons of `NULL` values require different operators than non-`NULL` values.
    [Recipe 5.6](ch05.xhtml#nch-select-select-null-compare) discusses how to construct
    SQL statements that perform `NULL` comparisons from within programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section covers the issue of getting special characters *into* your database.
    A related issue is the inverse operation of transforming special characters in
    values returned *from* your database for display in various contexts. For example,
    if you generate HTML pages that include values taken from your database, you must
    perform output encoding to convert `<` and `>` characters in those values to the
    HTML entities `&lt;` and `&gt;` to make sure they display properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using placeholders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Placeholders enable you to avoid writing data values literally in SQL statements.
    Using this approach, you write statements using placeholders—special markers that
    indicate where the values go. Two common parameter markers are `?` and `%s`. Depending
    on the marker, rewrite the `INSERT` statement to use placeholders like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Then pass the statement string to the database server and supply the data values
    separately. The API binds the values to the placeholders to replace them, resulting
    in a statement that contains the data values.
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of placeholders is that parameter-binding operations automatically
    handle escaping of characters such as quotes and backslashes. This is especially
    useful for inserting binary data such as images into your database or using data
    values with unknown content such as input submitted by a remote user through a
    form in a web page. Also, there is usually some special value that you bind to
    a placeholder to indicate that you want an SQL `NULL` value in the resulting statement.
  prefs: []
  type: TYPE_NORMAL
- en: A second benefit of placeholders is that you can <q>prepare</q> a statement
    in advance, then reuse it by binding different values to it each time it’s executed.
    Prepared statements thus encourage statement reuse. Statements become more generic
    because they contain placeholders rather than specific data values. If you perform
    an operation over and over, you may be able to reuse a prepared statement and
    simply bind different data values to it each time you execute it. Some database
    systems (MySQL not among them) have the capability of performing some preparsing
    or even execution planning prior to executing a prepared statement. For a statement
    that is executed multiple times later, this reduces overhead because anything
    that can be done prior to execution need be done only once, not once per execution.
    For example, if a program executes a particular type of `SELECT` statement several
    times while it runs, such a database system can construct a plan for the statement
    and then reuse it each time, rather than rebuild the plan over and over. MySQL
    doesn’t build query plans in advance, so you get no performance boost from using
    prepared statements. However, if you port a program to a database that does reuse
    query plans and you’ve written your program to use prepared statements, you can
    get this advantage of prepared statements automatically. You need not convert
    from nonprepared statements to enjoy that benefit.
  prefs: []
  type: TYPE_NORMAL
- en: A third (admittedly subjective) benefit is that code that uses placeholder-based
    statements can be easier to read. As you work through this section, compare the
    statements used here with those from [Recipe 4.4](#nch-api-api-statement) that
    did not use placeholders to see which you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Using a quoting function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some APIs provide a quoting function that takes a data value as its argument
    and returns a properly quoted and escaped value suitable for safe insertion into
    an SQL statement. This is less common than using placeholders, but it can be useful
    for constructing statements that you do not intend to execute immediately. However,
    you must have a connection open to the database server while you use such a quoting
    function because the API cannot select the proper quoting rules until the database
    driver is known. (The rules differ among database systems.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we’ll indicate later, some APIs quote as strings all non-`NULL` values, even
    numbers, when binding them to parameter markers. This can be an issue in contexts
    that *require* numbers, as described further in [Recipe 5.11](ch05.xhtml#nch-select-select-limit-calc).
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use placeholders with Perl DBI, put a `?` in your SQL statement string at
    each data value location. Then bind the values to the statement by passing them
    to `do()` or `execute()`, or by calling a DBI method specifically intended for
    placeholder substitution. Use `undef` to bind a `NULL` value to a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `do()`, add the `profile` row for De’Mont by passing the statement string
    and the data values in the same call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The arguments following the statement string are `undef`, then one data value
    for each placeholder. The `undef` argument is a historical artifact, but must
    be present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, pass the statement string to `prepare()` to get a statement
    handle, then use that handle to pass the data values to `execute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'In either case, DBI generates this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The Perl DBI placeholder mechanism provides quotes around data values when they
    are bound to the statement string, so don’t put quotes around the `?` characters
    in the string.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the placeholder mechanism adds quotes around numeric values. DBI relies
    on the MySQL server to perform type conversion as necessary to convert strings
    to numbers. If you bind `undef` to a placeholder, DBI puts a `NULL` into the statement
    and correctly refrains from adding enclosing quotes.
  prefs: []
  type: TYPE_NORMAL
- en: To execute the same statement over and over again, use `prepare()` once, then
    call `execute()` with appropriate data values each time you run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these methods for other types of statements as well. For example,
    the following `SELECT` statement uses a placeholder to look for rows that have
    a `cats` value larger than 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'High-level retrieval methods such as `selectrow_array()` and `selectall_arrayref()`
    can be used with placeholders, too. Like the `do()` method, the arguments are
    the statement string, `undef`, and the data values to bind to the placeholders.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The Perl DBI `quote()` database- handle method is an alternative to using placeholders.
    Here’s how to use `quote()` to create a statement string that inserts a new row
    in the `profile` table. Write the `%s` format specifiers without enclosing quotes
    because `quote()` provides them automatically as necessary. Non-`undef` values
    are inserted with quotes, and `undef` values are inserted as `NULL` without quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The statement string generated by this code is the same as when you use placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ruby DBI uses `?` as the placeholder character in SQL statements and `nil` as
    the value for binding an SQL `NULL` value to a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `?`, pass the statement string to `prepare` to get a statement handle,
    then use that handle to invoke `execute` with the data values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Mysql2 includes properly escaped quotes and a properly unquoted `NULL` value
    in the resulting statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The Ruby Mysql2 placeholder mechanism provides quotes around data values as
    necessary when they are bound to the statement string, so don’t put quotes around
    the `?` characters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use placeholders with the PDO extension, pass a statement string to `prepare()`
    to get a statement object. The string can contain `?` characters as placeholder
    markers. Use this object to invoke `execute()`, passing to it the array of data
    values to bind to the placeholders. Use the PHP `NULL` value to bind an SQL `NULL`
    value to a placeholder. The code to add the `profile` table row for De’Mont looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting statement includes a properly escaped quote and a properly unquoted
    `NULL` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The PDO placeholder mechanism provides quotes around data values when they are
    bound to the statement string, so don’t put quotes around the `?` characters in
    the string. (Note that even the numeric value `4` is quoted; PDO relies on MySQL
    to perform type conversion as necessary when the statement executes.)
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Connector/Python module implements placeholders using `%s` format specifiers
    in the SQL statement string. (To place a literal `%` character into the statement,
    use `%%` in the statement string.) To use placeholders, invoke the `execute()`
    method with two arguments: a statement string containing format specifiers and
    a sequence containing the values to bind to the statement string. Use `None` to
    bind a `NULL` value to a placeholder. The code to add the `profile` table row
    for De’Mont looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement sent to the server by the preceding `execute()` call looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The Connector/Python placeholder mechanism provides quotes around data values
    as necessary when they are bound to the statement string, so don’t put quotes
    around the `%s` format specifiers in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have only a single value *`val`* to bind to a placeholder, write it
    as a sequence using the syntax `(`*`val`*,`)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, write the value as a list using the syntax `[`*`val`*`]`.
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go `sql` package uses question marks (`?`) as a placeholder markers. You can
    use placeholders with single `Exec()` or `Query()` calls, and also you can prepare
    the statement in advance and execute it later. Latter method is good when you
    need to execute the statement multiple times. The code to add the `profile` table
    row for De’Mont looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code with the `Prepare()` call will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JDBC provides support for placeholders if you use prepared statements. Recall
    that the process for executing nonprepared statements in JDBC is to create a `Statement`
    object, and then pass the statement string to the `executeUpdate()`, `executeQuery()`,
    or `execute()` function. To use a prepared statement instead, create a `PreparedStatement`
    object by passing a statement string containing `?` placeholder characters to
    your connection object’s `prepareStatement()` method. Then bind the data values
    to the statement using `set`*`XXX`*`()` methods. Finally, execute the statement
    by calling `executeUpdate()`, `executeQuery()`, or `execute()` with an empty argument
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that uses `executeUpdate()` to execute an `INSERT` statement
    that adds the `profile` table row for De’Mont:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set`*`XXX`*`()` methods that bind data values to statements take two arguments:
    a placeholder position (beginning with 1, not 0) and the value to bind to the
    placeholder. Choose each value-binding call to match the data type of the column
    to which the value is bound: `setString()` to bind a string to the `name` column,
    `setInt()` to bind an integer to the `cats` column, and so forth. (Actually, I
    cheated a bit by using `setString()` to treat the date value for `birth` as a
    string.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'One difference between JDBC and the other APIs is that you don’t bind a `NULL`
    to a placeholder by specifying some special value (such as `undef` in Perl or
    `nil` in Ruby). Instead, invoke `setNull()` with a second argument that indicates
    the type of the column: `java.sql.Types.CHAR` for a string, `java.sql.Types.INTEGER`
    for an integer, and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: The `set`*`XXX`*`()` calls add quotes around data values if necessary, so don’t
    put quotes around the `?` placeholder characters in the statement string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle a statement that returns a result set, the process is similar, but
    execute the prepared statement with `executeQuery()` rather than `executeUpdate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 4.6 Handling Special Characters in Identifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to construct SQL statements that refer to identifiers containing special
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quote each identifier so it can be inserted safely into statement strings.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 4.5](#nch-api-api-quoting) discusses how to handle special characters
    in data values by using placeholders or quoting methods. Special characters also
    can be present in identifiers such as database, table, and column names. For example,
    the table name `some table` contains a space, which is not permitted by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Special characters are handled differently in identifiers than in data values.
    To make an identifier safe for insertion into an SQL statement, quote it by enclosing
    it within backticks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'In MySQL, backticks are always permitted for identifier quoting. The double-quote
    character is permitted as well, if the `ANSI_QUOTES` SQL mode is enabled. Thus,
    with `ANSI_QUOTES` enabled, both of these statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: If it’s necessary to know which identifier quoting characters are permitted,
    execute a `SELECT` `@@sql_mode` statement to retrieve the SQL mode for your session
    and check whether its value includes `ANSI_QUOTES`.
  prefs: []
  type: TYPE_NORMAL
- en: If a quoting character appears within the identifier itself, double it when
    quoting the identifier. For example, quote ``abc`def`` as [PRE165].
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that although string data values in MySQL normally can be quoted using
    either single-quote or double-quote characters (`'abc'`, `"abc"`), that is not
    true when `ANSI_QUOTES` is enabled. In that case, MySQL interprets `'abc'` as
    a string and `"abc"` as an identifier, so you must use only single quotes for
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a program, you can use an identifier-quoting routine if your API provides
    one, or write one yourself if not. Perl DBI has a `quote_identifier()` method
    that returns a properly quoted identifier. For an API that has no such method,
    you can quote an identifier by enclosing it within backticks and doubling any
    backticks that occur within the identifier. Here’s a PHP routine that does so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Portability note: If you write your own identifier-quoting routines, remember
    that other DBMSs may require different quoting conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contexts where identifiers are used as data values, handle them as such.
    If you select information from the `INFORMATION_SCHEMA` metadata database, it’s
    common to indicate which rows to return by specifying database object names in
    the `WHERE` clause. For example, this statement retrieves the column names for
    the `profile` table in the `cookbook` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'The database and table names are used here as data values, not as identifiers.
    Were you to construct this statement within a program, parameterize them using
    placeholders, not identifier quoting. For example, in Ruby, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 4.7 Identifying NULL Values in Result Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A query result includes `NULL` values, but you’re not sure how to identify them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your API probably has some special value that represents `NULL` by convention.
    You just have to know what it is and how to test for it.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 4.5](#nch-api-api-quoting) describes how to refer to `NULL` values
    when you send statements *to* the database server. In this section, we’ll deal
    instead with the question of how to recognize and process `NULL` values returned
    *from* the database server. In general, this is a matter of knowing what special
    value the API maps `NULL` values to, or what method to call. The [Table 4-5](#nch-api-api-nul-detect)
    shows these values:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-5\. Detected NULL values
  prefs: []
  type: TYPE_NORMAL
- en: '| Language | NULL-detection value or method |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Perl DBI | `undef` value |'
  prefs: []
  type: TYPE_TB
- en: '| Ruby Mysql2 gem | `nil` value |'
  prefs: []
  type: TYPE_TB
- en: '| PHP PDO | `NULL` value |'
  prefs: []
  type: TYPE_TB
- en: '| Python DB API | `None` value |'
  prefs: []
  type: TYPE_TB
- en: '| Go `sql` interface | Go Null type implementation for the nullable data types.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Java JDBC | `wasNull()` method |'
  prefs: []
  type: TYPE_TB
- en: The following sections show a very simple application of `NULL` value detection.
    The examples retrieve a result set and print all values in it, mapping `NULL`
    values onto the printable string `"NULL"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that the `profile` table has a row that contains some `NULL` values,
    use *mysql* to execute the following `INSERT` statement, then execute the `SELECT`
    statement to verify that the resulting row has the expected values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The `id` column might contain a different number, but the other columns should
    appear as shown, with values of `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perl DBI represents `NULL` values using `undef`. To detect such values, use
    the `defined()` function; it’s particularly important to do so if you enable warnings
    with the Perl `-w` option or by including a `use` `warnings` line in your script.
    Otherwise, accessing `undef` values causes Perl to issue `Use` `of` `uninitialized`
    `value` warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent these warnings, test column values that might be `undef` with `defined()`
    before using them. The following code selects a few columns from the `profile`
    table and prints `"NULL"` for any undefined values in each row. This makes `NULL`
    values explicit in the output without activating any warning messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, testing multiple column values is ponderous and becomes worse
    the more columns there are. To avoid this, test and set undefined values using
    a loop or `map` prior to printing them. The following example uses `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: With this technique, the amount of code to perform the tests is constant, not
    proportional to the number of columns to be tested. Also, there is no reference
    to specific column names, so it can more easily be used in other programs or as
    the basis for a utility routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you fetch rows into an array rather than into a hash, use `map` like this
    to convert `undef` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ruby Mysql2 module represents `NULL` values using `nil`, which can be identified
    by applying the `nil?` method to a value. The following example uses the `nil?`
    method and ternary operator to determine whether to print result set values as
    is or as the string `"NULL"` for `NULL` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHP represents SQL `NULL` values in result sets as the PHP `NULL` value. To
    determine whether a value from a result set represents a `NULL` value, compare
    it to the PHP `NULL` value using the `===` <q>triple equal</q> operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP, the triple equal operator means <q>exactly equal to.</q> The usual
    `==` <q>equal to</q> comparison operator is not suitable here: with `==`, PHP
    considers the `NULL` value, the empty string, and `0` all equal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the `===` operator to identify `NULL` values in a result
    set and print them as the string `"NULL"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: An alternative to `===` for `NULL` value tests is `is_null()`.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python DB API programs represent `NULL` in result sets using `None`. The following
    example shows how to detect `NULL` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: The inner loop checks for `NULL` column values by looking for `None` and converts
    them to the string `"NULL"`. The example converts `row` to a mutable object (list)
    prior to the loop because `fetchall()` returns rows as sequence values, which
    are nonmutable (read only).
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go `sql` interface provides special data types to handle values in the result
    set that may contain NULL values. They are defined for the standard Go types.
    [Table 4-6](#nch-api-api-null-go) contains the list of the standard data types
    and their nullable equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-6\. Handling NULL values in Go
  prefs: []
  type: TYPE_NORMAL
- en: '| Standard Go Type | Type that can contain NULL values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `NullBool` |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` | `NullFloat64` |'
  prefs: []
  type: TYPE_TB
- en: '| `int32` | `NullInt32` |'
  prefs: []
  type: TYPE_TB
- en: '| `int64` | `NullInt64` |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `NullString` |'
  prefs: []
  type: TYPE_TB
- en: '| `time.Time` | `NullTime` |'
  prefs: []
  type: TYPE_TB
- en: To define a variable that can take both `NULL` and non-`NULL` value when passed
    as an argument to the function `Scan()`, use the corresponding nullable type.
  prefs: []
  type: TYPE_NORMAL
- en: 'All nullable types contains two functions: `Valid()` that returns `true` if
    the value is not `NULL` and `false` if the value is `NULL`. Second function is
    the type name, started from the capital letter. For example, `String()` for `string`
    values and `Time()` for `time.Time` values. This method returns actual value when
    it is not `NULL`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here is the example on how to handle `NULL` values in Go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We used type `NullString` for the `birth` column for simplicity. If you want
    to use type `NullTime` you need to add parameter `parseTime=true` to your connection
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Alternatively you can use MySQL’s `COALESCE()` function to convert null value
    to a string during the query execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For JDBC programs, if it’s possible for a column in a result set to contain
    `NULL` values, it’s best to check for them explicitly. The way to do this is to
    fetch the value and then invoke `wasNull()`, which returns true if the column
    is `NULL` and false otherwise. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example uses `getObject()`, but the principle holds for other
    `get`*`XXX`*`()` calls as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that prints each row of a result set as a comma-separated
    list of values, with `"NULL"` printed for each `NULL` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 4.8 Obtaining Connection Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to obtain connection parameters for a script so that it can connect
    to a MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to do this. Take your pick from the alternatives described
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any program that connects to MySQL specifies connection parameters such as
    the username, password, and hostname. The recipes shown so far have put connection
    parameters directly into the code that attempts to establish the connection, but
    that is not the only way for your programs to obtain the parameters. This discussion
    briefly surveys some of the available techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardwire the parameters into the program
  prefs: []
  type: TYPE_NORMAL
- en: The parameters can be given either in the main source file or in a library file
    used by the program. This technique is convenient because users need not enter
    the values themselves, but it’s also inflexible. To change parameters, you must
    modify your program. It is also insecure, because everyone who accesses the library
    would be able to read your database credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Ask for the parameters interactively
  prefs: []
  type: TYPE_NORMAL
- en: In a command-line environment, you can ask the user a series of questions. In
    a web or GUI environment, you might do this by presenting a form or dialog. Either
    way, this becomes tedious for people who use the application frequently, due to
    the need to enter the parameters each time.
  prefs: []
  type: TYPE_NORMAL
- en: Get the parameters from the command line
  prefs: []
  type: TYPE_NORMAL
- en: You can use this method either for commands run interactively or from within
    a script. Like the method of obtaining parameters interactively, you must supply
    parameters for each command invocation. (A factor that mitigates this burden is
    that many shells enable you to easily recall commands from your history list for
    re-execution.) This method could be insecure if you provide your credentials this
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Get the parameters from the execution environment
  prefs: []
  type: TYPE_NORMAL
- en: The most common way to do this is to set the appropriate environment variables
    in one of your shell’s startup files (such as *.profile* for *sh*, *bash*, *ksh*;
    or *.login* for *csh* or *tcsh*). Programs that you run during your login session
    then can get parameter values by examining their environment.
  prefs: []
  type: TYPE_NORMAL
- en: Get the parameters from a separate file
  prefs: []
  type: TYPE_NORMAL
- en: With this method, store information such as the username and password in a file
    that programs can read before connecting to the MySQL server. Reading parameters
    from a file that’s separate from your program gives you the benefit of not having
    to enter them each time you use the program, without hardwiring the values into
    it. Also, storing the values in a file enables you to centralize parameters for
    use by multiple programs, and for security purposes you can set the file access
    mode to keep other users from reading the file.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL client library itself supports an option file mechanism, although
    not all APIs provide access to it. For those that don’t, workarounds may exist.
    (As an example, Java supports the use of properties files and supplies utility
    routines for reading them.)
  prefs: []
  type: TYPE_NORMAL
- en: Use a combination of methods
  prefs: []
  type: TYPE_NORMAL
- en: It’s often useful to combine methods, to give users the flexibility of providing
    parameters different ways. For example, MySQL clients such as *mysql* and *mysqladmin*
    look for option files in several locations and read any that are present. They
    then check the command-line arguments for further parameters. This enables users
    to specify connection parameters in an option file or on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods of obtaining connection parameters do involve security issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Any method that stores connection parameters in a file may compromise your system’s
    security unless the file is protected against access by unauthorized users. This
    is true whether parameters are stored in a source file, an option file, or a script
    that invokes a command and specifies the parameters on the command line. (Web
    scripts that can be read only by the web server don’t qualify as secure if other
    users have administrative access to the server.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters specified on the command line or in environment variables are not
    particularly secure. While a program is executing, its command-line arguments
    and environment may be visible to other users who run process status commands
    such as *ps* `-e`. In particular, storing the password in an environment variable
    perhaps is best limited to those situations in which you’re the only user on the
    machine or you trust all other users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of this section discusses how to process command-line arguments to
    get connection parameters and how to read parameters from option files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting parameters from the command line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The convention used by standard clients such as *mysql* and *mysqladmin* for
    command-line arguments is to permit parameters to be specified using either a
    short option or a long option. For example, the username `cbuser` can be specified
    either as `-u` `cbuser` (or `-ucbuser`) or `--user=cbuser`. In addition, for either
    of the password options (`-p` or `--password`), the password value may be omitted
    after the option name to cause the program to prompt for the password interactively.
  prefs: []
  type: TYPE_NORMAL
- en: The standard flags for these command options are `-h` or `--host`, `-u` or `--user`,
    and `-p` or `--password`. You could write your own code to iterate through the
    argument list, but it’s much easier to use existing option-processing modules
    written for that purpose. Under the *api* directory of the `recipes` distribution,
    you’ll find example programs that show how to process command arguments to obtain
    the hostname, username, and password for Perl, Ruby, Python, and Java. An accompanying
    PDF file explains how each one works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Insofar as possible, the programs mimic option-handling behavior of the standard
    MySQL clients. An exception is that option-processing libraries may not permit
    making the password value optional, and they provide no way of prompting the user
    for a password interactively if a password option is specified without a password
    value. Consequently, the programs are written so that if you use `-p` or `--password`,
    you must provide the password value following the option.
  prefs: []
  type: TYPE_NORMAL
- en: Getting parameters from option files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your API supports it, you can specify connection parameters in a MySQL option
    file and let the API read the parameters from the file for you. For APIs that
    do not support option files directly, you may be able to arrange to read other
    types of files in which parameters are stored or to write your own functions that
    read option files.
  prefs: []
  type: TYPE_NORMAL
- en: '[Recipe 1.4](ch01.xhtml#nch-mysql-mysql-options) describes the format of MySQL
    option files. We assume that you’ve read the discussion there and concentrate
    here on how to use option files from within programs. You can find files containing
    the code discussed here under the *api* directory of the `recipes` distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: Under Unix, user-specific options are specified by convention in *~/.my.cnf*
    (that is, in the *.my.cnf* file in your home directory). However, the MySQL option-file
    mechanism can look in several different files if they exist, although no option
    file is *required* to exist. (For the list of standard locations in which MySQL
    programs look for them, see [Recipe 1.4](ch01.xhtml#nch-mysql-mysql-options).)
    If multiple option files exist and a given parameter is specified in several of
    them, the last value found takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programs you write do not use MySQL option files unless you tell them to:'
  prefs: []
  type: TYPE_NORMAL
- en: Perl DBI and Ruby Mysql2 gem provide direct API support for reading option files;
    simply indicate that you want to use them at the time that you connect to the
    server. It’s possible to specify that only a particular file should be read, or
    that the standard search order should be used to look for multiple option files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP PDO, Connector/Python, Java and Go do not support option files. (The PDO
    MySQL driver does, but not if you use `mysqlnd` as the underlying library.) As
    a workaround for PHP, we’ll write a simple option-file parsing function. For Java,
    we’ll adopt a different approach that uses properties files. For Go we will utilize
    `INI` parsing library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the conventional name under Unix for the user-specific option file
    is *.my.cnf* in the current user’s home directory, there’s no rule that your own
    programs must use this particular file. You can name an option file anything you
    like and put it wherever you want. For example, you might set up a file named
    *mcb.cnf* and install it in the */usr/local/lib/mcb* directory for use by scripts
    that access the `cookbook` database. Under some circumstances, you might even
    want to create multiple option files. Then, from within any given script, select
    the file that’s appropriate for the access privileges the script needs. For example,
    you might have one option file, *mcb.cnf*, that lists parameters for a full-access
    MySQL account, and another file, *mcb-readonly.cnf*, that lists connection parameters
    for an account that needs only read-only access to MySQL. Another possibility
    is to list multiple groups within the same option file and have your scripts select
    options from the appropriate group.
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Perl DBI scripts can use option files. To take advantage of this, place the
    appropriate option specifiers in the third component of the data source name (DSN)
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: To specify an option group, use ``mysql_read_default_group=*`groupname`*``.
    This tells MySQL to search the standard option files for options in the named
    group and in the `[client]` group. Write the *`groupname`* value without the surrounding
    square brackets. (If a group in an option file begins with a `[my_prog]` line,
    specify the *`groupname`* value as `my_prog`.) To search the standard files but
    look only in the `[client]` group, *`groupname`* should be `client`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To name a specific option file, use ``mysql_read_default_file=*`filename`*``
    in the DSN. When you do this, MySQL looks only in that file and only for options
    in the `[client]` group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you specify both an option file and an option group, MySQL reads only the
    named file, but looks for options both in the named group and in the `[client]`
    group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example tells MySQL to use the standard option-file search order
    to look for options in both the `[cookbook]` and `[client]` groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example explicitly names the option file located in `$ENV{HOME}`,
    the home directory of the user running the script. Thus, MySQL looks only in that
    file and uses options from the `[client]` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass an empty value (`undef` or the empty string) for the username or
    password arguments of the `connect()` call, `connect()` uses whatever values are
    found in the option file or files. A nonempty username or password in the `connect()`
    call overrides any option-file value. Similarly, a host named in the DSN overrides
    any option-file value. Use this behavior to enable DBI scripts to obtain connection
    parameters both from option files as well as from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `$host_name`, `$user_name`, and `$password` variables, each with a value
    of `undef`. Then parse the command-line arguments to set the variables to non-`undef`
    values if the corresponding options are present on the command line. (The *cmdline.pl*
    Perl script under the *api* directory of the `recipes` distribution demonstrates
    how to do this.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After parsing the command arguments, construct the DSN string, and call `connect()`.
    Use `mysql_read_default_group` and `mysql_read_default_file` in the DSN to specify
    how you want option files to be used, and, if `$host_name` is not `undef`, add
    `host=$host_name` to the DSN. In addition, pass `$user_name` and `$password` as
    the username and password arguments to `connect()`. These will be `undef` by default;
    if they were set from the command-line arguments, they will have non-`undef` values
    that override any option-file values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a script follows this procedure, parameters given by the user on the command
    line are passed to `connect()` and take precedence over the contents of option
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ruby Mysql2 scripts can read option files, specified by the `default_file` connection
    parameter. If you want to specify default group, use option `default_group`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses the standard option-file search order to look for options
    in both the `[cookbook]` and `[client]` groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example uses the *.my.cnf* file in the current user’s home directory
    to obtain parameters from the `[client]` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: PHP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned earlier, the PDO MySQL driver does not necessarily support using
    MySQL option files (it does not if you use `mysqlnd` as the underlying library).
    To work around that limitation, use a function that reads an option file, such
    as the `read_mysql_option_file()` function shown in the following listing. It
    takes as arguments the name of an option file and an option group name or an array
    containing group names. (Group names should be written without square brackets.)
    It then reads any options present in the file for the named group or groups. If
    no option group argument is given, the function looks by default in the `[client]`
    group. The return value is an array of option name/value pairs, or `FALSE` if
    an error occurs. It is not an error for the file not to exist. (Note that quoted
    option values and trailing `#`-style comments following option values are legal
    in MySQL option files, but this function does not handle those constructs.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two examples showing how to use `read_mysql_option_file()`. The first
    reads a user’s option file to get the `[client]` group parameters and uses them
    to connect to the server. The second reads the system-wide option file, */etc/my.cnf*,
    and prints the server startup parameters that are found there (that is, the parameters
    in the `[mysqld]` and `[server]` groups):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP does have a `parse_ini_file()` function that is intended for parsing *.ini*
    files. These have a syntax that is similar to MySQL option files, so you might
    find this function of use. However, there are some differences to watch out for.
    Suppose that you have a file written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Standard MySQL option parsing considers both the `user` and `host` values part
    of the `[client]` group, whereas `parse_ini_file()` returns only the contents
    of the final `[client]` stanza; the `user` option is lost. Also, `parse_ini_file()`
    ignores options that are given without a value, so the `no-auto-rehash` option
    is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Go-MySQL-Driver doesn’t support option files. However, the INI parsing
    library supports reading properties files that contain lines in the *`name=value`*
    format. Here is a sample properties file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Function `MyCnf()` shows one way to read a properties file named *~/.my.cnf*
    to obtain connection parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `MyCnf()` defined in the *cookbook.go*, developed elsewhere in
    the chapter (see [Recipe 4.3](#nch-api-api-library)). It is used in the file *mycnf.go*
    which you will find in the directory *api/06_conn_params* in the `recipes` distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: The function `MyCnf()` accepts section name as a parameter. If you want to replace
    section `[client]` with any other name call `MyCnf()` as `MyCnf("other")` where
    `other` is the name of the section.
  prefs: []
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The JDBC MySQL Connector/J driver doesn’t support option files. However, the
    Java class library supports reading properties files that contain lines in *`name=value`*
    format. This is similar but not identical to MySQL option-file format (for example,
    properties files do not permit ``[*`groupname`*]`` lines). Here is a simple properties
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program, *ReadPropsFile.java*, shows one way to read a properties
    file named *Cookbook.properties* to obtain connection parameters. The file must
    be in some directory named in your `CLASSPATH` variable, or you must specify it
    using a full pathname (the example shown here assumes that the file is in a `CLASSPATH`
    directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'To have `getProperty()` return a particular default value when the named property
    is not found, pass that value as a second argument. For example, to use `127.0.0.1`
    as the default `host` value, call `getProperty()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Cookbook.java* library file developed elsewhere in the chapter (see [Recipe
    4.3](#nch-api-api-library)) includes an extra library call in the version of the
    file that you’ll find in the *lib* directory of the `recipes` distribution: a
    `propsConnect()` routine that is based on the concepts discussed here. To use
    it, set up the contents of the properties file, *Cookbook.properties*, and copy
    the file to the same location where you installed *Cookbook.class*. You can then
    establish a connection within a program by importing the `Cookbook` class and
    calling `Cookbook.propsConnect()` rather than by calling `Cookbook.connect()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Resetting the profile Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While working on examples in this chapter you changed original content of the
    table `profile` and now want it back, so you can use it while working with other
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reload the table using the *mysql* client.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s a good idea to reset the `profile` table used in this chapter to a known
    state. Change location into the *tables* directory of the `recipes` distribution,
    and run these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Several statements in later chapters use the `profile` table; by reinitializing
    it, you’ll get the same results displayed in those chapters when you run the statements
    shown there.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discussed the basic operations provided by each of our APIs for
    handling various aspects of interaction with the MySQL server. These operations
    enable you to write programs that execute any kind of statement and retrieve the
    results. Up to this point, we’ve used simple statements because the focus is on
    the APIs rather than on SQL. The next chapter focuses on SQL instead, to show
    how to ask the database server more complex questions.
  prefs: []
  type: TYPE_NORMAL
