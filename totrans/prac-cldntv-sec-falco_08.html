<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Fields and Filters"><div class="chapter" id="fields_and_filters">
<h1><span class="label">Chapter 6. </span>Fields and Filters</h1>
<p>It’s finally time to take all the theory you learned in the previous chapters and start putting it into practice. In this chapter you will learn about Falco filters: what they are, how they work, and how to use them.</p>
<p>Filters are at the core of Falco. They are also a powerful investigation instrument that can be used in several other tools, such as sysdig. As a consequence, we expect that you will come back and consult this chapter often, even after finishing the book—so we’ve structured it to be used as a reference. For example, it contains tables with all of the operators and data types the filtering language provides, designed for quick consultation, as well as a well-documented list of Falco’s most useful fields. This chapter’s contents will be handy pretty much every time you write a Falco rule, so make sure to bookmark it!</p>
<section data-type="sect1" data-pdf-bookmark="What Is a Filter?"><div class="sect1" id="what_is_a_filterquestion_mark">
<h1>What Is a Filter?</h1>
<p><a contenteditable="false" data-primary="filters" data-secondary="basics" data-type="indexterm" id="ch06.html0"/>Let’s start with a semiformal definition:</p>
<blockquote>
<p><a contenteditable="false" data-primary="filters" data-secondary="defined" data-type="indexterm" id="idm45324227369968"/>A <em>filter</em> in Falco is a condition containing a sequence of comparisons that are connected by Boolean operators. Each of the comparisons evaluates a field, which is extracted from an input event, against a constant, using a relational operator. Comparisons in filters are evaluated left to right, but parentheses can be used to define precedence. A filter is applied to an input event and returns a Boolean result indicating if the event matches the filter.</p>
</blockquote>
<p>Ouch. That description is extremely dry and somewhat complicated. But if we unpack it, with the aid of some examples, you’ll see it’s not too bad. Let’s start with the first sentence:</p>
<blockquote>
<p>A <em>filter</em> in Falco is a condition containing a sequence of comparisons that are connected by Boolean operators.</p>
</blockquote>
<p>This just means that a filter looks like this:</p>
<pre data-type="programlisting">A = B and not C != D</pre>
<p>In other words, if you can write an <code>if</code> condition in any programming language, the filter syntax will look very familiar. Here’s the next sentence:</p>
<blockquote>
<p>Each of the comparisons evaluates a field, which is extracted from an input event, against a constant, using a relational operator.</p>
</blockquote>
<p>This tells us that Falco’s filtering syntax is based on the concept of <em>fields</em>, which we will describe in detail later in this chapter. Field names have a dotted syntax and appear on the left side of each comparison. On the right side is a constant value that will be compared against the field. Here’s an example:</p>
<pre data-type="programlisting">proc.name = emacs or proc.pid != 1234</pre>
<p>Moving on:</p>
<blockquote>
<p>Comparisons in filters are evaluated left to right, but parentheses can be used to define precedence.</p>
</blockquote>
<p>This means you can organize your filter using parentheses. For example:</p>
<pre data-type="programlisting">proc.name = emacs or (proc.name = vi and container.name=redis)</pre>
<p>Again, this works exactly the same as using parentheses inside a logical expression in your favorite programming language. Now for the final sentence:</p>
<blockquote>
<p>A filter is applied to an input event and returns a Boolean result indicating if the event matches the filter.</p>
</blockquote>
<p>When you specify a filter in a Falco rule, the filter is applied to every input event. For example, if you’re using one of Falco’s drivers, filters are applied to every system call. The filter evaluates the system call and returns a Boolean value: <code>true</code> or <code>false</code>. <code>true</code> means that the event satisfies the filter (we say that the filter <em>matches</em> the event), while <code>false</code> means that the filter rejects, or drops, the event. For example, this filter:</p> 
<pre data-type="programlisting">proc.name = emacs or proc.name = vi</pre>
<p>matches (returns <code>true</code> for) every system call generated by processes called <code>emacs</code> <span class="keep-together">or <code>vi</code></span>.</p>
<p>That’s essentially all you need to know at a high level. Now let’s dive into the details.<a contenteditable="false" data-primary="" data-startref="ch06.html0" data-type="indexterm" id="idm45324227350240"/></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Filtering Syntax Reference"><div class="sect1" id="filtering_syntax_reference">
<h1>Filtering Syntax Reference</h1>
<p><a contenteditable="false" data-primary="filters" data-secondary="syntax reference" data-type="indexterm" id="ch06.html1"/>From a syntactical point of view, as we mentioned, writing a Falco filter is very similar to writing an <code>if</code> condition in any programming language, so if you have basic programming experience, you shouldn’t expect any major surprises. However, there are some areas that are specific to the type of matching you do in Falco. This section takes a look at the syntax in detail, giving you the full picture.</p>
<section data-type="sect2" data-pdf-bookmark="Relational Operators"><div class="sect2" id="relational_operators">
<h2>Relational Operators</h2>
<p><a contenteditable="false" data-primary="filters" data-secondary="relational operators" data-type="indexterm" id="idm45324227343376"/><a contenteditable="false" data-primary="relational operators" data-type="indexterm" id="idm45324227342000"/><a data-type="xref" href="#falcoapostrophes_relational_operators">Table 6-1</a> provides a reference of all of the available relational operators, including an example for each of them.</p>
<table class="border" id="falcoapostrophes_relational_operators">
<caption><span class="label">Table 6-1. </span>Falco’s relational operators</caption>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code>, <code>!=</code></td>
<td>General equality/inequality operators. Can be used with all types of fields.</td>
<td><code>proc.name = emacs</code></td>
</tr>
<tr>
<td><code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code></td>
<td>Numeric comparison operators. Can be used with numeric fields only.</td>
<td><code>evt.buflen &gt; 100</code></td>
</tr>
<tr>
<td><code>contains</code></td>
<td>Can be used with string fields only. Performs a case-sensitive string search for the given constant inside the field value, and returns <code>true</code> if the field value contains the constant.</td>
<td><code>fd.filename contains passwd</code></td>
</tr>
<tr>
<td><code>icontains</code></td>
<td>Like <code>contains</code>, but case-insensitive.</td>
<td><code>user.name icontains john</code></td>
</tr>
<tr>
<td><code>bcontains</code></td>
<td>Like <code>contains</code>, but allows you to perform checks on binary buffers.</td>
<td><code>evt.buf bcontains DEADBEEF</code></td>
</tr>
<tr>
<td><code>startswith</code></td>
<td>Can be used with string fields only. Returns <code>true</code> if the given constant matches the beginning of the field value.</td>
<td><code>fd.directory startswith <span class="keep-together">"/etc"</span></code></td>
</tr>
<tr>
<td><code>bstartswith</code></td>
<td>Like <code>startswith</code>, but allows you to perform checks on binary buffers.</td>
<td><code>evt.buf bstartswith <span class="keep-together">DEADBEEF</span></code></td>
</tr>
<tr>
<td><code>endswith</code></td>
<td>Can be used with string fields only. Returns <code>true</code> if the given constant matches the end of the field value.</td>
<td><code>fd.filename endswidth ".key"</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td>Compares the field value to multiple constants and returns <code>true</code> if one or more of those constants equals the field value. Can be used with all fields, including numeric fields and string fields.</td>
<td><code>proc.name in (vi, emacs)</code></td>
</tr>
<tr>
<td><code><span class="keep-together">intersects</span></code></td>
<td>Returns <code>true</code> when a field with multiple values includes at least one value that matches one of the provided constants.</td>
<td><code>ka.req.pod.volumes.hostpath intersects (/proc, /var/run/docker.sock)</code></td>
</tr>
<tr>
<td><code>pmatch</code></td>
<td>Returns <code>true</code> if one of the constants is a prefix of the field value.<br/>Note: <code>pmatch</code> can be used as an alternative to the <code>in</code> operator, and performs better with large sets of constants because it is implemented internally as a trie instead of multiple comparisons.</td>
<td><code>fd.name pmatch (/var/run, <span class="keep-together">/etc,</span> /lib, /usr/lib)</code><br/><code>fd.name = /var/run/docker</code> succeeds because <code>/var/run</code> is a prefix of <code>/var/run/docker</code>.<br/><code>fd.name = /boot</code> does not succeed because no constant is a prefix of <code><span class="keep-together">/boot</span></code>.<br/><code>fd.name = /var</code> does not succeed because no constant is a prefix of <code>/var</code>.</td>
</tr>
<tr>
<td><code>exists</code></td>
<td>Returns <code>true</code> if the given field exists for the input event.</td>
<td><code>evt.res exists</code></td>
</tr>
<tr>
<td><code>glob</code></td>
<td>Matches the given string against the field value according to Unix shell wildcard patterns. <br/>For more details, enter <code><strong>man 7 glob</strong></code> in your terminal.</td>
<td><code>fd.name glob <span class="keep-together">'/home/*/.ssh/*'</span></code></td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Logical Operators"><div class="sect2" id="logical_operators">
<h2>Logical Operators</h2>
<p><a contenteditable="false" data-primary="filters" data-secondary="logical operators" data-type="indexterm" id="idm45324227290608"/><a contenteditable="false" data-primary="logical operators" data-type="indexterm" id="idm45324227289232"/>The logical operators that you can use in Falco filters are straightforward and don’t include any surprises. <a data-type="xref" href="#falcoapostrophes_logical_operators">Table 6-2</a> lists them and provides examples.</p>
<table class="border" id="falcoapostrophes_logical_operators">
<caption><span class="label">Table 6-2. </span>Falco’s logical operators</caption>
<thead>
<tr>
<th>Operator</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>and</code></td>
<td><code>proc.name = emacs and proc.cmdline contains myfile.txt</code></td>
</tr>
<tr>
<td><code>or</code></td>
<td><code>proc.name = emacs or proc.name = vi</code></td>
</tr>
<tr>
<td><code>not</code></td>
<td><code>not proc.name = emacs</code></td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Strings and Quoting"><div class="sect2" id="strings_and_quoting">
<h2>Strings and Quoting</h2>
<p><a contenteditable="false" data-primary="filters" data-secondary="strings and quoting" data-type="indexterm" id="idm45324227276368"/><a contenteditable="false" data-primary="strings, specifying" data-type="indexterm" id="idm45324227274992"/>String constants can be specified without quotation marks:</p>
<pre data-type="programlisting">proc.name = emacs</pre>
<p><a contenteditable="false" data-primary="&quot; (double quotes), delimiting strings with" data-type="indexterm" id="idm45324227272672"/><a contenteditable="false" data-primary="' (single quotes), delimiting strings with" data-type="indexterm" id="idm45324227271472"/><a contenteditable="false" data-primary="quotes, delimiting strings with" data-type="indexterm" id="idm45324227270336"/>Quotes can, however, be used to enclose strings that include spaces or special characters. Both single quotes and double quotes are accepted. For example:</p>
<pre data-type="programlisting">proc.name = "my process" or proc.name = 'my process'</pre>
<p>This means you can include quotes in strings:<a contenteditable="false" data-primary="" data-startref="ch06.html1" data-type="indexterm" id="idm45324227267872"/></p>
<pre data-type="programlisting">evt.buffer contains '"'</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Fields"><div class="sect1" id="fields">
<h1>Fields</h1>
<p><a contenteditable="false" data-primary="fields" data-secondary="basics" data-type="indexterm" id="ch06.html2"/>As you can see, Falco filters are not very complicated. However, they are extremely flexible and powerful. This power comes from the fields you can use in filtering conditions. Falco gives you access to a variety of fields, each of which exposes a property of the input events that Falco captures. Since fields are so important, let’s take a look at how they work and how they are organized. Then we’ll discuss which ones to use and when.</p>
<section data-type="sect2" data-pdf-bookmark="Argument Fields Versus Enrichment Fields"><div class="sect2" id="argument_fields_versus_enrichment_field">
<h2>Argument Fields Versus Enrichment Fields</h2>
<p><a contenteditable="false" data-primary="argument fields" data-type="indexterm" id="ch06.html3"/><a contenteditable="false" data-primary="enrichment fields" data-type="indexterm" id="ch06.html4"/><a contenteditable="false" data-primary="fields" data-secondary="argument fields versus enrichment fields" data-type="indexterm" id="ch06.html5"/>Fields expose properties of input events as typed values. A field, for example, can be a string, like the process name, or a number, like the process ID.</p>
<p>At the highest level, Falco offers two categories of fields. The first category includes the fields that are obtained by dissecting input events. System call arguments, like the filename for an <code>open</code> system call or the buffer argument for a <code>read</code> system call, are examples of such fields. You access these fields with the following syntax, where <code><em>X</em></code> is the name of the argument you want to access:</p>
<pre data-type="programlisting">evt.arg.<em>X</em></pre>
<p>or, where <code><em>N</em></code> is the position of the argument:</p>
<pre data-type="programlisting">evt.arg[<em>N</em>]</pre>
<p>For example:</p>
<pre data-type="programlisting">evt.arg.name = /etc/passwd
evt.arg[1] = /etc/passwd</pre>
<p>To find out which arguments a specific event type supports, sysdig is your friend. The output line for an event in sysdig will show you all of its arguments and their names.</p>
<p><a contenteditable="false" data-primary="libsinsp" data-secondary="enrichment fields and" data-type="indexterm" id="idm45324227248304"/>The second category consists of fields that derive from the enrichment process that <em>libsinsp</em> performs while capturing system calls and other events, described in <a data-type="xref" href="ch05.xhtml#data_enrichment">Chapter 5</a>. Falco exports many fields that expose the content of <em>libsinsp</em>’s thread and file descriptor tables, adding rich context about the events received from the drivers.</p>
<p>To help you understand how this works, let’s take the <code>proc.cwd</code> field as an example. For each system call that Falco captures, this field contains the current working directory of the process that issued the system call. This is handy if you want to capture all of the system calls generated by processes that are currently running inside a specific directory; for example:</p>
<pre data-type="programlisting">proc.cwd = /tmp</pre>
<p>The working directory of the process is not part of the system call, so exposing this field requires tracking the working directory of a process and attaching it to every system call that the process generates. This, in turn, involves four steps:</p>
<ol>
<li><p>Collect the working directory when a process starts, and store it in the process’s entry in the thread table.</p></li>
<li><p>Keep track of when the process changes its working directory (by intercepting and parsing the <code>chdir</code> system call), and update the thread table entry accordingly.</p></li>
<li><p>Resolve the thread ID of every system call to identify the corresponding thread table entry.</p></li>
<li><p>Return the thread table entry’s <code>cwd</code> value.</p></li>
</ol>
<p><em>libsinsp</em> does all of this, which means that the <code>proc.cwd</code> field is available for every system call, not only for directory-related ones like <code>chdir</code>. It’s impressive how much hard work Falco does to expose this field to you!</p>
<p>Enrichment-based filtering is powerful because it allows you to filter system calls (and any other events) based on properties that are not included with the syscalls themselves, but are of great use for security policies. For example, the following filter allows you to capture the system calls that read from or write to <em>/etc/passwd</em>:</p>
<pre data-type="programlisting">evt.is_io=true and fd.name=/etc/passwd</pre>
<p>It works even if these system calls originally don’t contain any information about the filename (they operate on file descriptors). The hundreds of enrichment-based fields available out of the box are the main reason why Falco is so powerful and versatile.<a contenteditable="false" data-primary="" data-startref="ch06.html5" data-type="indexterm" id="idm45324227234272"/><a contenteditable="false" data-primary="" data-startref="ch06.html4" data-type="indexterm" id="idm45324227232896"/><a contenteditable="false" data-primary="" data-startref="ch06.html3" data-type="indexterm" id="idm45324227231520"/></p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Mandatory Fields Versus Optional Fields"><div class="sect2" id="mandatory_fields_versus_optional_fields">
<h2>Mandatory Fields Versus Optional Fields</h2>
<p><a contenteditable="false" data-primary="fields" data-secondary="mandatory fields versus optional fields" data-type="indexterm" id="idm45324227228032"/><a contenteditable="false" data-primary="mandatory fields" data-type="indexterm" id="idm45324227226592"/><a contenteditable="false" data-primary="optional fields" data-type="indexterm" id="idm45324227225488"/>Some fields exist for every input event, and you will be guaranteed to find them regardless of the event type or family. Examples of such fields are <code>evt.ts</code>, <code>evt.dir</code>, and <code>evt.type</code>.</p>
<p>However, most fields are optional and only present in some input event types. Typically, you don’t have to worry about this, as fields that don’t exist will just <span class="keep-together">evaluate to</span> <code>false</code> without generating an error. For example, the following check will evaluate <span class="keep-together">to <code>false</code></span> for all events that don’t have an argument called <code>name</code>:</p>
<pre data-type="programlisting">evt.arg.name contains /etc</pre>
<p>In some cases, though, you might want to explicitly check if a field exists. One reason would be to resolve ambiguities like whether the filter <code>evt.arg.name != /etc</code> returns <code>true</code> or <code>false</code> for events that don’t have an argument called <code>name</code>. You can answer questions like this by using the <code>exists</code> relational operator:</p>
<pre data-type="programlisting">evt.arg.name exists and evt.arg.name != /etc</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Field Types"><div class="sect2" id="field_types">
<h2>Field Types</h2>
<p><a contenteditable="false" data-primary="fields" data-secondary="types" data-type="indexterm" id="ch06.html6"/>Fields have types, which are used to validate values and ensure the syntactic correctness of filters. Take the following filter:</p>
<pre data-type="programlisting">proc.pid = hello</pre>
<p>Falco and sysdig will reject this with the following error:</p>
<pre data-type="programlisting">filter error at position 16: hello is not a valid number</pre>
<p>This happens because the <code>proc.pid</code> field is of type <code>INT64</code>, so its value must be an integer. The typing system also allows Falco to improve the rendering of some fields by understanding the meaning behind them. For example, <code>evt.arg.res</code> is of type <code>ERRNO</code>, which by default is a number. However, when possible, Falco will resolve it into an error code string (such as <code>EAGAIN</code>), which improves the readability and usability of the field.</p>
<p>When we looked at relational operators, we noted how some are very similar to the ones in most programming languages, while others are unique to Falco filters. The same is true for field types. <a data-type="xref" href="#field_type">Table 6-3</a> lists the types you may encounter in Falco filter fields.</p>
<table class="border" id="field_type">
<caption><span class="label">Table 6-3. </span>Field types</caption>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>INT8</code>, <code>INT16</code>, <code>INT32</code>, <code>INT64</code>, <code>UINT8</code>, <code>UINT16</code>, <code>UINT32</code>, <code>UINT64</code>, <code>DOUBLE</code></td>
<td>Numeric types, like in your favorite programming language.</td>
</tr>
<tr>
<td><code>CHARBUF</code></td>
<td>A printable buffer of characters.</td>
</tr>
<tr>
<td><code>BYTEBUF</code></td>
<td>A raw buffer of bytes not suitable for printing.</td>
</tr>
<tr>
<td><code>ERRNO</code></td>
<td>An <code>INT64</code> value that, when possible, is resolved to an error code.</td>
</tr>
<tr>
<td><code>FD</code></td>
<td>An <code>INT64</code> value that, when possible, is resolved to the value of the file descriptor. For example, for a file this gets resolved to the filename; for a socket it gets resolved to the TCP connection tuple.</td>
</tr>
<tr>
<td><code>PID</code></td>
<td>An <code>INT64</code> value that, when possible, is resolved to the process name.</td>
</tr>
<tr>
<td><code>FSPATH</code></td>
<td>A string containing a relative or absolute filesystem path.</td>
</tr>
<tr>
<td><code>SYSCALLID</code></td>
<td>A 16-bit system call ID. When possible, the value gets resolved to the system call name.</td>
</tr>
<tr>
<td><code>SIGTYPE</code></td>
<td>An 8-bit signal number that, when possible, gets resolved to the signal name (e.g., <code>SIGCHLD</code>).</td>
</tr>
<tr>
<td><code>RELTIME</code></td>
<td>A relative time, with nanosecond precision, rendered as a human-readable string.</td>
</tr>
<tr>
<td><code>ABSTIME</code></td>
<td>An absolute time interval.</td>
</tr>
<tr>
<td><code>PORT</code></td>
<td>A TCP/UDP port. When possible, this gets resolved to a protocol name.</td>
</tr>
<tr>
<td><code>L4PROTO</code></td>
<td>A 1-byte IP protocol type. When possible, this gets resolved to a L4 protocol name (TCP, UDP).</td>
</tr>
<tr>
<td><code>BOOL</code></td>
<td>A Boolean value.</td>
</tr>
<tr>
<td><code>IPV4ADDR</code></td>
<td>An IPv4 address.</td>
</tr>
<tr>
<td><code>DYNAMIC</code></td>
<td>An indication that the field type can vary depending on the context. Used for generic fields like <code>evt.rawarg</code>.</td>
</tr>
<tr>
<td><code>FLAGS8</code>, <code>FLAGS16</code>, <code>FLAGS32</code></td>
<td>A flags word (i.e., a set of flags encoded as a number using binary encoding) that, when possible, is converted into a readable string (e.g., <code>O_RDONLY|O_CLOEXEC</code>). The resolution into the string is dependent on the context, as events can register their own flag values. So, for example, flags for an lseek system call event will be converted into values like <code>SEEK_END</code>, <code>SEEK_CUR</code>, and <code>SEEK_SET</code>, while <code>sockopt</code> flags will be converted into <code>SOL_SOCKET</code>, <code>SOL_TCP</code>, and so on.</td>
</tr>
<tr>
<td><code>UID</code></td>
<td>A Unix user ID, resolved to a username when possible.</td>
</tr>
<tr>
<td><code>GID</code></td>
<td>A Unix group ID, resolved to a group name when possible.</td>
</tr>
<tr>
<td><code>IPADDR</code></td>
<td>An IPv4 or IPv6 address.</td>
</tr>
<tr>
<td><code>IPNET</code></td>
<td>An IPv4 or IPv6 network.</td>
</tr>
<tr>
<td><code>MODE</code></td>
<td>A 32-bit bitmask to represent file modes.</td>
</tr>
</tbody>
</table>
<p>How do you find out the type of a field you want to use? The best way is to invoke Falco with the <code>--list</code> and <code>-v</code> options:</p>
<pre data-type="programlisting">$ <strong>falco --list -v</strong></pre>
<p>This will print the full list of fields, including type information for each entry in the list<a contenteditable="false" data-primary="" data-startref="ch06.html6" data-type="indexterm" id="idm45324227154704"/>.<a contenteditable="false" data-primary="" data-startref="ch06.html2" data-type="indexterm" id="idm45324227153200"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Using Fields and Filters"><div class="sect1" id="using_fields_and_filters">
<h1>Using Fields and Filters</h1>
<p><a contenteditable="false" data-primary="fields" data-secondary="using" data-type="indexterm" id="ch06.html7"/><a contenteditable="false" data-primary="filters" data-secondary="using" data-type="indexterm" id="ch06.html8"/>Now that you’ve learned about filters and fields, let’s take a look at how you can use them in practice. We’ll focus on Falco and sysdig.</p>
<section data-type="sect2" data-pdf-bookmark="Fields and Filters in Falco"><div class="sect2" id="fields_and_filters_in_falco">
<h2>Fields and Filters in Falco</h2>
<p><a contenteditable="false" data-primary="fields" data-secondary="Falco rules" data-type="indexterm" id="idm45324227144448"/><a contenteditable="false" data-primary="filters" data-secondary="Falco rules" data-type="indexterm" id="idm45324227143072"/><a contenteditable="false" data-primary="rules" data-secondary="fields/filters and" data-type="indexterm" id="idm45324227141696"/>Fields and filters are at the core of Falco rules. Fields are used to express rules’ conditions and are part of both conditions and outputs. To demonstrate how, we’ll craft our own rule.</p>
<p>Let’s say we would like Falco to notify us every time there is an attempt to change the permissions of a file and make it executable by another user. When that happens, we would like to know the name of the file that was changed, the new mode of the file, and the name of the user who caused the trouble. We would also like to know whether the mode change attempt was successful or not.</p>
<p>Here is the rule:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">File Becoming Executable by Others</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Attempt to make a file executable by other users</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">(evt.type=chmod or evt.type=fchmod or evt.type=fchmodat) </code><code class="w"/>
<code class="w">    </code><code class="no">and evt.arg.mode contains S_IXOTH</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">attempt to make a file executable by others </code><code class="w"/>
<code class="w">    </code><code class="no">(file=%evt.arg.filename mode=%evt.arg.mode user=%user.name </code><code class="w"/>
<code class="w">    </code><code class="no">failed=%evt.failed)</code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">WARNING</code><code class="w"/></pre>
<p>The <code>condition</code> section is where the rule’s filter is specified.</p>
<p>File modes, including the executable bit, are changed using the <code>chmod</code> system call, or one of its variants. Therefore, the first part of the filter selects events that are of type <code>chmod</code>, <code>fchmod</code>, or <code>fchmodat</code>:</p>
<pre data-type="programlisting">evt.type=chmod or evt.type=fchmod or evt.type=fchmodat</pre>
<p>Now that we have the right system calls, we want to accept only the subset of them that set the “other” executable bit. Reading the <a href="https://oreil.ly/zuKuC"><code>chmod</code> manual page</a> reveals that the flag we need to check is <code>S_IXOTH</code>. We determine its presence by using the <code>contains</code> operator:</p>
<pre data-type="programlisting">evt.arg.mode contains S_IXOTH</pre>
<p>Combining the two pieces with an <code>and</code> gives us the full filter. Easy!</p>
<p>Now, let’s focus our attention on the <code>output</code> section of the rule. This is where we tell Falco what to print on the screen when the rule’s condition returns <code>true</code>. You will notice that this is just a <code>printf</code>-like string that mixes regular text with fields, whose values will be resolved in the final message:</p>
<pre data-type="programlisting">attempt to make a file executable by others (file=%evt.arg.filename 
mode=%evt.arg.mode user=%user.name failed=%evt.failed)</pre>
<p>The only thing you need to remember is that you need to prefix field names in the output string with the <code>%</code> character; otherwise, they will just be treated as part of the string.</p>
<p>Time for you to try this! Save the preceding rule in a file called <em>ch6.yaml</em>. After that, run this command line in a terminal:</p>
<pre data-type="programlisting">$ <strong>sudo falco -r ch6.yaml</strong></pre>
<p>Then, in another terminal, run these two commands:</p>
<pre data-type="programlisting">$ <strong>echo test &gt; test.txt</strong>
$ <strong>chmod o+x test.txt</strong></pre>
<p>This is the output you will get in the Falco terminal:</p>
<pre data-type="programlisting">17:26:43.796934201: Warning attempt to make a file executable by others 
(file=/home/loris/test.txt mode=S_IXOTH|S_IWOTH|S_IROTH|S_IXGRP|S_IWGRP
|S_IRGRP|S_IXUSR|S_IWUSR|S_IRUSR user=root failed=false)</pre>
<p>Congratulations, you’ve just performed your very own Falco detection! Note how <code>evt.arg.mode</code> and <code>evt.failed</code> are rendered in a human-readable way, even if internally they are numbers. This shows you the power of the filter/fields type system.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Fields and Filters in sysdig"><div class="sect2" id="fields_and_filters_in_sysdig">
<h2>Fields and Filters in sysdig</h2>
<p><a contenteditable="false" data-primary="fields" data-secondary="sysdig" data-type="indexterm" id="idm45324227042864"/><a contenteditable="false" data-primary="filters" data-secondary="in sysdig" data-secondary-sortas="sysdig" data-type="indexterm" id="idm45324227041488"/><a contenteditable="false" data-primary="sysdig" data-secondary="fields/filters in" data-type="indexterm" id="idm45324227039840"/>An introduction to sysdig was provided in <a data-type="xref" href="ch04.xhtml#data_source">Chapter 4</a> (if you need a refresher, see <a data-type="xref" href="ch04.xhtml#sysdig">“sysdig”</a>). Here we will look specifically at how filters and fields are used in sysdig.</p>
<p>While Falco is based on the concepts of rules and of notifying the user when rules match, sysdig focuses on investigation, troubleshooting, and threat-hunting workflows. In sysdig, you use filters to <em>restrict</em> the input, and you (optionally) use field formatting to <em>control</em> the output. The combination of the two provides a ton of flexibility during investigations.</p>
<p>Filters in sysdig are specified at the end of the command line:</p>
<pre data-type="programlisting">$ <strong>sudo sysdig proc.name=echo</strong></pre>
<p>Output formatting is provided using the <code>-p</code> command-line flag and uses the same <code>printf</code>-like syntax that we just described when talking about Falco outputs:</p>
<pre data-type="programlisting">$ <strong>sudo sysdig -p"type:%evt.type proc:%proc.name" proc.name=echo</strong></pre>
<p>An important thing to keep in mind is that, when the <code>-p</code> flag is used, sysdig will only print an output line for the events in which <em>all</em> of the specified filters exist. So, this command:</p>
<pre data-type="programlisting">$ <strong>sudo sysdig -p"%evt.res %proc.name"</strong></pre>
<p>will print a line only for events that have both a return value <em>and</em> a process name, skipping, for example, all the system call “enter” events. If you care about seeing all of the events, put a star (<code>*</code>) at the beginning of the formatting string:</p>
<pre data-type="programlisting">$ <strong>sudo sysdig -p"*%evt.res %proc.name"</strong></pre>
<p>When a field is missing, it will be rendered as <code>&lt;NA&gt;</code>.</p>
<p>When no formatting is specified with <code>-p</code>, sysdig displays input events in a standard format that conveniently includes all of the arguments and argument names, for every system call. Here’s an example sysdig output line for an <code>openat</code> system call, with the system call arguments highlighted in bold for visibility:</p>
<pre data-type="programlisting">4831 20:50:01.473556825 2 cat (865.865) &lt; openat <strong>fd</strong>=7(&lt;f&gt;/tmp/myfile.txt) 
<strong>dirfd</strong>=-100(AT_FDCWD) <strong>name</strong>=/tmp/myfile.txt <strong>flags</strong>=1(O_RDONLY) <strong>mode</strong>=0 <strong>dev</strong>=4</pre>
<p>Each of the arguments can be used in a filter with the <code>evt.arg</code> syntax:</p>
<pre data-type="programlisting">$ <strong>sudo sysdig evt.arg.name=/tmp/myfile.txt</strong></pre>
<p>As a more advanced example, let’s convert the <em>File Becoming Executable by Others</em> rule we created for Falco in the previous section into a sysdig command line:</p>
<pre data-type="programlisting">$ <strong>sudo sysdig -p"attempt to make a file executable by others \
  (file=%evt.arg.filename mode=%evt.arg.mode user=%user.name \
  failed=%evt.failed)" \ 
  "(evt.type=chmod or evt.type=fchmod or evt.type=fchmodat) \ 
  and evt.arg.mode contains S_IXOTH"</strong></pre>
  <p>This shows how easy it is to use sysdig as a development tool when creating new rules.<a contenteditable="false" data-primary="" data-startref="ch06.html8" data-type="indexterm" id="idm45324227015776"/><a contenteditable="false" data-primary="" data-startref="ch06.html7" data-type="indexterm" id="idm45324227014304"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Falco’s Most Useful Fields"><div class="sect1" id="falcoapostrophes_most_useful_fields">
<h1>Falco’s Most Useful Fields</h1>
<p><a contenteditable="false" data-primary="fields" data-secondary="most important" data-type="indexterm" id="idm45324227011488"/>This section presents a curated list of some of the most important Falco fields, organized by class. You can use this list as a reference when writing filters. For a full list, including all plugin fields, use the following at the command line:</p>
<pre data-type="programlisting">$ <strong>falco --list -v</strong></pre>
<section data-type="sect2" data-pdf-bookmark="General"><div class="sect2" id="general">
<h2>General</h2>
<p><a contenteditable="false" data-primary="evt filter class fields" data-type="indexterm" id="idm45324227007120"/><a contenteditable="false" data-primary="fields" data-secondary="general" data-type="indexterm" id="idm45324227005920"/>The fields listed in <a data-type="xref" href="#evt_filter_class_fields">Table 6-4</a> apply to every event and include general properties of an event.</p>
<table class="border" id="evt_filter_class_fields">
<caption><span class="label">Table 6-4. </span><code>evt</code> filter class fields</caption>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>evt.num</code></td>
<td>The event number.</td>
</tr>
<tr>
<td><code>evt.time</code></td>
<td>The event timestamp as a string that includes the nanosecond part.</td>
</tr>
<tr>
<td><code>evt.dir</code></td>
<td>The event direction; can be either <code>&gt;</code> for enter events or <code>&lt;</code> for exit events.</td>
</tr>
<tr>
<td><code>evt.type</code></td>
<td>The name of the event (e.g., <code>open</code>).</td>
</tr>
<tr>
<td><code>evt.cpu</code></td>
<td>The number of the CPU where this event happened.</td>
</tr>
<tr>
<td><code>evt.args</code></td>
<td>All the event arguments, aggregated into a single string.</td>
</tr>
<tr>
<td><code>evt.rawarg</code></td>
<td>One of the event arguments, specified by name (e.g., <code>evt.rawarg.fd</code>).</td>
</tr>
<tr>
<td><code>evt.arg</code></td>
<td>One of the event arguments, specified by name or by number. Some events (such as return codes or file descriptors) will be converted into a text representation when possible (e.g., <code>evt.arg.fd</code> or <code>evt.arg[0]</code>).</td>
</tr>
<tr>
<td><code>evt.buffer</code></td>
<td>The binary data buffer for events that have one, like read, recvfrom, etc. Use this field in filters with <code>contains</code> to search in I/O data buffers.</td>
</tr>
<tr>
<td><code>evt.buflen</code></td>
<td>The length of the binary data buffer for events that have one, like <code>read</code>, <code>recvfrom</code>, etc.</td>
</tr>
<tr>
<td><code>evt.res</code></td>
<td>The event return value, as a string. If the event failed, the result is an error code string (e.g., <code>ENOENT</code>); otherwise, the result is the string <code>SUCCESS</code>.</td>
</tr>
<tr>
<td><code>evt.rawres</code></td>
<td>The event return value, as a number (e.g., <code>-2</code>). Useful for range comparisons.</td>
</tr>
<tr>
<td><code>evt.failed</code></td>
<td><code>true</code> for events that returned an error status.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Processes"><div class="sect2" id="processes">
<h2>Processes</h2>
<p><a contenteditable="false" data-primary="fields" data-secondary="process/thread information" data-type="indexterm" id="idm45324226971968"/><a contenteditable="false" data-primary="filters" data-secondary="process/thread information" data-type="indexterm" id="idm45324226970528"/><a contenteditable="false" data-primary="proc filter class fields" data-type="indexterm" id="idm45324226969136"/><a contenteditable="false" data-primary="processes, fields containing information about" data-type="indexterm" id="idm45324226968016"/><a contenteditable="false" data-primary="threads" data-secondary="fields containing information about" data-type="indexterm" id="idm45324226966816"/>The fields in this class contain all the information you need about processes and threads. The information in <a data-type="xref" href="#proc_filter_class_fields">Table 6-5</a> comes mostly from the process table that <em>libsinsp</em> constructs in memory.</p>
<table class="border" id="proc_filter_class_fields">
<caption><span class="label">Table 6-5. </span><code>proc</code> filter class fields</caption>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>proc.pid</code></td>
<td>The ID of the process generating the event.</td>
</tr>
<tr>
<td><code>proc.exe</code></td>
<td>The first command-line argument (usually the executable name or a custom one).</td>
</tr>
<tr>
<td><code>proc.name</code></td>
<td>The name (excluding the path) of the executable generating the event.</td>
</tr>
<tr>
<td><code>proc.args</code></td>
<td>The arguments passed on the command line when starting the process generating the event.</td>
</tr>
<tr>
<td><code>proc.env</code></td>
<td>The environment variables of the process generating the event.</td>
</tr>
<tr>
<td><code>proc.cwd</code></td>
<td>The current working directory of the event.</td>
</tr>
<tr>
<td><code>proc.ppid</code></td>
<td>The PID of the parent of the process generating the event.</td>
</tr>
<tr>
<td><code>proc.pname</code></td>
<td>The name (excluding the path) of the parent of the process generating the event.</td>
</tr>
<tr>
<td><code>proc.pcmdline</code></td>
<td>The full command line (<code>proc.name</code> + <code>proc.args</code>) of the parent of the process generating the event.</td>
</tr>
<tr>
<td><code>proc.loginshellid</code></td>
<td>The PID of the oldest shell among the ancestors of the current process, if there is one. This field can be used to separate different user sessions and is useful in conjunction with chisels like spy_user.</td>
</tr>
<tr>
<td><code>thread.tid</code></td>
<td>The ID of the thread generating the event.</td>
</tr>
<tr>
<td><code>thread.vtid</code></td>
<td>The ID of the thread generating the event as seen from its current PID namespace.</td>
</tr>
<tr>
<td><code>proc.vpid</code></td>
<td>The ID of the process generating the event as seen from its current PID namespace.</td>
</tr>
<tr>
<td><code>proc.sid</code></td>
<td>The session ID of the process generating the event.</td>
</tr>
<tr>
<td><code>proc.sname</code></td>
<td>The name of the current process’s session leader. This is either the process with <code>pid=proc.sid</code> or the eldest ancestor that has the same session ID as the current process.</td>
</tr>
<tr>
<td><code>proc.tty</code></td>
<td>The controlling terminal of the process. This is <code>0</code> for processes without a terminal.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="File Descriptors"><div class="sect2" id="file_descriptors">
<h2>File Descriptors</h2>
<p><a contenteditable="false" data-primary="fd filter class fields" data-type="indexterm" id="idm45324226931648"/><a contenteditable="false" data-primary="fields" data-secondary="file descriptors" data-type="indexterm" id="idm45324226930544"/><a contenteditable="false" data-primary="file descriptors" data-secondary="fields related to" data-type="indexterm" id="idm45324226929168"/><a contenteditable="false" data-primary="filters" data-secondary="file descriptors" data-type="indexterm" id="idm45324226927792"/><a data-type="xref" href="#fd_filter_class_fields">Table 6-6</a> lists the fields related to file descriptors, which are at the base of I/O. Fields containing details about files and directories, network connections, pipes, and other types of interprocess communication can all be found in this class.</p>
<table class="border" id="fd_filter_class_fields">
<caption><span class="label">Table 6-6. </span><code>fd</code> filter class fields</caption>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fd.num</code></td>
<td>The unique number identifying the file descriptor.</td>
</tr>
<tr>
<td><code>fd.typechar</code></td>
<td>The type of the file descriptor, as a single character. Can be <code>f</code> for file, <code>4</code> for IPv4 socket, <code>6</code> for IPv6 socket, <code>u</code> for Unix socket, <code>p</code> for pipe, <code>e</code> for eventfd, <code>s</code> for signalfd, <code>l</code> for eventpoll, <code>i</code> for inotify, or <code>o</code> for unknown.</td>
</tr>
<tr>
<td><code>fd.name</code></td>
<td>The full name of the file descriptor. If it’s a file, this field contains the full path. If it’s a socket, this field contains the connection tuple.</td>
</tr>
<tr>
<td><code>fd.directory</code></td>
<td>If the file descriptor is a file, the directory that contains it.</td>
</tr>
<tr>
<td><code>fd.filename</code></td>
<td>If the file descriptor is a file, the filename without the path.</td>
</tr>
<tr>
<td><code>fd.ip</code></td>
<td><em>(Filter only)</em> Matches the IP address (client or server) of the file descriptor.</td>
</tr>
<tr>
<td><code>fd.cip</code></td>
<td>The client’s IP address.</td>
</tr>
<tr>
<td><code>fd.sip</code></td>
<td>The server’s IP address.</td>
</tr>
<tr>
<td><code>fd.lip</code></td>
<td>The local IP address.</td>
</tr>
<tr>
<td><code>fd.rip</code></td>
<td>The remote IP address.</td>
</tr>
<tr>
<td><code>fd.port</code></td>
<td><em>(Filter only)</em> Matches the port (either client or server) of the file descriptor.</td>
</tr>
<tr>
<td><code>fd.cport</code></td>
<td>For TCP/UDP file descriptors, the client’s port.</td>
</tr>
<tr>
<td><code>fd.sport</code></td>
<td>For TCP/UDP file descriptors, the server’s port.</td>
</tr>
<tr>
<td><code>fd.lport</code></td>
<td>For TCP/UDP file descriptors, the local port.</td>
</tr>
<tr>
<td><code>fd.rport</code></td>
<td>For TCP/UDP file descriptors, the remote port.</td>
</tr>
<tr>
<td><code>fd.l4proto</code></td>
<td>The IP protocol of a socket. Can be <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>raw</code>.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Users and Groups"><div class="sect2" id="users_and_groups">
<h2>Users and Groups</h2>
<p><a contenteditable="false" data-primary="fields" data-secondary="user/group filter classes" data-type="indexterm" id="idm45324226888640"/><a contenteditable="false" data-primary="filters" data-secondary="user/group filter classes" data-type="indexterm" id="idm45324226887296"/><a contenteditable="false" data-primary="group filter class fields" data-type="indexterm" id="idm45324226885904"/><a contenteditable="false" data-primary="user filter class fields" data-type="indexterm" id="idm45324226884784"/><a data-type="xref" href="#user_and_group_filter_class_fields">Table 6-7</a> lists the fields in the <code>user</code> and <code>group</code> filter classes.</p>
<table class="border" id="user_and_group_filter_class_fields">
<caption><span class="label">Table 6-7. </span><code>user</code> and <code>group</code> filter class fields</caption>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>user.uid</code></td>
<td>The user’s ID</td>
</tr>
<tr>
<td><code>user.name</code></td>
<td>The user’s name</td>
</tr>
<tr>
<td><code>group.gid</code></td>
<td>The group’s ID</td>
</tr>
<tr>
<td><code>group.name</code></td>
<td>The group’s name</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Containers"><div class="sect2" id="containers">
<h2>Containers</h2>
<p><a contenteditable="false" data-primary="container filter class fields" data-type="indexterm" id="idm45324226869584"/><a contenteditable="false" data-primary="fields" data-secondary="container class" data-type="indexterm" id="idm45324226868464"/><a contenteditable="false" data-primary="filters" data-secondary="container class" data-type="indexterm" id="idm45324226867088"/>The fields in the <code>container</code> class (<a data-type="xref" href="#container_filter_class_fields">Table 6-8</a>) can be used for everything related to containers, including obtaining IDs, names, labels, and mounts.</p>
<table class="border" id="container_filter_class_fields">
<caption><span class="label">Table 6-8. </span><code>container</code> filter class fields</caption>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>container.id</code></td>
<td>The container ID.</td>
</tr>
<tr>
<td><code>container.name</code></td>
<td>The container name.</td>
</tr>
<tr>
<td><code>container.image</code></td>
<td>The container image name (e.g., <code>falcosecurity/falco:latest</code> for Docker).</td>
</tr>
<tr>
<td><code>con⁠tainer.image​.id</code></td>
<td>The container image ID (e.g., <code>6f7e2741b66b</code>).</td>
</tr>
<tr>
<td><code>container​.privi⁠leged</code></td>
<td><code>true</code> for containers running as privileged, <code>false</code> otherwise.</td>
</tr>
<tr>
<td><code>con⁠tainer​.mounts</code></td>
<td>A space-separated list of mount information. Each item in the list has the format <code><em>&lt;source&gt;</em>:<em>&lt;dest&gt;</em>:<em>&lt;mode&gt;</em>:<em>&lt;rdrw&gt;</em>:<em>&lt;propagation&gt;</em></code>.</td>
</tr>
<tr>
<td><code>container.mount</code></td>
<td>Information about a single mount, specified by number (e.g., <code>container.mount[0]</code>) or mount source (e.g., <code><span class="keep-together">con⁠tainer</span>.mount[/usr/local]</code>). The pathname can be a glob (e.g., <code><span class="keep-together">container</span>.mount[/usr/local/*]</code>), in which case the first matching mount will be returned. <span class="keep-together">The information</span> has the format <code><em>&lt;source&gt;</em>:<em>&lt;dest&gt;</em>:<em>&lt;mode&gt;</em>:<em>&lt;rdrw&gt;</em>:<em>&lt;propagation&gt;</em></code>. If there is no mount with the specified index or matching the provided source, this returns the string <code>"none"</code> instead of a NULL value.</td>
</tr>
<tr>
<td><code>container.image​.reposi⁠tory</code></td>
<td>The container image repository (e.g., <code>falcosecurity/falco</code>).</td>
</tr>
<tr>
<td><code>con⁠tainer.image​.tag</code></td>
<td>The container image tag (e.g., <code>stable</code>, <code>latest</code>).</td>
</tr>
<tr>
<td><code>con⁠tainer.image​.digest</code></td>
<td>The container image registry digest (e.g., <code>sha256:d977378f890d445c15e51795296​e4e5062f109ce6da83e0a355fc4ad8699d27</code>).</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Kubernetes"><div class="sect2" id="kubernetes">
<h2>Kubernetes</h2>
<p><a contenteditable="false" data-primary="fields" data-secondary="Kubernetes filter class fields" data-type="indexterm" id="idm45324226831152"/><a contenteditable="false" data-primary="filters" data-secondary="Kubernetes filter class fields" data-type="indexterm" id="idm45324226829712"/><a contenteditable="false" data-primary="k8s filter class fields" data-type="indexterm" id="idm45324226828320"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="k8s filter class fields" data-type="indexterm" id="idm45324226827216"/>When Falco is configured to interface with the Kubernetes API server, the fields in this class (listed in <a data-type="xref" href="#keights_filter_class_fields">Table 6-9</a>) can be used to fetch information about Kubernetes objects.</p>
<table class="border" id="keights_filter_class_fields">
<caption><span class="label">Table 6-9. </span><code>k8s</code> filter class fields</caption>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>k8s.pod.name</code></td>
<td>The Kubernetes Pod name.</td>
</tr>
<tr>
<td><code>k8s.pod.id</code></td>
<td>The Kubernetes Pod ID.</td>
</tr>
<tr>
<td><code>k8s.pod.label</code></td>
<td>The Kubernetes Pod label (e.g., <code>k8s.pod.label.foo</code>).</td>
</tr>
<tr>
<td><code>k8s.rc.name</code></td>
<td>The Kubernetes ReplicationController name.</td>
</tr>
<tr>
<td><code>k8s.rc.id</code></td>
<td>The Kubernetes ReplicationController ID.</td>
</tr>
<tr>
<td><code>k8s.rc.label</code></td>
<td>The Kubernetes ReplicationController label (e.g., <code>k8s.rc.label.foo</code>).</td>
</tr>
<tr>
<td><code>k8s.svc.name</code></td>
<td>The Kubernetes Service name. Can return more than one value, concatenated.</td>
</tr>
<tr>
<td><code>k8s.svc.id</code></td>
<td>The Kubernetes Service ID. Can return more than one value, concatenated.</td>
</tr>
<tr>
<td><code>k8s.svc.label</code></td>
<td>The Kubernetes Service label (e.g., <code>k8s.svc.label.foo)</code>. Can return more than one value, concatenated.</td>
</tr>
<tr>
<td><code>k8s.ns.name</code></td>
<td>The Kubernetes namespace name.</td>
</tr>
<tr>
<td><code>k8s.ns.id</code></td>
<td>The Kubernetes namespace ID.</td>
</tr>
<tr>
<td><code>k8s.ns.label</code></td>
<td>The Kubernetes namespace label (e.g., <code>k8s.ns.label.foo</code>).</td>
</tr>
<tr>
<td><code>k8s.rs.name</code></td>
<td>The Kubernetes ReplicaSet name.</td>
</tr>
<tr>
<td><code>k8s.rs.id</code></td>
<td>The Kubernetes ReplicaSet ID.</td>
</tr>
<tr>
<td><code>k8s.rs.label</code></td>
<td>The Kubernetes ReplicaSet label (e.g., <code>k8s.rs.label.foo</code>).</td>
</tr>
<tr>
<td><code>k8s.deploy⁠ment​.name</code></td>
<td>The Kubernetes Deployment name.</td>
</tr>
<tr>
<td><code>k8s.deployment.id</code></td>
<td>The Kubernetes Deployment ID.</td>
</tr>
<tr>
<td><code><span class="keep-together">k8s.deployment.label</span></code></td>
<td>The Kubernetes Deployment label (e.g., <code>k8s.rs.label.foo</code>).</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="CloudTrail"><div class="sect2" id="cloudtrail">
<h2>CloudTrail</h2>
<p><a contenteditable="false" data-primary="CloudTrail" data-secondary="cloudtrail filter class fields" data-type="indexterm" id="idm45324226788656"/><a contenteditable="false" data-primary="fields" data-secondary="cloudtrail class" data-type="indexterm" id="idm45324226787264"/><a contenteditable="false" data-primary="filters" data-secondary="cloudtrail class" data-type="indexterm" id="idm45324226785888"/>The fields in the <code>cloudtrail</code> class (listed in <a data-type="xref" href="#cloudtrail_filter_class_fields">Table 6-10</a>) are available when the CloudTrail plugin is configured. They allow you to build filters and formatters for AWS detections.</p>
<table class="border" id="cloudtrail_filter_class_fields">
<caption><span class="label">Table 6-10. </span><code>cloudtrail</code> filter class fields</caption>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ct.error</code></td>
<td>The error code from the event. Will be <code>""</code> if there was no error.</td>
</tr>
<tr>
<td><code>ct.src</code></td>
<td>The source of the CloudTrail event (<code>eventSource</code> in the JSON).</td>
</tr>
<tr>
<td><code>ct.shortsrc</code></td>
<td>The source of the CloudTrail event (<code>eventSource</code> in the JSON), without the <code>.amazonaws.com</code> trailer.</td>
</tr>
<tr>
<td><code>ct.name</code></td>
<td>The name of the CloudTrail event (<code>eventName</code> in the JSON).</td>
</tr>
<tr>
<td><code>ct.user</code></td>
<td>The user of the CloudTrail event (<code>userIdentity.userName</code> in the JSON).</td>
</tr>
<tr>
<td><code>ct.region</code></td>
<td>The region of the CloudTrail event (<code>awsRegion</code> in the JSON).</td>
</tr>
<tr>
<td><code>ct.srcip</code></td>
<td>The IP address generating the event (<code>sourceIPAddress</code> in the JSON).</td>
</tr>
<tr>
<td><code>ct.useragent</code></td>
<td>The user agent generating the event (<code>userAgent</code> in the JSON).</td>
</tr>
<tr>
<td><code>ct.readonly</code></td>
<td><code>true</code> if the event only reads information (e.g., <code>DescribeInstances</code>), <code>false</code> if the event modifies the state (e.g., <code>RunInstances</code>, <code>CreateLoadBalancer</code>).</td>
</tr>
<tr>
<td><code>s3.uri</code></td>
<td>The S3 URI (<code>s3://<em>&lt;bucket&gt;</em>/<em>&lt;key&gt;</em></code>).</td>
</tr>
<tr>
<td><code>s3.bucket</code></td>
<td>The bucket name for S3 events.</td>
</tr>
<tr>
<td><code>s3.key</code></td>
<td>The S3 key name.</td>
</tr>
<tr>
<td><code>ec2.name</code></td>
<td>The name of the EC2 instance, typically stored in the instance tags.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Kubernetes Audit Logs"><div class="sect2" id="kubernetes_audit_logs">
<h2>Kubernetes Audit Logs</h2>
<p><a contenteditable="false" data-primary="fields" data-secondary="Kubernetes audit log filter class fields" data-type="indexterm" id="idm45324226750384"/><a contenteditable="false" data-primary="filters" data-secondary="Kubernetes audit log filter class fields" data-type="indexterm" id="idm45324226748912"/><a contenteditable="false" data-primary="k8saudit filter class fields" data-type="indexterm" id="idm45324226747504"/><a contenteditable="false" data-primary="Kubernetes audit logs" data-secondary="filter class fields" data-type="indexterm" id="idm45324226746336"/>Fields related to Kubernetes audit logs (listed in <a data-type="xref" href="#keightsaudit_filter_class_fields">Table 6-11</a>) are available when the k8saudit plugin is configured. The k8saudit plugin is responsible for interfacing Falco with the Kubernetes audit logs facility. The fields exported by the plugin can be used to monitor several types of Kubernetes activities.</p>
<table class="border" id="keightsaudit_filter_class_fields">
<caption><span class="label">Table 6-11. </span><code>k8saudit</code> filter class fields</caption>
<thead>
<tr>
<th>Field name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ka.user.name</code></td>
<td>The name of the user performing the request</td>
</tr>
<tr>
<td><code>ka.user.groups</code></td>
<td>The groups to which the user belongs</td>
</tr>
<tr>
<td><code>ka.verb</code></td>
<td>The action being performed</td>
</tr>
<tr>
<td><code>ka.uri</code></td>
<td>The request URI as sent from client to server</td>
</tr>
<tr>
<td><code>ka.uri.param</code></td>
<td>The value of a given query parameter in the URI (e.g., when <code>uri=/foo?key=val</code>, <code>ka.uri.param[key]</code> is <code>val</code>)</td>
</tr>
<tr>
<td><code>ka.target.name</code></td>
<td>The target object’s name</td>
</tr>
<tr>
<td><code>ka.target.namespace</code></td>
<td>The target object’s namespace</td>
</tr>
<tr>
<td><code>ka.target.resource</code></td>
<td>The target object’s resource</td>
</tr>
<tr>
<td><code>ka.req.configmap.name</code></td>
<td>When the request object refers to a ConfigMap, the ConfigMap name</td>
</tr>
<tr>
<td><code>ka.req.pod.containers.image</code></td>
<td>When the request object refers to a Pod, the container’s images</td>
</tr>
<tr>
<td><code>ka.req.pod.containers​.privi⁠leged</code></td>
<td>When the request object refers to a Pod, the value of the <code>privileged</code> flag for all containers</td>
</tr>
<tr>
<td><code>ka.req.pod.containers<br/>.add_capabilities</code></td>
<td>When the request object refers to a Pod, all capabilities to add when running <span class="keep-together">the container</span></td>
</tr>
<tr>
<td><code>ka.req.role.rules</code></td>
<td>When the request object refers to a role or cluster role, the rules associated with the role</td>
</tr>
<tr>
<td><code>ka.req.role.rules.verbs</code></td>
<td>When the request object refers to a role or cluster role, the verbs associated with the role’s rules</td>
</tr>
<tr>
<td><code>ka.req.role.rules<br/>.resources</code></td>
<td>When the request object refers to a role or cluster role, the resources associated with the role’s rules</td>
</tr>
<tr>
<td><code>ka.req.service.type</code></td>
<td>When the request object refers to a service, the service type</td>
</tr>
<tr>
<td><code>ka.resp.name</code></td>
<td>The response object’s name</td>
</tr>
<tr>
<td><code>ka.response.code</code></td>
<td>The response code</td>
</tr>
<tr>
<td><code>ka.response.reason</code></td>
<td>The response reason (usually present only for failures)</td>
</tr>
</tbody>
</table>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000005">
<h1>Conclusion</h1>
<p>Congratulations, you are now a filtering expert! At this point, you should be able to read and understand Falco rules, and you are much closer to being able to write your own. In the next chapter, we will devote our attention to Falco’s outputs.</p>
</div></section>
</div></section></div></body></html>