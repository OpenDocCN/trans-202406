["```\n- index.js\n- List.js\n- Detail.js\n- dist/\n  - clientBundle.js\n```", "```\n// index.js\n\nimport React from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport Router from \"./Router\";\n\nconst root = createRoot(document);\n\nconst params = new URLSearchParams();\nconst thingId = params.get(\"id\");\n\nroot.render(\n  window.location.pathname === \"/\" ? <List /> : <Detail thingId={thingId} />\n);\n\n// List.js\n\nexport const List = () => {\n  const [things, setThings] = useState([]);\n  const [requestState, setRequestState] = useState(\"initial\");\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    setRequestState(\"loading\");\n    fetch(\"https://api.com/get-list\")\n      .then((r) => r.json())\n      .then(setThings)\n      .then(() => {\n        setRequestState(\"success\");\n      })\n      .catch((e) => {\n        setRequestState(\"error\");\n        setError(e);\n      });\n  }, []);\n\n  return (\n    <div>\n      <ul>\n        {things.map((thing) => (\n          <li key={thing.id}>{thing.label}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\n// Detail.js\n\nexport const Detail = ({ thingId }) => {\n  const [thing, setThing] = useState([]);\n  const [requestState, setRequestState] = useState(\"initial\");\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    setRequestState(\"loading\");\n    fetch(\"https://api.com/get-thing/\" + thingId)\n      .then((r) => r.json())\n      .then(setThings)\n      .then(() => {\n        setRequestState(\"success\");\n      })\n      .catch((e) => {\n        setRequestState(\"error\");\n        setError(e);\n      });\n  }, []);\n\n  return (\n    <div>\n      <h1>The thing!</h1>\n      {thing}\n    </div>\n  );\n};\n```", "```\n// ./server.js\n\nimport express from \"express\";\nimport { renderToString } from \"react-dom/server\"; // Covered in Chapter 6\n\nimport { List } from \"./List\";\nimport { Detail } from \"./Detail\";\n\nconst app = express();\n\napp.use(express.static(\"./dist\")); // Get static files like client JS, etc.\n\nconst createLayout = (children) => `<html lang=\"en\">\n<head>\n <title>My page</title>\n</head>\n<body>\n  ${children}\n <script src=\"/clientBundle.js\"></script>\n</body>\n<html>`;\n\napp.get(\"/\", (req, res) => {\n  res.setHeader(\"Content-Type\", \"text/html\");\n  res.end(createLayout(renderToString(<List />)));\n});\n\napp.get(\"/detail\", (req, res) => {\n  res.setHeader(\"Content-Type\", \"text/html\");\n  res.end(\n    createLayout(renderToString(<Detail thingId={req.params.thingId} />))\n  );\n});\n\napp.listen(3000, () => {\n  console.info(\"App is listening!\");\n});\n```", "```\n- index.js\n- pages/\n  - list.js\n  - detail.js\n- dist/\n  - clientBundle.js\n```", "```\n// ./server.js\n\nimport express from \"express\";\nimport { join } from \"path\";\nimport { renderToString } from \"react-dom/server\"; // Covered in Chapter 6\n\nconst app = express();\n\napp.use(express.static(\"./dist\")); // Get static files like client JS, etc.\n\nconst createLayout = (children) => `<html lang=\"en\">\n<head>\n <title>My page</title>\n</head>\n<body>\n  ${children}\n <script src=\"/clientBundle.js\"></script>\n</body>\n<html>`;\n\napp.get(\"/:route\", async (req, res) => {\n  // Import the route's component from the pages directory\n  const exportedStuff = await import(\n    join(process.cwd(), \"pages\", req.params.route)\n  );\n\n  // We can no longer have named exports because we need predictability\n  // so we opt for default exports instead.\n  // `.default` is standardized and therefore we can rely on it.\n  const Page = exportedStuff.default;\n\n  // We can infer props from the query string maybe?\n  const props = req.query;\n\n  res.setHeader(\"Content-Type\", \"text/html\");\n  res.end(createLayout(renderToString(<Page {...props} />)));\n});\n\napp.listen(3000, () => {\n  console.info(\"App is listening!\");\n});\n```", "```\n// ./pages/list.jsx\n// Note the default export for filesystem-based routing.\n\nexport default function List({ initialThings } /* <- adding initial prop */) {\n  const [things, setThings] = useState(initialThings);\n  const [requestState, setRequestState] = useState(\"initial\");\n  const [error, setError] = useState(null);\n\n  // This can still run to fetch data if we need it to.\n  useEffect(() => {\n    if (initialThings) return;\n    setRequestState(\"loading\");\n    fetch(\"https://api.com/get-list\")\n      .then((r) => r.json())\n      .then(setThings)\n      .then(() => {\n        setRequestState(\"success\");\n      })\n      .catch((e) => {\n        setRequestState(\"error\");\n        setError(e);\n      });\n  }, [initialThings]);\n\n  return (\n    <div>\n      <ul>\n        {things.map((thing) => (\n          <li key={thing.id}>{thing.label}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```", "```\n// ./server.js\n\nimport express from \"express\";\nimport { join } from \"path\";\nimport { renderToString } from \"react-dom/server\"; // Covered in Chapter 6\n\nconst app = express();\n\napp.use(express.static(\"./dist\")); // Get static files like client JS, etc.\n\nconst createLayout = (children) => `<html lang=\"en\">\n<head>\n <title>My page</title>\n</head>\n<body>\n  ${children}\n <script src=\"/clientBundle.js\"></script>\n</body>\n<html>`;\n\napp.get(\"/:route\", async (req, res) => {\n  const exportedStuff = await import(\n    join(process.cwd(), \"pages\", req.params.route)\n  );\n\n  const Page = exportedStuff.default;\n\n  // Get component's data\n  const data = await exportedStuff.getData();\n  const props = req.query;\n\n  res.setHeader(\"Content-Type\", \"text/html\");\n\n  // Pass props and data\n  res.end(createLayout(renderToString(<Page {...props} {...data.props} />)));\n});\n\napp.listen(3000, () => {\n  console.info(\"App is listening!\");\n});\n```", "```\n// ./pages/list.jsx\n\n// We'll call this on the server and pass these props to the component\nexport const getData = async () => {\n  return {\n    props: {\n      initialThings: await fetch(\"https://api.com/get-list\").then((r) =>\n        r.json()\n      ),\n    },\n  };\n};\n\nexport default function List({ initialThings } /* <- adding initial prop */) {\n  const [things, setThings] = useState(initialThings);\n  const [requestState, setRequestState] = useState(\"initial\");\n  const [error, setError] = useState(null);\n\n  // This can still run to fetch data if we need it to.\n  useEffect(() => {\n    if (initialThings) return;\n    setRequestState(\"loading\");\n    getData()\n      .then(setThings)\n      .then(() => {\n        setRequestState(\"success\");\n      })\n      .catch((e) => {\n        setRequestState(\"error\");\n        setError(e);\n      });\n  }, [initialThings]);\n\n  return (\n    <div>\n      <ul>\n        {things.map((thing) => (\n          <li key={thing.id}>{thing.label}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```", "```\nnpm create remix@2.2.0\n```", "```\nimport { PassThrough } from \"node:stream\";\n\nimport type { AppLoadContext, EntryContext } from \"@remix-run/node\";\nimport { createReadableStreamFromReadable } from \"@remix-run/node\";\nimport { RemixServer } from \"@remix-run/react\";\nimport isbot from \"isbot\";\nimport { renderToPipeableStream } from \"react-dom/server\";\n\nconst ABORT_DELAY = 5_000;\n\nexport default function handleRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext,\n  loadContext: AppLoadContext\n) {\n  return isbot(request.headers.get(\"user-agent\"))\n    ? handleBotRequest(\n        request,\n        responseStatusCode,\n        responseHeaders,\n        remixContext\n      )\n    : handleBrowserRequest(\n        request,\n        responseStatusCode,\n        responseHeaders,\n        remixContext\n      );\n}\n\nfunction handleBotRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext\n) {\n  return new Promise((resolve, reject) => {\n    let shellRendered = false;\n    const { pipe, abort } = renderToPipeableStream(\n      <RemixServer\n        context={remixContext}\n        url={request.url}\n        abortDelay={ABORT_DELAY}\n      />,\n      {\n        onAllReady() {\n          shellRendered = true;\n          const body = new PassThrough();\n          const stream = createReadableStreamFromReadable(body);\n\n          responseHeaders.set(\"Content-Type\", \"text/html\");\n\n          resolve(\n            new Response(stream, {\n              headers: responseHeaders,\n              status: responseStatusCode,\n            })\n          );\n\n          pipe(body);\n        },\n        onShellError(error: unknown) {\n          reject(error);\n        },\n        onError(error: unknown) {\n          responseStatusCode = 500;\n          // Log streaming rendering errors from inside the shell.  Don't log\n          // errors encountered during initial shell rendering since they'll\n          // reject and get logged in handleDocumentRequest.\n          if (shellRendered) {\n            console.error(error);\n          }\n        },\n      }\n    );\n\n    setTimeout(abort, ABORT_DELAY);\n  });\n}\n\nfunction handleBrowserRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext\n) {\n  return new Promise((resolve, reject) => {\n    let shellRendered = false;\n    const { pipe, abort } = renderToPipeableStream(\n      <RemixServer\n        context={remixContext}\n        url={request.url}\n        abortDelay={ABORT_DELAY}\n      />,\n      {\n        onShellReady() {\n          shellRendered = true;\n          const body = new PassThrough();\n          const stream = createReadableStreamFromReadable(body);\n\n          responseHeaders.set(\"Content-Type\", \"text/html\");\n\n          resolve(\n            new Response(stream, {\n              headers: responseHeaders,\n              status: responseStatusCode,\n            })\n          );\n\n          pipe(body);\n        },\n        onShellError(error: unknown) {\n          reject(error);\n        },\n        onError(error: unknown) {\n          responseStatusCode = 500;\n          // Log streaming rendering errors from inside the shell.  Don't log\n          // errors encountered during initial shell rendering since they'll\n          // reject and get logged in handleDocumentRequest.\n          if (shellRendered) {\n            console.error(error);\n          }\n        },\n      }\n    );\n\n    setTimeout(abort, ABORT_DELAY);\n  });\n}\n```", "```\nexport default function CheesePage() {\n  return <h1>This might sound cheesy, but I think you're really grate!</h1>;\n}\n```", "```\n// Get some utils\nimport { json } from \"@remix-run/node\";\nimport { useLoaderData } from \"@remix-run/react\";\n\n// The loader\nexport async function loader() {\n  const data = await fetch(\"https://api.com/get-cheeses\");\n  return json(await data.json());\n}\n\nexport default function CheesePage() {\n  const cheeses = useLoaderData();\n  return (\n    <div>\n      <h1>This might sound cheesy, but I think you're really grate!</h1>\n      <ul>\n        {cheeses.map((cheese) => (\n          <li key={cheese.id}>{cheese.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```", "```\n// Get some utils\nimport { json } from \"@remix-run/node\";\nimport { useLoaderData } from \"@remix-run/react\";\n\n// The loader\nexport async function loader() {\n  const data = await fetch(\"https://api.com/get-cheeses\");\n  return json(await data.json());\n}\n\nexport default function CheesePage() {\n  const cheeses = useLoaderData();\n  return (\n    <div>\n      <h1>This might sound cheesy, but I think you're really grate!</h1>\n      <ul>\n        {cheeses.map((cheese) => (\n          <li key={cheese.id}>{cheese.name}</li>\n        ))}\n      </ul>\n      <form action=\"/cheese\" method=\"post\">\n        <input type=\"text\" name=\"cheese\" />\n        <button type=\"submit\">Add Cheese</button>\n      </form>\n    </div>\n  );\n}\n```", "```\n// Get some utils\nimport { json, ActionFunctionArgs, redirect } from \"@remix-run/node\";\nimport { useLoaderData } from \"@remix-run/react\";\n\n// The loader\nexport async function loader() {\n  const data = await fetch(\"https://api.com/get-cheeses\");\n  return json(await data.json());\n}\n\n// The form action\nexport async function action({ params, request }: ActionFunctionArgs) {\n  const formData = await request.formData();\n\n  await fetch(\"https://api.com/add-cheese\", {\n    method: \"POST\",\n    body: JSON.stringify({\n      name: formData.get(\"cheese\"),\n    }),\n  });\n\n  return redirect(\"/cheese\"); // Come back to this page, but with GET this time.\n}\n\nexport default function CheesePage() {\n  const cheeses = useLoaderData();\n  return (\n    <div>\n      <h1>This might sound cheesy, but I think you're really grate!</h1>\n      <ul>\n        {cheeses.map((cheese) => (\n          <li key={cheese.id}>{cheese.name}</li>\n        ))}\n      </ul>\n      <form action=\"/cheese\" method=\"post\">\n        <input type=\"text\" name=\"cheese\" />\n        <button type=\"submit\">Add Cheese</button>\n      </form>\n    </div>\n  );\n}\n```", "```\nnpm create next-app@14\n```", "```\nexport default function CheesePage() {\n  return <h1>This might sound cheesy, but I think you're really grate!</h1>;\n}\n```", "```\nexport default async function CheesePage() {\n  const cheeses = await fetch(\"https://api.com/get-cheeses\").then((r) =>\n    r.json()\n  );\n  return (\n    <div>\n      <h1>This might sound cheesy, but I think you're really grate!</h1>\n      <ul>\n        {cheeses.map((cheese) => (\n          <li key={cheese.id}>{cheese.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```", "```\nimport { CheeseList } from \"./CheeseList\";\n\nexport default function CheesePage() {\n  return (\n    <div>\n      <h1>This might sound cheesy, but I think you're really grate!</h1>\n      <CheeseList />\n    </div>\n  );\n}\n```", "```\nexport async function CheeseList() {\n  const cheeses = await fetch(\"https://api.com/get-cheeses\").then((r) =>\n    r.json()\n  );\n  return (\n    <ul>\n      {cheeses.map((cheese) => (\n        <li key={cheese.id}>{cheese.name}</li>\n      ))}\n    </ul>\n  );\n}\n```", "```\nimport { CheeseList } from \"./CheeseList\";\n\nimport { redirect } from \"next/navigation\";\nimport { revalidatePath } from \"next/cache\";\n\nexport default function CheesePage() {\n  return (\n    <div>\n      <h1>This might sound cheesy, but I think you're really grate!</h1>\n      <CheeseList />\n      <form\n        action={async (formData) => {\n          \"use server\";\n          await fetch(\"https://api.com/add-cheese\", {\n            method: \"POST\",\n            body: JSON.stringify({\n              name: formData.get(\"cheese\"),\n            }),\n          });\n          revalidatePath(\"/cheese\");\n          return redirect(\"/cheese\");\n        }}\n        method=\"post\"\n      >\n        <input type=\"text\" name=\"cheese\" />\n        <button type=\"submit\">Add Cheese</button>\n      </form>\n    </div>\n  );\n}\n```", "```\nimport { redirect } from \"next/navigation\";\nimport { revalidatePath } from \"next/cache\";\n\nexport default function CheesePage() {\n  async function addCheese(formData) {\n    \"use server\";\n    await fetch(\"https://api.com/add-cheese\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        name: formData.get(\"cheese\"),\n      }),\n    });\n\n    revalidatePath(\"/cheese\");\n    return redirect(\"/cheese\");\n  }\n\n  return (\n    <div>\n      <h1>This might sound cheesy, but I think you're really grate!</h1>\n      <CheeseList />\n      <form action={addCheese} method=\"post\">\n        <input type=\"text\" name=\"cheese\" />\n        <button type=\"submit\">Add Cheese</button>\n      </form>\n    </div>\n  );\n}\n```", "```\nimport { addCheeseAction } from \"./addCheeseAction\";\n\nexport default function CheesePage() {\n  return (\n    <div>\n      <h1>This might sound cheesy, but I think you're really grate!</h1>\n      <CheeseList />\n      <form action={addCheese} method=\"post\">\n        <input type=\"text\" name=\"cheese\" />\n        <button type=\"submit\">Add Cheese</button>\n      </form>\n    </div>\n  );\n}\n```", "```\n\"use server\";\n\nimport { redirect } from \"next/navigation\";\nimport { revalidatePath } from \"next/cache\";\n\nexport async function addCheeseAction(formData) {\n  await fetch(\"https://api.com/add-cheese\", {\n    method: \"POST\",\n    body: JSON.stringify({\n      name: formData.get(\"cheese\"),\n    }),\n  });\n\n  revalidatePath(\"/cheese\");\n  return redirect(\"/cheese\");\n}\n```", "```\n\"use client\";\nimport { addCheeseAction } from \"./addCheeseAction\";\n\nexport function AddCheeseForm() {\n  return (\n    <form action={addCheeseAction} method=\"post\">\n      <input type=\"text\" name=\"cheese\" />\n      <button type=\"submit\">Add Cheese</button>\n    </form>\n  );\n}\n```", "```\n\"use client\";\nimport { addCheeseAction } from \"./addCheeseAction\";\nimport { useFormStatus } from \"react-dom\";\n\nexport function AddCheeseForm() {\n  const { pending } = useFormStatus();\n\n  return (\n    <form action={addCheeseAction} method=\"post\">\n      <input disabled={pending} type=\"text\" name=\"cheese\" />\n      <button type=\"submit\" disabled={pending}>\n        {pending ? \"Loading...\" : \"Add Cheese\"}\n      </button>\n    </form>\n  );\n}\n```", "```\nimport { CheeseList } from \"./CheeseList\";\nimport { AddCheeseForm } from \"./AddCheeseForm\";\n\nexport default function CheesePage() {\n  return (\n    <div>\n      <h1>This might sound cheesy, but I think you're really grate!</h1>\n      <CheeseList />\n      <AddCheeseForm />\n    </div>\n  );\n}\n```"]