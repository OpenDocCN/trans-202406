<html><head></head><body><section data-pdf-bookmark="Chapter 7. Padding, Borders, Outlines, and Margins" data-type="chapter" epub:type="chapter"><div class="chapter" id="padding-borders-outlines-and-margins">&#13;
<h1><span class="label">Chapter 7. </span>Padding, Borders, Outlines, and Margins</h1>&#13;
&#13;
&#13;
<p>In <a data-type="xref" href="ch06.html#basic-visual-formatting">Chapter 6</a>, we talked about the basics of element display.  In this chapter, we’ll look at the CSS properties and values you can use to affect how element boxes are drawn and separated from one another.  These include the padding, borders, and margins around an element, as well as any outlines that may be added.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Basic Element Boxes" data-type="sect1"><div class="sect1" id="basic-element-boxes">&#13;
<h1>Basic Element Boxes</h1>&#13;
&#13;
<p>As <a data-primary="borders" data-secondary="in box model" data-secondary-sortas="box model" data-type="indexterm" id="idm45176103783824"/><a data-primary="boxes" data-secondary="element boxes" data-type="indexterm" id="idm45176103782736"/><a data-primary="box model" data-type="indexterm" id="idm45176103781888"/><a data-primary="margins" data-secondary="in box model" data-secondary-sortas="box model" data-type="indexterm" id="idm45176103781280"/><a data-primary="padding" data-secondary="in box model" data-secondary-sortas="box model" data-type="indexterm" id="idm45176103780192"/>discussed in the preceding chapter, all document elements generate a rectangular box called the <em>element box</em>, which describes the amount of space that an element occupies in the layout of the document. Therefore, each box influences the position and size of other element boxes. For example, if the first element box in the document is an inch tall, the next box will begin at least an inch below the top of the document. If the first element box is changed and made to be 2 inches tall, every following element box will shift downward an inch, and the second element box will begin at least 2 inches below the top of the &#13;
<span class="keep-together">document.</span></p>&#13;
&#13;
<p>By default, a visually rendered document is composed of numerous rectangular boxes that are distributed so that they don’t overlap.&#13;
Boxes can overlap if they have been manually positioned or placed on a grid,&#13;
and visual overlap can occur if negative margins are used on normal-flow elements.</p>&#13;
&#13;
<p>To understand how margins, padding, and borders are&#13;
handled, you must understand the <em>box model</em>, illustrated in&#13;
<a data-type="xref" href="#TheCSSboxmodel">Figure 7-1</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="TheCSSboxmodel">&#13;
<img alt="css5 0701" src="assets/css5_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>The CSS box model</h6>&#13;
</div></figure>&#13;
&#13;
<p>The diagram in <a data-type="xref" href="#TheCSSboxmodel">Figure 7-1</a> intentionally omits outlines, for reasons that will hopefully be clear once we discuss outlines.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The height and width of the content area, as well as the sizing of the content area along the block and inline directions, are covered in <a data-type="xref" href="ch06.html#basic-visual-formatting">Chapter 6</a>.  If you find some of the rest of this chapter a little confusing because of the way height, width, block axis, and inline axis are discussed, refer to that chapter for a detailed explanation.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Padding" data-type="sect1"><div class="sect1" id="padding">&#13;
<h1>Padding</h1>&#13;
&#13;
<p>Just <a data-primary="padding" data-type="indexterm" id="ix_padding_ch7"/><a data-primary="boxes" data-secondary="element boxes" data-tertiary="padding" data-type="indexterm" id="ix_box_elem_padding"/><a data-primary="blocks" data-secondary="padding for" data-type="indexterm" id="ix_block_padding"/><a data-primary="padding property" data-type="indexterm" id="ix_padding_prop"/>beyond the content area of an element, we find its <em>padding</em>,&#13;
nestled between <span class="keep-together">the content</span> and any borders. The simplest way to set&#13;
padding is by using the &#13;
<span class="keep-together">property <code>padding</code>.</span></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176103760848">&#13;
<h1>padding</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,4}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>Not defined for shorthand elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements except internal table elements other than table cells</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the width of the containing block</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties (<code>padding-top</code>, etc.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p><code>padding</code> can never be negative</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This property accepts any length value or a percentage&#13;
value. So if you want all <code>&lt;h2&gt;</code> elements to have 2 em of padding on all&#13;
sides, it’s this easy (see <a data-type="xref" href="#Addingpaddingtoelements">Figure 7-2</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Addingpaddingtoelements">&#13;
<img alt="css5 0702" src="assets/css5_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>Adding padding to elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>As <a data-type="xref" href="#Addingpaddingtoelements">Figure 7-2</a> illustrates, the background of an element extends into the&#13;
padding by default. If the background is transparent, setting padding will create extra transparent space around the element’s content, but any&#13;
visible background will extend into the padding area (and beyond, as you’ll see in a later section).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Visible <a data-primary="clipping" data-secondary="backgrounds" data-type="indexterm" id="idm45176103715984"/><a data-primary="background-clip property" data-type="indexterm" id="idm45176103714976"/><a data-primary="backgrounds" data-secondary="clipping" data-type="indexterm" id="idm45176103714336"/><a data-primary="backgrounds" data-secondary="padding with" data-type="indexterm" id="idm45176103713392"/>backgrounds can be prevented from extending into the&#13;
padding by using the property <code>background-clip</code> (see <a data-type="xref" href="ch08.html#backgrounds">Chapter 8</a>).</p>&#13;
</div>&#13;
&#13;
<p>By default, <a data-primary="borders" data-secondary="padding and" data-type="indexterm" id="idm45176103710528"/>elements have no padding. The separation between paragraphs,&#13;
for example, has traditionally been enforced with margins alone (as you’ll see later). On the other hand, without padding, the&#13;
border of an element will come very close to the content of the element&#13;
itself. Thus, when putting a border on an element, it’s usually a good&#13;
idea to add some padding as well, as <a data-type="xref" href="#Theeffectofpaddingonborderedblock-levelelements">Figure 7-3</a> illustrates.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Theeffectofpaddingonborderedblock-levelelements">&#13;
<img alt="css5 0703" src="assets/css5_0703.png"/>&#13;
<h6><span class="label">Figure 7-3. </span>The effect of padding on bordered block-level elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>Any length value is permitted, from ems to inches. The simplest way to&#13;
set padding is with a single length value, which is applied equally to&#13;
all four padding sides. At times, however, you might desire a different&#13;
amount of padding on each side of an element. If&#13;
you want all <code>&lt;h1&gt;</code> elements to have a top padding of 10 pixels, a right&#13;
padding of 20 pixels, a bottom padding of 15 pixels, and a left padding&#13;
of 5 pixels, you can just say this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">10px</code> <code class="m">20px</code> <code class="m">15px</code> <code class="m">5px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The order of the values is important and follows this pattern:</p>&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">padding</code><code class="o">:</code><code> </code><em><code class="nb">top</code><code> </code><code class="nb">right</code><code> </code><code class="n">bottom</code><code> </code><code class="nb">left</code></em><code>&#13;
</code></pre>&#13;
&#13;
<p>A good way to remember this pattern is to keep in mind that the four&#13;
values go clockwise around the element, starting from the top. The padding&#13;
values are <em>always</em> applied in this order, so to get the effect you&#13;
want, you have to arrange the values correctly.</p>&#13;
&#13;
<p>An easy way to remember the order in which sides must be declared, other&#13;
than thinking of it as being clockwise from the top, is to keep in mind&#13;
that getting the sides in the correct order helps you avoid&#13;
“TRouBLe”—that is, <em>TRBL</em>, for <em>top, right, bottom, left</em>.</p>&#13;
&#13;
<p>This ordering reveals that <code>padding</code>, like <code>height</code> and <code>width</code>, is a physical property: it refers to the physical directions of the page, such as top or left, rather than being based on writing direction.  (CSS does have writing-mode padding properties, as you’ll see in a bit.)</p>&#13;
&#13;
<p>It’s entirely possible to mix up the types of length values you use. You&#13;
aren’t restricted to using a single length type in a given rule, but can use whatever makes sense for a given side of the element, as shown here:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">14px</code> <code class="m">5em</code> <code class="m">0.1in</code> <code class="m">3ex</code><code class="p">;}</code> <code class="c">/* value variety! */</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#Mixed-valuepadding">Figure 7-4</a> shows you, <a data-primary="values" data-secondary="mixed-value padding" data-type="indexterm" id="idm45176103622096"/>with a little extra annotation, the results of this declaration.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Mixed-valuepadding">&#13;
<img alt="css5 0704" src="assets/css5_0704.png"/>&#13;
<h6><span class="label">Figure 7-4. </span>Mixed-value padding</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Replicating Values" data-type="sect2"><div class="sect2" id="replicating-values">&#13;
<h2>Replicating Values</h2>&#13;
&#13;
<p>Sometimes the <a data-primary="replicating values, padding" data-type="indexterm" id="ix_rep_value_padding"/><a data-primary="values" data-secondary="replicating in padding" data-type="indexterm" id="ix_value_rep_padding"/><a data-primary="padding" data-secondary="replicating values" data-type="indexterm" id="ix_padding_rep_value"/>values you enter can get a little repetitive:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0.25em</code> <code class="m">1em</code> <code class="m">0.25em</code> <code class="m">1em</code><code class="p">;}</code>  <code class="c">/* TRBL - Top Right Bottom Left */</code></pre>&#13;
&#13;
<p>You don’t have to keep typing in pairs of numbers like this, though.&#13;
Instead of the &#13;
<span class="keep-together">preceding</span> rule, try this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0.25em</code> <code class="m">1em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>These two values are enough to take the place of four. But how? CSS&#13;
defines a few rules to accommodate fewer than four values for <code>padding</code>&#13;
(and many other shorthand properties):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If the value for <em>left</em> is missing, use the value provided for&#13;
<em>right</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the value for <em>bottom</em> is also missing, use the value provided for&#13;
<em>top</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the value for <em>right</em> is also missing, use the value provided for <em>top</em>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If you prefer a more visual approach, take a look at <a data-type="xref" href="#Valuereplicationpattern">Figure 7-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="Valuereplicationpattern">&#13;
<img alt="css5 0705" src="assets/css5_0705.png"/>&#13;
<h6><span class="label">Figure 7-5. </span>Value-replication pattern</h6>&#13;
</div></figure>&#13;
&#13;
<p>In other words, if three values are given for <code>padding</code>, the fourth&#13;
(<em>left</em>) is copied from the second (<em>right</em>). If two values are given,&#13;
the fourth is copied from the second, and the third (<em>bottom</em>) from the&#13;
first (<em>top</em>). Finally, if only one value is given, all the other sides&#13;
copy that value.</p>&#13;
&#13;
<p>This mechanism allows you to supply only as many values as&#13;
necessary, as shown here:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0.25em</code> <code class="m">0</code> <code class="m">0.5em</code><code class="p">;}</code> <code class="c">/* same as '0.25em 0 0.5em 0' */</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0.15em</code> <code class="m">0.2em</code><code class="p">;}</code>   <code class="c">/* same as '0.15em 0.2em 0.15em 0.2em' */</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code> <code class="m">10px</code><code class="p">;}</code>      <code class="c">/* same as '0.5em 10px 0.5em 10px' */</code>&#13;
<code class="nt">p</code><code class="nc">.close</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0.1em</code><code class="p">;}</code>     <code class="c">/* same as '0.1em 0.1em 0.1em 0.1em' */</code></pre>&#13;
&#13;
<p>The method presents a small drawback, which you’re bound to eventually&#13;
encounter. Suppose you want to set the top and left padding for <code>&lt;h1&gt;</code> elements to be 10 pixels, <span class="keep-together">and the</span> bottom and right padding to be 20&#13;
pixels. You’d have to write the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">10px</code> <code class="m">20px</code> <code class="m">20px</code> <code class="m">10px</code><code class="p">;}</code> <code class="c">/* can't be any shorter */</code></pre>&#13;
&#13;
<p>You get what you want, but it takes a while to get it all in.&#13;
Unfortunately, there is no way to cut down on the number of values&#13;
needed in such a circumstance. Let’s take another example, one where you&#13;
want all of the padding to be 0—except for the left padding, which&#13;
should be 3 em:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="m">0</code> <code class="m">3em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Using <a data-primary="margins" data-secondary="padding and" data-type="indexterm" id="idm45176103420192"/><a data-primary="padding" data-secondary="margins and" data-type="indexterm" id="idm45176103419344"/>padding to separate the content areas of elements can be trickier&#13;
than using the traditional margins, although it’s not without its&#13;
rewards. For example, to keep paragraphs the traditional “one blank&#13;
line” apart with padding, you’d have to write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The half-em top and bottom padding of each paragraph butt up against&#13;
each other and total an em of separation. Why would you bother to do&#13;
this? Because then you could insert separation borders between the&#13;
paragraphs, and the side borders will touch to form&#13;
the appearance of a solid line. The following code defines these effects, illustrated in&#13;
<a data-type="xref" href="#Usingpaddinginsteadofmargins">Figure 7-6</a>:<a data-primary="" data-startref="ix_padding_prop" data-type="indexterm" id="idm45176103410560"/><a data-primary="" data-startref="ix_padding_rep_value" data-type="indexterm" id="idm45176103360960"/><a data-primary="" data-startref="ix_rep_value_padding" data-type="indexterm" id="idm45176103360016"/><a data-primary="" data-startref="ix_value_rep_padding" data-type="indexterm" id="idm45176103359072"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code> <code class="m">0</code><code class="p">;</code> <code class="k">border-bottom</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code>&#13;
    <code class="k">border-left</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">double</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Usingpaddinginsteadofmargins">&#13;
<img alt="css5 0706" src="assets/css5_0706.png"/>&#13;
<h6><span class="label">Figure 7-6. </span>Using padding instead of margins</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Single-Side Padding" data-type="sect2"><div class="sect2" id="single-side-padding">&#13;
<h2>Single-Side Padding</h2>&#13;
&#13;
<p>CSS <a data-primary="single-side padding" data-type="indexterm" id="ix_singleside_padding"/><a data-primary="padding" data-secondary="single-side" data-type="indexterm" id="ix_padding_singleside"/>provides a way to assign a value to the padding on a single&#13;
side of an <span class="keep-together">element.</span> Four ways, actually. Let’s say you want to set only the left padding of <code>&lt;h2&gt;</code> <span class="keep-together">elements</span> to be <code>3em</code>. Rather than writing out&#13;
<code>padding: 0 0 0 3em</code>, you can take this approach:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">padding-left</code><code class="o">:</code> <code class="m">3em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The <code>padding-left</code> option is one of <a data-primary="padding-bottom property" data-type="indexterm" id="idm45176103300288"/><a data-primary="padding-left property" data-type="indexterm" id="idm45176103299680"/><a data-primary="padding-right property" data-type="indexterm" id="idm45176103299008"/><a data-primary="padding-top property" data-type="indexterm" id="idm45176103298336"/>four properties devoted to setting the padding&#13;
on each of the four sides of an element box. Their names will come as&#13;
little surprise.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176103276384">&#13;
<h1>padding-top, padding-right, padding-bottom, padding-left</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the width of the containing block</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For percentage values, as specified; for length values, the absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Padding values can never be negative</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>These properties operate in a manner consistent with their names.&#13;
For example, the following two&#13;
rules will yield the same amount of padding (assuming no other CSS):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="m">0</code> <code class="m">0.25in</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">padding-left</code><code class="o">:</code> <code class="m">0.25in</code><code class="p">;}</code></pre>&#13;
&#13;
<p class="pagebreak-before">Similarly, these rules will create equal padding:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0.25in</code> <code class="m">0</code> <code class="m">0</code><code class="p">;}</code>  <code class="c">/* left padding is copied from right padding */</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">padding-top</code><code class="o">:</code> <code class="m">0.25in</code><code class="p">;}</code></pre>&#13;
&#13;
<p>For that matter, so will these rules:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0</code> <code class="m">0.25in</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">padding-right</code><code class="o">:</code> <code class="m">0.25in</code><code class="p">;</code> <code class="k">padding-left</code><code class="o">:</code> <code class="m">0.25in</code><code class="p">;}</code></pre>&#13;
&#13;
<p>It’s possible to use more than one of these single-side properties in a&#13;
single rule; <span class="keep-together">for example:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">padding-left</code><code class="o">:</code> <code class="m">3em</code><code class="p">;</code> <code class="k">padding-bottom</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code>&#13;
    <code class="k">padding-right</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">padding-top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As you can see in <a data-type="xref" href="#Morethanonesingle-sidepadding">Figure 7-7</a>, the padding is set as we wanted. In this case, it might have been easier to use <code>padding</code> after all, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="m">2em</code> <code class="m">3em</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Morethanonesingle-sidepadding">&#13;
<img alt="css5 0707" src="assets/css5_0707.png"/>&#13;
<h6><span class="label">Figure 7-7. </span>More than one single-side padding</h6>&#13;
</div></figure>&#13;
&#13;
<p>In general, once you’re trying to set padding for more than one side,&#13;
it’s easier to use the shorthand <code>padding</code>. From the standpoint of your&#13;
document’s display, however, it doesn’t really matter which approach you&#13;
use, so choose whichever is easiest for you.<a data-primary="" data-startref="ix_padding_singleside" data-type="indexterm" id="idm45176103049728"/><a data-primary="" data-startref="ix_singleside_padding" data-type="indexterm" id="idm45176103048752"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logical Padding" data-type="sect2"><div class="sect2" id="logical-padding">&#13;
<h2>Logical Padding</h2>&#13;
&#13;
<p>As you’ll see <a data-primary="padding" data-secondary="logical" data-type="indexterm" id="ix_padding_logical"/><a data-primary="properties" data-secondary="logical" data-type="indexterm" id="ix_prop_logic2"/><a data-primary="logical properties" data-secondary="padding" data-type="indexterm" id="ix_logic_prop_padding"/>throughout this chapter, physical properties have logical counterparts, with names that follow a consistent pattern.  For <code>height</code> and <code>width</code>, we have <code>block-size</code> and <code>inline-size</code>.  For padding, we have a set of four properties that correspond to the padding at the start and end of the block direction and the inline direction.  <a data-primary="padding-block-end property" data-type="indexterm" id="idm45176103040048"/><a data-primary="padding-block-start property" data-type="indexterm" id="idm45176103039376"/><a data-primary="padding-inline-end property" data-type="indexterm" id="idm45176103038736"/><a data-primary="padding-inline-start property" data-type="indexterm" id="idm45176103038096"/>These are called <em>logical properties</em>, because they use a little logic to determine which physical side they should be applied to.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176103036800">&#13;
<h1>padding-block-start, padding-block-end, padding-inline-start, padding-inline-end</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the width of the containing block</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For percentage values, as specified; for length values, the absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Padding values can never be negative</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>These <a data-primary="backgrounds" data-secondary="padding with" data-type="indexterm" id="idm45176103007392"/>properties are handy when you want to make sure your text has padding that has a consistent effect regardless of the writing direction.  For example, you might want a little bit of padding to set the background edges away from the start and end of each block element, and more padding to the sides of each line of text.  Here’s a way to make that &#13;
<span class="keep-together">happen</span>, with the result shown in <a data-type="xref" href="#logical-padding-figure">Figure 7-8</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code>&#13;
     <code class="n">padding</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">0.25em</code><code class="p">;</code>&#13;
     <code class="n">padding</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">0.25em</code><code class="p">;</code>&#13;
     <code class="n">padding</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code>&#13;
     <code class="n">padding</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="logical-padding-figure">&#13;
<img alt="css5 0708" src="assets/css5_0708.png"/>&#13;
<h6><span class="label">Figure 7-8. </span>Logical padding</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Percentage values for these logical padding properties are always calculated with respect to the <em>physical</em> width or height of the element’s container, not its logical width or height.  Thus, for example, <code>padding-inline-start: 10%</code> will calculate to 100 pixels when the container has <code>width: 1000px</code>, even in a vertical writing mode.  This may change going forward, but that is the consistent (and specified) behavior as of late 2022.</p>&#13;
</div>&#13;
&#13;
<p>It’s a <a data-primary="padding-block property" data-type="indexterm" id="idm45176102937552"/><a data-primary="padding-inline property" data-type="indexterm" id="idm45176102936816"/>little tedious to explicitly declare a padding value for each side of an element individually, and two shorthand properties can help: one for the block axis, and one for the &#13;
<span class="keep-together">inline axis.</span></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176102935360">&#13;
<h1>padding-block, padding-inline</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt;]{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the width of the containing block</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For percentage values, as specified; for length values, the absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Padding values can never be negative</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>With these shorthand properties, you can set block padding in one go, and inline padding in another.  The following CSS would have the same result as that shown in <a data-type="xref" href="#logical-padding">“Logical Padding”</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code>&#13;
     <code class="n">padding</code><code class="o">-</code><code class="nb">block</code><code class="o">:</code> <code class="m">0.25em</code><code class="p">;</code>&#13;
     <code class="n">padding</code><code class="o">-</code><code class="nb">inline</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Each property accepts one or two values.  If there are two values, they’re always in the order <em>start end</em>.  If there’s only one value, as shown before, the same value is used for both the start and end sides.  Thus, to give an element 10 pixels of block-start padding and 1 em of block-end padding, you could write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code>&#13;
     <code class="n">padding</code><code class="o">-</code><code class="nb">block</code><code class="o">:</code> <code class="m">10px</code> <code class="m">1em</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A more compact shorthand doesn’t exist for logical padding, unfortunately—no <code>padding-logical</code> that accepts four values, the way <code>padding</code> does.  Proposals have been made to extend the <code>padding</code> property with a keyword value (such as <code>logical</code>) to allow it to set logical padding instead of physical padding, but as of late 2022, those proposals have not been adopted.  As of this writing, the most compact you can get with logical padding is to use <code>padding-block</code> and <code>padding-inline</code>.<a data-primary="" data-startref="ix_logic_prop_padding" data-type="indexterm" id="idm45176102860880"/><a data-primary="" data-startref="ix_padding_logical" data-type="indexterm" id="idm45176102859872"/><a data-primary="" data-startref="ix_prop_logic2" data-type="indexterm" id="idm45176102858928"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Percentage Values and Padding" data-type="sect2"><div class="sect2" id="percentage-values-and-padding">&#13;
<h2>Percentage Values and Padding</h2>&#13;
&#13;
<p>We can set <a data-primary="padding" data-secondary="percentage values" data-type="indexterm" id="ix_padding_percent"/>percentage values for the padding&#13;
of an element. Percentages are computed in relation to the width of the&#13;
parent element’s content area, so they change if the parent element’s&#13;
width changes in some way.</p>&#13;
&#13;
<p>For example, assume the following, which is&#13;
illustrated in <a data-type="xref" href="#Paddingpercentagesandthewidthsofparentelements">Figure 7-9</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">10%</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code> <code class="na">style</code><code class="o">=</code><code class="s">"width: 600px;"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
        This paragraph is contained within a DIV that has a width of 600 pixels,&#13;
        so its padding will be 10% of the width of the paragraph's parent&#13;
        element. Given the declared width of 600 pixels, the padding will be 60&#13;
        pixels on all sides.&#13;
    <code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">div</code> <code class="na">style</code><code class="o">=</code><code class="s">"width: 300px;"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
        This paragraph is contained within a DIV with a width of 300 pixels,&#13;
        so its padding will still be 10% of the width of the paragraph's parent.&#13;
        There will, therefore, be half as much padding on this paragraph as&#13;
        on the first paragraph.&#13;
    <code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Paddingpercentagesandthewidthsofparentelements">&#13;
<img alt="css5 0709" src="assets/css5_0709.png"/>&#13;
<h6><span class="label">Figure 7-9. </span>Padding, percentages, and the widths of parent elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>You may have noticed something odd about the paragraphs in <a data-type="xref" href="#Paddingpercentagesandthewidthsofparentelements">Figure 7-9</a>. Not&#13;
only did their side padding change according to the width of their&#13;
parent elements, but so did their top and bottom padding. That’s the&#13;
desired behavior in CSS. Refer back to the property definition, and&#13;
you’ll see that percentage values are defined to be relative to the&#13;
<em>width</em> of the parent element. This applies to the top and bottom&#13;
padding as well as to the left and right. Thus, given the following&#13;
styles and markup, the top padding of the paragraph will be 50 pixels:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="nt">p</code> <code class="p">{</code><code class="k">padding-top</code><code class="o">:</code> <code class="m">10%</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code> <code class="na">style</code><code class="o">=</code><code class="s">"width: 500px;"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
        This is a paragraph, and its top margin is 10% the width of its parent&#13;
        element.&#13;
    <code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>If all this seems strange, consider that most elements in the normal flow&#13;
are (as we are assuming) as tall as necessary to contain their&#13;
descendant elements, including padding. If an element’s top and bottom&#13;
padding were a percentage of the parent’s height, an infinite loop could&#13;
result where the parent’s height was increased to accommodate the top and&#13;
bottom padding, which would then have to increase to match the new&#13;
height, and so on.</p>&#13;
&#13;
<p>Rather than ignore percentages for top and&#13;
bottom padding, the specification authors decided to make it relate to&#13;
the width of the parent’s content area, which does not change based on&#13;
the width of its descendants.  This allows authors to get a consistent padding all the way around an element by using the same percentage on all four sides.</p>&#13;
&#13;
<p>By contrast, consider elements without a declared width. In&#13;
such cases, the overall width of the element box (including padding) is&#13;
dependent on the width of the parent element. <a data-primary="fluid pages" data-type="indexterm" id="idm45176102726224"/>This leads to the&#13;
possibility of <em>fluid</em> pages, where the padding on elements enlarges or&#13;
reduces to match the actual size of the parent element. If you style a&#13;
document so that its elements use percentage padding, then as the user&#13;
changes the width of a browser window, the padding will expand or shrink&#13;
to fit. The design choice is up to you.</p>&#13;
&#13;
<p>You also can mix percentages with length values. Thus, to set&#13;
<code>&lt;h2&gt;</code> elements to have top and bottom padding of one-half em, and side&#13;
padding of 10% the width of their parent elements, you can declare&#13;
the following, illustrated in <a data-type="xref" href="#Mixedpadding">Figure 7-10</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code> <code class="m">10%</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Mixedpadding">&#13;
<img alt="css5 0710" src="assets/css5_0710.png"/>&#13;
<h6><span class="label">Figure 7-10. </span>Mixed padding</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here, although the top and bottom padding will stay constant in any&#13;
situation, the side padding will change based on the width of the parent&#13;
element.<a data-primary="" data-startref="ix_block_padding" data-type="indexterm" id="idm45176102682224"/><a data-primary="" data-startref="ix_padding_percent" data-type="indexterm" id="idm45176102681248"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Padding and Inline Elements" data-type="sect2"><div class="sect2" id="padding-and-inline-elements">&#13;
<h2>Padding and Inline Elements</h2>&#13;
&#13;
<p>You may <a data-primary="padding" data-secondary="inline elements" data-type="indexterm" id="ix_padding_inline_elem"/><a data-primary="inline formatting" data-secondary="padding" data-type="indexterm" id="ix_inline_format_padding"/>have noticed that the discussion so far has been&#13;
solely about padding set for elements that generate block boxes. When&#13;
padding is applied to inline nonreplaced &#13;
<span class="keep-together">elements</span>, the effects are a&#13;
little different.</p>&#13;
&#13;
<p>Let’s say you want to set top and bottom padding on strongly emphasized&#13;
text:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">padding-top</code><code class="o">:</code> <code class="m">25px</code><code class="p">;</code> <code class="k">padding-bottom</code><code class="o">:</code> <code class="m">50px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This is allowed in the specification, but since you’re applying the&#13;
padding to an inline nonreplaced element, it will have absolutely no&#13;
effect on the line height. <a data-primary="backgrounds" data-secondary="padding with" data-type="indexterm" id="ix_background_padding"/>Since padding is transparent when there’s no&#13;
visible background, the preceding declaration will have no visual effect&#13;
whatsoever. This happens because padding on inline nonreplaced elements&#13;
doesn’t change the line height of an element.</p>&#13;
&#13;
<p>Be careful: an inline nonreplaced element with a background color and&#13;
padding can have a background that extends above and below the&#13;
element, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">padding-top</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#Paddingonaninlinenonreplacedelement">Figure 7-11</a> gives you an idea of what this might look like.</p>&#13;
&#13;
<figure><div class="figure" id="Paddingonaninlinenonreplacedelement">&#13;
<img alt="css5 0711" src="assets/css5_0711.png"/>&#13;
<h6><span class="label">Figure 7-11. </span>Top padding on an inline nonreplaced element</h6>&#13;
</div></figure>&#13;
&#13;
<p>The line height isn’t changed, but since the background color does&#13;
extend into the padding, each line’s background ends up overlapping the&#13;
lines that come before it. That’s the expected result.</p>&#13;
&#13;
<p>The preceding behaviors are true only for the top and bottom sides of inline <span class="keep-together">nonreplaced</span> elements; the left and right sides are a different story. We’ll start by considering the case of a small, inline nonreplaced&#13;
element within a single line. Here, if you set values for the left or&#13;
right padding, they will be visible, as <a data-type="xref" href="#Aninlinenonreplacedelementwithleftpadding">Figure 7-12</a> makes clear (so to&#13;
speak):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">padding-left</code><code class="o">:</code> <code class="m">25px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Aninlinenonreplacedelementwithleftpadding">&#13;
<img alt="css5 0712" src="assets/css5_0712.png"/>&#13;
<h6><span class="label">Figure 7-12. </span>An inline nonreplaced element with left padding</h6>&#13;
</div></figure>&#13;
&#13;
<p>Note the extra space between the end of the word just before the inline&#13;
nonreplaced element and the edge of the inline element’s background. You&#13;
can add that extra space to both ends of the inline if you want:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">padding-left</code><code class="o">:</code> <code class="m">25px</code><code class="p">;</code> <code class="k">padding-right</code><code class="o">:</code> <code class="m">25px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As expected, <a data-type="xref" href="#Aninlinenonreplacedelementwith25-pixelsidepadding">Figure 7-13</a> shows a little extra space on the right and left&#13;
sides of the inline element, and no extra space above or below it.</p>&#13;
&#13;
<figure><div class="figure" id="Aninlinenonreplacedelementwith25-pixelsidepadding">&#13;
<img alt="css5 0713" src="assets/css5_0713.png"/>&#13;
<h6><span class="label">Figure 7-13. </span>An inline nonreplaced element with 25-pixel side padding</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, when an inline nonreplaced element stretches across multiple lines,&#13;
the situation changes a bit. <a data-type="xref" href="#Aninlinenonreplacedelementwith25-pixelsidepaddingdisplayedacrosstwolinesoftext">Figure 7-14</a> shows what happens when an inline&#13;
nonreplaced element with padding is displayed across multiple lines:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">0</code> <code class="m">25px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The left padding is applied to the beginning of the element, and the&#13;
right padding to the end of it. By default, padding is <em>not</em> applied to&#13;
the right and left side of each line. Also, you can see that, if not for&#13;
the padding, the line may have broken after “background” instead of&#13;
where it did. The <code>padding</code> property affects line breaking only by changing the point&#13;
at which the element’s content begins within a line.</p>&#13;
&#13;
<figure><div class="figure" id="Aninlinenonreplacedelementwith25-pixelsidepaddingdisplayedacrosstwolinesoftext">&#13;
<img alt="css5 0714" src="assets/css5_0714.png"/>&#13;
<h6><span class="label">Figure 7-14. </span>An inline nonreplaced element with 25-pixel side padding displayed across two lines of text</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The way padding is (or isn’t) applied to the ends of each line&#13;
box can be altered with the property <code>box-decoration-break</code>.  See <a data-type="xref" href="ch06.html#basic-visual-formatting">Chapter 6</a> for more details.<a data-primary="" data-startref="ix_background_padding" data-type="indexterm" id="idm45176102458384"/><a data-primary="" data-startref="ix_inline_format_padding" data-type="indexterm" id="idm45176102457408"/><a data-primary="" data-startref="ix_padding_inline_elem" data-type="indexterm" id="idm45176102456496"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Padding and Replaced Elements" data-type="sect2"><div class="sect2" id="padding-and-replaced-elements">&#13;
<h2>Padding and Replaced Elements</h2>&#13;
&#13;
<p>It is <a data-primary="padding" data-secondary="replaced elements" data-type="indexterm" id="idm45176102453856"/><a data-primary="replaced elements" data-secondary="padding" data-type="indexterm" id="idm45176102452848"/>possible to apply padding to replaced elements. The most surprising&#13;
case for most people is that you can apply padding to an image, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Regardless of whether the replaced element is block-level or inline, the&#13;
padding will surround its content, and the background color will fill&#13;
into that padding, as shown in <a data-type="xref" href="#Paddingreplacedelements">Figure 7-15</a>. You can also see that padding will push a replaced element’s border (dashed, in this case) away from its content.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Paddingreplacedelements">&#13;
<img alt="css5 0715" src="assets/css5_0715.png"/>&#13;
<h6><span class="label">Figure 7-15. </span>Padding, borders, and background on a replaced element</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, remember all that stuff about how padding on inline nonreplaced&#13;
elements doesn’t affect the height of the lines of text? You can throw&#13;
it all out for <em>replaced</em> elements, because they have a different set of&#13;
rules. As you can see in <a data-type="xref" href="#Paddingreplacedelements2">Figure 7-16</a>, the padding of an inline replaced&#13;
element very much affects the height of the line.</p>&#13;
&#13;
<figure><div class="figure" id="Paddingreplacedelements2">&#13;
<img alt="css5 0716" src="assets/css5_0716.png"/>&#13;
<h6><span class="label">Figure 7-16. </span>Padding an inline replaced element</h6>&#13;
</div></figure>&#13;
&#13;
<p>The same goes for borders and margins, as you’ll soon see.</p>&#13;
&#13;
<p>Note that if the image in <a data-type="xref" href="#Paddingreplacedelements2">Figure 7-16</a> had not loaded, or had somehow been set to have 0 height and width, the padding would still be rendered around the spot where the element should have been displayed, even if that spot has no height or width.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of late 2022, uncertainty <a data-primary="form elements" data-secondary="padding" data-type="indexterm" id="idm45176102414368"/><a data-primary="form elements" data-secondary="as replaced elements" data-secondary-sortas="replaced elements" data-type="indexterm" id="idm45176102413392"/>remains over what to do about&#13;
styling form elements such as <code>&lt;input&gt;</code>, which are replaced elements. It&#13;
is not entirely clear where the padding of a checkbox resides, for&#13;
example. Therefore, as of this writing, some browsers ignore padding&#13;
(and other forms of styling) for form elements, while others apply the styles as best they can.<a data-primary="" data-startref="ix_box_elem_padding" data-type="indexterm" id="idm45176102411664"/><a data-primary="" data-startref="ix_padding_ch7" data-type="indexterm" id="idm45176102410688"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Borders" data-type="sect1"><div class="sect1" id="borders">&#13;
<h1>Borders</h1>&#13;
&#13;
<p>Beyond the padding of an element are its <a data-primary="boxes" data-secondary="element boxes" data-tertiary="borders" data-type="indexterm" id="ix_box_elem_borders_ch7"/><a data-primary="borders" data-type="indexterm" id="ix_borders_ch7"/>borders. The <em>border</em> of an&#13;
element is just one or more lines that surround the content and&#13;
padding of an element. By default, the <a data-primary="borders" data-secondary="background and" data-type="indexterm" id="idm45176102404848"/>background of the element&#13;
stops at the outer border edge, since the background does not extend into&#13;
the margins, and the border is just inside the margin, and is thus drawn&#13;
“underneath” the border. This matters when parts of the border are transparent,&#13;
such as with dashed borders.</p>&#13;
&#13;
<p>Every border has three aspects: its width, or thickness; its style, or&#13;
appearance; and its color. <a data-primary="borders" data-secondary="width of" data-type="indexterm" id="idm45176102386512"/>The default value for the width of a border&#13;
is <code>medium</code>, which was explicitly declared to be 3 pixels wide in 2022.&#13;
Despite this, the reason you don’t usually&#13;
see borders is that the default style is <code>none</code>, which prevents them&#13;
from existing at all. (This lack of existence can also reset the&#13;
<code>border-width</code> value, but we’ll get to that in a little while.)</p>&#13;
&#13;
<p>Finally, the <a data-primary="foreground colors" data-type="indexterm" id="idm45176102383488"/><a data-primary="colors" data-secondary="foreground" data-type="indexterm" id="idm45176102382880"/><a data-primary="currentcolor keyword" data-type="indexterm" id="idm45176102382032"/><a data-primary="borders" data-secondary="colors" data-type="indexterm" id="idm45176102381424"/><a data-primary="colors" data-secondary="borders" data-type="indexterm" id="idm45176102380576"/>default border color is <code>currentcolor</code>, the foreground color of the element itself. If no color has been declared for the border, it will be the same color as the text of the element. If, on the other hand, an element has no text—let’s say it has a table that contains only&#13;
images—the border color for that table will be the text color of its&#13;
parent element (because <code>color</code> is inherited). Thus, if a&#13;
table has a border, and the <code>&lt;body&gt;</code> is its parent, given this rule</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code></pre>&#13;
&#13;
<p>then, by default, the border around the table will be purple (assuming&#13;
the user agent doesn’t set a color for tables).</p>&#13;
&#13;
<p>The CSS <a data-primary="borders" data-secondary="intermittent" data-type="indexterm" id="idm45176102362000"/>specification defines the background area of an element to&#13;
extend to the outside edge of the border, at least by default. This is&#13;
important because some borders are <em>intermittent</em>—for example, <code>dotted</code>&#13;
and <code>dashed</code> borders—so the element’s background should appear in the&#13;
spaces between the visible portions of the border.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Visible backgrounds can be prevented from extending into the&#13;
border area by using the property <code>background-clip</code>.  See <a data-type="xref" href="ch08.html#backgrounds">Chapter 8</a> for details.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Borders with Style" data-type="sect2"><div class="sect2" id="borders-with-style">&#13;
<h2>Borders with Style</h2>&#13;
&#13;
<p>We’ll start with <a data-primary="borders" data-secondary="styles for" data-type="indexterm" id="ix_borders_style_props"/><a data-primary="border-style property" data-type="indexterm" id="ix_border_style_prop"/>border styles, which are the most important aspect of a&#13;
border—not because they control the appearance of the border (although&#13;
they certainly do that) but because without a style, there wouldn’t be&#13;
any border at all.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176102352560">&#13;
<h1>border-style</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>none</code> | <code>hidden</code> | <code>solid</code> | <code>dotted</code> | <code>dashed</code> | <code>double</code> | <code>groove</code> | <code>ridge</code> | <code>inset</code> | <code>outset</code> ]{1,4}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>Not defined for shorthand properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><span class="keep-together"><strong>Computed value:</strong></span></p></td>&#13;
<td><p>See individual properties (<code>border-top-style</code>, etc.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>CSS defines 10 distinct styles for the property <code>border-style</code>, including the default value of <code>none</code>. <a data-type="xref" href="#Borderstyles">Figure 7-17</a> demonstrates these styles. This property is not inherited.</p>&#13;
&#13;
<p>The style value <code>hidden</code> is equivalent to <code>none</code>, except when applied to&#13;
tables, where it has a slightly different effect on border-conflict&#13;
resolution.</p>&#13;
&#13;
<figure><div class="figure" id="Borderstyles">&#13;
<img alt="css5 0717" src="assets/css5_0717.png"/>&#13;
<h6><span class="label">Figure 7-17. </span>Border styles</h6>&#13;
</div></figure>&#13;
&#13;
<p>As for <code>double</code>, it’s defined such that&#13;
the width of the two lines it creates, plus the width of the space&#13;
between them, is equal to the value of <code>border-width</code> (discussed in the&#13;
next section). However, the CSS specification doesn’t say whether one of&#13;
the lines should be thicker than the other, or if they should always be&#13;
the same width, or if the space should be thicker or thinner than the&#13;
lines. All of these options are left up to the user agent to decide, and&#13;
the author has no reliable way to influence the final result.</p>&#13;
&#13;
<p>All the borders shown in <a data-type="xref" href="#Borderstyles">Figure 7-17</a> are based on a <code>color</code> value of&#13;
<code>gray</code>, which makes all of the visual effects easier to see. The look of&#13;
a border style is always based in some way on the color of the border,&#13;
although the exact method may vary among user agents. The way browsers&#13;
treat colors in the border styles <code>inset</code>, <code>outset</code>, <code>groove</code>, and&#13;
<code>ridge</code> can and does vary. For example, <a data-type="xref" href="#Twovalidwaysofrenderinginset">Figure 7-18</a> illustrates two ways a browser could render an inset &#13;
<span class="keep-together">border.</span></p>&#13;
&#13;
<figure><div class="figure" id="Twovalidwaysofrenderinginset">&#13;
<img alt="css5 0718" src="assets/css5_0718.png"/>&#13;
<h6><span class="label">Figure 7-18. </span>Two valid ways of rendering an inset</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this example, one browser takes the <code>gray</code> value for the bottom and right sides, and a darker gray for the top and left; the other makes the&#13;
bottom and right lighter than <code>gray</code> and the top and left darker, but&#13;
not as dark as the first browser.</p>&#13;
&#13;
<p>Now let’s define a border style for images that are inside any unvisited&#13;
hyperlink. <span class="keep-together">We might</span> make them <code>outset</code>, so they have a “raised button”&#13;
look, as depicted in <a data-type="xref" href="#Applyinganoutsetbordertoahyperlinkedimage">Figure 7-19</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="nt">img</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">outset</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Applyinganoutsetbordertoahyperlinkedimage">&#13;
<img alt="css5 0719" src="assets/css5_0719.png"/>&#13;
<h6><span class="label">Figure 7-19. </span>Applying an outset border to a hyperlinked image</h6>&#13;
</div></figure>&#13;
&#13;
<p>By default, the <a data-primary="colors" data-secondary="borders" data-type="indexterm" id="idm45176102300000"/><a data-primary="colors" data-secondary="foreground" data-type="indexterm" id="idm45176102298992"/><a data-primary="foreground colors" data-type="indexterm" id="idm45176102298048"/><a data-primary="borders" data-secondary="colors" data-type="indexterm" id="idm45176102281152"/>color of the border is based on the element’s value for&#13;
<code>color</code>, which in this circumstance is likely to be <code>blue</code>. This is&#13;
because the image is contained with a hyperlink, and the foreground&#13;
color of hyperlinks is usually <code>blue</code>. If you so desired, you could&#13;
change that color to silver, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="nt">img</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">outset</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The border will now be based on the light-grayish <code>silver</code>, since that’s&#13;
now the foreground color of the image—even though the image doesn’t&#13;
actually use it, it’s still passed on to the border. We’ll talk about&#13;
another way to change border colors in <a data-type="xref" href="#border-colors">“Border Colors”</a>.</p>&#13;
&#13;
<p>Remember, though, that the color-shifting in borders is up to the user&#13;
agent. Let’s go back to the blue outset border and compare it in two browsers, as shown in <a data-type="xref" href="#Twooutsetborders">Figure 7-20</a>.</p>&#13;
&#13;
<p>Again, notice that one browser shifts the colors to the lighter and&#13;
darker, while another just shifts the “shadowed” sides to be darker than&#13;
blue. This is why, if a specific set of colors is desired, authors&#13;
usually set the exact colors they want instead of using a border style&#13;
like <code>outset</code> and leaving the result up to the browser. You’ll soon see&#13;
just how to do that.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Twooutsetborders">&#13;
<img alt="css5 0720" src="assets/css5_0720.png"/>&#13;
<h6><span class="label">Figure 7-20. </span>Two outset borders</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Multiple styles" data-type="sect3"><div class="sect3" id="multiple-styles">&#13;
<h3>Multiple styles</h3>&#13;
&#13;
<p>We can <a data-primary="multiple border styles" data-type="indexterm" id="idm45176102236720"/><a data-primary="borders" data-secondary="multiple styles" data-type="indexterm" id="idm45176102235984"/>define more than one style for a given border. For&#13;
example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.aside</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code> <code class="nb">dashed</code> <code class="nb">dotted</code> <code class="nb">solid</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The result is a paragraph with a solid top border, a dashed right&#13;
border, a dotted bottom border, and a solid left border.</p>&#13;
&#13;
<p>Again we see the TRBL order of values, just as we saw&#13;
in our discussion of setting <code>padding</code> with multiple values. All the&#13;
same rules about value replication apply to border styles, just as they&#13;
did with padding. Thus, the following two statements would have the same&#13;
effect, as depicted in <a data-type="xref" href="#Equivalentstylerules">Figure 7-21</a>:<a data-primary="" data-startref="ix_border_style_prop" data-type="indexterm" id="idm45176102200736"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.new1</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code> <code class="nb">none</code> <code class="nb">dashed</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.new2</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code> <code class="nb">none</code> <code class="nb">dashed</code> <code class="nb">none</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Equivalentstylerules">&#13;
<img alt="css5 0721" src="assets/css5_0721.png"/>&#13;
<h6><span class="label">Figure 7-21. </span>Equivalent style rules</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Single-side styles" data-type="sect3"><div class="sect3" id="single-side-styles">&#13;
<h3>Single-side styles</h3>&#13;
&#13;
<p>Sometimes you <a data-primary="single-side border styles" data-type="indexterm" id="idm45176102161440"/><a data-primary="borders" data-secondary="single-side properties" data-type="indexterm" id="idm45176102160736"/><a data-primary="border-top-style property" data-type="indexterm" id="idm45176102159792"/><a data-primary="border-bottom-style property" data-type="indexterm" id="idm45176102159152"/><a data-primary="border-left-style property" data-type="indexterm" id="idm45176102158512"/><a data-primary="border-right-style property" data-type="indexterm" id="idm45176102157872"/>might want to set border styles for just one side&#13;
of an element box, rather than all four. That’s where the single-side&#13;
border style properties come in.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176102134608">&#13;
<h1>border-top-style, border-right-style, <span class="keep-together">border-bottom-style, border-left-style</span></h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | <code>hidden</code> | <code>dotted</code> | <code>dashed</code> | <code>solid</code> | <code>double</code> | <code>groove</code> | <code>ridge</code> | <code>inset</code> | <code>outset</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Single-side border style properties are fairly self-explanatory. If you&#13;
want to change the style for the bottom border, for example, you use&#13;
<code>border-bottom-style</code>.</p>&#13;
&#13;
<p>It’s not uncommon to see <code>border</code> used in conjunction with a single-side&#13;
property. Suppose you want to set a solid border on three sides of a&#13;
heading, but not have a left border, as shown in <a data-type="xref" href="#Removingtheleftborder">Figure 7-22</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Removingtheleftborder">&#13;
<img alt="css5 0722" src="assets/css5_0722.png"/>&#13;
<h6><span class="label">Figure 7-22. </span>Removing the left border</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can accomplish this in two ways, each one equivalent to the other:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code> <code class="nb">solid</code> <code class="nb">solid</code> <code class="nb">none</code><code class="p">;}</code>&#13;
<code class="c">/* the above is the same as the below */</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-left-style</code><code class="o">:</code> <code class="nb">none</code><code class="p">;}</code></pre>&#13;
&#13;
<p>What’s important to remember is that if you’re going to use the second&#13;
approach, you have to place the single-side property <em>after</em> the&#13;
shorthand, as is usually the case with shorthand. This is because&#13;
<code>border-style: solid</code> is actually a declaration of&#13;
<code>border-style: solid solid solid solid</code>. If you put&#13;
<code>border-style-left: none</code> before the <code>border-style</code> declaration, the&#13;
shorthand’s value will override the single-side value of <code>none</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logical styles" data-type="sect3"><div class="sect3" id="logical-styles">&#13;
<h3>Logical styles</h3>&#13;
&#13;
<p>If you want your <a data-primary="logical properties" data-secondary="border styles" data-type="indexterm" id="idm45176102084496"/><a data-primary="properties" data-secondary="logical" data-type="indexterm" id="idm45176102083488"/><a data-primary="border-block-end-style property" data-type="indexterm" id="idm45176102082544"/><a data-primary="border-block-start-style property" data-type="indexterm" id="idm45176102081904"/><a data-primary="border-inline-end-style property" data-type="indexterm" id="idm45176102081264"/><a data-primary="border-inline-start-style property" data-type="indexterm" id="idm45176102080624"/>borders to be styled in relation to where they sit in the writing mode’s flow, rather than be pinned to physical directions, the following are the border-styling properties for you.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176102079728">&#13;
<h1>border-block-start-style, border-block-end-style, <span class="keep-together">border-inline-start-style, border-inline-end-style</span></h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | <code>hidden</code> | <code>dotted</code> | <code>dashed</code> | <code>solid</code> | <code>double</code> | <code>groove</code> | <code>ridge</code> | <code>inset</code> | <code>outset</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176102040592">&#13;
<h1>border-block-style, border-inline-style</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>none</code> | <code>hidden</code> | <code>dotted</code> | <code>dashed</code> | <code>solid</code> | <code>double</code> | <code>groove</code> | <code>ridge</code> | <code>inset</code> | <code>outset</code> ]{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>As <a data-primary="border-block-style property" data-type="indexterm" id="idm45176102023072"/><a data-primary="border-inline-style property" data-type="indexterm" id="idm45176102022368"/>with <code>padding-block</code> and <code>padding-inline</code>, <code>border-block-style</code> and <code>border-inline-style</code> each accept one or two values.  If two values are given, they are taken in the order of <em>start end</em>.  Given the following CSS, you’ll get a result like that shown in <a data-type="xref" href="#logical-border-styles">Figure 7-23</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">style</code><code class="o">:</code> <code class="nb">solid</code> <code class="nb">double</code><code class="p">;</code> <code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">style</code><code class="o">:</code> <code class="nb">dashed</code> <code class="nb">dotted</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="logical-border-styles">&#13;
<img alt="css5 0723" src="assets/css5_0723.png"/>&#13;
<h6><span class="label">Figure 7-23. </span>Logical border styles</h6>&#13;
</div></figure>&#13;
&#13;
<p>You could get the same result in the following, more verbose manner:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">-</code><code class="n">style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">-</code><code class="n">style</code><code class="o">:</code> <code class="nb">double</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">-</code><code class="n">style</code><code class="o">:</code> <code class="nb">dashed</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">-</code><code class="n">style</code><code class="o">:</code> <code class="nb">dotted</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The only difference between the two patterns is the number of characters you have to type, so really, which one you use is up to you.<a data-primary="" data-startref="ix_borders_style_props" data-type="indexterm" id="idm45176101891968"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Border Widths" data-type="sect2"><div class="sect2" id="border-widths">&#13;
<h2>Border Widths</h2>&#13;
&#13;
<p>Once you’ve <a data-primary="border-width property" data-type="indexterm" id="ix_border_width_prop"/><a data-primary="borders" data-secondary="width of" data-type="indexterm" id="ix_borders_width"/>assigned a border a style, the next step is to give it some&#13;
width, most easily by using the property <code>border-width</code> or one of its cousin properties.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176101921840">&#13;
<h1>border-width</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>thin</code> | <code>medium</code> | <code>thick</code> | &lt;<em><code>length</code></em>&gt; ]{1,4}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>Not defined for shorthand properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties (<code>border-top-style</code>, etc.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176101878544">&#13;
<h1>border-top-width, border-right-width, <span class="keep-together">border-bottom-width, border-left-width</span></h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>thin</code> | <code>medium</code> | <code>thick</code> | &lt;<em><code>length</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>medium</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>An absolute length, or <code>0</code> if the style of the border&#13;
is <code>none</code> or <code>hidden</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Each of these <a data-primary="border-bottom-width property" data-type="indexterm" id="idm45176101862352"/><a data-primary="border-left-width property" data-type="indexterm" id="idm45176101861648"/><a data-primary="border-right-width property" data-type="indexterm" id="idm45176101861008"/><a data-primary="border-top-width property" data-type="indexterm" id="idm45176101860368"/>properties is used to set the width on a specific border&#13;
side, just as with the margin properties.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of early 2023, border widths <em>still</em> cannot be given percentage&#13;
values, which is rather a shame.</p>&#13;
</div>&#13;
&#13;
<p>There are four ways to assign width to a border: you can give it a&#13;
length value such as <code>4px</code> or <code>0.1em</code>, or use one of three keywords.&#13;
These keywords are <code>thin</code>, <code>medium</code> (the default value), and <code>thick</code>. According to the specification, <code>thick</code> is 5px, wider than <code>medium</code>’s 3px, which is wider than the 1-px <code>thin</code>—which makes sense.</p>&#13;
&#13;
<p><a data-type="xref" href="#Therelationofborder-widthkeywordstoeachother">Figure 7-24</a> illustrates these three keywords, and how they relate to one another and to the content they surround.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Therelationofborder-widthkeywordstoeachother">&#13;
<img alt="css5 0724" src="assets/css5_0724.png"/>&#13;
<h6><span class="label">Figure 7-24. </span>The relation of border-width keywords to each other</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s suppose a paragraph has a background color and a border style set:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">background-color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code>&#13;
    <code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The border’s width is, by default, <code>medium</code>. We can change that easily&#13;
enough:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">background-color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code>&#13;
    <code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-width</code><code class="o">:</code> <code class="nb">thick</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Border widths can be taken to fairly ridiculous extremes,&#13;
such as setting 1,000-pixel borders, though this is rarely necessary (or advisable). It is important to remember that &#13;
<span class="keep-together">borders</span>, and therefore <code>border-width</code> values, participate in the box model, impacting an element’s size.</p>&#13;
&#13;
<p>It’s possible to set widths for individual sides, using two&#13;
familiar methods. The first is to use any of the specific properties&#13;
mentioned at the beginning of the section, such as&#13;
<code>border-bottom-width</code>. <a data-primary="values" data-secondary="replicating in borders" data-type="indexterm" id="idm45176101796736"/>The other way is to use value replication in&#13;
<code>border-width</code>, following the usual TRBL pattern, which is illustrated in <a data-type="xref" href="#Valuereplicationandunevenborderwidths">Figure 7-25</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">dotted</code><code class="p">;</code> <code class="k">border-width</code><code class="o">:</code> <code class="nb">thin</code> <code class="m">0px</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-width</code><code class="o">:</code> <code class="m">15px</code> <code class="m">2px</code> <code class="m">8px</code> <code class="m">5px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Valuereplicationandunevenborderwidths">&#13;
<img alt="css5 0725" src="assets/css5_0725.png"/>&#13;
<h6><span class="label">Figure 7-25. </span>Value replication and uneven border widths</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logical border widths" data-type="sect3"><div class="sect3" id="logical-border-widths">&#13;
<h3>Logical border widths</h3>&#13;
&#13;
<p>That said, <a data-primary="border-block-width property" data-type="indexterm" id="idm45176101744864"/><a data-primary="border-inline-width property" data-type="indexterm" id="idm45176101744160"/><a data-primary="logical properties" data-secondary="border styles" data-type="indexterm" id="idm45176101743520"/><a data-primary="properties" data-secondary="logical" data-type="indexterm" id="idm45176101742576"/>if you want to set border widths based on writing direction, you can use the usual complement of logical counterparts to go with the physical properties.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176101716992">&#13;
<h1>border-block-width, border-inline-width</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>thin</code> | <code>medium</code> | <code>thick</code> | &lt;<em><code>length</code></em>&gt; ]{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>Not defined for shorthand properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties (<code>border-top-style</code>, etc.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176101702544">&#13;
<h1>border-block-start-width, border-block-end-width, <span class="keep-together">border-inline-start-width, border-inline-end-width</span></h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>thin</code> | <code>medium</code> | <code>thick</code> | &lt;<em><code>length</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>medium</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>An absolute length, or <code>0</code> if the style of the border&#13;
is <code>none</code> or <code>hidden</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>As you saw with the <a data-primary="border-block-end-width property" data-type="indexterm" id="idm45176101686352"/><a data-primary="border-block-start-width property" data-type="indexterm" id="idm45176101685648"/><a data-primary="border-inline-end-width property" data-type="indexterm" id="idm45176101685008"/><a data-primary="border-inline-start-width property" data-type="indexterm" id="idm45176101684368"/>border widths, these can either be set one side at a time, or compressed into the <code>border-block-width</code> and <code>border-inline-width</code> properties.  The following two rules will have exactly the same effect:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="nb">thick</code> <code class="nb">thin</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="m">1em</code> <code class="m">5px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">p</code> <code class="p">{</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="m">5px</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="nb">thick</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="nb">thin</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="No border at all" data-type="sect3"><div class="sect3" id="no-border-at-all">&#13;
<h3>No border at all</h3>&#13;
&#13;
<p>So far, we’ve talked only about using a visible border style such as&#13;
<code>solid</code> or <code>outset</code>. <a data-primary="border-style property" data-type="indexterm" id="idm45176101654448"/><a data-primary="borders" data-secondary="none" data-type="indexterm" id="idm45176101653712"/>Let’s consider what happens when you set&#13;
<code>border-style</code> to <code>none</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">none</code><code class="p">;</code> <code class="k">border-width</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Even though the border’s width is <code>20px</code>, the style is set to <code>none</code>. In&#13;
this case, not only does the border’s style vanish, so does its width.&#13;
The border just ceases to be. Why?</p>&#13;
&#13;
<p>As you may remember, the terminology used earlier in the chapter indicated that a border with a style of <code>none</code> <em>does not exist</em>. Those words were chosen very carefully, because they help explain what’s going on here. Since the border doesn’t exist, it can’t have any width, so the width is automatically set to <code>0</code> (zero), no matter what you try to define.</p>&#13;
&#13;
<p>After all, if a drinking glass is empty, you can’t really describe it as being half-full of nothing. You can discuss the depth of a glass’s contents only if it has actual contents. In the same way, talking about the width of a border makes sense only in the context of a border that exists.</p>&#13;
&#13;
<p>This is important to keep in mind because it’s a common mistake to&#13;
forget to declare a border style. This leads to all kinds of developer frustration because, at first glance, the styles appear correct. Given&#13;
the following rule, though, no <code>&lt;h1&gt;</code> element will have a border of any&#13;
kind, let alone one that’s 20 pixels wide:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border-width</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code></pre>&#13;
&#13;
<p class="pagebreak-before">Since the default value of <code>border-style</code> is <code>none</code>, failure to declare&#13;
a style is exactly the same as declaring <code>border-style: none</code>.&#13;
Therefore, if you want a border to appear, you need to declare a border&#13;
style.<a data-primary="" data-startref="ix_borders_width" data-type="indexterm" id="idm45176101534272"/><a data-primary="" data-startref="ix_border_width_prop" data-type="indexterm" id="idm45176101533296"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Border Colors" data-type="sect2"><div class="sect2" id="border-colors">&#13;
<h2>Border Colors</h2>&#13;
&#13;
<p>Compared to the <a data-primary="colors" data-secondary="border" data-type="indexterm" id="ix_color_border"/><a data-primary="border-color property" data-type="indexterm" id="idm45176101527424"/><a data-primary="borders" data-secondary="colors" data-type="indexterm" id="ix_borders_colors"/>other aspects of borders, setting the color is pretty&#13;
easy. CSS <span class="keep-together">uses the</span> physical shorthand property <code>border-color</code>, which can accept up&#13;
to four color values at one time. (See <a data-type="xref" href="ch05.html#color">“Color”</a> for the valid value formats of colors.)</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176101523504">&#13;
<h1>border-color</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>color</code></em>&gt;{1,4}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>Not defined for shorthand properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties (<code>border-top-color</code>, etc.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>If there are fewer than four values, value replication takes effect as&#13;
usual. So if you want <code>&lt;h1&gt;</code> elements to have thin gray top and bottom&#13;
borders with thick green side borders, and medium gray borders around&#13;
<code>&lt;p&gt;</code> elements, the following styles will suffice, with the result shown&#13;
in <a data-type="xref" href="#Bordershavemanyaspects">Figure 7-26</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-width</code><code class="o">:</code> <code class="nb">thin</code> <code class="nb">thick</code><code class="p">;</code> <code class="k">border-color</code><code class="o">:</code> <code class="nb">gray</code> <code class="nb">green</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Bordershavemanyaspects">&#13;
<img alt="css5 0726" src="assets/css5_0726.png"/>&#13;
<h6><span class="label">Figure 7-26. </span>Borders have many aspects</h6>&#13;
</div></figure>&#13;
&#13;
<p>A single <code>color</code> value will be applied to all four sides, as&#13;
with the paragraph in the previous example. On the other hand, if you&#13;
supply four color values, you can get a different color on each side.&#13;
Any type of color value can be used, from named colors to hexadecimal&#13;
and HSL values:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-width</code><code class="o">:</code> <code class="nb">thick</code><code class="p">;</code>&#13;
    <code class="k">border-color</code><code class="o">:</code> <code class="nb">black</code> <code class="n">hsl</code><code class="p">(</code><code class="m">0</code> <code class="m">0%</code> <code class="m">25%</code> <code class="o">/</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">)</code> <code class="m">#808080</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If you don’t declare a color, the default is <code>currentcolor</code>, which is always the foreground color of the element. Thus, the following declaration will be displayed as shown in <a data-type="xref" href="#Bordercolorsbasedontheelementsforegroundandthevalueoftheborder-colorproperty">Figure 7-27</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.shade1</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-width</code><code class="o">:</code> <code class="nb">thick</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.shade2</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-width</code><code class="o">:</code> <code class="nb">thick</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;</code>&#13;
    <code class="k">border-color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Bordercolorsbasedontheelementsforegroundandthevalueoftheborder-colorproperty">&#13;
<img alt="css5 0727" src="assets/css5_0727.png"/>&#13;
<h6><span class="label">Figure 7-27. </span>Border colors based on the element’s foreground and the value of the <code>border-color</code> property</h6>&#13;
</div></figure>&#13;
&#13;
<p>The result is that the first paragraph has a gray border, having used&#13;
the foreground color of the paragraph. The second&#13;
paragraph, however, has a black border because that color was explicitly&#13;
assigned using <code>border-color</code>.</p>&#13;
&#13;
<p>Physical <a data-primary="borders" data-secondary="single-side properties" data-type="indexterm" id="idm45176101353088"/><a data-primary="single-side border styles" data-type="indexterm" id="idm45176101352192"/><a data-primary="border-bottom-color property" data-type="indexterm" id="idm45176101351552"/><a data-primary="border-left-color property" data-type="indexterm" id="idm45176101350912"/><a data-primary="border-right-color property" data-type="indexterm" id="idm45176101350272"/><a data-primary="border-top-color property" data-type="indexterm" id="idm45176101349632"/>single-side border color properties exist as well. They work in much the same way as the single-side properties for border style and width. One way to give headings a solid black border with a solid gray right border is&#13;
as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;</code> <code class="k">border-right-color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176101266624">&#13;
<h1>border-top-color, border-right-color, <span class="keep-together">border-bottom-color, border-left-color</span></h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>color</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>The element’s <code>currentcolor</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>If no value is declared, use the computed value of <code>currentcolor</code>; otherwise, as declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logical border colors" data-type="sect3"><div class="sect3" id="logical-border-colors">&#13;
<h3>Logical border colors</h3>&#13;
&#13;
<p>Just as <a data-primary="border-inline-end-color property" data-type="indexterm" id="idm45176101253312"/><a data-primary="border-inline-start-color property" data-type="indexterm" id="idm45176101252608"/><a data-primary="border-inline-color property" data-type="indexterm" id="idm45176101251968"/><a data-primary="logical properties" data-secondary="border styles" data-type="indexterm" id="idm45176101251328"/><a data-primary="properties" data-secondary="logical" data-type="indexterm" id="idm45176101250384"/><a data-primary="border-block-end-color property" data-type="indexterm" id="idm45176101249440"/><a data-primary="border-block-start-color property" data-type="indexterm" id="idm45176101248800"/><a data-primary="border-block-color property" data-type="indexterm" id="idm45176101248160"/>with border styles and widths, logical properties shadow the physical properties: two shorthand, four longhand.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176101247136">&#13;
<h1>border-block-color, border-inline-color</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>color</code></em>&gt;{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>Not defined for shorthand properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties (<code>border-block-start-color</code>, etc.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176101233856">&#13;
<h1>border-block-start-color, border-block-end-color, <span class="keep-together">border-inline-start-color, border-inline-end-color</span></h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>color</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>The element’s <code>currentcolor</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>If no value is declared, use the computed value of <code>currentcolor</code>; otherwise, as declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Thus, the following two rules would have the exact same outcome:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code> <code class="nb">green</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="k">color</code><code class="o">:</code> <code class="nb">orange</code> <code class="nb">blue</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">p</code> <code class="p">{</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="nb">black</code><code class="p">;</code>&#13;
     <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="nb">green</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transparent borders" data-type="sect3"><div class="sect3" id="transparent-borders">&#13;
<h3>Transparent borders</h3>&#13;
&#13;
<p>As you may recall, if a border has <a data-primary="borders" data-secondary="transparent" data-type="indexterm" id="idm45176101173488"/><a data-primary="transparent borders" data-type="indexterm" id="idm45176101172512"/>no style, it has no width. In some situations, however, you’ll want to create an invisible border&#13;
that still has width. This is where the border color value <code>transparent</code> comes in.</p>&#13;
&#13;
<p>Let’s say we want a set of three links to have borders that are&#13;
invisible by default, but look inset when the link is hovered. We can&#13;
accomplish this by making the borders transparent in the nonhovered&#13;
case:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code><code class="o">,</code> <code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">inset</code><code class="p">;</code> <code class="k">border-width</code><code class="o">:</code> <code class="m">5px</code><code class="p">;</code>&#13;
    <code class="k">border-color</code><code class="o">:</code> <code class="nb">transparent</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:hover</code> <code class="p">{</code><code class="k">border-color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will have the effect shown in <a data-type="xref" href="#using_transparent_borders">Figure 7-28</a>.<a data-primary="" data-startref="ix_borders_colors" data-type="indexterm" id="idm45176101088640"/><a data-primary="" data-startref="ix_color_border" data-type="indexterm" id="idm45176101087760"/></p>&#13;
&#13;
<p>In a sense, <code>transparent</code> lets you use borders as if they were extra&#13;
padding. Should you want to make them visible, the space is reserved, preventing a reflow of content when visible borders are added in.</p>&#13;
&#13;
<figure><div class="figure" id="using_transparent_borders">&#13;
<img alt="css5 0728" src="assets/css5_0728.png"/>&#13;
<h6><span class="label">Figure 7-28. </span>Using transparent borders</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Single-Side Shorthand Border Properties" data-type="sect2"><div class="sect2" id="single-side-shorthand-border-properties">&#13;
<h2>Single-Side Shorthand Border Properties</h2>&#13;
&#13;
<p>It turns out that <a data-primary="borders" data-secondary="single-side properties" data-type="indexterm" id="ix_border_singleside_prop"/><a data-primary="borders" data-secondary="shorthand properties for" data-type="indexterm" id="ix_border_shorthand_prop"/>shorthand properties such as <code>border-color</code> and&#13;
<code>border-style</code> aren’t always as helpful as you’d think. For example, you&#13;
might want to apply a thick, gray, solid border to all <code>&lt;h1&gt;</code> elements,&#13;
but only along the bottom. If you limit yourself to the properties we’ve&#13;
discussed so far, you’ll have a hard time applying such a border. Here&#13;
are two examples:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border-bottom-width</code><code class="o">:</code> <code class="nb">thick</code><code class="p">;</code>  <code class="c">/* option #1 */</code>&#13;
    <code class="k">border-bottom-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code>&#13;
    <code class="k">border-bottom-color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">border-width</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="nb">thick</code><code class="p">;</code>    <code class="c">/* option #2 */</code>&#13;
    <code class="k">border-style</code><code class="o">:</code> <code class="nb">none</code> <code class="nb">none</code> <code class="nb">solid</code><code class="p">;</code>&#13;
    <code class="k">border-color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Neither is really convenient, given all the typing involved.&#13;
Fortunately, a better solution is available:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border-bottom</code><code class="o">:</code> <code class="nb">thick</code> <code class="nb">solid</code> <code class="nb">rgb</code><code class="p">(</code><code class="m">50%</code> <code class="m">40%</code> <code class="m">75%</code><code class="p">);}</code></pre>&#13;
&#13;
<p>This will apply the values to the bottom border alone, as shown in&#13;
<a data-type="xref" href="#Settingabottomborderwithashorthandproperty">Figure 7-29</a>, leaving the others to their defaults. Since the default border&#13;
style is <code>none</code>, no borders appear on the other three sides of the&#13;
element.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Settingabottomborderwithashorthandproperty">&#13;
<img alt="css5 0729" src="assets/css5_0729.png"/>&#13;
<h6><span class="label">Figure 7-29. </span>Setting a bottom border with a shorthand property</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you may have guessed, CSS has <a data-primary="border-top property" data-type="indexterm" id="ix_border_top_prop"/><a data-primary="border-inline-start property" data-type="indexterm" id="ix_border_inlinestrt_prop"/><a data-primary="border-left property" data-type="indexterm" id="ix_border_left_prop"/><a data-primary="border-inline-end property" data-type="indexterm" id="ix_border_inlineend_prop"/><a data-primary="border-block-start property" data-type="indexterm" id="ix_border_block_strt_prop"/><a data-primary="border-bottom property" data-type="indexterm" id="ix_border_bottom_prop"/><a data-primary="border-block-end property" data-type="indexterm" id="ix_border_block_end_prop"/><a data-primary="border-right property" data-type="indexterm" id="ix_border_right_prop"/>four physical&#13;
shorthand properties and four logical shorthand properties.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176100943312">&#13;
<h1>border-top, border-right, border-bottom, border-left, border-block-start, border-block-end, border-inline-start, border-inline-end</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>border-width</code></em>&gt; ‖ &lt;<em><code>border-style</code></em>&gt; ‖ &lt;<em><code>border-color</code></em>&gt; ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>Not defined for shorthand properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties (<code>border-width</code>, etc.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>We can use these properties to create some complex borders,&#13;
such as those shown in <a data-type="xref" href="#Verycomplexborders">Figure 7-30</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border-left</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code>&#13;
    <code class="k">border-right</code><code class="o">:</code> <code class="nb">green</code> <code class="m">0.25em</code> <code class="nb">dotted</code><code class="p">;</code>&#13;
    <code class="k">border-top</code><code class="o">:</code> <code class="nb">thick</code> <code class="nb">goldenrod</code> <code class="nb">inset</code><code class="p">;</code>&#13;
    <code class="k">border-bottom</code><code class="o">:</code> <code class="nb">double</code> <code class="nb">rgb</code><code class="p">(</code><code class="m">13%</code> <code class="m">33%</code> <code class="m">53%</code><code class="p">)</code> <code class="m">10px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Verycomplexborders">&#13;
<img alt="css5 0730" src="assets/css5_0730.png"/>&#13;
<h6><span class="label">Figure 7-30. </span>Very complex borders</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you can see, the order of the actual values doesn’t really matter.&#13;
The following three rules will yield exactly the same border effect:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border-bottom</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">border-bottom</code><code class="o">:</code> <code class="nb">solid</code> <code class="nb">gray</code> <code class="m">3px</code><code class="p">;}</code>&#13;
<code class="nt">h3</code> <code class="p">{</code><code class="k">border-bottom</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">gray</code> <code class="nb">solid</code><code class="p">;}</code></pre>&#13;
&#13;
<p>You can also leave out some values and let their defaults kick in, like&#13;
this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h3</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">border-bottom</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Since no border color is declared, the default value (<code>currentcolor</code>) is applied instead. Just remember that if you leave out a border style, the default value of <code>none</code> will prevent your border from existing.</p>&#13;
&#13;
<p>By contrast, if you set only a style, you will still get a border. Let’s&#13;
say you want a top border style of <code>dashed</code> and you’re willing to&#13;
let the width default to <code>medium</code> and the color be the same as the text&#13;
of the element itself. All you need in such a case is the following&#13;
markup (shown in <a data-type="xref" href="#Dashingacrossthetopofanelement">Figure 7-31</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.roof</code> <code class="p">{</code><code class="k">border-top</code><code class="o">:</code> <code class="nb">dashed</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Dashingacrossthetopofanelement">&#13;
<img alt="css5 0731" src="assets/css5_0731.png"/>&#13;
<h6><span class="label">Figure 7-31. </span>Dashing across the top of an element</h6>&#13;
</div></figure>&#13;
&#13;
<p>Also note that since each of these border-side properties applies only to a specific side, there isn’t any possibility of value replication—it wouldn’t make any sense. There can be only one of each type of value: that is, only one width value, only one color value, and only one border style. So don’t try to declare more than one value type:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h3</code> <code class="p">{</code><code class="k">border-top</code><code class="o">:</code> <code class="nb">thin</code> <code class="nb">thick</code> <code class="nb">solid</code> <code class="nb">purple</code><code class="p">;}</code> <code class="c">/* two width values--WRONG */</code></pre>&#13;
&#13;
<p>This entire statement is invalid, and a user agent will ignore it.<a data-primary="" data-startref="ix_border_block_end_prop" data-type="indexterm" id="idm45176100751792"/><a data-primary="" data-startref="ix_border_block_strt_prop" data-type="indexterm" id="idm45176100750944"/><a data-primary="" data-startref="ix_border_bottom_prop" data-type="indexterm" id="idm45176100733936"/><a data-primary="" data-startref="ix_border_inlineend_prop" data-type="indexterm" id="idm45176100732992"/><a data-primary="" data-startref="ix_border_inlinestrt_prop" data-type="indexterm" id="idm45176100732080"/><a data-primary="" data-startref="ix_border_left_prop" data-type="indexterm" id="idm45176100731168"/><a data-primary="" data-startref="ix_border_right_prop" data-type="indexterm" id="idm45176100730224"/><a data-primary="" data-startref="ix_border_shorthand_prop" data-type="indexterm" id="idm45176100729280"/><a data-primary="" data-startref="ix_border_singleside_prop" data-type="indexterm" id="idm45176100728368"/><a data-primary="" data-startref="ix_border_top_prop" data-type="indexterm" id="idm45176100727456"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Global Borders" data-type="sect2"><div class="sect2" id="global-borders">&#13;
<h2>Global Borders</h2>&#13;
&#13;
<p>Now, we come to the <a data-primary="border property" data-secondary="shorthand property" data-type="indexterm" id="idm45176100703648"/><a data-primary="borders" data-secondary="global" data-type="indexterm" id="idm45176100702800"/><a data-primary="global borders" data-type="indexterm" id="idm45176100701952"/>shortest shorthand border property of all: <code>border</code>, which affects all four sides of the element equally.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176100700640">&#13;
<h1>border</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>border-width</code></em>&gt; ‖ &lt;<em><code>border-style</code></em>&gt; ‖ &lt;<em><code>border-color</code></em>&gt; ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>Refer to individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This property has the advantage of being very compact, although that&#13;
brevity introduces a few limitations. Before we worry about that, let’s&#13;
see how <code>border</code> works. If you want all <code>&lt;h1&gt;</code> elements to have a thick&#13;
silver border, the following declaration would display as shown in <a data-type="xref" href="#Areallyshortborderdeclaration">Figure 7-32</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="nb">thick</code> <code class="nb">silver</code> <code class="nb">solid</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Areallyshortborderdeclaration">&#13;
<img alt="css5 0732" src="assets/css5_0732.png"/>&#13;
<h6><span class="label">Figure 7-32. </span>A really short border declaration</h6>&#13;
</div></figure>&#13;
&#13;
<p>The drawback with <code>border</code> is that you can define only a single global style, width, and color. The values you supply for <code>border</code> will apply to all four sides equally. If you want the borders to be different for a single side, use some of the other border properties. Then again, it’s possible to turn the cascade to your advantage:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="nb">thick</code> <code class="nb">goldenrod</code> <code class="nb">solid</code><code class="p">;</code>&#13;
    <code class="k">border-left-width</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The second rule overrides the width value for the left border assigned&#13;
by the first rule, thus replacing <code>thick</code> with <code>20px</code>, as you can see in&#13;
<a data-type="xref" href="#Usingthecascadetoonesadvantage">Figure 7-33</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Usingthecascadetoonesadvantage">&#13;
<img alt="css5 0733" src="assets/css5_0733.png"/>&#13;
<h6><span class="label">Figure 7-33. </span>Using the cascade to your advantage</h6>&#13;
</div></figure>&#13;
&#13;
<p>You still need to take the usual precautions with shorthand properties:&#13;
if you omit a value, the default will be filled in automatically. This&#13;
can have unintended effects. Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h4</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="nb">medium</code> <code class="nb">green</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Here, we’ve failed to assign a <code>border-style</code>, which means that the default value of <code>none</code> will be used, and thus no <code>&lt;h4&gt;</code> elements will have any border at all.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Borders and Inline Elements" data-type="sect2"><div class="sect2" id="borders-and-inline-elements">&#13;
<h2>Borders and Inline Elements</h2>&#13;
&#13;
<p>Dealing with <a data-primary="inline formatting" data-secondary="borders" data-type="indexterm" id="ix_inline_format_borders"/><a data-primary="borders" data-secondary="inline elements" data-type="indexterm" id="ix_border_inline_elem"/>borders and inline elements should sound pretty familiar,&#13;
since the rules are largely the same as those that cover padding and&#13;
inline elements, as we discussed earlier. Still, we’ll briefly touch on&#13;
the topic again.</p>&#13;
&#13;
<p>First, no matter how thick you make your borders on inline elements, the&#13;
line height of the element won’t change. Let’s set block-start and block-end&#13;
borders on boldfaced text:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">10px</code> <code class="nb">solid</code> <code class="n">hsl</code><code class="p">(</code><code class="m">216</code><code class="o">,</code><code class="m">50%</code><code class="o">,</code><code class="m">50%</code><code class="p">);</code>&#13;
        <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="m">#AEA010</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As seen before, adding borders to the block start and end will have&#13;
absolutely no effect on the line height. However, since borders are&#13;
visible, they’ll be drawn—as illustrated in <a data-type="xref" href="#Bordersoninlinenonreplacedelements">Figure 7-34</a>.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="Bordersoninlinenonreplacedelements">&#13;
<img alt="css5 0734" src="assets/css5_0734.png"/>&#13;
<h6><span class="label">Figure 7-34. </span>Borders on inline nonreplaced elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>The borders have to go somewhere. That’s where they went. They get painted over the preceding line of text and under the next line of text if need be.</p>&#13;
&#13;
<p>Again, all of this is true only for the block-start and -end sides of inline elements; the inline sides are a different story. If you apply a border along an inline side, not only will they be visible, but they’ll&#13;
displace the text around them, as you can see in <a data-type="xref" href="#Aninlinenonreplacedelementwithaleftborder">Figure 7-35</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="n">border</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">25px</code> <code class="nb">double</code> <code class="n">hsl</code><code class="p">(</code><code class="m">216</code> <code class="m">50%</code> <code class="m">50%</code><code class="p">);</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="Aninlinenonreplacedelementwithaleftborder">&#13;
<img alt="css5 0735" src="assets/css5_0735.png"/>&#13;
<h6><span class="label">Figure 7-35. </span>Inline nonreplaced elements with inline-start borders</h6>&#13;
</div></figure>&#13;
&#13;
<p>With borders, just as with padding, the browser’s calculations for&#13;
line breaking are not directly affected by any box properties set for&#13;
inline nonreplaced elements. The only effect is that the space taken up&#13;
by the borders may shift portions of the line over a bit, which may in&#13;
turn change which word is at the end of the line.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The way borders are (or aren’t) drawn at the ends of each line&#13;
box can be altered with the property <code>box-decoration-break</code>.  See <a data-type="xref" href="ch06.html#basic-visual-formatting">Chapter 6</a> for more details.</p>&#13;
</div>&#13;
&#13;
<p>With <a data-primary="replaced elements" data-secondary="borders for" data-type="indexterm" id="idm45176100491712"/>replaced elements such as images, on the other hand, the effects&#13;
are very much like those we saw with padding: a border <em>will</em> affect the&#13;
height of the lines of text, in addition to shifting text around to the&#13;
sides. Thus, assuming the following styles, we get a result like that&#13;
seen in <a data-type="xref" href="#Bordersoninlinereplacedelements">Figure 7-36</a>:<a data-primary="" data-startref="ix_border_inline_elem" data-type="indexterm" id="idm45176100489392"/><a data-primary="" data-startref="ix_inline_format_borders" data-type="indexterm" id="idm45176100488416"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1em</code> <code class="nb">solid</code> <code class="nb">rgb</code><code class="p">(</code><code class="m">216</code><code class="o">,</code><code class="m">108</code><code class="o">,</code><code class="m">54</code><code class="p">);}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Bordersoninlinereplacedelements">&#13;
<img alt="css5 0736" src="assets/css5_0736.png"/>&#13;
<h6><span class="label">Figure 7-36. </span>Borders on inline replaced elements</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rounding Border Corners" data-type="sect2"><div class="sect2" id="border-radius">&#13;
<h2>Rounding Border Corners</h2>&#13;
&#13;
<p>We can <a data-primary="rounding corners" data-type="indexterm" id="ix_round_corner"/><a data-primary="borders" data-secondary="corner rounding" data-type="indexterm" id="ix_border_round_corner"/><a data-primary="corners" data-secondary="rounding" data-type="indexterm" id="ix_corner_round"/><a data-primary="border-radius property" data-type="indexterm" id="ix_border_radius_prop"/>soften the square corners of element borders—and actually, the entire background area—by using the property <code>border-radius</code> to define a rounding distance (or two).  In this particular case, we’re going to start with the shorthand physical property and then mention the individual physical properties at the end of the section, after which we’ll check out the logical equivalents.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176100431824">&#13;
<h1>border-radius</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,4} [ / [ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,4} ]?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Two absolute &lt;<em><code>length</code></em>&gt; or &lt;<em><code>percentage</code></em>&gt; values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Calculated with respect to the relevant dimension of the border box</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The radius of a rounded border corner is the radius of a circle or ellipse, one-quarter of which is used to define the path of the border’s rounding.  We’ll start with circles, because they’re a little easier to understand.</p>&#13;
&#13;
<p>Suppose we want to round the corner of an element so that each corner is pretty obviously rounded.  Here’s one way to do that:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">2em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That will have the result shown in <a data-type="xref" href="#Howborderradiiarecalculated">Figure 7-37</a>, where circle diagrams have been added to two of the corners.  (The same rounding is done in all four corners.)</p>&#13;
&#13;
<figure><div class="figure" id="Howborderradiiarecalculated">&#13;
<img alt="css5 0737" src="assets/css5_0737.png"/>&#13;
<h6><span class="label">Figure 7-37. </span>How border radii are calculated</h6>&#13;
</div></figure>&#13;
&#13;
<p>Focus on the top-left corner.  There, the border begins to curve 2 em below the top of the border, and 2 em to the right of the left side of the border.  The curve follows along the outside of the 2-em-radius circle.</p>&#13;
&#13;
<p>If we were to draw a box that contained just the part of the top-left corner that is curved, that box would be 2 em wide and 2 em tall.  The same would happen in the bottom-&#13;
<span class="keep-together">right corner.</span></p>&#13;
&#13;
<p>With single length values, we get circular corner-rounding shapes.  If a single percentage is used, the results are far more oval.  For example, consider the following, illustrated in <a data-type="xref" href="#Howpercentageborderradiiarecalculated">Figure 7-38</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">33%</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Howpercentageborderradiiarecalculated">&#13;
<img alt="css5 0738" src="assets/css5_0738.png"/>&#13;
<h6><span class="label">Figure 7-38. </span>How percentage border radii are calculated</h6>&#13;
</div></figure>&#13;
&#13;
<p>Again, let’s focus on the top-left corner.  On the left edge, the border curve begins at the point 33% of the element box’s height down from the top.  In other words, if the element box is 100 pixels tall from the top border edge to the bottom border edge, the curve begins 33 pixels from the top of the element box.</p>&#13;
&#13;
<p>Similarly, on the top edge, the curve begins at the point 33% of the element box’s width from the left edge.  So if the box is (say) 600 pixels wide, the curve begins 198 pixels from the left edge, because 600 × 0.33 = 198.</p>&#13;
&#13;
<p>The shape of the curve between those two points is identical to the top-left edge of an ellipse whose horizontal radius is 198 pixels long, and whose vertical radius is 33 <span class="keep-together">pixels</span> long.  (This is the same as an ellipse with a horizontal axis of 396 pixels and a vertical axis of 66 pixels.)</p>&#13;
&#13;
<p>The same thing is done in each corner, leading to a set of corner shapes that mirror each other, rather than being identical.</p>&#13;
&#13;
<p>Supplying a single length or percentage value for <code>border-radius</code> means all four corners will have the same rounding shape.  As you may have spotted in the syntax definition, you can supply <code>border-radius</code> with up to four values.  Because <code>border-radius</code> is a physical property, the values go in clockwise order from top left to bottom left, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code>&#13;
     <code class="m">1em</code>  <code class="c">/* Top Left */</code>&#13;
     <code class="m">2em</code>  <code class="c">/* Top Right */</code>&#13;
     <code class="m">3em</code>  <code class="c">/* Bottom Right */</code>&#13;
     <code class="m">4em</code><code class="p">;</code> <code class="c">/* Bottom Left */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This TL-TR-BR-BL can be remembered with the mnemonic “TiLTeR BuRBLe,” if you’re inclined to such things.  The important thing is that the rounding starts in the top left and works its way clockwise from there.</p>&#13;
&#13;
<p>If a value is omitted, the missing values are filled in using a pattern like that used for <code>padding</code>, and so on.  If there are three values, the fourth is copied from the second.  If there are two, the third is copied from the first, and the fourth from the second.  If there’s just one, the missing three are copied from the first.  Thus, the following two rules are identical and will have the result shown in <a data-type="xref" href="#Avarietyofroundedcorners">Figure 7-39</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">1em</code> <code class="m">2em</code> <code class="m">3em</code> <code class="m">2em</code><code class="p">;}</code>&#13;
<code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">1em</code> <code class="m">2em</code> <code class="m">3em</code><code class="p">;</code> <code class="c">/* BL copied from TR */</code><code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Avarietyofroundedcorners">&#13;
<img alt="css5 0739" src="assets/css5_0739.png"/>&#13;
<h6><span class="label">Figure 7-39. </span>A variety of rounded corners</h6>&#13;
</div></figure>&#13;
&#13;
<p>There’s an important aspect to <a data-type="xref" href="#Avarietyofroundedcorners">Figure 7-39</a>: the rounding of the content area’s background along with the rest of the background.  See how the silver curves, and the period sits outside it?  That’s the expected behavior when the content area’s background is different from the padding background (you’ll see how to do that in <a data-type="xref" href="ch08.html#backgrounds">Chapter 8</a>) and the curving of a corner is large enough to affect the boundary between content and padding.</p>&#13;
&#13;
<p>This is because while <code>border-radius</code> changes the way the border and background(s) of an element are drawn, it does <em>not</em> change the shape of the element box.  Consider the situation depicted in <a data-type="xref" href="#Elementswithroundedcornersarestillboxes">Figure 7-40</a>.</p>&#13;
&#13;
<figure><div class="figure" id="Elementswithroundedcornersarestillboxes">&#13;
<img alt="css5 0740" src="assets/css5_0740.png"/>&#13;
<h6><span class="label">Figure 7-40. </span>Elements with rounded corners are still boxes</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here, we have an element that’s been floated to the left, and other text flowing past it.  The border corners are completely round, using <code>border-radius: 50%</code> on a square element. Some of its text is sticking out past the rounded corners.  Beyond the rounded corners, the page background is visible where the corners <em>would</em> have been, were they not rounded.</p>&#13;
&#13;
<p>So at a glance, you might assume that the element has been reshaped from box to circle (technically to ellipse), and the text just happens to stick out of it.  But look at the text flowing past the float.  It doesn’t flow into the area the rounded corners “left behind.”  That’s because the corners of the floated element are still there.  They’re just not visibly filled by border and background, thanks to <code>border-radius</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rounded corner clamping" data-type="sect3"><div class="sect3" id="rounded_border_clamping">&#13;
<h3>Rounded corner clamping</h3>&#13;
&#13;
<p>What <a data-primary="shaping of rounded corners in borders" data-type="indexterm" id="ix_shape_corner"/><a data-primary="corners" data-secondary="shaping" data-type="indexterm" id="ix_corner_shape"/>happens if a radius value is so large that it would spill into other corners?  For example, what happens with <code>border-radius: 100%</code>?  Or <code>border-radius: 9999px</code> on an element that’s nowhere near 10,000 pixels tall or wide?</p>&#13;
&#13;
<p>In any such case, the <a data-primary="clamping of rounded corners in borders" data-type="indexterm" id="idm45176100253744"/>rounding is “clamped” to the maximum it can be for a given quadrant of the element.  Making sure that buttons always look like round-ended-pill shapes can be done like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.button</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">9999em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That will just cap off the shortest ends of the element (usually the left and right sides, but no guarantees) to be smooth semicircular caps.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More complex corner shaping" data-type="sect3"><div class="sect3" id="idm45176100226288">&#13;
<h3>More complex corner shaping</h3>&#13;
&#13;
<p>Now that you’ve seen how assigning a single radius value to a corner shapes it, let’s talk about what happens when corners get two values—and, more importantly, how they get those values.</p>&#13;
&#13;
<p>For example, suppose we want corners to be rounded by 3 character units horizontally, and 1 character unit vertically.  We can’t just use <code>border-radius: 3ch 1ch</code> because that will round the top-left and bottom-right corners by <code>3ch</code>, and the other two corners by <code>1ch</code> each.  Inserting a forward slash will get us what we’re after:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">3ch</code> <code class="o">/</code> <code class="m">1ch</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This is functionally equivalent to saying the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">3ch</code> <code class="m">3ch</code> <code class="m">3ch</code> <code class="m">3ch</code> <code class="o">/</code> <code class="m">1ch</code> <code class="m">1ch</code> <code class="m">1ch</code> <code class="m">1ch</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The way this syntax works, the horizontal radius of each corner’s rounding ellipse is given, and then after the slash, the vertical radius of each corner is given.  In both cases, the values are in TiLTeR BuRBLe order.</p>&#13;
&#13;
<p>Here’s a simpler example, illustrated in <a data-type="xref" href="#Ellipticalcornerrounding">Figure 7-41</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">1em</code> <code class="o">/</code> <code class="m">2em</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Ellipticalcornerrounding">&#13;
<img alt="css5 0741" src="assets/css5_0741.png"/>&#13;
<h6><span class="label">Figure 7-41. </span>Elliptical corner rounding</h6>&#13;
</div></figure>&#13;
&#13;
<p>Each corner is rounded by 1 em along the horizontal axis, and 2 em along the vertical axis, in the manner you saw in detail in the previous section.</p>&#13;
&#13;
<p>Here’s a slightly more complex version, providing two lengths to either side of the slash, as depicted in <a data-type="xref" href="#Differentellipticalroundingcalculations">Figure 7-42</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">2.5em</code> <code class="m">2em</code> <code class="o">/</code> <code class="m">1.5em</code> <code class="m">3em</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Differentellipticalroundingcalculations">&#13;
<img alt="css5 0742" src="assets/css5_0742.png"/>&#13;
<h6><span class="label">Figure 7-42. </span>Different elliptical rounding calculations</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this case, the top-left and bottom-right corners are curved 2.5 em along the horizontal axis, and 1.5 em along the vertical axis.  The top-right and bottom-left corners, on the other hand, are curved 2 em along the horizontal and 3 along the vertical.</p>&#13;
&#13;
<p>Remember, you use horizontal values before the slash, and vertical after.  If we’d wanted to make the top-left and bottom-right corners rounded 1 em horizontally and 1 em vertically (a circular rounding), the values would have been written like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">1em</code> <code class="m">2em</code> <code class="o">/</code> <code class="m">1em</code> <code class="m">3em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Percentages are also fair game here.  If we want to round the corners of an element so that the sides are fully rounded but extend only 2 character units into the element horizontally, we’d write it like so:<a data-primary="" data-startref="ix_corner_shape" data-type="indexterm" id="idm45176100047760"/><a data-primary="" data-startref="ix_shape_corner" data-type="indexterm" id="idm45176100044688"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">2ch</code> <code class="o">/</code> <code class="m">50%</code><code class="p">;}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Corner blending" data-type="sect3"><div class="sect3" id="corner-blending">&#13;
<h3>Corner blending</h3>&#13;
&#13;
<p>So far, the <a data-primary="borders" data-secondary="corner blending" data-type="indexterm" id="idm45176100039024"/><a data-primary="corners" data-secondary="blending" data-type="indexterm" id="idm45176100038016"/><a data-primary="blending" data-secondary="border corners" data-type="indexterm" id="idm45176100037072"/>corners we’ve rounded have been pretty simple—always the same width, style, and color.  That won’t always be the case, though.  What happens if a thick, red, solid border is rounded into a thin, dashed green border?</p>&#13;
&#13;
<p>The specification directs that the rounding cause as smooth a blend as possible when it comes to the width.  When rounding from a thicker border to a thinner border, the width of the border should gradually shrink throughout the curve of the rounded corner.</p>&#13;
&#13;
<p>When it comes to differing styles and colors, the specification is less clear about how this should be accomplished.  Consider the various samples shown in <a data-type="xref" href="#Roundedcornersupclose">Figure 7-43</a>.</p>&#13;
&#13;
<figure><div class="figure" id="Roundedcornersupclose">&#13;
<img alt="css5 0743" src="assets/css5_0743.png"/>&#13;
<h6><span class="label">Figure 7-43. </span>Rounded corners up close</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first is a simple rounded corner, with no variation in color, width, or style.  The second shows rounding from one thickness to another.  You can visualize this second case as defining a circular shape on the outer edge and an elliptical shape on the inner edge.</p>&#13;
&#13;
<p>In the third case, the color and thickness stay the same, but the corner curves from a solid style on the left to a double-line style on top.  The transition between styles is abrupt and occurs at the halfway point in the curve.</p>&#13;
&#13;
<p>The fourth example shows a transition from a thick solid to a thinner double border.  <a data-primary="transitions" data-secondary="border corner rounding" data-type="indexterm" id="idm45176100007968"/>Note the placement of the transition, which is <em>not</em> at the halfway point.  It is instead determined by taking the ratio of the two borders’ thicknesses and using that to find the transition point.  Let’s assume the left border is 10 pixels thick, and the top border 5 pixels thick.  By summing the two to get 15 pixels, the left border gets 2/3 (10/15), and the top border 1/3 (5/15).  Thus, the left border’s style is used in two-thirds of the curve, and the top border’s style in one-third the curve.  The width is still smoothly changed over the length of the curve.</p>&#13;
&#13;
<p>The fifth and sixth examples show what happens with color added to the mix.  Effectively, the color stays linked to the style.  This hard transition between colors is common behavior among browsers as of late 2022, but it may not always be so.  The specification explicitly states that user agents <em>may</em> blend from one border color to another by using a linear gradient.  Perhaps one day they will, but for now, the changeover is sharp.</p>&#13;
&#13;
<p>The seventh example in <a data-type="xref" href="#Roundedcornersupclose">Figure 7-43</a> shows a case we haven’t really discussed: “What happens if the borders are equal to or thicker than the value of <code>border-radius</code>?”  In this case, the outside of the corner is rounded, but the inside is not, as shown.  This would occur with code like the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code>&#13;
     <code class="k">border-color</code><code class="o">:</code> <code class="nb">tan</code> <code class="nb">red</code><code class="p">;</code>&#13;
     <code class="k">border-width</code><code class="o">:</code> <code class="m">20px</code><code class="p">;</code>&#13;
     <code class="k">border-radius</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Individual rounding properties" data-type="sect3"><div class="sect3" id="idm45176099974672">&#13;
<h3>Individual rounding properties</h3>&#13;
&#13;
<p>After that <a data-primary="border-bottom-left-radius property" data-type="indexterm" id="idm45176099966768"/><a data-primary="border-bottom-right-radius property" data-type="indexterm" id="idm45176099966064"/><a data-primary="border-top-left-radius property" data-type="indexterm" id="idm45176099965424"/><a data-primary="border-top-right-radius property" data-type="indexterm" id="idm45176099964784"/>tour of <code>border-radius</code>, you might be wondering whether you can just round one corner at a time.  Yes, you can!  First, let’s consider the physical corners, which are what <code>border-radius</code> brings together.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176099962896">&#13;
<h1>border-top-left-radius, border-top-right-radius, <span class="keep-together">border-bottom-right-radius, border-bottom-left-radius</span></h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Two absolute &lt;<em><code>length</code></em>&gt; or &lt;<em><code>percentage</code></em>&gt; values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Calculated with respect to the relevant dimension of the border box</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Each property sets the curve shape for its corner and doesn’t affect the others.  The fun part is that if you supply two values, one for the horizontal radius and one for the vertical radius, there is <em>no</em> slash separating them.  Really.  This means that the following two rules are functionally equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code>&#13;
     <code class="m">1.5em</code> <code class="m">2vw</code> <code class="m">20%</code> <code class="m">0.67ch</code> <code class="o">/</code> <code class="m">2rem</code> <code class="m">1.2vmin</code> <code class="m">1cm</code> <code class="m">10%</code><code class="p">;</code>&#13;
     <code class="p">}</code>&#13;
<code class="nf">#example</code> <code class="p">{</code>&#13;
     <code class="k">border-top-left-radius</code><code class="o">:</code> <code class="m">1.5em</code> <code class="m">2rem</code><code class="p">;</code>&#13;
     <code class="k">border-top-right-radius</code><code class="o">:</code> <code class="m">2vw</code> <code class="m">1.2vmin</code><code class="p">;</code>&#13;
     <code class="k">border-bottom-right-radius</code><code class="o">:</code> <code class="m">20%</code> <code class="m">1cm</code><code class="p">;</code>&#13;
     <code class="k">border-bottom-left-radius</code><code class="o">:</code> <code class="m">0.67ch</code> <code class="m">10%</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The individual corner border radius properties are mostly useful for setting a common corner rounding and then overriding just one.  Thus, a comic-book-like word balloon shape could be done as follows, with the result shown in <a data-type="xref" href="#links-shaped-like-balloons">Figure 7-44</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.tabs</code> <code class="p">{</code><code class="k">border-radius</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code>&#13;
     <code class="k">border-bottom-left-radius</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="links-shaped-like-balloons">&#13;
<img alt="css5 0744" src="assets/css5_0744.png"/>&#13;
<h6><span class="label">Figure 7-44. </span>Links shaped like word balloons</h6>&#13;
</div></figure>&#13;
&#13;
<p>In addition to the <a data-primary="logical properties" data-secondary="border styles" data-type="indexterm" id="idm45176099841440"/><a data-primary="properties" data-secondary="logical" data-type="indexterm" id="idm45176099823952"/><a data-primary="border-end-end-radius property" data-type="indexterm" id="idm45176099823008"/><a data-primary="border-end-start-radius property" data-type="indexterm" id="idm45176099822368"/><a data-primary="border-start-end-radius property" data-type="indexterm" id="idm45176099821728"/><a data-primary="border-start-start-radius property" data-type="indexterm" id="idm45176099821088"/>physical corners, CSS also has logical corners.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176099820192">&#13;
<h1>border-start-start-radius, border-start-end-radius, <span class="keep-together">border-end-start-radius, border-end-end-radius</span></h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Two absolute &lt;<em><code>length</code></em>&gt; or &lt;<em><code>percentage</code></em>&gt; values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Calculated with respect to the relevant dimension of the border box</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>You might be thinking, “Hold on, that’s not what the other logical properties looked like!”  And that’s true: these are a fair bit different.  That’s because if we had a property like <code>border-block-start-radius</code>, it would apply to both corners along the block-start edge.  But if you also had <code>border-inline-start-radius</code>, it would apply to both corners on the inline-start edge, one of which is also on the block-start edge.</p>&#13;
&#13;
<p>So the way the logical border radius properties work is they’re labeled in the pattern <em>border-block-inline-radius</em>.  Thus, <code>border-start-end-radius</code> sets the radius of the corner that’s at the junction of the block-start and inline-end edges.  Take the following example, which is illustrated in <a data-type="xref" href="#logical-border-radius">Figure 7-45</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="n">border</code><code class="o">-</code><code class="n">start</code><code class="o">-</code><code class="n">end</code><code class="o">-</code><code class="n">radius</code><code class="o">:</code> <code class="m">2em</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="logical-border-radius">&#13;
<img alt="css5 0745" src="assets/css5_0745.png"/>&#13;
<h6><span class="label">Figure 7-45. </span>Rounding the block-start, inline-end corner</h6>&#13;
</div></figure>&#13;
&#13;
<p>Remember that you can use the same space-separated value pattern for defining an elliptical corner radius, as shown earlier in the section for <code>border-top-left-radius</code> and friends.  However, the value is still in the pattern of horizontal radius, then vertical radius, instead of being relative to the block and inline flow directions.  This seems like a bit of an oversight in CSS, but it is how things are as of late 2022.</p>&#13;
&#13;
<p>One thing to keep in mind is that, as you’ve seen, corner shaping affects the background and (potentially) the padding and content areas of the element, but not any image borders.  Wait a minute, image borders?  What are those?  Glad you asked!<a data-primary="" data-startref="ix_border_radius_prop" data-type="indexterm" id="idm45176099762192"/><a data-primary="" data-startref="ix_border_round_corner" data-type="indexterm" id="idm45176099761216"/><a data-primary="" data-startref="ix_corner_round" data-type="indexterm" id="idm45176099760272"/><a data-primary="" data-startref="ix_round_corner" data-type="indexterm" id="idm45176099759328"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Image Borders" data-type="sect2"><div class="sect2" id="image-borders">&#13;
<h2>Image Borders</h2>&#13;
&#13;
<p>The various <a data-primary="image borders" data-type="indexterm" id="ix_image_border_ch7"/>border styles are nice enough but are still fairly limited.&#13;
What if you want to create a really complicated, visually rich border&#13;
around some of your elements? Back in the day, we’d create complex&#13;
multirow tables to achieve that sort of effect, but thanks to image&#13;
borders, there’s almost no limit to the kinds of borders you can create.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Loading and slicing a border image" data-type="sect3"><div class="sect3" id="loading-and-slicing-a-border-image">&#13;
<h3>Loading and slicing a border image</h3>&#13;
&#13;
<p>If you’re <a data-primary="border-image-source property" data-type="indexterm" id="idm45176099741440"/><a data-primary="image borders" data-secondary="source for" data-type="indexterm" id="idm45176099740832"/><a data-primary="image borders" data-secondary="loading" data-type="indexterm" id="idm45176099739984"/>going to use an image to create the borders of an image,&#13;
you’ll need to  define it or fetch it from somewhere. The <code>border-image-source</code> property is how you tell the browser where to look for it.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176099738336">&#13;
<h1>border-image-source</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | &lt;<em><code>image</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements when <code>border-collapse</code> is <code class="keep-together">collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p><code>none</code>, or the image with its URL made absolute</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Let’s load an image of a single circle to be used as the border image,&#13;
using the following styles, whose result is shown in <a data-type="xref" href="#Definingaborderimagessource">Figure 7-46</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border</code><code class="o">:</code> <code class="m">25px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="k">border-image-source</code><code class="o">:</code> <code class="sx">url(i/circle.png)</code><code class="p">;</code></pre>&#13;
&#13;
<figure><div class="figure" id="Definingaborderimagessource">&#13;
<img alt="css5 0746" src="assets/css5_0746.png"/>&#13;
<h6><span class="label">Figure 7-46. </span>Defining a border image’s source</h6>&#13;
</div></figure>&#13;
&#13;
<p>There are a few points to note here. First, without the&#13;
<code>border: 25px solid</code> declaration, there would have been no border at&#13;
all. Remember, if the value of <code>border-style</code> is <code>none</code>, the width&#13;
of the border is 0. So to make a border image appear, you&#13;
need to have a border, which means declaring a <code>border-style</code> value other than <code>none</code> or <code>hidden</code>. It doesn’t have to be <code>solid</code>. Second, the value of <code>border-width</code> determines the actual width of the border images. Without a declared value, it will default to <code>medium</code>, which is 3 pixels. If the border image fails to load, the border is the <code>border-color</code> value.</p>&#13;
&#13;
<p>OK, so we set up a <a data-primary="image borders" data-secondary="slicing" data-type="indexterm" id="ix_image_border_slice"/><a data-primary="border-image-slice property" data-type="indexterm" id="ix_border_image_slice_prop"/>border area 25 pixels wide and then applied an&#13;
image to it. That gave us the same circle in each of the four corners.&#13;
But why did it appear only there and not along the sides? The answer is found in the way the physical property <code>border-image-slice</code> is defined.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176099694224">&#13;
<h1>border-image-slice</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,4} &amp;&amp; <code>fill</code>?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>100%</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements when <code>border-collapse</code> is <code class="keep-together">collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to size of the border image</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As four values, each a number or percentage, and optionally the <code>fill</code> keyword</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>number</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p class="pagebreak-before">What <code>border-image-slice</code> does is establish a set of four slice-lines that are laid over the image, and where they fall determines how the image will be sliced up for use in an image border. The property takes up to four values, defining (in order) offsets from the top, right, bottom, and left edges. Yep, there’s that TRBL pattern again, which pegs <code>border-image-slice</code> as a physical property. And value replication&#13;
is also in effect here, so a single value will be used for all four offsets. <a data-type="xref" href="#Variousslicingpatterns">Figure 7-47</a> shows a small sampling of offset patterns, all based on percentages.</p>&#13;
&#13;
<figure><div class="figure" id="Variousslicingpatterns">&#13;
<img alt="css5 0747" src="assets/css5_0747.png"/>&#13;
<h6><span class="label">Figure 7-47. </span>Various slicing patterns</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of late 2022, no logical-property equivalent exists for <code>border-image-slice</code>.  If the proposed <code>logical</code> keyword, or something equivalent, is ever adopted and implemented, using <code>border-image-slice</code> in a writing-flow-relative fashion will be possible.  There are also no single-side properties; that is, there is no such thing as <code>border-left-image-slice</code>.</p>&#13;
</div>&#13;
&#13;
<p>Now let’s take an image that has a 3 × 3 grid of circles, each a different&#13;
color, and slice it up for use in an image border. <a data-type="xref" href="#Anall-aroundimageborder">Figure 7-48</a> shows a&#13;
single copy of this image and the resulting image border:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border</code><code class="o">:</code> <code class="m">25px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="k">border-image-source</code><code class="o">:</code> <code class="sx">url(i/circles.png)</code><code class="p">;</code>&#13;
<code class="k">border-image-slice</code><code class="o">:</code> <code class="m">33.33%</code><code class="p">;</code></pre>&#13;
&#13;
<p>Yikes! That’s…interesting. The stretchiness of the sides is the&#13;
default behavior, and it makes a fair amount of sense, as you’ll see (and&#13;
find out how to change) in <a data-type="xref" href="#altering-the-repeat-pattern">“Altering the repeat pattern”</a>. Beyond that effect, you can see&#13;
in <a data-type="xref" href="#Anall-aroundimageborder">Figure 7-48</a> that the slice-lines fall right between the circles, because&#13;
the circles are all the same size and so one-third offsets place the&#13;
slice-lines right between them. The corner circles go into the corners&#13;
of the border, and each side’s circle is stretched out to fill its side.</p>&#13;
&#13;
<figure><div class="figure" id="Anall-aroundimageborder">&#13;
<img alt="css5 0748" src="assets/css5_0748.png"/>&#13;
<h6><span class="label">Figure 7-48. </span>An all-around image border</h6>&#13;
</div></figure>&#13;
&#13;
<p>(“Wait, what happened to the gray circle in the middle?” you may wonder.&#13;
It’s an interesting question! For now, just accept it as one of life’s&#13;
little mysteries, albeit a mystery that will be explained later in this&#13;
section.)</p>&#13;
&#13;
<p>All right, so why did our first border image example, back at the&#13;
beginning of the section, place images only in the corners of the border&#13;
area instead of all the way around it?</p>&#13;
&#13;
<p>Anytime the slice-lines meet or go past each other, the&#13;
corner images are created but the side images are made empty. This is&#13;
easiest to visualize with <code>border-image-slice: 50%</code>. In that case, the&#13;
image is sliced into four quadrants, one for each corner, with nothing&#13;
remaining for the sides.</p>&#13;
&#13;
<p>However, any value <em>above</em> <code>50%</code> has the same&#13;
basic result, even though the image isn’t sliced into neat quadrants anymore. Thus, for <code>border-image-slice: 100%</code>—which is the default&#13;
value—each corner gets the entire image, and the sides are left empty. A&#13;
few examples of this effect are shown in <a data-type="xref" href="#Variouspatternsthatpreventsideslices">Figure 7-49</a>.</p>&#13;
&#13;
<p>That’s why we had to have a 3 × 3 grid of circles when we wanted to go all&#13;
the way around the border area, corners, and sides.</p>&#13;
&#13;
<figure><div class="figure" id="Variouspatternsthatpreventsideslices">&#13;
<img alt="css5 0749" src="assets/css5_0749.png"/>&#13;
<h6><span class="label">Figure 7-49. </span>Various patterns that prevent side slices</h6>&#13;
</div></figure>&#13;
&#13;
<p>In addition to using percentage offsets, we also can define the&#13;
offsets by using a number. Not a length, as you might assume, but a bare&#13;
number. In raster images like PNGs or JPEGs, the number corresponds to&#13;
pixels in the image on a 1:1 basis. If you have a raster image and want to define 25-pixel offsets for the slice-lines, this is how to do&#13;
that, as illustrated in <a data-type="xref" href="#Numberslicing">Figure 7-50</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border</code><code class="o">:</code> <code class="m">25px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="k">border-image-source</code><code class="o">:</code> <code class="sx">url(i/circles.png)</code><code class="p">;</code>&#13;
<code class="k">border-image-slice</code><code class="o">:</code> <code class="m">25</code><code class="p">;</code></pre>&#13;
&#13;
<figure><div class="figure" id="Numberslicing">&#13;
<img alt="css5 0750" src="assets/css5_0750.png"/>&#13;
<h6><span class="label">Figure 7-50. </span>Number slicing</h6>&#13;
</div></figure>&#13;
&#13;
<p>Yikes again! What happened there is that the raster image is 150 × 150 pixels, so each circle is 50 × 50 pixels. Our offsets, though, were&#13;
only <code>25</code>, as in 25 pixels. So the slice-lines were placed on the image&#13;
as shown in <a data-type="xref" href="#Slicelinesat25pixels">Figure 7-51</a>.</p>&#13;
&#13;
<p>This begins to give us an idea of why the default behavior for the side&#13;
images is to stretch them. Note how the corners flow into the sides,&#13;
visually speaking.</p>&#13;
&#13;
<p>If you change the image to one that has a different size, numeric offsets don’t adapt to the new size, whereas percentages do. The interesting thing about number&#13;
offsets is that they work just as well on nonraster images, like SVGs,&#13;
as they do on rasters. So do percentages. In general, it’s&#13;
probably best to use percentages for your slicing offsets whenever&#13;
possible, even if that means doing a little math to get exactly the right&#13;
percentages.</p>&#13;
&#13;
<figure><div class="figure" id="Slicelinesat25pixels">&#13;
<img alt="css5 0751" src="assets/css5_0751.png"/>&#13;
<h6><span class="label">Figure 7-51. </span>Slice-lines at 25 pixels</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now let’s address the curious case of the image’s center. In the&#13;
previous examples, a circle is at the center of the 3 × 3 grid of&#13;
circles, but it disappears when the image is applied to the border. In&#13;
the preceding example, in fact, not only the middle circle was&#13;
missing, but the entire center slice. This dropping of the center slice&#13;
is the default behavior for image slicing, but you can override it by&#13;
adding a <code>fill</code> keyword to the end of your <code>border-image-slice</code> value.&#13;
If we add <code>fill</code> to the previous example, as shown here, we’ll get the&#13;
result shown in <a data-type="xref" href="#Usingthefillslice">Figure 7-52</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border</code><code class="o">:</code> <code class="m">25px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="k">border-image-source</code><code class="o">:</code> <code class="sx">url(i/circles.png)</code><code class="p">;</code>&#13;
<code class="k">border-image-slice</code><code class="o">:</code> <code class="m">25</code> <code class="n">fill</code><code class="p">;</code></pre>&#13;
&#13;
<p>There’s the center slice, filling up the element’s background area. In&#13;
fact, it’s drawn over the top of whatever background the element might have, including any background images or color, so you can use it as a substitute for the background or as an addition to it.</p>&#13;
&#13;
<figure><div class="figure" id="Usingthefillslice">&#13;
<img alt="css5 0752" src="assets/css5_0752.png"/>&#13;
<h6><span class="label">Figure 7-52. </span>Using the fill slice</h6>&#13;
</div></figure>&#13;
&#13;
<p>You may have noticed that all our border areas have been a consistent&#13;
width (usually <code>25px</code>). This doesn’t have to be the case, regardless of&#13;
how the border image is actually sliced up. Suppose we take the circles&#13;
border image we’ve been using, slice it by thirds as we have, but make&#13;
the border widths different:<a data-primary="" data-startref="ix_border_image_slice_prop" data-type="indexterm" id="idm45176099536256"/><a data-primary="" data-startref="ix_image_border_slice" data-type="indexterm" id="idm45176099535312"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="k">border-width</code><code class="o">:</code> <code class="m">20px</code> <code class="m">40px</code> <code class="m">60px</code> <code class="m">80px</code><code class="p">;</code>&#13;
<code class="k">border-image-source</code><code class="o">:</code> <code class="sx">url(i/circles.png)</code><code class="p">;</code>&#13;
<code class="k">border-image-slice</code><code class="o">:</code> <code class="m">50</code><code class="p">;</code></pre>&#13;
&#13;
<p>This would have a result like that shown in <a data-type="xref" href="#Unevenborderimagewidths">Figure 7-53</a>. Even though the slice-lines are intrinsically set to 50 pixels (via&#13;
<code>50</code>), the resulting slices are resized to fit into the border areas&#13;
they occupy.</p>&#13;
&#13;
<figure><div class="figure" id="Unevenborderimagewidths">&#13;
<img alt="css5 0753" src="assets/css5_0753.png"/>&#13;
<h6><span class="label">Figure 7-53. </span>Uneven border image widths</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Altering the image widths" data-type="sect3"><div class="sect3" id="altering-the-image-widths">&#13;
<h3>Altering the image widths</h3>&#13;
&#13;
<p>Thus far, all our <a data-primary="border-image-width property" data-type="indexterm" id="ix_border_image_width_prop"/><a data-primary="image borders" data-secondary="width of" data-type="indexterm" id="ix_image_border_widths"/>image borders have depended on a <code>border-width</code> value&#13;
to set the sizes of the border areas, which the border images have&#13;
filled out precisely. That is, if the top border side is 25 pixels tall,&#13;
the border image that fills it will be 25 pixels tall. If you want to make the images a different size than the area defined by <code>border-width</code>, you can use the physical property <code>border-image-width</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176099479088">&#13;
<h1>border-image-width</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | &lt;<em><code>number</code></em>&gt; | <code>auto</code> ]{1,4}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except table elements when <code>border-collapse</code> is <code>collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Relative to width/height of the entire border image area—that is, the outer edges of the <span class="keep-together">border box</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Four values: each a percentage, number, <code>auto</code> keyword, or &lt;<em><code>length</code></em>&gt; made absolute</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Values can never be negative</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The basic fact to understand about <code>border-image-width</code> is that it’s&#13;
very similar to <code>border-image-slice</code>, except that <code>border-image-width</code>&#13;
slices up the border box itself.</p>&#13;
&#13;
<p>To understand what this means, let’s start with length values. We’ll set&#13;
up 1-em border widths like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border-image-width</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code></pre>&#13;
&#13;
<p>That pushes slice-lines 1 em inward from each of the border&#13;
area’s sides, as shown in <a data-type="xref" href="#Placingslice-linesfortheborderimageswidth">Figure 7-54</a>.</p>&#13;
&#13;
<figure><div class="figure" id="Placingslice-linesfortheborderimageswidth">&#13;
<img alt="css5 0754" src="assets/css5_0754.png"/>&#13;
<h6><span class="label">Figure 7-54. </span>Placing slice-lines for the border image’s width</h6>&#13;
</div></figure>&#13;
&#13;
<p>So the top and bottom border areas are 1 em tall, the right and left&#13;
border areas are 1 em wide, and each corner is 1 em tall and wide.&#13;
Given that, the border images created with <code>border-image-slice</code> are&#13;
filled into those border areas in the manner prescribed by&#13;
<code>border-image-repeat</code> (which we’ll get to shortly). Therefore, in <a data-type="xref" href="#css5_border_images-with-and-without">Figure 7-55</a>, we could have had a <code>border-width</code> of 0 and still made the border images show up, by using&#13;
<code>border-image-width</code>. This is useful if you want to have a solid&#13;
border as a fallback in case the border image doesn’t load, but don’t&#13;
want to make it as thick as the image border would be. You could use something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="k">border-image-source</code><code class="o">:</code> <code class="sx">url(stars.gif)</code><code class="p">;</code>&#13;
<code class="k">border-image-width</code><code class="o">:</code> <code class="m">12px</code><code class="p">;</code>&#13;
<code class="k">border-image-slice</code><code class="o">:</code> <code class="m">33.3333%</code><code class="p">;</code>&#13;
<code class="k">padding</code><code class="o">:</code> <code class="m">12px</code><code class="p">;</code></pre>&#13;
&#13;
<figure><div class="figure" id="css5_border_images-with-and-without">&#13;
<img alt="css5 0755" src="assets/css5_0755.png"/>&#13;
<h6><span class="label">Figure 7-55. </span>A border with and without its border image</h6>&#13;
</div></figure>&#13;
&#13;
<p>This allows for a 12-pixel star border to be replaced with a 2-pixel&#13;
solid border if border images aren’t available. Remember that if the image&#13;
border <em>does</em> load, you’ll need to leave enough space for it to show up&#13;
without overlapping the content (by default, that is). You’ll see how to&#13;
mitigate this problem in the next section.</p>&#13;
&#13;
<p>Now that we’ve established how the width slice-lines are placed, the way&#13;
percentage values are handled should make sense, as long as you keep in&#13;
mind that the offsets are with respect to the overall border box, <em>not</em>&#13;
each border side. For example, consider the following declaration,&#13;
illustrated in <a data-type="xref" href="#Placementofpercentageslice-lines">Figure 7-56</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border-image-width</code><code class="o">:</code> <code class="m">33%</code><code class="p">;</code></pre>&#13;
&#13;
<figure><div class="figure" id="Placementofpercentageslice-lines">&#13;
<img alt="css5 0756" src="assets/css5_0756.png"/>&#13;
<h6><span class="label">Figure 7-56. </span>Placement of percentage slice-lines</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">As with length units, the lines are offset from their respective sides&#13;
of the border box. The distance they travel is with respect to the&#13;
border box. A common mistake is to assume that a percentage&#13;
value is with respect to the border area defined by <code>border-width</code>; that&#13;
is, given a <code>border-width</code> value of <code>30px</code>, the result of&#13;
<code>border-image-width: 33.333%;</code> will be 10 pixels. But no! It’s&#13;
one-third the overall border box along that axis.</p>&#13;
&#13;
<p>One way in which the behavior of <code>border-image-width</code> differs from&#13;
<code>border-image-slice</code> is in how it handles slices passing each other, such as in this situation:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border-image-width</code><code class="o">:</code> <code class="m">75%</code><code class="p">;</code></pre>&#13;
&#13;
<p>As you may recall, for <code>border-image-slice</code>, if the slices pass each&#13;
other, then the side areas (top, right, bottom, and/or left) are made&#13;
empty. With <code>border-image-width</code>, the values are proportionally reduced&#13;
until they no longer pass each other. So, given the preceding value of <code>75%</code>, the browser will&#13;
treat that as if it were <code>50%</code>. Similarly, the following two&#13;
declarations will have equivalent results:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border-image-width</code><code class="o">:</code> <code class="m">25%</code> <code class="m">80%</code> <code class="m">25%</code> <code class="m">40%</code><code class="p">;</code>&#13;
<code class="k">border-image-width</code><code class="o">:</code> <code class="m">25%</code> <code class="m">66.6667%</code> <code class="m">25%</code> <code class="m">33.3333%</code><code class="p">;</code></pre>&#13;
&#13;
<p>Note that in both declarations, the right offset is twice the left value.&#13;
That’s what is meant by proportionally reducing the values until they&#13;
don’t overlap: in other words, until they no longer add up to more than&#13;
100%. The same would be done with top and bottom, were they to overlap.</p>&#13;
&#13;
<p>When it comes to number values for <code>border-image-width</code>, things get even&#13;
more interesting. If you set <code>border-image-width: 1</code>, the border&#13;
image areas will be determined by the value of <code>border-width</code>. That’s&#13;
the default behavior. Thus, the following two declarations will have the&#13;
same result:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border-width</code><code class="o">:</code> <code class="m">1em</code> <code class="m">2em</code><code class="p">;</code> <code class="k">border-image-width</code><code class="o">:</code> <code class="m">1em</code> <code class="m">2em</code><code class="p">;</code>&#13;
<code class="k">border-width</code><code class="o">:</code> <code class="m">1em</code> <code class="m">2em</code><code class="p">;</code> <code class="k">border-image-width</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code></pre>&#13;
&#13;
<p>You can increase or reduce the number values to get a certain multiple of the border area that <code>border-width</code> defines. <a data-type="xref" href="#Variousnumericborderimagewidths">Figure 7-57</a> shows a few examples.</p>&#13;
&#13;
<p>In each case, the number has been multiplied by the border area’s width&#13;
or height, and the resulting value indicates the inward distance that the offset is placed from the relevant side. Thus, for an element that has <code>border-top-width</code> set to 3 pixels, <code>border-image-width: 10</code> will create a 30-pixel offset from the top of the element. Change <code>border-image-width</code> to <code>0.333</code>, and the top offset will be a lone pixel.</p>&#13;
&#13;
<figure><div class="figure" id="Variousnumericborderimagewidths">&#13;
<img alt="css5 0757" src="assets/css5_0757.png"/>&#13;
<h6><span class="label">Figure 7-57. </span>Various numeric border image widths</h6>&#13;
</div></figure>&#13;
&#13;
<p>The last value, <code>auto</code>, is interesting in that its resulting values&#13;
depend on the state of two other properties. If <code>border-image-source</code> has been explicitly defined by the author, <code>border-image-width: auto</code> uses the values that result&#13;
from <code>border-image-slice</code>. Otherwise, it uses the values that result&#13;
from <code>border-width</code>. These two declarations will have the&#13;
same result:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border-width</code><code class="o">:</code> <code class="m">1em</code> <code class="m">2em</code><code class="p">;</code> <code class="k">border-image-width</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
<code class="k">border-image-slice</code><code class="o">:</code> <code class="m">1em</code> <code class="m">2em</code><code class="p">;</code> <code class="k">border-image-width</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code></pre>&#13;
&#13;
<p>Note that you can mix up the value types for <code>border-image-width</code>. The&#13;
following are all valid, and would be quite interesting to try out in&#13;
live web pages:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border-image-width</code><code class="o">:</code> <code class="nb">auto</code> <code class="m">10px</code><code class="p">;</code>&#13;
<code class="k">border-image-width</code><code class="o">:</code> <code class="m">5</code> <code class="m">15%</code> <code class="nb">auto</code><code class="p">;</code>&#13;
<code class="k">border-image-width</code><code class="o">:</code> <code class="m">0.42em</code> <code class="m">13%</code> <code class="m">3</code><code class="o">.</code><code class="m">14</code> <code class="nb">auto</code><code class="p">;</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As with <code>border-image-slice</code>, no logical-property equivalent exists for <code>border-image-width</code> as of late 2022.<a data-primary="" data-startref="ix_border_image_width_prop" data-type="indexterm" id="idm45176099138368"/><a data-primary="" data-startref="ix_image_border_widths" data-type="indexterm" id="idm45176099137392"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a border overhang" data-type="sect3"><div class="sect3" id="creating-a-border-overhang">&#13;
<h3>Creating a border overhang</h3>&#13;
&#13;
<p>Well, now that we can <a data-primary="border-image-outset property" data-type="indexterm" id="ix_border_image_outset_prop"/><a data-primary="overhanging image borders" data-type="indexterm" id="ix_overhang_image_border"/><a data-primary="image borders" data-secondary="overhanging" data-type="indexterm" id="ix_image_border_overhang"/>define these great big image slices and widths,&#13;
how do we keep them from overlapping the content? We could add&#13;
lots of padding, but that would leave huge amounts of space if the image&#13;
fails to load, or if the browser doesn’t support border images. Handling&#13;
such scenarios is what the physical property <code>border-image-outset</code> is built to manage.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176099131056">&#13;
<h1>border-image-outset</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>number</code></em>&gt; ]{1,4}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements when <code>border-collapse</code> is <code>collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>N/A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Four values, each a number or &lt;<em><code>length</code></em>&gt; made absolute</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Values can never be negative</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Regardless of whether you use a length or a number,&#13;
<code>border-image-outset</code> pushes the border image area outward, beyond the&#13;
border box, in a manner similar to the way slice-lines are offset. The&#13;
difference is that here, the offsets are outward, not inward. Just as&#13;
with <code>border-image-width</code>, number values for <code>border-image-outset</code> are a&#13;
multiple of the width defined by <code>border-width</code>—<em>not</em>&#13;
<code>border-image-width</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As with <code>border-image-slice</code> and <code>border-image-width</code>, no logical-property equivalent exists for <code>border-image-outset</code> as of late 2022.</p>&#13;
</div>&#13;
&#13;
<p>To see how this could be helpful, imagine that we want to use&#13;
a border image but have a fallback of a thin solid border if the image&#13;
isn’t available. We might start out like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code>&#13;
<code class="k">border-image-slice</code><code class="o">:</code> <code class="m">10</code><code class="p">;</code>&#13;
<code class="k">border-image-width</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code></pre>&#13;
&#13;
<p>In this case, we have half an em of padding; at default browser&#13;
settings, that will be about 8 pixels. That plus the 2-pixel&#13;
solid border make a distance of 10 pixels from the content edge to the&#13;
outer border edge. So if the border image is available and rendered, it&#13;
will fill not only the border area, but also the padding, bringing it&#13;
right up against the content.</p>&#13;
&#13;
<p>We could increase the padding to account for this, but then if the image&#13;
<em>doesn’t</em> appear, we’ll have a lot of excess padding between the content&#13;
and the thin solid border. Instead, let’s push the border image outward,&#13;
like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code>&#13;
<code class="k">border-image-slice</code><code class="o">:</code> <code class="m">10</code><code class="p">;</code>&#13;
<code class="k">border-image-width</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
<code class="k">border-image-outset</code><code class="o">:</code> <code class="m">8px</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is illustrated in <a data-type="xref" href="#Creatinganimageborderoverhang">Figure 7-58</a>, and is compared to having no outset nor border image.</p>&#13;
&#13;
<figure><div class="figure" id="Creatinganimageborderoverhang">&#13;
<img alt="css5 0758" src="assets/css5_0758.png"/>&#13;
<h6><span class="label">Figure 7-58. </span>Creating an image border overhang</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first case, the image border has been pushed out far enough that&#13;
rather than overlapping the padding area, the images actually overlap&#13;
the margin area! We can also split the difference so that the image&#13;
border is roughly centered on the border area, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code>&#13;
<code class="k">border-image-slice</code><code class="o">:</code> <code class="m">10</code><code class="p">;</code>&#13;
<code class="k">border-image-width</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
<code class="k">border-image-outset</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code>  <code class="c">/* twice the `border-width` value */</code></pre>&#13;
&#13;
<p>What you have to watch out for is pulling the image border&#13;
too far outward, to the point that it overlaps other content or gets&#13;
clipped off by the edges of the browser window (or both). If it does so, the image border will be painted between the previous element’s content and background, hiding the background, but will be partially obscured if subsequent content has a background or border.<a data-primary="" data-startref="ix_image_border_overhang" data-type="indexterm" id="idm45176098946816"/><a data-primary="" data-startref="ix_overhang_image_border" data-type="indexterm" id="idm45176098945968"/><a data-primary="" data-startref="ix_border_image_outset_prop" data-type="indexterm" id="idm45176098945120"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Altering the repeat pattern" data-type="sect3"><div class="sect3" id="altering-the-repeat-pattern">&#13;
<h3>Altering the repeat pattern</h3>&#13;
&#13;
<p>So far, you’ve <a data-primary="image borders" data-secondary="repeating" data-type="indexterm" id="ix_image_border_repeat"/><a data-primary="repeating elements" data-secondary="image borders" data-type="indexterm" id="ix_repeat_image_border"/><a data-primary="border-image-repeat property" data-type="indexterm" id="ix_border_image_repeat_prop"/>seen a lot of stretched-out images along the sides of our&#13;
examples. The stretching can be handy in some situations but a&#13;
real eyesore in others. With the physical property <code>border-image-repeat</code>, you can change the way those sides are handled.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176098963264">&#13;
<h1>border-image-repeat</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>stretch</code> | <code>repeat</code> | <code>round</code> | <code>space</code> ]{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>stretch</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements when <code>border-collapse</code> is <code>collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Two keywords, one for each axis</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As with the previous border image properties, no logical-property equivalent exists for <code>border-image-repeat</code> as of late 2022.</p>&#13;
</div>&#13;
&#13;
<p>Let’s see these values in action and then discuss each in turn. You’ve already seen <code>stretch</code>, so the effect is familiar. Each side gets a single image, stretched to match the height and width of the border side area the image is filling.</p>&#13;
&#13;
<p>The <code>repeat</code> value tiles the image until it fills up all the space in its&#13;
border side area. The exact arrangement is to center the image in its&#13;
side box, and then tile copies of the image outward from that point,&#13;
until the border side area is filled. This can lead to some of the&#13;
repeated images being clipped at the sides of the border area, as seen&#13;
in <a data-type="xref" href="#Variousimagerepeatpatterns">Figure 7-59</a>.</p>&#13;
&#13;
<figure><div class="figure" id="Variousimagerepeatpatterns">&#13;
<img alt="css5 0759" src="assets/css5_0759.png"/>&#13;
<h6><span class="label">Figure 7-59. </span>Various image-repeat patterns</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>round</code> value is a little different. With this value, the browser divides the length of the border side area by the size of the image being repeated inside it. It then rounds to the nearest whole number and repeats that number of images. In addition, it stretches or squashes the images so that they just touch each other as they repeat.</p>&#13;
&#13;
<p>As an example, suppose the top border side area is 420 pixels wide, and&#13;
the image being tiled is 50 pixels wide. Dividing 420 by 50 results in 8.4, so that’s rounded to 8. Thus, eight images are tiled. However, each is stretched to be 52.5 pixels wide (420 ÷ 8 = 52.5). Similarly, if the right border side area is 280 pixels tall, a 50-pixel-tall image will be tiled six times (280 ÷ 50 = 5.6, rounded to 6) and each image will be squashed to 46.6667 pixels tall (280 ÷ 6 = 46.6667). If you look closely at <a data-type="xref" href="#Variousimagerepeatpatterns">Figure 7-59</a>, you can see the top and bottom circles are stretched a bit, whereas the right and left circles show some squashing. The last value, <code>space</code>, starts out similar to <code>round</code>, in that the border side area’s length is divided by the size of the tiled image and then rounded. The differences are that the resulting number is always rounded <em>down</em>, and images are not distorted but instead distributed evenly throughout the border area.<a data-primary="" data-startref="ix_border_image_repeat_prop" data-type="indexterm" id="idm45176098912736"/><a data-primary="" data-startref="ix_image_border_repeat" data-type="indexterm" id="idm45176098911696"/><a data-primary="" data-startref="ix_repeat_image_border" data-type="indexterm" id="idm45176098910752"/></p>&#13;
&#13;
<p>Thus, given a top border side area 420 pixels wide and a 50-pixel-wide&#13;
image to be tiled, there will still be 8 images to repeat (8.4 rounded down is 8). The images will take up 400 pixels of space, leaving 20 pixels. That 20 pixels is divided by 8, which is 2.5 pixels. Half of that is put to each side of each image, meaning each image gets 1.25 pixels of space to either side. That puts 2.5 pixels of space between each image, and 1.25 pixels of space before the first and after the last&#13;
image (see <a data-type="xref" href="#Avarietyofspacerepetitions">Figure 7-60</a> for examples of <code>space</code> repeating).</p>&#13;
&#13;
<figure><div class="figure" id="Avarietyofspacerepetitions">&#13;
<img alt="css5 0760" src="assets/css5_0760.png"/>&#13;
<h6><span class="label">Figure 7-60. </span>A variety of space repetitions</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Shorthand border image" data-type="sect3"><div class="sect3" id="shorthand-border-image">&#13;
<h3>Shorthand border image</h3>&#13;
&#13;
<p>The single <a data-primary="border-image property" data-type="indexterm" id="idm45176098904432"/><a data-primary="image borders" data-secondary="shorthand properties" data-type="indexterm" id="idm45176098903696"/>shorthand physical property for border images is&#13;
(unsurprisingly enough) <code>border-image</code>. The way it’s written is a little unusual, but it offers a lot of power without a lot of typing.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176098902000">&#13;
<h1>border-image</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>border-image-source</code></em>&gt; ‖ &lt;<em><code>border-image-slice</code></em>&gt; <br/>[ /&#13;
&lt;<em><code>border-image-width</code></em>&gt; | / &lt;<em><code>border-image-width</code></em>&gt;? / <br/>&lt;<em><code>border-image-outset</code></em>&gt; ]? ‖ &lt;<em><code>border-image-repeat</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This <a data-primary="/ (forward slash), in value syntax" data-type="indexterm" id="idm45176098885296"/><a data-primary="forward slash (/), in value syntax" data-type="indexterm" id="idm45176098884528"/><a data-primary="slashes" data-secondary="forward slash" data-type="indexterm" id="idm45176098883856"/>property value has, it must be admitted, a somewhat unusual syntax. To get all the various properties for slices and widths and&#13;
offsets, <em>and</em> be able to tell which is which, the decision was made to&#13;
separate them by forward-slash symbols (<code>/</code>) and require them to be listed in a specific order: slice, then width, then offset. The&#13;
image source and repeat values can go anywhere&#13;
outside of that three-value chain. Therefore, the following rules are&#13;
equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.example</code> <code class="p">{</code>&#13;
    <code class="k">border-image-source</code><code class="o">:</code> <code class="sx">url(eagles.png)</code><code class="p">;</code>&#13;
    <code class="k">border-image-slice</code><code class="o">:</code> <code class="m">40%</code> <code class="m">30%</code> <code class="m">20%</code> <code class="n">fill</code><code class="p">;</code>&#13;
    <code class="k">border-image-width</code><code class="o">:</code> <code class="m">10px</code> <code class="m">7px</code><code class="p">;</code>&#13;
    <code class="k">border-image-outset</code><code class="o">:</code> <code class="m">5px</code><code class="p">;</code>&#13;
    <code class="k">border-image-repeat</code><code class="o">:</code> <code class="n">space</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nc">.example</code> <code class="p">{</code><code class="k">border-image</code><code class="o">:</code> <code class="sx">url(eagles.png)</code> <code class="m">40%</code> <code class="m">30%</code> <code class="m">20%</code> <code class="n">fill</code> <code class="o">/</code> <code class="m">10px</code> <code class="m">7px</code> <code class="o">/</code> <code class="m">5px</code> <code class="n">space</code><code class="p">;}</code>&#13;
<code class="nc">.example</code> <code class="p">{</code><code class="k">border-image</code><code class="o">:</code> <code class="sx">url(eagles.png)</code> <code class="n">space</code> <code class="m">40%</code> <code class="m">30%</code> <code class="m">20%</code> <code class="n">fill</code> <code class="o">/</code> <code class="m">10px</code> <code class="m">7px</code> <code class="o">/</code> <code class="m">5px</code><code class="p">;}</code>&#13;
<code class="nc">.example</code> <code class="p">{</code><code class="k">border-image</code><code class="o">:</code> <code class="n">space</code> <code class="m">40%</code> <code class="m">30%</code> <code class="m">20%</code> <code class="n">fill</code> <code class="o">/</code> <code class="m">10px</code> <code class="m">7px</code> <code class="o">/</code> <code class="m">5px</code> <code class="sx">url(eagles.png)</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The shorthand clearly means less typing, but also less clarity at a&#13;
glance.</p>&#13;
&#13;
<p>As is usually the case with shorthand properties, leaving out any of the&#13;
individual pieces means that the defaults will be supplied. For example,&#13;
if we supply just an image source, the rest of the properties will be set to their default values. Thus, the following two declarations will have&#13;
exactly the same effect:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border-image</code><code class="o">:</code> <code class="sx">url(orbit.svg)</code><code class="p">;</code>&#13;
<code class="k">border-image</code><code class="o">:</code> <code class="sx">url(orbit.svg)</code> <code class="n">stretch</code> <code class="m">100%</code> <code class="o">/</code> <code class="m">1</code> <code class="o">/</code> <code class="m">0</code><code class="p">;</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Some examples" data-type="sect3"><div class="sect3" id="some-examples">&#13;
<h3>Some examples</h3>&#13;
&#13;
<p>Border images can be tricky to internalize, conceptually speaking, so&#13;
it’s worth looking at some examples of ways to use them.</p>&#13;
&#13;
<p>First, let’s set up a border with scooped-out corners and&#13;
a raised appearance, like a plaque, with a fallback to a simple outset&#13;
border of similar colors. We might use something like these styles and an image, which is shown in <a data-type="xref" href="#border-ex-01">Figure 7-61</a>, along with both the final&#13;
result and the fallback result:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#plaque</code> <code class="p">{</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">outset</code> <code class="nb">goldenrod</code><code class="p">;</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="nb">goldenrod</code><code class="p">;</code>&#13;
    <code class="k">border-image-source</code><code class="o">:</code> <code class="sx">url(i/plaque.png)</code><code class="p">;</code>&#13;
    <code class="k">border-image-repeat</code><code class="o">:</code> <code class="n">stretch</code><code class="p">;</code>&#13;
    <code class="k">border-image-slice</code><code class="o">:</code> <code class="m">20</code> <code class="n">fill</code><code class="p">;</code>&#13;
    <code class="k">border-image-width</code><code class="o">:</code> <code class="m">12px</code><code class="p">;</code>&#13;
    <code class="k">border-image-outset</code><code class="o">:</code> <code class="m">9px</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="border-ex-01">&#13;
<img alt="css5 0761" src="assets/css5_0761.png"/>&#13;
<h6><span class="label">Figure 7-61. </span>A simple plaque effect and its older-browser fallback</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice that the side slices are perfectly set up to be&#13;
stretched—everything about them is just repeated strips of color along&#13;
the axis of stretching. They could also be repeated or rounded in this instance, but stretching works just fine. And since <span class="keep-together">that’s the</span> default value, we could have omitted the <code>border-image-repeat</code> declaration altogether.</p>&#13;
&#13;
<p>Next, let’s try to create something oceanic: an image border that has&#13;
waves marching all the way around. Since we don’t know how&#13;
wide or tall the element will be ahead of time, and we want the waves to&#13;
flow from one to another, we’ll use <code>round</code> to take advantage of its&#13;
scaling behavior while getting in as many waves as will reasonably fit.&#13;
You can see the result in <a data-type="xref" href="#wavy-border">Figure 7-62</a>, along with the image that’s used to&#13;
create the effect:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#oceanic</code> <code class="p">{</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="nb">blue</code><code class="p">;</code>&#13;
    <code class="k">border-image</code><code class="o">:</code>&#13;
        <code class="sx">url(waves.png)</code> <code class="m">50</code> <code class="n">fill</code> <code class="o">/</code> <code class="m">20px</code> <code class="o">/</code> <code class="m">10px</code> <code class="n">round</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="wavy-border">&#13;
<img alt="css5 0762" src="assets/css5_0762.png"/>&#13;
<h6><span class="label">Figure 7-62. </span>A wavy border</h6>&#13;
</div></figure>&#13;
&#13;
<p>You should be wary of one issue here, which is what happens if you add&#13;
in an element background. Just to make the situation clear, we’ll add a&#13;
red background to this element, with the result shown in <a data-type="xref" href="#border-ex-03">Figure 7-63</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#oceanic</code> <code class="p">{</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="nb">red</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="nb">blue</code><code class="p">;</code>&#13;
    <code class="k">border-image</code><code class="o">:</code>&#13;
        <code class="sx">url(waves.png)</code> <code class="m">50</code> <code class="n">fill</code> <code class="o">/</code> <code class="m">20px</code> <code class="o">/</code> <code class="m">10px</code> <code class="n">round</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>See how the background color is visible between the waves? That’s because the wave image is a PNG with transparent bits, and the combination of&#13;
image-slice widths and outset enable some of the background area to be visible through the transparent parts of the border. This can be a problem, because in some cases you’ll want to use a background color in&#13;
addition to an image border—for the fallback case where the image fails&#13;
to appear, if nothing else. Generally, this is a problem best addressed&#13;
by either not needing a background for the fallback case, using&#13;
<code>border-image-outset</code> to pull the image out far enough that no part of&#13;
the background area is visible, or using <code>background-clip: padding-box</code> (see <a data-type="xref" href="ch08.html#clipping-the-background">“Clipping the Background”</a>).<a data-primary="" data-startref="ix_borders_ch7" data-type="indexterm" id="idm45176098562400"/><a data-primary="" data-startref="ix_box_elem_borders_ch7" data-type="indexterm" id="idm45176098561456"/><a data-primary="" data-startref="ix_image_border_ch7" data-type="indexterm" id="idm45176098560512"/></p>&#13;
&#13;
<p>As you can see, border images have a lot of power. Be sure to use them wisely.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="border-ex-03">&#13;
<img alt="css5 0763" src="assets/css5_0763.png"/>&#13;
<h6><span class="label">Figure 7-63. </span>The background area, visible through the image border</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Outlines" data-type="sect1"><div class="sect1" id="outlines">&#13;
<h1>Outlines</h1>&#13;
&#13;
<p>CSS defines a special sort of <a data-primary="outlines" data-type="indexterm" id="ix_outline_ch7"/><a data-primary="visual formatting" data-secondary="outlines" data-type="indexterm" id="ix_vis_format_outline"/><a data-primary="boxes" data-secondary="element boxes" data-tertiary="outlines" data-type="indexterm" id="ix_box_elem_outline"/>element decoration called an <em>outline</em>. In&#13;
practice, outlines are often drawn just beyond the borders, though (as you’ll see) this is not the whole story. As the specification puts it, outlines differ from borders in three basic ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Outlines are visible but do not take up layout space.</p>&#13;
</li>&#13;
<li>&#13;
<p>User agents often render outlines on elements in the <code>:focus</code> state, precisely because they do not take up layout space and so do not change the layout.</p>&#13;
</li>&#13;
<li>&#13;
<p>Outlines may be nonrectangular.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To these, we’ll add a fourth:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Outlines are an all-or-nothing proposition: you can’t style one side&#13;
of a border independently from the others.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s start finding out exactly what all that means. First, we’ll run&#13;
through the various properties, comparing them to their border-related&#13;
counterparts.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Outline Styles" data-type="sect2"><div class="sect2" id="outline-styles">&#13;
<h2>Outline Styles</h2>&#13;
&#13;
<p>Much as <a data-primary="outline-style property" data-type="indexterm" id="ix_outline_style_prop"/><a data-primary="outlines" data-secondary="styles for" data-type="indexterm" id="ix_outline_styles"/>with <code>border-style</code>, you can set a style for your outlines. In&#13;
fact, the values will seem familiar to anyone who’s styled a border&#13;
before.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176098514304">&#13;
<h1>outline-style</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>auto</code> | <code>none</code> | <code>solid</code> | <code>dotted</code> | <code>dashed</code> | <code>double</code>&#13;
| <code>groove</code> | <code>ridge</code> | <code>inset</code> | <code>outset</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The two major differences are that outlines cannot have a <code>hidden</code>&#13;
style, as borders can; and outlines can have the <code>auto</code> style. This style&#13;
allows the user agent to get extra-fancy with the appearance of the&#13;
outline, as explained in the CSS specification:</p>&#13;
<blockquote>&#13;
<p>The <code>auto</code> value permits the user agent to render a custom outline&#13;
style, typically a style which is either a user interface default for&#13;
the platform, or perhaps a style that is richer than can be described in&#13;
detail in CSS—e.g., a rounded edge outline with semitranslucent outer&#13;
pixels that appears to glow.</p></blockquote>&#13;
&#13;
<p>It’s also the case that <code>auto</code> allows browsers to use different outlines&#13;
for different elements; e.g., the outline for a hyperlink may not be&#13;
the same as the outline for a form input. When using <code>auto</code>, the value for <code>outline-width</code> may be ignored.</p>&#13;
&#13;
<p>Beyond those differences, outlines have all the same styles that&#13;
borders have, as illustrated in <a data-type="xref" href="#Variousoutlinestyles">Figure 7-64</a>.</p>&#13;
&#13;
<p>The less obvious difference is that unlike <code>border-style</code>,&#13;
<code>outline-style</code> is <em>not</em> a shorthand property. <a data-primary="logical properties" data-secondary="outlines" data-type="indexterm" id="idm45176098489792"/>You can’t use it to set a&#13;
different outline style for each side of the outline, because outlines&#13;
can’t be styled that way. There is no <code>outline-top-style</code>. This is true for all the rest of the outline properties.&#13;
Because of this aspect of <code>outline-style</code>, the one property serves both physical and logical layout needs.</p>&#13;
&#13;
<figure><div class="figure" id="Variousoutlinestyles">&#13;
<img alt="css5 0764" src="assets/css5_0764.png"/>&#13;
<h6><span class="label">Figure 7-64. </span>Various outline styles</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Outline Width" data-type="sect2"><div class="sect2" id="outline-width">&#13;
<h2>Outline Width</h2>&#13;
&#13;
<p>Once you’ve <a data-primary="outlines" data-secondary="width of" data-type="indexterm" id="idm45176098484240"/><a data-primary="outline-width property" data-type="indexterm" id="idm45176098483232"/>decided on a style for the outline, assuming the style isn’t&#13;
<code>none</code>, you can define a width for the outline.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176098481856">&#13;
<h1>outline-width</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | <code>thin</code> | <code>medium</code> | <code>thick</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>medium</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>An absolute length, or <code>0</code> if the style of the&#13;
outline is <code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>There’s little to say about outline width that we didn’t already&#13;
say about border width. If the outline style is <code>none</code>, the&#13;
outline’s width is set to <code>0</code>. The <code>thick</code> value is wider than <code>medium</code>, which is wider than <code>thin</code>, but the specification doesn’t define exact widths for these keywords. <a data-type="xref" href="#Variousoutlinewidths">Figure 7-65</a> shows a few outline widths.</p>&#13;
&#13;
<figure><div class="figure" id="Variousoutlinewidths">&#13;
<img alt="css5 0765" src="assets/css5_0765.png"/>&#13;
<h6><span class="label">Figure 7-65. </span>Various outline widths</h6>&#13;
</div></figure>&#13;
&#13;
<p>As before, the real <a data-primary="logical properties" data-secondary="outlines" data-type="indexterm" id="idm45176098460832"/>difference here is that <code>outline-width</code> is not a&#13;
shorthand property, and serves both physical and logical layout needs.&#13;
You can set only one width for the whole outline, and cannot set different widths for different sides. (The reasons for this&#13;
will soon become clear.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Outline Color" data-type="sect2"><div class="sect2" id="outline-color">&#13;
<h2>Outline Color</h2>&#13;
&#13;
<p>Does your <a data-primary="outline-color property" data-type="indexterm" id="idm45176098457408"/><a data-primary="outlines" data-secondary="colors" data-type="indexterm" id="idm45176098456672"/><a data-primary="colors" data-secondary="outlines" data-type="indexterm" id="idm45176098455728"/>outline have a style and a width? Great! Let’s give it some&#13;
color!</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176098454528">&#13;
<h1>outline-color</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>color</code></em>&gt; | <code>invert</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>invert</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This is pretty much the same as <code>border-color</code>, with the caveat that&#13;
it’s an all-or-nothing proposition—for example, there’s no&#13;
<code>outline-left-color</code>.</p>&#13;
&#13;
<p>The one <a data-primary="invert keyword" data-type="indexterm" id="idm45176098439424"/>major difference is the default value, <code>invert</code>. What <code>invert</code>&#13;
is supposed to do is perform a “color conversion” on all pixels within the visible&#13;
parts of the outline.  The advantage to color inversion is that it can make the outline stand&#13;
out in a wide variety of situations, regardless of what’s behind it.</p>&#13;
&#13;
<p>However, as of late 2022, literally no browser engines support <code>invert</code>.  (Some did for a while, but that support was removed.)  Given this, if you use <code>invert</code>, it will be rejected by the browser, and the color keyword <code>currentcolor</code> will be used instead. (See <a data-type="xref" href="ch05.html#color_keywords">“Color Keywords”</a> for details.)</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The only outline shorthand" data-type="sect3"><div class="sect3" id="the-only-outline-shorthand">&#13;
<h3>The only outline shorthand</h3>&#13;
&#13;
<p>So far, you’ve seen three <a data-primary="outline property" data-type="indexterm" id="idm45176098433392"/><a data-primary="outlines" data-secondary="shorthand property" data-type="indexterm" id="idm45176098432688"/>outline properties that look like shorthand&#13;
properties but aren’t. It’s time for the one outline property that <em>is</em> a&#13;
shorthand: <code>outline</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176098430528">&#13;
<h1>outline</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>outline-color</code></em>&gt; ‖ &lt;<em><code>outline-style</code></em>&gt; ‖ &lt;<em><code>outline-width</code></em>&gt; ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>It probably <a data-primary="outlines" data-secondary="versus borders" data-secondary-sortas="borders" data-type="indexterm" id="idm45176098415920"/><a data-primary="borders" data-secondary="versus outlines" data-secondary-sortas="outlines" data-type="indexterm" id="ix_border_vs_outline"/>comes as little surprise that, like <code>border</code>, this is a&#13;
convenient way to set the overall style, width, and color of an outline.&#13;
<a data-type="xref" href="#Variousoutlines">Figure 7-66</a> illustrates a variety of outlines.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="Variousoutlines">&#13;
<img alt="css5 0766" src="assets/css5_0766.png"/>&#13;
<h6><span class="label">Figure 7-66. </span>Various outlines</h6>&#13;
</div></figure>&#13;
&#13;
<p>Thus far, outlines seem very much like borders. So how are they different?</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How They Are Different" data-type="sect2"><div class="sect2" id="how-they-are-different">&#13;
<h2>How They Are Different</h2>&#13;
&#13;
<p>The first major difference between borders and outlines is that outlines, like outset border images, don’t affect layout at all. In any way. They’re purely presentational.</p>&#13;
&#13;
<p>To understand what this means, consider the following styles,&#13;
illustrated in <a data-type="xref" href="#Outlineovermargin">Figure 7-67</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">10px</code> <code class="nb">solid</code> <code class="nb">green</code><code class="p">;</code>&#13;
    <code class="k">outline</code><code class="o">:</code> <code class="m">10px</code> <code class="nb">dashed</code> <code class="m">#9AB</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">10px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Outlineovermargin">&#13;
<img alt="css5 0767" src="assets/css5_0767.png"/>&#13;
<h6><span class="label">Figure 7-67. </span>Outline over margin</h6>&#13;
</div></figure>&#13;
&#13;
<p>Looks normal, right? What you can’t see is that the outline is&#13;
completely covering up the margin. If we put in a dotted line to show&#13;
the margin edges, they’d run right along the outside edge of the&#13;
outline. (We’ll deal with margins in the next section.)</p>&#13;
&#13;
<p>This is what’s meant by outlines not affecting layout. Let’s consider&#13;
another example, this time with two <code>&lt;span&gt;</code> elements that are given&#13;
outlines. You can see the results in <a data-type="xref" href="#Overlappingoutlines">Figure 7-68</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">span</code> <code class="p">{</code><code class="k">outline</code><code class="o">:</code> <code class="m">1em</code> <code class="nb">solid</code> <code class="n">rgba</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="m">128</code><code class="o">,</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">);}</code>&#13;
<code class="nt">span</code> <code class="o">+</code> <code class="nt">span</code> <code class="p">{</code><code class="k">outline</code><code class="o">:</code> <code class="m">0.5em</code> <code class="nb">double</code> <code class="nb">purple</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Overlappingoutlines">&#13;
<img alt="css5 0768" src="assets/css5_0768.png"/>&#13;
<h6><span class="label">Figure 7-68. </span>Overlapping outlines</h6>&#13;
</div></figure>&#13;
&#13;
<p>The outlines don’t affect the height of the lines, but they&#13;
also don’t shove the <code>&lt;span&gt;</code>s to one side or another. The text is laid&#13;
out as if the outlines aren’t even there.</p>&#13;
&#13;
<p>This raises an even more interesting feature of outlines: they are not always rectangular, nor are they always contiguous. Consider this outline applied to a <code>&lt;strong&gt;</code> element that breaks across two lines, as illustrated in two scenarios in <a data-type="xref" href="#Discontinuousandnon-rectangularoutlines">Figure 7-69</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">outline</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">dotted</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Discontinuousandnon-rectangularoutlines">&#13;
<img alt="css5 0769" src="assets/css5_0769.png"/>&#13;
<h6><span class="label">Figure 7-69. </span>Discontinuous and nonrectangular outlines</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first case has two complete outline boxes, one for each&#13;
fragment of the <code>&lt;strong&gt;</code> element. In the second case, with the longer&#13;
<code>&lt;strong&gt;</code> element causing the two fragments to be stacked together, the&#13;
outline is “fused” into a single polygon that encloses the fragments.&#13;
You won’t find a border doing <em>that</em>.</p>&#13;
&#13;
<p>This is why CSS has no side-specific outline properties like&#13;
<code>outline-right-style</code>: if an outline becomes nonrectangular, which&#13;
sides are the right sides?</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of late 2022, not every browser combines the inline fragments&#13;
into a single contiguous polygon. In those that do not support this&#13;
behavior, each fragment is still a self-contained rectangle, as in the&#13;
first example in <a data-type="xref" href="#Discontinuousandnon-rectangularoutlines">Figure 7-69</a>. <a data-primary="border-radius property" data-type="indexterm" id="idm45176098272864"/>Also, Firefox and Chrome have outlines follow <code>border-radius</code> rounding, whereas Safari keeps the corners rectangular.<a data-primary="" data-startref="ix_box_elem_outline" data-type="indexterm" id="idm45176098271648"/><a data-primary="" data-startref="ix_outline_ch7" data-type="indexterm" id="idm45176098270672"/><a data-primary="" data-startref="ix_vis_format_outline" data-type="indexterm" id="idm45176098251312"/><a data-primary="" data-startref="ix_border_vs_outline" data-type="indexterm" id="idm45176098250464"/><a data-primary="" data-startref="ix_outline_vs_border" data-type="indexterm" id="idm45176098249616"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Margins" data-type="sect1"><div class="sect1" id="margins">&#13;
<h1>Margins</h1>&#13;
&#13;
<p>The <a data-primary="margins" data-type="indexterm" id="ix_margins_ch7"/><a data-primary="boxes" data-secondary="element boxes" data-tertiary="margins" data-type="indexterm" id="ix_box_elem_margin"/><a data-primary="spacing" data-secondary="margins and blank space" data-type="indexterm" id="idm45176098244512"/>separation between most normal-flow elements occurs because of&#13;
element <em>margins</em>. Setting a margin creates extra blank space around&#13;
an element. <em>Blank space</em> generally refers to an area in which other&#13;
elements cannot also exist and in which the parent element’s background&#13;
is visible. <a data-type="xref" href="#Paragraphswithandwithoutmargins">Figure 7-70</a> shows the difference between two paragraphs without any margins and the same two paragraphs with margins.</p>&#13;
&#13;
<figure><div class="figure" id="Paragraphswithandwithoutmargins">&#13;
<img alt="css5 0770" src="assets/css5_0770.png"/>&#13;
<h6><span class="label">Figure 7-70. </span>Paragraphs with, and without, margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>The simplest way to set a <a data-primary="margin property" data-type="indexterm" id="ix_margin_prop"/>margin is by using the physical property <code>margin</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176098237808">&#13;
<h1>margin</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | <code>auto</code> ]{1,4}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>Not defined</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the width of the containing block</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>The effects of <code>auto</code> margins are not discussed here; see <a data-type="xref" href="ch11.html#auto">“Automatic flex basis”</a> for a full explanation</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Suppose you want to set a quarter-inch margin on <code>&lt;h1&gt;</code> elements (a background color has been added so you can clearly see the edges of the content area):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0.25in</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This sets a quarter-inch of blank space on each side of an <code>&lt;h1&gt;</code> element, as illustrated in <a data-type="xref" href="#Settingamarginforh1elements">Figure 7-71</a>. Here, dashed lines represent the margin’s outer edge, but the lines are purely illustrative and would not actually appear in a web browser.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Settingamarginforh1elements">&#13;
<img alt="css5 0771" src="assets/css5_0771.png"/>&#13;
<h6><span class="label">Figure 7-71. </span>Setting a margin for <code>&lt;h1&gt;</code> elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>margin</code> property can accept any length of measure, whether in pixels, inches, millimeters, or ems. However, the default value for <code>margin</code> is effectively <code>0</code>, so if you don’t declare a value, by default, no margin should appear.</p>&#13;
&#13;
<p>In practice, however, browsers come with preassigned styles for many&#13;
elements, and margins are no exception. For example, in CSS-enabled&#13;
browsers, margins generate the “blank line” above and below each&#13;
paragraph element. Therefore, if you don’t declare margins for the <code>&lt;p&gt;</code>&#13;
element, the browser may apply some margins on its own. Whatever you&#13;
declare will override the default styles.</p>&#13;
&#13;
<p>Finally, it’s possible to set a percentage value for <code>margin</code>. The&#13;
details of this value type are discussed in <a data-type="xref" href="#percentages-and-margins">“Percentages and Margins”</a>.<a data-primary="" data-startref="ix_margin_prop" data-type="indexterm" id="idm45176098189568"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Length Values and Margins" data-type="sect2"><div class="sect2" id="length-values-and-margins">&#13;
<h2>Length Values and Margins</h2>&#13;
&#13;
<p>Any <a data-primary="margins" data-secondary="length values" data-type="indexterm" id="idm45176098186560"/>length value can be used in setting the margins of&#13;
an element. It’s easy enough, for example, to apply 10 pixels of whitespace around paragraph elements. The following rule gives&#13;
paragraphs a silver background, 10 pixels of padding, and a 10-pixel&#13;
margin:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">background-color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">10px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This adds 10 pixels of space to each side of every paragraph, just beyond the outer border edge. You can just as easily use <code>margin</code> to set extra space around an image. Let’s say you want 1 em of space surrounding all images:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That’s all it takes.</p>&#13;
&#13;
<p>At times, you might desire a different amount of space on each side of&#13;
an element. That’s easy as well, thanks to the value replication&#13;
behavior we’ve used before. If you want all <code>&lt;h1&gt;</code> elements to have a top&#13;
margin of 10 pixels, a right margin of 20 pixels, a bottom margin of 15&#13;
pixels, and a left margin of 5 pixels, here’s all you need:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">10px</code> <code class="m">20px</code> <code class="m">15px</code> <code class="m">5px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>It’s also possible to mix up the types of length values you use. You&#13;
aren’t restricted to using a single length type in a given rule, as&#13;
shown here:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">14px</code> <code class="m">5em</code> <code class="m">0.1in</code> <code class="m">3ex</code><code class="p">;}</code> <code class="c">/* value variety! */</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#Mixed-valuemargins">Figure 7-72</a> shows, with a little extra annotation, the results of this&#13;
declaration.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Mixed-valuemargins">&#13;
<img alt="css5 0772" src="assets/css5_0772.png"/>&#13;
<h6><span class="label">Figure 7-72. </span>Mixed-value margins</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Percentages and Margins" data-type="sect2"><div class="sect2" id="percentages-and-margins">&#13;
<h2>Percentages and Margins</h2>&#13;
&#13;
<p>We can set <a data-primary="margins" data-secondary="percentage values" data-type="indexterm" id="idm45176098071888"/>percentage values for the&#13;
margins of an element. As with padding, percentage margin values are&#13;
computed in relation to the width of the parent element’s content area,&#13;
so they can change if the parent element’s width changes in some way.&#13;
For example, assume the following, which is illustrated in <a data-type="xref" href="#Parentwidthsandpercentages">Figure 7-73</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">10%</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code> <code class="na">style</code><code class="o">=</code><code class="s">"width: 200px; border: 1px dotted;"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
        This paragraph is contained within a DIV that has a width of 200 pixels,&#13;
        so its margin will be 10% of the width of the paragraph's parent (the&#13;
        DIV). Given the declared width of 200 pixels, the margin will be 20&#13;
        pixels on all sides.&#13;
    <code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">div</code> <code class="na">style</code><code class="o">=</code><code class="s">"width: 100px; border: 1px dotted;"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
        This paragraph is contained within a DIV with a width of 100 pixels,&#13;
        so its margin will still be 10% of the width of the paragraph's&#13;
        parent. There will, therefore, be half as much margin on this paragraph&#13;
        as on the first paragraph.&#13;
    <code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<figure><div class="figure" id="Parentwidthsandpercentages">&#13;
<img alt="css5 0773" src="assets/css5_0773.png"/>&#13;
<h6><span class="label">Figure 7-73. </span>Parent widths and percentages</h6>&#13;
</div></figure>&#13;
&#13;
<p>Note that the top and bottom margins are consistent with the right and&#13;
left margins; in other words, the percentage of top and bottom margins&#13;
is calculated with respect to the element’s width, not its height. You’ve&#13;
seen this before—in <a data-type="xref" href="#padding">“Padding”</a>, in case you don’t remember—but&#13;
it’s worth reviewing again, just to see how it operates.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Single-Side Margin Properties" data-type="sect2"><div class="sect2" id="single-side-margin-properties">&#13;
<h2>Single-Side Margin Properties</h2>&#13;
&#13;
<p>As you’ve seen throughout the chapter, CSS has <a data-primary="margins" data-secondary="single-side properties" data-type="indexterm" id="idm45176097982480"/><a data-primary="single-side margins" data-type="indexterm" id="idm45176097981504"/><a data-primary="margin-block-end property" data-type="indexterm" id="idm45176097980832"/><a data-primary="margin-block-start property" data-type="indexterm" id="idm45176097980192"/><a data-primary="margin-bottom property" data-type="indexterm" id="idm45176097979504"/><a data-primary="margin-inline-end property" data-type="indexterm" id="idm45176097978832"/><a data-primary="margin-inline-start property" data-type="indexterm" id="idm45176097978144"/><a data-primary="margin-left property" data-type="indexterm" id="idm45176097977456"/><a data-primary="margin-right property" data-type="indexterm" id="idm45176097976784"/><a data-primary="margin-top property" data-type="indexterm" id="idm45176097976112"/>properties that let you set the margin on a&#13;
single side of the box, without affecting the others.  There are four physical side properties, four logical side properties, and two logical shorthand properties.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176097975312">&#13;
<h1>margin-top, margin-right, margin-bottom, margin-left, <span class="keep-together">margin-block-start, margin-block-end,</span> <span class="keep-together">margin-inline-start, margin-inline-end</span></h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the width of the containing block</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For percentages, as specified; otherwise, the&#13;
absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176097933568">&#13;
<h1>margin-block, margin-inline</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | <code>auto</code> ]{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the width of the containing block</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For percentages, as specified; otherwise, the&#13;
absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>These <a data-primary="margin-inline property" data-type="indexterm" id="idm45176097917552"/><a data-primary="margin-block property" data-type="indexterm" id="idm45176097916816"/>properties operate as you’d expect. For example, the following two&#13;
rules will give the same amount of margin:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="m">0</code> <code class="m">0.25in</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">margin-left</code><code class="o">:</code> <code class="m">0.25in</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Similarly, the following two rules will have the same outcome:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code>&#13;
     <code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">0.25in</code><code class="p">;</code>&#13;
     <code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code>&#13;
     <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
     <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">:</code> <code class="m">0.25in</code> <code class="m">0.5em</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Margin Collapsing" data-type="sect2"><div class="sect2" id="margin-collapsing">&#13;
<h2>Margin Collapsing</h2>&#13;
&#13;
<p>An <a data-primary="margins" data-secondary="collapsing" data-type="indexterm" id="ix_margin_collapse2"/><a data-primary="vertical formatting" data-secondary="collapsing margins" data-type="indexterm" id="ix_vert_format_collapse_margin2"/><a data-primary="collapsing margins" data-type="indexterm" id="ix_collapse_margin2"/>interesting and often overlooked aspect of the block-start and block-end margins&#13;
on block boxes is that they <em>collapse</em> in normal-flow layout. This is the process by which two&#13;
(or more) margins that interact along the block axis will collapse to the largest of the&#13;
interacting margins.</p>&#13;
&#13;
<p>The canonical example of this is the space between paragraphs.&#13;
Generally, that space is set using a rule like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">1em</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That sets every paragraph to have block-start and -end margins of <code>1em</code>. If&#13;
margins <em>didn’t</em> collapse, then whenever one paragraph followed another,&#13;
there would be 2 ems of space between them. Instead, there’s only 1; the two margins collapse together.</p>&#13;
&#13;
<p>To illustrate this a little more clearly, let’s return to the&#13;
percentage-margin example. This time, we’ll add dashed lines to&#13;
indicate where the margins fall, as shown in <a data-type="xref" href="#Collapsingmargins">Figure 7-74</a>.</p>&#13;
&#13;
<figure><div class="figure" id="Collapsingmargins">&#13;
<img alt="css5 0774" src="assets/css5_0774.png"/>&#13;
<h6><span class="label">Figure 7-74. </span>Collapsing margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>The example shows the separation distance between the&#13;
contents of the two paragraphs. It’s 60 pixels, because that’s the&#13;
wider of the two margins that are interacting. The 30-pixel block-start margin&#13;
of the second paragraph is collapsed, leaving the first paragraph’s block-end&#13;
margin in charge.</p>&#13;
&#13;
<p>So in a sense, <a data-type="xref" href="#Collapsingmargins">Figure 7-74</a> is lying: if you take the CSS specification&#13;
strictly at its word, the block-start (top) margin of the second paragraph is actually&#13;
reset to 0. It doesn’t stick into the block-end margin of the first&#13;
paragraph because once it collapses, it isn’t there anymore. The end&#13;
result is the same, though.</p>&#13;
&#13;
<p>Margin collapsing also explains some oddities that arise when one element&#13;
is inside another. Consider the following styles and markup:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">goldenrod</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">header</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">h1</code><code class="o">&gt;</code><code class="nt">Welcome</code> <code class="nt">to</code> <code class="nt">ConHugeCo</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;/</code><code class="nt">header</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>The margin on the <code>&lt;h1&gt;</code> will push the edges of the <code>header</code> away from the&#13;
content of the <code>&lt;h1&gt;</code>, right? Well, not entirely. See <a data-type="xref" href="#Marginscollapsingwithparents">Figure 7-75</a>.</p>&#13;
&#13;
<p>What happened? The inline-side margins took effect—we can see that from the&#13;
way the text is moved over—but the block-start and block-end margins are gone!</p>&#13;
&#13;
<p>Only they aren’t gone. They’re just sticking out of the <code>header</code>&#13;
element, having interacted with the (zero-width) block-start margin of the&#13;
<code>header</code> element. The magic of dashed lines in <a data-type="xref" href="#Marginscollapsingwithparentsrevealed">Figure 7-76</a> shows us what’s&#13;
happening.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Marginscollapsingwithparents">&#13;
<img alt="css5 0775" src="assets/css5_0775.png"/>&#13;
<h6><span class="label">Figure 7-75. </span>Margins collapsing with parents</h6>&#13;
</div></figure>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="Marginscollapsingwithparentsrevealed">&#13;
<img alt="css5 0776" src="assets/css5_0776.png"/>&#13;
<h6><span class="label">Figure 7-76. </span>Margins collapsing with parents, revealed</h6>&#13;
</div></figure>&#13;
&#13;
<p>There the block-axis margins are—pushing away any content that might come before or after&#13;
the <code>&lt;header&gt;</code> element, but not pushing away the edges of the <code>&lt;header&gt;</code>&#13;
itself. This is the intended result, even if it’s often not the <em>desired</em>&#13;
result. As for <em>why</em> it’s intended, imagine what happens if you put a&#13;
paragraph in a list item. Without the specified margin-collapsing&#13;
behavior, the paragraph’s block-start (in this case, the top) margin would shove it downward, where it&#13;
would be far out of alignment with the list item’s bullet &#13;
<span class="keep-together">(or number).</span></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Margin collapsing can be interrupted by factors such as padding&#13;
and borders on parent elements. For more details, see the discussion in <a data-type="xref" href="ch06.html#collapsing-block-axis-margins">“Collapsing Block-Axis Margins”</a>.<a data-primary="" data-startref="ix_collapse_margin2" data-type="indexterm" id="idm45176097706896"/><a data-primary="" data-startref="ix_margin_collapse2" data-type="indexterm" id="idm45176097705920"/><a data-primary="" data-startref="ix_vert_format_collapse_margin2" data-type="indexterm" id="idm45176097704976"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Negative Margins" data-type="sect2"><div class="sect2" id="pbom_negative-margins">&#13;
<h2>Negative Margins</h2>&#13;
&#13;
<p>It’s possible to set <a data-primary="negative margins" data-type="indexterm" id="ix_neg_margin3"/><a data-primary="margins" data-secondary="negative" data-type="indexterm" id="ix_margin_neg3"/>negative margins for an element. This can cause the&#13;
element’s box to stick out of its parent or to overlap other elements.&#13;
Consider these rules, which are illustrated in <a data-type="xref" href="#Negativemarginsinaction">Figure 7-77</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">dashed</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.one</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0</code> <code class="m">-1em</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.two</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">-1em</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Negativemarginsinaction">&#13;
<img alt="css5 0777" src="assets/css5_0777.png"/>&#13;
<h6><span class="label">Figure 7-77. </span>Negative margins in action</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first case, the math works out such that the paragraph’s computed&#13;
width plus its inline-start and inline-end margins are exactly equal to the width of&#13;
the parent <code>&lt;div&gt;</code>. So the paragraph ends up 2 ems wider than the&#13;
parent element.</p>&#13;
&#13;
<p>In the second case, the negative block-start and block-end margins&#13;
move the paragraph’s block-start&#13;
and -end outer edges inward, which is how it ends up overlapping the&#13;
paragraphs before and after it.</p>&#13;
&#13;
<p>Combining negative and positive margins is actually very useful. For&#13;
example, you can make a paragraph “punch out” of a parent element by&#13;
being creative with positive and negative margins, or you can create a&#13;
Mondrian effect with several overlapping or randomly placed boxes, as&#13;
shown in <a data-type="xref" href="#Punchingoutofaparent">Figure 7-78</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="n">hsl</code><code class="p">(</code><code class="m">42</code><code class="o">,</code><code class="m">80%</code><code class="o">,</code><code class="m">80%</code><code class="p">);</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.punch</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">1em</code> <code class="m">-1px</code> <code class="m">1em</code> <code class="m">25%</code><code class="p">;</code>&#13;
  <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">border-right</code><code class="o">:</code> <code class="nb">none</code><code class="p">;</code> <code class="k">text-align</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.mond</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="n">rgba</code><code class="p">(</code><code class="m">5</code><code class="o">,</code><code class="m">5</code><code class="o">,</code><code class="m">5</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">);</code> <code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">1em</code> <code class="m">3em</code> <code class="m">-3em</code> <code class="m">-3em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Thanks to the negative bottom margin for the <code>mond</code> paragraph, the&#13;
bottom of its parent element is pulled upward, allowing the paragraph to&#13;
stick out of the bottom of its parent.<a data-primary="" data-startref="ix_margin_neg3" data-type="indexterm" id="idm45176097588912"/><a data-primary="" data-startref="ix_neg_margin3" data-type="indexterm" id="idm45176097473504"/></p>&#13;
&#13;
<figure><div class="figure" id="Punchingoutofaparent">&#13;
<img alt="css5 0778" src="assets/css5_0778.png"/>&#13;
<h6><span class="label">Figure 7-78. </span>Punching out of a parent</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Margins and Inline Elements" data-type="sect2"><div class="sect2" id="margins-and-inline-elements">&#13;
<h2>Margins and Inline Elements</h2>&#13;
&#13;
<p>Margins can also be applied to <a data-primary="inline formatting" data-secondary="margins" data-type="indexterm" id="ix_inline_format_margins"/><a data-primary="margins" data-secondary="inline elements" data-type="indexterm" id="ix_margins_inline_format"/>inline elements. Let’s say you want to&#13;
set block-start and block-end margins on strongly emphasized text:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">25px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">50px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This is allowed in the specification, but on an inline nonreplaced element, they will have absolutely no effect on the line height (the same as for padding and borders). And since margins are always transparent, you won’t even be able to see that they’re there. In&#13;
effect, they’ll have no effect at all.</p>&#13;
&#13;
<p>As with padding, the layout effects change a bit when you apply margins to the inline-start and inline-end sides of an inline nonreplaced element, as illustrated in&#13;
<a data-type="xref" href="#Aninlinenonreplacedelementwithaleftmargin">Figure 7-79</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">25px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Aninlinenonreplacedelementwithaleftmargin">&#13;
<img alt="css5 0779" src="assets/css5_0779.png"/>&#13;
<h6><span class="label">Figure 7-79. </span>An inline nonreplaced element with an inline-start margin</h6>&#13;
</div></figure>&#13;
&#13;
<p>Note the extra space between the end of the word just before the inline&#13;
nonreplaced element and the edge of the inline element’s background. You&#13;
can add that extra space to both ends of the inline element if you want:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">25px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As expected, <a data-type="xref" href="#Aninlinenonreplacedelementwith25-pixelsidemargins">Figure 7-80</a> shows a little extra space on the inline-start and -end&#13;
sides of the inline element, and no extra space above or below it.</p>&#13;
&#13;
<figure><div class="figure" id="Aninlinenonreplacedelementwith25-pixelsidemargins">&#13;
<img alt="css5 0780" src="assets/css5_0780.png"/>&#13;
<h6><span class="label">Figure 7-80. </span>An inline nonreplaced element with 25-pixel side margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, when an inline nonreplaced element stretches across multiple lines,&#13;
the situation changes. <a data-type="xref" href="#Aninlinenonreplacedelementwith25-pixelsidemargindisplayedacrosstwolinesoftext">Figure 7-81</a> shows what happens when an inline&#13;
nonreplaced element with a margin is displayed across multiple lines:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">25px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Aninlinenonreplacedelementwith25-pixelsidemargindisplayedacrosstwolinesoftext">&#13;
<img alt="css5 0781" src="assets/css5_0781.png"/>&#13;
<h6><span class="label">Figure 7-81. </span>An inline nonreplaced element with 25-pixel side margin displayed across two lines of text</h6>&#13;
</div></figure>&#13;
&#13;
<p>The inline-start margin is applied to the beginning of the element, and the inline-end&#13;
margin to the end of it. Margins are <em>not</em> applied to the inline-start and -end&#13;
side of each line fragment. Also, you can see that, if not for the&#13;
margins, the line may have broken a word or two sooner.&#13;
Margins affect line breaking only by changing the&#13;
point at which the element’s content begins within a line.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You can alter the way margins are (or aren’t) applied to the ends of each line box by using the property <code>box-decoration-break</code>.  See <a data-type="xref" href="ch06.html#basic-visual-formatting">Chapter 6</a> for more details.</p>&#13;
</div>&#13;
&#13;
<p>The situation gets even more interesting when we apply negative margins&#13;
to inline nonreplaced elements. The block-start and block-end of the element aren’t&#13;
affected, and neither are the heights of lines, but the inline-start and inline-end&#13;
sides of the element can overlap other content, as depicted in <a data-type="xref" href="#Aninlinenonreplacedelementwithanegativemargin">Figure 7-82</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">-25px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="Aninlinenonreplacedelementwithanegativemargin">&#13;
<img alt="css5 0782" src="assets/css5_0782.png"/>&#13;
<h6><span class="label">Figure 7-82. </span>An inline nonreplaced element with a negative margin</h6>&#13;
</div></figure>&#13;
&#13;
<p>Replaced inline <a data-primary="replaced elements" data-secondary="margins" data-type="indexterm" id="idm45176097316464"/>elements represent yet another story: margins set for&#13;
them <em>do</em> affect the height of a line, either increasing or reducing it,&#13;
depending on the value for the block-start and block-end margin.<a data-primary="" data-startref="ix_box_elem_margin" data-type="indexterm" id="idm45176097295552"/><a data-primary="" data-startref="ix_margins_ch7" data-type="indexterm" id="idm45176097294576"/><a data-primary="" data-startref="ix_inline_format_margins" data-type="indexterm" id="idm45176097293632"/><a data-primary="" data-startref="ix_margins_inline_format" data-type="indexterm" id="idm45176097292720"/> The inline-side&#13;
margins of an inline replaced element act the same as for a nonreplaced&#13;
element. <a data-type="xref" href="#Inlinereplacedelementswithdifferingmarginvalues">Figure 7-83</a> shows a series of effects on layout from&#13;
margins set on inline replaced elements.</p>&#13;
&#13;
<figure><div class="figure" id="Inlinereplacedelementswithdifferingmarginvalues">&#13;
<img alt="css5 0783" src="assets/css5_0783.png"/>&#13;
<h6><span class="label">Figure 7-83. </span>Inline replaced elements with differing margin values</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="pbom_summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>The ability to apply margins, borders, and padding to any element allows you to manage the separation and appearance of elements in a detailed way. Understanding how they interact with each other is the foundation of design for the web.</p>&#13;
</div></section>&#13;
</div></section></body></html>