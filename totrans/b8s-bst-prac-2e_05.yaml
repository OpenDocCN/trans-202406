- en: Chapter 5\. Continuous Integration, Testing, and Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。持续集成、测试和部署
- en: In this chapter, we look at the key concepts of how to integrate a continuous
    integration/continuous deployment (CI/CD) pipeline to deliver your applications
    to Kubernetes. Building a well-integrated pipeline will enable you to deliver
    applications to production with confidence, so here we look at the methods, tools,
    and processes to enable CI/CD in your environment. The goal of CI/CD is to have
    a fully automated process, from a developer checking in code to rolling out the
    new code to production. You want to avoid manually rolling out updates to your
    apps deployed to Kubernetes because it can be very error prone. Manually managing
    application updates in Kubernetes leads to configuration drift and fragile deployment
    updates, and overall agility delivering an application is lost.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将看看如何将持续集成/持续部署（CI/CD）流水线集成到 Kubernetes 中以交付应用程序的关键概念。构建一个良好集成的流水线将使您能够自信地将应用程序交付到生产环境，因此在这里我们将探讨在您的环境中实现
    CI/CD 所需的方法、工具和流程。CI/CD 的目标是实现全自动化的流程，从开发者提交代码到将新代码推送到生产环境中去。您希望避免在部署到 Kubernetes
    的应用程序中手动进行更新，因为这样很容易出错。在 Kubernetes 中手动管理应用程序更新会导致配置漂移和脆弱的部署更新，整体而言会失去交付应用程序的灵活性。
- en: 'We cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Version control
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Continuous integration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Container builds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器构建
- en: Container image tagging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像标记
- en: Continuous deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续部署
- en: Deployment strategies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署策略
- en: Testing in production
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中进行测试
- en: Chaos testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混乱测试
- en: 'We also go through an example CI/CD pipeline, which consists of the following
    tasks:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过一个示例的 CI/CD 流水线，其中包括以下任务：
- en: Pushing code changes to the Git repository
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码更改推送到 Git 仓库
- en: Running a build of the application code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序代码的构建
- en: Running test against the code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对代码运行测试
- en: Building a container image on a successful test
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功测试后构建容器镜像
- en: Pushing the container image to a container registry
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器镜像推送到容器注册表
- en: Deploying the application to Kubernetes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Kubernetes
- en: Running a test against a deployed application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对已部署应用程序运行测试
- en: Performing rolling upgrades on Deployments
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对部署进行滚动升级
- en: Version Control
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: Every CI/CD pipeline starts with version control, which maintains a running
    history of application and configuration code changes. Git has become the industry
    standard as a source-control management platform, and every Git repository will
    contain a *main branch*. A main branch contains your production code. You will
    have other branches for feature and development work that eventually will be merged
    to your main branch. There are many ways to set up a branching strategy, and the
    setup will be very dependent on the organization structure and separation of duties.
    We find that including both application code and configuration code, such as a
    Kubernetes manifest or Helm charts, helps promote good DevOps principles of communication
    and collaboration. Having both application developers and operation engineers
    collaborate in a single repository builds confidence in a team to deliver an application
    to production.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 CI/CD 流水线都从版本控制开始，这维护应用程序和配置代码更改的运行历史记录。Git 已成为行业标准的源代码管理平台，每个 Git 仓库都将包含一个*主分支*。主分支包含您的生产代码。您将有其他用于功能和开发工作的分支，最终将合并到主分支。有许多设置分支策略的方法，设置将非常依赖于组织结构和职责分离。我们发现，包含应用程序代码和配置代码（如
    Kubernetes 清单或 Helm 图表）有助于促进良好的 DevOps 沟通和协作原则。在单一仓库中让应用程序开发人员和运维工程师共同合作建立了团队交付应用程序到生产环境的信心。
- en: Continuous Integration
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: CI is the process of integrating code changes continuously into a version-control
    repository. Instead of committing large changes less often, you commit smaller
    changes more often. Each time a code change is committed to the repository, a
    build is kicked off. This allows you to have a quicker feedback loop into what
    might have broken the application if problems indeed arise. Many solutions provide
    CI, with Jenkins being one of the more popular tools. At this point you might
    be asking, “Why do I need to know about how the application is built; isn’t that
    the application developer’s role?” Traditionally, this might have been the case,
    but as companies move toward embracing a DevOps culture, the operations team comes
    closer to the application code and software development workflows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CI是将代码更改持续集成到版本控制存储库的过程。与较少频繁地提交大型更改不同，您会更频繁地提交较小的更改。每次向存储库提交代码更改时，都会启动一次构建。这使您能够更快地反馈可能导致应用程序出现问题的原因。许多解决方案提供CI，其中Jenkins是更受欢迎的工具之一。此时，您可能会问：“为什么我需要了解应用程序的构建过程；难道这不是应用程序开发人员的角色吗？”
    传统上可能是这样，但随着公司向DevOps文化的转变，运维团队更接近应用程序代码和软件开发工作流。
- en: Testing
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: The goal of running tests in the pipeline is to quickly provide a feedback loop
    for code changes that break the build. The language that you’re using will determine
    the testing framework you use. For example, Go applications can use `go test`
    for running a suite of unit tests against your code base. Having an extensive
    test suite helps to avoid delivering bad code into your production environment.
    You’ll want to ensure that if tests fail in the pipeline, the build fails after
    the test suite runs. You don’t want to build the container image and push it to
    a registry if you have failing tests against your code base.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在流水线中运行测试的目标是快速提供针对破坏构建的代码更改的反馈循环。您使用的编程语言将决定您使用的测试框架。例如，Go应用程序可以使用`go test`来运行一套针对您的代码库的单元测试。拥有广泛的测试套件有助于避免将糟糕的代码交付到生产环境。您将希望确保如果流水线中的测试失败，则在测试套件运行后构建失败。如果您的代码库存在失败的测试，则不应构建容器镜像并将其推送到注册表中。
- en: Again, you might be asking, “Isn’t creating tests a developer’s job?” As you
    begin automating the delivery of infrastructure and applications to production,
    you need to think about running automated tests against all of the pieces of the
    code base. For example, in [Chapter 2](ch02.html#developer_workflows), we talked
    about using Helm to package applications for Kubernetes. Helm includes a tool
    called `helm lint`, which runs a series of tests against a chart to examine any
    potential issues with the chart provided. Many different tests need to be run
    in an end-to-end pipeline. Some are the developer’s responsibility, like unit
    testing for the application, but others, like smoke testing, will be a joint effort.
    Testing the code base and its delivery to production is a team effort and needs
    to be implemented end to end.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会问：“创建测试不是开发人员的工作吗？” 当你开始自动化基础设施和应用程序的交付到生产环境时，你需要考虑对代码库中所有部分运行自动化测试。例如，在[第2章](ch02.html#developer_workflows)中，我们讨论了使用Helm为Kubernetes打包应用程序。Helm包括一个名为`helm
    lint`的工具，它针对图表运行一系列测试，以检查提供的图表是否存在潜在问题。在端到端的流水线中需要运行许多不同的测试。有些是开发人员的责任，比如应用程序的单元测试，但其他测试如烟雾测试则是团队共同努力的结果。测试代码库及其交付到生产环境是团队的工作，需要端到端实施。
- en: Container Builds
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器构建
- en: 'When building your images, you should optimize the size of the image. Having
    a smaller image decreases the time it takes to pull and deploy the image, and
    also increases the security of the image. There are multiple ways of optimizing
    the image size, but some do have trade-offs. The following strategies will help
    you build the smallest image possible for your application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建图像时，应优化图像的大小。图像越小，拉取和部署图像的时间就越短，同时也增加了图像的安全性。优化图像大小有多种方法，但某些方法确实存在权衡。以下策略将帮助您构建应用程序可能的最小图像：
- en: Multistage builds
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建
- en: These allow you to remove the dependencies not needed for your applications
    to run. For example, with Golang, we don’t need all the build tools used to build
    the static binary, so multistage builds allow you to run a build step in a single
    Dockerfile with the final image containing only the static binary that’s needed
    to run the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些允许您移除不需要的依赖项，以使您的应用程序运行。例如，对于 Golang，我们不需要用于构建静态二进制文件的所有构建工具，因此多阶段构建允许您在单个
    Dockerfile 中运行构建步骤，并且最终镜像仅包含运行应用程序所需的静态二进制文件。
- en: Distroless base images
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Distroless 基础镜像
- en: These remove all the unneeded binaries and shells from the image. This reduces
    the size of the image and increases the security. The trade-off with distroless
    images is you don’t have a shell, so you can’t attach a debugger to the image.
    You might think this is great, but it can be a pain to debug an application. Distroless
    images contain no package manager, shell, or other typical OS packages, so you
    might not have access to the debugging tools you are accustomed to with a typical
    OS.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些从镜像中移除所有不必要的二进制文件和 shell。这样做可以减小镜像的大小并增加安全性。Distroless 镜像的权衡在于没有 shell，因此无法附加调试器到镜像上。您可能认为这很好，但调试应用程序可能会很麻烦。Distroless
    镜像不包含包管理器、shell 或其他典型的操作系统包，因此可能无法访问您在典型操作系统中习惯使用的调试工具。
- en: Optimized base images
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 优化基础镜像
- en: These are images that focus on removing the cruft out of the OS layer and provide
    a slimmed-down image. For example, Alpine provides a base image that starts at
    just 10 MB, and it allows you to attach a local debugger for local development.
    Other distros also typically offer an optimized base image, such as Debian’s Slim
    image. This might be a good option for you because its optimized images give you
    the capabilities you expect for development while also optimizing for image size
    and lower security exposure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些镜像专注于清理操作系统层中的垃圾，并提供精简的镜像。例如，Alpine 提供一个从仅 10 MB 开始的基础镜像，并允许您在本地开发时附加本地调试器。其他发行版通常也提供优化的基础镜像，例如
    Debian 的 Slim 镜像。这可能对您是一个不错的选择，因为其优化的镜像既提供了您在开发中期望的功能，同时又优化了镜像大小并降低了安全风险。
- en: Optimizing your images is extremely important and often overlooked by users.
    You might have obstacles due to company standards for OSes that are approved for
    use in the enterprise, but push back on these so that you can maximize the value
    of containers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 优化您的镜像非常重要，但用户常常忽视。您可能因公司对企业中可用操作系统的标准存在障碍，但应对此进行抗拒，以便最大化容器的价值。
- en: We have found that companies starting out with Kubernetes tend to be successful
    with initially using their current OS but then choose a more optimized image,
    like Debian Slim. After you mature in operationalizing and developing against
    a container environment, you’ll be comfortable with distroless images.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现刚开始使用 Kubernetes 的公司通常通过使用当前的操作系统获得成功，然后选择更优化的镜像，如 Debian Slim。在操作化和针对容器环境进行开发成熟之后，您将会对
    Distroless 镜像感到满意。
- en: Container Image Tagging
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器镜像标记
- en: 'Another step in the CI pipeline is to build a container image so that you have
    an image artifact to deploy to an environment. It’s important to have an image-tagging
    strategy so that you can easily identify the versioned images you have deployed
    to your environments. We can’t preach enough about one of the most important things:
    do not use “latest” as an image tag. Using that as an image tag is not a *version*
    and will lead to not having the ability to identify what code change belongs to
    the rolled-out image. Every image that is built in the CI pipeline should have
    a unique tag.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: CI 流水线中的另一步是构建容器镜像，以便您拥有一个部署到环境中的镜像工件。拥有一个镜像标记策略非常重要，这样您可以轻松识别已部署到环境中的版本化镜像。我们强调一件最重要的事情：不要使用“latest”作为镜像标记。将其用作镜像标记不是一个*版本*，将导致无法识别哪个代码更改属于已部署的镜像。在
    CI 流水线中构建的每个镜像都应具有唯一的标记。
- en: 'There are multiple strategies we’ve found to be effective when tagging images
    in the CI pipeline. The following strategies allow you to easily identify the
    code changes and the build with which they are associated:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现在 CI 流水线中标记镜像时有多种有效策略。以下策略可帮助您轻松识别代码更改及其关联的构建：
- en: BuildID
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 构建ID
- en: When a CI build kicks off, it has a buildID associated with it. Using this part
    of the tag allows you to reference which build assembled the image.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CI 构建启动时，它会关联一个构建 ID。使用标签的这一部分可让您引用哪个构建组装了该镜像。
- en: Build System-buildID
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统-构建ID
- en: This tag is the same as BuildID but adds the Build System for users who have
    multiple build systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此标签与BuildID相同，但为那些使用多个构建系统的用户添加了构建系统。
- en: Git hash
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Git哈希
- en: On new code commits, a Git hash is generated, and using the hash for the tag
    allows you to easily reference which commit generated the image.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码提交时，将生成一个Git哈希，并使用该哈希作为标签，以便轻松地引用生成图像的提交。
- en: githash-buildID
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: githash-buildID
- en: This allows you to reference both the code commit and the buildID that generated
    the image. The only caution here is that the tag can be kind of long.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您能够引用生成图像的代码提交和BuildID。唯一需要注意的是，标签可能会有点长。
- en: Continuous Deployment
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续部署
- en: CD is the process by which changes that have passed successfully through the
    CI pipeline are deployed to production without human intervention. Containers
    provide a great advantage for deploying changes into production. Container images
    become an immutable object that can be promoted through dev and staging and into
    production. For example, a major issue we’ve always had has been maintaining consistent
    environments. Almost everyone has experienced a Deployment that works fine in
    staging, but when it gets promoted to production, it breaks. This is due to having
    *configuration drift*, with libraries and versioning of components differing in
    each environment. Kubernetes gives us a declarative way to describe our Deployment
    objects that can be versioned and deployed consistently.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CD是指通过已成功通过CI流水线的变更无需人工干预即可部署到生产环境的过程。容器为将变更部署到生产环境提供了巨大的优势。容器映像变成了一个不可变的对象，可以通过开发、暂存和生产环境推广使用。例如，我们一直面临的一个主要问题是如何保持一致的环境。几乎每个人都曾经经历过在暂存环境中运行正常的部署，在推广到生产环境时却出现了问题。这是由于存在*配置漂移*，每个环境中的库和组件版本不同。Kubernetes为我们提供了一种声明性的方式来描述我们的部署对象，从而可以进行版本控制并进行一致的部署。
- en: One thing to keep in mind is that you need a solid CI pipeline set up before
    focusing on CD. If you don’t have a robust set of tests to catch issues early
    in the pipeline, you’ll end up rolling bad code to all your environments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是，在专注于CD之前，您需要建立一个可靠的CI流水线。如果在流水线的早期没有强大的测试套件来及早发现问题，您最终将向所有环境部署糟糕的代码。
- en: Deployment Strategies
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署策略
- en: 'Now that we learned the principles of CD, let’s look at the different rollout
    strategies you can use. Kubernetes provides multiple strategies to roll out new
    versions of your application. And even though it has a built-in mechanism to provide
    rolling updates, you can also utilize more advanced strategies. Here, we examine
    the following strategies to deliver updates to your application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了CD的原理，让我们看看可以使用的不同部署策略。Kubernetes提供多种策略来部署应用程序的新版本。虽然它具有内置机制来提供滚动更新，但您还可以利用更高级的策略。在这里，我们将研究以下策略来提供应用程序的更新：
- en: Rolling updates
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动更新
- en: Blue/green deployments
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝/绿部署
- en: Canary deployments
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: '*Rolling updates* are built into Kubernetes and allow you to trigger an update
    to the currently running application without downtime. For example, if you took
    your frontend app that is currently running frontend:v1 and updated the Deployment
    to frontend:v2, Kubernetes would update the replicas in a rolling fashion to frontend:v2\.
    [Figure 5-1](#rolling_update) depicts a rolling update.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*滚动更新*内建于Kubernetes中，允许您触发当前运行的应用程序的更新，而无需停机。例如，如果您有一个当前正在运行frontend:v1的前端应用，并将部署更新为frontend:v2，Kubernetes将以滚动方式更新副本到frontend:v2。[图 5-1](#rolling_update)展示了一个滚动更新。'
- en: '![A Kubernetes rolling update](assets/kbp2_0501.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![一个Kubernetes滚动更新](assets/kbp2_0501.png)'
- en: Figure 5-1\. A Kubernetes rolling update
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 一个Kubernetes滚动更新
- en: 'A Deployment object also lets you configure the maximum amount of replicas
    to be updated and the maximum unavailable pods during the rollout. The following
    manifest is an example of how you specify the rolling update strategy:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Deployment对象还允许您配置要更新的最大副本数以及在部署过程中不可用的最大Pod数。以下清单是指定滚动更新策略的示例：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You need to be cautious with rolling updates because using this strategy can
    cause dropped connections. To deal with this issue, you can utilize *readiness
    probes* and *preStop* life-cycle hooks. The readiness probe ensures that the new
    version deployed is ready to accept traffic, whereas the preStop hook can ensure
    that connections are drained on the current deployed application. The life-cycle
    hook is called before the container exits and is synchronous, so it must complete
    before the final termination signal is given. The following example implements
    a readiness probe and life-cycle hook:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此策略时需要注意滚动更新，因为可能会导致连接丢失。为了解决此问题，可以使用 *就绪探针* 和 *preStop* 生命周期钩子。就绪探针确保部署的新版本已准备好接受流量，而
    preStop 钩子可以确保当前部署的应用程序上的连接已经被排空。生命周期钩子在容器退出之前被调用，是同步的，因此必须在最终终止信号给出之前完成。以下示例实现了就绪探针和生命周期钩子：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preStop life-cycle hook in this example will gracefully exit NGINX, whereas
    a SIGTERM conducts a nongraceful, quick exit.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，preStop 生命周期钩子将优雅地退出NGINX，而SIGTERM则进行不优雅且快速的退出。
- en: Another concern with rolling updates is that you now have two versions of the
    application running at the same time during the rollover. Your database schema
    needs to support both versions of the application. You can also use a feature
    flag strategy in which your schema indicates the new columns created by the new
    app version. After the rolling update has completed, the old columns can be removed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新的另一个问题是在转换期间同时运行两个应用程序版本。您的数据库架构需要支持应用程序的两个版本。您还可以使用特性标志策略，其中您的架构指示新应用程序版本创建的新列。完成滚动更新后，可以移除旧列。
- en: We have also defined a readiness and liveness probe in our Deployment manifest.
    A readiness probe will ensure that your application is ready to serve traffic
    before putting it behind the service as an endpoint. The liveness probe ensures
    that your application is healthy and running, and it restarts the pod if it fails
    its liveness probe. Kubernetes can automatically restart a failed pod only if
    the pod exits on error. For example, the liveness probe can check its endpoint
    and restart it if we had a deadlock from which the pod did not exit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在我们的部署清单中定义了就绪性探针和活性探针。就绪性探针将确保您的应用程序在成为服务端点之前已准备好提供流量。活性探针确保您的应用程序健康运行，并在其失败活性探针时重新启动
    Pod。只有在 Pod 因错误退出时，Kubernetes 才会自动重新启动失败的 Pod。例如，活性探针可以检查其端点，如果我们从中无法退出的死锁，则重新启动它。
- en: '*Blue/green deployments* allow you to release your application predictably.
    With blue/green deployments, you control when the traffic is shifted over to the
    new environment, so it gives you a lot of control over the rollout of a new version
    of your application. With blue/green deployments, you are required to have the
    capacity to deploy both the existing and new environment at the same time. These
    types of deployments have a lot of advantages, such as easily switching back to
    your previous version of the application. There are some things that you need
    to consider with this deployment strategy, however:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*蓝/绿部署* 允许您可预测地发布应用程序。通过蓝/绿部署，您可以控制何时将流量转移到新环境，因此可以很好地控制应用程序新版本的发布。使用蓝/绿部署，您需要具备同时部署现有和新环境的能力。这些类型的部署具有许多优势，例如轻松切换回先前的应用程序版本。然而，使用此部署策略时需要考虑一些事项：'
- en: Database migrations can become difficult with this deployment option because
    you need to consider in-flight transactions and schema update compatibility.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此部署选项可能使数据库迁移变得困难，因为您需要考虑飞行中的事务和架构更新兼容性。
- en: There is the risk of accidental deletion of both environments.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在意外删除两个环境的风险。
- en: You need extra capacity for both environments.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要为两个环境提供额外的容量。
- en: There are coordination issues for hybrid deployments in which legacy apps can’t
    handle the deployment.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合部署存在协调问题，其中旧版应用程序无法处理部署。
- en: '[Figure 5-2](#blue_green_deployment) depicts a blue/green deployment.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-2](#blue_green_deployment) 描述了一个蓝/绿部署。'
- en: '![A blue/green deployment](assets/kbp2_0502.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![一个蓝/绿部署](assets/kbp2_0502.png)'
- en: Figure 5-2\. A blue/green deployment
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 蓝/绿部署
- en: '*Canary deployments* are very similar to blue/green deployments, but they give
    you much more control over shifting traffic to the new release. Most modern Ingress
    implementations will give you the ability to release a percentage of traffic to
    a new release, but you can also implement a service mesh technology, like Istio,
    Linkerd, or HashiCorp Consul, which gives you a number of features that help implement
    this deployment strategy.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*金丝雀部署*与蓝绿部署非常相似，但它可以更好地控制将流量转移到新版本。大多数现代化的入口实现都允许您将一定比例的流量释放到新版本，但您也可以实现服务网格技术，比如Istio、Linkerd或HashiCorp
    Consul，这些技术提供了多种功能，有助于实施这种部署策略。'
- en: Canary deployments allow you to test new features for only a subset of users.
    For example, you might roll out a new version of an application and want to test
    the deployment for only 10% of your user base. This allows you to reduce the risk
    of a bad deployment or broken features to a much smaller subset of users. If there
    are no errors with the deployment or new features, you can begin shifting a greater
    percentage of traffic to the new version of the application. There are also more
    advanced techniques that you can use with canary deployments in which you release
    to only a specific region of users or only target users with a specific profile.
    These types of releases are often referred to as A/B or dark releases because
    users are unaware they are testing new feature deployments.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀部署允许您仅针对用户的一部分测试新功能。例如，您可能要推出应用程序的新版本，并且只想针对您用户群的10%进行部署测试。这样可以大大减少坏部署或功能中断对用户的影响。如果部署或新功能没有错误，您可以开始将更大比例的流量转移到新版本的应用程序上。还有更高级的技术可以与金丝雀部署结合使用，比如只向特定用户区域发布或只针对具有特定配置文件的用户发布。这些类型的发布通常称为A/B或暗发布，因为用户并不知道他们正在测试新功能的部署。
- en: 'With canary deployments, you have some of the same considerations that you
    have with blue/green deployments, but there are some additional considerations
    as well. You must have:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用金丝雀部署时，您会遇到与蓝绿部署相同的一些考虑因素，但也有一些额外的考虑因素。您必须具备以下能力：
- en: The ability to shift traffic to a percentage of users
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将流量转移到一部分用户的能力
- en: A firm knowledge of steady state to compare against a new release
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对稳态有坚实的理解，以便与新版本进行比较
- en: Metrics to understand whether the new release is in a “good” or “bad” state
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于理解新版本是否处于“良好”或“不良”状态的指标
- en: '[Figure 5-3](#canary_development) provides an example of a canary deployment.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-3](#canary_development)提供了金丝雀部署的示例。'
- en: '![A canary deployment](assets/kbp2_0503.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![金丝雀部署](assets/kbp2_0503.png)'
- en: Figure 5-3\. A canary deployment
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-3\. 金丝雀部署
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Canary releases also suffer from having multiple versions of the application
    running at the same time. Your database schema needs to support both versions
    of the application. When using these strategies, you’ll need to focus on how to
    handle dependent services and having multiple versions running. This includes
    having strong API contracts and ensuring that your data services support the multiple
    versions you have deployed at the same time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布也面临着同时运行多个应用程序版本的问题。您的数据库架构需要同时支持这两个版本的应用程序。在使用这些策略时，您需要关注如何处理依赖服务以及同时运行多个版本的问题。这包括具有强大的API契约，并确保您的数据服务支持同时部署的多个版本。
- en: Testing in Production
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生产环境中进行测试
- en: Testing in production helps you to build confidence in the resiliency, scalability,
    and UX of your application. This comes with the caveat that *testing in production*
    doesn’t come without challenges and risk, but it’s worth the effort to ensure
    reliability in your systems. There are important aspects you need to address up
    front when embarking on the implementation. You need to ensure that you have an
    in-depth observability strategy in place, in which you have the ability to identify
    the effects of testing in production. Without being able to observe metrics that
    affect the end users’ experience of your applications, you won’t have a clear
    indication of what to focus on when trying to improve the resiliency of your system.
    You also need a high degree of automation in place to be able to automatically
    recover from failures that you inject into your systems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中进行测试有助于建立对应用程序弹性、可扩展性和用户体验的信心。这带来了一个警告：*在生产环境中测试*并不是没有挑战和风险，但为了确保系统的可靠性，这是值得付出的努力。在实施时，您需要首先处理一些重要方面。您需要确保有一套深入的可观察策略，以便能够识别在生产环境中测试的影响。如果无法观察影响应用程序最终用户体验的指标，您将无法清楚地了解在努力提高系统弹性时应专注于什么。此外，您还需要实施高度自动化，以能够自动从注入到系统中的故障中恢复。
- en: 'You’ll need to implement many tools to reduce risk and effectively test your
    systems when they’re in production. We have discussed some tools in this chapter,
    but there are some new ones, like distributed tracing, instrumentation, chaos
    engineering, and traffic shadowing. To recap, here are the tools we have already
    mentioned:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在生产环境中运行实验时，需要实施许多工具来减少风险并有效地测试您的系统。我们在本章中讨论了一些工具，但还有一些新工具，如分布式跟踪、仪器化、混沌工程和流量阴影。总结一下，这些是我们已经提到的工具：
- en: Canary deployments
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: Blue/green deployments
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝/绿部署
- en: Traffic shifting
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量转移
- en: Feature flags
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能标志
- en: 'Chaos engineering was developed by Netflix. It is the practice of deploying
    experiments into live production systems to discover weaknesses within those systems.
    Chaos engineering allows you to learn about the behavior of your system by observing
    it during a controlled experiment. Following are the steps that you want to implement
    before doing a “game-day” experiment:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌工程是由Netflix开发的。它是将实验部署到实时生产系统中，以发现这些系统中的弱点的实践。混沌工程允许您通过观察在控制实验期间的系统行为来了解其行为。以下是在进行“游戏日”实验之前要实施的步骤：
- en: Build a hypothesis and learn about your steady state.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立假设并了解您的稳态。
- en: Have a varying degree of real-world events that can affect the system.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有可能影响系统的各种真实事件的不同程度。
- en: Build a control group and experiment to compare to steady state.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立一个对照组和实验组，以与稳态进行比较。
- en: Perform experiments to test the hypothesis.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行实验以测试假设。
- en: It’s extremely important that when you’re running experiments, you minimize
    the “blast radius” to ensure that the issues that might arise are minimal. You’ll
    also want to ensure that when you’re building experiments, you focus on automating
    them, given that running experiments can be labor intensive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行实验时，极为重要的是要最小化“影响范围”，以确保可能出现的问题最小化。此外，当您建立实验时，还需确保专注于自动化，因为运行实验可能会很费力。
- en: 'By this point, you might be asking, “Why wouldn’t I just test in staging?”
    We find there are some inherent problems when testing in staging, such as the
    following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你可能会问，“为什么我不只是在测试阶段测试呢？”我们发现在测试阶段会有一些固有问题，比如以下问题：
- en: Nonidentical deployment of resources.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的非相同部署。
- en: Configuration drift from production.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自生产环境的配置漂移。
- en: Traffic and user behavior tend to be generated synthetically.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量和用户行为倾向于是合成生成的。
- en: The number of requests generated don’t mimic a real workload.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的请求数量不模仿真实工作负载。
- en: Lack of monitoring implemented in staging.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试阶段没有实施监控。
- en: The data services deployed contain differing data and load than in production.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的数据服务包含与生产环境不同的数据和负载。
- en: 'We can’t stress this enough: ensure that you have solid confidence in the monitoring
    you have in place for production, because this practice tends to fail users who
    don’t have adequate observability of their production systems. Also, starting
    with smaller experiments to first learn about your experiments and their effects
    will help build confidence.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法过分强调这一点：确保您对生产环境的监控有足够的信心，因为这种做法往往会使没有足够可观察性的用户失败。此外，从较小的实验开始首先了解您的实验及其影响将有助于建立信心。
- en: Setting Up a Pipeline and Performing a Chaos Experiment
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置管道并执行混沌实验
- en: The first step in the process is to fork a GitHub repository so that you can
    have your own repository to use throughout the chapter. You will need to use the
    GitHub interface to fork the [sample application repository](https://oreil.ly/TtJfd).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的第一步是分叉一个GitHub存储库，以便您可以拥有自己的存储库在整章中使用。您将需要使用GitHub界面分叉[示例应用程序存储库](https://oreil.ly/TtJfd)。
- en: Setting Up CI
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置CI
- en: Now that you have learned about CI, you will set up a build of the code that
    we cloned previously.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了CI，您将设置代码的构建，我们之前克隆的。
- en: For this example, we use the hosted *drone.io*. You’ll need to [sign up for
    a free account](https://cloud.drone.io). Log in with your GitHub credentials (this
    registers your repositories in Drone and allows you to synchronize the repositories).
    After you’re logged in to Drone, select Activate on your forked repository. The
    first thing that you need to do is add some secrets to your settings so that you
    can push the app to your Docker Hub registry and also deploy the app to your Kubernetes
    cluster.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用托管的*drone.io*。您需要[注册一个免费帐户](https://cloud.drone.io)。使用GitHub凭据登录（这将注册您的存储库在Drone中并允许您同步存储库）。登录到Drone后，在您的分支存储库上选择激活。您需要做的第一件事是将一些机密添加到设置中，以便您可以将应用程序推送到您的Docker
    Hub注册表，并将其部署到您的Kubernetes集群。
- en: 'Under your repository in Drone, click Settings and add the following secrets
    (see [Figure 5-4](#fig0504)):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drone中的存储库下，单击“设置”，然后添加以下机密（见[图 5-4](#fig0504)）：
- en: '`docker_username`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker_username`'
- en: '`docker_password`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker_password`'
- en: '`kubernetes_server`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes_server`'
- en: '`kubernetes_cert`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes_cert`'
- en: '`kubernetes_token`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes_token`'
- en: '![Drone secrets configuration](assets/kbp2_0504.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Drone机密配置](assets/kbp2_0504.png)'
- en: Figure 5-4\. Drone secrets configuration
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. Drone机密配置
- en: The Docker username and password will be whatever you used to register on Docker
    Hub. The following steps show how to create a Kubernetes service account and certificate
    and retrieve the token.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Docker用户名和密码将是您注册在Docker Hub上使用的内容。以下步骤展示了如何创建Kubernetes服务账户和证书以及检索令牌。
- en: For the Kubernetes server, you will need a publicly available Kubernetes API
    endpoint.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Kubernetes服务器，您将需要一个公开可用的Kubernetes API端点。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You will need cluster-admin privileges on your Kubernetes cluster to perform
    the steps in this section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的Kubernetes集群上拥有cluster-admin特权才能执行本节中的步骤。
- en: 'You can retrieve your API endpoint by using the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下命令检索您的API端点：
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see something like the following: Kubernetes master is running at
    https://kbp.centralus.azmk8s.io:443\. You’ll store this in the `kubernetes_server`
    secret.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的内容：Kubernetes主服务器正在运行于https://kbp.centralus.azmk8s.io:443。您将把这个存储在`kubernetes_server`秘密中。
- en: 'Now let’s create a service account that Drone will use to connect to the cluster.
    Use the following command to create the `serviceaccount`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个服务账户，Drone将用其连接到集群。使用以下命令创建`serviceaccount`：
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, use the following command to create a `clusterrolebinding` for the `service​ac⁠count`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请使用以下命令为`service​ac⁠count`创建`clusterrolebinding`：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now retrieve your `serviceaccount` token:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检索您的`serviceaccount`令牌：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You’ll want to store the output of the token in the `kubernetes_token` secret.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要将令牌的输出存储在`kubernetes_token`秘密中。
- en: 'You will also need the user certificate to authenticate to the cluster, so
    use the following command and paste the `ca.crt` for the `kubernetes_cert` secret:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要用户证书以进行集群身份验证，因此请使用以下命令并粘贴`ca.crt`作为`kubernetes_cert`秘密：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, build your app in a Drone pipeline and then push it to Docker Hub.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Drone管道中构建您的应用程序，然后将其推送到Docker Hub。
- en: 'The first step is the *build step*, which will build your Node.js frontend.
    Drone utilizes container images to run its steps, which gives you a lot of flexibility
    in what you can do with it. For the build step, use a Node.js image from Docker
    Hub:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是 *构建步骤*，它将构建你的 Node.js 前端。Drone 利用容器镜像来运行其步骤，这为你提供了很大的灵活性。在构建步骤中，使用 Docker
    Hub 上的 Node.js 镜像：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the build completes, you’ll want to test it, so we include a *test step*,
    which will run `npm` against the newly built app:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建完成后，你将希望对其进行测试，因此我们包含了一个 *测试步骤*，它将针对新构建的应用程序运行 `npm`：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that you have successfully built and tested your app, you will move on to
    a *publish step* to create a container image of the app and push it to Docker
    Hub.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功构建并测试了你的应用程序，接下来将进行 *发布步骤*，创建一个应用程序的容器镜像并将其推送到 Docker Hub。
- en: 'In the *.drone.yml* file, make the following code change:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *.drone.yml* 文件中，进行以下代码更改：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After the Docker build step finishes, it will push the image to your Docker
    registry.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 构建步骤完成后，它将把镜像推送到你的 Docker 注册表。
- en: Setting Up CD
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 CD
- en: 'For the deployment step in your pipeline, you will push your application to
    your Kubernetes cluster. You will use the deployment manifest that is under the
    frontend app folder in your repository:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管道中的部署步骤，你将会将应用程序推送到你的 Kubernetes 集群。你将使用存储库中前端应用文件夹下的部署清单：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After the pipeline finishes its deployment, you will see the pods running in
    your cluster. Run the following command to confirm that the pods are running:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道完成部署后，你将看到在你的集群中运行的 pod。运行以下命令以确认 pod 是否在运行：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also add a test step that will retrieve the status of the deployment
    by adding the following step in your Drone pipeline:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加一个测试步骤，通过在你的 Drone 管道中添加以下步骤来检索部署的状态：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Performing a Rolling Upgrade
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行滚动升级
- en: 'Let’s demonstrate a rolling upgrade by changing a line in the frontend code.
    In the *server.js* file, change the following line and then commit the change:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更改前端代码中的一行来演示滚动升级。在 *server.js* 文件中更改以下行，然后提交更改：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will see the deployment rolling out and rolling updates happening to the
    existing pods. After the rolling update finishes, you’ll have the new version
    of the application deployed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到部署正在进行中，并且现有 pod 正在进行滚动更新。在滚动更新完成后，你将部署应用程序的新版本。
- en: A Simple Chaos Experiment
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的混沌实验
- en: 'A variety of tools in the Kubernetes ecosystem can help with performing chaos
    experiments in your environment. They range from sophisticated hosted Chaos as
    a Service solutions to basic chaos experiment tools that kill pods in your environment.
    Following are some of the successful tools:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 生态系统中的各种工具可以帮助你在环境中执行混沌实验。它们从复杂的托管混沌服务解决方案到简单的混沌实验工具，用于杀死你环境中的 pod。以下是一些成功的工具：
- en: Gremlin
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Gremlin
- en: Hosted chaos service that provides advanced features for running chaos experiments
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 提供运行混沌实验的先进特性的托管混沌服务
- en: PowerfulSeal
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: PowerfulSeal
- en: Open source project that provides advanced chaos scenarios
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提供高级混沌场景的开源项目
- en: Chaos Toolkit
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Chaos Toolkit
- en: Open source project with a mission to provide a free, open, and community-driven
    toolkit and API to all the various forms of chaos engineering tools
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 旨在为各种形式的混沌工程工具提供免费、开放和社区驱动的工具包和 API 的开源项目
- en: KubeMonkey
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: KubeMonkey
- en: Open source tool that provides basic resiliency testing for pods in your cluster
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 提供基本的容错测试以测试集群中的 pod 的开源工具
- en: 'Let’s set up a quick chaos experiment to test the resiliency of your application
    by automatically terminating pods. For this experiment, we’ll use Chaos Toolkit:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个快速的混沌实验，通过自动终止 pod 来测试你的应用程序的弹性。对于这个实验，我们将使用 Chaos Toolkit：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Best Practices for CI/CD
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD 的最佳实践
- en: 'Your CI/CD pipeline won’t be perfect on day one, but consider some of the following
    best practices to iteratively improve on the pipeline:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 CI/CD 管道在第一天可能不会完美无缺，但考虑以下一些最佳实践来逐步改进管道：
- en: With CI, focus on automation and providing quick builds. Optimizing the build
    speed will provide developers quick feedback if their changes have broken the
    build.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CI 中，专注于自动化和提供快速构建。优化构建速度将为开发人员提供快速反馈，以判断他们的更改是否导致构建失败。
- en: Focus on providing reliable tests in your pipeline. This will give developers
    rapid feedback on issues with their code. The faster the feedback loop to developers,
    the more productive they’ll become in their workflow.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焦点放在管道中提供可靠的测试上。这将为开发人员快速反馈他们代码中的问题。开发人员的反馈循环越快，他们在工作流程中的生产力就会越高。
- en: When deciding on CI/CD tools, ensure that the tools allow you to define the
    pipeline as code. This will allow you to version-control the pipeline with your
    application code.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择 CI/CD 工具时，请确保这些工具允许您将流水线定义为代码。这将使您能够将流水线与应用程序代码一同进行版本控制。
- en: Ensure that you optimize your images so that you can reduce the size of the
    image and also reduce the attack surface when running the image in production.
    Multistage Docker builds allow you to remove packages not needed for the application
    to run. For example, you might need Maven to build the application, but you don’t
    need it for the actual running image.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保优化您的镜像，以减小镜像的大小，并在生产环境中运行镜像时减少攻击面。多阶段 Docker 构建允许您移除应用程序运行时不需要的软件包。例如，您可能需要
    Maven 来构建应用程序，但在实际运行镜像时不需要它。
- en: Avoid using “latest” as an image tag, and utilize a *tag* that can be referenced
    back to the buildID or Git commit.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用“latest”作为镜像标签，而是使用可以引用到 buildID 或 Git 提交的 *tag*。
- en: If you are new to CD, utilize Kubernetes rolling updates to start. They are
    easy to use and will get you comfortable with deployment. As you become more comfortable
    and confident with CD, look at utilizing blue/green and canary deployment strategies.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您对持续交付（CD）不熟悉，请从使用 Kubernetes 的滚动更新开始。它们易于使用，并将帮助您逐步熟悉部署过程。随着您对持续交付更加熟悉和自信，可以考虑使用蓝绿部署和金丝雀部署策略。
- en: With CD, ensure that you test how client connections and database schema upgrades
    are handled in your application.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在持续交付过程中，请确保测试客户端连接和数据库架构升级在您的应用程序中的处理方式。
- en: Testing in production will help you build reliability into your application
    and ensure that you have good monitoring in place. With testing in production,
    also start at a small scale and limit the blast radius of the experiment.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中进行测试将帮助您在应用程序中建立可靠性，并确保您具备良好的监控能力。在生产环境测试时，也要从小规模开始，并限制实验的影响范围。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we discussed the stages of building a CI/CD pipeline for your
    applications, which let you reliably deliver software with confidence. CI/CD pipelines
    help reduce risk and increase throughput of delivering applications to Kubernetes.
    We also discussed the different deployment strategies that can be utilized for
    delivering applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了为应用程序构建 CI/CD 流水线的各个阶段，这将帮助您以可靠的方式交付软件并增强信心。CI/CD 流水线有助于减少风险，并增加将应用程序交付到
    Kubernetes 的吞吐量。我们还讨论了可用于应用程序交付的不同部署策略。
