<html><head></head><body><section data-pdf-bookmark="Chapter 17. Admission Control and Authorization" data-type="chapter" epub:type="chapter"><div class="chapter" id="admission_control_and_authorization">&#13;
<h1><span class="label">Chapter 17. </span>Admission Control and Authorization</h1>&#13;
&#13;
&#13;
<p>Controlling access to the Kubernetes API is key to ensuring that your cluster&#13;
is not only secured but also can be used as a means to impart policy&#13;
and governance for all users, workloads, and components of your&#13;
Kubernetes cluster. In this chapter, we share how you can use&#13;
admission controllers and authorization modules to enable specific&#13;
features and how you can customize them to suit your specific needs.</p>&#13;
&#13;
<p>Before we jump into admission control and authorization let’s review the API request flow<a data-primary="API request flow" data-type="indexterm" id="id1038"/><a data-primary="request flow" data-type="indexterm" id="id1039"/> through the API server. <a data-type="xref" href="#api_request_flow">Figure 17-1</a> provides insight on how and where admission&#13;
control and authorization take place in that flow. It depicts the end-to-end request&#13;
flow through the Kubernetes API server until the object, if accepted, is&#13;
saved to storage. Follow the API request from left to right through the API server,&#13;
paying specific attention to the ordering of admission control and authorization.&#13;
We will be covering best practices for those in this chapter.</p>&#13;
&#13;
<figure><div class="figure" id="api_request_flow">&#13;
<img alt="Kubernetes API request flow" src="assets/kbp2_1701.png"/>&#13;
<h6><span class="label">Figure 17-1. </span>Kubernetes API request flow</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Admission Control" data-type="sect1"><div class="sect1" id="id375">&#13;
<h1>Admission Control</h1>&#13;
&#13;
<p>Have you ever wondered how namespaces are automatically created when you&#13;
define a resource in a namespace that doesn’t already exist? Maybe&#13;
you’ve wondered how a default storage class is selected? These changes&#13;
are powered by a feature called <em>admission controllers</em>. In&#13;
this section, we look at how you can use admission controllers to implement Kubernetes best practices server-side on behalf of the&#13;
user and how you can utilize admission control to govern how a&#13;
Kubernetes cluster is used.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Are They?" data-type="sect2"><div class="sect2" id="id241">&#13;
<h2>What Are They?</h2>&#13;
&#13;
<p>Admission controllers<a data-primary="admission controllers" data-secondary="purpose of" data-type="indexterm" id="admission-purpose"/> sit in the path of the Kubernetes API server request&#13;
flow and receive requests following the authentication and authorization&#13;
phases. They are used to either validate or mutate (or both) the request&#13;
object before saving it to storage. The difference between&#13;
validating and mutating admission controllers is that mutating admission controllers can&#13;
modify the request object they admit, whereas validating admission controllers cannot.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why Are They Important?" data-type="sect2"><div class="sect2" id="id242">&#13;
<h2>Why Are They Important?</h2>&#13;
&#13;
<p>Given that admission controllers sit in the path of all API server requests, you can use them in a variety of different ways. Most commonly, admission&#13;
controller usage can be grouped into the following three categories:</p>&#13;
<dl>&#13;
<dt>Policy and governance</dt>&#13;
<dd>&#13;
<p>Admission controllers <a data-primary="policy and governance" data-secondary="admission controllers" data-type="indexterm" id="id1040"/>allow policy to be&#13;
enforced to meet business requirements; for example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Only internal cloud load balancers can be used when in the <code>dev</code>&#13;
namespace.</p>&#13;
</li>&#13;
<li>&#13;
<p>All containers in a pod must have resource limits.</p>&#13;
</li>&#13;
<li>&#13;
<p>Add predefined standard labels or annotations to all resources to make them discoverable to existing tools.</p>&#13;
</li>&#13;
<li>&#13;
<p>All Ingress resources only use HTTPS. For more details on how to use admission webhooks in this context, see <a data-type="xref" href="ch11.html#policy_and_governance_for_your_cluster">Chapter 11</a>.</p>&#13;
</li>&#13;
</ul>&#13;
</dd>&#13;
<dt>Security</dt>&#13;
<dd>&#13;
<p>You can use<a data-primary="security" data-secondary="admission controllers" data-type="indexterm" id="id1041"/> admission controllers to enforce a consistent&#13;
security posture across your cluster. A canonical example is the&#13;
Pod Security Admission controller, which determines whether a pod should be admitted&#13;
based on the configuration of security-sensitive fields defined in the pod specification. For instance, it can deny privileged containers or usage of specific paths from the host filesystem. You can enforce more granular or custom security rules using admission webhooks.</p>&#13;
</dd>&#13;
<dt>Resource management</dt>&#13;
<dd>&#13;
<p>Admission controllers<a data-primary="resource management" data-secondary="admission controllers" data-type="indexterm" id="id1042"/> allow you to validate to provide best practices for your cluster users, for example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Ensure all ingress fully qualified domain names (FQDN) fall within a specific suffix.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ensure ingress FQDNs don’t overlap.</p>&#13;
</li>&#13;
<li>&#13;
<p>All containers in a pod must have resource<a data-primary="admission controllers" data-secondary="purpose of" data-startref="admission-purpose" data-type="indexterm" id="id1043"/> limits.</p>&#13;
</li>&#13;
</ul>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Admission Controller Types" data-type="sect2"><div class="sect2" id="id144">&#13;
<h2>Admission Controller Types</h2>&#13;
&#13;
<p>There are<a data-primary="admission controllers" data-secondary="types of" data-type="indexterm" id="id1044"/><a data-primary="standard admission controllers" data-type="indexterm" id="id1045"/><a data-primary="dynamic admission controllers" data-type="indexterm" id="id1046"/> two classes of admission controllers: <em>standard</em> and <em>dynamic</em>.&#13;
Standard admission controllers are compiled into the API server and are&#13;
shipped as plug-ins with each Kubernetes release; they need to be&#13;
configured when the API server is started. Dynamic controllers, on the other hand, are&#13;
configurable at runtime and are developed outside the core Kubernetes&#13;
codebase. The only type of dynamic admission control is admission&#13;
webhooks, which receive admission requests via HTTP <span class="keep-together">callbacks.</span></p>&#13;
&#13;
<p>By default, the recommended admission controllers are enabled. You may enable additional admission controllers using the following flag on the Kubernetes API server:</p>&#13;
<pre>--enable-admission-plugins</pre>&#13;
&#13;
<p>In the current version of Kubernetes, the following admission controllers are enabled by default:</p>&#13;
<pre>CertificateApproval, CertificateSigning, CertificateSubjectRestriction,&#13;
DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds,&#13;
LimitRanger, MutatingAdmissionWebhook, NamespaceLifecycle,&#13;
PersistentVolumeClaimResize, PodSecurity, Priority, ResourceQuota,&#13;
RuntimeClass, ServiceAccount, StorageObjectInUseProtection,&#13;
TaintNodesByCondition,&#13;
ValidatingAdmissionWebhook</pre>&#13;
&#13;
<p>You can find the list of Kubernetes admission controllers and their functionality in the <a href="https://oreil.ly/APrUE">Kubernetes documentation</a>.</p>&#13;
&#13;
<p>You might have noticed the following from the list of recommended admission controllers to enable: “MutatingAdmissionWebhook,ValidatingAdmissionWebhook.” These standard admission&#13;
controllers don’t implement any admission logic themselves; rather, they&#13;
are used to configure a webhook endpoint running in-cluster to forward&#13;
the admission request object.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuring Admission Webhooks" data-type="sect2"><div class="sect2" id="id243">&#13;
<h2>Configuring Admission Webhooks</h2>&#13;
&#13;
<p>As previously <a data-primary="admission controllers" data-secondary="configuring admission webhooks" data-type="indexterm" id="admission-control-config"/><a data-primary="configuring" data-secondary="admission webhooks" data-type="indexterm" id="config-webhooks"/><a data-primary="admission webhooks" data-secondary="configuring" data-type="indexterm" id="admission-webhook-config"/>mentioned, one of the main advantages of admission&#13;
webhooks is that they are dynamically configurable. It is important that&#13;
you understand how to effectively configure admission webhooks because there&#13;
are implications and trade-offs when it comes to consistency and&#13;
failure modes.</p>&#13;
&#13;
<p>The snippet that follows is a ValidatingWebhookConfiguration resource&#13;
manifest. This manifest is used to define a validating admission&#13;
webhook. The snippet provides detailed descriptions of the function of&#13;
each field:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">admissionregistration.k8s.io/v1</code><code class="w"/>&#13;
<code class="w">  </code><code class="l-Scalar-Plain">kind</code><code class="p-Indicator">:</code><code class="w"> </code><code class="l-Scalar-Plain">ValidatingWebhookConfiguration</code><code class="w"/>&#13;
<code class="w">  </code><code class="l-Scalar-Plain">metadata</code><code class="p-Indicator">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="c1">## Resource name</code><code class="w"/>&#13;
<code class="w-Error">  </code><code class="nt">webhooks</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="c1">## Admission webhook name, which will be shown to the user when</code><code class="w"/>&#13;
<code class="w">          </code><code class="c1">## any admission reviews are denied</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">clientConfig</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">service</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="c1">## The namespace where the admission</code><code class="w"/>&#13;
<code class="w">                   </code><code class="c1">## webhook pod resides</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="c1">## The service name that is used to connect to the admission</code><code class="w"/>&#13;
<code class="w">              </code><code class="c1">## webhook</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="c1">## The webhook URL</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">caBundle</code><code class="p">:</code><code class="w"> </code><code class="c1">## The PEM encoded CA bundle which will be used to validate the</code><code class="w"/>&#13;
<code class="w">                </code><code class="c1">## webhook's server certificate</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">rules</code><code class="p">:</code><code class="w"> </code><code class="c1">## Describes what operations on what resources/subresources the API</code><code class="w"/>&#13;
<code class="w">           </code><code class="c1">## server must send to this webhook</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">operations</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="c1">## The specific operation that triggers the API server to send to this</code><code class="w"/>&#13;
<code class="w">        </code><code class="c1">## webhook (e.g., create, update, delete, connect)</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">""</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">apiVersions</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"*"</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="c1">## Specific resources by name (e.g., deployments, services, ingresses)</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">failurePolicy</code><code class="p">:</code><code class="w"> </code><code class="c1">## Defines how to handle access issues or unrecognized errors,</code><code class="w"/>&#13;
<code class="w">                   </code><code class="c1">## and must be Ignore or Fail</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">admissionReviewVersions</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"v1"</code><code class="p-Indicator">]</code><code class="w"> </code><code class="c1">## Specify what versions of AdmissionReview</code><code class="w"/>&#13;
<code class="w">                                    </code><code class="c1">## objects are accepted</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">sideEffects</code><code class="p">:</code><code class="w"> </code><code class="c1">## Signal whether the webhook may out-of-band changes that need</code><code class="w"/>&#13;
<code class="w">                 </code><code class="c1">## to be handled</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">timeoutSeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5</code><code class="w"> </code><code class="c1">## How long the API server should wait for a response</code><code class="w"/>&#13;
<code class="w">                      </code><code class="c1">## before treating the request as a failure</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">For completeness, let’s look at a MutatingWebhookConfiguration&#13;
resource manifest. This manifest defines a mutating admission&#13;
webhook. The snippet provides detailed descriptions on the function of&#13;
each field:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">admissionregistration.k8s.io/v1</code><code class="w"/>&#13;
<code class="w">  </code><code class="l-Scalar-Plain">kind</code><code class="p-Indicator">:</code><code class="w"> </code><code class="l-Scalar-Plain">MutatingWebhookConfiguration</code><code class="w"/>&#13;
<code class="w">  </code><code class="l-Scalar-Plain">metadata</code><code class="p-Indicator">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="c1">## Resource name</code><code class="w"/>&#13;
<code class="w-Error">  </code><code class="nt">webhooks</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="c1">## Admission webhook name, which will be shown to the user when any</code><code class="w"/>&#13;
<code class="w">          </code><code class="c1">## admission reviews are denied</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">clientConfig</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">service</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="c1">## The namespace where the admission webhook pod resides</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="c1">## The service name that is used to connect to the admission</code><code class="w"/>&#13;
<code class="w">              </code><code class="c1">## webhook</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="c1">## The webhook URL</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">caBundle</code><code class="p">:</code><code class="w"> </code><code class="c1">## The PEM encoded CA bundle which will be used to validate the</code><code class="w"/>&#13;
<code class="w">                </code><code class="c1">## webhook's server certificate</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">rules</code><code class="p">:</code><code class="w"> </code><code class="c1">## Describes what operations on what resources/subresources the API</code><code class="w"/>&#13;
<code class="w">           </code><code class="c1">## server must send to this webhook</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">operations</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="c1">## The specific operation that triggers the API server to send to this</code><code class="w"/>&#13;
<code class="w">        </code><code class="c1">## webhook (e.g., create, update, delete, connect)</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">""</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">apiVersions</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"*"</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="c1">## Specific resources by name (e.g., deployments, services, ingresses)</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">failurePolicy</code><code class="p">:</code><code class="w"> </code><code class="c1">## Defines how to handle access issues or unrecognized errors,</code><code class="w"/>&#13;
<code class="w">                   </code><code class="c1">## and must be Ignore or Fail</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">admissionReviewVersions</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"v1"</code><code class="p-Indicator">]</code><code class="w"> </code><code class="c1">## Specify what versions of AdmissionReview</code><code class="w"/>&#13;
<code class="w">                   </code><code class="c1">## objects are accepted</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">sideEffects</code><code class="p">:</code><code class="w"> </code><code class="c1">## Signal whether the webhook may out-of-band changes that need</code><code class="w"/>&#13;
<code class="w">                 </code><code class="c1">## to be handled</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">reinvocationPolicy</code><code class="p">:</code><code class="w"> </code><code class="c1">## Control whether mutating webhooks are reinvoked if</code><code class="w"/>&#13;
<code class="w">                        </code><code class="c1">## another mutation to an object occurs</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">timeoutSeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5</code><code class="w"> </code><code class="c1">## How long the API server should wait for a response</code><code class="w"/>&#13;
<code class="w">                      </code><code class="c1">## before treating the request as a failure</code><code class="w"/></pre>&#13;
&#13;
<p>You might have noticed that both resources are identical, with the&#13;
exception of the <code>kind</code> and the <code>reinvocationPolicy</code> fields. There is one difference on the backend,&#13;
however: MutatingWebhookConfiguration allows the admission webhook to&#13;
return a modified request object, whereas&#13;
ValidatingWebhookConfiguration does not. Still, it is acceptable to define&#13;
a MutatingWebhookConfiguration and simply validate; there are security&#13;
considerations that come into play, and you should consider following the&#13;
<em>least-privilege rule</em>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You have likely wondered, “What happens if I&#13;
define a ValidatingWebhookConfiguration or&#13;
MutatingWebhookConfiguration with the resource field under the rule&#13;
object to be either ValidatingWebhookConfiguration or&#13;
MutatingWebhookConfiguration?” The good news is that neither ValidatingAdmissionWebhooks or MutatingAdmissionWebhooks are ever&#13;
called on admission requests for ValidatingWebhookConfiguration and&#13;
MutatingWebhookConfiguration objects. This is for good reason: you&#13;
don’t want to accidentally put the cluster in an <a data-primary="admission controllers" data-secondary="configuring admission webhooks" data-startref="admission-control-config" data-type="indexterm" id="id1047"/><a data-primary="configuring" data-secondary="admission webhooks" data-startref="config-webhooks" data-type="indexterm" id="id1048"/><a data-primary="admission webhooks" data-secondary="configuring" data-startref="admission-webhook-config" data-type="indexterm" id="id1049"/>unrecoverable state.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Admission Control Best Practices" data-type="sect2"><div class="sect2" id="id244">&#13;
<h2>Admission Control Best Practices</h2>&#13;
&#13;
<p>Now that <a data-primary="admission controllers" data-secondary="best practices" data-type="indexterm" id="admission-control-best"/><a data-primary="best practices" data-secondary="admission controllers" data-type="indexterm" id="best-practice-admission-control"/>we’ve covered the power of admission controllers, here are our&#13;
best practices to help you make the most of using them.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Admission plug-in ordering doesn’t matter" data-type="sect3"><div class="sect3" id="id376">&#13;
<h3>Admission plug-in ordering doesn’t matter</h3>&#13;
&#13;
<p>In earlier versions of Kubernetes, the ordering of the admission plug-ins was specific to the&#13;
processing order; hence it mattered. In current supported Kubernetes&#13;
versions, the ordering of the admission plug-ins as specified as API server&#13;
flags via <code>--enable-admission-plugins</code> no longer matters. Ordering does,&#13;
however, play a small role when it comes to admission&#13;
webhooks, so it’s important to understand the request flow in this case.&#13;
Request admittance or rejection operates as a logical AND, meaning if&#13;
any of the admission webhooks rejects a request, the entire request&#13;
is rejected and an error is sent back to the user. It’s also important&#13;
to note that mutating admission controllers are always run prior to&#13;
running validating admission controllers. If you think about it, this&#13;
makes good sense: you probably don’t want to validate objects that you&#13;
are going to subsequently modify. <a data-type="xref" href="#api_request_flow_via_admission_webhooks">Figure 17-2</a> illustrates a request flow via admission webhooks; you will see that the mutating admission controller is run before the validating admission controller.</p>&#13;
&#13;
<figure><div class="figure" id="api_request_flow_via_admission_webhooks">&#13;
<img alt="An API request flow via admission webhooks" src="assets/kbp2_1702.png"/>&#13;
<h6><span class="label">Figure 17-2. </span>An API request flow via admission webhooks</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Don’t mutate the same fields" data-type="sect3"><div class="sect3" id="id377">&#13;
<h3>Don’t mutate the same fields</h3>&#13;
&#13;
<p>Configuring multiple mutating admission&#13;
webhooks also presents challenges. There is no way to order the request&#13;
flow through multiple mutating admission webhooks, so it’s important to&#13;
not have mutating admission controllers modify the same fields, because this can result in inconsistent behavior. In the case where you have&#13;
multiple mutating admission webhooks, we generally recommend configuring&#13;
validating admission webhooks to confirm that the final resource manifest&#13;
is what you expect post-mutation because it’s guaranteed to be run&#13;
following mutating webhooks.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mutating admission webhooks must be idempotent" data-type="sect3"><div class="sect3" id="id378">&#13;
<h3>Mutating admission webhooks must be idempotent</h3>&#13;
&#13;
<p>This means that they must be able to&#13;
process and admit an object that has already been processed and may have already been modified.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fail open/fail closed" data-type="sect3"><div class="sect3" id="id379">&#13;
<h3>Fail open/fail closed</h3>&#13;
&#13;
<p>You might recall seeing the <code>failurePolicy</code> field as part of both the mutating&#13;
and validating webhook configuration resources. This field defines how&#13;
the API server should proceed in the case where the admission webhooks&#13;
have access issues or encounter unrecognized errors. You can set this field to either <code>Ignore</code> or <code>Fail</code>. <code>Ignore</code> essentially fails to open, meaning that processing of the&#13;
request will continue, whereas <code>Fail</code> denies the entire request. This&#13;
might seem obvious, but the implications in both cases require&#13;
consideration. Ignoring a critical admission webhook could result in&#13;
policy that the business relies on not being applied to a resource&#13;
without the user knowing.</p>&#13;
&#13;
<p>One potential solution to protect against this&#13;
would be to raise an alert when the API server logs that it cannot reach&#13;
a given admission webhook. <code>Fail</code> can be even more devastating by denying all requests if the&#13;
admission webhook is experiencing issues. To protect against&#13;
this you can scope the rules to ensure that only specific resource&#13;
requests are set to the admission webhook. As a tenet, you should never&#13;
have any rules that apply to all resources in the cluster.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Admission webhooks must respond quickly" data-type="sect3"><div class="sect3" id="id245">&#13;
<h3>Admission webhooks must respond quickly</h3>&#13;
&#13;
<p>If you have<a data-primary="admission webhooks" data-secondary="best practices" data-type="indexterm" id="admission-webhook-best"/> written your own admission webhook, it’s important to&#13;
remember that user/system requests can be directly affected by the time&#13;
it takes for your admission webhook to make a decision and respond. All&#13;
admission webhook calls are configured with a 30-second timeout, after which&#13;
time the <code>failurePolicy</code> takes effect. Even if it takes several seconds&#13;
for your admission webhook to make an admit/deny decision, it can severely&#13;
affect user experience when working with the cluster. Avoid having&#13;
complex logic or relying on external systems such as databases to process the admit/deny logic.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Scoping admission webhooks" data-type="sect3"><div class="sect3" id="id380">&#13;
<h3>Scoping admission webhooks</h3>&#13;
&#13;
<p>An optional field allows&#13;
you to scope the namespaces in&#13;
which the admission webhooks operate on via the <code>NamespaceSelector</code>&#13;
field. This field defaults to empty, which matches everything, but it can be&#13;
used to match namespace labels via the use of the <code>matchLabels</code> field.&#13;
We recommend that you always use this field because it allows for an explicit&#13;
opt-in per namespace.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Always deploy in a separate namespace using NamespaceSelector" data-type="sect3"><div class="sect3" id="id381">&#13;
<h3>Always deploy in a separate namespace using NamespaceSelector</h3>&#13;
&#13;
<p>When self-hosting a webhook admission controller, deploy the webhook admission controller&#13;
to a separate namespace and use the <code>NamespaceSelector</code> field to exclude resources deployed to that namespace&#13;
from being processed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Don’t touch the kube-system namespace" data-type="sect3"><div class="sect3" id="id145">&#13;
<h3>Don’t touch the kube-system namespace</h3>&#13;
&#13;
<p>The <code>kube-system</code> namespace <a data-primary="kube-system namespace" data-type="indexterm" id="id1050"/>is a reserved namespace that’s common across all&#13;
Kubernetes clusters. It’s where all system-level services operate. We&#13;
recommend never running admission webhooks against the resources in this&#13;
namespace specifically, and you can achieve this by using the&#13;
<code>NamespaceSelector</code> field and simply not matching the <code>kube-system</code>&#13;
namespace. You should also consider doing this for any system-level namespaces&#13;
that are required for cluster operation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lock down admission webhook configurations with RBAC" data-type="sect3"><div class="sect3" id="id382">&#13;
<h3>Lock down admission webhook configurations with RBAC</h3>&#13;
&#13;
<p>Now that you know about all the fields in the admission webhook&#13;
configuration, you have probably thought of a really simple way to break&#13;
access to a cluster. It goes without saying that the creation of both a&#13;
MutatingWebhookConfiguration and ValidatingWebhookConfiguration is a&#13;
root-level operation on the cluster and must be locked down&#13;
appropriately using RBAC. Failure to do so can result in a broken&#13;
cluster or, even worse, an injection attack on your application&#13;
workloads.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Don’t send sensitive data" data-type="sect3"><div class="sect3" id="id246">&#13;
<h3>Don’t send sensitive data</h3>&#13;
&#13;
<p>Admission webhooks are essentially opaque boxes that accept AdmissionRequests and output AdmissionResponses. How they store and manipulate the request is opaque to the user. It’s important to think&#13;
about what request payloads you are sending to the admission webhook. In&#13;
the case of Kubernetes secrets or ConfigMaps, they might contain sensitive&#13;
information and require strong guarantees about how that information is&#13;
stored and shared. Sharing these resources with an admission webhook can leak&#13;
sensitive information, which is why you should scope your resource rules&#13;
to the minimum resource needed to<a data-primary="admission controllers" data-secondary="best practices" data-startref="admission-control-best" data-type="indexterm" id="id1051"/><a data-primary="best practices" data-secondary="admission controllers" data-startref="best-practice-admission-control" data-type="indexterm" id="id1052"/><a data-primary="admission webhooks" data-secondary="best practices" data-startref="admission-webhook-best" data-type="indexterm" id="id1053"/> validate and/or mutate.</p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authorization" data-type="sect1"><div class="sect1" id="id146">&#13;
<h1>Authorization</h1>&#13;
&#13;
<p>We often<a data-primary="authorization" data-secondary="in API request flow" data-secondary-sortas="API request flow" data-type="indexterm" id="id1054"/><a data-primary="API request flow" data-type="indexterm" id="id1055"/><a data-primary="request flow" data-type="indexterm" id="id1056"/> think about authorization in the context of answering the&#13;
following question: “Is this user able to perform these actions on&#13;
these resources?” In Kubernetes, the authorization of each request is&#13;
performed after authentication but before <span class="keep-together">admission.</span> In this section, we explore how you can configure different authorization modules and&#13;
better understand how you can create the appropriate policy to serve the&#13;
needs of your cluster. <a data-type="xref" href="#api_request_flow_via_authorization_modules">Figure 17-3</a> illustrates where authorization&#13;
sits in the request flow.</p>&#13;
&#13;
<figure><div class="figure" id="api_request_flow_via_authorization_modules">&#13;
<img alt="API request flow via authorization modules" src="assets/kbp2_1703.png"/>&#13;
<h6><span class="label">Figure 17-3. </span>API request flow via authorization modules</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authorization Modules" data-type="sect2"><div class="sect2" id="id274">&#13;
<h2>Authorization Modules</h2>&#13;
&#13;
<p>Authorization modules<a data-primary="authorization" data-secondary="modules" data-tertiary="list of" data-type="indexterm" id="auth-module-list"/> are responsible for either granting or denying&#13;
permission to access. They determine whether to grant access&#13;
based on policy that must be explicitly defined; otherwise all requests&#13;
will be implicitly denied.</p>&#13;
&#13;
<p>Kubernetes ships with the following authorization modules out of the&#13;
box:</p>&#13;
<dl>&#13;
<dt>Attribute-Based Access Control (ABAC)</dt>&#13;
<dd>&#13;
<p>Allows authorization policy to be configured via local files</p>&#13;
</dd>&#13;
<dt>RBAC</dt>&#13;
<dd>&#13;
<p>Allows authorization policy to be configured via the Kubernetes API (refer to <a data-type="xref" href="ch04.html#configuration_secrets_and_rbac">Chapter 4</a> for more detail)</p>&#13;
</dd>&#13;
<dt>Webhook</dt>&#13;
<dd>&#13;
<p>Allows the authorization of a request to be handled via a remote REST endpoint</p>&#13;
</dd>&#13;
<dt>Node</dt>&#13;
<dd>&#13;
<p>Specialized authorization module that authorizes requests from kubelets</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p class="pagebreak-before">The modules are configured by the cluster administrator via the following&#13;
flag on the API server: <code>--authorization-mode</code>. Multiple modules can be&#13;
configured and are checked in order. Unlike admission controllers, if a&#13;
single authorization module admits the request, the request can&#13;
proceed. Only for the case in which all modules deny the request will an&#13;
error be returned to the <a data-primary="authorization" data-secondary="modules" data-startref="auth-module-list" data-tertiary="list of" data-type="indexterm" id="id1057"/>user.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ABAC" data-type="sect3"><div class="sect3" id="id147">&#13;
<h3>ABAC</h3>&#13;
&#13;
<p>Let’s <a data-primary="authorization" data-secondary="modules" data-tertiary="ABAC" data-type="indexterm" id="auth-module-abac"/><a data-primary="ABAC (Attribute-Based Access Control)" data-type="indexterm" id="abac"/>look at a policy definition in the context of using the&#13;
ABAC authorization module. The following grants user Mary read-only&#13;
access to a pod in the <code>kube-system</code> namespace:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">abac.authorization.kubernetes.io/v1beta1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Policy</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">user</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mary</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">resource</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pods</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">readonly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kube-system</code><code class="w"/></pre>&#13;
&#13;
<p>If Mary were to make the following request, it would be denied because Mary&#13;
doesn’t have access to get pods in the <code>demo-app</code> namespace:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">authorization.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">SubjectAccessReview</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">resourceAttributes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">verb</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">get</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">resource</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pods</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-app</code><code class="w"/></pre>&#13;
&#13;
<p>This example introduced a new API group, <code>authorization.k8s.io</code>.&#13;
This set of APIs exposes API server authorization to external services&#13;
and has the following APIs, which are great for debugging:</p>&#13;
<dl>&#13;
<dt>SelfSubjectAccessReview</dt>&#13;
<dd>&#13;
<p>Access review for the current user</p>&#13;
</dd>&#13;
<dt>SubjectAccessReview</dt>&#13;
<dd>&#13;
<p>Like SelfSubjectAccessReview but for any user</p>&#13;
</dd>&#13;
<dt>LocalSubjectAccessReview</dt>&#13;
<dd>&#13;
<p>Like SubjectAccessReview but namespace specific</p>&#13;
</dd>&#13;
<dt>SelfSubjectRulesReview</dt>&#13;
<dd>&#13;
<p>Returns a list of actions a user can perform in a given namespace</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The cool part is that you can query these APIs by creating&#13;
resources as you typically would. Let’s take the previous example&#13;
and test this using the SelfSubjectAccessReview. The status&#13;
field in the output indicates that this request is allowed:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>cat<code class="w"> </code><code class="s">&lt;&lt; EOF | kubectl create -f - -o yaml</code>&#13;
<code class="s">apiVersion: authorization.k8s.io/v1</code>&#13;
<code class="s">kind: SelfSubjectAccessReview</code>&#13;
<code class="s">spec:</code>&#13;
<code class="s">  resourceAttributes:</code>&#13;
<code class="s">    verb: get</code>&#13;
<code class="s">    resource: pods</code>&#13;
<code class="s">    namespace: demo-app</code>&#13;
<code class="s">EOF</code><code class="w"/>&#13;
apiVersion:<code class="w"> </code>authorization.k8s.io/v1<code class="w"/>&#13;
kind:<code class="w"> </code>SelfSubjectAccessReview<code class="w"/>&#13;
metadata:<code class="w"/>&#13;
<code class="w">  </code>creationTimestamp:<code class="w"> </code>null<code class="w"/>&#13;
spec:<code class="w"/>&#13;
<code class="w">  </code>resourceAttributes:<code class="w"/>&#13;
<code class="w">    </code>namespace:<code class="w"> </code>kube-system<code class="w"/>&#13;
<code class="w">    </code>resource:<code class="w"> </code>pods<code class="w"/>&#13;
<code class="w">    </code>verb:<code class="w"> </code>get<code class="w"/>&#13;
status:<code class="w"/>&#13;
<code class="w">  </code>allowed:<code class="w"> </code><code class="nb">true</code><code class="w"/></pre>&#13;
&#13;
<p>In fact, Kubernetes ships with tooling built into <code>kubectl</code> to make this&#13;
even easier. The <code>kubectl auth can-i</code> command operates by querying the&#13;
same API as the previous example:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>kubectl<code class="w"> </code>auth<code class="w"> </code>can-i<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>--namespace<code class="w"> </code>demo-app<code class="w"/>&#13;
yes<code class="w"/></pre>&#13;
&#13;
<p>With administrator credentials, you can also run the same command to check&#13;
actions as another<a data-primary="authorization" data-secondary="modules" data-startref="auth-module-abac" data-tertiary="ABAC" data-type="indexterm" id="id1058"/><a data-primary="ABAC (Attribute-Based Access Control)" data-startref="abac" data-type="indexterm" id="id1059"/> user:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>kubectl<code class="w"> </code>auth<code class="w"> </code>can-i<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>--namespace<code class="w"> </code>demo-app<code class="w"> </code>--as<code class="w"> </code>mary<code class="w"/>&#13;
yes<code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RBAC" data-type="sect3"><div class="sect3" id="id383">&#13;
<h3>RBAC</h3>&#13;
&#13;
<p>Kubernetes role-based access control is covered in depth in <a data-type="xref" href="ch04.html#configuration_secrets_and_rbac">Chapter 4</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Webhook" data-type="sect3"><div class="sect3" id="id148">&#13;
<h3>Webhook</h3>&#13;
&#13;
<p>Using<a data-primary="authorization" data-secondary="modules" data-tertiary="webhook" data-type="indexterm" id="id1060"/><a data-primary="webhook authorization module" data-type="indexterm" id="id1061"/> the webhook authorization module allows a cluster administrator to&#13;
configure an external REST endpoint to delegate the authorization&#13;
process to. This would run off-cluster and be reachable via URL. The&#13;
configuration of the REST endpoint is found in a file on the&#13;
control plane host filesystem and configured on the API server via&#13;
<code>--authorization-webhook-config-file=SOME_FILENAME</code>. After you’ve configured it,&#13;
the API server will send SubjectAccessReview objects as part of the&#13;
request body to the authorization webhook application, which processes and&#13;
returns the object with the status field complete.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authorization Best Practices" data-type="sect2"><div class="sect2" id="id247">&#13;
<h2>Authorization Best Practices</h2>&#13;
&#13;
<p>Consider the<a data-primary="authorization" data-secondary="best practices" data-type="indexterm" id="id1062"/><a data-primary="best practices" data-secondary="authorization" data-type="indexterm" id="id1063"/> following best practices before making changes to the authorization modules configured on your cluster:</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Don’t use ABAC on multiple control plane clusters" data-type="sect3"><div class="sect3" id="id384">&#13;
<h3>Don’t use ABAC on multiple control plane clusters</h3>&#13;
&#13;
<p>Given that the ABAC policies need to be placed on the filesystem of each&#13;
control plane host and kept synchronized, we generally recommend <em>against</em> using ABAC in&#13;
multiple control plane clusters. The same can be said for the webhook module because the&#13;
configuration is based on a file and a corresponding flag being present.&#13;
Furthermore, changes to these policies in the files require a restart of&#13;
the API server to take effect, which is effectively a control plane&#13;
outage in a single control plane cluster or inconsistent configuration in a&#13;
 multiple control plane cluster. Given these details, we recommend using the&#13;
RBAC module only for user authorization because the rules are configured&#13;
and stored in Kubernetes itself.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Don’t use webhook modules" data-type="sect3"><div class="sect3" id="id385">&#13;
<h3>Don’t use webhook modules</h3>&#13;
&#13;
<p>Webhook modules, although powerful, are potentially very dangerous. Given&#13;
that every request is subject to the authorization process, a failure of&#13;
a webhook service would be devastating for a cluster. Therefore, we&#13;
generally recommend not using external authorization modules unless you&#13;
completely vet and are comfortable with your cluster failure modes if the webhook service becomes unreachable or &#13;
<span class="keep-together">unavailable.</span></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id386">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we covered the foundational topics of admission and&#13;
authorization and covered best practices. Put these skills to use by&#13;
determining the best admission and authorization configuration that&#13;
allows you to customize the controls and policies needed for the life of&#13;
your cluster.</p>&#13;
</div></section>&#13;
</div></section></body></html>