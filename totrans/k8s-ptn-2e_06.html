<html><head></head><body><section data-pdf-bookmark="Chapter 4. Health Probe" data-type="chapter" epub:type="chapter"><div class="chapter" id="HealthProbe">&#13;
<h1><span class="label">Chapter 4. </span>Health Probe</h1>&#13;
&#13;
&#13;
<p>The<a data-primary="Health Probe" data-type="indexterm" id="healthp04"/> <em>Health Probe</em> pattern indicates how an application can communicate its health state to Kubernetes. To be fully automatable, a cloud native application must be highly observable by allowing its state to be inferred so that Kubernetes can detect whether the application is up and whether it is ready to serve requests.&#13;
These observations influence the lifecycle management of Pods and the way traffic is routed to the application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902104030784">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>Kubernetes<a data-primary="problems" data-secondary="applications, health state of" data-type="indexterm" id="idm45902104029456"/> regularly checks the container process status and restarts it if issues are detected. However, from practice, we know that checking the process status is not sufficient to determine the health of an application. In many cases, an application hangs, but its process is still up and running. For example, a Java application may throw an <code>OutOfMemoryError</code> and still have the<a data-primary="JVM daemon threads" data-type="indexterm" id="idm45902104027968"/> JVM process running. Alternatively, an application may freeze because it runs into an infinite loop, deadlock, or some thrashing (cache, heap, process). To detect these kinds of situations, Kubernetes needs a reliable way to check the health of applications—that is, not to understand how an application works internally, but to check whether the application is functioning as expected and capable of serving consumers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902104026416">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>The<a data-primary="failures" data-secondary="detecting" data-type="indexterm" id="idm45902104024880"/> software industry has accepted the fact that it is not possible to write bug-free code. Moreover, the chances for failure increase even more when working with distributed applications. As a result, the focus for dealing with failures has shifted from avoiding them to detecting faults and recovering. Detecting failure is not a simple task that can be performed uniformly for all applications, as everyone has different definitions of a failure. Also, various types of failures require different corrective actions. Transient failures may self-recover, given enough time, and some other failures may need a restart of the application. Let’s look at the checks Kubernetes uses to detect and correct failures.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Process Health Checks" data-type="sect2"><div class="sect2" id="idm45902104023616">&#13;
<h2>Process Health Checks</h2>&#13;
&#13;
<p>A<a data-primary="process health checks" data-type="indexterm" id="idm45902104022320"/><a data-primary="Kubelet" data-secondary="process health checks" data-type="indexterm" id="idm45902104021584"/> <em>process health check</em> is the simplest health check the Kubelet constantly performs on the container processes. If the container processes are not running, the container is restarted on the node to which the Pod is assigned. So even without any other health checks, the application becomes slightly more robust with this generic check. If your application is capable of detecting any kind of failure and shutting itself down, the process health check is all you need. However, for most cases, that is not enough, and other types of health checks are also necessary.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Liveness Probes" data-type="sect2"><div class="sect2" id="idm45902104019840">&#13;
<h2>Liveness Probes</h2>&#13;
&#13;
<p>If<a data-primary="liveness probes" data-type="indexterm" id="idm45902104018272"/> your application runs into a deadlock, it is still considered healthy from the process health check’s point of view. To detect this kind of issue and any other types of failure according to your application business logic, Kubernetes has <em>liveness probes</em>—regular checks performed by the<a data-primary="Kubelet" data-secondary="liveness probes" data-type="indexterm" id="idm45902104017024"/> Kubelet agent that asks your container to confirm it is still healthy. It is important to have the health check performed from the outside rather than in the application itself, as some failures may prevent the application watchdog from reporting its failure. Regarding corrective action, this health check is similar to a process health check, since if a failure is detected, the container is restarted. However, it offers more flexibility regarding which methods to use for checking the application health, as follows:</p>&#13;
<dl>&#13;
<dt>HTTP probe</dt>&#13;
<dd>&#13;
<p>Performs an HTTP GET request to the container IP address and expects a successful HTTP response code between 200 and 399.</p>&#13;
</dd>&#13;
<dt>TCP Socket probe</dt>&#13;
<dd>&#13;
<p>Assumes a successful TCP connection.</p>&#13;
</dd>&#13;
<dt>Exec probe</dt>&#13;
<dd>&#13;
<p>Executes an arbitrary command in the container’s user and kernel namespace and expects a successful exit code (0).</p>&#13;
</dd>&#13;
<dt>gRPC probe</dt>&#13;
<dd>&#13;
<p>Leverages gRPC’s intrinsic support for health checks.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p class="pagebreak-before">In addition to the probe action, the health check behavior can be influenced with the following parameters:</p>&#13;
<dl>&#13;
<dt><code>initialDelaySeconds</code></dt>&#13;
<dd>&#13;
<p>Specifies the number of seconds to wait until the first liveness probe is checked.</p>&#13;
</dd>&#13;
<dt><code>periodSeconds</code></dt>&#13;
<dd>&#13;
<p>The interval in seconds between liveness probe checks.</p>&#13;
</dd>&#13;
<dt><code>timeoutSeconds</code></dt>&#13;
<dd>&#13;
<p>The maximum time allowed for a probe check to return before it is considered to have failed.</p>&#13;
</dd>&#13;
<dt><code>failureThreshold</code></dt>&#13;
<dd>&#13;
<p>Specifies how many times a probe check needs to fail in a row until the container is considered to be unhealthy and needs to be restarted.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>An example HTTP-based liveness probe is shown in <a data-type="xref" href="#ex-liveness-probe">Example 4-1</a>.</p>&#13;
<div data-type="example" id="ex-liveness-probe">&#13;
<h5><span class="label">Example 4-1. </span>Container with a liveness probe</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pod-with-liveness-check</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DELAY_STARTUP</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">20</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">livenessProbe</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">httpGet</code><code class="p">:</code><code class="w">                  </code><a class="co" href="#callout_health_probe_CO1-1" id="co_health_probe_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/actuator/health</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">initialDelaySeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">30</code><code class="w">   </code><a class="co" href="#callout_health_probe_CO1-2" id="co_health_probe_CO1-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_health_probe_CO1-1" id="callout_health_probe_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>HTTP probe to a health-check endpoint.</p></dd>&#13;
<dt><a class="co" href="#co_health_probe_CO1-2" id="callout_health_probe_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Wait 30 seconds before doing the first liveness check to give the application some time to warm up.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p class="pagebreak-before">Depending on the nature of your application, you can choose the method that is most suitable for you. It is up to your application to decide whether it considers itself healthy or not. However, keep in mind that the result of not passing a health check is that your container will restart. If restarting your container does not help, there is no benefit to having a failing health check as Kubernetes restarts your container without fixing the underlying issue.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Readiness Probes" data-type="sect2"><div class="sect2" id="idm45902104572480">&#13;
<h2>Readiness Probes</h2>&#13;
&#13;
<p>Liveness<a data-primary="readiness probes" data-type="indexterm" id="idm45902104570912"/> checks help keep applications healthy by killing unhealthy containers and replacing them with new ones. But sometimes, when a container is not healthy, restarting it may not help. A typical example is a container that is still starting up and is not ready to handle any requests. Another example is an application that is still waiting for a dependency like a database to be available. Also, a container can be overloaded, increasing its latency, so you want it to shield itself from the additional load for a while and indicate that it is not ready until the load decreases.</p>&#13;
&#13;
<p>For this kind of scenario, Kubernetes has <em>readiness probes</em>. The methods (HTTP, TCP, Exec, gRPC) and timing options for performing readiness checks are the same as for liveness checks, but the corrective action is different. Rather than restarting the container, a failed readiness probe causes the container to be removed from the service endpoint and not receive any new traffic. Readiness probes signal when a container is ready so that it has some time to warm up before getting hit with requests from the service. It is also useful for shielding the container from traffic at later stages, as readiness probes are performed regularly, similarly to liveness checks. <a data-type="xref" href="#ex-readiness-probe">Example 4-2</a> shows how a readiness probe can be implemented by probing the existence of a file the application creates when it is ready for operations.</p>&#13;
<div data-type="example" id="ex-readiness-probe">&#13;
<h5><span class="label">Example 4-2. </span>Container with readiness probe</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pod-with-readiness-check</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">readinessProbe</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">exec</code><code class="p">:</code><code class="w">  </code><a class="co" href="#callout_health_probe_CO2-1" id="co_health_probe_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"</code><code class="s">stat</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">/var/run/random-generator-ready</code><code class="s">"</code><code class="w"> </code><code class="p-Indicator">]</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_health_probe_CO2-1" id="callout_health_probe_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Check for the existence of a file the application creates to indicate it’s ready to serve requests. <code>stat</code> returns an error if the file does not exist, letting the readiness check fail.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Again, it is up to your implementation of the health check to decide when your application is ready to do its job and when it should be left alone. While process health checks and liveness checks are intended to recover from the failure by restarting the container, the readiness check buys time for your application and expects it to recover by itself. Keep in mind that Kubernetes tries to prevent your container from receiving new requests (when it is shutting down, for example), regardless of whether the readiness check still passes after having received a SIGTERM signal.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902101527376">&#13;
<h1>Custom Pod Readiness Gates</h1>&#13;
<p>Readiness probes<a data-primary="Pods" data-secondary="readiness gates for" data-type="indexterm" id="idm45902101525888"/> work on a per-container level, and a Pod is considered ready to serve requests when all containers pass their readiness probes. In some situations, this is not good enough—for example, when an external load balancer like the AWS LoadBalancer needs to be reconfigured and ready too. In this case, the <code>readinessGates</code> field of a Pod’s specification can be used to specify extra conditions that need to be met for the Pod to become ready.&#13;
<a data-type="xref" href="#ex-readiness-gates">Example 4-3</a> shows a readiness gate that will introduce an additional condition, <code>k8spatterns.io/load-balancer-ready</code>, to the Pod’s <code>status</code> sections.</p>&#13;
<div data-type="example" id="ex-readiness-gates">&#13;
<h5><span class="label">Example 4-3. </span>Readiness gate for indicating the status of an external load balancer</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="p">...</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">readinessGates</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">conditionType</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">k8spatterns.io/load-balancer-ready</code><code class="s">"</code><code class="w">&#13;
</code><code class="p">...</code><code class="w">&#13;
</code><code class="nt">status</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">conditions</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">k8spatterns.io/load-balancer-ready</code><code class="s">"</code><code class="w"> </code><a class="co" href="#callout_health_probe_CO3-1" id="co_health_probe_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">status</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">False</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">...</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Ready</code><code class="w">                                </code><a class="co" href="#callout_health_probe_CO3-2" id="co_health_probe_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">status</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">False</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">...</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_health_probe_CO3-1" id="callout_health_probe_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>New condition introduced by Kubernetes and set to <code>False</code> by default. It needs to be switched to <code>True</code> externally, e.g., by a controller, as desribed in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch27.html#Controller">Chapter 27, “Controller”</a>, when the load balancer is ready to serve.</p></dd>&#13;
<dt><a class="co" href="#co_health_probe_CO3-2" id="callout_health_probe_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The Pod is “ready” when all containers’ readiness probes are passing and the readiness gates’ conditions are <code>True</code>; otherwise, as here, the Pod is marked as nonready.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Pod readiness gates are an advanced feature that are not supposed to be used by the end user but by Kubernetes add-ons to introduce additional dependencies on the readiness of a Pod.</p>&#13;
</div></aside>&#13;
&#13;
<p>In many cases, liveness and readiness probes are performing the same checks. However, the presence of a readiness probe gives your container time to start up. Only by passing the readiness check is a Deployment considered to be successful, so that, for example, Pods with an older version can be terminated as part of a rolling update.</p>&#13;
&#13;
<p>For applications that need a very long time to initialize, it’s likely that failing liveness checks will cause your container to be restarted before the startup is finished.&#13;
To prevent these unwanted shutdowns, you can use <em>startup probes</em> to indicate when the startup is finished.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Startup Probes" data-type="sect2"><div class="sect2" id="idm45902105041568">&#13;
<h2>Startup Probes</h2>&#13;
&#13;
<p>Liveness probes<a data-primary="startup probes" data-type="indexterm" id="idm45902103670160"/> can also be used exclusively to allow for long startup times by stretching the check intervals, increasing the number of retries, and adding a longer delay for the initial liveness probe check. This strategy, however, is not optimal since these timing parameters will also apply for the post-startup phase and will prevent your application from quickly restarting when fatal errors occur.</p>&#13;
&#13;
<p>When applications take minutes to start (for example, Jakarta EE application servers), Kubernetes provides <em>startup probes</em>.</p>&#13;
&#13;
<p>Startup probes are configured with the same format as liveness probes but allow for different values for the probe action and the timing parameters. The <code>periodSeconds</code> and <code>failureThreshold</code> parameters are configured with much larger values compared to the corresponding liveness probes to factor in the longer application startup.&#13;
Liveness and readiness probes are called only after the startup probe reports success.&#13;
The container is restarted if the startup probe is not successful within the configured failure threshold.</p>&#13;
&#13;
<p>While the same probe action can be used for liveness and startup probes, a successful startup is often indicated by a marker file that is checked for existence by the startup probe.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-startup-probe">Example 4-4</a> is a typical example of a Jakarta EE application server that takes a long time to start.</p>&#13;
<div class="less_space pagebreak-before" data-type="example" id="ex-startup-probe">&#13;
<h5><span class="label">Example 4-4. </span>Container with a startup and liveness probe</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pod-with-startup-check</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">quay.io/wildfly/wildfly</code><code class="w"> </code><a class="co" href="#callout_health_probe_CO4-1" id="co_health_probe_CO4-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">wildfly</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">startupProbe</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">exec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"</code><code class="s">stat</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">/opt/jboss/wildfly/standalone/tmp/startup-marker</code><code class="s">"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w">  </code><a class="co" href="#callout_health_probe_CO4-2" id="co_health_probe_CO4-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">initialDelaySeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">60</code><code class="w">    </code><a class="co" href="#callout_health_probe_CO4-3" id="co_health_probe_CO4-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">periodSeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">60</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">failureThreshold</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">15</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">livenessProbe</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">httpGet</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/health</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">9990</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">periodSeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">10</code><code class="w">          </code><a class="co" href="#callout_health_probe_CO4-4" id="co_health_probe_CO4-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">failureThreshold</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_health_probe_CO4-1" id="callout_health_probe_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>JBoss WildFly Jakarta EE server that will take its time to start.</p></dd>&#13;
<dt><a class="co" href="#co_health_probe_CO4-2" id="callout_health_probe_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Marker file that is created by WildFly after a successful startup.</p></dd>&#13;
<dt><a class="co" href="#co_health_probe_CO4-3" id="callout_health_probe_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Timing parameters that specify that the container should be restarted when it has not been passing the startup probe after 15 minutes (60-second pause until the first check, then maximal 15 checks with 60-second intervals).</p></dd>&#13;
<dt><a class="co" href="#co_health_probe_CO4-4" id="callout_health_probe_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Timing parameters for the liveness probes are much smaller, resulting in a restart if subsequent liveness probes fail within 20 seconds (three retries with 10-second pauses between each).</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The liveness, readiness, and startup probes are fundamental building blocks of the automation of cloud native applications. Application frameworks such as Quarkus SmallRye Health, Spring Boot Actuator, WildFly<a data-primary="WildFly" data-type="indexterm" id="idm45902103166096"/> Swarm health check, Apache Karaf health check, or the MicroProfile spec for Java provide implementations for offering health probes.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902103165168">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>To be fully automatable, cloud native applications must be highly observable by providing a means for the managing platform to read and interpret the application health, and if necessary, take corrective actions. Health checks play a fundamental role in the automation of activities such as deployment, self-healing, scaling, and others. However, there are also other means through which your application can provide more visibility about its health.</p>&#13;
&#13;
<p>The obvious and old method for this purpose is through<a data-primary="logging" data-type="indexterm" id="idm45902104240656"/> logging. It is a good practice for containers to log any significant events to system out and system error and have these logs collected to a central location for further analysis. Logs are not typically used for taking automated actions but rather to raise alerts and further investigations. A more useful aspect of logs is the<a data-primary="failures" data-secondary="postmortem analysis of" data-type="indexterm" id="idm45902104239824"/><a data-primary="postmortem analysis" data-type="indexterm" id="idm45902104238880"/> postmortem analysis of failures and detection of unnoticeable errors.</p>&#13;
&#13;
<p>Apart from logging to standard streams, it is also a good practice to log the reason for exiting a container to <em>/dev/termination-log</em>. This location is the place where the container can state its last will before being permanently vanished.<sup><a data-type="noteref" href="ch04.html#idm45902104237024" id="idm45902104237024-marker">1</a></sup> <a data-type="xref" href="#img-observability">Figure 4-1</a> shows<a data-primary="containers" data-secondary="observability options" data-type="indexterm" id="idm45902104234000"/> the possible options for how a container can communicate with the runtime platform.</p>&#13;
&#13;
<figure class="width-65"><div class="figure" id="img-observability">&#13;
<img alt="Container observability options" src="assets/kup2_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>Container observability options</h6>&#13;
</div></figure>&#13;
&#13;
<p>Containers provide a unified way for packaging and running applications by treating them like opaque systems. However, any container that is aiming to become a cloud native citizen must provide APIs for the runtime environment to observe the container health and act accordingly. This support is a fundamental prerequisite for automation of the container updates and lifecycle in a unified way, which in turn improves the system’s resilience and user experience. In practical terms, that means, as a very minimum, your containerized application must provide APIs for the different kinds of health checks (liveness and readiness).</p>&#13;
&#13;
<p>Even-better-behaving applications must also provide other means for the managing platform to observe the state of the containerized application by integrating with tracing and metrics-gathering libraries such as<a data-primary="OpenTracing" data-type="indexterm" id="idm45902104229888"/> OpenTracing or Prometheus. Treat your application as an opaque system, but implement all the necessary APIs to help the platform observe and manage your application in the best way possible.</p>&#13;
&#13;
<p>The next pattern, <em>Managed Lifecycle</em>, is also about communication between applications and the Kubernetes management layer, but coming from the other direction. It’s about how your application gets informed about important Pod lifecycle events.<a data-primary="" data-startref="healthp04" data-type="indexterm" id="idm45902104228224"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902104227120">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/moMx7">Health Probe Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/h862g">Configure Liveness, Readiness, and Startup Probes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/q0wKy">Kubernetes Best Practices: Setting Up Health Checks with Readiness and Liveness Probes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/kEik7">Graceful Shutdown with Node.js and Kubernetes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/MHbup">Kubernetes Startup Probe—Practical Guide</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/h_W1G">Improving Application Availability with Pod Readiness Gates</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/O2sA2">Customizing the Termination Message</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/lhetJ">SmallRye Health</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/7kYX6">Spring Boot Actuator: Production-Ready Features</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/aKEGe">Advanced Health Check Patterns in Kubernetes</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45902104237024"><sup><a href="ch04.html#idm45902104237024-marker">1</a></sup> Alternatively, you could change the <code>.spec.containers.terminationMessagePolicy</code> field of a Pod to  <span class="keep-together"><code>FallbackToLogsOnError</code>,</span> in which case the last line of the log is used for the Pod’s status message when it terminates.</p></div></div></section></body></html>