- en: Chapter 5\. Classes and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re like most programmers coming from an object-oriented programming language,
    classes are your bread and butter. Classes are how you organize and think about
    your code, and they serve as your primary unit of encapsulation. You’ll be pleased
    to learn that TypeScript classes borrow heavily from C#, and support things like
    visibility modifiers, property initializers, polymorphism, decorators, and interfaces.
    But because TypeScript classes compile down to regular JavaScript classes, you
    can also express JavaScript idioms like mixins in a typesafe way.
  prefs: []
  type: TYPE_NORMAL
- en: Some of TypeScript’s class features, like property initializers and decorators,
    are supported by JavaScript classes too,^([1](ch05.html#idm46304973683464)) and
    so generate runtime code. Other features, like visibility modifiers, interfaces,
    and generics, are TypeScript-only features that just exist at compile time, and
    don’t generate any code when you compile your application to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I’ll guide you through an extended example of how we work with
    classes in TypeScript, so that you can gain some intuition not only for TypeScript’s
    object-oriented language features, but for how and why we use them. Try to follow
    along, entering the code in your code editor as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re going to build a chess engine. Our engine will model a game of chess and
    provide an API for two players to take turns making moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by sketching out the types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are six types of pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Every piece has a color and a current position. In chess, positions are modeled
    as (letter, number) coordinate pairs; letters run from left to right along the
    x-axis, numbers from bottom to top along the y-axis ([Figure 5-1](#standard-alg-fig)).
  prefs: []
  type: TYPE_NORMAL
- en: '![prts 0501](assets/prts_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1\. Standard algebraic notation in chess: A–H (the x-axis) are called
    “files” and 1–8 (the inverted y-axis) “ranks”'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s add color and position to our `Piece` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#icon_in_code_classes__amp__oop_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Since there are relatively few colors, ranks, and files, we can manually enumerate
    their possible values as type literals. This will let us squeeze out some extra
    safety by constraining these types’ domains from all strings and all numbers to
    a handful of very specific strings and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#icon_in_code_classes__amp__oop_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `private` *access modifier* in the constructor automatically assigns the
    parameter to `this` (`this.file` and so on), and sets its visibility to private,
    meaning that code within a `Piece` instance can read and write to it, but code
    outside of a `Piece` instance can’t. Different instances of `Piece` can access
    each other’s private members; instances of any other class—even a subclass of
    `Piece`—can’t.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#icon_in_code_classes__amp__oop_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the instance variable `position` as `protected`. Like `private`,
    `protected` assigns the property to `this`, but unlike `private`, `protected`
    makes the property visible both to instances of `Piece` and to instances of any
    subclass of `Piece`. We didn’t assign `position` a value when declaring it, so
    we have to assign a value to it in `Piece`’s constructor function. If we hadn’t
    assigned it a value in the constructor, TypeScript would have told us that the
    variable is not *definitely assigned*, i.e., we said it’s of type `T`, but it’s
    actually `T | undefined` because it’s not assigned a value in a property initializer
    or in the constructor—so we would need to update its signature to indicate that
    it’s not necessarily a `Position`, but it might also be `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#icon_in_code_classes__amp__oop_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`new Piece` takes three parameters: `color`, `file`, and `rank`. We added two
    modifiers to `color`: `private`, meaning assign it to `this` and make sure it’s
    only accessible from an instance of `Piece`, and `readonly`, meaning that after
    this initial assignment it can only be read and can’t be written anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TSC Flags: strictNullChecks and strictPropertyInitialization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To opt into definite assignment checks for class instance variables, enable
    `strictNullChecks` and `strictPropertyInitialization` flags in your *tsconfig.json*.
    If you’re already using the `strict` flag, you’re good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript supports three access modifiers for properties and methods on a
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible from anywhere. This is the default access level.
  prefs: []
  type: TYPE_NORMAL
- en: '`protected`'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible from instances of this class and its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '`private`'
  prefs: []
  type: TYPE_NORMAL
- en: Accessible from instances of this class only.
  prefs: []
  type: TYPE_NORMAL
- en: Using access modifiers, you can design classes that don’t expose too much information
    about their implementations, and instead expose well-defined APIs for others to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve defined a `Piece` class, but we don’t want users to instantiate a new
    `Piece` directly—we want them to extend it to create a `Queen`, a `Bishop`, and
    so on, and instantiate *that*. We can use the type system to enforce that for
    us, using the `abstract` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you try to instantiate a `Piece` directly, TypeScript complains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `abstract` keyword means that you can’t instantiate the class directly,
    but it doesn’t mean you can’t define some methods on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Piece` class now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tells its subclasses that they have to implement a method called `canMoveTo`
    that is compatible with the given signature. If a class extends `Piece` but forgets
    to implement the abstract `canMoveTo` method, that’s a type error at compile time:
    when you implement an abstract class, you have to implement its abstract methods
    too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comes with a default implementation for `moveTo` (which its subclasses can override
    if they want). We didn’t put an access modifier on `moveTo`, so it’s `public`
    by default, meaning it’s readable and writable from any other code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s update `King` to implement `canMoveTo`, to satisfy this new requirement.
    We’ll also implement a `distanceFrom` function for convenience, so we can easily
    compute the distance between two pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we make a new game, we’ll automatically create a board and some pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because of how strictly we typed `Rank` and `File`, if we had entered another
    letter (like `'J'`) or an out-of-range number (like `12`), TypeScript would have
    given us a compile-time error ([Figure 5-2](#typescript-valid-fig)).
  prefs: []
  type: TYPE_NORMAL
- en: '![prts 0502](assets/prts_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. TypeScript helps us stick to valid ranks and files
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is enough to show off how TypeScript classes work—I’ll avoid getting into
    the nitty-gritty details like how to know when a knight can take a piece, how
    bishops move, and so on. If you’re ambitious, see if you can use what we’ve done
    so far as a starting point to implement the rest of the game yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare classes with the `class` keyword. Extend them with the `extends` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes can be either concrete or `abstract`. Abstract classes can have `abstract`
    methods and `abstract` properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can be `private`, `protected`, or, by default, `public`. They can be
    instance methods or static methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes can have instance properties, which can also be `private`, `protected`,
    or, by default, `public`. You can declare them in constructor parameters or as
    property initializers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mark instance properties as `readonly` when declaring them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: super
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like JavaScript, TypeScript supports `super` calls. If your child class overrides
    a method defined on its parent class (say, if `Queen` and `Piece` both implement
    the `take` method), the child instance can make a `super` call to call its parent’s
    version of the method (e.g., `super.take`). There are two kinds of `super` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: Method calls, like `super.take`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor calls, which have the special form `super()` and can only be called
    from a constructor function. If your child class has a constructor function, you
    must call `super()` from the child’s constructor to correctly wire up the class
    (don’t worry, TypeScript will warn you if you forget; it’s like a cool futuristic
    robot elephant in that way).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that you can only access a parent class’s methods, and not its properties,
    with `super`.
  prefs: []
  type: TYPE_NORMAL
- en: Using this as a Return Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like you can use `this` as a value, you can also use it as a type (like
    we did in [“Typing this”](ch04.html#typing-this)). When working with classes,
    the `this` type can be useful for annotating methods’ return types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s build a simplified version of ES6’s `Set` data structure
    that supports two operations: adding a number to the set, and checking whether
    or not a given number is in the set. You use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s define the `Set` class, starting with the `has` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'How about `add`? When you call `add`, you get back an instance of `Set`. We
    could type that as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good. What happens when we try to subclass `Set`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, `Set`’s `add` method still returns a `Set`, which we’ll need to
    override with `MutableSet` for our subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This can get a bit tedious when working with classes that extend other classes—you
    have to override the signature for each method that returns `this`. And if you
    end up having to override each method to please the typechecker, what’s the point
    of inheriting from your base class at all?
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you can use `this` as a return type annotation to let TypeScript do
    the work for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can remove the `add` override from `MutableSet`, since `this` in `Set`
    points to a `Set` instance, and `this` in `MutableSet` points to a `MutableSet`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is a really convenient feature for working with chained APIs, like we do
    in [“Builder Pattern”](#builder-pattern).
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use classes, you will often find yourself using them with *interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like type aliases, interfaces are a way to name a type so you don’t have to
    define it inline. Type aliases and interfaces are mostly two syntaxes for the
    same thing (like function expressions and function declarations), but there are
    a few small differences. Let’s start with what they have in common. Consider the
    following type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s easy to rewrite it as an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Everywhere you used your `Sushi` type alias, you can also use your `Sushi` interface.
    Both declarations define shapes, and those shapes are assignable to one another
    (in fact, they’re identical!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get more interesting when you start combining types. Let’s model another
    food in addition to `Sushi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of foods have calories and are tasty—not just `Sushi` and `Cake`. Let’s
    pull `Food` out into its own type, and redefine our foods in terms of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Nearly equivalently, you can do that with interfaces too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Interfaces don’t have to extend other interfaces. In fact, an interface can
    extend any shape: an object `type`, a `class`, or another `interface`.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between types and interfaces? There are three, and
    they’re subtle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is that type aliases are more general, in that their righthand side
    can be any type, including a type expression (a type, and maybe some type operators
    like `&` or `|`); for an interface, the righthand side must be a shape. For example,
    there is no way to rewrite the following type aliases as interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second difference is that when you extend an interface, TypeScript will
    make sure that the interface you’re extending is assignable to your extension.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not the case when you use intersection types: if you turn the interfaces
    from the last example into type aliases and the `extends` into an intersection
    (`&`), TypeScript will do its best to combine your extension with the type it’s
    extending, resulting in an overloaded signature for `bad` instead of a compile-time
    error (try it in your code editor!).'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re modeling inheritance for object types, the assignability check that
    TypeScript does for interfaces can be a helpful tool to catch errors.
  prefs: []
  type: TYPE_NORMAL
- en: The third difference is that multiple interfaces with the same name in the same
    scope are automatically merged; multiple *type aliases* with the same name in
    the same scope will throw a compile-time error. This is a feature called *declaration
    merging*.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration Merging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaration merging is TypeScript’s way of automatically combining multiple
    declarations that share the same name. It came up when we introduced enums ([“Enums”](ch03.html#enums)),
    and it also comes up when working with other features like `namespace` declarations
    (see [“Namespaces”](ch10.html#namespaces)). In this section we’ll briefly introduce
    declaration merging in the context of interfaces. For a deeper dive, head over
    to [“Declaration Merging”](ch10.html#namespace-merging).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you declare two identically named `User` interfaces, then TypeScript
    will automatically combine them for you into a single interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what happens if you repeat that example with type aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the two interfaces can’t conflict; if one types `property` as a `T`
    and the other types it as a `U`, and `T` and `U` aren’t identical, then you’ll
    get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And if your interface declares generics (skip ahead to [“Polymorphism”](#class-generics)
    to learn more), those generics have to be declared the exact same way for two
    interfaces to be mergeable—down to the generic’s name!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, this is a rare place where TypeScript checks that two types are
    not only assignable, but *identical*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you declare a class, you can use the `implements` keyword to say that it
    satisfies a particular interface. Like other explicit type annotations, this is
    a convenient way to add a type-level constraint that your class is implemented
    correctly as closely as possible to the implementation itself, so that the error
    from an incorrect implementation doesn’t show up downstream where it’s less clear
    why it was thrown. It’s also a familiar way to implement common design patterns
    like adapters, factories, and strategies (see the end of this chapter for some
    examples).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`Cat` has to implement every method that `Animal` declares, and can implement
    more methods and properties on top if it wants.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces can declare instance properties, but they can’t declare visibility
    modifiers (`private`, `protected`, and `public`) and they can’t use the `static`
    keyword. You can also mark instance properties as `readonly`, just like we did
    for object types in Objects (in [Chapter 3](ch03.html#types)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re not limited to implementing just one interface—you can implement as
    many as you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All of these features are completely typesafe. If you forget to implement a
    method or a property, or implement it incorrectly, TypeScript will come to the
    rescue (see [Figure 5-3](#typescript-error-fig)).
  prefs: []
  type: TYPE_NORMAL
- en: '![prts 0503](assets/prts_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. TypeScript throws an error when you forget to implement a required
    method
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Implementing Interfaces Versus Extending Abstract Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing an interface is really similar to extending an abstract class.
    The difference is that interfaces are more general and lightweight, and abstract
    classes are more special-purpose and feature-rich.
  prefs: []
  type: TYPE_NORMAL
- en: An interface is a way to model a shape. At the value level, that means an object,
    array, function, class, or class instance. Interfaces do not emit JavaScript code,
    and only exist at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can only model, well, a class. It emits runtime code that
    is, you guessed it, a JavaScript class. Abstract classes can have constructors,
    provide default implementations, and set access modifiers for properties and methods.
    Interfaces can’t do any of those things.
  prefs: []
  type: TYPE_NORMAL
- en: Which one you use depends on your use case. When an implementation is shared
    among multiple classes, use an abstract class. When you need a lightweight way
    to say “this class is a `T`,” use an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Classes Are Structurally Typed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like every other type in TypeScript, TypeScript compares classes by their structure,
    not by their name. A class is compatible with any other type that shares its shape,
    including a regular old object that defines the same properties or methods as
    the class. This is important to keep in mind for those of you coming from C#,
    Java, Scala, and most other languages where classes are typed nominally. It means
    that if you have a function that takes a `Zebra` and you give it a `Poodle`, TypeScript
    might not mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As the phylogeneticists among you know, a zebra is no poodle—but TypeScript
    doesn’t mind! As long as `Poodle` is assignable to `Zebra`, TypeScript is OK with
    it because from our function’s point of view, the two are interchangeable; all
    that matters is that they implement `.trot`. If you were using almost any other
    language that types classes nominally, this code would have raised an error; but
    TypeScript is structurally typed through and through, so this code is perfectly
    acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception to this rule is classes with `private` or `protected` fields:
    when checking whether or not a shape is assignable to a class, if the class has
    any `private` or `protected` fields and the shape is not an instance of that class
    or a subclass of that class, then the shape is not assignable to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Classes Declare Both Values and Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most things that you can express in TypeScript are either values *or* types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Types and values are namespaced separately in TypeScript. Depending on how
    you use a term (`a` or `b` in this example), TypeScript knows whether to resolve
    it to a type or to a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This *contextual term resolution* is really nice, and lets us do cool things
    like implement companion types (see [“Companion Object Pattern”](ch06.html#companion-objects)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes and enums are special. They are unique because they generate both a
    type in the type namespace and a value in the value namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, `C` refers to the instance type of our `C` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, `C` refers to `C` the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_interfaces_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, `E` refers to the type of our `E` enum.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_interfaces_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, `E` refers to `E` the value.
  prefs: []
  type: TYPE_NORMAL
- en: When we work with classes, we need a way to say “this variable should be an
    instance of this class” and the same goes for enums (“this variable should be
    a member of this enum”). Because classes and enums generate types at the type
    level we’re able to express this “is-a” relationship easily.^([2](ch05.html#idm46304971345608))
  prefs: []
  type: TYPE_NORMAL
- en: We also need a way to represent a class at runtime, so that we can instantiate
    it with `new`, call static methods on it, do metaprogramming with it, and operate
    on it with `instanceof`—so a class needs to generate a value too.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example `C` refers to an *instance of* the class `C`. How do
    you talk about the `C` class itself? We use the `typeof` keyword (a type operator
    provided by TypeScript, which is like JavaScript’s value-level `typeof` but for
    types).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a class `StringDatabase`—the world’s simplest database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What types does this class declaration generate? The instance type `StringDatabase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And the constructor type `typeof StringDatabase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That is, `StringDatabaseConstructor` has a single method `.from`, and `new`-ing
    the constructor gives a `StringDatabase` instance. Combined, these two interfaces
    model both the constructor and instance sides of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'That `new()` bit is called a *constructor signature*, and is TypeScript’s way
    of saying that a given type can be instantiated with the `new` operator. Because
    TypeScript is structurally typed, that’s the best we can do to describe what a
    class is: a class is anything that can be `new`-ed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case the constructor doesn’t take any arguments, but you can use it
    to declare constructors that take arguments too. For example, say we update `StringDatabase`
    to take an optional initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then type `StringDatabase`’s constructor signature as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, not only does a class declaration generate terms at the value and type
    levels, but it generates two terms at the type level: one representing an instance
    of the class; one representing the class constructor itself (reachable with the
    `typeof` type operator).'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like functions and types, classes and interfaces have rich support for generic
    type parameters, including defaults and bounds. You can scope a generic to your
    whole class or interface, or to a specific method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Bind class-scoped generic types when you declare your `class`. Here, `K` and
    `V` are available to every instance method and instance property on `MyMap`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you cannot declare generic types in a `constructor`. Instead, move
    the declaration up to your `class` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_interfaces_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use class-scoped generic types anywhere inside your class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_interfaces_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Instance methods have access to class-level generics, and can also declare their
    own generics on top. `.merge` makes use of the `K` and `V` class-level generics,
    and also declares two of its own generics, `K1` and `V1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_classes_and_interfaces_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Static methods do not have access to their class’s generics, just like at the
    value level they don’t have access to their class’s instance variables. `of` does
    not have access to the `K` and `V` declared in [![1](assets/1.png)](#co_classes_and_interfaces_CO2-1);
    instead, it declares its own `K` and `V` generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can bind generics to interfaces too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And like with functions, you can bind concrete types to generics explicitly,
    or let TypeScript infer the types for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript and TypeScript don’t have `trait` or `mixin` keywords, but it’s straightforward
    to implement them ourselves. Both are ways to simulate *multiple inheritance*
    (classes that extend more than one other class) and do *role-oriented programming*,
    a style of programming where you don’t say things like “this thing is a `Shape`"
    but instead describe properties of a thing, like “it can be measured” or “it has
    four sides.” Instead of “is-a” relationships, you describe “can” and “has-a” relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build a mixin implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixins are a pattern that allows us to *mix* behaviors and properties *into*
    a class. By convention, mixins:'
  prefs: []
  type: TYPE_NORMAL
- en: Can have state (i.e., instance properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can only provide concrete methods (not abstract ones)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can have constructors, which are called in the same order as their classes were
    mixed in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TypeScript doesn’t have a built-in concept of mixins, but it’s easy to implement
    them ourselves. For example, let’s design a debugging library for TypeScript classes.
    We’ll call it `EZDebug`. The library works by letting you log out information
    about whatever classes use the library, so that you can inspect them at runtime.
    We’ll use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With a standard `.debug` interface, our users will be able to debug anything!
    Let’s build it. We’ll model it with a mixin, which we’ll call `withEZDebug`. A
    mixin is just a function that takes a class constructor and returns a class constructor,
    so our mixin might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We start by declaring a type `ClassConstructor`, which represents any constructor.
    Since TypeScript is completely structurally typed, we say that a constructor is
    anything that can be `new`-ed. We don’t know what types of parameters the constructor
    might have, so we say it takes any number of arguments of any type.^([3](ch05.html#idm46304970560536))
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare our `withEZDebug` mixin with a single type parameter, `C`. `C` has
    to be at least a class constructor, which we enforce with an `extends` clause.
    We let TypeScript infer `withEZDebug`’s return type, which is the intersection
    of `C` and our new anonymous class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_interfaces_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Since a mixin is a function that takes a constructor and returns a constructor,
    we return an anonymous class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_interfaces_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The class constructor has to take *at least* the arguments that the class you
    pass in might take. But remember, since we don’t know what class you might pass
    in beforehand, I have to keep it as general as possible, which means any number
    of parameters of any type—just like `ClassConstructor`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_classes_and_interfaces_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since this anonymous class extends another class, to wire everything
    up correctly we need to remember to call `Class`’s constructor too.
  prefs: []
  type: TYPE_NORMAL
- en: Like with regular JavaScript classes, if you don’t have any more logic in the
    `constructor`, you can omit lines [![4](assets/4.png)](#co_classes_and_interfaces_CO3-4)
    and [![5](assets/5.png)](#co_classes_and_interfaces_CO3-5). We aren’t going to
    put any logic into the constructor for this `withEZDebug` example, so we can omit
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve set up the boilerplate, it’s time to work some debugging magic.
    When we call `.debug`, we want to log out the class’s constructor name and the
    instance’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: But wait! How do we make sure the class implements a `.getDebugValue` method,
    so that we can call it? Think about this for a second before you move on—can you
    figure it out?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that instead of accepting any old class, we use a generic type
    to make sure the class passed into `withEZDebug` defines a `.getDebugValue` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![](assets/1.png)](#callout_5_1)'
  prefs: []
  type: TYPE_NORMAL
- en: We add a generic type parameter to `ClassConstructor`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](assets/2.png)](#callout_5_2)'
  prefs: []
  type: TYPE_NORMAL
- en: We bind a shape type to `ClassConstructor`, `C`, enforcing that the constructor
    we passed to `withEZDebug` at least defines the `.getDebugValue` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it! So, how do you use this incredible debugging utility? Like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right? You can apply as many mixins to a class as you want to yield a
    class with richer and richer behavior, all in a typesafe way. Mixins help encapsulate
    behavior, and are an expressive way to specify reusable behaviors.^([4](ch05.html#idm46304970288936))
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators are an experimental TypeScript feature that gives us a clean syntax
    for metaprogramming with classes, class methods, properties, and method parameters.
    They’re just a syntax for calling a function on the thing you’re decorating.
  prefs: []
  type: TYPE_NORMAL
- en: 'TSC Flag: experimentalDecorators'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because they’re still experimental—meaning they may change in a backward-incompatible
    way, or may even be entirely removed in future TypeScript releases—decorators
    are hidden behind a TSC flag. If you’re OK with that, and want to play around
    with the feature, set `"experimentalDecorators": true` in your *tsconfig.json*
    and read on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a sense for how decorators work, let’s start with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@serializable` class decorator wraps our `APIPayload` class, and optionally
    returns a new class that replaces it. Without decorators, you might implement
    the same thing with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For each type of decorator, TypeScript requires that you have a function in
    scope with the given name and the required signature for that type of decorator
    (see [Table 5-1](#expected-type-table)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Expected type signatures for the different kinds of decorator functions
  prefs: []
  type: TYPE_NORMAL
- en: '| What you’re decorating | Expected type signature |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Class | `(Constructor: {new(...any[]) => any}) => any` |'
  prefs: []
  type: TYPE_TB
- en: '| Method | `(classPrototype: {}, methodName: string, descriptor:` `PropertyDescriptor``)
    => any` |'
  prefs: []
  type: TYPE_TB
- en: '| Static method | `(Constructor: {new(...any[]) => any}, methodName: string,
    descriptor: PropertyDescriptor) => any` |'
  prefs: []
  type: TYPE_TB
- en: '| Method parameter | `(classPrototype: {}, paramName: string, index: number)
    => void` |'
  prefs: []
  type: TYPE_TB
- en: '| Static method parameter | `(Constructor: {new(...any[]) => any}, paramName:
    string, index: number) => void` |'
  prefs: []
  type: TYPE_TB
- en: '| Property | `(classPrototype: {}, propertyName: string) => any` |'
  prefs: []
  type: TYPE_TB
- en: '| Static property | `(Constructor: {new(...any[]) => any}, propertyName: string)
    => any` |'
  prefs: []
  type: TYPE_TB
- en: '| Property getter/setter | `(classPrototype: {}, propertyName: string, descriptor:`
    `PropertyDescriptor``) => any` |'
  prefs: []
  type: TYPE_TB
- en: '| Static property getter/setter | `(Constructor: {new(...any[]) => any}, propertyName:
    string, descriptor: PropertyDescriptor) => any` |'
  prefs: []
  type: TYPE_TB
- en: 'TypeScript doesn’t come with any built-in decorators: whatever decorators you
    use, you have to implement yourself (or install from NPM). The implementation
    for each kind of decorator—for classes, methods, properties, and function parameters—is
    a regular function that satisfies a specific signature, depending on what it’s
    decorating. For example, our `@serializable` decorator might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, `new()` is how we structurally type a class constructor in TypeScript.
    And for a class constructor that can be extended (with `extends`), TypeScript
    requires that we type its arguments with an `any` spread: `new(...any[])`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@serializable` can decorate any class whose instances implement the method
    `.getValue`, which returns a `Payload`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_interfaces_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Class decorators are functions that take a single argument—the class. If the
    decorator function returns a class (as in the example) it will replace the class
    it’s decorating at runtime; otherwise, it will return the original class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_interfaces_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: To decorate the class, we return a class that extends it and adds a `.serialize`
    method along the way.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we try to call `.serialize`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript assumes that a decorator doesn’t change the shape of the thing it’s
    decorating—meaning that you didn’t add or remove methods and properties. It checks
    at compile time that the class you returned is assignable to the class you passed
    in, but at the time of writing, TypeScript does not keep track of extensions you
    make in your decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until decorators in TypeScript become a more mature feature, I recommend you
    avoid using them and stick to regular functions instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We won’t delve more deeply into decorators in this book. For more information,
    head over to the [official documentation](http://bit.ly/2IDQd1U).
  prefs: []
  type: TYPE_NORMAL
- en: Simulating final Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though TypeScript doesn’t support the `final` keyword for classes or methods,
    it’s easy to simulate it for classes. If you haven’t worked much with object-oriented
    languages before, `final` is the keyword some languages use to mark a class as
    nonextensible, or a method as nonoverridable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simulate `final` classes in TypeScript, we can take advantage of private
    constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When a `constructor` is marked `private`, you can’t `new` the class or extend
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as preventing you from extending the class—which is what we want—private
    constructors also prevent you from directly instantiating it. But for `final`
    classes we do want the ability to instantiate a class, just not to extend it.
    How do we keep the first restriction but get rid of the second? Easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes `MessageQueue`’s API a bit, but it does a great job of preventing
    extensions at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This wouldn’t be a chapter on object-oriented programming if we didn’t walk
    through implementing a design pattern or two in TypeScript, right?
  prefs: []
  type: TYPE_NORMAL
- en: Factory Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *factory pattern* is a way to create objects of some type, leaving the decision
    of which concrete object to create to the specific factory that creates that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build a shoe factory. We’ll start by defining a `Shoe` type, and a few
    kinds of shoes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that this example uses a `type`, but we could have just as well used an
    `interface` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make a shoe factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_interfaces_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Using a union type for `type` helps make `.create` as typesafe as possible,
    preventing consumers from passing in an invalid `type` at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_interfaces_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Switching on `type` makes it easy for TypeScript to enforce that we’ve handled
    every type of `Shoe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example we use the companion object pattern (see [“Companion Object
    Pattern”](ch06.html#companion-objects)) to declare a type `Shoe` and a value `Shoe`
    with the same name (remember that TypeScript has separate namespaces for values
    and for types), as a way to signal that the value provides methods for operating
    on the type. To use the factory, we can just call `.create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We have a factory pattern. Note that we could have gone further and indicated
    in `Shoe.create`’s type signature that passing in `'boot'` will give a `Boot`,
    `'sneaker'` will give a `Sneaker`, and so on, but that would break the abstraction
    that the factory pattern gives us (that the consumer shouldn’t know what concrete
    class they’ll get back, just that the class satisfies a particular interface).
  prefs: []
  type: TYPE_NORMAL
- en: Builder Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *builder pattern* is a way to separate the construction of an object from
    the way that object is actually implemented. If you’ve used JQuery, or ES6 data
    structures like `Map` and `Set`, this style of API should look familiar. Here’s
    what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we implement `RequestBuilder`? Easy—we’ll start with a bare class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'First we’ll add the `.setURL` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[![](assets/1.png)](#co_5_2_1)'
  prefs: []
  type: TYPE_NORMAL
- en: We keep track of the URL the user set in a private instance variable `url`,
    which we initialize to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](assets/2.png)](#co_5_2_2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`setURL`’s return type is `this` (see [“Using this as a Return Type”](#this-in-return-type)),
    that is, the specific instance of `RequestBuilder` that the user called `setURL`
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s add the other methods from our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This traditional builder design is not completely safe: we can call `.send`
    before we set the method, URL, or data, resulting in a runtime exception (remember,
    that’s the bad kind of exception). See Exercise 4 for some ideas about how to
    improve this design.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve now explored TypeScript classes from all sides: how to declare classes;
    how to inherit from classes and implement interfaces; how to mark classes as `abstract`
    so they can’t be instantiated; how to put a field or method on a class with `static`
    and on an instance without it; how to control access to a field or method with
    the `private`, `protected`, and `public` visibility modifiers; and how to mark
    a field as nonwritable using the `readonly` modifier. We’ve covered how to safely
    use `this` and `super`, explored what it means for classes to be both values and
    types at the same time, and talked about the differences between type aliases
    and interfaces, the basics of declaration merging, and using generic types in
    classes. Finally, we covered a few more advanced patterns for working with classes:
    mixins, decorators, and simulating `final` classes. And to cap the chapter off,
    we went through and derived a couple of common patterns for working with classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the differences between a class and an interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you mark a class’s constructor as `private`, that means you can’t instantiate
    or extend the class. What happens when you mark it as `protected` instead? Play
    around with this in your code editor, and see if you can figure it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extend the implementation we developed [“Factory Pattern”](#factory-pattern)
    to make it safer, at the expense of breaking the abstraction a bit. Update the
    implementation so that a consumer knows at compile time that calling `Shoe.create(''boot'')`
    returns a `Boot` and calling `Shoe.create(''balletFlat'')` returns a `BalletFlat`
    (rather than both returning a `Shoe`). Hint: think back to [“Overloaded Function
    Types”](ch04.html#function-overloads).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Hard] As an exercise, think about how you might design a typesafe builder
    pattern. Extend the Builder pattern [“Builder Pattern”](#builder-pattern) to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Guarantee at compile time that someone can’t call `.send` before setting at
    least a URL and a method. Would it be easier to make this guarantee if you also
    force the user to call methods in a specific order? (Hint: what can you return
    instead of `this`?)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Harder] How would you change your design if you wanted to make this guarantee,
    but still let people call methods in any order? (Hint: what TypeScript feature
    can you use to make each method’s return type “add” to the `this` type after each
    method call?)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ^([1](ch05.html#idm46304973683464-marker)) Or are on track to soon be supported
    by JavaScript classes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.html#idm46304971345608-marker)) Because TypeScript is structurally
    typed, of course, the relationship for classes is more of a “looks-like”—any object
    that implements the same shape as your class will be assignable to the type of
    your class.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch05.html#idm46304970560536-marker)) Note that TypeScript is picky here:
    the type of a constructor type’s arguments has to be `any[]` (not `void`, `unknown[]`,
    etc.) in order for us to be able to extend it.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch05.html#idm46304970288936-marker)) A handful of languages—Scala, PHP,
    Kotlin, and Rust, to name a few—implement a pared-down version of mixins, called
    *traits*. Traits are like mixins, but don’t have constructors and don’t support
    instance properties. This makes it easier to wire them up and prevent collisions
    between multiple traits accessing state that is shared between them and the base
    class.
  prefs: []
  type: TYPE_NORMAL
