- en: Chapter 10\. React Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to keep up with our competitors, we must move quickly while ensuring
    quality. One vital tool that allows us to do this is *unit testing*. Unit testing
    makes it possible to verify that every piece, or unit, of our application functions
    as intended.^([1](ch10.html#idm45901621151704))
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of practicing functional techniques is that they lend themselves
    to writing testable code. Pure functions are naturally testable. Immutability
    is easily testable. Composing applications out of small functions designed for
    specific tasks produces testable functions or units of code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll demonstrate techniques that can be used to unit test
    React applications. This chapter will not only cover testing, but also tools that
    can be used to help evaluate and improve your code and your tests.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most programming languages, code needs to be compiled before you can run
    anything. Programming languages have pretty strict rules about coding style and
    will not compile until the code is formatted appropriately. JavaScript does not
    have those rules and does not come with a compiler. We write code, cross our fingers,
    and run it in the browser to see if it works or not. The good news is that there
    are tools we can use to analyze our code and make us stick to specific formatting
    guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: The process of analyzing JavaScript code is called *hinting* or *linting*. JSHint
    and JSLint are the original tools used to analyze JavaScript and provide feedback
    about formatting. [ESLint](http://eslint.org) is the latest code linter that supports
    emerging JavaScript syntax. Additionally, ESLint is pluggable. This means we can
    create and share plug-ins that can be added to ESLint configurations to extend
    its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint is supported out of the box with Create React App, and we’ve already
    seen lint warnings and errors appear in the console.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be working with a plug-in called [`eslint-plugin-react`](https://oreil.ly/3yeXO).
    This plug-in will analyze our JSX and React syntax in addition to our JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install `eslint` as a dev dependency. We can install `eslint` with npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before we use ESLint, we’ll need to define some configuration rules that we
    can agree to follow. We’ll define these in a configuration file that’s located
    in our project root. This file can be formatted as JSON or YAML. [YAML](http://yaml.org)
    is a data serialization formation like JSON but with less syntax, making it a
    little easier for humans to read.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint comes with a tool that helps us set up configuration. There are several
    companies that have created ESLint config files that we can use as a starting
    point, or we can create our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an ESLint configuration by running `eslint --init` and answering
    some questions about our coding style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After `npx eslint --init` runs, three things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eslint-plugin-react` is installed locally to the *./node_modules* folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These dependencies are automatically added to the *package.json* file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A configuration file, *.eslintrc.json*, is created and added to the root of
    our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we open *.eslintrc.json*, we’ll see an object of settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Importantly, if we look at the `extends` key, we’ll see that our `--init` command
    initalized defaults for `eslint` and `react`. This means that we don’t have to
    manually configure all of the rules. Instead, those rules are provided to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test our ESLint configuration and these rules by creating a *sample.js*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This file has some issues, but nothing that would cause errors in the browser.
    Technically, this code works just fine. Let’s run ESLint on this file and see
    what feedback we get based on our customized rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ESLint has performed a static analysis of our code and is reporting some issues
    based on our configuration choices. There are errors about property validation,
    and ESLint also complains about `__filename` and `__dirname` because it does not
    automatically include Node.js globals. And finally, ESLint’s default React warnings
    let us know that React must be in scope when using JSX.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command `eslint .` will lint our entire directory. To do this, we’ll most
    likely require that ESLint ignore some JavaScript files. The *.eslintignore* file
    is where we can add files or directories for ESLint to ignore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This *.eslintignore* file tells ESLint to ignore our new *sample.js* file as
    well as anything in the *dist/assets* folder. If we don’t ignore the *assets*
    folder, ESLint will analyze the client *bundle.js* file, and it will probably
    find a lot to complain about in that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a script to our *package.json* file for running ESLint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now ESLint can be run any time we want with `npm run lint`, and it will analyze
    all of the files in our project except the ones we’ve ignored.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint Plug-Ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a multitude of plug-ins that can be added to your ESLint configuration
    to help you as you’re writing code. For a React project, you’ll definitely want
    to install [`eslint-plugin-react-hooks`](https://reactjs.org/docs/hooks-rules.html),
    a plug-in to enforce the rules of React Hooks. This package was released by the
    React team to help fix bugs related to Hooks usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the *.eslintrc.json* file and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This plug-in will check to ensure that functions that start with the word “use”
    (assumed to be a hook) are following the rules of Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this has been added, we’ll write some sample code to test the plug-in.
    Adjust the code in *sample.js*. Even though this code won’t run, we’re testing
    to see if the plug-in is working appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Several errors will pop up from this code, but most importantly, there’s the
    error that lets us know we’re trying to call `useState` in a function that isn’t
    a component or a hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These shoutouts will help us along the way as we learn the ins and outs of working
    with Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful ESLint plug-in to incorporate into your projects is `eslint-plugin-jsx-a11y`.
    A11y is a numeronym, which means that there are 11 letters between the “a” and
    the “y” in accessibility. When we consider accessibility, we build tools, websites,
    and technologies that can be used by people with disabilities.
  prefs: []
  type: TYPE_NORMAL
- en: This plug-in will analyze your code and ensure that it’s not breaking any accessibility
    rules. Accessibility should be an area of focus for all of us, and working with
    this plug-in will promote good practices when writing accessible React applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install, we’ll use npm or yarn again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll add to our config, *.eslintrc.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s test it. We’ll adjust our *sample.js* file to include an image tag
    that has no alt property. In order for an image to pass a lint check, it must
    have an alt prop or an empty string if the image doesn’t affect the user’s understanding
    of the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run lint again with `npm run lint`, we’ll see that there’s a new error
    that’s called by the `jsx/a11y` plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are many other ESLint plug-ins you can use to statically analyze your
    code, and you could spend weeks tuning your ESLint config to perfection. If you’re
    looking to take yours to the next level, there are many useful resources in the
    [Awesome ESLint repository](https://github.com/dustinspecker/awesome-eslint).
  prefs: []
  type: TYPE_NORMAL
- en: Prettier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prettier is an opinionated code formatter you can use on a range of projects.
    The effect Prettier has had on the day-to-day work of web developers since its
    release has been pretty incredible. Based on historical records, arguing over
    syntax filled 87% of an average JavaScript developer’s day, but now Prettier handles
    code formatting and defining the rules around what code syntax should be used
    per project. The time savings are significant. Also, if you’ve ever unleashed
    Prettier on a Markdown table, the quick, crisp formatting that occurs is a pretty
    incredible sight to behold.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint used to be in charge of code formatting for many projects, but now there’s
    a clear delineation of responsibilities. ESLint handles code-quality concerns.
    Prettier handles code formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make Prettier work with ESLint, we’ll tinker with the configuration of our
    project a bit more. You can install Prettier globally to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now you can use Prettier anywhere on any project.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Prettier by Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a Prettier configuration file to your project, you can create a *.prettierrc*
    file. This file will describe the project defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These are our preferred defaults, but of course, choose what makes most sense
    to you. For more Prettier formatting options, check out [Prettier’s documentation](https://prettier.io/docs/en/options.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s replace what currently lives in our *sample.js* file with some code to
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s try running the Prettier CLI from the Terminal or Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Prettier runs the test and shows us the following message: `Code style issues
    found in the above file(s). Forgot to run Prettier?` To run it from the CLI, we
    can pass the `write` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once we do this, we’ll see an output of a certain number of milliseconds that
    it took Prettier to format the file. If we open the file, we’ll see that the content
    has changed based on the defaults supplied in the *.prettierrc* file. If you’re
    thinking that this process seems laborious and could be sped up, you’re right.
    Let’s start automating!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll integrate ESLint and Prettier by installing a config tool and
    a plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The config (`eslint-config-prettier`) turns off any ESLint rules that could
    conflict with Prettier. The plug-in (`eslint-plugin-prettier`) integrates Prettier
    rules into ESLint rules. In other words, when we run our `lint` script, Prettier
    will run, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll incorporate these tools into *.eslintrc.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to break some formatting rules in your code to ensure that Prettier
    is working. For example, in *sample.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the lint command `npm run lint` will yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the errors were found. Now you can run the Prettier write command and
    sweep the formatting for one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for all of the JavaScript files in certain folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Prettier in VSCode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re using VSCode, it’s highly recommended that you set up Prettier in
    your editor. Configuration is fairly quick and will save you a lot of time as
    you’re writing code.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll first want to install the VSCode extension for Prettier. Just follow
    [this link](https://oreil.ly/-7Zgz) and click Install. Once installed, you can
    run Prettier with Control + Command + P on a Mac or Ctrl + Shift + P on a PC to
    manually format a file or highlighted bit of code. For even better results, you
    can format your code on Save. This involves adding some settings to VSCode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access these settings, select the Code menu, then Preferences, then Settings.
    (Or Command + comma on a Mac or Ctrl + comma on a PC, if you’re in a hurry.) Then
    you can click on the small paper icon in the upper right-hand corner to open the
    VSCode settings as JSON. You’ll want to add a few helpful keys here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now when you save any file, Prettier will format it based on the `.prettierrc`
    defaults! Pretty killer. You can also search Settings for Prettier options to
    set up defaults in your editor if you want to enforce formatting, even if your
    project doesn’t contain a *.prettierrc* config file.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a different editor, Prettier likely supports that, too. For
    instructions specific to other code editors, check out the [Editor Integration
    section of the docs](https://prettier.io/docs/en/editors.html).
  prefs: []
  type: TYPE_NORMAL
- en: Typechecking for React Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you’re working with a larger application, you may want to incorporate
    typechecking to help pinpoint certain types of bugs. There are three main solutions
    for typechecking in React apps: the `prop-types` library, Flow, and TypeScript.
    In the next section, we’ll take a closer look at how you might set up these tools
    to increase code quality.'
  prefs: []
  type: TYPE_NORMAL
- en: PropTypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first edition of this book, PropTypes were part of the core React library
    and were the recommended way to add typechecking to your application. Today, due
    to the emergence of other solutions like Flow and TypeScript, the functionality
    has been moved to its own library to make React’s bundle size smaller. Still,
    PropTypes are a widely used solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add PropTypes to your app, install the `prop-types` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll test this by creating a minimal `App` component that renders the name
    of a library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll import the `prop-types` library and use `App.propTypes` to define
    which type each property should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` component has one property `name` and should always be a string.
    If an incorrect type value is passed as the name, an error will be thrown. For
    example, if we used a boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our console would report a problem back to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When a value of an incorrect type is provided for a property, the warning only
    appears in development mode. The warnings and broken renders won’t appear in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other types are available, of course, when validating properties. We could
    add a boolean for whether or not a technology was used at a company:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The longer list of type checks includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PropTypes.array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.func`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes.symbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, if you want to ensure that a value was provided, you can chain
    `.isRequired` onto the end of any of these options. For example, if a string must
    be supplied, you’d use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if you fail to provide a value for this field, the following warning
    will appear in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There also may be situations where you don’t care what the value is, as long
    as a value is provided. In that case, you can use `any`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This means that a boolean, string, number––anything––could be supplied. As long
    as `name` is not `undefined`, the typecheck will succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the basic typechecks, there are a few other utilities that are
    useful for many real-world situations. Consider a component where there are two
    `status` options: `Open` and `Closed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Status is a string, so we might be inclined to use the string check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That works well, but if other string values besides `Open` and `Closed` are
    passed in, the property will be validated. The type of check we actually want
    to enforce is an enum check. An enumeration type is a restricted list of options
    for a particular field or property. We’ll adjust the `propTypes` object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now if anything other than the values from the array that’s passed to `PropTypes.oneOf`
    is supplied, a warning will appear.
  prefs: []
  type: TYPE_NORMAL
- en: For all the options you can configure for PropTypes in your React app, check
    out [the documentation](https://oreil.ly/pO2Js).
  prefs: []
  type: TYPE_NORMAL
- en: Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flow is a typechecking library that’s used and maintained by Facebook Open Source.
    It’s a tool that checks for errors via static type annotations. In other words,
    if you create a variable that’s a particular type, Flow will check to be sure
    that that value used is the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s fire up a Create React App project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll add Flow to the project. Create React App doesn’t assume you want
    to use Flow, so it doesn’t ship with the library, but it’s smooth to incorporate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we’ll add an npm script to run Flow when we type `npm run flow`.
    In *package.json*, just add this to the `scripts` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now running the `flow` command will run typechecking on our files. Before we
    can use it, though, we need to create a *.flowconfig* file. To do so, we run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a skeleton of a configuration file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, you’ll leave this blank to use Flow’s defaults. If you want to
    configure Flow beyond the basics, you can explore more options in [the documentation](https://flow.org/en/docs/config/).
  prefs: []
  type: TYPE_NORMAL
- en: One of the coolest features of Flow is that you can adopt Flow incrementally.
    It can feel overwhelming to have to add typechecking to an entire project. With
    Flow, this isn’t a requirement. All you need to do is add the line `//@flow` to
    the top of any files you want to typecheck, then Flow will automatically only
    check those files.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to add the VSCode extension for Flow to help with code completion
    and parameter hints. If you have Prettier or a linting tool set up, this will
    help your editor handle the unexpected syntax of Flow. You can find that [in the
    marketplace](https://oreil.ly/zdaPv).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open the *index.js* file and, for the sake of simplicity, keep everything
    in the same file. Make sure to add `//@flow` to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll define the types for the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run Flow `npm run flow`. In certain versions of Flow, you may see this
    warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This warning exists because if `document.getElementById("root")` returns `null`,
    the app will crash. To safeguard against this (and to clear the error), we can
    do one of two things. The first approach is to use an `if` statement to check
    to see that `root` is not `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to add a typecheck to the root constant using Flow syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In either case, you’ll clear the error and see that your code is free of errors!
  prefs: []
  type: TYPE_NORMAL
- en: '*No errors!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could trust this fully, but trying to break it feels like a good idea. Let’s
    pass a different property type to the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool, we broke it! Now we get an error that reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s switch it back and add another property for a number. We’ll also adjust
    the component and property definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Running this works, but what if we removed the cost value?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll immediately get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If `cost` is truly not a required value, we can make it optional in the property
    definitions using the question mark after the property name, `cost?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If we run it again, we don’t see the error.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the tip of the iceberg with all of the different features that Flow has
    to offer. To learn more and to stay on top of the changes in the library, head
    over to the [documentation site](https://flow.org/en/docs/getting-started/).
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript is another popular tool for typechecking in React applications. It’s
    an open source superset of JavaScript, which means that it adds additional features
    to the language. Created at Microsoft, TypeScript is designed to be used for large
    apps to help developers find bugs and iterate more quickly on projects.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript has a growing allegiance of supporters, so the tooling in the ecosystem
    continues to improve. One tool that we’re already familiar with is Create React
    App, which has a TypeScript template we can use. Let’s set up some basic typechecking,
    similar to what we did with PropTypes and Flow, to get a sense of how we can start
    using it in our own apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by generating yet another Create React App, this time with some
    different flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s tour the features of our scaffolded project. Notice in the `src` directory
    that the file extensions are *.ts* or *.tsx* now. We’ll also find a *.tsconfig.json*
    file, which contains all of our TypeScript settings. More on that in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you take a look at the *package.json* file, there are new dependencies
    listed and installed related to TypeScript, like the library itself and type definitions
    for Jest, React, ReactDOM, and more. Any dependency that starts with `@types/`
    describes the type definitions for a library. That means that the functions and
    methods in the library are typed so that we don’t have to describe all of the
    library’s types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If your project doesn’t include the TypeScript features, you might be using
    an old version of Create React App. To get rid of this, you can run `npm uninstall
    -g create-react-app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try dropping our component from the Flow lesson into our project. Just
    add the following to the *index.ts* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the project with `npm start`, we should see our first TypeScript
    error. This is to be expected at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we need to add type rules for this `App` component. We’ll start
    by defining types just as we did earlier for the Flow component. The `item` is
    a string, so we’ll add that to the `AppProps` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll reference `AppProps` in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the component will render with no TypeScript issues. It’s also possible
    to destructure `props` if we’d like to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can break this by passing a value of a different type as the `item` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This immediately triggers an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The error also tells us the exact line where there’s a problem. This is extremely
    useful as we’re debugging.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript helps with more than just property validation, though. We can use
    TypeScript’s *type inference* to help us do typechecking on hook values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a state value for a `fabricColor` with an initial state of `purple`.
    The component might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we haven’t added anything to the type definitions object. Instead,
    TypeScript is inferring that the type for the `fabricColor` should match the type
    of its initial state. If we try setting the `fabricColor` with a number instead
    of another string color `blue`, an error will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The error looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript is hooking us up with some pretty low-effort typechecking for this
    value. Of course, you can customize this further, but this should give you a start
    toward adding typechecking to your applications.
  prefs: []
  type: TYPE_NORMAL
- en: For more on TypeScript, check out the [official docs](https://oreil.ly/97_Px)
    and the amazing [React+TypeScript Cheatsheets on GitHub](https://oreil.ly/vmran).
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test-driven development, or TDD, is a practice—not a technology. It does not
    mean that you simply have tests for your application. Rather, it’s the practice
    of letting the tests drive the development process. In order to practice TDD,
    you should follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the tests first
  prefs: []
  type: TYPE_NORMAL
- en: This is the most critical step. You declare what you’re building and how it
    should work first in a test. The steps you’ll use to test are red, green, and
    gold.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests and watch them fail (red)
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests and watch them fail before you write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Write the minimal amount of code required to make the tests pass (green)
  prefs: []
  type: TYPE_NORMAL
- en: Focus specifically on making each test pass; do not add any functionality beyond
    the scope of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Refactor both the code and the tests (gold)
  prefs: []
  type: TYPE_NORMAL
- en: Once the tests pass, it’s time to take a closer look at your code and your tests.
    Try to express your code as simply and as beautifully as possible.^([2](ch10.html#idm45901618932040))
  prefs: []
  type: TYPE_NORMAL
- en: TDD gives us an excellent way to approach a React application, particularly
    when testing Hooks. It’s typically easier to think about how a Hook should work
    before actually writing it. Practicing TDD will allow you to build and certify
    the entire data structure for a feature or application independent of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: TDD and Learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re new to TDD, or new to the language you’re testing, you may find it
    challenging to write a test before writing code. This is to be expected, and it’s
    OK to write the code before the test until you get the hang of it. Try to work
    in small batches: a little bit of code, a few tests, and so on. Once you get used
    to writing tests, it will be easier to write the tests first.'
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of this chapter, we’ll be writing tests for code that already
    exists. Technically, we’re not practicing TDD. However, in the next section, we’ll
    pretend that our code does not already exist so we can get a feel for the TDD
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can get started writing tests, we’ll need to select a testing framework.
    You can write tests for React with any JavaScript testing framework, but the official
    React docs recommend testing with Jest, a JavaScript test runner that lets you
    access the DOM via JSDOM. Accessing the DOM is important because you want to be
    able to check what is rendered with React to ensure your application is working
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Create React App and Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Projects that have been initialized with Create React App already come with
    the `jest` package installed. We can create another Create React App project to
    get started, or use an existing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start thinking about testing with a small example. We’ll create
    two new files in the *src* folder: *functions.js* and *functions.test.js*. Remember,
    Jest is already configured and installed in Create React App, so all you need
    to do is start writing tests. In *functions.test.js*, we’ll stub the tests. In
    other words, we’ll write what we think the function should do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our function to take in a value, multiply it by two, and return it.
    So we’ll model that in the test. The `test` function is the function that Jest
    provides to test a single piece of functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '*functions.test.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The first argument, `Multiplies by two`, is the test name. The second argument
    is the function that contains what should be tested and the third (optional) argument
    specifies a timeout. The default timeout is five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we’ll do is stub the function that will multiply numbers by
    two. This function will be referred to as our *system under test* (*SUT*). In
    *functions.js*, create the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll export it so that we can use the SUT in the test. In the test file, we
    want to import the function, and we’ll use `expect` to write an assertion. In
    the assertion, we’ll say that if we pass 4 to the `timesTwo` function, we expect
    that it should return 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Jest “matchers” are returned by the `expect` function and used to verify results.
    To test the function, we’ll use the `.toBe` matcher. This verifies that the resulting
    object matches the argument sent to `.toBe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the tests and watch them fail using `npm test` or `npm run test`.
    Jest will provide specific details on each failure, including a stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Taking the time to write the tests and run them to watch them fail shows us
    that our tests are working as intended. This failure feedback represents our to-do
    list. It’s our job to write the minimal code required to make our tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we add the proper functionality to the *functions.js* file, we can make
    the tests pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `.toBe` matcher has helped us test for equality with a single value. If
    we want to test an object or array, we could use `.toEqual`. Let’s go through
    another cycle with our tests. In the test file, we’ll test for equality of an
    array of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a list of menu items from the Guy Fieri restaurant in Las Vegas. It’s
    important that we build an object of their ordered items so the customer can get
    what they want and know what they’re supposed to pay. We’ll stub the test first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll stub our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll use the order function in the test file. We’ll also assume that we
    have a starter list of data for an order that we need to transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we’ll use `toEqual` because we’re checking the value of an object
    instead of an array. What do we want the result to equal? Well, we want to create
    an object that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'So we just add that to the test and use it in the assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll complete the function in the *functions.js* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: And when we check out the terminal, we’ll find that are tests are now passing!
    Now this might feel like a trivial example, but if you were fetching data, it’s
    likely that you’d test for shape matches of arrays and objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another commonly used function with Jest is `describe()`. If you’ve used other
    testing libraries, you might have seen a similar function before. This function
    is typically used to wrap several related tests. For example, if we had a few
    tests for similar functions, we could wrap them in a `describe` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When you wrap tests in the `describe` statement, the test runner creates a
    block of tests, which makes the testing output in the terminal look more organized
    and easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As you write more tests, grouping them in `describe` blocks might be a useful
    enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: This process represents a typical TDD cycle. We wrote the tests first, then
    wrote code to make the tests pass. Once the tests pass, we can take a closer look
    at the code to see if there’s anything that’s worth refactoring for clarity or
    performance. This approach is very effective when working with JavaScript (or
    really any other language).
  prefs: []
  type: TYPE_NORMAL
- en: Testing React Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the process behind writing tests,
    we can start to apply these techniques to component testing in React.
  prefs: []
  type: TYPE_NORMAL
- en: React components provide instructions for React to follow when creating and
    managing updates to the DOM. We can test these components by rendering them and
    checking the resulting DOM.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not running our tests in a browser; we’re running them in the terminal
    with Node.js. Node.js does not have the DOM API that comes standard with each
    browser. Jest incorporates an npm package called `jsdom` that’s used to simulate
    a browser environment in Node.js, which is essential for testing React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each component test, it’s likely that we’ll need to render our React component
    tree to a DOM element. To demonstrate this workflow, let’s revisit our `Star`
    component in *Star.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in *index.js*, we’ll import and render the star:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s write our test. We already wrote the code for the star, so we won’t
    be partaking in TDD here. If you had to incorporate tests into your existing apps,
    this is how you’d do it. In a new file called *Star.test.js*, start by importing
    React, ReactDOM, and the `Star`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also want to write the tests. Remember, the first argument we supply
    to `test` is the name of the test. Then we’re going to perform some setup by creating
    a div that we can render the star to with `ReactDOM.render`. Once the element
    is created, we can write the assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll expect that if we try to select an `svg` element inside of the created
    `div`, the result will be truthy. When we run the test, we should see that the
    test passes. Just to verify that we aren’t getting a valid assertion when we shouldn’t
    be, we can change the selector to find something fake and watch the test fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[The documentation](https://oreil.ly/ah7ZU) provides more detail about all
    of the custom matchers that are available so that you can test exactly what you
    want to test.'
  prefs: []
  type: TYPE_NORMAL
- en: When you generated your React project, you may have noticed that a few packages
    from `@testing-library` were installed in addition to the basics like React and
    ReactDOM. React Testing Library is a project that was started by Kent C. Dodds
    as a way to enforce good testing practices and to expand the testing utilities
    that were part of the React ecosystem. Testing Library is an umbrella over many
    testing packages for libraries like Vue, Svelte, Reason, Angular, and more—it’s
    not just for React.
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential reason you might choose React Testing Library is to get better
    error messages when a test fails. The current error we see when we test the assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s punch this up by adding React Testing Library. It’s already installed
    in our Create React App project. To begin, we’ll import the `toHaveAttribute`
    function from `@testing-library/jest-dom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, we want to extend the functionality of `expect` to include this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now instead of using `toBeTruthy`, which gives us hard-to-read messages, we
    can use `toHaveAttribute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we run the tests, we see an error telling us exactly what’s what:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be pretty straightforward to fix this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Using more than one of the custom matchers just means that you need to import,
    extend, and use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s an even faster way to do this, though. If you find yourself importing
    too many of these matchers to list or keep track of, you can import the `extend-expect`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The assertions will continue to run as expected (pun intended). Another fun
    fact about Create React App is that, in a file called *setupTests.js* that ships
    with CRA, there’s a line that has already included the `extend-expect` helpers.
    If you look at the *src* folder, you’ll see that *setupTests.js* contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: So if you’re using Create React App, you don’t even have to include the import
    in your test files.
  prefs: []
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Queries are another feature of the React Testing Library that allow you to
    match based on certain criteria. In order to demonstrate using a query, let’s
    adjust the `Star` component to include a title. This will allow us to write a
    common style of test—one that matches based on text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s pause to think about what we’re trying to test. We want the component
    to render, and now we want to test to see if the `h1` contains the correct text.
    A function that’s part of React Testing Library, `render`, will help us do just
    that. `render` will replace our need to use `ReactDOM.render()`, so the test will
    look a bit different. Start by importing `render` from React Testing Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '`render` will take in one argument: the component or element that we want to
    render. The function returns an object of queries that can be used to check in
    with values in that component or element. The query we’ll use is `getByText`,
    which will find the first matching node for a query and throw an error if no elements
    match. To return a list of all matching nodes, use `getAllBy` to return an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '`getByText` finds the `h1` element via the regular expression that’s passed
    to it. Then we use the Jest matcher `toHaveTextContent` to describe what text
    the `h1` should include.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests, and they’ll pass. If we change the text passed to the `toHaveTextContent()`
    function, the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important part of writing tests is testing events that are part of
    components. Let’s use and test the `Checkbox` component we created in [Chapter 7](ch07.html#enhancing_components_with_hooks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This component uses `useReducer` to toggle a checkbox. Our aim here is to create
    an automated test that will click this checkbox and change the value of `checked`
    from the default `false` to `true`. Writing a test to check the box will also
    fire `useReducer` and test the hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s stub the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do is select the element that we want to fire the
    event on. In other words, which element do we want to click on with the automated
    test? We’ll use one of Testing Library’s queries to find the element we’re looking
    for. Since the input has a label, we can use `getByLabelText()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'When the component first renders, its label text reads `not checked`, so we
    can search via a regular expression to find a match with the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, this regex is case sensitive, so if you wanted to search for any
    case, you could add an `i` to the end of it. Use that technique with caution depending
    on how permissive you want the query selection to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have our checkbox selected. All we need to do now is fire the event
    (click the checkbox) and write an assertion to make sure that the `checked` property
    is set to `true` when the checkbox is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'You also could add the reverse toggle to this checkbox test by firing the event
    again and checking that the property is set to `false` on toggle. We changed the
    name of the test to be more accurate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, selecting the checkbox is pretty easy. We have a label we can
    use to find the input we want to check. In the event that you don’t have such
    an easy way to access a DOM element, Testing Library gives you another utility
    you can use to check in with any DOM element. You’ll start by adding an attribute
    to the element you want to select:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the query `getByTestId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This will do the same thing but is particularly useful when reaching out to
    DOM elements that are otherwise difficult to access.
  prefs: []
  type: TYPE_NORMAL
- en: Once this `Checkbox` component is tested, we can confidently incorporate it
    into the rest of the application and reuse it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Code Coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Code coverage* is the process of reporting on how many lines of code have
    actually been tested. It provides a metric that can help you decide when you’ve
    written enough tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Jest ships with Istanbul, a JavaScript tool used to review your tests and generate
    a report that describes how many statements, branches, functions, and lines have
    been covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Jest with code coverage, simply add the `coverage` flag when you run
    the `jest` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This report tells you how much of your code in each file has been executed during
    the testing process and reports on all files that have been imported into tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jest also generates a report that you can run in your browser, which provides
    more details about what code has been covered by tests. After running Jest with
    coverage reporting, you’ll notice that a *coverage* folder has been added to the
    root. In a web browser, open this file: */coverage/lcov-report/index.html*. It
    will show you your code coverage in an interactive report.'
  prefs: []
  type: TYPE_NORMAL
- en: This report tells you how much of the code has been covered, as well as the
    individual coverage based on each subfolder. You can drill down into a subfolder
    to see how well the individual files within have been covered. If you select the
    *components/ui* folder, you’ll see how well your user interface components are
    covered by testing.
  prefs: []
  type: TYPE_NORMAL
- en: You can see which lines have been covered in an individual file by clicking
    on the filename.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is a great tool to measure the reach of your tests. It’s one benchmark
    to help you understand when you’ve written enough unit tests for your code. It’s
    not typical to have 100% code coverage in every project. Shooting for anything
    above 85% is a good target.^([3](ch10.html#idm45901616918376))
  prefs: []
  type: TYPE_NORMAL
- en: Testing can often feel like an extra step, but the tooling around React testing
    has never been better. Even if you don’t test all of your code, starting to think
    about how to incorporate testing practices can help you save time and money when
    building production-ready applications.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch10.html#idm45901621151704-marker)) For a brief introduction to unit
    testing, see Martin Fowler’s article, [“Unit Testing”](http://martinfowler.com/bliki/UnitTest.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.html#idm45901618932040-marker)) For more on this development pattern,
    see Jeff McWherter’s and James Bender’s [“Red, Green, Refactor”](https://oreil.ly/Hr6Me).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch10.html#idm45901616918376-marker)) See Martin Fowler’s article, [“Test-Coverage”](https://oreil.ly/Hbb-D).
  prefs: []
  type: TYPE_NORMAL
