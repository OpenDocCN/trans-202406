- en: Chapter 15\. Generating and Using Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 15.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A sequence is a set of integers (1, 2, 3, …) generated in order on demand.
    Sequences see frequent use in databases because many applications require each
    row in a table to contain a unique value, and sequences provide an easy way to
    generate them. This chapter describes how to use sequences in MySQL in the following
    five ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `AUTO_INCREMENT` columns
  prefs: []
  type: TYPE_NORMAL
- en: The `AUTO_INCREMENT` column is MySQL’s mechanism for generating a sequence over
    a set of rows. Each time you create a row in a table that contains an `AUTO_INCREMENT`
    column, MySQL automatically generates the next value in the sequence as the column’s
    value. This value serves as a unique identifier, making sequences an easy way
    to create items such as customer ID numbers, shipping package waybill numbers,
    invoice or purchase order numbers, bug report IDs, ticket numbers, or product
    serial numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving sequence values
  prefs: []
  type: TYPE_NORMAL
- en: For many applications, it’s not enough just to create sequence values. It’s
    also necessary to determine the sequence value for a just-inserted row. A web
    application may need to redisplay to a user the contents of a row created from
    the contents of a form just submitted by the user. The value may need to be retrieved
    so it can be stored in rows of a related table.
  prefs: []
  type: TYPE_NORMAL
- en: Resequencing techniques
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to renumber a sequence that has holes in it due to row deletions,
    reuse deleted values at the top of a sequence, or add a sequence column to a table
    that has none.
  prefs: []
  type: TYPE_NORMAL
- en: Managing multiple simultaneous sequences
  prefs: []
  type: TYPE_NORMAL
- en: Special care is necessary when you need to keep track of multiple sequence values,
    such as when you create rows in multiple tables that each have an `AUTO_INCREMENT`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: Using single-row sequence generators
  prefs: []
  type: TYPE_NORMAL
- en: Sequences can be used as counters. For example, to count votes in a poll, you
    might increment a counter each time a candidate receives a vote. The counts for
    a given candidate form a sequence, but because the count itself is the only value
    of interest, there is no need to generate a new row to record each vote. MySQL
    provides a solution for this problem using a mechanism that enables a sequence
    to be easily generated within a single table row over time. To store multiple
    counters in the table, use a column that identifies each counter uniquely. The
    same mechanism also enables creation of sequences that increase by values other
    than one or by nonuniform values.
  prefs: []
  type: TYPE_NORMAL
- en: The engines for most database systems provide sequence-generation capabilities,
    although the implementations tend to be engine-dependent. That’s true for MySQL
    as well, so the material in this section is almost completely MySQL-specific,
    even at the SQL level. In other words, the SQL for generating sequences is itself
    nonportable, even if you use an API such as DBI or JDBC that provides an abstraction
    layer. Abstract interfaces may help you process SQL statements portably, but they
    don’t make nonportable SQL portable.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts related to the examples shown in this chapter are located in the *sequences*
    directory of the `recipes` distribution. For scripts that create tables used here,
    look in the *tables* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 Generating a Sequence with AUTO_INCREMENT Columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your table includes a column that should contain only unique IDs, and you need
    to insert values into this column, insuring they are part of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use an `AUTO_INCREMENT` column to generate a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe provides the essential background on using `AUTO_INCREMENT` columns,
    beginning with an example that demonstrates the sequence-generation mechanism.
    The example centers around a bug-collection scenario: your eight-year-old son
    Junior is assigned the task of collecting insects for a class project at school.
    For each insect, Junior is to record its name (<q>ant,</q> <q>bee,</q> and so
    forth), and its date and location of collection. You have expounded the benefits
    of MySQL for record-keeping to Junior since his early days, so upon your arrival
    home from work that day, he immediately announces the necessity of completing
    this project and then, looking you straight in the eye, declares that it’s clearly
    a task for which MySQL is well-suited. Who are you to argue? So the two of you
    get to work. Junior already collected some specimens after school while waiting
    for you to come home and has recorded the following information in his notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Date | Origin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| millipede | 2014-09-10 | driveway |'
  prefs: []
  type: TYPE_TB
- en: '| housefly | 2014-09-10 | kitchen |'
  prefs: []
  type: TYPE_TB
- en: '| grasshopper | 2014-09-10 | front yard |'
  prefs: []
  type: TYPE_TB
- en: '| stink bug | 2014-09-10 | front yard |'
  prefs: []
  type: TYPE_TB
- en: '| cabbage butterfly | 2014-09-10 | garden |'
  prefs: []
  type: TYPE_TB
- en: '| ant | 2014-09-10 | back yard |'
  prefs: []
  type: TYPE_TB
- en: '| ant | 2014-09-10 | back yard |'
  prefs: []
  type: TYPE_TB
- en: '| termite | 2014-09-10 | kitchen woodwork |'
  prefs: []
  type: TYPE_TB
- en: Looking over Junior’s notes, you’re pleased to see that even at his tender age,
    he has learned to write dates in ISO format. However, you also notice that he’s
    collected a millipede and a termite, neither of which actually are insects. You
    decide to let this pass for the moment; Junior forgot to bring home the written
    instructions for the project, so at this point it’s unclear whether these specimens
    are acceptable. (You also note with some alarm Junior’s discovery of termites
    in the house and make a mental note to call the exterminator.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As you consider how to create a table to store this information, it’s apparent
    that you need at least `name`, `date`, and `origin` columns corresponding to the
    types of information that Junior is required to record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, those columns are insufficient to make the table easy to use. Note
    that the records collected thus far are not unique; both ants were collected at
    the same time and place. If you put the information into an `insect` table that
    has the structure just shown, neither ant row can be referred to individually
    because there’s nothing to distinguish one from another. Unique IDs would be helpful
    to make the rows distinct and to provide values that make each row easy to refer
    to. An `AUTO_INCREMENT` column is good for this purpose, so a better `insect`
    table has a structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and create the `insect` table using this second `CREATE` `TABLE` statement.
    ([Recipe 15.2](#nch-sequences-seq-type) discusses the particulars of the `id`
    column definition.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have an `AUTO_INCREMENT` column, use it to generate new sequence
    values. One of the useful properties of an `AUTO_INCREMENT` column is that you
    need not assign its values yourself: MySQL does so for you. There are two ways
    to generate new `AUTO_INCREMENT` values in the `id` column. One is to explicitly
    set the `id` column to `NULL`. The following statement inserts the first four
    of Junior’s specimens into the `insect` table that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, omit the `id` column from the `INSERT` statement entirely. MySQL
    permits creating rows without explicitly specifying values for columns that have
    a default value. MySQL assigns each missing column its default value, and the
    default for an `AUTO_INCREMENT` column is its next sequence number. Thus, this
    statement adds Junior’s other four specimens to the `insect` table and generates
    sequence values without naming the `id` column at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Whichever method you use, MySQL determines the sequence number for each row
    and assigns it to the `id` column, as you can verify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As Junior collects more specimens, add more rows to the table and they’ll be
    assigned the next values in the sequence (9, 10, …).
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept underlying `AUTO_INCREMENT` columns is simple enough in principle:
    each time you create a new row, MySQL generates the next number in the sequence
    and assigns it to the row. But there are certain subtleties to know about, as
    well as differences in how different storage engines handle `AUTO_INCREMENT` sequences.
    Awareness of these issues enables you to use sequences more effectively and avoid
    surprises. For example, if you explicitly set the `id` column to a non-`NULL`
    value, one of two things happens:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the value is already present in the table, an error occurs if the column
    cannot contain duplicates. For the `insect` table, the `id` column is a `PRIMARY`
    `KEY`, which prohibits duplicates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the value is not present in the table, MySQL inserts the row using that value.
    In addition, if the value is larger than the current sequence counter, the table’s
    counter is reset to the value plus one. The `insect` table at this point has sequence
    values 1 through 8\. If you insert a new row with the `id` column set to 20, that
    becomes the new maximum value. Subsequent inserts that automatically generate
    `id` values will begin at 21\. The values 9 through 19 become unused, resulting
    in a gap in the sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next recipe looks in more detail at how to define `AUTO_INCREMENT` columns
    and how they behave.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2 Choosing the Data Type for a Sequence Column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to choose correct data type to define a sequence column.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider how many unique values your sequence should hold and choose the data
    type accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should follow certain principles when creating `AUTO_INCREMENT` columns.
    As an illustration, consider how [Recipe 15.1](#nch-sequences-seq-create-col)
    declared the `id` column in the `insect` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AUTO_INCREMENT` keyword informs MySQL that it should generate successive
    sequence numbers for the column’s values, but the other information is important,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INT` is the column’s base data type. You need not necessarily use `INT`, but
    the column should be one of the integer types: `TINYINT`, `SMALLINT`, `MEDIUMINT`,
    `INT`, or `BIGINT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNSIGNED` prohibits negative column values. This is not a required attribute
    for `AUTO_INCREMENT` columns, but sequences consist only of positive integers
    (normally beginning at 1), so there is no reason to permit negative values. Furthermore,
    *not* declaring the column to be `UNSIGNED` cuts the range of your sequence in
    half. For example, `TINYINT` has a range of –128 to 127. Because sequences include
    only positive values, the effective range of a `TINYINT` sequence is 1 to 127\.
    `TINYINT` `UNSIGNED` has a range of 0 to 255, which increases the upper end of
    the sequence to 255\. The specific integer type determines the maximum sequence
    value. The following table shows the maximum unsigned value of each type; use
    this information to choose a type big enough to hold the largest value you’ll
    need:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Data type | Maximum unsigned value |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `TINYINT` | 255 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `SMALLINT` | 65,535 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `MEDIUMINT` | 16,777,215 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `INT` | 4,294,967,295 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `BIGINT` | 18,446,744,073,709,551,615 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Sometimes people omit `UNSIGNED` so that they can create rows that contain negative
    numbers in the sequence column (using –1 to signify <q>has no ID,</q> for example.)
    This is a bad idea. MySQL makes no guarantees about how negative numbers will
    be treated in an `AUTO_INCREMENT` column, so by using them you’re playing with
    fire. For example, if you resequence the column, all your negative values get
    turned into positive sequence numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`AUTO_INCREMENT` columns cannot contain `NULL` values, so `id` is declared
    as `NOT` `NULL`. (It’s true that you can specify `NULL` as the column value when
    you insert a new row, but for an `AUTO_INCREMENT` column, that really means <q>generate
    the next sequence value.</q>) MySQL automatically defines `AUTO_INCREMENT` columns
    as `NOT` `NULL` if you forget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTO_INCREMENT` columns must be indexed. Normally, because a sequence column
    exists to provide unique identifiers, you use a `PRIMARY` `KEY` or `UNIQUE` index
    to enforce uniqueness. Tables can have only one `PRIMARY` `KEY`, so if the table
    already has some other `PRIMARY` `KEY` column, you can declare an `AUTO_INCREMENT`
    column to have a `UNIQUE` index instead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you create a table that contains an `AUTO_INCREMENT` column, it’s also
    important to consider which storage engine to use (InnoDB, MyISAM, and so forth).
    The engine affects behaviors such as reuse of values deleted from the top of the
    sequence (see [Recipe 15.3](#nch-sequences-seq-delete)).
  prefs: []
  type: TYPE_NORMAL
- en: 15.3 Deleting Rows Without Changing a Sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to delete few rows from the table that contains an `AUTO_INCREMENT`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use regular `DELETE` statement. MySQL would not change generated sequence numbers
    for the existing rows.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have thus far considered how MySQL generates sequence values in an `AUTO_INCREMENT`
    column under circumstances where rows are only added to a table. But it’s unrealistic
    to assume that rows will never be deleted. What happens to the sequence then?
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer again to Junior’s bug-collection project, for which you currently have
    an `insect` table that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s about to change because after Junior remembers to bring home the written
    instructions for the project, you read through them and discover two things that
    affect the table contents:'
  prefs: []
  type: TYPE_NORMAL
- en: Specimens should include only insects, not insect-like creatures such as millipedes
    and termites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of the project is to collect as many *different* specimens as possible,
    not just as *many* specimens as possible. This means that only one ant row is
    permitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These instructions dictate that a few rows be removed from table—specifically
    those with `id` values 2 (millipede), 8 (termite), and 7 (duplicate ant). Thus,
    despite Junior’s evident disappointment at the reduction in the size of his collection,
    you instruct him to remove those rows by issuing a `DELETE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement illustrates why it’s useful to have unique ID values: they enable
    you to specify any row unambiguously. The ant rows are identical except for the
    `id` value. Without that column in the table, it would be more difficult to delete
    just one of them (though not impossible; see [Recipe 18.5](ch18.xhtml#nch-dups-dups-elim-table)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After removing the unsuitable rows, the table has these remaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `id` column sequence now has a hole (row 2 is missing) and the values 7
    and 8 at the top of the sequence are no longer present. How do these deletions
    affect future insert operations? What sequence number will the next new row get?
  prefs: []
  type: TYPE_NORMAL
- en: Removing row 2 creates a gap in the middle of the sequence. This has no effect
    on subsequent inserts, because MySQL makes no attempt to fill in holes in a sequence.
    On the other hand, deleting rows 7 and 8 removes values at the top of the sequence.
    For InnoDB or MyISAM tables, values are not reused. The next sequence number is
    the smallest positive integer that has not previously been used. (For a sequence
    that stands at 8, the next row gets a value of 9 even if you delete rows 7 and
    8 first.) If you require strictly monotonic sequences, you can use one of these
    storage engines. For other storage engines, values removed at the top of the sequence
    may or may not be reused. Check the properties of the engine before using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a table uses an engine that differs in value-reuse behavior from the behavior
    you require, use `ALTER` `TABLE` to change the table to a more appropriate engine.
    For example, to change a table to use InnoDB (to prevent sequence values from
    being reused after rows are deleted), do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t know what engine a table uses, consult `INFORMATION_SCHEMA` or
    use `SHOW` `TABLE` `STATUS` or `SHOW` `CREATE` `TABLE` to find out. For example,
    the following statement indicates that `insect` is an InnoDB table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To empty a table and reset the sequence counter (even for engines that normally
    do not reuse values), use `TRUNCATE` `TABLE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 15.4 Retrieving Sequence Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating a row that includes a new sequence number, you want to know what
    that number is.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Invoke the `LAST_INSERT_ID()` function. If you’re writing a program, your MySQL
    API may provide a way to get the value directly without issuing an SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s common for applications to need to know the `AUTO_INCREMENT` value of
    a newly created row. For example, if you write a web-based frontend for entering
    rows into Junior’s `insect` table, you might have the application display each
    new row nicely formatted in a new page immediately after you hit the Submit button.
    To do this, you must know the new `id` value so that you can retrieve the proper
    row. Another situation in which the `AUTO_INCREMENT` value is needed occurs when
    you use multiple tables: after inserting a row in a main table, you need its ID
    to create rows in other related tables that refer to the row in the main table.
    ([Recipe 15.11](#nch-sequences-seq-relate) shows how to do this.)'
  prefs: []
  type: TYPE_NORMAL
- en: When you generate a new `AUTO_INCREMENT` value, one way to get the value from
    the server is to execute a statement that invokes the `LAST_INSERT_ID()` function.
    In addition, many MySQL APIs provide a client-side mechanism for making the value
    available without issuing another statement. This recipe discusses both methods
    and compares their characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Using LAST_INSERT_ID() to obtain AUTO_INCREMENT values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The obvious (but incorrect) way to determine a new row’s `AUTO_INCREMENT` value
    uses the fact that when MySQL generates the value, it becomes the largest sequence
    number in the column. Thus, you might try using the `MAX()` function to retrieve
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is unreliable; if another client inserts a row before you issue the `SELECT`
    statement, `MAX(id)` returns that client’s ID, not yours. It’s possible to solve
    this problem by grouping the `INSERT` and `SELECT` statements as a transaction
    or locking the table, but MySQL provides a simpler way to obtain the proper value:
    invoke the `LAST_INSERT_ID()` function. It returns the most recent `AUTO_INCREMENT`
    value generated within your session, regardless of what other clients are doing.
    For example, to insert a row into the `insect` table and retrieve its `id` value,
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use the new value to retrieve the entire row, without even knowing
    what it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The server maintains the value returned by `LAST_INSERT_ID()` on a session-specific
    basis. This property is by design, and it’s important because it prevents clients
    from interfering with each other. When you generate an `AUTO_INCREMENT` value,
    `LAST_INSERT_ID()` returns that specific value, even when other clients generate
    new rows in the same table in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: Using API-specific methods to obtain AUTO_INCREMENT values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`LAST_INSERT_ID()` is an SQL function, so you can use it from within any client
    that can execute SQL statements. On the other hand, you do have to execute a separate
    statement to get its value. When you write your own programs, you may have another
    choice. Many MySQL interfaces include an API-specific extension that returns the
    `AUTO_INCREMENT` value without executing an additional statement. Most of our
    APIs have this capability.'
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `mysql_insertid` attribute to obtain the `AUTO_INCREMENT` value generated
    by a statement. This attribute is accessed through either a database handle or
    a statement handle, depending on how you issue the statement. The following example
    references it through the database handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To access `mysql_insertid` as a statement-handle attribute, use `prepare()`
    and `execute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Ruby
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ruby Mysql2 gem exposes the client-side `AUTO_INCREMENT` value using the
    `last_id` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: PHP
  prefs: []
  type: TYPE_NORMAL
- en: 'The PDO interface for MySQL has a `lastInsertId()` database-handle method that
    returns the most recent `AUTO_INCREMENT` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: 'The Connector/Python driver for DB API provides a `lastrowid` cursor object
    attribute that returns the most recent `AUTO_INCREMENT` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Java
  prefs: []
  type: TYPE_NORMAL
- en: The Connector/J JDBC driver `getGeneratedKeys()` method returns `AUTO_INCREMENT`
    values. It can be used with a `Statement` or `PreparedStatement` object if you
    supply an additional `Statement.RETURN_GENERATED_KEYS` argument during the statement-execution
    process to indicate that you want to retrieve the sequence value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `Statement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For a `PreparedStatement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then generate a new result set from `getGeneratedKeys()` to access the sequence
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Go
  prefs: []
  type: TYPE_NORMAL
- en: The Go MySQL driver provides method `LastInsertId` of the `Result` interface
    that returns the latest `AUTO_INCREMENT` value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Server-side and client-side sequence value retrieval compared
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, the server maintains the value of `LAST_INSERT_ID()` on
    a session-specific basis. By contrast, the API-specific methods for accessing
    `AUTO_INCREMENT` values directly are implemented on the client side. Server-side
    and client-side sequence value retrieval methods have some similarities, but also
    some differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'All methods, both server-side and client-side, require that you access an `AUTO_INCREMENT`
    value within the same MySQL session that generated it. If you generate an `AUTO_INCREMENT`
    value, then disconnect from the server and reconnect before attempting to access
    the value, you’ll get zero. Within a given session, the persistence of `AUTO_INCREMENT`
    values can be much longer on the server side of the session:'
  prefs: []
  type: TYPE_NORMAL
- en: After you execute a statement that generates an `AUTO_INCREMENT` value, the
    value remains available through `LAST_INSERT_ID()` even if you execute other statements,
    as long as none of those statements generate an `AUTO_INCREMENT` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sequence value available using client-side API methods typically is set
    for *every* statement, not only those that generate `AUTO_INCREMENT` values. If
    you execute an `INSERT` statement that generates a new value and then execute
    some other statement before accessing the client-side sequence value, it probably
    will have been set to zero. The precise behavior varies among APIs, but to be
    safe, you can do this: when a statement generates a sequence value that you won’t
    use immediately, save the value in a variable that you can refer to later. Otherwise,
    you may find the sequence value wiped out by the time you try to access it. (For
    more on this topic, see [Recipe 15.10](#nch-sequences-seq-simultaneous).)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.5 Renumbering an Existing Sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have gaps in a sequence column, and you want to resequence it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, consider whether resequencing is necessary. In many cases it is not.
    But if you have to, resequence the AUTO_INCREMENT columns periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you insert rows into a table that has an `AUTO_INCREMENT` column and never
    delete any of them, values in the column form an unbroken sequence. If you delete
    rows, the sequence begins to have holes in it. For example, Junior’s `insect`
    table currently looks something like this, with gaps in the sequence (assuming
    that you’ve inserted the cricket and moth rows shown in [Recipe 15.4](#nch-sequences-seq-retrieve)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: MySQL won’t attempt to eliminate these gaps by filling in the unused values
    when you insert new rows. People who dislike this behavior tend to resequence
    `AUTO_INCREMENT` columns periodically to eliminate the holes. The examples in
    this recipe show how to do that. It’s also possible to extend the range of an
    existing sequence (see [Recipe 15.6](#nch-sequences-seq-range)), force deleted
    values at the top of a sequence to be reused (see [Recipe 15.7](#nch-sequences-seq-reuse-top)),
    number rows in a particular order (see [Recipe 15.8](#nch-sequences-seq-order)),
    or add a sequence column to a table that doesn’t currently have one (see [Recipe
    15.9](#nch-sequences-seq-add-seq)).
  prefs: []
  type: TYPE_NORMAL
- en: Before you decide to resequence an `AUTO_INCREMENT` column, consider whether
    that’s really necessary. It usually isn’t, and in some cases can cause you real
    problems. For example, you should *not* resequence a column containing values
    that are referenced by another table. Renumbering the values destroys their correspondence
    to values in the other table, making it impossible to properly relate rows in
    the two tables to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are reasons we have seen advanced for resequencing a column:'
  prefs: []
  type: TYPE_NORMAL
- en: Aesthetics
  prefs: []
  type: TYPE_NORMAL
- en: Some people prefer unbroken sequences to sequences with holes in them. If this
    is why you want to resequence, there’s probably not much we can say to convince
    you otherwise. Nevertheless, it’s not a particularly good reason.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs: []
  type: TYPE_NORMAL
- en: The impetus for resequencing may stem from the notion that doing so <q>compacts</q>
    a sequence column by removing gaps and enables MySQL to run statements more quickly.
    This is not true. MySQL doesn’t care whether there are holes, and there is no
    performance gain to be had by renumbering an `AUTO_INCREMENT` column. In fact,
    resequencing affects performance negatively in the sense that the table remains
    locked while MySQL performs the operation—which may take a nontrivial amount of
    time for a large table. Other clients can read from the table while this is happening,
    but clients trying to insert new rows block until the operation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Running out of numbers
  prefs: []
  type: TYPE_NORMAL
- en: The sequence column’s data type and signedness determine its upper limit (see
    [Recipe 15.2](#nch-sequences-seq-type)). If an `AUTO_INCREMENT` sequence is approaching
    the upper limit of its data type, renumbering packs the sequence and frees up
    more values at the top. This may be a legitimate reason to resequence a column,
    but it is still unnecessary in many cases. You may be able to change the column
    data type to increase its upper limit without changing the values stored in the
    column; see [Recipe 15.6](#nch-sequences-seq-range).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re still determined to resequence a column, it’s easy to do: drop the
    column from the table; then put it back. MySQL renumbers the values in the column
    in unbroken sequence. The following example shows how to renumber the `id` values
    in the `insect` table using this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first `ALTER` `TABLE` statement gets rid of the `id` column (and as a result
    also drops the `PRIMARY` `KEY`, because the column to which it refers is no longer
    present). The second statement restores the column to the table and establishes
    it as the `PRIMARY` `KEY`. (The `FIRST` keyword places the column first in the
    table, which is where it was originally. Normally, `ADD` puts columns at the end
    of the table.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When you add an `AUTO_INCREMENT` column to a table, MySQL automatically numbers
    all the rows consecutively, so the resulting contents of the `insect` table look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'One problem with resequencing a column using separate `ALTER` `TABLE` statements
    is that the table is without that column for the interval between the two operations.
    This might cause difficulties for other clients that try to access the table during
    that time. To prevent this from happening, perform both operations with a single
    `ALTER` `TABLE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'MySQL permits multiple actions to be done with `ALTER` `TABLE` (something not
    true for all database systems). However, notice that this multiple-action statement
    is not simply a concatenation of the two single-action `ALTER` `TABLE` statements.
    The difference is that it is unnecessary to reestablish the `PRIMARY` `KEY`: MySQL
    doesn’t drop it unless the indexed column is missing after all the actions specified
    in the `ALTER` `TABLE` statement have been performed.'
  prefs: []
  type: TYPE_NORMAL
- en: 15.6 Extending the Range of a Sequence Column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to avoid resequencing a column, but you’re running out of room for
    new sequence numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check whether you can make the column `UNSIGNED` or change it to use a larger
    integer type.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Resequencing an `AUTO_INCREMENT` column changes the contents of potentially
    every row in the table. It’s often possible to avoid this by extending the range
    of the column, which changes the table’s structure rather than its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data type is signed, make it `UNSIGNED` to double the range of available
    values. Suppose that an `id` column currently is defined like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The upper range of a signed `MEDIUMINT` column is 8,388,607\. To increase this
    to 16,777,215, make the column `UNSIGNED` with `ALTER` `TABLE`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your column is already `UNSIGNED` and it is not already the largest integer
    type (`BIGINT`), converting it to a larger type increases its range. Use `ALTER`
    `TABLE` for this, too. Convert the `id` column in the previous example from `MEDIUMINT`
    to `BIGINT` like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Recipe 15.2](#nch-sequences-seq-type) shows the ranges for each integer data
    type, which can help you choose an appropriate type.'
  prefs: []
  type: TYPE_NORMAL
- en: 15.7 Reusing Values at the Top of a Sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve deleted rows at the top end of your sequence, and you want to avoid resequencing
    the column, but still reuse the values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes. Use `ALTER` `TABLE` to reset the sequence counter. New sequence numbers
    will begin with the value one larger than the current maximum in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have removed rows only from the top of the sequence, those that remain
    are still in order with no gaps. (For example, if you have rows numbered 1 to
    100 and you remove the rows with numbers 91 to 100, the remaining rows are still
    in unbroken sequence from 1 to 90.) In this special case, it’s unnecessary to
    renumber the column. Instead, tell MySQL to resume the sequence beginning with
    the value one larger than the highest existing sequence number by executing this
    statement, which causes MySQL to reset the sequence counter down as far as it
    can for new rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can use `ALTER` `TABLE` to reset the sequence counter if a sequence column
    contains gaps in the middle, but doing so still reuses only values deleted from
    the top of the sequence. It does not eliminate the gaps. Suppose that a table
    contains sequence values from 1 to 10, from which you delete the rows for values
    3, 4, 5, 9, and 10\. The maximum remaining value is 8, so if you use `ALTER` `TABLE`
    to reset the sequence counter, the next row is given a value of 9, not 3\. To
    resequence a table to eliminate the gaps, see [Recipe 15.5](#nch-sequences-seq-reseq).
  prefs: []
  type: TYPE_NORMAL
- en: 15.8 Ensuring That Rows Are Renumbered in a Particular Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You resequenced a column, but MySQL didn’t number the rows the way you want.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Select the rows into another table, using an `ORDER` `BY` clause to place them
    in the order you want, and let MySQL number them according to the sort order as
    it performs the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you resequence an `AUTO_INCREMENT` column, MySQL is free to pick the rows
    from the table in any order, so it doesn’t necessarily renumber them in the order
    that you expect. This doesn’t matter at all if your only requirement is that each
    row have a unique identifier. But you might have an application for which it’s
    important that the rows be assigned sequence numbers in a particular order. For
    example, you may want the sequence to correspond to the order in which rows were
    created, as indicated by a `TIMESTAMP` column. To assign numbers in a particular
    order, use this procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty clone of the table (see [Recipe 6.1](ch06.xhtml#nch-tblmgmt-tblmgmt-clone)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy rows from the original into the clone using `INSERT` `INTO` … `SELECT`.
    Copy all columns except the `AUTO_INCREMENT` column, using an `ORDER` `BY` clause
    to specify the order in which rows are copied (and thus the order in which MySQL
    assigns numbers to the `AUTO_INCREMENT` column).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop the original table and rename the clone to have the original table’s name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the table is a large MyISAM table and has multiple indexes, it is more efficient
    to create the new table initially with no indexes except the one on the `AUTO_INCREMENT`
    column. Then copy the original table into the new table and use `ALTER` `TABLE`
    to add the remaining indexes afterward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This applies to InnoDB as well. But InnoDB [Change Buffer](https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html)
    caches changes to the secondary indexes in memory and flushes then them to the
    disk in background. This allows to keep insert performance at the good speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An alternative procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new table that contains all the columns of the original table except
    the `AUTO_INCREMENT` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `INSERT` `INTO` … `SELECT` to copy the non-`AUTO_INCREMENT` columns from
    the original table into the new table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `TRUNCATE` `TABLE` on the original table to empty it; this also resets the
    sequence counter to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy rows from the new table back to the original table, using an `ORDER` `BY`
    clause to sort rows into the order in which you want sequence numbers assigned.
    MySQL assigns sequence values to the `AUTO_INCREMENT` column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 15.9 Sequencing an Unsequenced Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You forgot to include a sequence column when you created a table. Is it too
    late to sequence the table rows?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No. Add an `AUTO_INCREMENT` column using `ALTER` `TABLE`; MySQL creates the
    column and numbers its rows.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that a table contains `name` and `age` columns, but no sequence column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a sequence column named `id` to the table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: MySQL numbers the rows for you; it’s unnecessary to assign the values yourself.
    Very handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `ALTER` `TABLE` adds new columns to the end of the table. To place
    a column at a specific position, use `FIRST` or `AFTER` at the end of the `ADD`
    clause. The following `ALTER` `TABLE` statements are similar to the one just shown,
    but place the `id` column first in the table or after the `name` column, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 15.10 Managing Multiple Auto-Increment Values Simultaneously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re executing multiple statements that generate `AUTO_INCREMENT` values,
    and it’s necessary to keep track of them independently. For example, you’re inserting
    rows into multiple tables, each of which has its own `AUTO_INCREMENT` column.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Save the sequence values in variables for later use. Alternatively, if you execute
    sequence-generating statements from within a program, you might be able to issue
    the statements using separate connection or statement objects to keep them from
    getting mixed up.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As described in [Recipe 15.4](#nch-sequences-seq-retrieve), the `LAST_INSERT_ID()`
    server-side sequence value function is set each time a statement generates an
    `AUTO_INCREMENT` value, whereas client-side sequence indicators may be reset for
    every statement. What if you issue a statement that generates an `AUTO_INCREMENT`
    value, but you don’t want to refer to that value until after issuing a second
    statement that also generates an `AUTO_INCREMENT` value? In this case, the original
    value is no longer accessible, either through `LAST_INSERT_ID()` or as a client-side
    value. To retain access to it, save the value first before issuing the second
    statement. There are several ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the SQL level, save the value in a user-defined variable after issuing a
    statement that generates an `AUTO_INCREMENT` value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then you can issue other statements without regard to their effect on `LAST_INSERT_ID()`.
    To use the original `AUTO_INCREMENT` value in a subsequent statement, refer to
    the `@saved_id` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the API level, save the `AUTO_INCREMENT` value in an API language variable.
    This can be done by saving the value returned from either `LAST_INSERT_ID()` or
    any API-specific extension that is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some APIs enable you to maintain separate client-side `AUTO_INCREMENT` values.
    For example, Perl DBI statement handles have a `mysql_insertid` attribute, and
    the attribute value for one handle is unaffected by activity on another. In Java,
    use separate `Statement` or `PreparedStatement` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Recipe 15.11](#nch-sequences-seq-relate) for application of these techniques
    to situations in which you must insert rows into multiple tables that each contain
    an `AUTO_INCREMENT` column.
  prefs: []
  type: TYPE_NORMAL
- en: 15.11 Using Auto-Increment Values to Associate Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use sequence values from one table as keys in a second table so that you
    can associate rows in the two tables with each other. But the associations aren’t
    being set up properly.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re probably not inserting rows in the proper order, or you’re losing track
    of the sequence values. Change the insertion order, or save the sequence values
    so that you can refer to them when you need them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Be careful with an `AUTO_INCREMENT` value used as an ID value in a master table
    if you also store the value in detail table rows for the purpose of linking the
    detail rows to the proper master table row. Suppose that an `invoice` table lists
    invoice information for customer orders, and an `inv_item` table lists the individual
    items associated with each invoice. Here, `invoice` is the master table and `inv_item`
    is the detail table. To uniquely identify each order, include an `AUTO_INCREMENT`
    column `inv_id` in the `invoice` table. You’d also store the appropriate invoice
    number in each `inv_item` table row so that you can tell which invoice it goes
    with. The tables might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For this kind of table relationship, it’s typical to insert a row into the
    master table first (to generate the `AUTO_INCREMENT` value that identifies the
    row), and then insert the detail rows using `LAST_INSERT_ID()` to obtain the master
    row ID. If a customer buys a hammer, three boxes of nails, and (in anticipation
    of finger-bashing with the hammer) a dozen bandages, the rows pertaining to the
    order can be inserted into the two tables like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first `INSERT` adds a row to the `invoice` master table and generates a
    new `AUTO_INCREMENT` value for its `inv_id` column. The following `INSERT` statements
    each add a row to the `inv_item` detail table, using `LAST_INSERT_ID()` to get
    the invoice number. This associates the detail rows with the proper master row.
  prefs: []
  type: TYPE_NORMAL
- en: What if you have multiple invoices to process? There’s a right way and a wrong
    way to enter the information. The right way is to insert all the information for
    the first invoice, then proceed to the next. The wrong way is to add all the master
    rows into the `invoice` table, then add all the detail rows to the `inv_item`
    table. If you do that, *all* the new detail rows in the `inv_item` table have
    the `AUTO_INCREMENT` value from the most recently entered `invoice` row. Thus,
    all items appear to be part of that invoice, and rows in the two tables don’t
    have the proper associations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the detail table contains its own `AUTO_INCREMENT` column, you must be even
    more careful about how you add rows to the tables. Suppose that you want each
    row in the `inv_item` table to have a unique identifier. To do that, create the
    `inv_item` table as follows with an `AUTO_INCREMENT` column named `item_id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `inv_id` column enables each `inv_item` row to be associated with the proper
    `invoice` table row, just as with the original table structure. In addition, `item_id`
    uniquely identifies each item row. However, now that both tables contain an `AUTO_INCREMENT`
    column, you cannot enter information for an invoice the same way as before. If
    you execute the `INSERT` statements shown previously, they now produce a different
    result due to the change in the `inv_item` table structure. The `INSERT` into
    the `invoice` table works properly. So does the first `INSERT` into the `inv_item`
    table; `LAST_INSERT_ID()` returns the `inv_id` value from the master row in the
    `invoice` table. However, this `INSERT` also generates its own `AUTO_INCREMENT`
    value (for the `item_id` column), which changes the value of `LAST_INSERT_ID()`
    and causes the master row `inv_id` value to be <q>lost.</q> As a result, each
    of the remaining inserts into the `inv_item` table stores the preceding row’s
    `item_id` value into the `inv_id` column. This causes the second and following
    rows to have incorrect `inv_id` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this difficulty, save the sequence value generated by the insert into
    the master table and use the saved value for the inserts into the detail table.
    To save the value, use a user-defined SQL variable or a variable maintained by
    your program. [Recipe 15.10](#nch-sequences-seq-simultaneous) describes those
    techniques, which apply here as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a user-defined variable: Save the master row `AUTO_INCREMENT` value in
    a user-defined variable for use when inserting the detail rows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a variable maintained by your program: This method is similar to the previous
    one, but applies only from within an API. Insert the master row, and then save
    the `AUTO_INCREMENT` value into an API variable for use when inserting detail
    rows. For example, in Ruby, access the `AUTO_INCREMENT` value using the `last_id`
    method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 15.12 Using Sequence Generators as Counters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re interested only in counting events, so you want to avoid having to create
    a new table row for each sequence value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Increment a single row per counter.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AUTO_INCREMENT` columns are useful for generating sequences across a set of
    individual rows. But some applications require only a count of the number of times
    an event occurs, and there’s no benefit from creating a separate row for each
    event. Instances include web page or banner ad hit counters, a count of items
    sold, or the number of votes in a poll. Such applications need only a single row
    to hold the count as it changes over time. MySQL provides a mechanism for this
    that enables counts to be treated like `AUTO_INCREMENT` values so that you can
    not only increment the count, but retrieve the updated value easily.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To count a single type of event, use a trivial table with a single row and
    column. For example, to record copies sold of a book, create a table like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you’re counting sales for multiple book titles, that method doesn’t
    work well. You certainly don’t want to create a separate single-row counting table
    per book. Instead, count them all within a single table by including a column
    that uniquely identifies each book. The following table does this using a `title`
    column for the book title in addition to a `copies` column that records the number
    of copies sold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To record sales for a given book, different approaches are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize a row for the book with a `copies` value of 0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then increment the `copies` value for each sale:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method requires that you remember to initialize a row for each book or
    the `UPDATE` will fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `INSERT` with `ON` `DUPLICATE` `KEY` `UPDATE`, which initializes the row
    with a count of 1 for the first sale and increments the count for subsequent sales:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is simpler because the same statement works to initialize and update the
    sales count.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To retrieve the sales count (for example, to display a message to customers
    such as <q>you just purchased copy *`n`* of this book</q>), issue a `SELECT` query
    for the same book title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this is not quite correct. Suppose that between the times when
    you update and retrieve the count, some other person buys a copy of the book (and
    thus increments the `copies` value). Then the `SELECT` statement won’t actually
    produce the value *you* incremented the sales count to, but rather its most recent
    value. In other words, other clients can affect the value before you have time
    to retrieve it. This is similar to the problem discussed in [Recipe 15.4](#nch-sequences-seq-retrieve)
    that can occur if you try to retrieve the most recent `AUTO_INCREMENT` value from
    a column by invoking `MAX(`*`col_name`*`)` rather than `LAST_INSERT_ID()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are ways around this (such as by grouping the two statements as a transaction
    or by locking the table), but MySQL provides a simpler solution based on `LAST_INSERT_ID()`.
    If you call `LAST_INSERT_ID()` with an expression argument, MySQL treats it like
    an `AUTO_INCREMENT` value. To use this feature with the `booksales` table, modify
    the count-incrementing statement slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement uses the `LAST_INSERT_ID(`*`expr`*`)` construct both to initialize
    and to increment the count. MySQL treats the expression argument like an `AUTO_INCREMENT`
    value, so that you can invoke `LAST_INSERT_ID()` later with no argument to retrieve
    the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting and retrieving the `copies` column this way, you always get back
    the value you set it to, even if some other client updated it in the meantime.
    If you issue the `INSERT` statement from within an API that provides a mechanism
    for fetching the most recent `AUTO_INCREMENT` value directly, you need not even
    issue the `SELECT` query. For example, using Connector/Python, update a count
    and get the new value using the `lastrowid` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, the operation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Use of `LAST_INSERT_ID(`*`expr`*`)` for sequence generation has certain other
    properties that differ from true `AUTO_INCREMENT` sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AUTO_INCREMENT` values increment by one each time, whereas values generated
    by `LAST_INSERT_ID(`*`expr`*`)` can be any nonnegative value you want. For example,
    to produce the sequence 10, 20, 30, …, increment the count by 10 each time. You
    need not even increment the counter by the same value each time. If you sell a
    dozen copies of a book rather than a single copy, update its sales count as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To reset a counter, simply set it to the desired value. Suppose that you want
    to report to book buyers the sales for the current month, rather than the total
    sales (for example, to display messages like <q>you’re the *`n`*th buyer this
    month</q>). To clear the counters to zero at the beginning of each month, use
    this statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One property that’s not so desirable is that the value generated by `LAST_INSERT_ID(`*`expr`*`)`
    is not uniformly available via client-side retrieval methods under all circumstances.
    You can get it after `UPDATE` or `INSERT` statements, but not for `SET` statements.
    If you generate a value as follows (in Ruby), the client-side value returned by
    `insert_id` is 0, not 48:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the value in this case, ask the server for it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 15.13 Generating Repeating Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You require a sequence that contains cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make cycles in the sequence with division and modulo operations.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some sequence-generation problems require values that go through cycles. Suppose
    that you manufacture items such as pharmaceutical products or automobile parts,
    and you must be able to track them by lot number if manufacturing problems are
    discovered later that require items sold within a particular lot to be recalled.
    Suppose also that you pack and distribute items 12 units to a box and 6 boxes
    to a case. In this situation, item identifiers are three-part values: the unit
    number (with a value from 1 to 12), the box number (with a value from 1 to 6),
    and a lot number (with a value from 1 to the highest current case number).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This item-tracking problem appears to require that you maintain three counters,
    so you might generate the next identifier value using an algorithm like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it’s possible simply to assign each item a sequence number identifier
    and derive the corresponding case, box, and unit numbers from it. The identifier
    can come from an `AUTO_INCREMENT` column or a single-row sequence generator. The
    formulas for determining the case, box, and unit numbers for any item from its
    sequence number look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table illustrates the relationship between some sample sequence
    numbers and the corresponding case, box, and unit numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| seq | case | box | unit |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 1 | 1 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | 1 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 72 | 1 | 6 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| 73 | 2 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 144 | 2 | 6 | 12 |'
  prefs: []
  type: TYPE_TB
- en: 15.14 Using Custom Increment Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to increment sequences not by one but by a different number.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the system variables `auto_increment_increment` and `auto_increment_offset`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default MySQL increases values in a column, having an `AUTO_INCREMENT` option,
    by one. This is not always desirable. Suppose you have a replication chain ([Recipe
    3.9](ch03.xhtml#nch-replication-replication-circle)) of three servers: `Venus`,
    `Mars`, `Saturn` and want to distinguish from which server the inserted value
    is originated.'
  prefs: []
  type: TYPE_NORMAL
- en: The simpliest solution for this issue would be to assign sequence of `1, 4,
    7, 10, ...` values to the rows, inserted on `Venus`; sequence of `2, 5, 8, 11,
    ...` to the rows, inserted on `Mars` and sequence of `3, 6, 9, 12, ...` for the
    rows, inserted on `Saturn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do it set the value of the system variable `auto_increment_increment` to
    the number of servers: in our case three (3), so MySQL will increment sequence
    value by three. Then set `auto_increment_offset` to one (1) on `Venus`, to two
    (2) on `Mars` and to three (3) on `Saturn`. This will instruct MySQL to start
    new sequences from the specified values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We set session variables for our example, but if you want to affect not only
    your own session, but all connections on the server you need to use *SET GLOBAL*.
    To preserve configuration change after restart set these value in the configuration
    file, or, starting from the version 8.0, use command *SET PERSIST*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already have tables with an auto-increment column, specify the offset
    using statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Not all engines support option `AUTO_INCREMENT` for the *CREATE TABLE* and *ALTER
    TABLE*. In this case you can set starting value for the auto-incremented column
    by inserting a row with the desired value, then removing it.
  prefs: []
  type: TYPE_NORMAL
- en: After preparations are done MySQL will use `auto_increment_increment` value
    to generate the next sequence number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-sequences-seq-increment_increment-hostname_co)'
  prefs: []
  type: TYPE_NORMAL
- en: System variable `hostname` contains value of the MySQL host. We use it to distinguish
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-sequences-seq-increment_increment-venus_co)'
  prefs: []
  type: TYPE_NORMAL
- en: 'On `Venus` sequence starts from one and we have expected values: `1, 4, 7`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-sequences-seq-increment_increment-alter_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Table on `Mars` already existed. The *ALTER TABLE* command sets offset for the
    `AUTO_INCREMENT` sequence to the desired value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-sequences-seq-increment_increment-mars_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Since table `offset` already had rows on Mars new `AUTO_INCREMENT` value started
    from 8 that belongs to the sequence `2, 5, 8, 11, ...`.
  prefs: []
  type: TYPE_NORMAL
- en: 15.15 Using Window Functions to Number Rows In the Result Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to enumerate the result of a `SELECT` query.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the window function `ROW_NUMBER()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sequences are useful not only when you store data in tables, but also when you
    work with results of queries.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are running a singing competition. Each talent should present in
    its turn. To provide everyone equal chances the position in the queue should be
    defined randomly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Talents are stored in the `name` table. To retrieve them in random order use
    function *RAND()*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This query will return list of names in different orders each time it is called.
  prefs: []
  type: TYPE_NORMAL
- en: Window functions can perform calculations per each row in the result set and
    we can use them to create a new column with order in which the singers will perform.
  prefs: []
  type: TYPE_NORMAL
- en: Window functions work over a specific window that in our case is a `SELECT`
    query. They may access multiple rows while are executing but produce result for
    each row in the window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-sequences-seq-window-functions-over_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Function *ROW_NUMBER()* defines the position in the singing schedule.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-sequences-seq-window-functions-table_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Other columns in the table `name` which we want to see in the query result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-sequences-seq-window-functions-window_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword `WINDOW` defines named window over which we will use the function *ROW_NUMBER*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-sequences-seq-window-functions-order_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the window in random order to get fair queue distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Another common use of the function *ROW_NUMBER()* is to generate a sequence
    of identifiers that later could be used to join `SELECT` result with the another
    table. We discuss this approach in one of examples in [Recipe 15.16](#nch-sum-sum-recursive-cte).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about window functions, see [Window Function Concepts
    and Syntax](https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html).
  prefs: []
  type: TYPE_NORMAL
- en: 15.16 Generating Series with Recursive CTEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a custom sequence, such as a geometric progression or Fibonacci
    number.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use recursive Commont Table Expressions (CTEs) to create the sequence from the
    custom formula.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sequences should not always be an arithmetic progression. They could be any
    kind of progression and even random numbers or strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to create custom sequences is recursive CTE. They are named temporary
    result sets that allow self-referencing. Basic recursive CTE syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Thus, to generate a geometric progression starting from two with a common ratio
    two use CTE as follow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-sum-sum-recursive-cte-init_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Starting value for the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-sum-sum-recursive-cte-next_co)'
  prefs: []
  type: TYPE_NORMAL
- en: All subsequent values in the geometric progression are previous number multiplied
    by the common ratio.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-sum-sum-recursive-cte-limit_co)'
  prefs: []
  type: TYPE_NORMAL
- en: To limit number of the generated numbers and avoid infinite loops use either
    `LIMIT` clause or any valid `WHERE` condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursive CTEs allow to create multiple sequences at the same time. For example,
    we can use them to create:'
  prefs: []
  type: TYPE_NORMAL
- en: An id that will use regular arithmetic progression, starting from one with a
    common difference one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A geometric progression, starting from three with a common ratio four
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random number between one and five
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create all these in a single query use a recursive CTE as follow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: To illustrate use of the custom sequence suppose that we are working on a new
    Data Phobia vaccine and want to start phase III trials on it. Phase III includes
    testing of the real vaccine and a placebo. Doses are distributed randomly between
    volunteers. To perform this trial we will use table `patients` and those who do
    not have diagnosis of Data Phobia already. We generate a sequence of two random
    values and assign either a real vaccine or a placebo based on that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-sum-sum-recursive-cte-options_co)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function *FLOOR(1+RAND()*2)* generates two random numbers: one or two. Function
    *IF* works as a ternary operator: if the first argument is true it returns the
    second one, otherwise it returns the third argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-sum-sum-recursive-cte-count_co)'
  prefs: []
  type: TYPE_NORMAL
- en: We do not want patients who already diagnosed with Data Phobia to participate
    in our tests as well as we cannot test our vaccine on the patients who did not
    recover.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-sum-sum-recursive-cte-volunteers_co)'
  prefs: []
  type: TYPE_NORMAL
- en: While the table `patients` has an `AUTO_INCREMENT` column `id` we cannot use
    it, because we could not excude patients that do not participate in our tests
    this way. Therefore we use CTE to create named result set `volunteers` and generate
    its own sequence for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-sum-sum-recursive-cte-rownumber_co)'
  prefs: []
  type: TYPE_NORMAL
- en: The function *ROW_NUMBER()* generates new sequence for the patients who participate
    in the tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_nch-sum-sum-recursive-cte-join_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Join generated sequence of random values for the dose and named result set `volunteers`
    using generated `id` without including it into the final result set.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about Common Table Expressions, see [Recipe 10.18](ch10.xhtml#nch-sum-sum-with).
  prefs: []
  type: TYPE_NORMAL
- en: 15.17 Creating and Storing Custom Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use custom sequence as a stored id column in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a table that will hold sequence values and a function that will update
    and select these values.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although MySQL does not support the SQL `SEQUENCE` object, it is pretty easy
    to imitate one.
  prefs: []
  type: TYPE_NORMAL
- en: First you need to create a table that will hold sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'For this recipe we used the same table definition that the MySQL Engineering
    Team is planning to implement as part of [WL#827: SEQUENCE object as in Oracle,
    PostgreSQL, and/or SQL:2003](https://dev.mysql.com/worklog/task/?id=827) . This
    definition is not required for real-life sequence implementation that could be
    either simpler or have more options.'
  prefs: []
  type: TYPE_NORMAL
- en: Columns in the table `sequences` all have special meanings. [Table 15-1](#nch-sequences-seq-custom-sequences)
    shows their meanings.
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1\. Columns in the table `sequences`
  prefs: []
  type: TYPE_NORMAL
- en: '| Column | Description | Comments |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sequence_name` | Name of the sequence. | Required field, should be unique.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `maximum_value` | Maximum value that the sequence can generate. | We allow
    negative values in our custom sequence, therefore maximum possible value is 9223372036854775807
    that is the maximum value for the `BIGINT SIGNED` datatype. If you make this column
    `BIGINT UNSIGNED` the sequence could have two times more values. This option is
    not critical for the sequence generation and could be skipped. |'
  prefs: []
  type: TYPE_TB
- en: '| `minimum_value` | Minimum value for the sequence. | In our case default is
    -9223372036854775808 that is the minimum for the type `BIGINT SIGNED`. Depending
    on how you want to create custom sequences this column could be skipped or have
    different type or different default value. |'
  prefs: []
  type: TYPE_TB
- en: '| `increment` | Increment for the sequence. | SQL standard defines sequence
    that use arithmetic progression. This column contains a common difference for
    the progression. This is required field.If you create custom sequence, such as
    geometric progression you may have a common ratio in this field or any other value
    that allows to generate the next one. |'
  prefs: []
  type: TYPE_TB
- en: '| `start_value` | The value from which the sequence will start. | This is not
    essential field for implemnting sentences. In our case it is `minimum_value` by
    default. |'
  prefs: []
  type: TYPE_TB
- en: '| `current_base_value` | The value that the sequence needs to return when asked
    for the next value. Once returned it should be replaced with the newly generated
    one. | This is required field. Default is the same as `start_value`. |'
  prefs: []
  type: TYPE_TB
- en: '| `cycle_option` | Does the sequence support cycles? | If enabled the sequence
    will reset back to `start_value` when it reaches either its `minimum_value` or
    `maximum_value`. |'
  prefs: []
  type: TYPE_TB
- en: Then we need to create a stored procedure that will update the table `sequences`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Using stored routines, rather than updating the table `sequences` directly,
    has a number of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You do not need to care on how to update the `current_base_value` each time
    you use the sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `cycle_option` is enabled you do not need to put code, resetting the `current_base_value`
    each time when the sequence boundaries are reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may restrict direct access to the table `sequences` for anyone, except the
    administrator while still allow application users to use sequences. See [Recipe
    24.13](ch24.xhtml#nch-security-security-routines) for the details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL does not allow us to call a stored function with a variable number of
    arguments. The function *COALESCE* allows to put defaults if `NULL` values are
    passed in the places of the arguments for which you want to have default values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In the example above we first created sequence `bar` that starts from 1, increments
    by 1, does not have cycle option and has default `maximum_value` 9223372036854775807\.
    Then, we created the sequence `baz`, that also starts from 1, increments by 1,
    but has `cycle_option` enabled and `maximum_value` 10, so it cycles quite fast.
    Finally, we created sequence `foo` that has only custom name and all other defaults.
  prefs: []
  type: TYPE_NORMAL
- en: To get the next sequnece value and update the sequence table at the same time
    we will use a stored function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The function first retrieves `current_base_value` of the sequence using statement
    `SELECT ... FOR UPDATE`, so other connections would not modify the sequence until
    we return the value.
  prefs: []
  type: TYPE_NORMAL
- en: Our function supports cycles. In cases where `cycle_option` is enabled, and
    the next sequence value exceeds the boundaries, it sets `current_base_value` to
    the value, defined by the `start_value`. If `cycle_option` is disabled and the
    next sequence value exceeds boundaries we insert `NULL` value into the column
    `current_base_value` that MySQL will reject with an error. You may consider raising
    a custom exception instead.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how `cycle_option` option works let’s see how sequence `baz`
    behaves when its boundaries are reached.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate function behavior when boundaries are reached while `cycle_option`
    is not enabled we created a sequence that has small maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: To use custom sequences with tables simply call `sequence_next_value` each time
    when you need the next sequence value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You can automate sequence values generation for your tables if use triggers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In this example we generate new sequence value when a user tries to insert `NULL`
    into the `id` column of the table `sequence_test`. If the user, instead, decides
    to specify the value explicitly, the trigger would not change it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to define a stored procedure to delete the sequence when we
    do not need it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You will find code for maintaining custom sequneces in the file `sequences/custom_sequences.sql`
    of the `recipes` distribution.
  prefs: []
  type: TYPE_NORMAL
