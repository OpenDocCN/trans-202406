- en: Chapter 9\. Intrusion Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will see how container intrusion detection operates with
    the new low-level eBPF interface, what forensics looks like for a container, and
    how to catch attackers who have evaded all other controls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Defense in depth means limiting the trust you place in each security control
    you deploy. No solution is infallible, but you can use intrusion detection systems
    (IDS) to detect unexpected activity in much the same way that motion sensors detect
    movement. Your adversary has already accessed your system and may even have viewed
    confidential information already, so an IDS reviews your system in real time for
    unexpected behavior and observes or blocks it. Alerts can trigger further defensive
    actions from an IDS, like dumping compromised memory or recording network activity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Intrusion detection can inspect file, network, and kernel reads and writes to
    verify or block them with an allowlist or a denylist (as `seccomp-bpf` configuration
    does). If Captain Hashjack’s Hard Hat Hacking Collective has remote access to
    your servers, an IDS might be triggered by their use of malware with known behavioral
    signatures, scan of networks or files for further targets, or any other program
    access that deviates from the expected “stable” baseline the IDS has learned about
    the process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Some attackers’ campaigns are only discovered after the adversary has been on
    the system for weeks or months and finally inadvertently tripped the IDS detection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Defaults
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stable behavior is what we’d expect our container process to do normally, when
    running as intended, and not compromised. We can apply the same thing to any data
    we collect: access and audit logs, metrics and telemetry, and system calls and
    network activity.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Intrusion detection to identify deviance from this behavior requires installation,
    maintenance, and monitoring. By default most systems do not have any intrusion
    detection unless configured to do so.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Threat Model
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Intrusion detection can detect threats to BCTL’s systems. If an attacker gets
    remote code execution (RCE) into a container they may be able to control the process,
    changing its behavior. Potentially nonstable behaviors that could indicate compromise
    might include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: New or disallowed system calls (perhaps fork or exec system calls to create
    a shell like Bash or sh)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any unexpected network, filesystem, file metadata, or device access
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application usage and order
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unexplained processes or files
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to users or identity settings
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System and kernel configuration events
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of a process’s properties and behaviors when interacting with the wider
    system may also be subject to scrutiny.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Attack tools like [ccat](https://oreil.ly/pKyt0) and [dockerscan](https://oreil.ly/bchJw)
    can poison images in registries and install backdoors in container images that
    an attacker may use to gain entry to your pods at runtime. This sort of unexpected
    behavior should be noticed and alerted on by your IDS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don’t want to be alerted to legitimate activity, so you authorize
    expected behavior. It’s either preconfigured with rules and signatures or learned
    while the process is under observation in a nonproduction environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: These threats should be identified and configured to alert your IDS system.
    We’ll see how in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Traditional IDS
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into cloud native IDS, let’s have a look at a few of the other
    intrustion detection applications that have been prominent over the years.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Traditional intrusion detection systems are classed as Network- or Host-based
    IDS (NIDS or HIDS), and some tools offer both. Historically these used signals
    from the host kernel or network adapter, and were not aware of the Linux namespaces
    that containers use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Linux has [`auditd`](https://oreil.ly/N5BSs) built in for system call events,
    but this doesn’t correlate activity nicely across nodes in a distributed system.
    It’s also considered heavyweight (it generates a great volume of logs) and can’t
    distinguish by namespace due to “complex and incomplete” ID tracking of namespaced
    processes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Tools like [Suricata](https://suricata.io), [Snort](https://www.snort.org),
    and [Zeek](https://zeek.org) inspect network traffic against a rule and scripting
    engine, and may be run on the same host or (as they tend to be resource intensive)
    on dedicated hardware attached to the network under observation. Encrypted or
    steganographic payloads may escape such NIDS undetected. To further guard against
    these slippery assailants, the old-but-effective [Tripwire](https://oreil.ly/3ewaE)
    tool watches files on the host for unauthorized changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: An IDS detects threats by either using preknown information about them or detecting
    deviance from an expected baseline. Information known in advance can be considered
    a “signature,” and signatures can relate to network traffic and scans, malware
    binaries, or memory. Any suspicious patterns in packets, “fingerprints” of application
    code or memory usage, and process activities are verified against an expected
    ruleset derived from the application’s “known good” behavior.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Once a signature pattern is identified (for example, the SUNBURST traffic back
    to command and control servers), the IDS creates a relevant alert.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: FireEye released IDS configurations [to detect SUNBURST](https://oreil.ly/kgkNH).
    These configurations support various IDS tools including Snort, Yara, IOC, and
    ClamAV.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Signatures are distributed and update files, so you must regularly update them
    to ensure new and recent threats are detected. A signature-based approach is usually
    less resource intensive and less prone to false positives, but it may not detect
    zero-days and novel attacks. Attackers have access to defensive tooling and can
    determine how to circumvent controls in their own test systems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Without predefined signatures to trip the IDS, anomalous behavior may be detected.
    This relies on a “known good state” of the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The derivation of a normal application behavior state defines “secure,” which
    puts the onus on defenders to ensure application correctness, rather than on the
    tool to enforce a generic ruleset.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: This observational approach is more powerful than signatures as it can act autonomously
    against new threats. The price for this more general protection is greater resource
    utilization, which may impact the performance of the system being protected.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Signature and anomaly detection can be fooled, circumvented, and potentially
    disabled by a skilled adversary, so never rely entirely upon one control.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[VirusTotal](https://oreil.ly/Zpw8C) is a library of malicious files. When
    a defender discovers an attack, they upload the files retrieved by forensics (for
    example, malware, implants, and C2 binaries or encrypted files), allowing researchers
    to correlate techniques across targets and helping defenders to understand their
    adversary, the attacks being used, and (with any luck) how they can best defend
    themselves. Antivirus vendors ensure their products have signatures for every
    malicious file on VirusTotal, and new submissions are scanned by existing virus
    detection engines for matches.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Attackers use these same tools to ensure their payloads will bypass antivirus
    and malware signature scanners. Red Teams have been retrospectively discovered
    leaking tooling and signatures onto VirusTotal once their attacking campaigns
    have been decloaked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: eBPF-Based IDS
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running IDS for every packet or system call can incur overhead and slow down
    the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduced eBPF in [“eBPF”](ch05.xhtml#workload-networking-bpf) as a mechanism
    to safely and efficiently extend the Linux kernel. eBPF avoids some of these issues
    by being very fast indeed: it was designed for fast packet handling, and now kernel
    developers use it to observe runtime behavior for everything in the kernel. Because
    it runs inside the kernel as trusted code it is less restricted than other IDS
    and tracing technologies.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: However, running in the kernel poses its own set of possible risks, and the
    eBPF subsystem and JIT compiler have had a number of breakouts, but these are
    considered less dangerous than slow, incomplete kernel developer tracing solutions
    or more fallible IDS.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Jeff Dileo’s](https://oreil.ly/BPYwJ) [“Evil eBPF In-Depth Practical Abuses
    of an In-Kernel Bytecode Runtime”](https://oreil.ly/sllD3) is a good primer on
    BPF and its attacks, and [“Kernel Pwning with eBPF: A Love Story”](https://oreil.ly/KzOg0)
    by [Valentina Palmiotti](https://oreil.ly/NjjEf) is a walkthrough of the various
    components of eBPF.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Since eBPF’s powers have been extended and integrated more deeply into the kernel,
    a number of CNIs and security products now use eBPF for detection and networking
    including [Cilium](https://cilium.io), [Pixie](https://pixielabs.ai), and [Falco](https://falco.org)
    (which we detail in the following section).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with all container software, bugs can lead to container breakout, as in [CVE-2021-31440](https://oreil.ly/82xbU),
    where an incorrect bounds calculation in the Linux kernel eBPF verifier allowed
    an exploitable verifier bypass.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to some applications of eBPF in Kubernetes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes and Container Intrusion Detection
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are signature and anomaly detection systems available for Kubernetes workloads
    at runtime. Kubernetes and container IDS systems support namespaced workload,
    host, and network IDS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: By splitting processes into namespaces, you can use more well-defined metadata
    to help an IDS make decisions. This more granular data can give greater insight
    into an attack, which is vital when the decision to kill a running container may
    affect your production workloads.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives container IDS an advantage: the behavior it is monitoring is just
    a single container, not a whole machine. The definition of allowed behavior is
    much smaller in a single-purpose container, so the IDS has a far greater fidelity
    of policy to block unwanted behavior. With this in mind, let’s now have a look
    at a few container-specific IDS.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Falco
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Falco is an open source, cloud native IDS that can run in a container or on
    a host. Traditionally, Falco required a dedicated kernel module to run (with its
    code loaded into the kernel) so that it could interact with system calls. Since
    2019, Falco has also supported eBPF. The eBPF interface allows general-purpose
    code to be loaded by Falco, from userspace, into the kernel’s memory. This means
    less custom code, fewer kernel modules, and the ability to use the kernel monitoring
    and enforcement techniques through a well-known interface.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: When run in a container, it requires privileged access to the host or use of
    the `CAP_BPF` capability with host PID namespace access.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'In eBPF mode, when a process interacts with a file using a system call such
    as `open()`, the eBPF program is triggered, which can run arbitrary code in a
    kernel VM to make its decision. Depending on the inputs, the action will be accepted
    or blocked:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Falco is based on Sysdig, a system introspection tool. Sysdig Cloud offers workload
    and Kubernetes performance monitoring, and [Sysdig Secure](https://oreil.ly/S6q1e)
    is the commercial product built around Falco.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Falco comes with a collection of [community contributed and maintained rules](https://oreil.ly/T43NW),
    including dedicated rules to manage Kubernetes clusters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Unexpected inbound TCP connections:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detects inbound TCP traffic to Kubernetes components from a port outside of
    an expected set
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowed inbound ports:'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`6443` (`kube-apiserver` container)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10252` (`kube-controller` container)'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`8443` (`kube-dashboard` container)'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10053`, `10055`, `8081` (`kube-dns` container)'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10251` (`kube-scheduler` container)'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unexpected spawned processes:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detects a process started in a Kubernetes cluster outside of an expected set
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowed processes:'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-apiserver` (for `kube-apiserver` container)'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-controller-manager` (for `kube-controller` container)'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dashboard` (`kube-dashboard` container)'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/kube-dns` (`kube-dns` container)'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-scheduler` (`kube-scheduler` container)'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unexpected file access readonly:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detects an attempt to access a file in readonly mode, other than those in an
    expected list of directories
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowed file prefixes for readonly:'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/public`'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules form a useful base set to extend with custom rules for your own
    cluster’s specific security needs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'While it’s almost always better to consume community contributed rules, no
    software is free of bugs. For example, Darkbit found a [Falco rule bypass](https://oreil.ly/wgZy7)
    that exploited a loose regex rule to deploy a custom privileged agent container—`docker.io/my-org-name-that-ends-with-sysdig/agent`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Machine Learning Approaches to IDS
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Machine learning (ML) replays the same signals used in other IDS systems through
    a model, which then predicts whether the container is compromised.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many examples of machine learning IDS available:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[Aqua Security](https://oreil.ly/gfl98) uses ML-based behavioral profiling
    to analyze and react to behaviors in containers, the network, and hosts.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Prisma Cloud](https://oreil.ly/AoLCX)’s layer 3 inter-container firewall learns
    valid traffic flows between app components with ML.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lacework](https://oreil.ly/6pooI) uses unsupervised machine learning for cross-cloud
    observability and response to runtime threats.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Accuknox](https://accuknox.com) uses unsupervised machine learning to detect
    instability and discern potential attacks, and “Identity as a Perimeter” for zero-trust
    network, application, and data protection.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container Forensics
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forensics is the art of reconstructing data from incomplete or historical sources.
    In Linux this involves capturing process, memory, and filesystem contents to interrogate
    them offline, find the source or impact of a breach, and inspect adversarial techniques.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: More advanced systems gather more information, like network connection information
    they were already logging. In the event of a serious break, the entire cluster
    or account may be cut off from the network so that the attacker cannot continue
    their assault, and the entire system can be imaged and explored.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Tools like [kube-forensics](https://oreil.ly/s4xup) “create checkpoint snapshots
    of the state of running pods for later off-line analysis,” so malicious workloads
    can be dumped and killed, and the system returned to use. It runs a `forensics-controller-manager`
    with a `PodCheckpoint` custom resource definition (CRD) to effectively `docker
    inspect`, `docker diff`, and finally `docker export`. Notably, this does not capture
    the process’s memory, which may have implants or attacker tools that were not
    saved to disk or were deleted once the process started.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture a process’ memory, you can use standard tools like GDB. Using these
    tools from inside a container is difficult as symbols may be required. From outside
    a container, dumping memory and searching it for interesting data is trivial,
    as this [simple Bash script](https://oreil.ly/6eDzc) mashing together [Trufflehog](https://oreil.ly/U2ibi)
    and GDB process dumping demonstrates:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Put this script into *procdump.sh* and run it against a local shell:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will see any high entropy strings or suspected secrets that were loaded
    into the shell:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Warning
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An attacker as root in a process namespace can dump the memory of any other
    process in the namespace. The root user in the host process namespace can dump
    any process memory on the node (including child namespaces).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Avoid this type of attack in a cloud native application by retrieving secrets
    at time of use from a filesystem or key management system. If you can discard
    the Secrets from memory when not in use, you’ll be more resilient to this attack.
    You can also encrypt Secrets in memory, although the decryption keys suffer the
    same risk of being dumped and so should also be discarded when not in use.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Honeypots
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![captain](Images/haku_0000.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'Although IDS can detect and prevent almost all abuses of your systems, we cannot
    emphasize enough that there is no such thing as a silver bullet. It should be
    assumed that rogue sea dogs like Captain Hashjack will still be able to bypass
    any careful security configuration. A complex system offers asymmetrical advantage
    for an attacker: a defender only has to make one mistake to get compromised.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Attackers may still be able to escape from a container or traverse onto the
    host. Or, if they’re in a container governed by IDS and manipulates the expected
    behavior of the application (for example, by invoking the same application with
    different flags), they may be able to read sensitive data without triggering IDS
    alarms.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: So the last line of defense is the humble honeypot, a simple server or file
    that legitimate applications never use. It innocuously nestles in a tempting or
    secured location and triggers an alert when an attacker accesses it. Honeypots
    might be triggered by a network scan, or HTTP requests that the system would never
    usually make.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-1](#ids-honeypot-architecture) shows BCTL’s honeypot entrapping Dread
    Pirate Hashjack. A honeypot such as this one is as simple as using tools like
    [ElastAlert](https://oreil.ly/L1bSu) to monitor, audit, and access logs for pods
    that should never be accessed.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Catching an attacker in a Honeypot](Images/haku_0901.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Catching an attacker in a honeypot
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You are looking to catch an attacker operating inside the pod network. They
    may scan local IP ranges for open TCP and UDP ports. Remember that each Kubernetes
    workload must be identical, so we can’t run “custom” pods to deploy a single honeypot.
    Instead, deploy a dedicated DaemonSet so each node is defended by a honeypot pod.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: If the attacker or internal actor has cluster DNS access, can read a pod’s environment
    variables, or has read access to the Kubernetes API, they can see the names of
    the Kubernetes services in the DNS and pod names. They may be looking for a specifically
    named target. You can name your honeypot service with an appealingly similar name
    (such as “myapp-data” or “myapp-support”) to entice an attacker. Deploying honeypots
    as a DaemonSet will ensure one is lying in wait on any node Captain Hashjack might
    plunder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Canary tokens](https://oreil.ly/1E7Eo) are honeypots for protocols like AWS
    and Slack keys, URLs, DNS records, QR codes, email addresses, documents, and binaries.
    They are “tiny tripwires” that you can drop in production systems and developer
    devices to detect compromise.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Auditing
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [Chapter 8](ch08.xhtml#ch-policy), Kubernetes generates audit
    logs for every API request it receives, and IDS tools can ingest and monitor that
    stream of information for unexpected requests. This could include requests from
    outside known IP ranges or expected working hours, honeytoken credentials, or
    attempts to use unauthorized APIs (e.g., a default service account token attempting
    to get all Secrets in its namespace or a privileged namespace).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Audit log level and depth is configurable, but as CVE-2020-8563 for Kubernetes
    v1.19.2 (and CVE-2020-8564, CVE-2020-8565, CVE-2020-8566) shows, defaults were
    not historically tight enough. Some sensitive request payload information was
    persisted to logs that could have been read from outside the cluster and then
    used to attack it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Unintended data leakage into logs is being mitigated in [KEP 1753](https://oreil.ly/5iuMK):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: This KEP proposes the introduction of a logging filter which could be applied
    to all Kubernetes system components logs to prevent various types of sensitive
    information from leaking via logs…Ensure that sensitive data cannot be trivially
    stored in logs. Prevent dangerous logging actions with improved code review policies.
    Redact sensitive information with logging filters. Together, these actions can
    help to prevent sensitive data from being exposed in the logs.
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It can be used with the `kubelet` flag `--experimental-logging-sanitization`
    in v1.20+.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Leaking Secrets into logs and audit streams is common in all technology organizations,
    and is another reason to avoid environment variables for sensitive information.
    Developers need introspection and useful output from running programs, but sanitizing
    debug during development is a rare practice. These debug strings invariably make
    their way into production, and so searching logs for Secrets is perhaps the only
    practical way to detect this.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The bugs that gave momentum to the log sanitization focus include:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: CVE-2020-8563
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Secret leaks in logs for vSphere Provider kube-controller-manager
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: CVE-2020-8564
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Docker config Secrets leaked when file is malformed and `logLevel` >= 4
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: CVE-2020-8565
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Incomplete fix for CVE-2019-11250 allows for token leak in logs when `logLevel`
    >= 9
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: CVE-2020-8566
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Ceph RBD adminSecrets exposed in logs when `logLevel` >= 4
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: You can read the disclosure on the [Kubernetes Forums](https://oreil.ly/yBvQu).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Detection Evasion
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bypassing Kubernetes audit logs was demonstrated by [Brad Geesaman](https://oreil.ly/KaOWm)
    and [Ian Coldwater](https://oreil.ly/KMK0u) at [RSA 2020](https://oreil.ly/LfzS0).
    As [Figure 9-2](#ids-oversized-logs) shows, the `etcd` datastore in the Kubernetes
    control plane is highly efficient and resillient, however it does not support
    large data sizes. That means request payloads in the audit logs that exceed 256
    KB will not get stored, enabling stealthy behavior with oversized log entries.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An attacker with access to the API server can blackhole, redirect, or tamper
    with any audit logs that are stored locally. As a post-mortem exercise it’s useful
    to explore an attacker’s path, so shipping the API server’s audit logs directly
    to a remote webhook backend safeguards against this. Configure the API server
    to use the flag `--audit-webhook-config-file` to ship logs remotely, or use a
    managed service that configures this for you.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![haku 0902](Images/haku_0902.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. Oversize `etcd` logs ([RSA 2020](https://oreil.ly/LfzS0))
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Security Operations Centers
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Larger organizations may have a Security Operations Center (SOC) that manages
    security information and events (SIEM).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Configuring enterprise applications for alerting on your audit and pod logs
    requires fine-tuning to avoid false positives and needless alerts. You can use
    a local cluster to build out automated tests and capture the audit log events,
    then use that data to configure your SIEM. Finally, rerun your automated tests
    to ensure alerts are raised correctly in production systems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You should run Red Team security tests against production systems to validate
    the Blue Team controls work as expected. This provides a real-world test for the
    attack trees and threat models that the system is configured upon.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intrusion detection is the last line of defense for a cloud native system. eBPF
    approaches offer greater speed on modern kernels, and the performance overhead
    is slight. Sensitive or web-facing workloads should always be guarded by IDS as
    they have the greatest risk of compromise.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'With this we’re switching gears and will turn our attention to the weakest
    link and its natural habitat: organizations.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
