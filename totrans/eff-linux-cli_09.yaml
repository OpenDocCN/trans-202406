- en: Chapter 7\. 11 More Ways to Run a Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have lots of commands in your toolbox and a thorough understanding
    of the shell, it’s time to learn…how to run commands. Wait a minute, haven’t you
    been running commands since the beginning of the book? Well, yes, but only in
    two ways. The first is the ordinary execution of a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is a pipeline of simple commands, as covered in [Chapter 1](ch01.xhtml#ch_combining_commands):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, I’ll show you 11 more ways to run a command and why you should
    care to learn them. Each technique has pros and cons, and the more techniques
    you know, the more flexibly and efficiently you can interact with Linux. I’ll
    stick to the basics of each technique for now; you’ll see more intricate examples
    in the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: List Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list is a sequence of commands on a single command line. You’ve already seen
    one type of list—a pipeline—but the shell supports others with different behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional lists
  prefs: []
  type: TYPE_NORMAL
- en: Each command depends on the success or failure of the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Unconditional lists
  prefs: []
  type: TYPE_NORMAL
- en: Commands simply run one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique #1: Conditional Lists'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you want to create a file *new.txt* in a directory *dir*. A typical
    sequence of commands might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the second command depends on the success of the first. If the directory
    *dir* doesn’t exist, there is no point in running the `touch` command. The shell
    lets you make this dependency explicit. If you place the operator `&&` (pronounced
    “and”) between the two commands on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: then the second command (`touch`) runs only if the first command (`cd`) succeeds.
    The preceding example is a *conditional list* of two commands. (To learn what
    it means for a command to “succeed,” see [“Exit Codes Indicate Success or Failure”](#sidebar_exit_codes).)
  prefs: []
  type: TYPE_NORMAL
- en: Very likely, you run commands every day that depend on previous ones. For example,
    have you ever made a backup copy of a file for safekeeping, modified the original,
    and deleted the backup when done?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these commands makes sense only if the preceding command succeeds.
    Therefore, this sequence is a candidate for a conditional list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As another example, if you use the version-control system Git to maintain files,
    you’re probably familiar with the following sequence of commands after you change
    some files: run `git add` to prepare files for a commit, then `git commit`, and
    finally `git push` to share your committed changes. If any of these commands failed,
    you wouldn’t run the rest (until you fixed the cause of the failure). Therefore,
    these three commands work well as a conditional list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Just as the `&&` operator runs a second command only if the first succeeds,
    the related operator `||` (pronounced “or”) runs a second command only if the
    first fails. For example, the following command tries to enter *dir*, and if it
    fails to do so, it creates *dir*:^([1](ch07.xhtml#idm46586639844176))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll commonly see the `||` operator in scripts, causing the script to exit
    if an error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine the `&&` and `||` operators to set up more complicated actions for
    success and failure. The following command tries to enter directory *dir*, and
    if it fails, it creates the directory and enters it. If all fails, the command
    prints a failure message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The commands in a conditional list don’t have to be simple commands; they can
    also be pipelines and other combined commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique #2: Unconditional Lists'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commands in a list don’t have to depend on one another. If you separate the
    commands with semicolons, they simply run in order. Success or failure of a command
    does not affect later ones in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'I like unconditional lists for launching ad hoc commands after I’ve left work
    for the day. Here’s one that sleeps (does nothing) for two hours (7,200 seconds)
    and then backs up my important files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a similar command that functions as a primitive reminder system, sleeping
    for five minutes and then sending me an email:^([3](ch07.xhtml#idm46586639789616))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Unconditional lists are a convenience feature: they produce the same results
    (mostly) as typing the commands individually and pressing Enter after each. The
    only significant difference relates to exit codes. In an unconditional list, the
    exit codes of the individual commands are thrown away except the last one. Only
    the exit code of the last command run in the list is assigned to the shell variable
    `?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Substitution Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Substitution* means automatically replacing the text of a command with other
    text. I’ll show you two types with powerful possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Command substitution
  prefs: []
  type: TYPE_NORMAL
- en: A command is replaced by its output.
  prefs: []
  type: TYPE_NORMAL
- en: Process substitution
  prefs: []
  type: TYPE_NORMAL
- en: A command is replaced by a file (sort of).
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique #3: Command Substitution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you have a few thousand text files representing songs. Each file includes
    a song title, artist name, album title, and the song lyrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You’d like to organize the files into subdirectories by artist. To perform
    this task by hand, you could search for all song files by Kansas using `grep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'and then move each file to a directory *kansas*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Tedious, right? Wouldn’t be great if you could tell the shell, “Move all files
    that contain the string *Artist: Kansas* to the directory *kansas*.” In Linux
    terms, you’d like to take the list of names from the preceding `grep -l` command
    and hand it to `mv`. Well, you can do this easily with the help of a shell feature
    called *command substitution*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'executes the command inside the parentheses and replaces the command by its
    output. So on the preceding command line, the `grep -l` command is replaced by
    the list of filenames that it prints, as if you had typed the filenames like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you find yourself copying the output of one command into a later command
    line, you can usually save time with command substitution. You can even include
    aliases in command substitution, because its contents are run in a subshell, which
    includes copies of its parent’s aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Special Characters and Command Substitution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example with `grep -l` works great for most Linux filenames, but
    not for filenames that contain spaces or other special characters. The shell evaluates
    these characters before the output is handed to `mv`, potentially producing unexpected
    results. For example, if `grep -l` printed *dust in the wind.txt*, the shell would
    treat the spaces as separators, and `mv` would attempt to move four nonexistent
    files named *dust*, *in*, *the*, and *wind.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example. Suppose you have several years’ worth of bank statements
    downloaded in PDF format. The downloaded files have names that include the statement’s
    year, month, and day, such as *eStmt_2021-08-26.pdf* for the date August 26, 2021.^([4](ch07.xhtml#idm46586639738208))
    You’d like to view the most recent statement in the current directory. You could
    do it manually: list the directory, locate the file with the most recent date
    (which will be the final file in the listing), and display it with a Linux PDF
    viewer such as `okular`. But why do all that manual work? Let command substitution
    ease your way. Create a command that prints the name of the latest PDF file in
    the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'and provide it to `okular` using command substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `ls` command lists all the statement files, and `tail` prints only the last
    one, such as *eStmt_2021-08-26.pdf*. Command substitution places that single filename
    right onto the command line, as if you’d typed `okular eStmt_2021-08-26.pdf`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The original syntax for command substitution was backquotes (backticks). The
    following two commands are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Backticks are supported by most shells. The `$()` syntax is simpler to nest,
    however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In scripts, a common use of command substitution is to store the output of
    a command in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to get the filenames containing Kansas songs and store them in
    a variable, use command substitution like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output might have multiple lines, so to preserve any newline characters,
    make sure you quote the value wherever you use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Technique #4: Process Substitution'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command substitution, which you just saw, replaces a command with its output
    in place, as a string. *Process substitution* also replaces a command with its
    output, but it treats the output as if it were stored in a file. This powerful
    difference may look confusing at first, so I’ll explain it step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you’re in a directory of JPEG image files named *1.jpg* through *1000.jpg*,
    but some files are mysteriously missing and you want to identify them. Produce
    such a directory with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A poor way to locate the missing files is to list the directory, sorted numerically,
    and look for gaps by eye:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A more robust, automated solution is to compare the existing filenames to a
    complete list of names from *1.jpg* to *1000.jpg*, using the `diff` command. One
    way to achieve this solution is with temporary files. Store the existing filenames,
    sorted, in one temporary file, *original-list*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then print a complete list of filenames from *1.jpg* to *1000.jpg* to another
    temporary file, *full-list*, by generating the integers 1 to 1000 with `seq`,
    and appending “.jpg” to each line with `sed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the two temporary files with the `diff` command to discover that *4.jpg*
    and *981.jpg* are missing, then delete the temporary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a lot of steps. Wouldn’t it be grand to compare the two lists of names
    directly and not bother with temporary files? The challenge is that `diff` can’t
    compare two lists from stdin; it requires files as arguments.^([5](ch07.xhtml#idm46586639674432))
    Process substitution solves the problem. It makes both lists appear to `diff`
    as files. (The sidebar [“How Process Substitution Works”](#sidebar_process_substitution)
    provides the technical details.) The syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'runs the command in a subshell and presents its output as if it were contained
    in a file. For example, the following expression represents the output of `ls
    -1 | sort -n` as if it were contained in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can `cat` the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can copy the file with `cp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'and as you’ll now see, you can `diff` the file against another. Begin with
    the two commands that generated your two temporary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply process substitution so `diff` can treat them as files, and you get the
    same output as before, but without using temporary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Clean up the output by grepping for lines beginning with `>` and stripping
    off the first two characters with `cut`, and you have your missing files report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Process substitution transformed how I use the command line. Commands that read
    only from disk files suddenly could read from stdin. With practice, commands that
    previously seemed impossible became easy.
  prefs: []
  type: TYPE_NORMAL
- en: Command-as-String Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every command is a string, but some commands are more “stringy” than others.
    I’ll show you several techniques that construct a string, piece by piece, and
    then run the string as a command:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing a command to `bash` as an argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Piping commands to `bash` on stdin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending commands to another host with `ssh`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a sequence of commands with `xargs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The following techniques can be risky because they send unseen text to a shell
    for execution. Never do this blindly. Always understand the text (and trust its
    origin) before executing it. You don’t want to execute the string `"rm -rf $HOME"`
    by mistake and wipe out all your files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique #5: Passing a Command as an Argument to bash'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`bash` is a normal command like any other, as explained in [“Shells Are Executable
    Files”](ch06.xhtml#section_shell_executable), so you can run it by name on the
    command line. By default, running `bash` launches an interactive shell for typing
    and executing commands, as you’ve seen. Alternatively, you can pass a command
    to `bash` as a string, via the `-c` option, and `bash` will run that string as
    a command and exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is this helpful? Because the new `bash` process is a child with its own
    environment, including a current directory, variables with values, and so on.
    Any changes to the child shell won’t affect your currently running shell. Here’s
    a `bash -c` command that changes directory to */tmp* just long enough to delete
    a file, then exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The most instructive and beautiful use of `bash -c`, however, arises when you
    run certain commands as the superuser. Specifically, the combination of `sudo`
    and input/output redirection produces an interesting (sometimes maddening) situation
    in which `bash -c` is the key to success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to create a log file in the system directory */var/log*, which
    is not writable by ordinary users. You run the following `sudo` command to gain
    superuser privileges and create the log file, but it mysteriously fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a minute—`sudo` should give you permission to create any file anywhere.
    How can this command possibly fail? Why didn’t `sudo` even prompt you for a password?
    The answer is: because `sudo` didn’t run. You applied `sudo` to the `echo` command
    but not to the output redirection, which ran first and failed. In detail:'
  prefs: []
  type: TYPE_NORMAL
- en: You pressed Enter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell began to evaluate the whole command, including redirection (`>`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell tried to create the file *custom.log* in a protected directory, */var/log*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You didn’t have permission to write to */var/log*, so the shell gave up and
    printed the “Permission denied” message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That’s why `sudo` never ran. To solve this problem, you need to tell the shell,
    “Run the entire command, including output redirection, as the superuser.” This
    is exactly the kind of situation that `bash -c` solves so well. Construct the
    command you want to run, as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'and pass it as an argument to `sudo bash -c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This time, you’ve run `bash`, not just `echo`, as the superuser, and `bash`
    executes the entire string as a command. The redirection succeeds. Remember this
    technique whenever you pair `sudo` with redirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique #6: Piping a Command to bash'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The shell reads every command that you type on stdin. That means `bash` the
    program can participate in pipelines. For example, print the string `"ls -l"`
    and pipe it to `bash`, and `bash` will treat the string as a command and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember, never blindly pipe text to `bash`. Be aware of what you’re executing.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is terrific when you need to run many similar commands in a row.
    If you can print the commands as strings, then you can pipe the strings to `bash`
    for execution. Suppose you’re in a directory with many files, and you want to
    organize them into subdirectories by their first character. A file named *apple*
    would be moved to subdirectory *a*, a file named *cantaloupe* would move to subdirectory
    *c*, and so on.^([6](ch07.xhtml#idm46586639568448)) (For simplicity, we’ll assume
    all the filenames begin with a lowercase letter and contain no spaces or special
    characters.)
  prefs: []
  type: TYPE_NORMAL
- en: 'First, list the files, sorted. We’ll assume all the names are at least two
    characters long (matching the pattern `??*`) so our commands don’t collide with
    the subdirectories *a* through *z*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the 26 subdirectories you need via brace expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now generate the `mv` commands you’ll need, as strings. Start with a regular
    expression for `sed` that captures the first character of the filename as expression
    #1 (`\1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Capture the rest of the filename as expression #2 (`\2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect the two regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now form an `mv` command with the word *mv* followed by a space, the full filename
    (`\1\2`), another space, and the first character (`\1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete command generator is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Its output contains exactly the `mv` commands you need. Read the output to
    convince yourself it’s correct, perhaps by piping it to `less` for page-by-page
    viewing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re satisfied that your generated commands are correct, pipe the output
    to `bash` for execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The steps you just completed are a repeatable pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Print a sequence of commands by manipulating strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View the results with `less` to check correctness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pipe the results to `bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Technique #7: Executing a String Remotely with ssh'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Disclaimer*: this technique will make sense only if you’re familiar with SSH,
    the secure shell, for logging into remote hosts. Setting up SSH relationships
    between hosts is beyond the scope of this book; to learn more about it, seek out
    an SSH tutorial.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the usual way of logging into a remote host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'you also can execute a single command on the remote host—by passing a string
    to `ssh` on the command line. Simply append the string to the rest of the `ssh`
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique is generally quicker than logging in, running a command, and
    logging out. If the command includes special characters, such as redirection symbols,
    that need to be evaluated on the remote host, then quote or escape them. Otherwise,
    they’ll be evaluated by your local shell. Both of the following commands run `ls`
    remotely, but the output redirection occurs on different hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pipe commands to `ssh` to run them on the remote host, much like
    you pipe them to `bash` to run locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When piping commands to `ssh`, the remote host might print diagnostic or other
    messages. These generally do not affect the remote command, and you can suppress
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see messages about pseudo-terminals or pseudo-ttys, such as “Pseudo-terminal
    will not be allocated because stdin is not a terminal,” run `ssh` with the `-T`
    option to prevent the remote SSH server from allocating a terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you see welcome messages that normally appear when you log in (“Welcome
    to Linux!”) or other unwanted messages, try telling `ssh` explicitly to run `bash`
    on the remote host, and the messages should disappear:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Technique #8: Running a List of Commands with xargs'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many Linux users have never heard of the command `xargs`, but it’s a powerful
    tool for constructing and running multiple, similar commands. Learning `xargs`
    was another transformative moment in my Linux education, and I hope yours as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`xargs` accepts two inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On stdin: A list of strings separated by whitespace. An example is file paths
    produced by `ls` or `find`, but any strings will do. I’ll call them the *input
    strings*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the command line: An incomplete command that’s missing some arguments, which
    I’ll call the *command template*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xargs` merges the input strings and the command template to produce and run
    new, complete commands, which I’ll call the *generated commands*. I’ll demonstrate
    this process with a toy example. Suppose you’re in a directory with three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Pipe the directory listing to `xargs` to serve as its input strings, and provide
    `wc -l` to serve as the command template, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As promised, `xargs` applied the `wc -l` command template to the input strings
    and counts lines in each file. To print the same three files with `cat`, simply
    change the command template to “cat”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: My toy examples with `xargs` have two shortcomings, one fatal and one practical.
    The fatal shortcoming is that `xargs` may do the wrong thing if an input string
    contains special characters, such as spaces. A robust solution is in the sidebar
    [“Safety with find and xargs”](#sidebar_find_xargs).
  prefs: []
  type: TYPE_NORMAL
- en: 'The practical shortcoming is that you don’t need `xargs` here—you can accomplish
    the same tasks more simply with file pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Why use `xargs`, then? Its power becomes apparent when the input strings are
    more interesting than a simple directory listing. Suppose you want to count lines
    in all files in a directory *and all its subdirectories* (recursively), but only
    for Python source files with names ending in *.py*. It’s easy to produce such
    a list of file paths with `find`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`xargs` can now apply the command template `wc -l` to each file path, producing
    a recursive result that would be difficult to obtain otherwise. For safety, I’ll
    replace the option `-print` with `-print0`, and `xargs` with `xargs -0`, for reasons
    explained in the sidebar [“Safety with find and xargs”](#sidebar_find_xargs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: By combining `find` and `xargs`, you can empower any command to run recursively
    through the filesystem, affecting only files (and/or directories) that match your
    stated criteria. (In some cases, you can produce the same effect with `find` alone,
    using its option `-exec`, but `xargs` is often a cleaner solution.)
  prefs: []
  type: TYPE_NORMAL
- en: '`xargs` has numerous options (see `man xargs`) that control how it creates
    and runs the generated commands. The most important ones in my view (other than
    `-0`) are `-n` and `-I`. The `-n` option controls how many arguments are appended
    by `xargs` onto each generated command. The default behavior is to append as many
    arguments as will fit within the shell’s limits:^([7](ch07.xhtml#idm46586639466144))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-I` option controls where the input strings appear in the generated command.
    By default, they’re appended to the command template, but you can make them appear
    elsewhere. Follow `-I` with any string (of your choice), and that string becomes
    a placeholder in the command template, indicating exactly where input strings
    should be inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: I chose “XYZ” arbitrarily as a placeholder for input strings and positioned
    it immediately after `echo`, moving the input string to the beginning of each
    output line. Note that the `-I` option limits `xargs` to one input string per
    generated command. I recommend reading the `xargs` manpage thoroughly to learn
    what else you can control.
  prefs: []
  type: TYPE_NORMAL
- en: Long Argument Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`xargs` is a problem solver when command lines grow very long. Suppose your
    current directory contains one million files named *file1.txt* through *file1000000.txt*
    and you try to remove them by pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern `*.txt` evaluates to a string of more than 14 million characters,
    which is longer than Linux supports. To work around this limitation, pipe a list
    of the files to `xargs` for deletion. `xargs` will split the list of files across
    multiple `rm` commands. Form the list of files by piping a full directory listing
    to `grep`, matching only filenames ending in *.txt*, then pipe to `xargs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution is better than file pattern matching (`ls *.txt`), which will
    produce the same “Argument list too long” error. Better yet, run `find -print0`
    as described in [“Safety with find and xargs”](#sidebar_find_xargs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Process-Control Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, all commands I’ve discussed occupy the parent shell until they finish.
    Let’s consider several techniques that forge a different relationship with the
    parent shell:'
  prefs: []
  type: TYPE_NORMAL
- en: Background commands
  prefs: []
  type: TYPE_NORMAL
- en: Immediately return the prompt and execute out of sight
  prefs: []
  type: TYPE_NORMAL
- en: Explicit subshells
  prefs: []
  type: TYPE_NORMAL
- en: Can be launched in the middle of a combined command
  prefs: []
  type: TYPE_NORMAL
- en: Process replacement
  prefs: []
  type: TYPE_NORMAL
- en: Supersedes the parent shell
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique #9: Backgrounding a Command'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, all our techniques run a command to completion while you wait, and then
    present the next shell prompt. But you don’t have to wait, especially for commands
    that take a long time. You can launch commands in a special way so they disappear
    from sight (sort of) yet continue to run, freeing up the current shell immediately
    to run further commands. This technique is called *backgrounding* a command or
    *running a command in the background*. In contrast, commands that occupy the shell
    are called *foreground* commands. A shell instance runs at most one foreground
    command at a time plus any number of background commands.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a command in the background
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run a command in the background, simply append an ampersand (`&`). The shell
    responds with a cryptic-looking message indicating that the command is back­groun⁠ded
    and presents the next prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then continue running foreground commands (or more background commands)
    in this shell. Output from backgrounded commands may appear at any time, even
    while you are typing. If the backgrounded command finishes successfully, the shell
    will inform you with a *Done* message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'or if it fails, you’ll see an *Exit* message with an exit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The ampersand is also a list operator, like `&&` and `||`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Suspending a command and sending it to the background
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A related technique is to run a foreground command, change your mind during
    execution, and send it to the background. Press Ctrl-Z to stop the command temporarily
    (called *suspending* the command) and return to the shell prompt; then type `bg`
    to resume running the command in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs and job control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Background commands are part of a shell feature called *job control* that manipulates
    running commands in various ways, like backgrounding, suspending, and resuming
    them. A *job* is a shell’s unit of work: a single instance of a command running
    in a shell. Simple commands, pipelines, and conditional lists are all examples
    of jobs—basically anything you can run at the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: A job is more than a Linux process. A job may consist of one process, two processes,
    or more. A pipeline of six programs, for example, is a single job that includes
    (at least) six processes. Jobs are a construct of the shell. The Linux operating
    system doesn’t keep track of jobs, just the underlying processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any moment, a shell may have multiple jobs running. Each job in a given
    shell has a positive integer ID, called the job ID or job number. When you run
    a command in the background, the shell prints the job number and the ID of the
    first process it runs within the job. In the following command, the job number
    is 1 and the process ID is 74931:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Common job-control operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The shell has built-in commands for controlling jobs, listed in [Table 7-1](#table_job_control).
    I’ll demonstrate the most common job-control operations by running a bunch of
    jobs and manipulating them. To keep the jobs simple and predictable, I’ll run
    the command `sleep`, which just sits there doing nothing (“sleeping”) for a given
    number of seconds and then exits. For example, `sleep 10` sleeps for 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Job control commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| bg | Move the current suspended job into the background |'
  prefs: []
  type: TYPE_TB
- en: '| bg %*n* | Move suspended job number *n* into the background (example: `bg
    %1`) |'
  prefs: []
  type: TYPE_TB
- en: '| fg | Move the current background job into the foreground |'
  prefs: []
  type: TYPE_TB
- en: '| fg %*n* | Move background job number *n* into the foreground (example: `fg
    %2`) |'
  prefs: []
  type: TYPE_TB
- en: '| kill %*n* | Terminate background job number *n* (example: `kill %3`) |'
  prefs: []
  type: TYPE_TB
- en: '| jobs | View a shell’s jobs |'
  prefs: []
  type: TYPE_TB
- en: 'Run a job in the background to completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When jobs complete, the *Done* message might not appear until the next time
    you press Enter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a background job and bring it into the foreground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a foreground job, suspend it, and bring it back into the foreground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a foreground job and send it to the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Work with multiple background jobs. Refer to a job by its job number preceded
    by a percent sign (`%1`, `%2`, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Output and input in the background
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A backgrounded command may write to stdout, sometimes at inconvenient or confusing
    times. Notice what happens if you sort the Linux dictionary file (100,000 lines
    long) and print the first two lines in the background. As expected, the shell
    immediately prints the job number (1), a process ID (81089), and the next prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wait until the job finishes, it prints two lines on stdout wherever
    your cursor happens to be at the time. In this case, the cursor is sitting at
    the second prompt, so you get this sloppy-looking output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Press Enter, and the shell will print a “job done” message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Screen output from a background job can appear at any time while the job runs.
    To avoid this sort of messiness, redirect stdout to a file, then examine the file
    at your leisure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Other odd things happen when a background job attempts to read from stdin.
    The shell suspends the job, prints a *Stopped* message, and waits for input in
    the background. Demonstrate this by backgrounding `cat` with no arguments so it
    reads stdin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Jobs can’t read input in the background, so bring the job into the foreground
    with `fg` and then supply the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'After supplying all input, do any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Continue running the command in the foreground until it completes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suspend and background the command again by pressing Ctrl-Z followed by `bg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End the input with Ctrl-D, or kill the command with Ctrl-C.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backgrounding tips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Backgrounding is ideal for commands that take a long time to run, such as text
    editors during long editing sessions, or any program that opens its own windows.
    For example, programmers can save a lot of time by suspending their text editor
    rather than exiting. I’ve seen experienced engineers modify some code in their
    text editor, save and quit the editor, test the code, then relaunch the editor
    and hunt for the spot in the code where they’d left off. They lose 10–15 seconds
    to job-switching every time they quit the editor. If they instead suspend the
    editor (Ctrl-Z), test their code, and resume the editor (`fg`), they avoiding
    wasting time unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: Backgrounding is also great for running a sequence of commands in the background
    using a conditional list. If any command within the list fails, the rest won’t
    run and the job completes. (Just watch out for commands that read input, since
    they’ll cause the job to suspend and wait for input.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Technique #10: Explicit Subshells'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each time you launch a simple command, it runs in a child process, as you saw
    in [“Parent and Child Processes”](ch06.xhtml#section_parent_child_processes).
    Command substitution and process substitution create subshells. There are times,
    however, when it’s helpful to launch an extra subshell explicitly. To do so, simply
    enclose a command in parentheses and it runs in a subshell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'When applied to a whole command, this technique isn’t super useful, except
    maybe to save you from running a second `cd` command to return to your previous
    directory. However, if you place parentheses around one piece of a combined command,
    you can perform some useful tricks. A typical example is a pipeline that changes
    directory in the middle of execution. Suppose you have downloaded a compressed
    `tar` file, *package.tar.gz*, and you want to extract the files. A `tar` command
    to extract the files is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The extraction occurs relative to the current directory.^([8](ch07.xhtml#idm46586639185696))
    What if you want to extract them into a different directory? You could `cd` to
    the other directory first and run `tar` (and then `cd` back), but you can also
    perform this task with a single command. The trick is to pipe the tarred data
    to a subshell that performs directory operations and runs `tar` as it reads from
    stdin:^([9](ch07.xhtml#idm46586639182704))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique also works to copy files from one directory *dir1* to another
    existing directory *dir2* using two `tar` processes, one writing to stdout and
    one reading from stdin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The same technique can copy files to an existing directory on another host
    via SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s tempting to view `bash` parentheses as if they simply group commands together,
    like parentheses in arithmetic. They do not. Each pair of parentheses causes a
    subshell to be launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technique #11: Process Replacement'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally when you run a command, the shell runs it in a separate process that
    is destroyed when the command exits, as described in [“Parent and Child Processes”](ch06.xhtml#section_parent_child_processes).
    You can change this behavior with the `exec` command, which is a shell builtin.
    It *replaces* the running shell (a process) with another command of your choice
    (another process). When the new command exits, no shell prompt will follow because
    the original shell is gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, run a new shell manually and change its prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `exec` a command and watch the new shell die:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Running exec May Be Fatal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you run `exec` in a shell, the shell exits afterward. If the shell was running
    in a terminal window, the window closes. If the shell was a login shell, you will
    be logged out.
  prefs: []
  type: TYPE_NORMAL
- en: Why would you ever run `exec`? One reason is to conserve resources by not launching
    a second process. Shell scripts sometimes make use of this optimization by running
    `exec` on the final command in the script. If the script is run many times (say,
    millions or billions of executions), the savings might be worth it.
  prefs: []
  type: TYPE_NORMAL
- en: '`exec` has a second ability—it can reassign stdin, stdout, and/or stderr for
    the current shell. This is most practical in a shell script, such as this toy
    example that prints information to a file, */tmp/outfile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of redirecting the output of each command to */tmp/outfile* individually,
    use `exec` to redirect stdout to */tmp/outfile* for the entire script. Subsequent
    commands can simply print to stdout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this script and examine the file */tmp/outfile2* to see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: You probably won’t use `exec` often, but it’s there when you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you have 13 techniques for running a command—the 11 in this chapter plus
    simple commands and pipelines. [Table 7-2](#table_umpteen_summary) reviews some
    common use cases for different techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-2\. Common idioms for running commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sending stdout from one program to stdin of another | Pipelines |'
  prefs: []
  type: TYPE_TB
- en: '| Inserting output (stdout) into a command | Command substitution |'
  prefs: []
  type: TYPE_TB
- en: '| Providing output (stdout) to a command that doesn’t read from stdin, but
    does read disk files | Process substitution |'
  prefs: []
  type: TYPE_TB
- en: '| Executing one string as a command | `bash -c`, or piping to `bash` |'
  prefs: []
  type: TYPE_TB
- en: '| Printing multiple commands on stdout and executing them | Piping to `bash`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Executing many similar commands in a row | `xargs`, or constructing the commands
    as strings and piping them to `bash` |'
  prefs: []
  type: TYPE_TB
- en: '| Managing commands that depend on one other’s success | Conditional lists
    |'
  prefs: []
  type: TYPE_TB
- en: '| Running several commands at a time | Backgrounding |'
  prefs: []
  type: TYPE_TB
- en: '| Running several commands at a time that depend on one another’s success |
    Backgrounding a conditional list |'
  prefs: []
  type: TYPE_TB
- en: '| Running one command on a remote host | Run `ssh` *`host command`* |'
  prefs: []
  type: TYPE_TB
- en: '| Changing directory in the middle of a pipeline | Explicit subshells |'
  prefs: []
  type: TYPE_TB
- en: '| Running a command later | Unconditional list with `sleep` followed by the
    command |'
  prefs: []
  type: TYPE_TB
- en: '| Redirecting to/from protected files | Run `sudo bash -c "`*`command`* `>`
    *`file`*`"` |'
  prefs: []
  type: TYPE_TB
- en: The next two chapters will teach you to combine techniques to achieve business
    goals efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch07.xhtml#idm46586639844176-marker)) The command `mkdir -p dir`, which
    creates a directory path only if it doesn’t already exist, would be a more elegant
    solution here.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch07.xhtml#idm46586639836000-marker)) This behavior is opposite of what
    many programming languages do, where zero means failure.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch07.xhtml#idm46586639789616-marker)) Alternatively, you could use `cron`
    for the backup job and `at` for reminders, but Linux is all about flexibility—finding
    multiple ways to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch07.xhtml#idm46586639738208-marker)) Bank of America’s downloadable statement
    files are named this way at press time.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch07.xhtml#idm46586639674432-marker)) Technically, `diff` can read one
    list from stdin if you provide a dash as a filename, but not two lists.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch07.xhtml#idm46586639568448-marker)) This directory structure is similar
    to a hashtable with chaining.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch07.xhtml#idm46586639466144-marker)) The exact number depends on length
    limits on your Linux system; see `man xargs`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch07.xhtml#idm46586639185696-marker)) Assuming that the `tar` archive
    was built with relative paths—which is typical for downloaded software—not absolute
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch07.xhtml#idm46586639182704-marker)) This specific problem can be solved
    more simply with the `tar` option `-C` or `--directory`, which specifies a target
    directory. I’m just demonstrating the general technique of using a subshell.
  prefs: []
  type: TYPE_NORMAL
