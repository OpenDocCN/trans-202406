- en: Chapter 5\. Automating Code Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you’ll learn how to use the Kubernetes code generators in Go
    projects to write custom resources in a natural way. Code generators are used
    a lot in the implementation of native Kubernetes resources, and we’ll use the
    very same generators here.
  prefs: []
  type: TYPE_NORMAL
- en: Why Code Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is a simple language by design. It lacks higher-level or even metaprogramming-like
    mechanisms to express algorithms on different data types in a generic (i.e., type-independent)
    way. The “Go way” is to use external code generation instead.
  prefs: []
  type: TYPE_NORMAL
- en: Very early in the Kubernetes development process, more and more code had to
    be rewritten as more resources were added to the system. Code generation made
    the maintenance of this code much easier. Very early on, the [Gengo library](http://bit.ly/2L9kwNJ)
    was created, and eventually, based on Gengo, [*k8s.io/code-generator*](http://bit.ly/2Kw8I8U)
    was developed as an externally usable collection of generators. We will use these
    generators in the following sections for CRs.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, the code generators are called in mostly the same way in every controller
    project. Only packages, group names, and API versions differ. Calling the script
    *k8s.io/code-generator/generate-groups.sh* or a bash script like *hack/update-codegen.sh*
    is the easiest way to add code generation to CR Go types from the build system
    (see [the book’s GitHub repository](http://bit.ly/2J0s2YL)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that some projects call the generator binaries directly due to very special
    requirements and often historic reasons. For the use case of building a controller
    for CRs, it is much easier to just call the *generate-groups.sh* script from the
    *k8s.io/code-generator* repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `all` means to call all four standard code generators for CRs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deepcopy-gen`'
  prefs: []
  type: TYPE_NORMAL
- en: Generates `func` `(t *T)` `DeepCopy()` `*T` and `func` `(t *T)` `DeepCopyInto(*T)`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`client-gen`'
  prefs: []
  type: TYPE_NORMAL
- en: Creates typed client sets.
  prefs: []
  type: TYPE_NORMAL
- en: '`informer-gen`'
  prefs: []
  type: TYPE_NORMAL
- en: Creates informers for CRs that offer an event-based interface to react to changes
    of CRs on the server.
  prefs: []
  type: TYPE_NORMAL
- en: '`lister-gen`'
  prefs: []
  type: TYPE_NORMAL
- en: Creates listers for CRs that offer a read-only caching layer for `GET` and `LIST`
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: The last two are the basis for building controllers (see [“Controllers and Operators”](ch01.html#ch_controllers-operators)).
    These four code generators make up a powerful basis for building full-featured,
    production-ready controllers using the same mechanisms and packages that the Kubernetes
    upstream controllers are using.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are some more generators in *k8s.io/code-generator*, mostly for other
    contexts. For example, if you build your own aggregated API server (see [Chapter 8](ch08.html#ch_custom-api-servers)),
    you will work with internal types in addition to versioned types, and you have
    to define defaulting functions. Then these two generators, which you can access
    by calling the [*generate-internal-groups.sh*](http://bit.ly/2L9kSE3) script from
    *k8s.io/code-generator*, will become relevant:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conversion-gen`'
  prefs: []
  type: TYPE_NORMAL
- en: Creates functions for converting between internal and external types.
  prefs: []
  type: TYPE_NORMAL
- en: '`defaulter-gen`'
  prefs: []
  type: TYPE_NORMAL
- en: Takes care of defaulting certain fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look in detail at the parameters to `generate-groups.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is the target package name for the generated clients, listers,
    and informers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is the base package for the API group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth parameter is a space-separated list of API groups with their versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--output-base` is passed as a flag to all generators to define the base directory
    where the given packages are found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--go-header-file` enables us to put copyright headers into generated code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some generators, like `deepcopy-gen`, create files directly inside the API group
    packages. Those files follow a standard naming scheme with a *zz_generated.* prefix
    such that it is easy to exclude them from version control systems (e.g., via *.gitignore*
    file), though most projects decide to check generated files in because the Go
    tooling around code generators is not well developed.^([1](ch05.html#idm46336860111320))
  prefs: []
  type: TYPE_NORMAL
- en: 'If the project follows the pattern of [*k8s.io/sample-controller*](http://bit.ly/2UppsTN)—the
    `sample-controller` is a blueprint project replicating the patterns established
    by the many controllers built in Kubernetes itself—then the code generation starts
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `cnat` example in the `sample-controller+client-go` variant in [“Following
    sample-controller”](ch06.html#cnat-client-go) goes this route.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Usually, in addition to the [`hack/update-codegen.sh`](http://bit.ly/2J0s2YL)
    script, there is a second script called [`hack/verify-codegen.sh`](http://bit.ly/2IXUWsy).
  prefs: []
  type: TYPE_NORMAL
- en: This script calls the `hack/update-codegen.sh` script and checks whether anything
    changed, and then it terminates with a nonzero return code if any of the generated
    files is not up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very helpful in a continuous integration (CI) script: if a developer
    modified the files by accident or if the files are just outdated, CI will notice
    and complain.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Generators with Tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While some of the code-generator behavior is controlled via command-line flags
    as described earlier (especially the packages to process), a lot more properties
    are controlled via *tags* in your Go files. A tag is a specially formatted Go
    comment in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two kind of tags:'
  prefs: []
  type: TYPE_NORMAL
- en: Global tags above the `package` line in a file called *doc.go*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local tags above a type declaration (e.g., above a struct definition)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the tags in question, the position of the comment might be important.
  prefs: []
  type: TYPE_NORMAL
- en: Global Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Global tags are written into a package’s *doc.go*. A typical *pkg/apis/`group`/`version`/doc.go*
    file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this file tells `deepcopy-gen` to create deep-copy methods
    by default for every type in that package. If you have types where deep copy is
    not necessary, not desired, or even not possible, you can opt out for them with
    the local tag `// +k8s:deepcopy-gen=false`. If you do not enable package-wide
    deep copy, you have to opt in to deep copy for each desired type via `// +k8s:deepcopy-gen=true`.
  prefs: []
  type: TYPE_NORMAL
- en: The second tag, `// +groupName=example.com`, defines the fully qualified API
    group name. This tag is necessary if the Go parent package name does not match
    the group name.
  prefs: []
  type: TYPE_NORMAL
- en: The file shown here actually comes from the [`cnat client-go` example *pkg/apis/cnat/v1alpha1/doc.go*
    file](http://bit.ly/2L6M9ad) (see [“Following sample-controller”](ch06.html#cnat-client-go)).
    There, `cnat` is the parent package, but `cnat.programming-kubernetes.info` is
    the group name.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `// +groupName` tag, the client generator (see [“Typed client created
    via client-gen”](ch04.html#clientgen-client)) will generate a client using the
    correct HTTP path */apis/foo.project.example.com*. Besides `+groupName` there
    is also `+groupGoName`, which defines a custom Go identifier (for variable and
    type names) to be used instead of the parent package name. For example, the generators
    will use the uppercase parent package name for identifies by default, which in
    our example is `Cnat`. A better identifier would be `CNAt` for “Cloud Native At.”
    With `// +groupGoName=CNAt` we could use that instead of `Cnat` (though we don’t
    do that in this example—we’ve stayed with `Cnat`), and the `client-gen` result
    would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Local Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Local tags are written either directly above an API type or in the second comment
    block above it. Here are the main types in the *types.go* file of the [`cnat`
    example](http://bit.ly/31QosJw):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections we’ll walk through the tags of this example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, the API documentation is in the first comment block, while
    we put the tags into the second comment block. This helps to keep the tags out
    of the API documentation, if you use some tool to extract the Go doc comments
    for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: deepcopy-gen Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deep-copy method generation is usually enabled for all types by default via
    the global `// +k8s:deepcopy-gen=package` tag (see [“Global Tags”](#global-tags))—that
    is, with possible opt-out. However, in the preceding example file (and actually
    the whole package), all API types need deep-copy methods. Hence, we don’t have
    to opt out locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had a helper struct in the API types package (this is usually discouraged
    to keep API packages clean), we would have to disable deep-copy generation. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: runtime.Object and DeepCopyObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a special deep-copy tag that needs more explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In [“Kubernetes Objects in Go”](ch03.html#kube-objects) we saw that `runtime.Object`s
    have to implement the `DeepCopyObject() runtime.Object` method. The reason is
    that generic code within Kubernetes has to be able to create deep copies of objects.
    This method allows that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DeepCopyObject()` method does nothing other than calling the generated
    `DeepCopy` method. The signature of the latter varies from type to type (`DeepCopy()`
    `*T` depends on `T`). The signature of the former is always `DeepCopyObject()`
    `runtime.Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Put the local tag `//` `+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object`
    above your top-level API types to generate this method with `deepcopy-gen`. This
    tells `deepcopy-gen` to create such a method for `runtime.Object`, called `DeepCopyObject()`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the previous example, both `At` and `AtList` are top-level types because
    they are used as `runtime.Object`s.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, top-level types are those that have `metav1.TypeMeta` embedded.
  prefs: []
  type: TYPE_NORMAL
- en: 'It happens that other interfaces need a way to be deep-copied. This is usually
    the case if, for example, API types have a field of interface type `Foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, API types must be deep-copyable, and hence the field `Foo`
    must be deep-copied too. How could you do that in a generic way (without type-casts)
    without adding `DeepCopyFoo() Foo` to the `Foo` interface?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In that case the same tag can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few examples beyond `runtime.Object` in the Kubernetes source where
    this tag is actually used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: client-gen Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, there are a number of tags to control `client-gen`, one of which we
    saw in the earlier example for `At` and `AtList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It tells `client-gen` to create a client for this type (this is always opt-in).
    Note that you don’t have to and indeed *must not* put it above the `List` type
    of the API objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `cnat` example, we use the */status* subresource and update the status
    of the CRs with the `UpdateStatus` method of the client (see [“Status subresource”](ch04.html#status-subresource)).
    There are instances of CRs without a status or without a spec-status split. In
    those cases, the following tag avoids the generation of that `UpdateStatus()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Without this tag, `client-gen` will blindly generate the `UpdateStatus()` method.
    It is important to understand, however, that the spec-status split works only
    if the */status* subresource is actually enabled in the CustomResourceDefinition
    manifest (see [“Subresources”](ch04.html#crd-subresources)).
  prefs: []
  type: TYPE_NORMAL
- en: The existence of the method alone in the client has no effect. Requests to it
    without the change in the manifest will even fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client generator has to choose the right HTTP path, either with or without
    a namespace. For cluster-wide resources, you have to use the tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The default is to generate a namespaced client. Again, this has to match the
    scope setting in the CRD manifest. For special-purpose clients, you might also
    want to control in detail which HTTP methods are offered. You can do this by using
    a couple of tags, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first three should be pretty self-explanatory, but the last one warrants
    some explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The type this tag is written above will be create-only and will not return the
    API type itself, but a `metav1.Status`. For CRs this does not make much sense,
    but for user-provided API servers written in Go (see [Chapter 8](ch08.html#ch_custom-api-servers))
    those resources can exist, and they do in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common case for the `// +genclient:method=` tag is the addition of a method
    to scale a resource. In [“Scale subresource”](ch04.html#scale-subresource) we
    describe how the */scale* subresource can be enabled for CRs. The following tags
    create the corresponding client methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first tag creates the getter `GetScale`. The second creates the setter `UpdateScale`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All CR */scale* subresources receive and output the `Scale` type from the *autoscaling/v1*
    group. In the Kubernetes API there are resources that use other types for historic
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: informer-gen and lister-gen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both `informer-gen` and `lister-gen` process the `// +genclient` tag of `client-gen`.
    There is nothing else to configure. Each type that opted in to client generation
    gets informers and listers automatically that match the client (if the whole suite
    of generators is called via the *k8s.io/code-generator/generate-group.sh* script).
  prefs: []
  type: TYPE_NORMAL
- en: The documentation of the Kubernetes generators has a lot of room for improvement
    and will certainly be refined slowly over time. For more information about the
    different generators, it is often helpful to look at examples inside Kubernetes
    itself—for example, [k8s.io/api](http://bit.ly/2ZA6dWH) and [OpenShift API types](http://bit.ly/2KxpKnc).
    Both repositories have many advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, don’t hesitate to look into the generators themselves. `deepcopy-gen`
    has some documentation available inside its [*main.go*](http://bit.ly/2x9HmN4)
    file. `client-gen` has some documentation available in the [Kubernetes contributor
    documentation](http://bit.ly/2WYNlns). `informer-gen` and `lister-gen` currently
    don’t have further documentation, but *generate-groups.sh* shows [how each is
    invoked](http://bit.ly/31MeSHp).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we showed you how to use the Kubernetes code generators for
    CRs. With that out of the way, we now move on to higher-level abstraction tooling—that
    is, solutions for writing custom controllers and operators that enable you to
    focus on the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.html#idm46336860111320-marker)) The Go tools do not run the generation
    automatically when needed and lack a way to define dependencies between source
    and generated files.
  prefs: []
  type: TYPE_NORMAL
