- en: Chapter 7\. Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A container’s temporary filesystem is isolated from any other container or Pod
    and is not persisted beyond a Pod restart. A Pod can define a Volume and mount
    it to a container.
  prefs: []
  type: TYPE_NORMAL
- en: Ephemeral Volumes exist for the lifespan of a Pod. They are useful if you want
    to share data between multiple containers running in the Pod. Persistent Volumes
    preserve data beyond the lifespan of a Pod. They are a good option for applications
    that require data to exist longer, e.g., in the form of storage for a database-driven
    application. In this chapter, we’ll exercise the use of different Volumes types
    in a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications running in a container can use the temporary filesystem to read
    and write files. In case of a container crash or a cluster/node restart, the kubelet
    will restart the container. Any data that had been written to the temporary filesystem
    is lost and cannot be retrieved. The container effectively starts with a clean
    slate.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many uses cases for wanting to mount a Volume in a container. We’ll
    see one of the most prominent use cases in [Chapter 8](ch08.xhtml#multi_container_pods):
    using an ephemeral Volume to exchange data between a main application container
    and a sidecar. [Figure 7-1](#tmp_file_system_volume) illustrates the differences
    between the temporary filesystem of a container and the use of a Volume.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0701](Images/ckd2_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. A container using the temporary filesystem versus a Volume
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Volume Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Volume needs to define a type. The type determines the medium that backs
    the Volume and its runtime behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Ephemeral Volumes
  prefs: []
  type: TYPE_NORMAL
- en: These exist for the lifespan of a Pod. Ephemeral Volumes are useful if you want
    to share data between multiple containers running in the Pod or if you can easily
    reconstruct the data stored on the Volume upon a Pod restart.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent Volumes
  prefs: []
  type: TYPE_NORMAL
- en: These preserve data beyond the lifespan of a Pod. Persistent Volumes are a good
    option for applications that require data to exist longer, for example, in the
    form of storage for a database-driven application.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes documentation offers a long list of Volume types. [Table 7-1](#table_volume_types)
    provides a select list of Volume types that I have found to be most relevant to
    the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Volume types most relevant to exam
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `emptyDir` | Empty directory in Pod with read/write access. Only persisted
    for the lifespan of a Pod. A good choice for cache implementations or data exchange
    between containers of a Pod. |'
  prefs: []
  type: TYPE_TB
- en: '| `hostPath` | File or directory from the host node’s filesystem. Supported
    only on single-node clusters and not meant for production. |'
  prefs: []
  type: TYPE_TB
- en: '| `configMap`, `secret` | Provides a way to inject configuration data. For
    practical examples, see [Chapter 19](ch19.xhtml#configmaps_secrets). |'
  prefs: []
  type: TYPE_TB
- en: '| `nfs` | An existing NFS (Network File System) share. Preserves data after
    Pod restart. |'
  prefs: []
  type: TYPE_TB
- en: '| `persistentVolumeClaim` | Claims a Persistent Volume. For more information,
    see [“Creating PersistentVolumeClaims”](#creating_pvc). |'
  prefs: []
  type: TYPE_TB
- en: Ephemeral Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining an ephemeral Volume for a Pod requires two steps. First, you need to
    declare the Volume itself using the attribute `spec.volumes[]`. As part of the
    definition, you provide the name and the type. Just declaring the Volume won’t
    be sufficient. Second, the Volume needs to be mounted to a path of the consuming
    container via `spec.containers[].volumeMounts[]`. The mapping between the Volume
    and the Volume mount occurs through the matching name.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and mounting an ephemeral Volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Example 7-1](#ephemeral_volume), stored in the file *pod-with-volume.yaml*
    here, you can see the definition of a Volume with type `emptyDir`. The Volume
    has been mounted to the path */var/log/nginx* inside the container named `nginx`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. A Pod defining and mounting a ephemeral Volume
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Interacting with the Volume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create the Pod and see if we can interact with the mounted Volume. The
    following commands open an interactive shell after the Pod’s creation, then navigate
    to the mount path. You can see that the Volume type `emptyDir` initializes the
    mount path as an empty directory. New files and directories can be created as
    needed without limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For an illustrative use case of the `emptyDir` Volume type mounted by more than
    one container, see [Chapter 8](ch08.xhtml#multi_container_pods).
  prefs: []
  type: TYPE_NORMAL
- en: Persistent Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data stored on Volumes outlives a container restart. In many applications,
    the data lives far beyond the life cycles of the applications, container, Pod,
    nodes, and even the clusters themselves. Data persistence ensures the life cycles
    of the data are decoupled from the life cycles of the cluster resources. A typical
    example would be data persisted by a database. That’s the responsibility of a
    persistent Volume. Kubernetes models persist data with the help of two primitives:
    the PersistentVolume and the PersistentVolumeClaim.'
  prefs: []
  type: TYPE_NORMAL
- en: The PersistentVolume is the primitive representing a piece of storage in a Kubernetes
    cluster. It is completely decoupled from the Pod and therefore has its own life
    cycle. The object captures the source of the storage (e.g., storage made available
    by a cloud provider). A PersistentVolume is either provided by a Kubernetes administrator
    or assigned dynamically by mapping to a storage class.
  prefs: []
  type: TYPE_NORMAL
- en: The PersistentVolumeClaim requests the resources of a PersistentVolume—for example,
    the size of the storage and the access type. In the Pod, you will use the type
    `persistentVolumeClaim` to mount the abstracted PersistentVolume by using the
    PersistentVolumeClaim.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](#pvc_relationship) shows the relationship between the Pod, the
    PersistentVolumeClaim, and the PersistentVolume.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0702](Images/ckd2_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Claiming a PersistentVolume from a Pod
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Static versus dynamic provisioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A PersistentVolume can be created statically or dynamically. If you go with
    the static approach, then you first need to create a storage device and then reference
    it by explicitly creating an object of kind PersistentVolume. The dynamic approach
    doesn’t require you to create a PersistentVolume object. It will be automatically
    created from the PersistentVolumeClaim by setting a storage class name using the
    attribute `spec.storageClassName`.
  prefs: []
  type: TYPE_NORMAL
- en: A storage class is an abstraction concept that defines a class of storage device
    (e.g., storage with slow or fast performance) used for different application types.
    It’s the job of a Kubernetes administrator to set up storage classes. For a deeper
    discussion on storage classes, see [“Storage Classes”](#understanding_storage_class).
    For now, we’ll focus on the static provisioning of PersistentVolumes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating PersistentVolumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create a PersistentVolume object yourself, we refer to the approach
    as static provisioning. A PersistentVolume can be created only by using the manifest-first
    approach. At this time, `kubectl` doesn’t allow the creation of a PersistentVolume
    using the `create` command. Every PersistentVolume needs to define the storage
    capacity using `spec.capacity` and an access mode set via `spec.accessModes`.
    See [“Configuration options for a PersistentVolume”](#configuring_pv) for more
    information on the configuration options available to a PersistentVolume.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 7-2](#yaml_manifest_persistent_volume) creates a PersistentVolume
    named `db-pv` with a storage capacity of 1Gi and read/write access by a single
    node. The attribute `hostPath` mounts the directory */data/db* from the host node’s
    filesystem. We’ll store the YAML manifest in the file `db-pv.yaml`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. YAML manifest defining a PersistentVolume
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you inspect the created PersistentVolume, you’ll find most of the information
    you provided in the manifest. The status `Available` indicates that the object
    is ready to be claimed. The reclaim policy determines what should happen with
    the PersistentVolume after it has been released from its claim. By default, the
    object will be retained. The following example uses the short-form command `pv`
    to avoid having to type `persistentvolume`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Configuration options for a PersistentVolume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A PersistentVolume offers a variety of configuration options that determine
    their innate runtime behavior. For the exam, it’s important to understand the
    volume mode, access mode, and reclaim policy configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Volume mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The volume mode handles the type of device. That’s a device either meant to
    be consumed from the filesystem or backed by a block device. The most common case
    is a filesystem device. You can set the volume mode using the attribute `spec.volumeMode`.
    [Table 7-2](#persistentvolume_volume_modes) shows all available volume modes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-2\. PersistentVolume volume modes
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Filesystem` | Default. Mounts the volume into a directory of the consuming
    Pod. Creates a filesystem first if the volume is backed by a block device and
    the device is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `Block` | Used for a volume as a raw block device without a filesystem on
    it. |'
  prefs: []
  type: TYPE_TB
- en: 'The volume mode is not rendered by default in the console output of the `get
    pv` command. You will need to provide the `-o wide` command-line option to see
    the `VOLUMEMODE` column, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Access mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each PersistentVolume can express how it can be accessed using the attribute
    `spec.accessModes`. For example, you can define that the volume can be mounted
    only by a single Pod in a read or write mode or that a volume is read-only but
    accessible from different nodes simultaneously. [Table 7-3](#persistentvolume_access_modes)
    provides an overview of the available access modes. The short-form notation of
    the access mode is usually rendered in outputs of specific commands, e.g., `get
    pv` or `describe pv`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-3\. PersistentVolume access modes
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Short Form | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteOnce` | RWO | Read/write access by a single node |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadOnlyMany` | ROX | Read-only access by many nodes |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteMany` | RWX | Read/write access by many nodes |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteOncePod` | RWOP | Read/write access mounted by a single Pod |'
  prefs: []
  type: TYPE_TB
- en: 'The following command parses the access modes from the PersistentVolume named
    `db-pv`. As you can see, the returned value is an array underlining the fact that
    you can assign multiple access modes at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Reclaim policy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Optionally, you can also define a reclaim policy for a PersistentVolume. The
    reclaim policy specifies what should happen to a PersistentVolume object when
    the bound PersistentVolumeClaim is deleted (see [Table 7-4](#persistentvolume_reclaim_policy)).
    For dynamically created PersistentVolumes, the reclaim policy can be set via the
    attribute `.reclaimPolicy` in the storage class. For statically created PersistentVolumes,
    use the attribute `spec.persistentVolumeReclaimPolicy` in the PersistentVolume
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-4\. PersistentVolume reclaim policies
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Retain` | Default. When PersistentVolumeClaim is deleted, the PersistentVolume
    is “released” and can be reclaimed. |'
  prefs: []
  type: TYPE_TB
- en: '| `Delete` | Deletion removes PersistentVolume and its associated storage.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Recycle` | This value is deprecated. You should use one of the other values.
    |'
  prefs: []
  type: TYPE_TB
- en: 'This command retrieves the assigned reclaim policy of the PersistentVolume
    named `db-pv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating PersistentVolumeClaims
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next object we’ll need to create is the PersistentVolumeClaim. Its purpose
    is to bind the PersistentVolume to the Pod. Let’s look at the YAML manifest stored
    in the file *db-pvc.yaml*, shown in [Example 7-3](#yaml_manifest_persistent_volume_claim).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. Definition of a PersistentVolumeClaim
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What we’re saying is: “Give me a PersistentVolume that can fulfill the resource
    request of 256Mi and provides the access mode `ReadWriteOnce`.” Static provisioning
    should use an empty string for the attribute `spec.storageClassName` if you do
    not want it to automatically assign the default storage class. The binding to
    an appropriate PersistentVolume happens automatically based on those criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the PersistentVolumeClaim, the status is set as `Bound`, which
    means that the binding to the PersistentVolume was successful. Once the associated
    binding occurs, nothing else can bind to it. The binding relationship is one-to-one.
    Nothing else can bind to the PersistentVolume once claimed. The following `get`
    command uses the short-form `pvc` instead of `persistentvolumeclaim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The PersistentVolume has not been mounted by a Pod yet. Therefore, inspecting
    the details of the object shows `<none>`. Using the `describe` command is a good
    way to verify if the PersistentVolumeClaim was mounted properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Mounting PersistentVolumeClaims in a Pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All that’s left is to mount the PersistentVolumeClaim in the Pod that wants
    to consume it. You already learned how to mount a volume in a Pod. The big difference
    here, shown in [Example 7-4](#pod_referencing_persistent_volume_claim), is using
    `spec.volumes[].persistentVolumeClaim` and providing the name of the PersistentVolumeClaim.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4\. A Pod referencing a PersistentVolumeClaim
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume we stored the configuration in the file *app-consuming-pvc.yaml*.
    After creating the Pod from the manifest, you should see the Pod transitioning
    into the `Ready` state. The `describe` command will provide additional information
    on the volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The PersistentVolumeClaim now also shows the Pod that mounted it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now go ahead and open an interactive shell to the Pod. Navigating to
    the mount path at */mnt/data* gives you access to the underlying PersistentVolume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Storage Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A storage class is a Kubernetes primitive that defines a specific type or “class”
    of storage. Typical storage characteristics can be the type (e.g., fast SSD storage
    versus remote cloud storage or the backup policy for storage). The storage class
    is used to provision a PersistentVolume dynamically based on its criteria. In
    practice, this means that you do not have to create the PersistentVolume object
    yourself. The provisioner assigned to the storage class takes care of it. Most
    Kubernetes cloud providers come with a list of existing provisioners. Minikube
    already creates a default storage class named `standard`, which you can query
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating storage classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storage classes can be created declaratively only with the help of a YAML manifest.
    At a minimum, you need to declare the provisioner. All other attributes are optional
    and use default values if not provided upon creation. Most provisioners let you
    set parameters specific to the storage type. [Example 7-5](#storage_class_gce)
    defines a storage class on Google Compute Engine denoted by the provisioner `kubernetes.io/gce-pd`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-5\. Definition of a storage class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you saved the YAML contents in the file *fast-sc.yaml*, then the following
    command will create the object. The storage class can be listed using the `get
    storageclass` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using storage classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Provisioning a PersistentVolume dynamically requires assigning of the storage
    class when you create the PeristentVolumeClaim. [Example 7-6](#yaml_manifest_persistent_volume_claim_storage_class)
    shows the usage of the attribute `spec.storageClassName` for assigning the storage
    class named `standard`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-6\. Using a storage class in a PersistentVolumeClaim
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding PersistentVolume object will be created only if the storage
    class can provision a fitting PersistentVolume using its provisioner. It’s important
    to understand that Kubernetes does not render an error or warning message if it
    isn’t the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command renders the created PersistentVolumeClaim and PersistentVolume.
    As you can see, the name of the dynamically provisioned PersistentVolume uses
    a hash to ensure a unique naming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The steps for mounting the PersistentVolumeClaim from a Pod are the same as
    for static and dynamic provisioning. Refer to [“Mounting PersistentVolumeClaims
    in a Pod”](#mounting_persistent_volume) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes offers the concept of a Volume to implement the use case. A Pod mounts
    a Volume to a path in the container. Kubernetes offers a wide range of Volume
    types to fulfill different requirements.
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumes store data beyond a Pod or cluster/node restart. Those objects
    are decoupled from the Pod’s life cycle and are therefore represented by a Kubernetes
    primitive. The PersistentVolumeClaim abstracts the underlying implementation details
    of a PersistentVolume and acts as an intermediary between Pod and PersistentVolume.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practice defining and consuming ephemeral Volumes
  prefs: []
  type: TYPE_NORMAL
- en: Volumes are a cross-cutting concept applied in different areas of the exam.
    Know where to find the relevant documentation for defining a Volume as well as
    the multitude of ways to consume a Volume from a container. Definitely read [Chapter 19](ch19.xhtml#configmaps_secrets)
    for a deep dive on how to mount ConfigMaps and Secrets as a Volume, and [Chapter 8](ch08.xhtml#multi_container_pods)
    for sharing a Volume between two containers.
  prefs: []
  type: TYPE_NORMAL
- en: Internalize the mechanics of defining and consuming a PersistentVolume
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PersistentVolume involves a couple of moving parts. Understand the
    configuration options for PersistentVolumes and PersistentVolumeClaims and how
    they play together. Try to emulate situations that prevent a successful binding
    of a PersistentVolumeClaim. Then fix the situation by taking counteractions. Internalize
    the short-form commands `pv` and `pvc` to save precious time during the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_003.xhtml#appendix_a_volumes).
  prefs: []
  type: TYPE_NORMAL
- en: Create a Pod YAML manifest with two containers that use the image `alpine:3.12.0`.
    Provide a command for both containers that keep them running forever.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a Volume of type `emptyDir` for the Pod. Container 1 should mount the
    Volume to path */etc/a*, and container 2 should mount the Volume to path */etc/b*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open an interactive shell for container 1 and create the directory *data* in
    the mount path. Navigate to the directory and create the file *hello.txt* with
    the contents “Hello World.” Exit out of the container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open an interactive shell for container 2 and navigate to the directory */etc/b/data*.
    Inspect the contents of file *hello.txt*. Exit out of the container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a PersistentVolume named `logs-pv` that maps to the `hostPath` */var/logs*.
    The access mode should be `ReadWriteOnce` and `ReadOnlyMany`. Provision a storage
    capacity of 5Gi. Ensure that the status of the PersistentVolume shows `Available`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a PersistentVolumeClaim named `logs-pvc`. It uses `ReadWriteOnce` access.
    Request a capacity of 2Gi. Ensure that the status of the PersistentVolume shows
    `Bound`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Mount the PersistentVolumeClaim in a Pod running the image `nginx` at the mount
    path */var/log/nginx*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open an interactive shell to the container and create a new file named *my-nginx.log*
    in */var/log/nginx*. Exit out of the Pod.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delete the Pod and re-create it with the same YAML manifest. Open an interactive
    shell to the Pod, navigate to the directory */var/log/nginx*, and find the file
    you created before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
