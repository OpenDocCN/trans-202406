<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Appendix. Answers to Review Questions" data-type="appendix" epub:type="appendix"><div class="appendix" id="appendix-a">
<h1><span class="label">Appendix. </span>Answers to Review Questions</h1>
<section data-pdf-bookmark="Chapter 2, “Cluster Setup”" data-type="sect1"><div class="sect1" id="idm46394748049248">
<h1>Chapter 2, “Cluster Setup”</h1>
<ol>
<li>
<p><a data-primary="answers to review questions" data-secondary="cluster setup" data-type="indexterm" id="a_cs"/><a data-primary="cluster setup" data-secondary="answers to review questions" data-type="indexterm" id="cs_a"/>Create a file with the name <code>deny-egress-external.yaml</code> for defining the network policy. The network policy needs to set the Pod selector to <code>app=backend</code> and define the <code>Egress</code> policy type. Make sure to allow the port 53 for the protocols UDP and TCP. The namespace selector for the egress policy needs to use <code>{}</code> to select all namespaces:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NetworkPolicy</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">deny-egress-external</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/>
<code class="w">  </code><code class="nt">policyTypes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">Egress</code><code class="w"/>
<code class="w">  </code><code class="nt">egress</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">to</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">namespaceSelector</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">53</code><code class="w"/>
<code class="w">      </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">UDP</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">53</code><code class="w"/>
<code class="w">      </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/></pre>
<p>Run the <code>apply</code> command to instantiate the network policy object from the YAML file:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f deny-egress-external.yaml</strong></pre>
</li>
<li>
<p>A Pod that does not match the label selection of the network policy can make a call to a URL outside of the cluster. In this case, the label assignment is <code>app=frontend</code>:</p>
<pre data-type="programlisting"><strong>$ kubectl run web --image=busybox:1.36.0 -l app=frontend --port=80 -it</strong> \
  <strong>--rm --restart=Never -- wget http://google.com --timeout=5 --tries=1</strong>
Connecting to google.com (142.250.69.238:80)
Connecting to www.google.com (142.250.72.4:80)
saving to /'index.xhtml'
index.xhtml           100% |<strong><strong/><strong/></strong><strong><strong/><strong/></strong><strong><strong/><strong/></strong>**| 13987 \
0:00:00 ETA
/'index.xhtml' saved
pod "web" deleted</pre>
</li>
<li>
<p>A Pod that does match the label selection of the network policy cannot make a call to a URL outside of the cluster. In this case, the label assignment is <code>app=backend</code>:</p>
<pre data-type="programlisting"><strong>$ kubectl run web --image=busybox:1.36.0 -l app=backend --port=80 -it</strong> \
  <strong>--rm --restart=Never -- wget http://google.com --timeout=5 --tries=1</strong>
wget: download timed out
pod "web" deleted
pod default/web terminated (Error)</pre>
</li>
<li>
<p>First, see if the Dashboard is already installed. You can check the namespace the Dashboard usually creates:</p>
<pre data-type="programlisting"><strong>$ kubectl get ns kubernetes-dashboard</strong>
NAME                   STATUS   AGE
kubernetes-dashboard   Active   109s</pre>
<p>If the namespace does not exist, you can assume that the Dashboard has not been installed yet. Install it with the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/</strong>\
<strong>dashboard/v2.6.0/aio/deploy/recommended.yaml</strong></pre>
<p>Create the ServiceAccount, ClusterRole, and ClusterRoleBinding. Make sure that the ClusterRole only allows listing Deployment objects. The following YAML manifest has been saved in the file <code>dashboard-observer-user.yaml</code>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">observer-user</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubernetes-dashboard</code><code class="w"/>
<code class="nn">---</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">rbac.authorization.kubernetes.io/autoupdate</code><code class="p">:</code><code class="w"> </code><code class="s">"true"</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cluster-observer</code><code class="w"/>
<code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">'apps'</code><code class="w"/>
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">'deployments'</code><code class="w"/>
<code class="w">  </code><code class="nt">verbs</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">list</code><code class="w"/>
<code class="nn">---</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRoleBinding</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">observer-user</code><code class="w"/>
<code class="nt">roleRef</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code class="w"/>
<code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cluster-observer</code><code class="w"/>
<code class="nt">subjects</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">observer-user</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubernetes-dashboard</code><code class="w"/></pre>
<p>Create the objects with the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f dashboard-observer-user.yaml</strong></pre>
</li>
<li>
<p>Run the following command to create a token for the ServiceAccount. The option <code>--duration 0s</code> ensures that the token will never expire. Copy the token that was rendered in the console output of the command:</p>
<pre data-type="programlisting"><strong>$ kubectl create token observer-user -n kubernetes-dashboard</strong> \
  <strong>--duration 0s</strong>
eyJhbGciOiJSUzI1NiIsImtpZCI6Ik5lNFMxZ1...</pre>
<p>Run the proxy command and open the link <a class="bare" href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy"><em class="hyperlink">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy</em></a> in a browser:</p>
<pre data-type="programlisting"><strong>$ kubectl proxy</strong></pre>
<p>Select the “Token” authentication method and paste the token you copied before. Sign into the Dashboard. You should see that only Deployment objects are listable (see <a data-type="xref" href="#dashboard-deployments">Figure A-1</a>).</p>
<p>All other objects will say “There is nothing to display here.” <a data-type="xref" href="#dashboard-pods">Figure A-2</a> renders the list of Pods.</p>
<figure><div class="figure" id="dashboard-deployments">
<img alt="ckss aa01" height="856" src="assets/ckss_aa01.png" width="2926"/>
<h6><span class="label">Figure A-1. </span>The Dashboard view of Deployments is allowed</h6>
</div></figure>
<figure><div class="figure" id="dashboard-pods">
<img alt="ckss aa02" height="842" src="assets/ckss_aa02.png" width="2920"/>
<h6><span class="label">Figure A-2. </span>The Dashboard view of Pods is not permitted</h6>
</div></figure>
</li>
<li>
<p>Download the API server binary with the following command:</p>
<pre data-type="programlisting"><strong>$ curl -LO "https://dl.k8s.io/v1.26.1/bin/linux/amd64/kube-apiserver"</strong></pre>
<p>Next, download the SHA256 file for the same binary, but a different version. The following command downloads the file for version 1.23.1:</p>
<pre data-type="programlisting"><strong>$ curl -LO "https://dl.k8s.io/v1.23.1/bin/linux/amd64/</strong>\
<strong>kube-apiserver.sha256"</strong></pre>
<p><a data-primary="" data-startref="a_cs" data-type="indexterm" id="idm46394747712192"/><a data-primary="" data-startref="cs_a" data-type="indexterm" id="idm46394747711216"/>Comparing the binary file with the checksum file results in a failure, as the versions do not match:</p>
<pre data-type="programlisting"><strong>$ echo "$(cat kube-apiserver.sha256)  kube-apiserver" | shasum -a 256</strong> \
  <strong>--check</strong>
kube-apiserver: FAILED
shasum: WARNING: 1 computed checksum did NOT match</pre>
</li>
</ol>
</div></section>
<section data-pdf-bookmark="Chapter 3, “Cluster Hardening”" data-type="sect1"><div class="sect1" id="idm46394747708416">
<h1>Chapter 3, “Cluster Hardening”</h1>
<ol>
<li>
<p><a data-primary="answers to review questions" data-secondary="cluster hardening" data-type="indexterm" id="a_ch"/><a data-primary="cluster hardening" data-secondary="answers to review questions" data-type="indexterm" id="ch_a"/>Create a private key using the <code>openssl</code> executable. Provide an expressive file name, such as <code>jill.key</code>. The <code>-subj</code> option provides the username (CN) and the group (O). The following command uses the username <code>jill</code> and the group named <code>observer</code>:</p>
<pre data-type="programlisting"><strong>$ openssl genrsa -out jill.key 2048</strong>
<strong>$ openssl req -new -key jill.key -out jill.csr -subj</strong> \
  <strong>"/CN=jill/O=observer"</strong></pre>
<p>Retrieve the base64-encoded value of the CSR file content with the following command. You will need it when creating a the CertificateSigningRequest object in the next step:</p>
<pre data-type="programlisting"><strong>$ cat jill.csr | base64 | tr -d "\n"</strong>
LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tL...</pre>
<p>The following script creates a CertificateSigningRequest object:</p>
<pre data-type="programlisting"><strong>$ cat &lt;&lt;EOF | kubectl apply -f -</strong>
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: jill
spec:
  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tL...
  signerName: kubernetes.io/kube-apiserver-client
  expirationSeconds: 86400
  usages:
  - client auth
EOF</pre>
<p>Use the <code>certificate approve</code> command to approve the signing request and export the issued certificate:</p>
<pre data-type="programlisting"><strong>$ kubectl certificate approve jill</strong>
<strong>$ kubectl get csr jill -o jsonpath=<em>{.status.certificate}</em>| base64</strong> \
  <strong>-d &gt; jill.crt</strong></pre>
<p>Add the user to the kubeconfig file and add the context for the user. The cluster name used here is <code>minikube</code>. It might be different for your Kubernetes 
<span class="keep-together">environment:</span></p>
<pre data-type="programlisting"><strong>$ kubectl config set-credentials jill --client-key=jill.key</strong> \
  <strong>--client-certificate=jill.crt --embed-certs=true</strong>
<strong>$ kubectl config set-context jill --cluster=minikube --user=jill</strong></pre>
</li>
<li>
<p>Create the Role and RoleBinding. The following imperative commands assign the verbs <code>get</code>, <code>list</code>, and <code>watch</code> for Pods, ConfigMaps, and Secrets to the subject named <code>observer</code> of type <code>group</code>. The user <code>jill</code> is part of the group:</p>
<pre data-type="programlisting"><strong>$ kubectl create role observer --verb=create --verb=get --verb=list</strong> \
  <strong>--verb=watch --resource=pods --resource=configmaps --resource=secrets</strong>
<strong>$ kubectl create rolebinding observer-binding --role=observer</strong> \
  <strong>--group=observer</strong></pre>
</li>
<li>
<p>Switch to the user context:</p>
<pre data-type="programlisting"><strong>$ kubectl config use-context jill</strong></pre>
<p>We’ll pick one permitted operation, listing ConfigMap objects. The user is authorized to map the call:</p>
<pre data-type="programlisting"><strong>$ kubectl get configmaps</strong>
NAME               DATA   AGE
kube-root-ca.crt   1      16m</pre>
<p>Listing nodes won’t be authorized. The user does not have the appropriate 
<span class="keep-together">permissions:</span></p>
<pre data-type="programlisting"><strong>$ kubectl get nodes</strong>
Error from server (Forbidden): nodes is forbidden: User "jill" cannot \
list resource "nodes" in API group "" at the cluster scope</pre>
<p>Switch back to the admin context:</p>
<pre data-type="programlisting"><strong>$ kubectl config use-context minikube</strong></pre>
</li>
<li>
<p>Create the namespace <code>t23</code>:</p>
<pre data-type="programlisting"><strong>$ kubectl create namespace t23</strong></pre>
<p>Create the service account <code>api-call</code> in the namespace:</p>
<pre data-type="programlisting"><strong>$ kubectl create serviceaccount api-call -n t23</strong></pre>
<p>Define a YAML manifest file with the name <code>pod.yaml</code>. The contents of the file define a Pod that makes an HTTPS GET call to the API server to retrieve the list of Services in the <code>default</code> namespace:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">service-list</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">t23</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-call</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">service-list</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine/curl:3.14</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">'sh'</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">'-c'</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">'while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">curl</code><code class="nv"> </code><code class="s">-s</code><code class="nv"> </code><code class="s">-k</code><code class="nv"> </code><code class="s">-m</code><code class="nv"> </code><code class="s">5</code><code class="nv"> </code><code class="s">\</code><code class="w"/>
<code class="w">              </code><code class="s">-H</code><code class="nv"> </code><code class="s">"Authorization:</code><code class="nv"> </code><code class="s">Bearer</code><code class="nv"> </code><code class="s">$(cat</code><code class="nv"> </code><code class="s">/var/run/secrets/\</code><code class="w"/>
<code class="w">              </code><code class="s">kubernetes.io/serviceaccount/token)"</code><code class="nv"> </code><code class="s">https://kubernetes.\</code><code class="w"/>
<code class="w">              </code><code class="s">default.svc.cluster.local/api/v1/namespaces/default/\</code><code class="w"/>
<code class="w">              </code><code class="s">services;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">10;</code><code class="nv"> </code><code class="s">done'</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Create the Pod with the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f pod.yaml</strong></pre>
<p>Check the logs of the Pod. The API call is not authorized, as shown in the following log output:</p>
<pre data-type="programlisting"><strong>$ kubectl logs service-list -n t23</strong>
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {},
  "status": "Failure",
  "message": "services is forbidden: User \"system:serviceaccount:t23 \
              :api-call\" cannot list resource \"services\" in API \
              group \"\" in the namespace \"default\"",
  "reason": "Forbidden",
  "details": {
    "kind": "services"
  },
  "code": 403
}</pre>
</li>
<li>
<p>Create the YAML manifest in the file <code>clusterrole.yaml</code>, as shown in the 
<span class="keep-together">following:</span></p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">list-services-clusterrole</code><code class="w"/>
<code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"services"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code><code class="nt">verbs</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"list"</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Reference the ClusterRole in a RoleBinding defined in the file <code>rolebinding.yaml</code>. The subject should list the service account <code>api-call</code> in the namespace <code>t23</code>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RoleBinding</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">serviceaccount-service-rolebinding</code><code class="w"/>
<code class="nt">subjects</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-call</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">t23</code><code class="w"/>
<code class="nt">roleRef</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">list-services-clusterrole</code><code class="w"/>
<code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code class="w"/></pre>
<p>Create both objects from the YAML manifests:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f clusterrole.yaml
$ kubectl apply -f rolebinding.yaml</strong></pre>
<p>The API call running inside of the container should now be authorized and be allowed to list the Service objects in the <code>default</code> namespace. As shown in the following output, the namespace currently hosts at least one Service object, the <code>kubernetes.default</code> Service:</p>
<pre data-type="programlisting"><strong>$ kubectl logs service-list -n t23</strong>
{
  "kind": "ServiceList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion": "1108"
  },
  "items": [
     {
       "metadata": {
         "name": "kubernetes",
         "namespace": "default",
         "uid": "30eb5425-8f60-4bb7-8331-f91fe0999e20",
         "resourceVersion": "199",
         "creationTimestamp": "2022-09-08T18:06:52Z",
         "labels": {
           "component": "apiserver",
           "provider": "kubernetes"
       },
       ...
     }
  ]
}</pre>
</li>
<li>
<p>Create the token for the service account using the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl create token api-call -n t23</strong>
eyJhbGciOiJSUzI1NiIsImtpZCI6IjBtQkJzVWlsQjl...</pre>
<p>Change the existing Pod definition by deleting and recreating the live object. Add the attribute that disables automounting the token, as shown in the following:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">service-list</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">t23</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-call</code><code class="w"/>
<code class="w">  </code><code class="nt">automountServiceAccountToken</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">service-list</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine/curl:3.14</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">'sh'</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">'-c'</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">'while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">curl</code><code class="nv"> </code><code class="s">-s</code><code class="nv"> </code><code class="s">-k</code><code class="nv"> </code><code class="s">-m</code><code class="nv"> </code><code class="s">5</code><code class="nv"> </code><code class="s">\</code><code class="w"/>
<code class="w">              </code><code class="s">-H</code><code class="nv"> </code><code class="s">"Authorization:</code><code class="nv"> </code><code class="s">Bearer</code><code class="nv"> </code><code class="s">eyJhbGciOiJSUzI1NiIsImtpZCI6Ij</code><code class="nv"> </code><code class="s">\</code><code class="w"/>
<code class="w">              </code><code class="s">BtQkJzVWlsQjl"</code><code class="nv"> </code><code class="s">https://kubernetes.default.svc.cluster.</code><code class="nv"> </code><code class="s">\</code><code class="w"/>
<code class="w">              </code><code class="s">local/api/v1/namespaces/default/services;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">10;</code><code class="nv"> </code><code class="s">\</code><code class="w"/>
<code class="w">              </code><code class="s">done'</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>The API server will allow the HTTPS request performed with the token of the service account to be authenticated and authorized:</p>
<pre data-type="programlisting"><strong>$ kubectl logs service-list -n t23</strong>
{
  "kind": "ServiceList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion": "81194"
  },
  "items": [
     {
       "metadata": {
         "name": "kubernetes",
         "namespace": "default",
         "uid": "30eb5425-8f60-4bb7-8331-f91fe0999e20",
         "resourceVersion": "199",
         "creationTimestamp": "2022-09-08T18:06:52Z",
         "labels": {
           "component": "apiserver",
           "provider": "kubernetes"
       },
       ...
     }
  ]
}</pre>
</li>
<li>
<p>The solution to this sample exercise requires a lot of manual steps. The following commands do not render their output.</p>
<p>Open an interactive shell to the control plane node using Vagrant:</p>
<pre data-type="programlisting"><strong>$ vagrant ssh kube-control-plane</strong></pre>
<p>Upgrade <code>kubeadm</code> to version 1.26.1 and apply it:</p>
<pre data-type="programlisting"><strong>$ sudo apt-mark unhold kubeadm &amp;&amp; sudo apt-get update &amp;&amp; sudo apt-get</strong> \
  <strong>install -y kubeadm=1.26.1-00 &amp;&amp; sudo apt-mark hold kubeadm
$ sudo kubeadm upgrade apply v1.26.1</strong></pre>
<p>Drain the node, upgrade the kubelet and <code>kubectl</code>, restart the kubelet, and uncordon the node:</p>
<pre data-type="programlisting"><strong>$ kubectl drain kube-control-plane --ignore-daemonsets
$ sudo apt-get update &amp;&amp; sudo apt-get install -y</strong> \
  <strong>--allow-change-held-packages kubelet=1.26.1-00 kubectl=1.26.1-00
$ sudo systemctl daemon-reload
$ sudo systemctl restart kubelet
$ kubectl uncordon kube-control-plane</strong></pre>
<p>The version of the node should now say v1.26.1. Exit the node:</p>
<pre data-type="programlisting"><strong>$ kubectl get nodes
$ exit</strong></pre>
<p>Open an interactive shell to the first worker node using Vagrant. Repeat all of the following steps for the worker node:</p>
<pre data-type="programlisting"><strong>$ vagrant ssh kube-worker-1</strong></pre>
<p>Upgrade <code>kubeadm</code> to version 1.26.1 and apply it to the node:</p>
<pre data-type="programlisting"><strong>$ sudo apt-get update &amp;&amp; sudo apt-get install -y</strong> \
  <strong>--allow-change-held-packages kubeadm=1.26.1-00
$ sudo kubeadm upgrade node</strong></pre>
<p>Drain the node, upgrade the kubelet and <code>kubectl</code>, restart the kubelet, and uncordon the node:</p>
<pre data-type="programlisting"><strong>$ kubectl drain kube-worker-1 --ignore-daemonsets
$ sudo apt-get update &amp;&amp; sudo apt-get install -y</strong> \
  <strong>--allow-change-held-packages kubelet=1.26.1-00 kubectl=1.26.1-00
$ sudo systemctl daemon-reload
$ sudo systemctl restart kubelet
$ kubectl uncordon kube-worker-1</strong></pre>
<p><a data-primary="" data-startref="a_ch" data-type="indexterm" id="idm46394747163888"/><a data-primary="" data-startref="ch_a" data-type="indexterm" id="idm46394747137168"/>The version of the node should now say v1.26.1. Exit out of the node:</p>
<pre data-type="programlisting"><strong>$ kubectl get nodes
$ exit</strong></pre>
</li>
</ol>
</div></section>
<section data-pdf-bookmark="Chapter 4, “System Hardening”" data-type="sect1"><div class="sect1" id="idm46394747135008">
<h1>Chapter 4, “System Hardening”</h1>
<ol>
<li>
<p><a data-primary="answers to review questions" data-secondary="system hardening" data-type="indexterm" id="a_sh"/><a data-primary="system hardening" data-secondary="answers to review questions" data-type="indexterm" id="sh_a"/>Shell into the worker node with the following command:</p>
<pre data-type="programlisting"><strong>$ vagrant ssh kube-worker-1</strong></pre>
<p>Identify the process exposing port 21. One way to do this is by using the <code>lsof</code> command. The command that exposes the port is <code>vsftpd</code>:</p>
<pre data-type="programlisting"><strong>$ sudo lsof -i :21</strong>
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
vsftpd  10178 root    3u  IPv6  56850      0t0  TCP *:ftp (LISTEN)</pre>
<p>Alternatively, you could also use the <code>ss</code> command, as shown in the following:</p>
<pre data-type="programlisting">
<strong>$ sudo ss -at -pn '( dport = :21 or sport = :21 )'</strong>
State   Recv-Q   Send-Q   Local Address:Port \
   Peer Address:Port   Process
LISTEN  0   32   *:21 \
   *:*   users:(("vsftpd",pid=10178,fd=3))
</pre>
<p>The process <code>vsftpd</code> has been started as a service:</p>
<pre data-type="programlisting"><strong>$ sudo systemctl status vsftpd</strong>
● vsftpd.service - vsftpd FTP server
     Loaded: loaded (/lib/systemd/system/vsftpd.service; enabled; \
             vendor preset: enabled)
     Active: active (running) since Thu 2022-10-06 14:39:12 UTC; \
             11min ago
   Main PID: 10178 (vsftpd)
      Tasks: 1 (limit: 1131)
     Memory: 604.0K
     CGroup: /system.slice/vsftpd.service
             └─10178 /usr/sbin/vsftpd /etc/vsftpd.conf

Oct 06 14:39:12 kube-worker-1 systemd[1]: Starting vsftpd FTP server...
Oct 06 14:39:12 kube-worker-1 systemd[1]: Started vsftpd FTP server.</pre>
<p>Shut down the service and deinstall the package:</p>
<pre data-type="programlisting"><strong>$ sudo systemctl stop vsftpd
$ sudo systemctl disable vsftpd
$ sudo apt purge --auto-remove -y vsftpd</strong></pre>
<p>Checking on the port, you will see that it is not listed anymore:</p>
<pre data-type="programlisting"><strong>$ sudo lsof -i :21</strong></pre>
<p>Exit out of the node:</p>
<pre data-type="programlisting"><strong>$ exit</strong></pre>
</li>
<li>
<p>Shell into the worker node with the following command:</p>
<pre data-type="programlisting"><strong>$ vagrant ssh kube-worker-1</strong></pre>
<p>Create the AppArmor profile at <code>/etc/apparmor.d/network-deny</code> using the command <code>sudo vim /etc/apparmor.d/network-deny</code>. The contents of the file should look as follows:</p>
<pre data-type="programlisting">#include &lt;tunables/global&gt;

profile network-deny flags=(attach_disconnected) {
  #include &lt;abstractions/base&gt;

  network,
}</pre>
<p>Enforce the AppArmor profile by running the following command:</p>
<pre data-type="programlisting"><strong>$ sudo apparmor_parser /etc/apparmor.d/network-deny</strong></pre>
<p>You cannot modify the existing Pod object in order to add the annotation for AppArmor. You will need to delete the object first. Write the definition of the Pod to a file:</p>
<pre data-type="programlisting"><strong>$ kubectl get pod -o yaml &gt; pod.yaml
$ kubectl delete pod network-call</strong></pre>
<p>Edit the <code>pod.yaml</code> file to add the AppArmor annotation. For the relevant annotation, use the name of the container <code>network-call</code> as part of the key suffix and <code>localhost/network-deny</code> as the value. The suffix <code>network-deny</code> refers to the name of the AppArmor profile. The final content could look as follows after a little bit of cleanup:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">network-call</code><code class="w"/>
<code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">container.apparmor.security.beta.kubernetes.io/network-call</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">\</code><code class="w"/>
<code class="w">    </code><code class="l-Scalar-Plain">localhost/network-deny</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">network-call</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine/curl:3.14</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"sh"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">ping</code><code class="nv"> </code><code class="s">-c</code><code class="nv"> </code><code class="s">1</code><code class="nv"> </code><code class="s">google.com;</code><code class="nv"> </code><code class="s">\</code>
<code class="w">              </code><code class="s">sleep</code><code class="nv"> </code><code class="s">5;</code><code class="nv"> </code><code class="s">done"</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Create the Pod from the manifest. After a couple of seconds, the Pod should transition into the “Running” status:</p>
<pre data-type="programlisting"><strong>$ kubectl create -f pod.yaml
$ kubectl get pod network-call</strong>
NAME           READY   STATUS    RESTARTS   AGE
network-call   1/1     Running   0          27s</pre>
<p>AppArmor prevents the Pod from making a network call. You can check the logs to verify:</p>
<pre data-type="programlisting"><strong>$ kubectl logs network-call</strong>
...
sh: ping: Permission denied
sh: sleep: Permission denied</pre>
<p>Exit out of the node:</p>
<pre data-type="programlisting"><strong>$ exit</strong></pre>
</li>
<li>
<p>Shell into the worker node with the following command:</p>
<pre data-type="programlisting"><strong>$ vagrant ssh kube-worker-1</strong></pre>
<p>Create the target directory for the seccomp profiles:</p>
<pre data-type="programlisting"><strong>$ sudo mkdir -p /var/lib/kubelet/seccomp/profiles</strong></pre>
<p>Add the file <code>audit.json</code> in the directory <code>/var/lib/kubelet/seccomp/profiles</code> with the following content:</p>
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"defaultAction"</code><code class="p">:</code><code class="w"> </code><code class="s2">"SCMP_ACT_LOG"</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You cannot modify the existing Pod object in order to add the seccomp configuration via the security context. You will need to delete the object first. Write the definition of the Pod to a file:</p>
<pre data-type="programlisting"><strong>$ kubectl get pod -o yaml &gt; pod.yaml
$ kubectl delete pod network-call</strong></pre>
<p>Edit the <code>pod.yaml</code> file. Point the seccomp profile to the definition. The final content could look as follows after a little bit of cleanup:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">network-call</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">seccompProfile</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Localhost</code><code class="w"/>
<code class="w">      </code><code class="nt">localhostProfile</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">profiles/audit.json</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">network-call</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine/curl:3.14</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"sh"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">ping</code><code class="nv"> </code><code class="s">-c</code><code class="nv"> </code><code class="s">1</code><code class="nv"> </code><code class="s">google.com;</code><code class="nv"> </code><code class="s">\</code>
<code class="w">              </code><code class="s">sleep</code><code class="nv"> </code><code class="s">5;</code><code class="nv"> </code><code class="s">done"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">    </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">allowPrivilegeEscalation</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/></pre>
<p>Create the Pod from the manifest. After a couple of seconds, the Pod should transition into the “Running” status:</p>
<pre data-type="programlisting"><strong>$ kubectl create -f pod.yaml
$ kubectl get pod network-call</strong>
NAME           READY   STATUS    RESTARTS   AGE
network-call   1/1     Running   0          27s</pre>
<p>You should be able to find log entries for syscalls, e.g., for the <code>sleep</code> command:</p>
<pre data-type="programlisting"><strong>$ sudo cat /var/log/syslog</strong>
Oct  6 16:25:06 ubuntu-focal kernel: [ 2114.894122] audit: type=1326 \
audit(1665073506.099:23761): auid=4294967295 uid=0 gid=0 \
ses=4294967295 pid=19226 comm="sleep" exe="/bin/busybox" \
sig=0 arch=c000003e syscall=231 compat=0 ip=0x7fc026adbf0b \
code=0x7ffc0000</pre>
<p>Exit out of the node:</p>
<pre data-type="programlisting"><strong>$ exit</strong></pre>
<p>Create the Pod definition in the file <code>pod.yaml</code>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">sysctl-pod</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">sysctls</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">net.core.somaxconn</code><code class="w"/>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="s">"1024"</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">debug.iotrace</code><code class="w"/>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="s">"1"</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.23.1</code><code class="w"/></pre>
<p>Create the Pod and then check on the status. You will see that the status is “SysctlForbidden”:</p>
<pre data-type="programlisting"><strong>$ kubectl create -f pod.yaml
$ kubectl get pods</strong>
NAME         READY   STATUS            RESTARTS   AGE
sysctl-pod   0/1     SysctlForbidden   0          4s</pre>
<p><a data-primary="" data-startref="a_sh" data-type="indexterm" id="idm46394746707296"/><a data-primary="" data-startref="sh_a" data-type="indexterm" id="idm46394746706384"/>The event log will tell you more about the reasoning:</p>
<pre data-type="programlisting"><strong>$ kubectl describe pod sysctl-pod</strong>
...
Events:
  Type     Reason           Age    From    \
             Message
  ----     ------           ----   ----    \
             -------
  Warning  SysctlForbidden  2m48s  kubelet \
             forbidden sysctl: "net.core.somaxconn" \
             not allowlisted</pre>
</li>
</ol>
</div></section>
<section data-pdf-bookmark="Chapter 5, “Minimize Microservice Vulnerabilities”" data-type="sect1"><div class="sect1" id="idm46394747056992">
<h1>Chapter 5, “Minimize Microservice Vulnerabilities”</h1>
<ol>
<li>
<p><a data-primary="answers to review questions" data-secondary="microservice vulnerabilities" data-type="indexterm" id="a_mv"/><a data-primary="microservice vulnerabilities" data-secondary="answers to review questions" data-type="indexterm" id="mv_a"/>Define the Pod with the security settings in the file <code>busybox-security-context.yaml</code>. You can find the content of the following YAML manifest:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox-security-context</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">runAsUser</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1000</code><code class="w"/>
<code class="w">    </code><code class="nt">runAsGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3000</code><code class="w"/>
<code class="w">    </code><code class="nt">fsGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2000</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">vol</code><code class="w"/>
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.28</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"sh"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"sleep</code><code class="nv"> </code><code class="s">1h"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">vol</code><code class="w"/>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/data/test</code><code class="w"/>
<code class="w">    </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">allowPrivilegeEscalation</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/></pre>
<p>Create the Pod with the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f busybox-security-context.yaml
$ kubectl get pod busybox-security-context</strong>
NAME                       READY   STATUS    RESTARTS   AGE
busybox-security-context   1/1     Running   0          54s</pre>
<p>Shell into the container and create the file. You will find that the file group is 2000, as defined by the security context:</p>
<pre data-type="programlisting"><strong>$ kubectl exec busybox-security-context -it -- /bin/sh</strong>
/ $ cd /data/test
/data/test $ touch hello.txt
/data/test $ ls -l
total 0
-rw-r--r--    1 1000     2000             0 Nov 21 18:29 hello.txt
/data/test $ exit</pre>
</li>
<li>
<p>Specify the namespace named <code>audited</code> in the file <code>psa-namespace.yaml</code>. Set the PSA label with <code>baseline</code> level and the <code>warn</code> mode:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespace</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">audited</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/warn</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">baseline</code><code class="w"/></pre>
<p>Create the namespace from the YAML manifest:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f psa-namespace.yaml</strong></pre>
<p>You can produce an error by using the following Pod configuration in the file <code>psa-pod.yaml</code>. The YAML manifest sets the attribute <code>hostNetwork: true</code>, which is not allowed for the <a href="https://oreil.ly/c8JEW"><code>baseline</code> level</a>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">audited</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">hostNetwork</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.28</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"sh"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"sleep</code><code class="nv"> </code><code class="s">1h"</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Creating the Pod renders a warning message. The Pod will have been created nevertheless. You can prevent the creation of the Pod by configuring the PSA with the <code>restricted</code> level:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f psa-pod.yaml</strong>
Warning: would violate PodSecurity "baseline:latest": host namespaces \
(hostNetwork=true)
pod/busybox created
<strong>$ kubectl get pod busybox -n audited</strong>
NAME      READY   STATUS    RESTARTS   AGE
busybox   1/1     Running   0          2m21s</pre>
</li>
<li>
<p>You can install Gatekeeper with the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/</strong>\
<strong>gatekeeper/master/deploy/gatekeeper.yaml</strong></pre>
<p>The Gatekeeper library describes a ConstraintTemplate for defining <a href="https://oreil.ly/gyD1-">replica limits</a>. Inspect the YAML manifest described on the page. Apply the manifest with the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/</strong>\
<strong>gatekeeper-library/master/library/general/replicalimits/template.yaml</strong></pre>
<p>Now, define the Constraint with the YAML manifest in the file named <code>replica-limits-constraint.yaml</code>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">constraints.gatekeeper.sh/v1beta1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">K8sReplicaLimits</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">replica-limits</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">match</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">kinds</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"apps"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">        </code><code class="nt">kinds</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"Deployment"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code><code class="nt">parameters</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">ranges</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">min_replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code><code class="w"/>
<code class="w">      </code><code class="nt">max_replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">10</code><code class="w"/></pre>
<p>Create the Constraint with the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f replica-limits-constraint.yaml</strong></pre>
<p>You can see that a Deployment can only be created if the provided number of replicas falls within the range of the Constraint:</p>
<pre data-type="programlisting"><strong>$ kubectl create deployment nginx --image=nginx:1.23.2 --replicas=15</strong>
error: failed to create deployment: admission webhook \
"validation.gatekeeper.sh" denied the request: [replica-limits] \
The provided number of replicas is not allowed for deployment: nginx. \
Allowed ranges: {"ranges": [{"max_replicas": 10, "min_replicas": 3}]}
<strong>$ kubectl create deployment nginx --image=nginx:1.23.2 --replicas=7</strong>
deployment.apps/nginx created</pre>
</li>
<li>
<p>Configure encryption for etcd, as described in <a data-type="xref" href="ch05.xhtml#encrypting-etcd-data">“Encrypting etcd Data”</a>. Next, create a new Secret with the following imperative command:</p>
<pre data-type="programlisting"><strong>$ kubectl create secret generic db-credentials</strong> \
  <strong>--from-literal=api-key=YZvkiWUkycvspyGHk3fQRAkt</strong></pre>
<p>You can check the encrypted value of the Secret stored in etcd with the following command:</p>
<pre data-type="programlisting"><strong>$ sudo ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt</strong> \
<strong>--cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/</strong>\
<strong>etcd/server.key get /registry/secrets/default/db-credentials | hexdump -C</strong></pre>
</li>
<li>
<p>Open an interactive shell to the worker node using Vagrant:</p>
<pre data-type="programlisting"><strong>$ vagrant ssh kube-worker-1</strong></pre>
<p>Define the RuntimeClass with the following YAML manifest. The contents have been stored in the file <code>runtime-class.yaml</code>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">node.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RuntimeClass</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">container-runtime-sandbox</code><code class="w"/>
<code class="nt">handler</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">runsc</code><code class="w"/></pre>
<p>Create the RuntimeClass object:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f runtime-class.yaml</strong></pre>
<p>Assign the name of the RuntimeClass to the Pod using the <code>spec.runtimeClassName</code> attribute. The nginx Pod has been defined in the file <code>pod.yaml</code>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">runtimeClassName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">container-runtime-sandbox</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.23.2</code><code class="w"/></pre>
<p>Create the Pod object. The Pod will transition into the status “Running”:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f pod.yaml
$ kubectl get pod nginx</strong>
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          2m21s</pre>
<p><a data-primary="" data-startref="a_mv" data-type="indexterm" id="idm46394746098928"/><a data-primary="" data-startref="mv_a" data-type="indexterm" id="idm46394746098048"/>Exit out of the node:</p>
<pre data-type="programlisting"><strong>$ exit</strong></pre>
</li>
</ol>
</div></section>
<section data-pdf-bookmark="Chapter 6, “Supply Chain Security”" data-type="sect1"><div class="sect1" id="idm46394746146560">
<h1>Chapter 6, “Supply Chain Security”</h1>
<ol>
<li>
<p><a data-primary="answers to review questions" data-secondary="supply chain security" data-type="indexterm" id="a_scs"/><a data-primary="supply chain security" data-secondary="answers to review questions" data-type="indexterm" id="scs_a"/>The initial container image built with the provided Dockerfile has a size of 998MB. You can produce and run the container image with the following commands. Run a quick <code>curl</code> command to see if the endpoint exposed by the application can be reached:</p>
<pre data-type="programlisting"><strong>$ docker build . -t node-app:0.0.1</strong>
...
<strong>$ docker images</strong>
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
node-app     0.0.1     7ba99d4ba3af   3 seconds ago   998MB
<strong>$ docker run -p 3001:3001 -d node-app:0.0.1</strong>
c0c8a301eeb4ac499c22d10399c424e1063944f18fff70ceb5c49c4723af7969
<strong>$ curl -L http://localhost:3001/</strong>
Hello World</pre>
<p>One of the changes you can make is to avoid using a large base image. You could replace it with the <code>alpine</code> version of the node base image. Also, avoid pulling the <code>latest</code> image. Pick the Node.js version you actually want the application to run with. The following command uses a Dockerfile with the base image <code>node:19-alpine</code>, which reduces the container image size to 176MB:</p>
<pre data-type="programlisting"><strong>$ docker build . -t node-app:0.0.1</strong>
...
<strong>$ docker images</strong>
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
node-app     0.0.1     ef2fbec41a75   2 seconds ago    176MB</pre>
</li>
<li>
<p>You can install Kyverno using Helm or by pointing to the YAML manifest available on the project’s GitHub repository. We’ll use the YAML manifest here:</p>
<pre data-type="programlisting"><strong>$ kubectl create -f https://raw.githubusercontent.com/kyverno/</strong>\
<strong>kyverno/main/config/install.yaml</strong></pre>
<p>Set up a YAML manifest file named <code>restrict-image-registries.yaml</code>. Add the following contents to the file. The manifest represents a ClusterPolicy that only allows the use of container images that start with <code>gcr.io/</code>. Make sure to assign the value <code>Enforce</code> to the attribute <code>spec.validationFailureAction</code>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kyverno.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterPolicy</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">restrict-image-registries</code><code class="w"/>
<code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">policies.kyverno.io/title</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Restrict Image Registries</code><code class="w"/>
<code class="w">    </code><code class="nt">policies.kyverno.io/category</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Best Practices, EKS Best Practices</code><code class="w"/>
<code class="w">    </code><code class="nt">policies.kyverno.io/severity</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">medium</code><code class="w"/>
<code class="w">    </code><code class="nt">policies.kyverno.io/minversion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1.6.0</code><code class="w"/>
<code class="w">    </code><code class="nt">policies.kyverno.io/subject</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="w">    </code><code class="nt">policies.kyverno.io/description</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;-</code><code class="w"/>
<code class="w">      </code><code class="no">Images from unknown, public registries can be of dubious quality \</code><code class="w"/>
<code class="w">      </code><code class="no">and may not be scanned and secured, representing a high degree of \</code><code class="w"/>
<code class="w">      </code><code class="no">risk. Requiring use of known, approved registries helps reduce \</code><code class="w"/>
<code class="w">      </code><code class="no">threat exposure by ensuring image pulls only come from them. This \</code><code class="w"/>
<code class="w">      </code><code class="no">policy validates that container images only originate from the \</code><code class="w"/>
<code class="w">      </code><code class="no">registry `eu.foo.io` or `bar.io`. Use of this policy requires \</code><code class="w"/>
<code class="w">      </code><code class="no">customization to define your allowable registries.</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">validationFailureAction</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Enforce</code><code class="w"/>
<code class="w">  </code><code class="nt">background</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">validate-registries</code><code class="w"/>
<code class="w">    </code><code class="nt">match</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">any</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">kinds</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="w">    </code><code class="nt">validate</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">message</code><code class="p">:</code><code class="w"> </code><code class="s">"Unknown</code><code class="nv"> </code><code class="s">image</code><code class="nv"> </code><code class="s">registry."</code><code class="w"/>
<code class="w">      </code><code class="nt">pattern</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="s">"gcr.io/*"</code><code class="w"/></pre>
<p>Apply the manifest with the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f restrict-image-registries.yaml</strong></pre>
<p>Run the following commands to verify that the policy has become active. Any container image definition that doesn’t use the prefix <code>gcr.io/</code> will be denied:</p>
<pre data-type="programlisting">
<strong>$ kubectl run nginx --image=nginx:1.23.3</strong>
Error from server: admission webhook "validate.kyverno.svc-fail" \
denied the request:

policy Pod/default/nginx for resource violation:

restrict-image-registries:
  validate-registries: 'validation error: Unknown image registry. \
  rule validate-registries
    failed at path /spec/containers/0/image/'
<strong>$ kubectl run busybox --image=gcr.io/google-containers/busybox:1.27.2</strong>
pod/busybox created</pre>
</li>
<li>
<p>Find the SHA256 hash for the image <code>nginx:1.23.3-alpine</code> with the search 
<span class="keep-together">functionality</span> of Docker Hub. The <a href="https://oreil.ly/a4o8E">search result</a> will lead you to the tag 
<span class="keep-together">of the image. On</span> top of the page, you should find the digest <code>sha256:c1b9fe3c0c015486cf1e4a0ecabe78d05864475e279638e9713eb55f013f907f</code>. Use the digest instead of the tag in the Pod definition. The result is the following YAML manifest:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx@sha256:c1b9fe3c0c015486cf1e4a0ecabe78d05864475e279638 \</code><code class="w"/>
<code class="w">           </code><code class="l-Scalar-Plain">e9713eb55f013f907f</code><code class="w"/></pre>
<p>The creation of the Pod should work:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f pod-validate-image.yaml</strong>
pod/nginx created
<strong>$ kubectl get pods nginx</strong>
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          29s</pre>
<p>If you modify the SHA256 hash in any form and try to recreate the Pod, then Kubernetes would not allow you to pull the image.</p>
</li>
<li>
<p>Running Kubesec in a Docker container results in a whole bunch of suggestions, as shown in the following output:</p>
<pre data-type="programlisting"><strong>$ docker run -i kubesec/kubesec:512c5e0 scan /dev/stdin &lt; pod.yaml</strong>
[
  {
    "object": "Pod/hello-world.default",
    "valid": true,
    "message": "Passed with a score of 0 points",
    "score": 0,
    "scoring": {
      "advise": [
        {
          "selector": "containers[] .securityContext .capabilities \
                       .drop | index(\"ALL\")",
          "reason": "Drop all capabilities and add only those \
                     required to reduce syscall attack surface"
        },
        {
          "selector": "containers[] .resources .requests .cpu",
          "reason": "Enforcing CPU requests aids a fair balancing \
                     of resources across the cluster"
        },
        {
          "selector": "containers[] .securityContext .runAsNonRoot \
                       == true",
          "reason": "Force the running image to run as a non-root \
                     user to ensure least privilege"
        },
        {
          "selector": "containers[] .resources .limits .cpu",
          "reason": "Enforcing CPU limits prevents DOS via resource \
                     exhaustion"
        },
        {
          "selector": "containers[] .securityContext .capabilities \
                       .drop",
          "reason": "Reducing kernel capabilities available to a \
                     container limits its attack surface"
        },
        {
          "selector": "containers[] .resources .requests .memory",
          "reason": "Enforcing memory requests aids a fair balancing \
                     of resources across the cluster"
        },
        {
          "selector": "containers[] .resources .limits .memory",
          "reason": "Enforcing memory limits prevents DOS via resource \
                     exhaustion"
        },
        {
          "selector": "containers[] .securityContext \
                       .readOnlyRootFilesystem == true",
          "reason": "An immutable root filesystem can prevent malicious \
                     binaries being added to PATH and increase attack \
                     cost"
        },
        {
          "selector": ".metadata .annotations .\"container.seccomp. \
                       security.alpha.kubernetes.io/pod\"",
          "reason": "Seccomp profiles set minimum privilege and secure \
                     against unknown threats"
        },
        {
          "selector": ".metadata .annotations .\"container.apparmor. \
                       security.beta.kubernetes.io/nginx\"",
          "reason": "Well defined AppArmor policies may provide greater \
                     protection from unknown threats. WARNING: NOT \
                     PRODUCTION READY"
        },
        {
          "selector": "containers[] .securityContext .runAsUser -gt \
                       10000",
          "reason": "Run as a high-UID user to avoid conflicts with \
                     the host's user table"
        },
        {
          "selector": ".spec .serviceAccountName",
          "reason": "Service accounts restrict Kubernetes API access \
                     and should be configured with least privilege"
        }
      ]
    }
  }
]</pre>
<p>The fixed-up YAML manifest could look like this:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hello-world</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">linux</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hello-world:linux</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"64Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"250m"</code><code class="w"/>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"128Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"500m"</code><code class="w"/>
<code class="w">    </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">readOnlyRootFilesystem</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">      </code><code class="nt">runAsNonRoot</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">      </code><code class="nt">runAsUser</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">20000</code><code class="w"/>
<code class="w">      </code><code class="nt">capabilities</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">drop</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"ALL"</code><code class="p-Indicator">]</code><code class="w"/></pre>
</li>
<li>
<p>Executing the <code>kubectl apply</code> command against the existing <code>setup.yaml</code> manifest will create the Pods named <code>backend</code>, <code>loop</code>, and <code>logstash</code> in the namespace <code>r61</code>:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f setup.yaml</strong>
namespace/r61 created
pod/backend created
pod/loop created
pod/logstash created</pre>
<p>You can check on them with the following command:</p>
<pre data-type="programlisting"><strong>$ kubectl get pods -n r61</strong>
NAME       READY   STATUS    RESTARTS   AGE
backend    1/1     Running   0          115s
logstash   1/1     Running   0          115s
loop       1/1     Running   0          115s</pre>
<p>Check the images of each Pod in the namespace <code>r61</code> using the <code>kubectl describe</code> command. The images used are <code>bmuschko/nodejs-hello-world:1.0.0</code>, <code>alpine:3.13.4</code>, and <code>elastic/logstash:7.13.3</code>:</p>
<pre data-type="programlisting"><strong>$ kubectl describe pod backend -n r61</strong>
...
Containers:
  hello:
    Container ID:   docker://eb0bdefc75e635d03b625140d1e \
                    b229ca2db7904e44787882147921c2bd9c365
    Image:          bmuschko/nodejs-hello-world:1.0.0
    ...</pre>
<p>Use the Trivy executable to check vulnerabilities for all images:</p>
<pre data-type="programlisting"><strong>$ trivy image bmuschko/nodejs-hello-world:1.0.0
$ trivy image alpine:3.13.4
$ trivy image elastic/logstash:7.13.3</strong></pre>
<p><a data-primary="" data-startref="a_scs" data-type="indexterm" id="idm46394745647872"/><a data-primary="" data-startref="scs_a" data-type="indexterm" id="idm46394745646896"/>If you look closely at the list of vulnerabilities, you will find that all images contain issues with “CRITICAL” severity. As a result, delete all Pods:</p>
<pre data-type="programlisting"><strong>$ kubectl delete pod backend -n r61
$ kubectl delete pod logstash -n r61
$ kubectl delete pod loop -n r61</strong></pre>
</li>
</ol>
</div></section>
<section data-pdf-bookmark="Chapter 7, “Monitoring, Logging, and Runtime Security”" data-type="sect1"><div class="sect1" id="idm46394745615840">
<h1>Chapter 7, “Monitoring, Logging, and Runtime Security”</h1>
<ol>
<li>
<p><a data-primary="answers to review questions" data-secondary="behavior analytics" data-type="indexterm" id="a_ba"/><a data-primary="behavior analytics" data-secondary="answers to review questions" data-type="indexterm" id="ba_a"/>Shell into the worker node with the following command:</p>
<pre data-type="programlisting"><strong>$ vagrant ssh kube-worker-1</strong></pre>
<p>Inspect the command and arguments of the running Pod named <code>malicious</code>. You will see that it tries to append a message to the file <code>/etc/threat</code>:</p>
<pre data-type="programlisting">
<strong>$ kubectl get pod malicious -o jsonpath='{.spec.containers[0].args}'</strong>
...
spec:
  containers:
  - args:
    - /bin/sh
    - -c
    - while true; do echo "attacker intrusion" &gt;&gt; /etc/threat; \
      sleep 5; done
...
</pre>
<p>One of Falco’s default rules monitors file operations that try to write to the <code>/etc</code> directory. You can find a message for every write attempt in standard output:</p>
<pre data-type="programlisting"><strong>$ sudo journalctl -fu falco</strong>
Jan 24 23:40:18 kube-worker-1 falco[8575]: 23:40:18.359740123: Error \
File below /etc opened for writing (user=&lt;NA&gt; user_loginuid=-1 \
command=sh -c while true; do echo "attacker intrusion" &gt;&gt; /etc/threat; \
sleep 5; done pid=9763 parent=&lt;NA&gt; pcmdline=&lt;NA&gt; file=/etc/threat \
program=sh gparent=&lt;NA&gt; ggparent=&lt;NA&gt; gggparent=&lt;NA&gt; \
container_id=e72a6dbb63b8 image=docker.io/library/alpine)
...</pre>
<p>Find the rule that produces the message in <code>/etc/falco/falco_rules.yaml</code> by searching for the string “etc opened for writing.” The rule looks as follows:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Write below etc</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">an attempt to write to any file below /etc</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">write_etc_common</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="s">"File</code><code class="nv"> </code><code class="s">below</code><code class="nv"> </code><code class="s">/etc</code><code class="nv"> </code><code class="s">opened</code><code class="nv"> </code><code class="s">for</code><code class="nv"> </code><code class="s">writing</code><code class="nv"> </code><code class="s">(user=%user.name</code><code class="nv"> </code><code class="s">\</code>
<code class="w">           </code><code class="s">user_loginuid=%user.loginuid</code><code class="nv"> </code><code class="s">command=%proc.cmdline</code><code class="nv"> </code><code class="s">\</code>
<code class="w">           </code><code class="s">pid=%proc.pid</code><code class="nv"> </code><code class="s">parent=%proc.pname</code><code class="nv"> </code><code class="s">pcmdline=%proc.pcmdline</code><code class="nv"> </code><code class="s">\</code>
<code class="w">           </code><code class="s">file=%fd.name</code><code class="nv"> </code><code class="s">program=%proc.name</code><code class="nv"> </code><code class="s">gparent=%proc.aname[2]</code><code class="nv"> </code><code class="s">\</code>
<code class="w">           </code><code class="s">ggparent=%proc.aname[3]</code><code class="nv"> </code><code class="s">gggparent=%proc.aname[4]</code><code class="nv"> </code><code class="s">\</code>
<code class="w">           </code><code class="s">container_id=%container.id</code><code class="nv"> </code><code class="s">image=%container.image.repository)"</code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ERROR</code><code class="w"/>
<code class="w">  </code><code class="nt">tags</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">filesystem</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">mitre_persistence</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Copy the rule to the file <code>/etc/falco/falco_rules.local.yaml</code> and modify the output definition, as follows:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Write below etc</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">an attempt to write to any file below /etc</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">write_etc_common</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="s">"%evt.time,%user.name,%container.id"</code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ERROR</code><code class="w"/>
<code class="w">  </code><code class="nt">tags</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">filesystem</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">mitre_persistence</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Restart the Falco service, and find the changed output in the Falco logs:</p>
<pre data-type="programlisting"><strong>$ sudo systemctl restart falco
$ sudo journalctl -fu falco</strong>
Jan 24 23:48:18 kube-worker-1 falco[17488]: 23:48:18.516903001: \
Error 23:48:18.516903001,&lt;NA&gt;,e72a6dbb63b8
...</pre>
<p>Edit the file <code>/etc/falco/falco.yaml</code> to change the output channel. Disable standard output, enable file output, and point the <code>file_output</code> attribute to the file <code>/var/log/falco.log</code>. The resulting configuration will look like the 
<span class="keep-together">following:</span></p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">file_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">keep_alive</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">filename</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/log/falco.log</code><code class="w"/>

<code class="nt">stdout_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/></pre>
<p>The log file will now append Falco log:</p>
<pre data-type="programlisting"><strong>$ sudo tail -f /var/log/falco.log</strong>
00:10:30.425084165: Error 00:10:30.425084165,&lt;NA&gt;,e72a6dbb63b8
...</pre>
<p>Exit out of the VM:</p>
<pre data-type="programlisting"><strong>$ exit</strong></pre>
</li>
<li>
<p>Create the Pod named <code>hash</code> from the <code>setup.yaml</code> file. The command running in its container appends a hash to a file at <code>/var/config/hash.txt</code> in an infinite loop:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f setup.yaml</strong>
pod/hash created
<strong>$ kubectl get pod hash</strong>
NAME   READY   STATUS    RESTARTS   AGE
hash   1/1     Running   0          27s
<strong>$ kubectl exec -it hash -- /bin/sh</strong>
/ # ls /var/config/hash.txt
/var/config/hash.txt</pre>
<p>To make the container immutable, you will have to add configuration to the existing Pod definition. You have to set the root filesystem to read-only access and mount a Volume to the path <code>/var/config</code> to allow writing to the file named <code>hash.txt</code>. The resulting YAML manifest could look as follows:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hash</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hash</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine:3.17.1</code><code class="w"/>
<code class="w">    </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">readOnlyRootFilesystem</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hash-vol</code><code class="w"/>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/config</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"sh"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"if</code><code class="nv"> </code><code class="s">[</code><code class="nv"> </code><code class="s">!</code><code class="nv"> </code><code class="s">-d</code><code class="nv"> </code><code class="s">/var/config</code><code class="nv"> </code><code class="s">];</code><code class="nv"> </code><code class="s">then</code><code class="nv"> </code><code class="s">mkdir</code><code class="nv"> </code><code class="s">-p</code><code class="nv"> </code><code class="s">\</code>
<code class="w">              </code><code class="s">/var/config;</code><code class="nv"> </code><code class="s">fi;</code><code class="nv"> </code><code class="s">while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">echo</code><code class="nv"> </code><code class="s">$RANDOM</code><code class="nv"> </code><code class="s">|</code><code class="nv"> </code><code class="s">md5sum</code><code class="nv"> </code><code class="s">\</code>
<code class="w">              </code><code class="s">|</code><code class="nv"> </code><code class="s">head</code><code class="nv"> </code><code class="s">-c</code><code class="nv"> </code><code class="s">20</code><code class="nv"> </code><code class="s">&gt;&gt;</code><code class="nv"> </code><code class="s">/var/config/hash.txt;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">20;</code><code class="nv"> </code><code class="s">done"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hash-vol</code><code class="w"/>
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/></pre>
</li>
<li>
<p>Shell into the control plane node with the following command:</p>
<pre data-type="programlisting"><strong>$ vagrant ssh kube-control-plane</strong></pre>
<p>Edit the existing audit policy file at <code>/etc/kubernetes/audit/rules/audit-policy.yaml</code>. Add the rules asked about in the instructions. The content of the final audit policy file could look as follows:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">audit.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Policy</code><code class="w"/>
<code class="nt">omitStages</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"RequestReceived"</code><code class="w"/>
<code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">level</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RequestResponse</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">      </code><code class="nt">resources</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"pods"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">level</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Metadata</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">      </code><code class="nt">resources</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"secrets"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"configmaps"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">level</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Request</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">      </code><code class="nt">resources</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"services"</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Configure the API server to consume the audit policy file by editing the file <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code>. Provide additional options, as requested. The relevant configuration needed is as follows:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">command</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">kube-apiserver</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">--audit-policy-file=/etc/kubernetes/audit/rules/audit-policy.yaml</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">--audit-log-path=/var/log/kubernetes/audit/logs/apiserver.log</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">--audit-log-maxage=5</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/kubernetes/audit/rules/audit-policy.yaml</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">audit</code><code class="w"/>
<code class="w">      </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/log/kubernetes/audit/logs/</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">audit-log</code><code class="w"/>
<code class="w">      </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="p">...</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">audit</code><code class="w"/>
<code class="w">    </code><code class="nt">hostPath</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/kubernetes/audit/rules/audit-policy.yaml</code><code class="w"/>
<code class="w">      </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">File</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">audit-log</code><code class="w"/>
<code class="w">    </code><code class="nt">hostPath</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/log/kubernetes/audit/logs/</code><code class="w"/>
<code class="w">      </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DirectoryOrCreate</code><code class="w"/></pre>
<p>One of the logged resources is a ConfigMap on the <code>Metadata</code> level. The following command creates an exemplary ConfigMap object:</p>
<pre data-type="programlisting"><strong>$ kubectl create configmap db-user --from-literal=username=tom</strong>
configmap/db-user created</pre>
<p>The audit log file will now contain an entry for the event:</p>
<pre data-type="programlisting"><strong>$ sudo cat /var/log/kubernetes/audit/logs/apiserver.log</strong>
{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata", \
"auditID":"1fbb409a-3815-4da8-8a5e-d71c728b98b1","stage": \
"ResponseComplete","requestURI":"/api/v1/namespaces/default/configmaps? \
fieldManager=kubectl-create\u0026fieldValidation=Strict","verb": \
"create","user":{"username":"kubernetes-admin","groups": \
["system:masters","system:authenticated"]},"sourceIPs": \
["192.168.56.10"], "userAgent":"kubectl/v1.24.4 (linux/amd64) \
kubernetes/95ee5ab", "objectRef":{"resource":"configmaps", \
"namespace":"default", "name":"db-user","apiVersion":"v1"}, \
"responseStatus":{"metadata": {},"code":201}, \
"requestReceivedTimestamp":"2023-01-25T18:57:51.367219Z", \
"stageTimestamp":"2023-01-25T18:57:51.372094Z","annotations": \
{"authorization.k8s.io/decision":"allow", \
"authorization.k8s.io/reason":""}}</pre>
<p>Exit out of the VM:</p>
<pre data-type="programlisting"><strong>$ exit</strong></pre>
</li>
</ol>
</div></section>
</div></section></div></body></html>