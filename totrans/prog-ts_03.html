<html><head></head><body><section data-pdf-bookmark="Chapter 3. All About Types" data-type="chapter" epub:type="chapter"><div class="chapter" id="types">&#13;
<h1><span class="label">Chapter 3. </span>All About Types</h1>&#13;
&#13;
&#13;
<p>In the last chapter I introduced the idea of type systems, but I never defined what the <em>type</em> in type system really means.<a data-primary="types" data-secondary="defined" data-type="indexterm" id="idm46304992988872"/></p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304992987768">&#13;
<h5>Type</h5>&#13;
<p>A set of values and the things you can do with them.</p>&#13;
</div></aside>&#13;
&#13;
<p>If that sounds confusing, let me give a few familiar examples:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>boolean</code> type is the set of all booleans (there are just two: <code>true</code> and <code>false</code>) and the operations you can perform on them (like <code>||</code>, <code>&amp;&amp;</code>, and <code>!</code>).<a data-primary="boolean type" data-type="indexterm" id="idm46304992981624"/></p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>number</code> type is the set of all numbers and the operations you can perform on them (like <code>+</code>, <code>-</code>, *, <code>/</code>, <code>%</code>, <code>||</code>, <code>&amp;&amp;</code>, and <code>?</code>), including the methods you can call on them like <code>.toFixed</code>, <code>.toPrecision</code>, <code>.toString</code>, and so on.<a data-primary="number type" data-type="indexterm" id="idm46304992953992"/></p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>string</code> type is the set of all strings and the operations you can perform on them (like <code>+</code>, <code>||</code>, and <code>&amp;&amp;</code>), including the methods you can call on them like <code><span class="keep-together">.concat</span></code> and <code>.toUpperCase</code>.<a data-primary="string type" data-type="indexterm" id="idm46304992949496"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>When you see that something is of type <code>T</code>, not only do you know that it’s a <code>T</code>, but you also know <em>exactly what you can do</em> with that <code>T</code> (and what you can’t). Remember, the whole point is to use the typechecker to stop you from doing invalid things.<a data-primary="typechecker" data-type="indexterm" id="idm46304992946168"/> And the way the typechecker knows what’s valid and what’s not is by looking at the types you’re using and how you’re using them.</p>&#13;
&#13;
<p>In this chapter we’ll take a tour of the types available in TypeScript and cover the basics of what you can do with each of them. <a data-type="xref" href="#ch03-type-hierarchy">Figure 3-1</a> gives an overview.</p>&#13;
&#13;
<figure><div class="figure" id="ch03-type-hierarchy">&#13;
<img alt="prts 0301" src="assets/prts_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>TypeScript’s type hierarchy</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Talking About Types" data-type="sect1"><div class="sect1" id="talking-about-types">&#13;
<h1>Talking About Types</h1>&#13;
&#13;
<p>When programmers talk about types, they share a precise, common vocabulary to describe what they mean.<a data-primary="types" data-secondary="terminology and vocabulary of" data-type="indexterm" id="idm46304992939848"/> We’re going to use this vocabulary throughout this book.</p>&#13;
&#13;
<p>Say you have a function that takes some value and returns<a data-primary="functions" data-secondary="parameter types" data-type="indexterm" id="idm46304992938296"/> that value multiplied by itself:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">squareOf</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">squareOf</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>     <code class="c1">// evaluates to 4</code>&#13;
<code class="nx">squareOf</code><code class="p">(</code><code class="s1">'z'</code><code class="p">)</code>   <code class="c1">// evaluates to NaN</code></pre>&#13;
&#13;
<p>Clearly, this function will only work for numbers—if you pass anything besides a number to <code>squareOf</code>, the result will be invalid.<a data-primary="parameters" data-secondary="type" data-type="indexterm" id="idm46304992912344"/> So what we do is explicitly <em>annotate</em> the parameter’s<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304992910984"/> type:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">function</code><code> </code><code class="nx">squareOf</code><code class="p">(</code><code class="nx">n</code><code>: </code><code class="kt">number</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">n</code><code> </code><code class="o">*</code><code> </code><code class="nx">n</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="nx">squareOf</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code>     </code><em><code class="c1">// evaluates to 4</code></em><code class="c1">&#13;
</code><code class="nx">squareOf</code><code class="p">(</code><code class="s1">'z'</code><code class="p">)</code><code>   </code><em><code class="c1">// Error TS2345: Argument of type '"z"' is not assignable to</code></em><code class="c1">&#13;
</code><code>                </code><em><code class="c1">// parameter of type 'number'.</code></em><code class="c1">&#13;
</code></pre>&#13;
&#13;
<p>Now if we call <code>squareOf</code> with anything but a number, TypeScript will know to complain right away. This is a trivial example (we’ll talk a lot more about functions in the next chapter), but it’s enough to introduce a couple of concepts that are key to talking about types in TypeScript. We can say the following things about the last code example:</p>&#13;
<ol>&#13;
<li>&#13;
<p><code>squareOf</code>’s parameter <code>n</code> is <em>constrained to</em> <code>number</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The type of the value <code>2</code> is <em>assignable to</em> (equivalently: <em>compatible with</em>) <code>number</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Without a type annotation, <code>squareOf</code> is unconstrained in its parameter, and you can pass any type of argument to it.<a data-primary="constraints" data-type="indexterm" id="idm46304992835336"/><a data-primary="assignability" data-type="indexterm" id="idm46304992834632"/> Once we constrain it, TypeScript goes to work for us verifying that every place we call our function, we call it with a compatible argument. In this example the type of <code>2</code> is <code>number</code>, which is assignable to <code>squareOf</code>’s annotation <code>number</code>, so TypeScript accepts our code; but <code>'z'</code> is a <code>string</code>, which is not assignable to <code>number</code>, so TypeScript complains.</p>&#13;
&#13;
<p>You can also <a data-primary="bounds" data-type="indexterm" id="idm46304992803224"/>think of it in terms of <em>bounds</em>: we told TypeScript that <code>n</code>’s <em>upper bound</em> is <code>number</code>, so any value we pass to <code>squareOf</code> has to be at most a <code>number</code>. If it’s anything more than a <code>number</code> (like, if it’s a value that might be a <code>number</code> or might be a <code>string</code>), then it’s not assignable to <code>n</code>.</p>&#13;
&#13;
<p>I’ll define assignability, bounds, and constraints more formally in <a data-type="xref" href="ch06.html#advanced-types">Chapter 6</a>. For now, all you need to know is this is the language that we use to talk about whether or not a type can be used in a place where we require a certain type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The ABCs of Types" data-type="sect1"><div class="sect1" id="idm46304992941224">&#13;
<h1>The ABCs of Types</h1>&#13;
&#13;
<p>Let’s take a tour of the types TypeScript supports, what values they contain, and what you can do with them.<a data-primary="types" data-secondary="supported by TypeScript" data-type="indexterm" id="ix_typeTS"/> We’ll also cover a few basic language features for working with types: type aliases, union types, and intersection types.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="any" data-type="sect2"><div class="sect2" id="idm46304992793208">&#13;
<h2>any</h2>&#13;
&#13;
<p><code>any</code> is the Godfather of types.<a data-primary="any type" data-type="indexterm" id="idm46304992791384"/><a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="any" data-type="indexterm" id="idm46304992790680"/> It does anything for a price, but you don’t want to ask <code>any</code> for a favor unless you’re completely out of options. In TypeScript everything needs to have a type at compile time, and <code>any</code> is the default type when you (the programmer) and TypeScript (the typechecker) can’t figure out what type something is. It’s a last resort type, and you should avoid it when possible.</p>&#13;
&#13;
<p>Why should you avoid it? Remember what a type is? (It’s a set of values and the things you can do with them.) <code>any</code> is the set of <em>all</em> values, and you can do <em>anything</em> with <code>any</code>. That means that if you have a value of type <code>any</code> you can add to it, multiply by it, call <code>.pizza()</code> on it—anything.</p>&#13;
&#13;
<p><code>any</code> makes your value behave like it would in regular JavaScript, and totally prevents the typechecker from working its magic. When you allow <code>any</code> into your code you’re flying blind. Avoid <code>any</code> like fire, and use it only as a very, very last resort.</p>&#13;
&#13;
<p>On the rare occasion that you do need to use it, you do it like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code>: <code class="kt">any</code> <code class="o">=</code> <code class="mi">666</code>            <code class="c1">// any</code>&#13;
<code class="kd">let</code> <code class="nx">b</code>: <code class="kt">any</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'danger'</code><code class="p">]</code>     <code class="c1">// any</code>&#13;
<code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code>               <code class="c1">// any</code></pre>&#13;
&#13;
<p>Notice how the third type should report an error (why are you trying to add a number and an array?), but doesn’t because you told TypeScript that you’re adding two <code>any</code>s. If you want to use <code>any</code>, you have to be explicit about it. When TypeScript infers that some value is of type <code>any</code> (for example, if you forgot to annotate a function’s parameter, or if you imported an untyped JavaScript module), it will throw a compile-time exception and toss a red squiggly at you in your editor. By explicitly annotating <code>a</code> and <code>b</code> with the <code>any</code> type (<code>: any</code>), you avoid the exception—it’s your way of telling TypeScript that you know what you’re doing.</p>&#13;
<div data-type="tip"><h1>TSC Flag: noImplicitAny</h1>&#13;
<p>By default, TypeScript is permissive, and won’t complain about values that it infers as <code>any</code>. To get TypeScript to<a data-primary="noImplicitAny flag in tsconfig.json" data-type="indexterm" id="idm46304992753416"/><a data-primary="tsconfig.json" data-secondary="enabling noImplicitAny flag" data-type="indexterm" id="idm46304992752712"/> complain about implicit <code>any</code>s, be sure to enable the <code>noImplicitAny</code> flag in your <em>tsconfig.json</em>.</p>&#13;
&#13;
<p><code>noImplicitAny</code> is part of the <code>strict</code> family of TSC flags, so if you already enabled <code>strict</code> in your <em>tsconfig.json</em> (as we did in <a data-type="xref" href="ch02.html#tsconfig.json">“tsconfig.json”</a>), you’re good to go.<a data-primary="strict flags in TSC" data-type="indexterm" id="idm46304992747320"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="unknown" data-type="sect2"><div class="sect2" id="idm46304992746488">&#13;
<h2>unknown</h2>&#13;
&#13;
<p>If <code>any</code> is the Godfather, then <code>unknown</code> is Keanu Reeves as undercover FBI agent Johnny Utah in <em>Point Break</em>: laid back, fits right in with the bad guys,<a data-primary="unknown type" data-type="indexterm" id="idm46304992743448"/><a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="unknown" data-type="indexterm" id="idm46304992742744"/> but deep down has a respect for the law and is on the side of the good guys. For the few cases where you have a value whose type you really don’t know ahead of time, don’t use <code>any</code>, and instead reach for <code>unknown</code>. Like <code>any</code>, it represents any value, but TypeScript won’t let you use an <code>unknown</code> type until you refine it by checking what it is (see <a data-type="xref" href="ch06.html#refinement">“Refinement”</a>).</p>&#13;
&#13;
<p>What operations does <code>unknown</code> support? You can compare <code>unknown</code> values (with <code>==</code>, <code>===</code>, <code>||</code>, <code>&amp;&amp;</code>, and <code>?</code>), negate them (with <code>!</code>), and refine them (like you can any other type) with JavaScript’s <code>typeof</code> and <code>instanceof</code> operators.<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2571" data-type="indexterm" id="idm46304992733624"/> Use <code>unknown</code> like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code>: <code class="kt">unknown</code> <code class="o">=</code> <code class="mi">30</code>         <code class="c1">// unknown</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">===</code> <code class="mi">123</code>           <code class="c1">// boolean</code>&#13;
<code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">+</code> <code class="mi">10</code>              <code class="c1">// Error TS2571: Object is of type 'unknown'.</code>&#13;
<code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">a</code> <code class="o">===</code> <code class="s1">'number'</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">+</code> <code class="mi">10</code>            <code class="c1">// number</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">This example should give you a rough idea of how to use <code>unknown</code>:</p>&#13;
<ol>&#13;
<li>&#13;
<p>TypeScript will never infer something as <code>unknown</code>—you have to explicitly annotate it (<code>a</code>).<sup><a data-type="noteref" href="ch03.html#idm46304992666696" id="idm46304992666696-marker">1</a></sup></p>&#13;
</li>&#13;
<li>&#13;
<p>You can compare values to values that are of type <code>unknown</code> (<code>b</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>But, you can’t do things that assume an <code>unknown</code> value is of a specific type (<code>c</code>); you have to prove to TypeScript that the value really is of that type first (<code>d</code>).</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="boolean" data-type="sect2"><div class="sect2" id="idm46304992660120">&#13;
<h2>boolean</h2>&#13;
&#13;
<p>The <code>boolean</code> type has two values: <code>true</code> and <code>false</code>.<a data-primary="true and false values (boolean type)" data-type="indexterm" id="idm46304992656632"/><a data-primary="boolean type" data-type="indexterm" id="idm46304992655928"/><a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="boolean" data-type="indexterm" id="idm46304992655256"/> You can compare them (with <code>==</code>, <code>===</code>, <code>||</code>, <code>&amp;&amp;</code>, and <code>?</code>), negate them (with <code>!</code>), and not much else. Use <code>boolean</code> like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="kc">true</code>                <code class="c1">// boolean</code>&#13;
<code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="kc">false</code>               <code class="c1">// boolean</code>&#13;
<code class="kr">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kc">true</code>              <code class="c1">// true</code>&#13;
<code class="kd">let</code> <code class="nx">d</code>: <code class="kt">boolean</code> <code class="o">=</code> <code class="kc">true</code>       <code class="c1">// boolean</code>&#13;
<code class="kd">let</code> <code class="nx">e</code>: <code class="kt">true</code> <code class="o">=</code> <code class="kc">true</code>          <code class="c1">// true</code>&#13;
<code class="kd">let</code> <code class="nx">f</code>: <code class="kt">true</code> <code class="o">=</code> <code class="kc">false</code>         <code class="c1">// Error TS2322: Type 'false' is not assignable</code>&#13;
                            <code class="c1">// to type 'true'.</code></pre>&#13;
&#13;
<p>This example shows a few <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2322" data-type="indexterm" id="idm46304992650056"/>ways to tell TypeScript that something is a <code>boolean</code>:</p>&#13;
<ol>&#13;
<li>&#13;
<p>You can let TypeScript infer that your value is a <code>boolean</code> (<code>a</code> and <code>b</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>You can let TypeScript infer that your value is a specific <code>boolean</code> (<code>c</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>You can tell TypeScript explicitly that your value is a <code>boolean</code> (<code>d</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>You can tell TypeScript explicitly that your value is a specific <code>boolean</code> (<code>e</code> and <code>f</code>).</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>In general, you will use the first or second way in your programs. Very rarely, you’ll use the fourth way—only when it buys you extra type safety (I’ll show you examples of that throughout this book). You will almost never use the third way.</p>&#13;
&#13;
<p>The second and fourth cases are particularly interesting because while they do something intuitive, they’re supported by surprisingly few programming languages and so might be new to you. What I did in that example was say, “Hey TypeScript! See this variable <code>e</code> here? <code>e</code> isn’t just any old <code>boolean</code>—it’s the specific <code>boolean</code> <code>true</code>.” By using a value as a type, I essentially limited the possible values for <code>e</code> and <code>f</code> from all <code>booleans</code> to one specific <code>boolean</code> each. <a data-primary="type literals" data-type="indexterm" id="idm46304992550360"/>This feature is called <em>type literals</em>.</p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304992555016">&#13;
<h5>Type literal</h5>&#13;
<p>A type that represents a single value and nothing else.</p>&#13;
</div></aside>&#13;
&#13;
<p>In the fourth case I explicitly annotated my variables with type literals, and in the second case TypeScript inferred a literal type for me because I used <code>const</code> instead of <code>let</code> or <code>var</code>.<a data-primary="const values" data-type="indexterm" id="idm46304992545432"/><a data-primary="let" data-secondary="using const instead of" data-type="indexterm" id="idm46304992544696"/><a data-primary="var" data-secondary="using const instead of" data-type="indexterm" id="idm46304992543752"/> Because TypeScript knows that once a primitive is assigned with <code>const</code> its value will never change, it infers the most narrow type it can for that variable. That’s why in the second case TypeScript inferred <code>c</code>’s type as <code>true</code> instead of as <code>boolean</code>. To learn more about why TypeScript infers different types for <code>let</code> and <code>const</code>, jump ahead to <a data-type="xref" href="ch06.html#type-widening">“Type Widening”</a>.</p>&#13;
&#13;
<p>We will revisit type literals throughout this book. They are a powerful language feature that lets you squeeze out extra safety all over the place. Type literals make TypeScript unique in the language world and are something you should lord over your Java friends.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="number" data-type="sect2"><div class="sect2" id="idm46304992659464">&#13;
<h2>number</h2>&#13;
&#13;
<p><code>number</code> is the set of all numbers: integers, floats, positives, negatives, <code>Infinity</code>, <code>NaN</code>, and so on. <a data-primary="number type" data-type="indexterm" id="idm46304992535608"/><a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="number" data-type="indexterm" id="idm46304992534872"/>Numbers can do, well, numbery things, like addition (<code>+</code>), subtraction (<code>-</code>), modulo (<code>%</code>), and comparison (<code>&lt;</code>). Let’s look at a few examples:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1234</code>                <code class="c1">// number</code>&#13;
<code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="kc">Infinity</code> <code class="o">*</code> <code class="mf">0.10</code>     <code class="c1">// number</code>&#13;
<code class="kr">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="mi">5678</code>              <code class="c1">// 5678</code>&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">&lt;</code> <code class="nx">b</code>               <code class="c1">// boolean</code>&#13;
<code class="kd">let</code> <code class="nx">e</code>: <code class="kt">number</code> <code class="o">=</code> <code class="mi">100</code>         <code class="c1">// number</code>&#13;
<code class="kd">let</code> <code class="nx">f</code>: <code class="kt">26.218</code> <code class="o">=</code> <code class="mf">26.218</code>      <code class="c1">// 26.218</code>&#13;
<code class="kd">let</code> <code class="nx">g</code>: <code class="kt">26.218</code> <code class="o">=</code> <code class="mi">10</code>          <code class="c1">// Error TS2322: Type '10' is not assignable</code>&#13;
                            <code class="c1">// to type '26.218'.</code></pre>&#13;
&#13;
<p>Like in the <code>boolean</code> example, there are four ways to type something as a <code>number</code>:</p>&#13;
<ol>&#13;
<li>&#13;
<p>You can let TypeScript infer that your value is a <code>number</code> (<code>a</code> and <code>b</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>You can use <code>const</code> so TypeScript infers that your value is a specific <code>number</code> (<code>c</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>You can tell TypeScript explicitly that your value is a <code>number</code> (<code>e</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>You can tell TypeScript explicitly that your value is a specific <code>number</code> (<code>f</code> and <code>g</code>).</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>And just like with <code>booleans</code>, you’re usually going to let TypeScript infer the type for you (the first way). Once in a while you’ll do some clever programming that requires your number’s type to be restricted to a specific value (the second or fourth way). There is no good reason to explicitly type something as a <code>number</code> (the third way).</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>When working with long numbers, use numeric separators to make those numbers easier to read.<a data-primary="numbers, numeric separators in" data-type="indexterm" id="idm46304992453976"/> You can use numeric separators in both type and value positions:</p>&#13;
<pre data-type="programlisting"><code class="kd">let</code> <code class="nx">oneMillion</code> <code class="o">=</code> <code class="nx">1_000_000</code> <code class="c1">// Equivalent to 1000000</code>&#13;
<code class="kd">let</code> <code class="nx">twoMillion</code>: <code class="kt">2_000_000</code> <code class="o">=</code> <code class="nx">2_000_000</code></pre>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="bigint" data-type="sect2"><div class="sect2" id="idm46304992445272">&#13;
<h2>bigint</h2>&#13;
&#13;
<p><code>bigint</code> is a newcomer to JavaScript and TypeScript: it lets you work with large integers without running into rounding errors.<a data-primary="bigint type" data-type="indexterm" id="idm46304992443064"/><a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="bigint" data-type="indexterm" id="idm46304992442360"/> While the <code>number</code> type can only represent whole numbers up to 2<sup>53</sup>, <code>bigint</code> can represent integers bigger than that too. <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS1353" data-type="indexterm" id="idm46304992439608"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2322" data-type="indexterm" id="idm46304992438360"/>The <code>bigint</code> type is the set of all BigInts, and supports things like addition (<code>+</code>), subtraction (<code>-</code>), multiplication (*), division (<code>/</code>), and comparison (<code>&lt;</code>). Use it like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1234</code><code class="nx">n</code>               <code class="c1">// bigint</code>&#13;
<code class="kr">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">5678</code><code class="nx">n</code>             <code class="c1">// 5678n</code>&#13;
<code class="kd">var</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code>               <code class="c1">// bigint</code>&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">&lt;</code> <code class="mi">1235</code>            <code class="c1">// boolean</code>&#13;
<code class="kd">let</code> <code class="nx">e</code> <code class="o">=</code> <code class="mf">88.5</code><code class="nx">n</code>               <code class="c1">// Error TS1353: A bigint literal must be an integer.</code>&#13;
<code class="kd">let</code> <code class="nx">f</code>: <code class="kt">bigint</code> <code class="o">=</code> <code class="mi">100</code><code class="nx">n</code>        <code class="c1">// bigint</code>&#13;
<code class="kd">let</code> <code class="nx">g</code>: <code class="kt">100n</code> <code class="o">=</code> <code class="mi">100</code><code class="nx">n</code>          <code class="c1">// 100n</code>&#13;
<code class="kd">let</code> <code class="nx">h</code>: <code class="kt">bigint</code> <code class="o">=</code> <code class="mi">100</code>         <code class="c1">// Error TS2322: Type '100' is not assignable</code>&#13;
                            <code class="c1">// to type 'bigint'.</code></pre>&#13;
&#13;
<p>Like with <code>boolean</code> and <code>number</code>, there are four ways to declare bigints. Try to let TypeScript infer your bigint’s type when you can.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>At the time of writing, <code>bigint</code> is not yet natively supported by every JavaScript engine. If your application relies on <code>bigint</code>, be careful to check whether or not it’s supported by your target platform.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="string" data-type="sect2"><div class="sect2" id="idm46304992338232">&#13;
<h2>string</h2>&#13;
&#13;
<p><code>string</code> is the set of all strings and the things you can do with them like concatenate (<code>+</code>), slice (<code>.slice</code>), and so on.<a data-primary="string type" data-type="indexterm" id="idm46304992335752"/><a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="string" data-type="indexterm" id="idm46304992335016"/> Let’s see some examples:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="s1">'hello'</code>             <code class="c1">// string</code>&#13;
<code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="s1">'billy'</code>             <code class="c1">// string</code>&#13;
<code class="kr">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="s1">'!'</code>               <code class="c1">// '!'</code>&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">+</code> <code class="s1">' '</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code>     <code class="c1">// string</code>&#13;
<code class="kd">let</code> <code class="nx">e</code>: <code class="kt">string</code> <code class="o">=</code> <code class="s1">'zoom'</code>      <code class="c1">// string</code>&#13;
<code class="kd">let</code> <code class="nx">f</code><code class="o">:</code> <code class="s1">'john'</code> <code class="o">=</code> <code class="s1">'john'</code>      <code class="c1">// 'john'</code>&#13;
<code class="kd">let</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'john'</code> <code class="o">=</code> <code class="s1">'zoe'</code>       <code class="c1">// Error TS2322: Type "zoe" is not assignable</code>&#13;
                            <code class="c1">// to type "john".</code></pre>&#13;
&#13;
<p>Like <code>boolean</code> and <code>number</code>, there are four ways to declare <code>string</code> types, and you should let TypeScript<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2322" data-type="indexterm" id="idm46304992250856"/> infer the type for you whenever you can.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="symbol" data-type="sect2"><div class="sect2" id="idm46304992249160">&#13;
<h2>symbol</h2>&#13;
&#13;
<p><code>symbol</code> is a relatively new language feature that arrived with one of the latest major JavaScript revisions (ES2015). <a data-primary="symbol type" data-type="indexterm" id="idm46304992246984"/><a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="symbol" data-type="indexterm" id="idm46304992246280"/>Symbols don’t come up often in practice; they are used as an alternative to string keys in objects and maps, in places where you want to be extra sure that people are using the right well-known key and didn’t accidentally set the key—think setting a default iterator for your object (<code>Symbol.iterator</code>), or overriding at runtime whether or not your object is an instance of something (<code>Symbol.hasInstance</code>). Symbols have the type <code>symbol</code>, and there isn’t all that much you can do with them:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'a'</code><code class="p">)</code>         <code class="c1">// symbol</code>&#13;
<code class="kd">let</code> <code class="nx">b</code>: <code class="kt">symbol</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'b'</code><code class="p">)</code> <code class="c1">// symbol</code>&#13;
<code class="kd">var</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">===</code> <code class="nx">b</code>             <code class="c1">// boolean</code>&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">+</code> <code class="s1">'x'</code>             <code class="c1">// Error TS2469: The '+' operator cannot be applied</code>&#13;
                            <code class="c1">// to type 'symbol'.</code></pre>&#13;
&#13;
<p>The way <code>Symbol('a')</code> works in JavaScript<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2469" data-type="indexterm" id="idm46304992162904"/> is by creating a new <code>symbol</code> with the given name; that <code>symbol</code> is unique, and will not be equal (when compared with <code>==</code> or <code>===</code>) to any other <code>symbol</code> (even if you create a second <code>symbol</code> with the same exact name!). Similarly to how the value <code>27</code> is inferred to be a <code>number</code> when declared with <code>let</code> but the specific number <code>27</code> when you declare it with <code>const</code>, symbols are inferred to be of type <code>symbol</code> but can be <a data-primary="const" data-secondary="declaring symbols with" data-type="indexterm" id="idm46304992156376"/><a data-primary="unique symbols" data-type="indexterm" id="idm46304992155368"/><a data-primary="symbol type" data-secondary="example usages for unique symbol" data-type="indexterm" id="idm46304992154696"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS1332" data-type="indexterm" id="idm46304992153688"/>explicitly typed as <code>unique symbol</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">const</code> <code class="nx">e</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'e'</code><code class="p">)</code>                <code class="c1">// typeof e</code>&#13;
<code class="kr">const</code> <code class="nx">f</code>: <code class="kt">unique</code> <code class="nx">symbol</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'f'</code><code class="p">)</code> <code class="c1">// typeof f</code>&#13;
<code class="kd">let</code> <code class="nx">g</code>: <code class="kt">unique</code> <code class="nx">symbol</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'f'</code><code class="p">)</code>   <code class="c1">// Error TS1332: A variable whose type is a</code>&#13;
                                     <code class="c1">// 'unique symbol' type must be 'const'.</code>&#13;
<code class="kd">let</code> <code class="nx">h</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">===</code> <code class="nx">e</code>             <code class="c1">// boolean</code>&#13;
<code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">===</code> <code class="nx">f</code>             <code class="c1">// Error TS2367: This condition will always return</code>&#13;
                            <code class="c1">// 'false' since the types 'unique symbol' and</code>&#13;
                            <code class="c1">// 'unique symbol' have no overlap.</code></pre>&#13;
&#13;
<p>This example shows<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2367" data-type="indexterm" id="idm46304992150696"/> off a few ways to create unique symbols:</p>&#13;
<ol>&#13;
<li>&#13;
<p>When you declare a new <code>symbol</code> and assign it to a <code>const</code> variable (not a <code>let</code> or <code>var</code> variable), TypeScript will infer its type as <code>unique symbol</code>. It will show up as <code>typeof</code> <em>yourVariableName</em>, not <code>unique symbol</code>, in your code editor.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can explicitly annotate a <code>const</code> variable’s type as <code>unique symbol</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <code>unique symbol</code> is always equal to itself.</p>&#13;
</li>&#13;
<li>&#13;
<p>TypeScript knows at compile time that a <code>unique symbol</code> will never be equal to any other <code>unique symbol</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Think of <code>unique symbols</code> like other literal types, like <code>1</code>, <code>true</code>, or <code>"literal"</code>. They’re a way to create a type that represents a particular inhabitant of <code>symbol</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Objects" data-type="sect2"><div class="sect2" id="object-type">&#13;
<h2>Objects</h2>&#13;
&#13;
<p>TypeScript’s object types specify the shapes of objects.<a data-primary="objects" data-type="indexterm" id="ix_objs"/><a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="objects" data-type="indexterm" id="ix_typTSobj"/> Notably, they can’t tell the difference between simple objects (like the kind you make with <code>{}</code>) and more complicated ones (the kind you create with <code>new Blah</code>). <a data-primary="structural typing" data-type="indexterm" id="idm46304992065368"/><a data-primary="nominal typing" data-type="indexterm" id="idm46304992064632"/>This is by design: JavaScript is generally <em>structurally typed</em>, so TypeScript favors that style of programming over a <em>nominally typed</em> style.</p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304992062968">&#13;
<h5>Structural typing</h5>&#13;
<p>A style of programming where you just care that an object has certain properties, and not what its name is (nominal typing).<a data-primary="duck typing" data-seealso="structural typing" data-type="indexterm" id="idm46304992061192"/> Also called <em>duck typing</em> in some languages (or, not judging a book by its cover).</p>&#13;
</div></aside>&#13;
&#13;
<p>There are a few ways to use types to describe objects in TypeScript. The first is to declare a value as an <code>object</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code>: <code class="kt">object</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">b</code><code class="o">:</code> <code class="s1">'x'</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What happens when you access <code>b</code>?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">a</code><code class="p">.</code><code class="nx">b</code>   <code class="c1">// Error TS2339: Property 'b' does not exist on type 'object'.</code></pre>&#13;
&#13;
<p>Wait, that’s not very useful! What’s the point of typing something as an <code>object</code> if you can’t do anything with it?<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2339" data-type="indexterm" id="idm46304992051320"/></p>&#13;
&#13;
<p>Why, that’s a great point, aspiring TypeScripter! In fact, <code>object</code> is a little narrower than <code>any</code>, but not by much. <code>object</code> doesn’t tell you a lot about the value it describes, just that the value is a JavaScript object (and that it’s not <code>null</code>).<a data-primary="any type" data-secondary="object versus" data-type="indexterm" id="idm46304992047944"/></p>&#13;
&#13;
<p>What if we leave off the explicit annotation, and let TypeScript do its thing?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">b</code><code class="o">:</code> <code class="s1">'x'</code>&#13;
<code class="p">}</code>            <code class="c1">// {b: string}</code>&#13;
<code class="nx">a</code><code class="p">.</code><code class="nx">b</code>          <code class="c1">// string</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">c</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">d</code><code class="o">:</code> <code class="s1">'f'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>            <code class="c1">// {c: {d: string}}</code></pre>&#13;
&#13;
<p class="pagebreak-before">Voilà! You’ve just discovered the second way to type an object: object literal syntax (not to be confused with type literals).<a data-primary="object literals" data-type="indexterm" id="idm46304991923656"/><a data-primary="{} (curly braces), defining object literal types with" data-type="indexterm" id="idm46304991923048"/><a data-primary="const" data-secondary="declaring objects with" data-type="indexterm" id="idm46304991922312"/> You can either let TypeScript infer your object’s shape for you, or explicitly describe it inside curly braces(<code>{}</code>):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code><code class="o">:</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">b</code>: <code class="kt">12</code>&#13;
<code class="p">}</code>            <code class="c1">// {b: number}</code></pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304991904264">&#13;
<h5>Type Inference When Declaring Objects with const</h5>&#13;
<p>What would have happened if we’d used <code>const</code> to declare the object instead?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">const</code> <code class="nx">a</code><code class="o">:</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">b</code>: <code class="kt">12</code>&#13;
<code class="p">}</code>            <code class="c1">// Still {b: number}</code></pre>&#13;
&#13;
<p>You might be surprised that TypeScript inferred <code>b</code> as a <code>number</code>, and not as the literal <code>12</code>. After all, we learned that when declaring <code>number</code>s or <code>string</code>s, our choice of <code>const</code> or <code>let</code> affects how TypeScript infers our types.</p>&#13;
&#13;
<p>Unlike the primitive types we’ve looked at so far—<code>boolean</code>, <code>number</code>, <code>bigint</code>, <code>string</code>, and <code>symbol</code>—declaring an object with <code>const</code> won’t hint to TypeScript to infer its type more narrowly. That’s because JavaScript objects are mutable, and for all TypeScript knows you might update their fields after you create them.</p>&#13;
&#13;
<p>We explore this idea more deeply—including how to opt into narrower inference—in <a data-type="xref" href="ch06.html#type-widening">“Type Widening”</a>.</p>&#13;
</div></aside>&#13;
&#13;
<p>Object literal syntax says, “Here is a thing that has this shape.” The thing might be an object literal, or it might be a class:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">let</code> <code class="nx">c</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">firstName</code>: <code class="kt">string</code>&#13;
  <code class="nx">lastName</code>: <code class="kt">string</code>&#13;
<code class="p">}</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">firstName</code><code class="o">:</code> <code class="s1">'john'</code><code class="p">,</code>&#13;
  <code class="nx">lastName</code><code class="o">:</code> <code class="s1">'barrowman'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code>&#13;
    <code class="kr">public</code> <code class="nx">firstName</code>: <code class="kt">string</code><code class="p">,</code>   <code class="c1">// public is shorthand for</code>&#13;
                                <code class="c1">// this.firstName = firstName</code>&#13;
    <code class="kr">public</code> <code class="nx">lastName</code>: <code class="kt">string</code>&#13;
  <code class="p">)</code> <code class="p">{}</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">c</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s1">'matt'</code><code class="p">,</code> <code class="s1">'smith'</code><code class="p">)</code> <code class="c1">// OK</code>&#13;
</pre>&#13;
&#13;
<p><code>{firstName: string, lastName: string}</code> describes <a data-primary="objects" data-secondary="shape of" data-type="indexterm" id="idm46304991788920"/>the <em>shape</em> of an object, and both the object literal and the class instance from the last example satisfy that shape, so TypeScript lets us assign a <code>Person</code> to <code>c</code>.</p>&#13;
&#13;
<p>Let’s explore what happens when <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2322" data-type="indexterm" id="idm46304991764392"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2741" data-type="indexterm" id="idm46304991763144"/>we add extra properties, or leave out required ones:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code><code class="o">:</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">number</code><code class="p">}</code>&#13;
&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{}</code>  <code class="c1">// Error TS2741: Property 'b' is missing in type '{}'</code>&#13;
        <code class="c1">// but required in type '{b: number}'.</code>&#13;
&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">b</code>: <code class="kt">1</code><code class="p">,</code>&#13;
  <code class="nx">c</code>: <code class="kt">2</code>  <code class="c1">// Error TS2322: Type '{b: number; c: number}' is not assignable</code>&#13;
<code class="p">}</code>       <code class="c1">// to type '{b: number}'. Object literal may only specify known</code>&#13;
        <code class="c1">// properties, and 'c' does not exist in type '{b: number}'.</code></pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304991760920">&#13;
<h5>Definite Assignment</h5>&#13;
<p>This is the first example we’ve looked at where we first declare a variable (<code>a</code>), then initialize it with values (<code>{}</code> and <code>{b: 1, c: 2}</code>).<a data-primary="variables" data-secondary="declaring, then initializing with values" data-type="indexterm" id="idm46304991701304"/> This is a common JavaScript pattern, and it’s supported by TypeScript too.</p>&#13;
&#13;
<p>When you declare a variable in one place and initialize it later, TypeScript will make sure that your variable is <em>definitely assigned</em> a value by the time you use it:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">i</code>: <code class="kt">number</code>&#13;
<code class="kd">let</code> <code class="nx">j</code> <code class="o">=</code> <code class="nx">i</code> <code class="o">*</code> <code class="mi">3</code>  <code class="c1">// Error TS2454: Variable 'i' is used</code>&#13;
               <code class="c1">// before being assigned.</code></pre>&#13;
&#13;
<p>And don’t worry, TypeScript enforces this for you even if you leave off the explicit type <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2532" data-type="indexterm" id="idm46304991692552"/>annotation:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">i</code>&#13;
<code class="kd">let</code> <code class="nx">j</code> <code class="o">=</code> <code class="nx">i</code> <code class="o">*</code> <code class="mi">3</code>  <code class="c1">// Error TS2532: Object is possibly</code>&#13;
               <code class="c1">// 'undefined'.</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>By default, TypeScript is pretty strict about object properties—if you say the object should have a property <a data-primary="objects" data-secondary="properties of" data-type="indexterm" id="idm46304991639752"/>called <code>b</code> that’s a <code>number</code>, TypeScript expects <code>b</code> and only <code>b</code>. If <code>b</code> is missing, or if there are extra properties, TypeScript will complain.</p>&#13;
&#13;
<p>Can you tell TypeScript that something is optional, or that there might be more properties <a data-primary="? (question mark)" data-secondary="for optional properties in objects" data-type="indexterm" id="idm46304991636200"/>than you planned for? You bet:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code><code> </code><code class="nx">a</code><code class="o">:</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">b</code><code>: </code><code class="kt">number</code><code> </code><a class="co" href="#callout_all_about_types_CO1-1" id="co_all_about_types_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">c?</code><code>: </code><code class="kt">string</code><code> </code><a class="co" href="#callout_all_about_types_CO1-2" id="co_all_about_types_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="p">[</code><code class="nx">key</code><code>: </code><code class="kt">number</code><code class="p">]</code><code class="o">:</code><code> </code><code class="kr">boolean</code><code> </code><a class="co" href="#callout_all_about_types_CO1-3" id="co_all_about_types_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_all_about_types_CO1-1" id="callout_all_about_types_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>a</code> has a property <code>b</code> that’s a <code>number</code>.</p></dd>&#13;
<dt><a class="co" href="#co_all_about_types_CO1-2" id="callout_all_about_types_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><code>a</code> might have a property <code>c</code> that’s a <code>string</code>. And if <code>c</code> is set, it might be <code>undefined</code>.</p></dd>&#13;
<dt><a class="co" href="#co_all_about_types_CO1-3" id="callout_all_about_types_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>a</code> might have any number of numeric properties that are <code>booleans</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Let’s see what types of<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2741" data-type="indexterm" id="idm46304991532888"/> objects we can assign to <code>a</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">a</code> <code class="o">=</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">1</code><code class="p">}</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">1</code><code class="p">,</code> <code class="nx">c</code>: <code class="kt">undefined</code><code class="p">}</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">1</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="s1">'d'</code><code class="p">}</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">1</code><code class="p">,</code> <code class="nx">10</code>: <code class="kt">true</code><code class="p">}</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">1</code><code class="p">,</code> <code class="nx">10</code>: <code class="kt">true</code><code class="p">,</code> <code class="nx">20</code>: <code class="kt">false</code><code class="p">}</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{</code><code class="nx">10</code>: <code class="kt">true</code><code class="p">}</code>          <code class="c1">// Error TS2741: Property 'b' is missing in type</code>&#13;
                        <code class="c1">// '{10: true}'.</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">1</code><code class="p">,</code> <code class="mi">33</code><code class="o">:</code> <code class="s1">'red'</code><code class="p">}</code>   <code class="c1">// Error TS2741: Type 'string' is not assignable</code>&#13;
                        <code class="c1">// to type 'boolean'.</code></pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304991530024">&#13;
<h5>Index Signatures</h5>&#13;
<p>The <code>[key: T]: U</code> syntax is called an <em>index signature</em>, and this is the way you tell TypeScript that the given object might contain more keys.<a data-primary="[] (square brackets)" data-secondary="index signature syntax" data-type="indexterm" id="idm46304991461960"/><a data-primary="index signatures" data-type="indexterm" id="idm46304991460984"/><a data-primary="objects" data-secondary="index signature" data-type="indexterm" id="idm46304991460312"/> The way to read it is, “For this object, all keys of type <code>T</code> must have values of type <code>U</code>.” Index signatures let you safely add more keys to an object, in addition to any keys that you explicitly declared.</p>&#13;
&#13;
<p>There is one rule to keep in mind for index signatures: the index signature key’s type (<code>T</code>) must be assignable to either <code>number</code> or <code>string</code>.<sup><a data-type="noteref" href="ch03.html#idm46304991456584" id="idm46304991456584-marker">2</a></sup></p>&#13;
&#13;
<p>Also note that you can use any word for the index signature key’s name—it doesn’t have to be <code>key</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">airplaneSeatingAssignments</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">seatNumber</code>: <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code>&#13;
<code class="p">}</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="s1">'34D'</code><code class="o">:</code> <code class="s1">'Boris Cherny'</code><code class="p">,</code>&#13;
  <code class="s1">'34E'</code><code class="o">:</code> <code class="s1">'Bill Gates'</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Optional (<code>?</code>) isn’t the only modifier you can use when declaring object types. You can also mark fields as read-only (that is, you can declare that a field can’t be modified after it’s assigned an initial value—kind of like <code>const</code> for object properties) with <a data-primary="readonly modifier" data-type="indexterm" id="idm46304991429384"/>the <code>readonly</code> modifier:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">user</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">readonly</code> <code class="nx">firstName</code>: <code class="kt">string</code>&#13;
<code class="p">}</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">firstName</code><code class="o">:</code> <code class="s1">'abby'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">user</code><code class="p">.</code><code class="nx">firstName</code> <code class="c1">// string</code>&#13;
<code class="nx">user</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code>&#13;
  <code class="s1">'abbey with an e'</code> <code class="c1">// Error TS2540: Cannot assign to 'firstName' because it</code>&#13;
                    <code class="c1">// is a read-only property.</code></pre>&#13;
&#13;
<p>Object literal<a data-primary="objects" data-secondary="empty" data-type="indexterm" id="idm46304991426888"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2540" data-type="indexterm" id="idm46304991338536"/> notation has one special case: empty object types (<code>{}</code>). Every type—except <code>null</code> and <code>undefined</code>—is assignable to an empty object type, which can make it tricky to use. Try to avoid empty object types when possible:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">danger</code><code class="o">:</code> <code class="p">{}</code>&#13;
<code class="nx">danger</code> <code class="o">=</code> <code class="p">{}</code>&#13;
<code class="nx">danger</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="kt">1</code><code class="p">}</code>&#13;
<code class="nx">danger</code> <code class="o">=</code> <code class="p">[]</code>&#13;
<code class="nx">danger</code> <code class="o">=</code> <code class="mi">2</code></pre>&#13;
&#13;
<p>As a final note on objects, it’s worth mentioning one last way of typing something as an object: <code>Object</code>. This is pretty much the same as using <code>{}</code>, and is best avoided. <sup><a data-type="noteref" href="ch03.html#idm46304991324152" id="idm46304991324152-marker">3</a></sup></p>&#13;
&#13;
<p>To summarize, there are four ways to declare <a data-primary="objects" data-secondary="declaring in TypeScript" data-type="indexterm" id="idm46304991274936"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2322" data-type="indexterm" id="idm46304991273960"/>objects in TypeScript:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Object literal notation (like <code>{a: string}</code>), also called a <em>shape</em>. Use this when you know which fields your object could have, or when all of your object’s values will have the same type.</p>&#13;
</li>&#13;
<li>&#13;
<p>Empty object literal notation (<code>{}</code>). Try to avoid this.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>object</code> type. Use this when you just want an object, and don’t care about which fields it has.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>Object</code> type. Try to avoid this.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>In your TypeScript programs, you should almost always stick to the first way and the third way. Be careful to avoid the second and fourth ways—use a linter to warn about them, complain about them in code reviews, print posters—use your team’s preferred tool to keep them far away from your codebase.</p>&#13;
&#13;
<p class="pagebreak-before"><a data-type="xref" href="#table-valid-obj">Table 3-1</a> is a handy reference for options 2–4 in the previous list.</p>&#13;
<table id="table-valid-obj">&#13;
<caption><span class="label">Table 3-1. </span>Is the value a valid object?</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Value</th>&#13;
<th><code>{}</code></th>&#13;
<th><code>object</code></th>&#13;
<th><code>Object</code></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>{}</code></p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>['a']</code></p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>function () {}</code></p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>new String('a')</code></p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>'a'</code></p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p><strong>No</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>1</code></p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p><strong>No</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Symbol('a')</code></p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p><strong>No</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>null</code></p></td>&#13;
<td><p><strong>No</strong></p></td>&#13;
<td><p><strong>No</strong></p></td>&#13;
<td><p><strong>No</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>undefined</code></p></td>&#13;
<td><p><strong>No</strong></p></td>&#13;
<td><p><strong>No</strong></p></td>&#13;
<td><p><strong>No</strong></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Intermission: Type Aliases, Unions, and Intersections" data-type="sect2"><div class="sect2" id="idm46304992070472">&#13;
<h2>Intermission: Type Aliases, Unions, and Intersections</h2>&#13;
&#13;
<p>You are quickly becoming a grizzled TypeScript programmer.<a data-primary="objects" data-startref="ix_objs" data-type="indexterm" id="idm46304991209960"/><a data-primary="types" data-secondary="supported by TypeScript" data-startref="ix_typTSobj" data-tertiary="objects" data-type="indexterm" id="idm46304991208984"/> You have seen several types and how they work, and are now familiar with the concepts of type systems, types, and safety. It’s time we go deeper.</p>&#13;
&#13;
<p>As you know, if you have a value, you can perform certain operations on it, depending on what its type permits. For example, you can use <code>+</code> to add two numbers, or <code>.toUpperCase</code> to uppercase a string.</p>&#13;
&#13;
<p>If you have a <em>type</em>, you can perform some operations on it too. I’m going to introduce a few type-level operations here—there are more to come later in the book, but these are so common that I want to introduce them as early as possible.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type aliases" data-type="sect3"><div class="sect3" id="idm46304991204568">&#13;
<h3>Type aliases</h3>&#13;
&#13;
<p>Just like you can use variable declarations (<code>let</code>, <code>const</code>, and <code>var</code>) to declare a variable that aliases a value, you can declare a type alias that points to a type.<a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="type aliases" data-type="indexterm" id="idm46304991201320"/><a data-primary="aliases (type)" data-see="type aliases" data-type="indexterm" id="idm46304991200072"/><a data-primary="type aliases" data-type="indexterm" id="idm46304991199128"/> It looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Age</code> <code class="o">=</code> <code class="kt">number</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code>: <code class="kt">string</code>&#13;
  <code class="nx">age</code>: <code class="kt">Age</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before"><code>Age</code> is but a <code>number</code>. It can also help make the definition of the <code>Person</code> shape easier to understand. Aliases are never inferred by TypeScript, so you have to type them explicitly:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">age</code>: <code class="kt">Age</code> <code class="o">=</code> <code class="mi">55</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">driver</code>: <code class="kt">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'James May'</code>&#13;
  <code class="nx">age</code>: <code class="kt">age</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because <code>Age</code> is just an alias for <code>number</code>, that means it’s also assignable to <code>number</code>, so we can rewrite this as:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">55</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">driver</code>: <code class="kt">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'James May'</code>&#13;
  <code class="nx">age</code>: <code class="kt">age</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Wherever you see a type alias used, you can substitute in the type it aliases without changing the meaning of your program.</p>&#13;
&#13;
<p>Like JavaScript <a data-primary="let" data-secondary="variable declarations with" data-type="indexterm" id="idm46304991136024"/><a data-primary="const" data-secondary="variable declarations with" data-type="indexterm" id="idm46304991135288"/><a data-primary="var" data-secondary="variable declarations with" data-type="indexterm" id="idm46304991134376"/>variable declarations (<code>let</code>, <code>const</code>, and <code>var</code>), you can’t declare a type twice:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Color</code> <code class="o">=</code> <code class="s1">'red'</code>&#13;
<code class="nx">type</code> <code class="nx">Color</code> <code class="o">=</code> <code class="s1">'blue'</code>  <code class="c1">// Error TS2300: Duplicate identifier 'Color'.</code></pre>&#13;
&#13;
<p>And like <code>let</code> and <code>const</code>, type aliases are block-scoped.<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2300" data-type="indexterm" id="idm46304991092248"/> Every block and every function has its own scope, and inner type alias declarations shadow outer ones:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Color</code> <code class="o">=</code> <code class="s1">'red'</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="p">.</code><code class="mi">5</code>&#13;
&#13;
<code class="k">if</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">type</code> <code class="nx">Color</code> <code class="o">=</code> <code class="s1">'blue'</code>  <code class="c1">// This shadows the Color declared above.</code>&#13;
  <code class="kd">let</code> <code class="nx">b</code>: <code class="kt">Color</code> <code class="o">=</code> <code class="s1">'blue'</code>&#13;
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">c</code>: <code class="kt">Color</code> <code class="o">=</code> <code class="s1">'red'</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Type aliases are useful for DRYing up repeated complex types,<sup><a data-type="noteref" href="ch03.html#idm46304991089496" id="idm46304991089496-marker">4</a></sup> and for making it clear what a variable is used for (some people prefer descriptive type names to descriptive variable names!).<a data-primary="Don't Repeat Yourself (DRY)" data-type="indexterm" id="idm46304982371848"/><a data-primary="DRY (Don't Repeat Yourself)" data-type="indexterm" id="idm46304982371240"/> When deciding whether or not to alias a type, use the same judgment as when deciding whether or not to pull a value out into its own <span class="keep-together">variable</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Union and intersection types" data-type="sect3"><div class="sect3" id="union-intersection">&#13;
<h3>Union and intersection types</h3>&#13;
&#13;
<p>If you have two things <code>A</code> and <code>B</code>, the <em>union</em> of those things is their sum (everything in <code>A</code> or <code>B</code> or both), and the <em>intersection</em> is what they have in common (everything in both <code>A</code> and <code>B</code>). <a data-primary="union types" data-type="indexterm" id="idm46304982363768"/><a data-primary="intersection types" data-type="indexterm" id="idm46304982363032"/>The easiest way to think about this is with sets.<a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="union and intersection types" data-type="indexterm" id="idm46304982362168"/> In <a data-type="xref" href="#ch03-union-intersection">Figure 3-2</a> I represent sets as circles. On the left is the union, or <em>sum</em>, of the two sets; on the right is their intersection, or <em>product</em>.</p>&#13;
&#13;
<figure><div class="figure" id="ch03-union-intersection">&#13;
<img alt="prts 0302" src="assets/prts_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>Union (|) and intersection (&amp;)</h6>&#13;
</div></figure>&#13;
&#13;
<p>TypeScript gives us special type operators to describe unions and intersections of types: <code>|</code> for union and <code>&amp;</code> for intersection.<a data-primary="| (pipe symbol), for union types" data-type="indexterm" id="idm46304982356184"/><a data-primary="&amp; (ampersand), for intersection types" data-type="indexterm" id="idm46304982355480"/> Since types are a lot like sets, we can think of them in the same way:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Cat</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">purrs</code>: <code class="kt">boolean</code><code class="p">}</code>&#13;
<code class="nx">type</code> <code class="nx">Dog</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">barks</code>: <code class="kt">boolean</code><code class="p">,</code> <code class="nx">wags</code>: <code class="kt">boolean</code><code class="p">}</code>&#13;
<code class="nx">type</code> <code class="nx">CatOrDogOrBoth</code> <code class="o">=</code> <code class="nx">Cat</code> <code class="o">|</code> <code class="nx">Dog</code>&#13;
<code class="nx">type</code> <code class="nx">CatAndDog</code> <code class="o">=</code> <code class="nx">Cat</code> <code class="o">&amp;</code> <code class="nx">Dog</code></pre>&#13;
&#13;
<p>If something is a <code>CatOrDogOrBoth</code>, what do you know about it? You know that it has a <code>name</code> property that’s a string, and not much else. On the flip side, what can you assign to a <code>CatOrDogOrBoth</code>? Well, a <code>Cat</code>, a <code>Dog</code>, or both:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="c1">// Cat</code>&#13;
<code class="kd">let</code> <code class="nx">a</code>: <code class="kt">CatOrDogOrBoth</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Bonkers'</code><code class="p">,</code>&#13;
  <code class="nx">purrs</code>: <code class="kt">true</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Dog</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Domino'</code><code class="p">,</code>&#13;
  <code class="nx">barks</code>: <code class="kt">true</code><code class="p">,</code>&#13;
  <code class="nx">wags</code>: <code class="kt">true</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Both</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Donkers'</code><code class="p">,</code>&#13;
  <code class="nx">barks</code>: <code class="kt">true</code><code class="p">,</code>&#13;
  <code class="nx">purrs</code>: <code class="kt">true</code><code class="p">,</code>&#13;
  <code class="nx">wags</code>: <code class="kt">true</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>This is worth reiterating: a value with a union type (<code>|</code>) isn’t necessarily one specific member of your union; in fact, it can be both members at once!<sup><a data-type="noteref" href="ch03.html#idm46304982252728" id="idm46304982252728-marker">5</a></sup></p>&#13;
&#13;
<p>On the other hand, what do you know about <code>CatAndDog</code>? Not only does your canine-feline hybrid super-pet have a <code>name</code>, but it can purr, bark, and wag:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">b</code>: <code class="kt">CatAndDog</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Domino'</code><code class="p">,</code>&#13;
  <code class="nx">barks</code>: <code class="kt">true</code><code class="p">,</code>&#13;
  <code class="nx">purrs</code>: <code class="kt">true</code><code class="p">,</code>&#13;
  <code class="nx">wags</code>: <code class="kt">true</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Unions come up naturally a lot more often than intersections do. Take this function, for example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">trueOrNull</code><code class="p">(</code><code class="nx">isTrue</code>: <code class="kt">boolean</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">isTrue</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="s1">'true'</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="kc">null</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What is the type of the value this function returns? Well, it might be a <code>string</code>, or it might be <code>null</code>. We can express its return type as:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Returns</code> <code class="o">=</code> <code class="kt">string</code> <code class="o">|</code> <code class="kc">null</code></pre>&#13;
&#13;
<p>How about this one?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code><code class="p">(</code><code class="nx">a</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">b</code>: <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">||</code> <code class="nx">b</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If <code>a</code> is truthy then the return type is <code>string</code>, and otherwise it’s <code>number</code>: in other words, <code>string | number</code>.</p>&#13;
&#13;
<p>The last place where unions come up naturally is in arrays (specifically the heterogeneous kind), which we’ll talk about next.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Arrays" data-type="sect2"><div class="sect2" id="idm46304982369112">&#13;
<h2>Arrays</h2>&#13;
&#13;
<p>Like in JavaScript, TypeScript arrays are special kinds of objects that support things like concatenation, pushing, searching, and slicing.<a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="arrays" data-type="indexterm" id="ix_typeTSarr"/><a data-primary="arrays" data-type="indexterm" id="ix_arr"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304982039368"/> It’s example time:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>           <code class="c1">// number[]</code>&#13;
<code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">]</code>          <code class="c1">// string[]</code>&#13;
<code class="kd">let</code> <code class="nx">c</code>: <code class="kt">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'a'</code><code class="p">]</code>     <code class="c1">// string[]</code>&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">]</code>            <code class="c1">// (string | number)[]</code>&#13;
<code class="kr">const</code> <code class="nx">e</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">]</code>          <code class="c1">// (string | number)[]</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">f</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'red'</code><code class="p">]</code>&#13;
<code class="nx">f</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'blue'</code><code class="p">)</code>&#13;
<code class="nx">f</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code>                <code class="c1">// Error TS2345: Argument of type 'true' is not</code>&#13;
                            <code class="c1">// assignable to parameter of type 'string'.</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">g</code> <code class="o">=</code> <code class="p">[]</code>                  <code class="c1">// any[]</code>&#13;
<code class="nx">g</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>                   <code class="c1">// number[]</code>&#13;
<code class="nx">g</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'red'</code><code class="p">)</code>               <code class="c1">// (string | number)[]</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">h</code>: <code class="kt">number</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[]</code>        <code class="c1">// number[]</code>&#13;
<code class="nx">h</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>                   <code class="c1">// number[]</code>&#13;
<code class="nx">h</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'red'</code><code class="p">)</code>               <code class="c1">// Error TS2345: Argument of type '"red"' is not</code>&#13;
                            <code class="c1">// assignable to parameter of type 'number'.</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>TypeScript supports two syntaxes for arrays: <code>T[]</code> and <code>Array&lt;T&gt;</code>. They are identical both in meaning and in performance.<a data-primary="arrays" data-secondary="syntaxes for, T[] and Array&lt;T&gt;" data-type="indexterm" id="idm46304982034824"/> This book uses <code>T[]</code> syntax for its terseness, but you should pick whichever style you like for your own code.</p>&#13;
</div>&#13;
&#13;
<p>As you read through these examples, notice that everything but <code>c</code> and <code>h</code> is implicitly typed. You’ll also notice that TypeScript has rules about what you can and can’t put in an array.</p>&#13;
&#13;
<p>The general rule of thumb is to keep arrays <em>homogeneous</em>. <a data-primary="homogeneous arrays" data-type="indexterm" id="idm46304981905464"/><a data-primary="arrays" data-secondary="homogeneous" data-type="indexterm" id="idm46304981904728"/>That is, don’t mix apples and oranges and numbers in a single array—try to design your programs so that every element of your array has the same type. The reason is that otherwise, you’re going to have to do more work to prove to TypeScript that what you’re doing is safe.</p>&#13;
&#13;
<p>To see why things are easier when your arrays are homogeneous, take a look at example <code>f</code>. I initialized an array with the string <code>'red'</code> (at the point when I declared the array it contained just strings, so TypeScript inferred that it must be an array of strings). I then pushed <code>'blue'</code> onto it; <code>'blue'</code> is a string, so TypeScript let it pass. Then I tried to push <code>true</code> onto the array, but that failed! Why? Because <code>f</code> is an array of strings, and <code>true</code> is not a string.</p>&#13;
&#13;
<p>On the other hand, when I initialized <code>d</code> I gave it a <code>number</code> and a <code>string</code>, so TypeScript inferred that <a data-primary="intersection types" data-secondary="array" data-type="indexterm" id="idm46304981897656"/>it must be an array of type <code>number | string</code>. Because each element might be either a number or a string, you have to check which it is before using it. For example, say you want to map over that array, converting every letter to uppercase and tripling every number:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">]</code>&#13;
&#13;
<code class="nx">d</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">_</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">_</code> <code class="o">===</code> <code class="s1">'number'</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">_</code> <code class="o">*</code> <code class="mi">3</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">_</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code>&#13;
<code class="p">})</code>&#13;
</pre>&#13;
&#13;
<p>You have to query the type of each item with <code>typeof</code>, checking if it’s a <code>number</code> or a <code>string</code> before you can do anything with it.<a data-primary="typeof operator" data-secondary="using with array items" data-type="indexterm" id="idm46304981861368"/></p>&#13;
&#13;
<p>Like with objects, creating arrays with <code>const</code> won’t hint to TypeScript to infer their types more narrowly.<a data-primary="const" data-secondary="array declarations with" data-type="indexterm" id="idm46304981859368"/> That’s why TypeScript inferred both <code>d</code> and <code>e</code> to be arrays of <code>number | string</code>.</p>&#13;
&#13;
<p><code>g</code> is the special case: when you initialize an empty array, TypeScript doesn’t know what type the array’s elements should be, so it gives you the benefit of the doubt and makes them <code>any</code>. As you manipulate<a data-primary="any type" data-secondary="inferred for empty array elements" data-type="indexterm" id="idm46304981855752"/> the array and add elements to it, TypeScript starts to piece together your array’s type. Once your array leaves the scope it was defined in (for example, if you declared it in a function, then returned it), TypeScript<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304981854408"/> will assign it a final type that can’t be expanded anymore:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">buildArray() {</code>&#13;
  <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[]</code>                <code class="c1">// any[]</code>&#13;
  <code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>                 <code class="c1">// number[]</code>&#13;
  <code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'x'</code><code class="p">)</code>               <code class="c1">// (string | number)[]</code>&#13;
  <code class="k">return</code> <code class="nx">a</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">myArray</code> <code class="o">=</code> <code class="nx">buildArray</code><code class="p">()</code>  <code class="c1">// (string | number)[]</code>&#13;
<code class="nx">myArray</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code>          <code class="c1">// Error 2345: Argument of type 'true' is not</code>&#13;
                            <code class="c1">// assignable to parameter of type 'string | number'.</code></pre>&#13;
&#13;
<p>So as far as uses of <code>any</code> go, this one shouldn’t make you sweat too much.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tuples" data-type="sect2"><div class="sect2" id="tuple-type">&#13;
<h2>Tuples</h2>&#13;
&#13;
<p>Tuples are subtypes of <code>array</code>. They’re a special <a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="tuples" data-type="indexterm" id="idm46304981714840"/><a data-primary="tuples" data-type="indexterm" id="idm46304981713560"/><a data-primary="arrays" data-secondary="tuples" data-type="indexterm" id="idm46304981712888"/>way to type arrays that have fixed lengths, where the values at each index have specific, known types. Unlike most other types, tuples have to be explicitly typed when you declare them.<a data-primary="[] (square brackets)" data-secondary="in tuple declarations" data-secondary-sortas="tuple declarations" data-type="indexterm" id="idm46304981711608"/> That’s because the JavaScript syntax is the same for tuples and arrays (both use square brackets), and TypeScript already has rules for inferring array types from square brackets:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
&#13;
<code class="c1">// A tuple of [first name, last name, birth year]</code>&#13;
<code class="kd">let</code> <code class="nx">b</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'malcolm'</code><code class="p">,</code> <code class="s1">'gladwell'</code><code class="p">,</code> <code class="mi">1963</code><code class="p">]</code>&#13;
&#13;
<code class="nx">b</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'queen'</code><code class="p">,</code> <code class="s1">'elizabeth'</code><code class="p">,</code> <code class="s1">'ii'</code><code class="p">,</code> <code class="mi">1926</code><code class="p">]</code>  <code class="c1">// Error TS2322: Type 'string' is not</code>&#13;
                                        <code class="c1">// assignable to type 'number'.</code></pre>&#13;
&#13;
<p>Tuples support optional elements too.<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2322" data-type="indexterm" id="idm46304981685320"/><a data-primary="? (question mark)" data-secondary="for optional elements in tuples" data-type="indexterm" id="idm46304981647800"/><a data-primary="tuples" data-secondary="optional elements" data-type="indexterm" id="idm46304981646920"/> Just like in object types, <code>?</code> means “optional”:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// An array of train fares, which sometimes vary depending on direction</code>&#13;
<code class="kd">let</code> <code class="nx">trainFares</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="o">?</code><code class="p">][]</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">[</code><code class="mf">3.75</code><code class="p">],</code>&#13;
  <code class="p">[</code><code class="mf">8.25</code><code class="p">,</code> <code class="mf">7.70</code><code class="p">],</code>&#13;
  <code class="p">[</code><code class="mf">10.50</code><code class="p">]</code>&#13;
<code class="p">]</code>&#13;
&#13;
<code class="c1">// Equivalently:</code>&#13;
<code class="kd">let</code> <code class="nx">moreTrainFares</code><code class="o">:</code> <code class="p">([</code><code class="kt">number</code><code class="p">]</code> <code class="o">|</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">])[]</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>Tuples also support rest elements, which you <a data-primary="tuples" data-secondary="rest elements" data-type="indexterm" id="idm46304981618648"/>can use to type tuples with minimum lengths:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// A list of strings with at least 1 element</code>&#13;
<code class="kd">let</code> <code class="nx">friends</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="p">...</code><code class="kt">string</code><code class="p">[]]</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Sara'</code><code class="p">,</code> <code class="s1">'Tali'</code><code class="p">,</code> <code class="s1">'Chloe'</code><code class="p">,</code> <code class="s1">'Claire'</code><code class="p">]</code>&#13;
&#13;
<code class="c1">// A heterogeneous list</code>&#13;
<code class="kd">let</code> <code class="nx">list</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kr">boolean</code><code class="p">,</code> <code class="p">...</code><code class="kt">string</code><code class="p">[]]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">]</code></pre>&#13;
&#13;
<p>Not only do tuple types safely encode heterogeneous lists, but they also capture the length of the list they type. These features buy you significantly more safety than plain old arrays—use them often.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Read-only arrays and tuples" data-type="sect3"><div class="sect3" id="readonly-array">&#13;
<h3>Read-only arrays and tuples</h3>&#13;
&#13;
<p>While regular arrays are mutable (meaning you can <code>.push</code> onto them, <code>.splice</code> them, and update them in place), which is probably what you want most of the time, sometimes you want an immutable array—one that you can update to produce a new array, leaving the original unchanged.<a data-primary="tuples" data-secondary="read-only" data-type="indexterm" id="idm46304981487752"/><a data-primary="arrays" data-secondary="read-only" data-type="indexterm" id="idm46304981486776"/></p>&#13;
&#13;
<p>TypeScript comes with a <code>readonly</code> array type out of the box, which you can use to create immutable arrays.<a data-primary="ReadonlyArray type" data-type="indexterm" id="idm46304981484808"/> Read-only arrays are just like regular arrays, but you can’t update them in place. To create a read-only array, use an explicit type annotation; to update a read-only array, use nonmutating methods like <code>.concat</code> and <code>.slice</code> instead of <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2339" data-type="indexterm" id="idm46304981482920"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2542" data-type="indexterm" id="idm46304981481640"/>mutating ones like <code>.push</code> and <code>.splice</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="kr">as</code><code class="o">:</code> <code class="nx">readonly</code> <code class="kt">number</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>     <code class="c1">// readonly number[]</code>&#13;
<code class="kd">let</code> <code class="nx">bs</code>: <code class="kt">readonly</code> <code class="kt">number</code><code class="p">[]</code> <code class="o">=</code> <code class="kr">as</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>  <code class="c1">// readonly number[]</code>&#13;
<code class="kd">let</code> <code class="nx">three</code> <code class="o">=</code> <code class="nx">bs</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code>                         <code class="c1">// number</code>&#13;
<code class="kr">as</code><code class="p">[</code><code class="mi">4</code><code class="p">]</code> <code class="o">=</code> <code class="mi">5</code>            <code class="c1">// Error TS2542: Index signature in type</code>&#13;
                     <code class="c1">// 'readonly number[]' only permits reading.</code>&#13;
<code class="kr">as</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">6</code><code class="p">)</code>           <code class="c1">// Error TS2339: Property 'push' does not</code>&#13;
                     <code class="c1">// exist on type 'readonly number[]'.</code></pre>&#13;
&#13;
<p>Like <code>Array</code>, TypeScript comes with a couple of longer-form ways to declare read-only arrays and tuples:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">readonly</code> <code class="kt">string</code><code class="p">[]</code>           <code class="c1">// readonly string[]</code>&#13;
<code class="nx">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code>       <code class="c1">// readonly string[]</code>&#13;
<code class="nx">type</code> <code class="nx">C</code> <code class="o">=</code> <code class="nx">Readonly</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code>          <code class="c1">// readonly string[]</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">D</code> <code class="o">=</code> <code class="nx">readonly</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">string</code><code class="p">]</code>   <code class="c1">// readonly [number, string]</code>&#13;
<code class="nx">type</code> <code class="nx">E</code> <code class="o">=</code> <code class="nx">Readonly</code><code class="o">&lt;</code><code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">string</code><code class="p">]</code><code class="o">&gt;</code>  <code class="c1">// readonly [number, string]</code></pre>&#13;
&#13;
<p>Which syntax you use—the terser <code>readonly</code> modifier, or the longer-form <code>Readonly</code> or <code>ReadonlyArray</code> utilities—is a matter of taste.<a data-primary="readonly modifier" data-secondary="using with arrays and tuples" data-type="indexterm" id="idm46304981304072"/></p>&#13;
&#13;
<p>Note that while read-only arrays can make your code easier to reason about in some cases by avoiding mutability, they are backed by regular JavaScript arrays. That means even small updates to an array result in having to copy the original array first, which can hurt your application’s runtime performance if you’re not careful. For small arrays this overhead is rarely noticeable, but for bigger arrays, the overhead can become significant.<a data-primary="immutable arrays" data-type="indexterm" id="idm46304981302264"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you plan to make heavy use of immutable arrays, consider reaching for a more efficient implementation, like Lee Byron’s excellent <a href="https://www.npmjs.com/package/immutable"><code>immutable</code></a>.<a data-primary="types" data-secondary="supported by TypeScript" data-startref="ix_typeTSarr" data-tertiary="arrays" data-type="indexterm" id="idm46304981299576"/><a data-primary="arrays" data-startref="ix_arr" data-type="indexterm" id="idm46304981298056"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="null, undefined, void, and never" data-type="sect2"><div class="sect2" id="null-undefined">&#13;
<h2>null, undefined, void, and never</h2>&#13;
&#13;
<p>JavaScript has two values to represent an absence of something: <code>null</code> and <code>undefined</code>. <a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="null, undefined, void, and never" data-type="indexterm" id="ix_typeTSnull"/>TypeScript supports both of these as values, and it also has types for them—any guess what they’re called? You got it, the types are called <code>null</code> and <code>undefined</code> too.<a data-primary="null type" data-type="indexterm" id="idm46304981291384"/><a data-primary="undefined type" data-type="indexterm" id="idm46304981290648"/></p>&#13;
&#13;
<p>They’re both special types, because in TypeScript the only thing of type <code>undefined</code> is the value <code>undefined</code>, and the only thing of type <code>null</code> is the value <code>null</code>.<a data-primary="values" data-secondary="null and undefined" data-type="indexterm" id="idm46304981287992"/></p>&#13;
&#13;
<p>JavaScript programmers usually use the two interchangeably, though there is a subtle semantic difference worth mentioning: <code>undefined</code> means that something hasn’t been defined yet, and <code>null</code> means an absence of a value (like if you tried to compute a value, but ran into an error along the way). These are just conventions and TypeScript doesn’t hold you to them, but it can be a useful distinction to make.</p>&#13;
&#13;
<p>In addition to <code>null</code> and <code>undefined</code>, TypeScript<a data-primary="void type" data-type="indexterm" id="idm46304981283688"/><a data-primary="never type" data-type="indexterm" id="idm46304981282952"/> also has <code>void</code> and <code>never</code>. <a data-primary="functions" data-secondary="null, undefined, void and never return types" data-type="indexterm" id="idm46304981281288"/>These are really specific, special-purpose types that draw even finer lines between the different kinds of things that don’t exist: <code>void</code> is the return type of a function that doesn’t explicitly return anything (for example, <code>console.log</code>), and <code>never</code> is the type <a data-primary="null type" data-secondary="example of usage" data-type="indexterm" id="idm46304981278552"/><a data-primary="undefined type" data-secondary="example of usage" data-type="indexterm" id="idm46304981277544"/>of a function that never returns at all (like a function that throws an exception, or one that runs forever):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// (a) A function that returns a number or null</code>&#13;
<code class="kd">function</code> <code class="nx">a</code><code class="p">(</code><code class="nx">x</code>: <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">x</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="kc">null</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// (b) A function that returns undefined</code>&#13;
<code class="kd">function</code> <code class="nx">b() {</code>&#13;
  <code class="k">return</code> <code class="kc">undefined</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// (c) A function that returns void</code>&#13;
<code class="kd">function</code> <code class="nx">c() {</code>&#13;
  <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code>&#13;
  <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">*</code> <code class="nx">a</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// (d) A function that returns never</code>&#13;
<code class="kd">function</code> <code class="nx">d() {</code>&#13;
  <code class="k">throw</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s1">'I always error'</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// (e) Another function that returns never</code>&#13;
<code class="kd">function</code> <code class="nx">e() {</code>&#13;
  <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">doSomething</code><code class="p">()</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>(a) and (b) explicitly return <code>null</code> and <code>undefined</code>, respectively. (c) returns <code>undefined</code>, but it doesn’t do so  with an explicit <code>return</code> statement, so we say it returns <code>void</code>. (d) throws an exception, and (e) runs forever—neither will ever return, so we say their return type is <code>never</code>.</p>&#13;
&#13;
<p>If <code>unknown</code> is the supertype of every other type, then <code>never</code> is the subtype of every other type. <a data-primary="bottom type" data-type="indexterm" id="idm46304981167768"/>We call it a <em>bottom type</em>. That means it’s assignable to every other type, and a value of type <code>never</code> can be used anywhere safely. This has mostly theoretical significance,<sup><a data-type="noteref" href="ch03.html#idm46304981166104" id="idm46304981166104-marker">6</a></sup> but is something that will come up when you talk about TypeScript with other language nerds.<a data-primary="null type" data-secondary="summary of usage" data-type="indexterm" id="idm46304981165144"/><a data-primary="undefined type" data-secondary="summary of usage" data-type="indexterm" id="idm46304981164200"/><a data-primary="void type" data-secondary="summary of usage" data-type="indexterm" id="idm46304981163256"/><a data-primary="never type" data-secondary="summary of usage" data-type="indexterm" id="idm46304981162312"/></p>&#13;
&#13;
<p><a data-type="xref" href="#table-absence">Table 3-2</a> summarizes how the four absence types are used.</p>&#13;
<table class="pagebreak-before" id="table-absence">&#13;
<caption><span class="label">Table 3-2. </span>Types that mean an absence of something</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Type</th>&#13;
<th>Meaning</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>null</code></p></td>&#13;
<td><p>Absence of a value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>undefined</code></p></td>&#13;
<td><p>Variable that has not been assigned a value yet</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>void</code></p></td>&#13;
<td><p>Function that doesn’t have a <code>return</code> statement</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>never</code></p></td>&#13;
<td><p>Function that never returns</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304981149048">&#13;
<h5>Strict null Checking</h5>&#13;
<p>In older versions of TypeScript (or with TSC’s <code>strictNullChecks</code> option set to <code>false</code>), <code>null</code> behaves a little differently: it is a subtype of all types, except <code>never</code>. <a data-primary="strictNullChecks option" data-type="indexterm" id="idm46304981145400"/><a data-primary="TSC compiler" data-secondary="strictNullChecks option" data-type="indexterm" id="idm46304981144664"/><a data-primary="null type" data-secondary="strict null checking" data-type="indexterm" id="idm46304981143720"/>That means every type is nullable, and you can never really trust the type of anything without first checking if it’s <code>null</code> or not. For example, if someone passes the variable <code>pizza</code> to your function and you want to call the method <code>.addAnchovies</code> on it, you first have to check if your <code>pizza</code> is <code>null</code> before you can add delicious tiny fish to it. In practice this is really tedious to do with every single variable, so people often forget to actually check first. Then, when something really is <code>null</code>, you get a dreaded null pointer exception at runtime:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">addDeliciousFish</code><code class="p">(</code><code class="nx">pizza</code>: <code class="kt">Pizza</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">pizza</code><code class="p">.</code><code class="nx">addAnchovies</code><code class="p">()</code>  <code class="c1">// Uncaught TypeError: Cannot read</code>&#13;
<code class="p">}</code>                              <code class="c1">// property 'addAnchovies' of null</code>&#13;
&#13;
<code class="c1">// TypeScript lets this fly with strictNullChecks = false</code>&#13;
<code class="nx">addDeliciousFish</code><code class="p">(</code><code class="kc">null</code><code class="p">)</code></pre>&#13;
&#13;
<p><code>null</code> has been called the <a href="http://bit.ly/2WEdZNO">“billion dollar mistake”</a> by the guy that introduced it in the 1960s.<a data-primary="null type" data-secondary="problems with in programming languages" data-type="indexterm" id="idm46304981066152"/> The problem with <code>null</code> is it’s something that most languages’ type systems can’t express and don’t check for; so when a programmer tries to do something with a variable that they thought was defined but it actually turns out to be <code>null</code> at runtime, the code throws a runtime exception!</p>&#13;
&#13;
<p>Why? Don’t ask me, I’m just the guy writing this book. But languages are coming around to encoding <code>null</code> in their type systems, and TypeScript is a great example of how to do it right. If the goal is to catch as many bugs as possible at compile time before your users encounter them, then being able to check for <code>null</code> in the type system is indispensable.<a data-primary="types" data-secondary="supported by TypeScript" data-startref="ix_typeTSnull" data-tertiary="null, undefined, void, and never" data-type="indexterm" id="idm46304981130904"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enums" data-type="sect2"><div class="sect2" id="enums">&#13;
<h2>Enums</h2>&#13;
&#13;
<p>Enums are a way to <em>enumerate</em> the possible values for a type. <a data-primary="enums" data-type="indexterm" id="ix_enum"/>They are unordered data structures that map keys to values. Think of them like objects where the keys are fixed at compile time, so TypeScript can check that the given key actually exists when you access it.</p>&#13;
&#13;
<p>There are two kinds of enums: enums that map from strings to strings, and enums that map from strings to numbers. <a data-primary="enums" data-secondary="with inferred numeric values, example of" data-type="indexterm" id="idm46304981124808"/>They look like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">enum</code> <code class="nx">Language</code> <code class="p">{</code>&#13;
  <code class="nx">English</code><code class="p">,</code>&#13;
  <code class="nx">Spanish</code><code class="p">,</code>&#13;
  <code class="nx">Russian</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>By convention, enum names are uppercase and singular.<a data-primary="enums" data-secondary="naming conventions" data-type="indexterm" id="idm46304981114792"/> Their keys are also uppercase.</p>&#13;
</div>&#13;
&#13;
<p>TypeScript will automatically infer a number as the value for each member of your enum, but you can also set values explicitly. <a data-primary="enums" data-secondary="with explicit numeric values, example of" data-type="indexterm" id="idm46304981113096"/>Let’s make explicit what TypeScript inferred in the previous example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">enum</code> <code class="nx">Language</code> <code class="p">{</code>&#13;
  <code class="nx">English</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>&#13;
  <code class="nx">Spanish</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>&#13;
  <code class="nx">Russian</code> <code class="o">=</code> <code class="mi">2</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To retrieve a value from an enum, you access it with either dot or bracket notation—just like you would to get a value <a data-primary="[] (square brackets)" data-secondary="retrieving enum values" data-type="indexterm" id="idm46304981001832"/>from a regular object:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">myFirstLanguage</code> <code class="o">=</code> <code class="nx">Language</code><code class="p">.</code><code class="nx">Russian</code>      <code class="c1">// Language</code>&#13;
<code class="kd">let</code> <code class="nx">mySecondLanguage</code> <code class="o">=</code> <code class="nx">Language</code><code class="p">[</code><code class="s1">'English'</code><code class="p">]</code>  <code class="c1">// Language</code></pre>&#13;
&#13;
<p>You can split your enum across multiple declarations, and TypeScript will automatically merge them for you (to learn more, jump ahead to <a data-type="xref" href="ch10.html#namespace-merging">“Declaration Merging”</a>). Beware that when you do split your enum, TypeScript can only infer values for one of those declarations, <a data-primary="enums" data-secondary="splitting across multiple declarations" data-type="indexterm" id="idm46304980988840"/>so it’s good practice to explicitly assign a value to each enum member:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">enum</code> <code class="nx">Language</code> <code class="p">{</code>&#13;
  <code class="nx">English</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>&#13;
  <code class="nx">Spanish</code> <code class="o">=</code> <code class="mi">1</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">enum</code> <code class="nx">Language</code> <code class="p">{</code>&#13;
  <code class="nx">Russian</code> <code class="o">=</code> <code class="mi">2</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">You can use computed values, <a data-primary="enums" data-secondary="with partially inferred values, example of" data-type="indexterm" id="idm46304980949160"/>and you don’t have to define all of them (TypeScript will do its best to infer what’s missing):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">enum</code> <code class="nx">Language</code> <code class="p">{</code>&#13;
  <code class="nx">English</code> <code class="o">=</code> <code class="mi">100</code><code class="p">,</code>&#13;
  <code class="nx">Spanish</code> <code class="o">=</code> <code class="mi">200</code> <code class="o">+</code> <code class="mi">300</code><code class="p">,</code>&#13;
  <code class="nx">Russian</code>                 <code class="c1">// TypeScript infers 501 (the next number after 500)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can also use string values for enums, or even mix string and number values:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">enum</code> <code class="nx">Color</code> <code class="p">{</code>&#13;
  <code class="nx">Red</code> <code class="o">=</code> <code class="s1">'#c10000'</code><code class="p">,</code>&#13;
  <code class="nx">Blue</code> <code class="o">=</code> <code class="s1">'#007ac1'</code><code class="p">,</code>&#13;
  <code class="nx">Pink</code> <code class="o">=</code> <code class="mh">0xc10050</code><code class="p">,</code>        <code class="c1">// A hexadecimal literal</code>&#13;
  <code class="nx">White</code> <code class="o">=</code> <code class="mi">255</code>             <code class="c1">// A decimal literal</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">red</code> <code class="o">=</code> <code class="nx">Color</code><code class="p">.</code><code class="nx">Red</code>       <code class="c1">// Color</code>&#13;
<code class="kd">let</code> <code class="nx">pink</code> <code class="o">=</code> <code class="nx">Color</code><code class="p">.</code><code class="nx">Pink</code>     <code class="c1">// Color</code></pre>&#13;
&#13;
<p>TypeScript lets you access enums both by value and by key for convenience, but this can get <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2339" data-type="indexterm" id="idm46304980772952"/>unsafe quickly:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">Color</code><code class="p">.</code><code class="nx">Red</code>         <code class="c1">// Color</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">Color</code><code class="p">.</code><code class="nx">Green</code>       <code class="c1">// Error TS2339: Property 'Green' does not exist</code>&#13;
                          <code class="c1">// on type 'typeof Color'.</code>&#13;
<code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">Color</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>          <code class="c1">// string</code>&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">Color</code><code class="p">[</code><code class="mi">6</code><code class="p">]</code>          <code class="c1">// string (!!!)</code></pre>&#13;
&#13;
<p>You shouldn’t be able to get <code>Color[6]</code>, but TypeScript doesn’t stop you! We can ask TypeScript to prevent this kind of unsafe access by opting into a safer subset of enum behavior with <code>const enum</code> instead.<a data-primary="const" data-secondary="enum declarations with" data-type="indexterm" id="idm46304980741512"/><a data-primary="enums" data-secondary="const" data-type="indexterm" id="idm46304980740712"/> Let’s rewrite our <code>Language</code> enum from earlier:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">const</code> <code class="kr">enum</code> <code class="nx">Language</code> <code class="p">{</code>&#13;
  <code class="nx">English</code><code class="p">,</code>&#13;
  <code class="nx">Spanish</code><code class="p">,</code>&#13;
  <code class="nx">Russian</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Accessing a valid enum key</code>&#13;
<code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">Language</code><code class="p">.</code><code class="nx">English</code>  <code class="c1">// Language</code>&#13;
&#13;
<code class="c1">// Accessing an invalid enum key</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">Language</code><code class="p">.</code><code class="nx">Tagalog</code>  <code class="c1">// Error TS2339: Property 'Tagalog' does not exist</code>&#13;
                          <code class="c1">// on type 'typeof Language'.</code>&#13;
&#13;
<code class="c1">// Accessing a valid enum value</code>&#13;
<code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">Language</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>       <code class="c1">// Error TS2476: A const enum member can only be</code>&#13;
                          <code class="c1">// accessed using a string literal.</code>&#13;
&#13;
<code class="c1">// Accessing an invalid enum value</code>&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">Language</code><code class="p">[</code><code class="mi">6</code><code class="p">]</code>       <code class="c1">// Error TS2476: A const enum member can only be</code>&#13;
                          <code class="c1">// accessed using a string literal.</code></pre>&#13;
&#13;
<p>A <code>const enum</code> doesn’t let you do reverse lookups, and so behaves a lot like a regular JavaScript object.<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2476" data-type="indexterm" id="idm46304980736936"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2339" data-type="indexterm" id="idm46304980659240"/> It also doesn’t generate any JavaScript code by default, and instead inlines the enum member’s value wherever it’s used (for example, TypeScript will replace every occurrence of <code>Language.Spanish</code> with its value, <code>1</code>).</p>&#13;
<div data-type="tip"><h1>TSC Flag: preserveConstEnums</h1>&#13;
<p><code>const enum</code> inlining can lead to safety issues when you import a <code>const enum</code> from someone else’s TypeScript code: if the enum author updates their <code>const enum</code> after you’ve compiled your <a data-primary="const" data-secondary="enum declarations with" data-tertiary="problems with" data-type="indexterm" id="idm46304980653992"/>TypeScript code, then your version of the enum and their version might point to different values at runtime, and TypeScript will be none the wiser.<a data-primary="enums" data-secondary="preserveConstEnums TSC flag" data-type="indexterm" id="idm46304980652456"/><a data-primary="preserveConstEnums TSC flag" data-type="indexterm" id="idm46304980651448"/><a data-primary="TSC compiler" data-secondary="preserveConstEnums option" data-type="indexterm" id="idm46304980650760"/></p>&#13;
&#13;
<p>If you use <code>const enum</code>s, be careful to avoid inlining them and to only use them in TypeScript programs that you control: avoid using them in programs that you’re planning to publish to NPM, or to make available for others to use as a library.</p>&#13;
&#13;
<p>To enable runtime code generation for <code>const enum</code>s, switch the <code>preserveConstEnums</code> TSC setting to <code>true</code> in your <em>tsconfig.json</em>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"preserveConstEnums"</code><code class="p">:</code> <code class="kc">true</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div>&#13;
&#13;
<p> &#13;
Let’s see how we use <code>const enum</code>s:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">const</code> <code class="kr">enum</code> <code class="nx">Flippable</code> <code class="p">{</code>&#13;
  <code class="nx">Burger</code><code class="p">,</code>&#13;
  <code class="nx">Chair</code><code class="p">,</code>&#13;
  <code class="nx">Cup</code><code class="p">,</code>&#13;
  <code class="nx">Skateboard</code><code class="p">,</code>&#13;
  <code class="nx">Table</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">flip</code><code class="p">(</code><code class="nx">f</code>: <code class="kt">Flippable</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="s1">'flipped it'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">flip</code><code class="p">(</code><code class="nx">Flippable</code><code class="p">.</code><code class="nx">Chair</code><code class="p">)</code>     <code class="c1">// 'flipped it'</code>&#13;
<code class="nx">flip</code><code class="p">(</code><code class="nx">Flippable</code><code class="p">.</code><code class="nx">Cup</code><code class="p">)</code>       <code class="c1">// 'flipped it'</code>&#13;
<code class="nx">flip</code><code class="p">(</code><code class="mi">12</code><code class="p">)</code>                  <code class="c1">// 'flipped it' (!!!)</code></pre>&#13;
&#13;
<p>Everything looks great—<code>Chairs</code> and <code>Cups</code> work exactly as you expect… until you realize that all numbers are also assignable to enums!<a data-primary="assignability" data-secondary="for enums" data-type="indexterm" id="idm46304980531752"/> That behavior is an unfortunate consequence of TypeScript’s assignability rules, and to fix it you have to be extra careful to only use string-valued enums:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">const</code> <code class="kr">enum</code> <code class="nx">Flippable</code> <code class="p">{</code>&#13;
  <code class="nx">Burger</code> <code class="o">=</code> <code class="s1">'Burger'</code><code class="p">,</code>&#13;
  <code class="nx">Chair</code> <code class="o">=</code> <code class="s1">'Chair'</code><code class="p">,</code>&#13;
  <code class="nx">Cup</code> <code class="o">=</code> <code class="s1">'Cup'</code><code class="p">,</code>&#13;
  <code class="nx">Skateboard</code> <code class="o">=</code> <code class="s1">'Skateboard'</code><code class="p">,</code>&#13;
  <code class="nx">Table</code> <code class="o">=</code> <code class="s1">'Table'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">flip</code><code class="p">(</code><code class="nx">f</code>: <code class="kt">Flippable</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="s1">'flipped it'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">flip</code><code class="p">(</code><code class="nx">Flippable</code><code class="p">.</code><code class="nx">Chair</code><code class="p">)</code>     <code class="c1">// 'flipped it'</code>&#13;
<code class="nx">flip</code><code class="p">(</code><code class="nx">Flippable</code><code class="p">.</code><code class="nx">Cup</code><code class="p">)</code>       <code class="c1">// 'flipped it'</code>&#13;
<code class="nx">flip</code><code class="p">(</code><code class="mi">12</code><code class="p">)</code>                  <code class="c1">// Error TS2345: Argument of type '12' is not</code>&#13;
                          <code class="c1">// assignable to parameter of type 'Flippable'.</code>&#13;
<code class="nx">flip</code><code class="p">(</code><code class="s1">'Hat'</code><code class="p">)</code>               <code class="c1">// Error TS2345: Argument of type '"Hat"' is not</code>&#13;
                          <code class="c1">// assignable to parameter of type 'Flippable'.</code></pre>&#13;
&#13;
<p>All it takes is one pesky numeric value in your enum to make the whole enum unsafe.<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304980528728"/></p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Because of all the pitfalls that come with using enums safely, I recommend you stay away from them—there are plenty of better ways to express yourself in TypeScript.<a data-primary="enums" data-secondary="avoiding use of" data-type="indexterm" id="idm46304980437016"/></p>&#13;
&#13;
<p>And if a coworker insists on using enums and there’s nothing you can do to change their mind, be sure to ninja-merge a few TSLint rules while they’re out to warn about numeric values and non-<code>const</code> enums.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46304992795960">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In short, TypeScript comes with a bunch of built-in types. You can let TypeScript infer types for you from your values, or you can explicitly type your values. <code>const</code> will infer more specific types, <code>let</code> and <code>var</code> more general ones.<a data-primary="const" data-secondary="type declarations with" data-type="indexterm" id="idm46304980432328"/><a data-primary="let" data-secondary="type declarations with" data-type="indexterm" id="idm46304980431320"/><a data-primary="var" data-secondary="type declarations with" data-type="indexterm" id="idm46304980430376"/><a data-primary="types" data-secondary="supported by TypeScript" data-tertiary="types and their subtypes" data-type="indexterm" id="idm46304980429432"/> Most types have general and more specific counterparts, the latter subtypes of the former (see <a data-type="xref" href="#table-subtypes">Table 3-3</a>).</p>&#13;
<table id="table-subtypes">&#13;
<caption><span class="label">Table 3-3. </span>Types and their more specific subtypes</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Type</th>&#13;
<th>Subtype</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Boolean literal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>bigint</code></p></td>&#13;
<td><p>BigInt literal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>number</code></p></td>&#13;
<td><p>Number literal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>string</code></p></td>&#13;
<td><p>String literal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>symbol</code></p></td>&#13;
<td><p><code>unique symbol</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>object</code></p></td>&#13;
<td><p>Object literal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Array</p></td>&#13;
<td><p>Tuple</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>enum</code></p></td>&#13;
<td><p><code>const enum</code><a data-primary="enums" data-startref="ix_enum" data-type="indexterm" id="idm46304980410040"/><a data-primary="types" data-secondary="supported by TypeScript" data-startref="ix_typeTS" data-type="indexterm" id="idm46304980409064"/></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46304980407336">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>For each of these values, what type will TypeScript infer?</p>&#13;
<ol>&#13;
<li><code>let a = 1042</code></li>&#13;
<li><code>let b = 'apples and oranges'</code></li>&#13;
<li><code>const c = 'pineapples'</code></li>&#13;
<li><code>let d = [true, true, false]</code></li>&#13;
<li><code>let e = {type: 'ficus'}</code></li>&#13;
<li><code>let f = [1, false]</code></li>&#13;
<li><code>const g = [3]</code></li>&#13;
<li><code>let h = null</code> (try this out in your code editor, then jump ahead to <a data-type="xref" href="ch06.html#type-widening">“Type Widening”</a> if the result surprises you!)</li>&#13;
</ol>&#13;
</li>&#13;
<li>&#13;
<p>Why does each of these throw the error it does?</p>&#13;
<ol>&#13;
<li>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">let</code> <code class="nx">i</code>: <code class="kt">3</code> <code class="o">=</code> <code class="mi">3</code>&#13;
<code class="nx">i</code> <code class="o">=</code> <code class="mi">4</code> <code class="c1">// Error TS2322: Type '4' is not assignable to type '3'.</code>&#13;
</pre>&#13;
&#13;
</li>&#13;
<li>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">let</code> <code class="nx">j</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>&#13;
<code class="nx">j</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>&#13;
<code class="nx">j</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'5'</code><code class="p">)</code> <code class="c1">// Error TS2345: Argument of type '"5"' is not</code>&#13;
            <code class="c1">// assignable to parameter of type 'number'.</code>&#13;
</pre>&#13;
&#13;
</li>&#13;
<li>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">let</code> <code class="nx">k</code>: <code class="kt">never</code> <code class="o">=</code> <code class="mi">4</code> <code class="c1">// Error TSTS2322: Type '4' is not assignable</code>&#13;
                 <code class="c1">// to type 'never'.</code>&#13;
</pre>&#13;
&#13;
</li>&#13;
<li>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">let</code> <code class="nx">l</code>: <code class="kt">unknown</code> <code class="o">=</code> <code class="mi">4</code>&#13;
<code class="kd">let</code> <code class="nx">m</code> <code class="o">=</code> <code class="nx">l</code> <code class="o">*</code> <code class="mi">2</code> <code class="c1">// Error TS2571: Object is of type 'unknown'.</code>&#13;
</pre>&#13;
&#13;
</li>&#13;
</ol>&#13;
</li>&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304992666696"><sup><a href="ch03.html#idm46304992666696-marker">1</a></sup> Almost. When <code>unknown</code> is part of a union type, the result of the union will be <code>unknown</code>. You’ll read more about union types in <a data-type="xref" href="#union-intersection">“Union and intersection types”</a>.</p><p data-type="footnote" id="idm46304991456584"><sup><a href="ch03.html#idm46304991456584-marker">2</a></sup> Objects in JavaScript use strings for keys; arrays are special kinds of objects that use numerical keys.</p><p data-type="footnote" id="idm46304991324152"><sup><a href="ch03.html#idm46304991324152-marker">3</a></sup> There’s one minor technical difference: <code>{}</code> lets you define whatever types you want for built-in methods on the <code>Object</code> prototype, like <code>.toString</code> and <code>.hasOwnProperty</code> (head over to <a href="https://mzl.la/2VSuDJz">MDN</a> to learn more about prototypes), while <code>Object</code> enforces that the types you declare are assignable to those on <code>Object</code>’s prototype. For example, this code typechecks: <code>let a: {} = {toString() { return 3 }}</code>. But if you change the type annotation to <code>Object</code>, TypeScript complains: <code>let b: Object = {toString() { return 3 }}</code> results in <code>Error TS2322: Type 'number' is not assignable to type 'string'</code>.</p><p data-type="footnote" id="idm46304991089496"><sup><a href="ch03.html#idm46304991089496-marker">4</a></sup> The acronym DRY stands for “Don’t Repeat Yourself”—the idea that code shouldn’t be repetitive. It was introduced by Andrew Hunt and David Thomas in their book <em>The Pragmatic Programmer: From Journeyman to Master</em> (Addison-Wesley).</p><p data-type="footnote" id="idm46304982252728"><sup><a href="ch03.html#idm46304982252728-marker">5</a></sup> Jump ahead to <a data-type="xref" href="ch06.html#discriminated-unions">“Discriminated union types”</a> to learn how to hint to TypeScript that your union is disjoint and a value of that union’s type has to be one or the other, and not both.</p><p data-type="footnote" id="idm46304981166104"><sup><a href="ch03.html#idm46304981166104-marker">6</a></sup> The way to think about a bottom type is as a type that has no values. A bottom type corresponds to a mathematical proposition that’s always false.</p></div></div></section></body></html>