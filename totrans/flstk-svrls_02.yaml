- en: Chapter 2\. Getting Started with AWS Amplify
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the core of most applications is the data/API layer. This layer could look
    like many things. In the serverless world, this usually will be composed of a
    combination of API endpoints and serverless functions. These serverless functions
    could be doing some logic and returning data, interacting with a database of some
    kind, or even interacting with another API endpoint.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways of creating APIs with Amplify:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A combination of Amazon API Gateway and a Lambda function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GraphQL API connected to some type of data source (database, Lambda function,
    or HTTP endpoint)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway is an AWS service that allows you to create API endpoints and route
    them to different services, often via a Lambda function. When you make an API
    call, it will route the request through API Gateway, invoke the function, and
    return the response. Using the Amplify CLI, you can create both the API Gateway
    endpoint as well as the Lambda function; the CLI will automatically configure
    the API to be able to invoke the Lambda function via an HTTP request.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Once your API is created, you then need a way to interact with it. Using the
    Amplify client you will be able to send requests to the endpoint using the Amplify
    `API` class. The `API` class allows you to interact with both GraphQL APIs as
    well as API Gateway endpoints, as shown in [Figure 2-1](#fig2a).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll create your first full stack serverless app that will
    interact with a serverless function via an API Gateway endpoint. You’ll use the
    CLI to create an API endpoint as well as a serverless function, and then use the
    Amplify client libraries to interact with the API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![API with Lambda](Images/fssl_0201.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. API with Lambda
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At first, the app will fetch a hardcoded array of items from the function. You’ll
    then learn how to update the function to make an asynchronous HTTP request to
    another API to retrieve data and return it to the client.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Deploying a Serverless Function
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the core of many serverless applications are *serverless functions*. Serverless
    functions run your code in *stateless compute containers* that are event-driven,
    short-lived (may last for one invocation), and fully managed by the cloud provider
    of your choice. These functions scale seamlessly and do not require any server
    operations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: While most people think of serverless functions as being invoked or triggered
    by an API call, these functions can also be triggered by a variety of different
    events. In addition to HTTP requests, a few popular ways to invoke a serverless
    function are via an image upload to a storage service, a database operation (like
    create, update, or delete), or even from another serverless function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Serverless functions scale automatically, so there’s no need to worry about
    your application if you get a large spike in traffic. The first time you invoke
    a function, the service provider will create an instance of the function and run
    its handler method to process the event. After the function finishes and returns
    a response, it will remain and process additional events if they come in. If another
    invocation happens while the first event is still processing, the service will
    then create another instance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Serverless functions also have a payment model that is different from traditional
    infrastructure. With services like AWS Lambda, you only pay for what you use and
    are charged based on the number of requests for your functions and the time it
    takes for your code to execute. This is in contrast to provisioning and paying
    for infrastructure like servers regardless of whether they are being utilized.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about serverless functions, let’s take a look at how you can
    create a serverless function and hook it up to an API that will invoke it from
    an HTTP request.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Creating the React Application and Installing the Dependencies
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, you’ll first need to create the React application. To do so,
    you can use `npx`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, you will need to install the dependencies. For this app, you’ll only
    need the AWS Amplify library:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After installing the dependencies, you can now initialize a new Amplify project
    in the root of the React application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, both the Amplify project and the React app have been successfully created
    and you can begin adding new features.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Creating a New Serverless Function with the Amplify CLI
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next step, we’ll create the serverless function that you will be using
    for this app. The app you are building in this chapter is a cryptocurrency app.
    At first, you will hardcode an array of cryptocurrency information in the function
    and return it to the client. Later in this chapter, you’ll update this function
    to call another API (CoinLore) and asynchronously fetch and return data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the function, run the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the function has successfully been created, you should see a message saying
    “Successfully added resource cryptofunction locally.”
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: You should now see a new subfolder located within the *amplify* directory at
    *amplify/backend/function/cryptofunction*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Walking Through the Code
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you created this resource, a new folder in *amplify/backend* was created
    named *function*. All of the functions created by the CLI will be stored in this
    folder. For now, you only have a single function, `cryptofunction`. In the *cryptofunction*
    folder, you will see a couple of configuration files as well as an *src* directory
    where the main function code is located.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Serverless functions are essentially just encapsulated applications running
    on their own. Because the function you created is in JavaScript, you’ll see that
    there are all of the things you’d typically see in any JavaScript application,
    including *package.json* and *index.js* files.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Next, have a look at the function entry point located at *src/index.js*, in
    the *cryptofunction* folder. In this file you’ll see that there is a function
    called `exports.handler`. This is the entry point for the function invocation.
    When the function is invoked, this is the code that is run.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: You can handle the event directly in this function if you would like, but since
    you will be working with an API, a more useful way to do this is to proxy the
    path into an express app with routing (i.e., *http://yourapi/<somepath>*). Doing
    this gives you multiple routes in a single function as well as multiple HTTP request
    methods like `get`, `put`, `post`, and `delete` for each route. The *serverless
    express* framework provides an easy way to do this and has been built into the
    function boilerplate for you.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'In *index.js*, you will see a line of code that looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code is where the event, context, and path are proxied to the express server
    running in *app.js*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: In *app.js*, you will then be able to create HTTP requests against whatever
    routes you create for your API (this example being a `/coins` route to fetch cryptocurrency).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Creating the /coins Route
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have seen how the application is structured, let’s create a new
    route in *app.js* and return some data from it. The route that you will be creating
    is a `/coins` route. This route will be returning an object containing a coins
    array.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the new route. Before the first `app.get(''/items'')` route, add
    the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This new route has a hardcoded array of cryptocurrency information. When the
    function is invoked with this route, it will respond with an object containing
    a single property named `coins` that will contain the coins array.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Adding the API
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the function is created and configured, let’s put an API in front of
    it so you can trigger it with an HTTP request.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you will be using Amazon API Gateway. API Gateway is a fully managed
    service that enables developers to create, publish, maintain, monitor, and secure
    REST and WebSocket APIs. API Gateway is one of the services supported by both
    the Amplify CLI as well as the Amplify client library.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll create a new API Gateway endpoint and configure it to
    invoke the Lambda function you created in the previous section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Creating a New API
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the API, you can use the Amplify `add` command. From the root of
    the project, run the following command in your terminal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Deploying the API and the Lambda Function
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the function and API have both been created, you need to deploy them
    to your account to make them live. To do so, you can run the Amplify `push` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the deployment has successfully completed, the services are live and ready
    to use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the Amplify CLI `status` command at any time to see the current
    status of your project. The `status` command will list out all of the currently
    configured services in your project and give you the status for each of them:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The main thing to notice in this status output is the `Operation`. The `Operation`
    tells you what will happen the next time `push` is run in the project. The `Operation`
    property will be set to `Create`, `Update`, `Delete`, or `No Change`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the New API
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the resources have been deployed, you can begin interacting with the
    API from the React application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Client App to Work with Amplify
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the Amplify client library in any application, there is a base configuration
    that needs to be set up, usually at the root level. When you create the resources,
    the CLI populates the *aws-exports.js* file with information about your resources.
    You will use this file to configure the client application to work with Amplify.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the app, open *src/index.js* and add the following below the last
    import:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Amplify Client API Category
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the client application has been configured, you can begin interacting
    with your resources.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The Amplify client library has various API categories that can be imported and
    used for various types of functionality, including `Auth` for authentication,
    `Storage` for storing items in S3, and `API` for interacting with REST and GraphQL
    APIs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will be working with the `API` category. `API` has various
    methods available—including `API.get`, `API.post`, `API.put`, and `API.del`—for
    interacting with REST APIs, and `API.graphql` for interacting with GraphQL APIs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a REST API, `API` takes in three arguments:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`apiName`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The name given when you create the API from the command line. In our example,
    this value would be `cryptoapi`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`path`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The path that you would like to interact with. In our example, we created `/coins`,
    so the path would be `/coins`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`data`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: This is an optional object containing any properties you’d like to pass to the
    API, including headers, query string parameters, or a body.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the API call is going to look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The API returns a promise, meaning you can handle the call using either a promise
    or an `async` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the examples in this book, we’ll be handling promises using `async` functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Calling the API and Rendering the Data in React
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s call the API and render the data. Update *src/App.js* with the
    following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, run the app:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the app loads, you should see a list of coins with their name, symbol,
    and price, as shown in [Figure 2-2](#fig2b).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Fetching data from API](Images/fssl_0202.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Fetching data from the API
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Updating the Function to Call Another API
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, you’ll update the function to call another API, the CoinLore API, that
    will return dynamic data from the CoinLore service. The user will be able to add
    set filters like `limit` and `start` to limit the number of items coming back
    from the API.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you will first need a way to interact with an HTTP endpoint
    in the Lambda function. The library you will be using for this lesson is the Axios
    library. Axios is a promise-based HTTP client for the browser and Node.js.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Installing Axios
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you need to do is install the Axios package in your function
    folder in order to send HTTP requests from the function. Navigate to *amplify/backend/function/cryptofunction/src*,
    install Axios, and then navigate back to the root of the app:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Updating the Function
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, update the `/coins` route in *amplify/backend/function/cryptofunction/src/app.js*
    with the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding function, we’ve imported the Axios library and then used it
    to make an API call to the CoinLore API. In the API call, you can pass in a `start`
    and `limit` parameter to the request to define the number of coins to return,
    as well as to define the starting point.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: In the `req` parameter, there is an `apiGateway` property that holds the `event`
    and the `context` variables. In the function just defined, there is a check to
    see if this `event` exists as well as the `queryStringParameters` property on
    the `event`. If the `queryStringParameters` property exists, we use those values
    to update the base URL with the parameters. Using `queryStringParameters`, the
    user can specify the `start` and `limit` values when querying the CoinLore API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the function is updated, you can deploy the updates by running the `push`
    command in your terminal:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Updating the Client App
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have updated the function, let’s update the React app to give the
    user the option to specify the `limit` and `start` parameters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: To do so, you’ll need to add fields for user input and give the user a button
    to trigger a new API request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Update *src/App.js* with the following changes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, run the app:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, you’ve deployed your first serverless API!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few things to keep in mind from this chapter:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions can be triggered from a variety of events. In this chapter,
    we triggered the function using an API call from API Gateway.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda functions can be created from the Amplify CLI by using the command `amplify
    add function`, and APIs can be created using the command `amplify add api`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single API Gateway endpoint can be configured to work with multiple Lambda
    functions. In the example in this chapter, we have only connected it to a single
    function.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda functions are essentially self-contained Node.js applications. In the
    example for this chapter, we chose to run an express application in order to handle
    REST methods like `get`, `post`, and `delete`, though we have only worked with
    a `get` call at this point.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `API` category from the Amplify client library can be used with both GraphQL
    as well as REST APIs.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amplify客户端库中的`API`类别可用于GraphQL和REST API。
