<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Kubernetes and OpenShift Overview" data-type="chapter" epub:type="chapter"><div class="chapter" id="kubernetes_and_openshift_overview">&#13;
<h1><span class="label">Chapter 1. </span>Kubernetes and OpenShift Overview</h1>&#13;
&#13;
<p>Over the past few years, Kubernetes has emerged as the de facto standard platform for <a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="development of" data-type="indexterm" id="idm45358202304824"/><a contenteditable="false" data-primary="cloud native applications" data-secondary="definition" data-type="indexterm" id="idm45358202303176"/><a contenteditable="false" data-primary="microservices definition" data-type="indexterm" id="idm45358202301736"/>managing, orchestrating, and provisioning container-based cloud native computing applications. <em>Cloud native computing applications</em> are essentially applications that are built from a collection of smaller services (microservices) and take advantage of the speed of development and scalability capabilities that cloud computing environments typically provide. Over time, Kubernetes has matured to provide the controls required to manage even more advanced and stateful workloads, such as databases and AI services. The Kubernetes ecosystem continues to experience explosive growth, and the project benefits greatly from being a multiple-vendor and meritocracy-based open source project backed by a solid governance policy and a level playing field for contributing.</p>&#13;
&#13;
<p>Although many Kubernetes distributions are available for customers to choose from, the <a contenteditable="false" data-primary="Kubernetes" data-secondary="Red Hat OpenShift distribution" data-seealso="OpenShift" data-type="indexterm" id="idm45358202298920"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="about" data-tertiary="popularity of distribution" data-type="indexterm" id="idm45358202297208"/>Red Hat OpenShift Kubernetes distribution is of particular interest. OpenShift has achieved broad adoption across a variety of industries; over one thousand enterprise customers across the globe currently use it to host their business applications and drive their digital transformation efforts.</p>&#13;
&#13;
<p>This book focuses on enabling you to become an expert at running both traditional Kubernetes and the OpenShift distribution of Kubernetes in production environments. In this first chapter, we begin with a broad overview of both Kubernetes and OpenShift and the historical origin of both platforms. We then review the key features and capabilities that have made Kubernetes and OpenShift the dominant platforms for creating and deploying cloud native applications.</p>&#13;
&#13;
<section data-pdf-bookmark="Kubernetes: Cloud Infrastructure for Orchestrating Containerized Applications" data-type="sect1"><div class="sect1" id="kubernetes_cloud_infrastructure_for_orch">&#13;
<h1>Kubernetes: Cloud Infrastructure for Orchestrating Containerized Applications</h1>&#13;
&#13;
<p>The emergence of Docker in 2013 introduced numerous developers to <a contenteditable="false" data-primary="Docker containerization emergence" data-type="indexterm" id="idm45358202764920"/><a contenteditable="false" data-primary="containers" data-secondary="about" data-tertiary="development" data-type="indexterm" id="idm45358202763720"/>containers and container-based application development. Containers were presented as an alternative to virtual machines (VMs) for creating self-contained deployable units. <a contenteditable="false" data-primary="Linux operating system" data-secondary="security for containers" data-type="indexterm" id="idm45358202761752"/><a contenteditable="false" data-primary="containers" data-secondary="security" data-tertiary="Linux operating system" data-type="indexterm" id="idm45358202760376"/><a contenteditable="false" data-primary="security" data-secondary="containers via Linux operating system" data-type="indexterm" id="idm45358202758728"/>Containers rely on advanced security and resource management features of the Linux operating system to provide isolation at the process level instead of relying on VMs for creating deployable units of software. A Linux process is much more lightweight and orders of magnitude more efficient than a VM for common activities like starting up an application image or creating new image snapshots. Because of these advantages, developers favored containers as the desired approach to creating new software applications as self-contained units of deployable software. As the popularity of containers grew, so did a need for a common platform for provisioning, managing, and orchestrating containers across a cluster. For more than a decade, <a contenteditable="false" data-primary="Google" data-secondary="Kubernetes development" data-type="indexterm" id="idm45358202756456"/>Google had embraced the use of Linux containers as the foundation for applications deployed in its cloud.<sup><a data-type="noteref" href="ch01.html#ch01fn1" id="ch01fn1-marker">1</a></sup> Google had extensive experience orchestrating and managing containers at scale and had developed three generations of container-management systems: Borg, Omega, and <a href="https://kubernetes.io">Kubernetes</a>. The latest generation of container management developed by Google, Kubernetes was a redesign based on lessons learned from Borg and Omega and was made available as an open source project. Kubernetes delivered several key features that dramatically improved the experience of developing and deploying a scalable container-based cloud application:</p>&#13;
&#13;
<dl>&#13;
	<dt>Declarative deployment model</dt>&#13;
	<dd>Most cloud infrastructures that existed before Kubernetes was released <a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="declarative deployment model" data-type="indexterm" id="idm45358202749544"/><a contenteditable="false" data-primary="declarative deployment model" data-type="indexterm" id="idm45358202747848"/><a contenteditable="false" data-primary="containers" data-secondary="declarative deployment model" data-type="indexterm" id="idm45358202746728"/>took a procedural approach based on a scripting language like Ansible, Chef, Puppet, and so on for automating the deployment of applications to production environments. In contrast, Kubernetes used a declarative approach of describing what the desired state of the system should be. Kubernetes infrastructure was then responsible for starting new containers when necessary (e.g., when a container failed) to achieve the desired declared state. The declarative model was much more clear at communicating which deployment actions were desired, and this approach was a huge step forward compared with trying to read and interpret a script to determine what the desired deployment state should be.</dd>&#13;
	<dt class="pagebreak-before less_space">Built-in replica and autoscaling support</dt>&#13;
	<dd>In some cloud infrastructures that existed before Kubernetes, support for <a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="replicas and autoscaling" data-type="indexterm" id="idm45358202743160"/><a contenteditable="false" data-primary="replicas" data-secondary="about Kubernetes" data-type="indexterm" id="idm45358202741544"/><a contenteditable="false" data-primary="autoscaling" data-secondary="about Kubernetes" data-type="indexterm" id="idm45358202740168"/><a contenteditable="false" data-primary="autoscaling" data-secondary="definition" data-type="indexterm" id="idm45358202738792"/><a contenteditable="false" data-primary="pods" data-secondary="replicas" data-tertiary="about Kubernetes" data-type="indexterm" id="idm45358202737416"/>replicas of an application and autoscaling capabilities were not part of the core <span class="keep-together">infrastructure</span> and, in some cases, never successfully materialized due to platform or architectural limitations. <em>Autoscaling</em> refers to the ability of a cloud environment to recognize that an application is becoming more heavily used, so the cloud environment automatically increases the capacity of the application, typically by creating more copies of the application on extra servers in the cloud environment. Autoscaling capabilities were provided as core features in Kubernetes and dramatically improved the robustness and consumability of its orchestration capabilities.</dd>&#13;
	<dt>Built-in rolling upgrades support</dt>&#13;
	<dd>Most cloud infrastructures do not provide support for <a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="rolling upgrades" data-type="indexterm" id="idm45358202733192"/><a contenteditable="false" data-primary="rolling upgrades" data-secondary="about Kubernetes" data-type="indexterm" id="idm45358202731448"/><a contenteditable="false" data-primary="upgrades" data-secondary="rolling upgrades of Kubernetes" data-type="indexterm" id="idm45358202730072"/>upgrading applications. Instead, they assume the operator will use a scripting language, such as Chef, Puppet, or Ansible, to handle upgrades. In contrast, Kubernetes actually provides built-in support for rolling out upgrades of applications. For example, <a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="rollouts configurable" data-type="indexterm" id="idm45358202728280"/><a contenteditable="false" data-primary="rollouts" data-secondary="about Kubernetes" data-type="indexterm" id="idm45358202726632"/>Kubernetes rollouts are configurable such that they can leverage extra resources for faster rollouts that have no downtime, or they can perform slower rollouts that do canary testing, reducing the risk and validating new software by releasing software to a small percentage of users to ensure that the new version of the application is stable. Kubernetes also supports pausing, resuming, and rolling back the version of an application.</dd>&#13;
	<dt>Improved networking model</dt>&#13;
	<dd>Kubernetes mapped a single IP address to a <em>pod</em>, which is <a contenteditable="false" data-primary="IP address per pod" data-type="indexterm" id="idm45358202723368"/><a contenteditable="false" data-primary="pods" data-secondary="IP address per pod" data-type="indexterm" id="idm45358202387912"/><a contenteditable="false" data-primary="pods" data-secondary="about" data-type="indexterm" id="idm45358202386536"/><a contenteditable="false" data-primary="containers" data-secondary="pod networking model" data-type="indexterm" id="idm45358202385160"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="pod networking model" data-type="indexterm" id="idm45358202383784"/>Kubernetes’s smallest unit of container deployment, aggregation, and management. This approach aligned the network identity with the application identity and simplified running software on Kubernetes.<sup><a data-type="noteref" href="ch01.html#ch01fn2" id="ch01fn2-marker">2</a></sup></dd>&#13;
	<dt>Built-in health-checking support</dt>&#13;
	<dd>Kubernetes provided container health-checking and <a contenteditable="false" data-primary="containers" data-secondary="about" data-tertiary="health checking" data-type="indexterm" id="idm45358202378136"/><a contenteditable="false" data-primary="health checking" data-secondary="containers" data-type="indexterm" id="idm45358202376488"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="health checking" data-type="indexterm" id="idm45358202375112"/>monitoring capabilities that reduced the complexity of identifying when failures occur.</dd>&#13;
</dl>&#13;
&#13;
<p>Even with all the innovative capabilities available in Kubernetes, many <a contenteditable="false" data-primary="Kubernetes" data-secondary="about" data-tertiary="Cloud Native Computing Foundation" data-type="indexterm" id="idm45358202373080"/><a contenteditable="false" data-primary="Cloud Native Computing Foundation (CNCF)" data-type="indexterm" id="ch01-CNCF"/>enterprise companies were still hesitant to adopt this technology because it was an open source project supported by a single vendor. Enterprise companies are careful about which open source projects they are willing to adopt, and they expect open source projects like Kubernetes to have multiple vendors contributing to them; they also expect open source projects to be meritocracy based with a solid governance policy and a level playing field for contributing. In 2015, the Cloud Native Computing Foundation (CNCF) was formed to address these issues facing Kubernetes.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="CNCF Accelerates the Growth of the Kubernetes Ecosystem" data-type="sect1"><div class="sect1" id="cncf_accelerates_the_growth_of_the_kuber">&#13;
<h1>CNCF Accelerates the Growth of the Kubernetes Ecosystem</h1>&#13;
&#13;
<p>In 2015, the Linux Foundation initiated the creation of the CNCF.<sup><a data-type="noteref" href="ch01.html#ch01fn3" id="ch01fn3-marker">3</a></sup> The CNCF’s mission is to make cloud native computing ubiquitous.<sup><a data-type="noteref" href="ch01.html#ch01fn4" id="ch01fn4-marker">4</a></sup> <a contenteditable="false" data-primary="Google" data-secondary="Kubernetes donated to CNCF" data-type="indexterm" id="idm45358202362264"/>In support of this new foundation, Google donated Kubernetes to the CNCF to serve as its seed technology. With Kubernetes as the core of its ecosystem, the CNCF has grown to more than 440 member companies, including Google Cloud, IBM Cloud, Red Hat, Amazon Web Services (AWS), Docker, Microsoft Azure, VMware, Intel, Huawei, Cisco, Alibaba Cloud, and many more.<sup><a data-type="noteref" href="ch01.html#ch01fn5" id="ch01fn5-marker">5</a></sup> In addition, the CNCF ecosystem has grown to hosting 26 open source projects, including Prometheus, Envoy, gRPC, etcd, and many others. Finally, the CNCF nurtures several early-stage projects and has had eight projects accepted into its Sandbox program for emerging technologies.</p>&#13;
&#13;
<p>With the weight of the vendor-neutral CNCF foundation behind it, Kubernetes has grown to having more than 3,200 contributors annually from a wide range of industries.<sup><a data-type="noteref" href="ch01.html#ch01fn6" id="ch01fn6-marker">6</a></sup> In addition to hosting several cloud native projects, the CNCF provides training, a Technical Oversight Board, a Governing Board, a community infrastructure lab, and several certification programs to boost the ecosystem for Kubernetes and related projects. As a result of these efforts, there are currently over one hundred certified distributions of Kubernetes. <a contenteditable="false" data-primary="Kubernetes" data-secondary="Red Hat OpenShift distribution" data-type="indexterm" id="idm45358202355720"/><a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="about" data-tertiary="popularity of distribution" data-type="indexterm" id="idm45358202354312"/>One of the most popular distributions of Kubernetes, particularly for enterprise customers, is Red Hat’s OpenShift Kubernetes. In the next section, we introduce OpenShift and give an overview of the key benefits it provides for developers and IT operations teams.<a contenteditable="false" data-primary="" data-startref="ch01-CNCF" data-type="indexterm" id="idm45358202352232"/></p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="OpenShift: Red Hat’s Distribution of Kubernetes" data-type="sect1"><div class="sect1" id="openshift_red_hatapostrophes_distributio">&#13;
<h1>OpenShift: Red Hat’s Distribution of Kubernetes</h1>&#13;
&#13;
<p>Although many companies have contributed to Kubernetes, the contributions from Red Hat are particularly noteworthy. Red Hat has been a part of the Kubernetes ecosystem from its inception as an open source project, and it continues to serve as the second-largest contributor to Kubernetes. Based on this hands-on expertise with Kubernetes, Red Hat provides its own distribution of Kubernetes that it refers to as <em>OpenShift</em>. OpenShift is the most broadly deployed distribution of Kubernetes across the enterprise. It provides a 100% conformant Kubernetes platform and supplements it with a variety of tools and capabilities focused on improving the productivity of developers and IT operations.</p>&#13;
&#13;
<p>OpenShift was originally released in 2011.<sup><a data-type="noteref" href="ch01.html#ch01fn7" id="ch01fn7-marker">7</a></sup> At that time, it had its own platform-specific container runtime environment.<sup><a data-type="noteref" href="ch01.html#ch01fn8" id="ch01fn8-marker">8</a></sup> <a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="about" data-tertiary="Kubernetes container orchestration" data-type="indexterm" id="idm45358202342744"/>In early 2014, the Red Hat team met with the container orchestration team at Google and learned about a new container orchestration project that eventually became Kubernetes. The Red Hat team was incredibly impressed with Kubernetes, and OpenShift was rewritten to use Kubernetes as its container orchestration engine. As a result of these efforts, OpenShift was able to deliver a 100% conformant Kubernetes platform as part of its version 3 release in June 2015.<sup><a data-type="noteref" href="ch01.html#ch01fn9" id="ch01fn9-marker">9</a></sup></p>&#13;
&#13;
<p>The Red Hat OpenShift Container Platform is Kubernetes with<a contenteditable="false" data-primary="Red Hat OpenShift Container Platform" data-seealso="OpenShift" data-type="indexterm" id="idm45358202337976"/><a contenteditable="false" data-primary="errors" data-secondary="bug fix support of OpenShift" data-type="indexterm" id="idm45358202336504"/><a contenteditable="false" data-primary="errors" data-secondary="debugging" data-see="debugging" data-type="indexterm" id="idm45358202335112"/><a contenteditable="false" data-primary="errors" data-secondary="failure" data-see="failure" data-type="indexterm" id="idm45358202333464"/><a contenteditable="false" data-primary="bug fix support of OpenShift" data-type="indexterm" id="idm45358202331816"/> additional supporting capabilities to make it operational for enterprise needs. The Kubernetes community provides fixes for releases for a period of up to 12 months. OpenShift differentiates itself from other distributions by providing long-term support (three or more years) for major Kubernetes releases, security patches, and enterprise support contracts that cover both the operating system and the OpenShift Kubernetes platform. <a contenteditable="false" data-primary="Red Hat Enterprise Linux (RHEL)" data-type="indexterm" id="idm45358202330120"/><a contenteditable="false" data-primary="Linux operating system" data-secondary="Red Hat Enterprise Linux" data-type="indexterm" id="idm45358202329000"/>Red Hat Enterprise Linux (RHEL) has long been a de facto distribution of Linux for organizations large and small. Red Hat OpenShift Container Platform builds on RHEL to ensure consistent Linux distributions from the host operating system through all containerized functions on the cluster. In addition to all these benefits, OpenShift enhances Kubernetes by supplementing it with a variety of tools and capabilities focused on improving the productivity of both developers and IT operations. The following sections describe these benefits.</p>&#13;
&#13;
<section data-pdf-bookmark="Benefits of OpenShift for Developers" data-type="sect2"><div class="sect2" id="benefits_of_openshift_for_developers">&#13;
<h2>Benefits of OpenShift for Developers</h2>&#13;
&#13;
<p>While Kubernetes has a lot of functionality for provisioning and managing container images, <a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="about" data-tertiary="benefits for developers" data-type="indexterm" id="idm45358202324920"/>it does not provide much support for creating new images from base images, pushing images to registries, or identifying when new versions become available. In addition, the networking support provided by Kubernetes can be quite complicated to use. To fill these gaps, OpenShift offers several benefits to developers beyond those provided by the core Kubernetes platform:</p>&#13;
&#13;
<dl>&#13;
	<dt>Source-to-Image</dt>&#13;
	<dd>When using basic Kubernetes, the cloud native application <a contenteditable="false" data-primary="deployments" data-secondary="Source-to-Image by OpenShift" data-type="indexterm" id="idm45358202321192"/>developer is responsible for creating their own container images. Typically, this involves finding the proper base image and creating a <code>Dockerfile</code> with all the necessary commands for taking a base image and adding in the developer’s code to create an assembled image that Kubernetes can deploy. This requires the developer to learn a variety of Docker commands that are used for image assembly. <a contenteditable="false" data-primary="S2I (Source-to-Image)" data-type="indexterm" id="idm45358202318744"/><a contenteditable="false" data-primary="Source-to-Image (S2I)" data-type="indexterm" id="idm45358202317640"/><a contenteditable="false" data-primary="Git repositories" data-secondary="Source-to-Image updates" data-type="indexterm" id="idm45358197378712"/><a contenteditable="false" data-primary="upgrades" data-secondary="Source-to-Image by OpenShift" data-type="indexterm" id="idm45358197377336"/>With its Source-to-Image (S2I) capability, OpenShift is able to handle merging the cloud native developer’s code into the base image. In many cases, S2I can be configured such that all the developer needs to do is commit their changes to a Git repository, and S2I will see the updated changes and merge them with a base image to create a new assembled image for deployment.</dd>&#13;
	<dt>Push images to registries</dt>&#13;
	<dd>Another key step that must be performed by the cloud native developer when using basic Kubernetes is storing newly assembled container images in an <a contenteditable="false" data-primary="Docker Hub" data-secondary="OpenShift handling image registries" data-type="indexterm" id="idm45358197374440"/><a contenteditable="false" data-primary="image registries" data-secondary="OpenShift private registry" data-type="indexterm" id="idm45358197373000"/><a contenteditable="false" data-primary="image registries" data-secondary="OpenShift and third-party registries" data-type="indexterm" id="idm45358197371608"/><a contenteditable="false" data-primary="image registries" data-secondary="Docker Hub as" data-type="indexterm" id="idm45358197370216"/>image registry such as Docker Hub. In this case, the developer needs to create and manage the repository. In contrast, OpenShift provides its own private registry and developers can use that option, or <a contenteditable="false" data-primary="S2I (Source-to-Image)" data-secondary="assembled images to registries" data-type="indexterm" id="idm45358197368488"/><a contenteditable="false" data-primary="Source-to-Image (S2I)" data-secondary="assembled images to registries" data-type="indexterm" id="idm45358197367096"/><a contenteditable="false" data-primary="image registries" data-secondary="S2I pushing assembled images to" data-type="indexterm" id="idm45358197365704"/>S2I can be configured to push assembled images to third-party registries.</dd>&#13;
	<dt>Image streams</dt>&#13;
	<dd>When developers create cloud native applications, the development effort results in a large number of configuration changes, as well as changes to the container image of the application. <a contenteditable="false" data-primary="image streams in OpenShift" data-type="indexterm" id="idm45358197363112"/><a contenteditable="false" data-primary="container images" data-secondary="image streams in OpenShift" data-type="indexterm" id="idm45358197361992"/>To address this complexity, OpenShift provides the image stream functionality, which monitors for configuration or image changes and performs automated builds and deployments based on the change events. This feature takes the burden off the developer of having to perform these steps manually whenever changes occur.</dd>&#13;
	<dt>Base image catalog</dt>&#13;
	<dd>OpenShift provides a base image catalog with a large number of <a contenteditable="false" data-primary="base image catalogs by OpenShift" data-type="indexterm" id="idm45358197359272"/>useful base images for a variety of tools and platforms, such as WebSphere Liberty, JBoss, PHP, Redis, Jenkins, Python, .NET, MariaDB, and many others. The catalog provides trusted content that is packaged from known source code.</dd>&#13;
	<dt>Routes</dt>&#13;
	<dd>Networking in base Kubernetes can be quite complicated to configure. <a contenteditable="false" data-primary="routes of OpenShift" data-type="indexterm" id="idm45358197356840"/><a contenteditable="false" data-primary="load balancing" data-secondary="routes of OpenShift" data-type="indexterm" id="idm45358197355656"/><a contenteditable="false" data-primary="URLs readable via routes" data-type="indexterm" id="idm45358197354280"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="services" data-tertiary="load balancing via routes" data-type="indexterm" id="idm45358197353160"/><a contenteditable="false" data-primary="deployments" data-secondary="routes load balancing" data-type="indexterm" id="idm45358197351496"/>OpenShift has a route construct that interfaces with Kubernetes services and is responsible for adding Kubernetes services to an external load balancer. Routes also provide readable URLs for applications and a variety of load-balancing strategies to <span class="keep-together">support</span> several deployment options, such as blue-green, canary, and A/B testing deployments.<sup><a data-type="noteref" href="ch01.html#ch01fn10" id="ch01fn10-marker">10</a></sup></dd>&#13;
</dl>&#13;
&#13;
<p>While OpenShift has a large number of benefits for developers, its greatest differentiators are the benefits it gives IT operations. In the next section, we describe several of the core capabilities for automating the day-to day-operations of running <span class="keep-together">OpenShift</span> in production.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Benefits of OpenShift for IT Operations" data-type="sect2"><div class="sect2" id="benefits_of_openshift_for_it_operations">&#13;
<h2>Benefits of OpenShift for IT Operations</h2>&#13;
&#13;
<p>In May 2019, Red Hat announced the release of OpenShift 4.<sup>11</sup> <a contenteditable="false" data-primary="OpenShift (Red Hat)" data-secondary="about" data-tertiary="benefits for IT operations" data-type="indexterm" id="idm45358197343560"/><a contenteditable="false" data-primary="CoreOS" data-type="indexterm" id="idm45358197341864"/><a contenteditable="false" data-primary="Red Hat OpenShift Container Platform " data-type="indexterm" id="idm45358197340760"/>Red Hat acquired <span class="keep-together">CoreOS</span>, which had a very automated approach to managing Kubernetes’s life-cycle behavior and was an early advocate of the “operator” concept. This new version of OpenShift was completely rewritten to build on capabilities from CoreOS’s innovative management practices and OpenShift 3’s reputation for reliability, which dramatically improved how the OpenShift platform is installed, upgraded, and managed.<sup><a data-type="noteref" href="ch01.html#ch01fn11" id="ch01fn11-marker">11</a></sup> To deliver these significant life-cycle improvements, OpenShift heavily used the latest Kubernetes innovations and best practices for automating the management of resources in its architecture. As a result of these efforts, OpenShift 4 is able to deliver the following benefits for IT operations:</p>&#13;
&#13;
<dl>&#13;
	<dt>Automated installation</dt>&#13;
	<dd>OpenShift 4 supports an innovative installation approach that is automated,<a contenteditable="false" data-primary="installation automated" data-type="indexterm" id="idm45358197334408"/><a contenteditable="false" data-primary="automations" data-secondary="installation automated" data-type="indexterm" id="idm45358197333304"/><a contenteditable="false" data-primary="deployments" data-secondary="full stack automated deployments" data-type="indexterm" id="idm45358197331928"/><a contenteditable="false" data-primary="infrastructure" data-secondary="OpenShift installation including" data-type="indexterm" id="idm45358197330584"/><a contenteditable="false" data-primary="upgrades" data-secondary="automated installation of OpenShift" data-type="indexterm" id="idm45358197329240"/> reliable, and repeatable.<sup><a data-type="noteref" href="ch01.html#ch01fn12" id="ch01fn12-marker">12</a></sup> Additionally, the OpenShift 4 installation process supports full stack automated deployments and can handle installing the complete infrastructure, including components like DNS and the VM.</dd>&#13;
	<dt>Automated operating system and OpenShift platform updates</dt>&#13;
	<dd>OpenShift is tightly integrated with the lightweight RHEL CoreOS operating system,<a contenteditable="false" data-primary="Red Hat Enterprise Linux (RHEL)" data-secondary="CoreOS" data-type="indexterm" id="idm45358197324056"/><a contenteditable="false" data-primary="upgrades" data-secondary="OpenShift OS and platform updates" data-type="indexterm" id="idm45358197322616"/> which itself is optimized for running OpenShift and cloud native applications. Thanks to the tight coupling of OpenShift with a specific version of RHEL CoreOS, the OpenShift platform is able to manage updating the operating system as part of its cluster management operations. The key value of this approach for IT operations is that it supports automated, self-managing, over-the-air updates. This enables OpenShift to support cloud native and hands-free operations.</dd>&#13;
	<dt>Automated cluster size management</dt>&#13;
	<dd>OpenShift supports the ability to automatically increase or decrease the <a contenteditable="false" data-primary="clusters" data-secondary="cluster size management by OpenShift" data-type="indexterm" id="idm45358197319784"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="cluster worker nodes added" data-type="indexterm" id="idm45358197318344"/><a contenteditable="false" data-primary="machine operator adding worker nodes" data-type="indexterm" id="idm45358197316952"/><a contenteditable="false" data-primary="deployments" data-secondary="worker nodes added" data-type="indexterm" id="idm45358197315832"/>size of the cluster it is managing. Like all Kubernetes clusters, an OpenShift cluster has a certain number of worker nodes on which the container applications are deployed. In a typical Kubernetes cluster, adding worker nodes is an out-of-band operation that IT operations must handle manually. In contrast, OpenShift provides a component called the <em>machine operator</em> that is capable of automatically adding worker nodes to a cluster. An IT operator can use a <code>MachineSet</code> object to declare the number of machines needed by the cluster, and OpenShift will automatically perform the provisioning and installation of new worker nodes to achieve the desired state.</dd>&#13;
	<dt>Automated cluster version management</dt>&#13;
	<dd>OpenShift, like all Kubernetes distributions, is composed of a large <a contenteditable="false" data-primary="clusters" data-secondary="cluster version management by OpenShift" data-type="indexterm" id="idm45358197311976"/><a contenteditable="false" data-primary="operators" data-secondary="operator construct" data-tertiary="cluster version automation" data-type="indexterm" id="idm45358197310456"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="operator construct" data-type="indexterm" id="idm45358197308792"/><a contenteditable="false" data-primary="upgrades" data-secondary="cluster version management by OpenShift" data-type="indexterm" id="idm45358197307416"/>number of components. Each of these components has its own version number. To manage updating each of these components, OpenShift relies on a Kubernetes innovation called the <em>operator construct</em>. OpenShift uses a cluster version number to identify which version of OpenShift is running, and this cluster version number denotes which versions of the individual OpenShift platform components need to be installed. With its automated cluster version management, OpenShift is able to install the proper versions of all these components automatically to ensure that it is properly updated when the cluster is updated to a new version.</dd>&#13;
	<dt>Multicloud management support</dt>&#13;
	<dd>Many enterprise customers that use OpenShift have multiple clusters, <a contenteditable="false" data-primary="multicloud management" data-secondary="OpenShift" data-type="indexterm" id="idm45358197304008"/><a contenteditable="false" data-primary="clusters" data-secondary="multicloud management by OpenShift" data-type="indexterm" id="idm45358197302552"/>and these clusters are deployed across multiple clouds or in multiple data centers. To simplify the management of multiple clusters, OpenShift 4 has introduced a new unified cloud console that allows customers to view and manage multiple <span class="keep-together">OpenShift</span> clusters.<sup><a data-type="noteref" href="ch01.html#ch01fn13" id="ch01fn13-marker">13</a></sup></dd>&#13;
</dl>&#13;
&#13;
<p>As we will see later in this book, OpenShift and the capabilities it provides become extremely prominent when it’s time to run in production and IT operators need to address operational and security-related concerns.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we gave an overview of Kubernetes and OpenShift, including the historical origins of both platforms. We then presented the key benefits provided by both Kubernetes and OpenShift that have driven the huge growth in popularity of these platforms. This has helped us have a greater appreciation for the value that Kubernetes and OpenShift provide to cloud native application developers and IT operations teams. Thus, it is no surprise that these platforms are experiencing explosive growth across a variety of industries. In <a data-type="xref" href="ch02.html#getting_started_with_openshift_and_kuber">Chapter 2</a>, we will build a solid foundational overview of Kubernetes and OpenShift that presents the Kubernetes architecture, discusses how to get Kubernetes and OpenShift production environments up and running, and introduces several key Kubernetes and OpenShift concepts that are critical to running successfully in production.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch01fn1"><sup><a href="ch01.html#ch01fn1-marker">1</a></sup> Brendan Burns et al., “Borg, Omega, and Kubernetes: Lessons Learned from Three Container-Management Systems over a Decade,” <em>ACM Queue</em> 14 (2016): 70–93, <a href="http://bit.ly/2vIrL4S"><em class="hyperlink">http://bit.ly/2vIrL4S</em></a>.</p><p data-type="footnote" id="ch01fn2"><sup><a href="ch01.html#ch01fn2-marker">2</a></sup> Brendan Burns et al., “Borg, Omega, and Kubernetes: Lessons Learned from Three Container-Management Systems over a Decade,” <em>ACM Queue</em> 14 (2016): 70–93, <a href="http://bit.ly/2vIrL4S"><em class="hyperlink">http://bit.ly/2vIrL4S</em></a>.</p><p data-type="footnote" id="ch01fn3"><sup><a href="ch01.html#ch01fn3-marker">3</a></sup> Steven J. Vaughan-Nicholls, “Cloud Native Computing Foundation Seeks to Forge Cloud and Container Unity,” <em>ZDNet</em> (July 21, 2015), <a href="https://oreil.ly/WEoE0"><em class="hyperlink">https://oreil.ly/WEoE0</em></a>.</p><p data-type="footnote" id="ch01fn4"><sup><a href="ch01.html#ch01fn4-marker">4</a></sup> Linux Foundation, CNCF Charter (updated December 10, 2018), <a href="https://oreil.ly/tHHvr"><em class="hyperlink">https://oreil.ly/tHHvr</em></a>.</p><p data-type="footnote" id="ch01fn5"><sup><a href="ch01.html#ch01fn5-marker">5</a></sup> The <a href="https://oreil.ly/Tj3Vw">CNCF Members page</a> provides more details on membership growth of the CNCF.</p><p data-type="footnote" id="ch01fn6"><sup><a href="ch01.html#ch01fn6-marker">6</a></sup> See the <a href="https://oreil.ly/mkSTm">Kubernetes Companies Table Dashboard</a> for a current list.</p><p data-type="footnote" id="ch01fn7"><sup><a href="ch01.html#ch01fn7-marker">7</a></sup> Joe Fernandes, “Why Red Hat Chose Kubernetes for OpenShift,” Red Hat OpenShift Blog (November 7, 2016), <a href="https://oreil.ly/r66GM"><em class="hyperlink">https://oreil.ly/r66GM</em></a>.</p><p data-type="footnote" id="ch01fn8"><sup><a href="ch01.html#ch01fn8-marker">8</a></sup> Anton McConville and Olaph Wagoner, “A Brief History of Kubernetes, OpenShift, and IBM,” IBM Developer Blog (August 1, 2019), <a href="https://oreil.ly/IugtP"><em class="hyperlink">https://oreil.ly/IugtP</em></a>.</p><p data-type="footnote" id="ch01fn9"><sup><a href="ch01.html#ch01fn9-marker">9</a></sup> “Red Hat Delivers OpenShift Enterprise 3 to Power a New Web-Scale Distributed Application Platform” [press release], Red Hat (June 24, 2015), <a href="https://oreil.ly/jlane"><em class="hyperlink">https://oreil.ly/jlane</em></a>.</p><p data-type="footnote" id="ch01fn10"><sup><a href="ch01.html#ch01fn10-marker">10</a></sup> For more details on OpenShift routes, please see <a href="https://oreil.ly/hmpJz">Using Route-Based Deployment Strategies</a> in the OpenShift documentation.</p><p data-type="footnote" id="ch01fn11"><sup><a href="ch01.html#ch01fn11-marker">11</a></sup> Joe Fernandes, “Introducing Red Hat OpenShift 4: Kubernetes for the Enterprise,” Red Hat OpenShift Blog (May 8, 2019), <a href="https://oreil.ly/yNb8s"><em class="hyperlink">https://oreil.ly/yNb8s</em></a>.</p><p data-type="footnote" id="ch01fn12"><sup><a href="ch01.html#ch01fn12-marker">12</a></sup> Christian Hernandez, “OpenShift 4.1 Bare Metal Install Quickstart,” Red Hat OpenShift Blog (July 31, 2019), <a href="https://oreil.ly/yz4pR"><em class="hyperlink">https://oreil.ly/yz4pR</em></a>.</p><p data-type="footnote" id="ch01fn13"><sup><a href="ch01.html#ch01fn13-marker">13</a></sup> Fernandes, “Introducing Red Hat OpenShift 4: Kubernetes for the Enterprise.”</p></div></div></section></body></html>