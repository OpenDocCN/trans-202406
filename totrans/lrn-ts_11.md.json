["```\nlet anyValue: any;\nanyValue = \"Lucille Ball\"; // Ok\nanyValue = 123; // Ok\n\nconsole.log(anyValue); // Ok\n```", "```\nfunction greetComedian(name: any) {\n    // No type error...\n    console.log(`Announcing ${name.toUpperCase()}!`);\n}\n\ngreetComedian({ name: \"Bea Arthur\" });\n    // Runtime error: name.toUpperCase is not a function\n```", "```\nfunction greetComedian(name: unknown) {\n    console.log(`Announcing ${name.toUpperCase()}!`);\n    //                        ~~~~\n    // Error: Object is of type 'unknown'.\n}\n```", "```\nfunction greetComedianSafety(name: unknown) {\n    if (typeof value === \"string\") {\n        console.log(`Announcing ${name.toUpperCase()}!`); // Ok\n    } else {\n        console.log(\"Well, I'm off.\");\n    }\n}\n\ngreetComedianSafety(\"Betty White\"); // Logs: 4\ngreetComedianSafety({}); // Does not log\n```", "```\nfunction isNumberOrString(value: unknown) {\n    return ['number', 'string'].includes(typeof value);\n}\n\nfunction logValueIfExists(value: number | string | null | undefined) {\n    if (isNumberOrString(value)) {\n        // Type of value: number | string | null | undefined\n        value.toString();\n        // Error: Object is possibly undefined.\n    } else {\n        console.log(\"Value does not exist:\", value);\n    }\n}\n```", "```\nfunction typePredicate(input: WideType): input is NarrowType;\n```", "```\nfunction isNumberOrString(value: unknown): value is number | string {\n    return ['number', 'string'].includes(typeof value);\n}\n\nfunction logValueIfExists(value: number | string | null | undefined) {\n    if (isNumberOrString(value)) {\n        // Type of value: number | string\n        value.toString(); // Ok\n    } else {\n        // Type of value: null | undefined\n        console.log(\"value does not exist:\", value);\n    }\n}\n```", "```\ninterface Comedian {\n    funny: boolean;\n}\n\ninterface StandupComedian extends Comedian {\n    routine: string;\n}\n\nfunction isStandupComedian(value: Comedian): value is StandupComedian {\n    return 'routine' in value;\n}\n\nfunction workWithComedian(value: Comedian) {\n    if (isStandupComedian(value)) {\n        // Type of value: StandupComedian\n        console.log(value.routine); // Ok\n    }\n\n    // Type of value: Comedian\n    console.log(value.routine);\n    //                ~~~~~~~\n    // Error: Property 'routine' does not exist on type 'Comedian'.\n}\n```", "```\nfunction isLongString(input: string | undefined): input is string {\n    return !!(input && input.length >= 7);\n}\n\nfunction workWithText(text: string | undefined) {\n    if (isLongString(text)) {\n        // Type of text: string\n        console.log(\"Long text:\", text.length);\n    } else {\n        // Type of text: undefined\n        console.log(\"Short text:\", text?.length);\n        //                               ~~~~~~\n        // Error: Property 'length' does not exist on type 'never'.\n    }\n}\n```", "```\ninterface Ratings {\n    audience: number;\n    critics: number;\n}\n\nfunction getRating(ratings: Ratings, key: string): number {\n    return ratings[key];\n    //     ~~~~~~~~~~~\n    // Error: Element implicitly has an 'any' type because expression\n    // of type 'string' can't be used to index type 'Ratings'.\n    //   No index signature with a parameter of\n    //   type 'string' was found on type 'Ratings'.\n}\n\nconst ratings: Ratings = { audience: 66, critic: 84 };\n\ngetRating(ratings, 'audience'); // Ok\n\ngetRating(ratings, 'not valid'); // Ok, but shouldn't be\n```", "```\nfunction getRating(ratings: Ratings, key: 'audience' | 'critic'): number {\n    return ratings[key]; // Ok\n}\n\nconst ratings: Ratings = { audience: 66, critic: 84 };\n\ngetCountLiteral(ratings, 'audience'); // Ok\n\ngetCountLiteral(ratings, 'not valid');\n//                       ~~~~~~~~~~~\n// Error: Argument of type '\"not valid\"' is not\n// assignable to parameter of type '\"audience\" | \"critic\"'.\n```", "```\nfunction getCountKeyof(ratings: Ratings, key: keyof Ratings): number {\n    return ratings[key]; // Ok\n}\n\nconst ratings: Ratings = { audience: 66, critic: 84 };\n\ngetCountKeyof(ratings, 'audience'); // Ok\n\ngetCountKeyof(ratings, 'not valid');\n//                     ~~~~~~~~~~~\n// Error: Argument of type '\"not valid\"' is not\n// assignable to parameter of type 'keyof Ratings'.\n```", "```\nconst original = {\n    medium: \"movie\",\n    title: \"Mean Girls\",\n};\n\nlet adaptation: typeof original;\n\nif (Math.random() > 0.5) {\n    adaptation = { ...original, medium: \"play\" }; // Ok\n} else {\n    adaptation = { ...original, medium: 2 };\n    //                          ~~~~~~\n    // Error: Type 'number' is not assignable to type 'string'.\n}\n```", "```\nconst ratings = {\n    imdb: 8.4,\n    metacritic: 82,\n};\n\nfunction logRating(key: keyof typeof ratings) {\n    console.log(ratings[key]);\n}\n\nlogRating(\"imdb\"); // Ok\n\nlogRating(\"invalid\");\n//        ~~~~~~~~~\n// Error: Argument of type '\"missing\"' is not assignable\n// to parameter of type '\"imdb\" | \"metacritic\"'.\n```", "```\nconst rawData = `[\"grace\", \"frankie\"]`;\n\n// Type: any\nJSON.parse(rawData);\n\n// Type: string[]\nJSON.parse(rawData) as string[];\n\n// Type: [string, string]\nJSON.parse(rawData) as [string, string];\n\n// Type: [\"grace\", \"frankie\"]\nJSON.parse(rawData) as [\"grace\", \"frankie\"];\n```", "```\nconst rawData = `[\"grace\", \"frankie\"]`;\n\n// Type: any\nJSON.parse(rawData);\n\n// Type: string[]\nJSON.parse(rawData);\n\n// Type: [string, string]\nJSON.parse(rawData);\n\n// Type: [\"grace\", \"frankie\"]\nJSON.parse(rawData);\n```", "```\ntry {\n    // (code that may throw an error)\n} catch (error) {\n    console.warn(\"Oh no!\", (error as Error).message);\n}\n```", "```\ntry {\n    // (code that may throw an error)\n} catch (error) {\n    console.warn(\"Oh no!\", error instanceof Error ? error.message : error);\n}\n```", "```\n// Inferred type: Date | undefined\nlet maybeDate = Math.random() > 0.5\n    ? undefined\n    : new Date();\n\n// Asserted type: Date\nmaybeDate as Date;\n\n// Asserted type: Date\nmaybeDate!;\n```", "```\nconst seasonCounts = new Map([\n    [\"I Love Lucy\", 6],\n    [\"The Golden Girls\", 7],\n]);\n\n// Type: string | undefined\nconst maybeValue = seasonCounts.get(\"I Love Lucy\");\n\nconsole.log(maybeValue.toUpperCase());\n//          ~~~~~~~~~~\n// Error: Object is possibly 'undefined'.\n\n// Type: string\nconst knownValue = seasonCounts.get(\"I Love Lucy\")!;\n\nconsole.log(knownValue.toUpperCase()); // Ok\n```", "```\nconst seasonCounts = new Map([\n    [\"Broad City\", 5],\n    [\"Community\", 6],\n]);\n\n// Type: string\nconst knownValue = seasonCounts.get(\"I Love Lucy\")!;\n\nconsole.log(knownValue.toUpperCase()); // No type error, but...\n// Runtime TypeError: Cannot read property 'toUpperCase' of undefined.\n```", "```\ninterface Entertainer {\n    acts: string[];\n    name: string;\n}\n\nconst declared: Entertainer = {\n    name: \"Moms Mabley\",\n};\n// Error: Property 'acts' is missing in type\n// '{ one: number; }' but required in type 'Entertainer'.\n\nconst asserted = {\n    name: \"Moms Mabley\",\n} as Entertainer; // Ok, but...\n\n// Both of these statements would fail at runtime with:\n// Runtime TypeError: Cannot read properties of undefined (reading 'toPrecision')\nconsole.log(declared.acts.join(\", \"));\nconsole.log(asserted.acts.join(\", \"));\n```", "```\nlet myValue = \"Stella!\" as number;\n//            ~~~~~~~~~~~~~~~~~~~\n// Error: Conversion of type 'string' to type 'number'\n// may be a mistake because neither type sufficiently\n// overlaps with the other. If this was intentional,\n// convert the expression to 'unknown' first.\n```", "```\nlet myValueDouble = \"1337\" as unknown as number; // Ok, but... eww.\n```", "```\n// Type: (number | string)[]\n[0, ''];\n\n// Type: readonly [0, '']\n[0, ''] as const;\n```", "```\n// Type: () => string\nconst getName = () => \"Maria Bamford\";\n\n// Type: () => \"Maria Bamford\"\nconst getNameConst = () => \"Maria Bamford\" as const;\n```", "```\ninterface Joke {\n    quote: string;\n    style: \"story\" | \"one-liner\";\n}\n\nfunction tellJoke(joke: Joke) {\n    if (joke.style === \"one-liner\") {\n        console.log(joke.quote);\n    } else {\n        console.log(joke.quote.split(\"\\n\"));\n    }\n}\n\n// Type: { quote: string; style: \"one-liner\" }\nconst narrowJoke = {\n    quote: \"If you stay alive for no other reason do it for spite.\",\n    style: \"one-liner\" as const,\n};\n\ntellJoke(narrowJoke); // Ok\n\n// Type: { quote: string; style: string }\nconst wideObject = {\n    quote: \"Time flies when you are anxious!\",\n    style: \"one-liner\",\n};\n\ntellJoke(wideObject);\n// Error: Argument of type '{ quote: string; style: string; }'\n// is not assignable to parameter of type 'LogAction'.\n//   Types of property 'style' are incompatible.\n//     Type 'string' is not assignable to type '\"story\" | \"one-liner\"'.\n```", "```\nfunction describePreference(preference: \"maybe\" | \"no\" | \"yes\") {\n    switch (preference) {\n        case \"maybe\":\n            return \"I suppose...\";\n        case \"no\":\n            return \"No thanks.\";\n        case \"yes\":\n            return \"Yes please!\";\n    }\n}\n\n// Type: { movie: string, standup: string }\nconst preferencesMutable = {\n    movie: \"maybe\"\n    standup: \"yes\",\n};\n\ndescribePreference(preferencesMutable.movie);\n//                 ~~~~~~~~~~~~~~~~~~~~~~~~\n// Error: Argument of type 'string' is not assignable\n// to parameter of type '\"maybe\" | \"no\" | \"yes\"'.\n\npreferencesMutable.movie = \"no\"; // Ok\n\n// Type: readonly { readonly movie: \"maybe\", readonly standup: \"yes\" }\nconst preferencesReadonly = {\n    movie: \"maybe\"\n    standup: \"yes\",\n} as const;\n\ndescribePreference(preferencesReadonly.movie); // Ok\n\npreferencesReadonly.movie = \"no\";\n//                  ~~~~~\n// Error: Cannot assign to 'movie' because it is a read-only property.\n```"]