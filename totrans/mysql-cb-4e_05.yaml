- en: Chapter 5\. Selecting Data from Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on using the `SELECT` statement to retrieve information
    from your database. You will find the chapter helpful if your SQL background is
    limited or to find out about the MySQL-specific extensions to `SELECT` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to write `SELECT` statements; we’ll look at only a few.
    Consult the *MySQL Reference Manual* or a general MySQL text for more information
    about `SELECT` syntax and the functions and operators available to extract and
    manipulate data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many examples in this chapter use a table named `mail` that contains rows that
    track mail message traffic between users on a set of hosts. The following shows
    how that table was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mail` table contents look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To create and load the `mail` table, change location into the *tables* directory
    of the `recipes` distribution and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This chapter also uses other tables from time to time. Some were used in previous
    chapters, whereas others are new. To create any of them, do so the same way as
    for the `mail` table, using the appropriate script in the *tables* directory.
    In addition, many of the other scripts and programs used in this chapter are located
    in the *select* directory. The files in that directory enable you to try the examples
    more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the statements shown here can be executed from within the *mysql* program,
    which is discussed in [Chapter 1](ch01.xhtml#nch-mysql). A few examples involve
    issuing statements from within the context of a programming language. See [Chapter 4](ch04.xhtml#nch-api)
    for information on programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Specifying Which Columns and Rows to Select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to display specific columns and rows from a table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To indicate which columns to display, name them in the output column list. To
    indicate which rows to display, use a `WHERE` clause that specifies conditions
    that rows must satisfy.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to display columns from a table is to use `SELECT` `*` `FROM`
    *`tbl_name`*. The `*` specifier is a shortcut that means <q>all columns</q>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `*` is easy, but you cannot select only certain columns or control column
    display order. Naming columns explicitly enables you to select only the ones of
    interest, in any order. This query omits the recipient columns and displays the
    sender before the date and size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Unless you qualify or restrict a `SELECT` query in some way, it retrieves every
    row in your table. To be more precise, provide a `WHERE` clause that specifies
    one or more conditions that rows must satisfy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditions can test for equality, inequality, or relative ordering. For some
    types of data, such as strings, you can use pattern matches. The following statements
    select columns from rows in the `mail` table containing `srchost` values that
    are exactly equal to the string `''venus''` or that begin with the letter `''s''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `LIKE` operator in the previous query performs a pattern match, where `%`
    acts as a wildcard that matches any string. [Recipe 7.10](ch07.xhtml#nch-strings-strings-pat-sql)
    discusses pattern matching further.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `WHERE` clause can test multiple conditions and different conditions can
    test different columns. The following statement finds messages sent by `barb`
    to `tricia`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Output columns can be calculated by evaluating expressions. This query combines
    the `srcuser` and `srchost` columns using `CONCAT()` to produce composite values
    in email address format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that the email address column label is the expression that calculates
    it. To provide a better label, use a column alias (see [Recipe 5.2](#nch-select-select-column-alias)).
  prefs: []
  type: TYPE_NORMAL
- en: As of MySQL 8.0.19 you can use statement `TABLE` to select all columns from
    the table. `TABLE` supports `ORDER BY` (see [Recipe 5.3](#nch-select-select-sort))
    and `LIMIT` (see [Recipe 5.11](#nch-select-select-limit-calc)) clauses, but does
    not allow any other filtering of columns or rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 5.2 Naming Query Result Columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The column names in a query result are unsuitable, ugly, or difficult to work
    with, so you want to name them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use aliases to choose your own column names.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you retrieve a result set, MySQL gives every output column a name. (That’s
    how the *mysql* program gets the names you see displayed in the initial row of
    column headers in result set output.) By default, MySQL assigns the column names
    specified in the `CREATE` `TABLE` or `ALTER` `TABLE` statement to output columns,
    but if these defaults are not suitable, you can use column aliases to specify
    your own names.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe explains aliases and shows how to use them to assign column names
    in statements. If you’re writing a program that must determine the names, see
    [Recipe 12.2](ch12.xhtml#nch-meta-meta-result) for information about accessing
    column metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an output column comes directly from a table, MySQL uses the table column
    name for the output column name. The following statement selects four table columns,
    the names of which become the corresponding output column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you generate a column by evaluating an expression, the expression itself
    is the column name. This can produce long and unwieldy names in result sets, as
    illustrated by the following statement that uses one expression to reformat the
    dates in the `t` column, and another to combine `srcuser` and `srchost` into email
    address format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To choose your own output column name, use an `AS` *`name`* clause to specify
    a column alias (the keyword `AS` is optional). The following statement retrieves
    the same result as the previous one, but renames the first column to `date_sent`
    and the second to `sender`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The aliases make the column names more concise, easier to read, and more meaningful.
    Aliases are subject to a few restrictions. For example, they must be quoted if
    they are SQL keywords, entirely numeric, or contain spaces or other special characters
    (an alias can consist of several words if you want to use a descriptive phrase).
    The following statement retrieves the same data values as the preceding one but
    uses phrases to name the output columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If MySQL complains about a single-word alias, the word probably is reserved.
    Quoting the alias should make it legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Column aliases also are useful for programming purposes. If you write a program
    that fetches rows into an array and accesses them by numeric column indexes, the
    presence or absence of column aliases makes no difference because aliases don’t
    change the positions of columns within the result set. However, aliases make a
    big difference if you access output columns by name because aliases change those
    names. Exploit this fact to give your program easier names to work with. For example,
    if your query displays reformatted message time values from the `mail` table using
    the expression `DATE_FORMAT(t,''%M %e, %Y'')`, that expression is also the name
    you must use when referring to the output column. In a Perl hashref, for example,
    you’d access it as `$ref->{"DATE_FORMAT(t,''%M %e, %Y'')"}`. That’s inconvenient.
    Use `AS` `date_sent` to give the column an alias and you can refer to it more
    easily as `$ref->{date_sent}`. Here’s an example that shows how a Perl DBI script
    might process such values. It retrieves rows into a hash and refers to column
    values by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, you’d do something like this, where the argument to `getString()`
    names the column to access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Recipe 4.4](ch04.xhtml#nch-api-api-statement) shows for each of our programming
    languages how to fetch rows into data structures that permit access to column
    values by name. The *select* directory of the `recipes` distribution has examples
    that show how to do this for the `mail` table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot refer to column aliases in a `WHERE` clause. Thus, the following
    statement is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The error occurs because an alias names an *output* column, whereas a `WHERE`
    clause operates on *input* columns to determine which rows to select for output.
    To make the statement legal, replace the alias in the `WHERE` clause with the
    same column or expression that the alias represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 5.3 Sorting Query Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to control how your query results are sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MUse an `ORDER` `BY` clause to tell it how to sort result rows.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you select rows, the MySQL server is free to return them in any order
    unless you instruct it otherwise by saying how to sort the result. There are lots
    of ways to use sorting techniques, as [Chapter 9](ch09.xhtml#nch-sort) explores
    in detail. Briefly, to sort a result set, add an `ORDER` `BY` clause that names
    the column or columns to use for sorting. This statement names multiple columns
    in the `ORDER` `BY` clause to sort rows by host and by user within each host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'MySQL sorts rows in the ascending order by default. To sort a column in reverse
    (descending) order, add the keyword `DESC` after its name in the `ORDER` `BY`
    clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 5.4 Removing Duplicate Rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Output from a query contains duplicate rows. You want to eliminate them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `DISTINCT`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some queries produce results containing duplicate rows. For example, to see
    who sent mail, query the `mail` table like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That result is heavily redundant. To remove the duplicate rows and produce
    a set of unique values, add `DISTINCT` to the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To count the number of unique values in a column, use `COUNT(DISTINCT)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`DISTINCT` works with multiple-column output, too. The following query shows
    which dates are represented in the `mail` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.xhtml#nch-sum) revisits `DISTINCT` and `COUNT(DISTINCT)`.
    [Chapter 18](ch18.xhtml#nch-dups) discusses duplicate removal in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Working with NULL Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re trying to to compare column values to `NULL`, but it isn’t working.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the proper comparison operators: `IS` `NULL`, `IS` `NOT` `NULL`, or `<=>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditions that involve `NULL` are special because `NULL` means <q>unknown value.</q>
    Consequently, comparisons such as *`value`* `=` `NULL` or *`value`* `<>` `NULL`
    always produce a result of `NULL` (not true or false) because it’s impossible
    to tell whether they are true or false. Even `NULL` `=` `NULL` produces `NULL`
    because you can’t determine whether one unknown value is the same as another.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look for values that are or are not `NULL`, use the `IS` `NULL` or `IS`
    `NOT` `NULL` operator. Suppose that a table named `expt` contains experimental
    results for subjects who are to be given four tests each and that represents tests
    not yet administered using `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that `=` and `<>` fail to identify `NULL` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the statements like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The MySQL-specific `<=>` null-safe comparison operator, unlike the `=` operator,
    is true even for two `NULL` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes it’s useful to map `NULL` values onto some other value that has more
    meaning in the context of your application. For example, use `IF()` to map `NULL`
    onto the string `Unknown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This `IF()`-based mapping technique works for any kind of value, but it’s especially
    useful with `NULL` values because `NULL` tends to be given a variety of meanings:
    unknown, missing, not yet determined, out of range, and so forth. Choose the label
    that makes the most sense in a given context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding query can be written more concisely using `IFNULL()`, which tests
    its first argument and returns it if it’s not `NULL`, or returns its second argument
    otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, these two tests are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: From a readability standpoint, `IF()` often is easier to understand than `IFNULL()`.
    From a computational perspective, `IFNULL()` is more efficient because *`expr1`*
    need not be evaluated twice, as happens with `IF()`.
  prefs: []
  type: TYPE_NORMAL
- en: One more way to map `NULL` values is to use function `COALESCE` that returns
    first not-null element from the list of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NULL` values also behave differently when used by sorting and summary operations.
    See [Recipe 9.11](ch09.xhtml#nch-sort-sort-float) and [Recipe 10.9](ch10.xhtml#nch-sum-sum-null).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Writing Comparisons Involving NULL in Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re writing a program that looks for rows containing a specific value, but
    it fails when the value is `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choose the proper comparison operator according to whether the comparison value
    is or is not `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 5.5](#nch-select-select-null) discusses the need to use different comparison
    operators for `NULL` values than for non-`NULL` values in SQL statements. This
    issue leads to a subtle danger when constructing statement strings within programs.
    If a value stored in a variable might represent a `NULL` value, you must account
    for that when you use the value in comparisons. For example, in Python, `None`
    represents a `NULL` value, so to construct a statement that finds rows in the
    `expt` table matching some arbitrary value in a `score` variable, you cannot do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement fails when `score` is `None` because the resulting statement
    becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A comparison of `score` `=` `NULL` is never true, so that statement returns
    no rows. To take into account the possibility that `score` could be `None`, construct
    the statement using the appropriate comparison operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in statements as follows for `score` values of `None` (`NULL`)
    or 43 (not `NULL`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For inequality tests, set `operator` like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 5.7 Using Views to Simplify Table Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to refer to values calculated from expressions without writing the
    expressions each time you retrieve them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a view defined such that its columns perform the desired calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that you retrieve several values from the `mail` table, using expressions
    to calculate most of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you must issue such a statement often, it’s inconvenient to keep writing
    the expressions. To make the statement results easier to access, use a view, which
    is a virtual table that contains no data. Instead, it’s defined as the `SELECT`
    statement that retrieves the data of interest. The following view, `mail_view`,
    is equivalent to the `SELECT` statement just shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the view contents, refer to it like any other table. You can select
    some or all of its columns, add a `WHERE` clause to restrict which rows to retrieve,
    use `ORDER` `BY` to sort the rows, and so forth. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Stored programs provide another way to encapsulate calculations (see [Recipe
    11.2](ch11.xhtml#nch-routines-routines-encapsulation)).
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Selecting Data from Multiple Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The answer to a question requires data from more than one table, so you need
    to select data from multiple tables.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a join or a subquery.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The queries shown so far select data from a single table, but sometimes you
    must retrieve information from multiple tables. Two types of statements that accomplish
    this are joins and subqueries. A join matches rows in one table with rows in another
    and enables you to retrieve output rows that contain columns from either or both
    tables. A subquery is one query nested within another, to perform a comparison
    between values selected by the inner query against values selected by the outer
    query.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe shows a couple brief examples to illustrate the basic ideas. Other
    examples appear elsewhere: subqueries are used in various examples throughout
    the book (for example, [Recipe 5.10](#nch-select-select-limit-sort) and [Recipe
    10.6](ch10.xhtml#nch-sum-sum-assoc)). [Chapter 16](ch16.xhtml#nch-multi) discusses
    joins in detail, including some that select from more than two tables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples use the `profile` table introduced in [Chapter 4](ch04.xhtml#nch-api).
    Recall that it lists the people on your buddy list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s extend use of the `profile` table to include another table named `profile_contact`.
    This second table indicates how to contact people listed in the `profile` table
    via various social media services and is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The table associates each row with the proper `profile` row via the `profile_id`
    column. The `service` and `contact_name` columns name the media service and the
    name to use for contacting the given person via that service. For the examples,
    assume that the table contains these rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A question that requires information from both tables is, <q>For each person
    in the `profile` table, show me which services I can use to get in touch, and
    the contact name for each service.</q> To answer this question, use a join. Select
    from both tables and match rows by comparing the `id` column from the `profile`
    table with the `profile_id` column from the `profile_contact` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `FROM` clause indicates the tables from which to select data, and the `ON`
    clause tells MySQL which columns to use to find matches between the tables. In
    the result, rows include the `id` and `name` columns from the `profile` table,
    and the `service` and `contact_name` columns from the `profile_contact` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another question that requires both tables to answer: <q>List all the
    `profile_contact` records for Nancy.</q> To pull the proper rows from the `profile_contact`
    table, you need Nancy’s ID, which is stored in the `profile` table. To write the
    query without looking up Nancy’s ID yourself, use a subquery that, given her name,
    looks it up for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here the subquery appears as a nested `SELECT` statement enclosed within parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Selecting Rows from the Beginning, End, or Middle of Query Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want only certain rows from a result set, such as the first one, the last
    five, or rows 21 through 40.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `LIMIT` clause, perhaps in conjunction with an `ORDER` `BY` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL supports a `LIMIT` clause that tells the server to return only part of
    a result set. `LIMIT` is a MySQL-specific extension to SQL that is extremely valuable
    when your result set contains more rows than you want to see at a time. It enables
    you to retrieve an arbitrary section of a result set. Typical `LIMIT` uses include
    the following kinds of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Answering questions about first or last, largest or smallest, newest or oldest,
    least or most expensive, and so forth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting a result set into sections so that you can process it one piece at
    a time. This technique is common in web applications for displaying a large search
    result across several pages. Showing the result in sections enables display of
    smaller, easier-to-understand pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following examples use the `profile` table shown in [Recipe 5.8](#nch-select-select-join).
    To see the first *`n`* rows of a `SELECT` result, add `LIMIT` *`n`* to the end
    of the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`LIMIT` *`n`* means <q>return *at most* *`n`* rows.</q> If you specify `LIMIT`
    `10`, and the result set has only four rows, the server returns four rows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rows in the preceding query results are returned in no particular order,
    so they may not be very meaningful. A more common technique uses `ORDER` `BY`
    to sort the result set and `LIMIT` to find smallest and largest values. For example,
    to find the row with the minimum (earliest) birth date, sort by the `birth` column,
    then add `LIMIT` `1` to retrieve the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This works because MySQL processes the `ORDER` `BY` clause to sort the rows,
    then applies `LIMIT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain rows from the end of a result set, sort them in the opposite order.
    The statement that finds the row with the most recent birth date is similar to
    the previous one, except that the sort order is descending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the earliest or latest birthday within the calendar year, sort by the
    month and day of the `birth` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can obtain the same information by running these statements without `LIMIT`
    and ignoring everything but the first row. The advantage of `LIMIT` is that the
    server returns only the first row, and the extra rows don’t cross the network
    at all. This is much more efficient than retrieving an entire result set, only
    to discard all but one row.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pull rows from the middle of a result set, use the two-argument form of
    `LIMIT`, which enables you to pick an arbitrary section of rows. The arguments
    indicate how many rows to skip and how many to return. This means that you can
    use `LIMIT` to do such things as skip two rows and return the next one, thus answering
    questions such as <q>What is the *third-*smallest or *third-*largest value?</q>
    These are questions that `MIN()` or `MAX()` are not suited for, but are easy with
    `LIMIT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The two-argument form of `LIMIT` also makes it possible to partition a result
    set into smaller sections. For example, to retrieve 20 rows at a time from a result,
    issue a `SELECT` statement repeatedly, but vary its `LIMIT` clause like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This way of using `LIMIT` clause can cause performance degradations for large
    data sets, because it requires reading minimum `OFFSET` plus `LIMIT` rows. This
    means that to get result for the `LIMIT 0, 20` statement MySQL will have to read
    20 rows from the table, to get result of `LIMIT 20, 20` it will need to read 40
    rows, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the number of rows in a result set so that you can determine the
    number of sections, issue a `COUNT()` statement first. For example, to display
    `profile` table rows in name order, three at a time, you can find out how many
    there are with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'That tells you that there are three sets of rows (the last with fewer than
    three rows), which you can retrieve as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LIMIT` is useful in combination with `RAND()` to make random selections from
    a set of items. See [Recipe 17.8](ch17.xhtml#nch-stats-stats-rand-items).'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `LIMIT` to restrict the effect of a `DELETE` or `UPDATE` statement
    to a subset of the rows that would otherwise be deleted or updated, respectively.
    For more information about using `LIMIT` for duplicate row removal, see [Recipe
    18.5](ch18.xhtml#nch-dups-dups-elim-table).
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 What to Do When LIMIT and Final Result Require Different Sort Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LIMIT` usually works best in conjunction with an `ORDER` `BY` clause that
    sorts rows. But sometimes that sort order differs from what you want for the final
    result.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `LIMIT` in a subquery to retrieve the desired rows, then use the outer query
    to sort them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want the last four rows of a result set, you can obtain them easily
    by sorting the set in reverse order and using `LIMIT` `4`. The following statement
    returns the names and birth dates for the four people in the `profile` table who
    were born most recently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'But that requires sorting the `birth` values in descending order to place them
    at the head of the result set. What if you want the output rows to appear in ascending
    order instead? Use the `SELECT` as a subquery of an outer statement that re-sorts
    the rows in the desired final order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`AS` `t` is used here because any table referred to in the `FROM` clause must
    have a name, even a <q>derived</q> table produced from a subquery.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.11 Calculating LIMIT Values from Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use expressions to specify the arguments for `LIMIT`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LIMIT` arguments must be literal integers—unless you issue the statement in
    a context that permits the statement string to be constructed dynamically. In
    that case, you can evaluate the expressions yourself and insert the resulting
    values into the statement string.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arguments to `LIMIT` must be literal integers, not expressions. Statements
    such as the following are illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The same <q>no expressions permitted</q> principle applies if you use an expression
    to calculate a `LIMIT` value in a program that constructs a statement string.
    You must evaluate the expression first, and then place the resulting value in
    the statement. For example, if you produce a statement string in Perl or PHP as
    follows, an error will result when you attempt to execute the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid the problem, evaluate the expression first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Or do this (don’t omit the parentheses or the expression won’t evaluate properly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To construct a two-argument `LIMIT` clause, evaluate both expressions before
    placing them into the statement string.
  prefs: []
  type: TYPE_NORMAL
- en: 5.12 Combining Two or More SELECT Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to combine rows, retrieved by two or more `SELECT` statements into
    one result set.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `UNION` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mail` table stores user names and hosts of the email senders and recipients.
    But what if we want to know all the user and host combinations possible?
  prefs: []
  type: TYPE_NORMAL
- en: Naive approach would be to choose either sender or receiver pairs. But if we
    perform even very basic test by comparing number of unique user-host combinations
    we will find out that it is different for each of directions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We also do not know if our table stores emails from users who only send them
    and for users who receive but never send.
  prefs: []
  type: TYPE_NORMAL
- en: To get the full list we need to select pairs for both sender and receiver, then
    remove duplicates. SQL clause `UNION DISTINCT` and its short form `UNION` does
    exactly that. It combines results of two or more `SELECT` queries that select
    the same number of columns of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: By default `UNION` uses column names of the first `SELECT` for the full result
    set header, but we can also use aliases as discussed in [Recipe 5.2](#nch-select-select-column-alias).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You may sort as individual query, participating in `UNION`, as well the whole
    result. If you do not want to remove duplicates from the result use clause `UNION
    ALL`.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this lets create a query that will find four users who sent the
    highest number of emails and four users who recieved the highest number of emails,
    then sort result of the union by the user name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-select-select-union-concat_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenate user and host into email address of the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-select-select-union-order_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Order first `SELECT` result by number of emails descending and limit number
    of retrieved rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-select-select-union-order2_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Order result of the second `SELECT`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-select-select-union-order-union_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Order result of the `UNION` by the user email address.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_nch-select-select-union-duplicate_co)'
  prefs: []
  type: TYPE_NORMAL
- en: We used clause `UNION ALL` instead of `UNION [DISTINCT]`, therefore we have
    two entries for `gene@venus` in the result. This user is in the top list of those
    who send emails and also of those who recieve emails.
  prefs: []
  type: TYPE_NORMAL
- en: 5.13 Selecting Results of Subqueries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to retrieve not only table columns, but also results of queries that
    use these columns.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use subquery in the column list.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that you want to know not only how many emails sent a particular user,
    but also how many emails they received. You cannot do it without accessing the
    table `mail` two times: one to count how many emails were sent and second to count
    how many emails were received.'
  prefs: []
  type: TYPE_NORMAL
- en: One of solutions for this issue is to use subqueries in the column list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-select-select-subqueries-sent_co)'
  prefs: []
  type: TYPE_NORMAL
- en: First we are retrieved a user name and a host of the sender and count number
    of emails that they sent.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-select-select-subqueries-received_co)'
  prefs: []
  type: TYPE_NORMAL
- en: To find the number of emails that this user received we are using subquery to
    the same table `mail`. In the `WHERE` clause we select only those rows where receiver
    has the same credentials as the sender in the main query.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-select-select-subqueries-received_alias_co)'
  prefs: []
  type: TYPE_NORMAL
- en: A subquery in the column list must have its own alias.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-select-select-subqueries-group_co)'
  prefs: []
  type: TYPE_NORMAL
- en: To display statistics per user we use clause `GROUP BY`, so result is groupped
    by each user name and host. We discuss `GROUP BY` clause in detail in [Chapter 10](ch10.xhtml#nch-sum).
  prefs: []
  type: TYPE_NORMAL
