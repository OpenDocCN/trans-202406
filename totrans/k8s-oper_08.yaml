- en: Chapter 8\. Operator Lifecycle Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have written an Operator, it’s time to turn your attention to its installation
    and management. As there are multiple steps involved in deploying an Operator,
    including creating the deployment, adding the custom resource definitions, and
    configuring the necessary permissions, a management layer becomes necessary to
    facilitate the process.
  prefs: []
  type: TYPE_NORMAL
- en: Operator Lifecycle Manager (OLM) fulfills this role by introducing a packaging
    mechanism for delivering Operators and the necessary metadata for visualizing
    them in compatible UIs, including installation instructions and API hints in the
    form of CRD descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: OLM’s benefits extend beyond installation into Day 2 operations, including managing
    upgrades to existing Operators, providing a means to convey Operator stability
    through version channels, and the ability to aggregate multiple Operator hosting
    sources into a single interface.
  prefs: []
  type: TYPE_NORMAL
- en: We begin this chapter by introducing OLM and its interfaces, including both
    the CRDs that end users will interact with inside of the cluster and the packaging
    format it uses for Operators. After that, we will show you OLM in action, using
    it to connect to OperatorHub.io to install an Operator. We conclude the chapter
    with a developer-focused exploration of the process of writing the necessary metadata
    files to make an Operator available to OLM and test it against a local cluster.
  prefs: []
  type: TYPE_NORMAL
- en: OLM Custom Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, the CRDs owned by an Operator make up that Operator’s API. So,
    it makes sense to look at each of the CRDs that are installed by OLM and explore
    their uses.
  prefs: []
  type: TYPE_NORMAL
- en: ClusterServiceVersion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *ClusterServiceVersion* (CSV) is the primary metadata resource that describes
    an Operator. Each CSV represents a version of an Operator and contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: General metadata about the Operator, including its name, version, description,
    and icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator installation information, describing the deployments that are created
    and the permissions that are required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CRDs that are owned by the Operator as well as references to any CRDs the
    Operator is dependent on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations on the CRD fields to provide hints to users on how to properly specify
    values for the fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When learning about CSVs, it can be useful to relate the concepts to that of
    a traditional Linux system. You can think of a CSV as analogous to a Linux package,
    such as a Red Hat Package Manager (RPM) file. Like an RPM file, the CSV contains
    information on how to install the Operator and any dependencies it requires. Following
    this analogy, you can think of OLM as a management tool similar to yum or DNF.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect to understand is the relationship between a CSV and
    the Operator deployment resource it manages. Much like how a deployment describes
    the “pod template” for the pods it creates, a CSV contains a “deployment template”
    for the deployment of the Operator pod. This is a formal ownership in the Kubernetes
    sense of the word; if the Operator deployment is deleted, the CSV will recreate
    it to bring the cluster back to the desired state, similar to how a deployment
    will cause deleted pods to be recreated.
  prefs: []
  type: TYPE_NORMAL
- en: A ClusterServiceVersion resource is typically populated from a Cluster Service
    Version YAML file. We provide more details on how to write this file in [“Writing
    a Cluster Service Version File”](#writing_a_cluster_service_version_file).
  prefs: []
  type: TYPE_NORMAL
- en: CatalogSource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *CatalogSource* contains information for accessing a repository of Operators.
    OLM provides a utility API named `packagemanifests` for querying catalog sources,
    which provides a list of Operators and the catalogs in which they are found. It
    uses resources of this kind to populate the list of available Operators. The following
    is an example of using the `packagemanifests` API against the default catalog
    source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Subscription
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: End users create a *subscription* to install, and subsequently update, the Operators
    that OLM provides. A subscription is made to a *channel*, which is a stream of
    Operator versions, such as “stable” or “nightly.”
  prefs: []
  type: TYPE_NORMAL
- en: To continue with the earlier analogy to Linux packages, a subscription is equivalent
    to a command that installs a package, such as `yum install`. An installation command
    through yum will typically refer to the package by name rather than to a specific
    version, leaving the determination of the latest package to yum itself. In the
    same way, a subscription to an Operator by name and its channel lets OLM resolve
    the version based on what is available in that particular channel.
  prefs: []
  type: TYPE_NORMAL
- en: Users configure a subscription with an *approval mode*. This value, set to either
    `manual` or `automatic`, tells OLM if manual user review is required before an
    Operator is installed. If set to `manual approval`, OLM-compatible user interfaces
    present the user with the details of the resources OLM will create during the
    Operator installation. The user has the option of approving or rejecting the Operator,
    and OLM takes the appropriate next steps.
  prefs: []
  type: TYPE_NORMAL
- en: InstallPlan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A subscription creates an *InstallPlan*, which describes the full list of resources
    that OLM will create to satisfy the CSV’s resource requirements. For subscriptions
    set to require manual approval, the end user sets an approval on this resource
    to inform OLM that the installation should proceed. Otherwise, users do not need
    to explicitly interact with these resources.
  prefs: []
  type: TYPE_NORMAL
- en: OperatorGroup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: End users control Operator multitenancy through an *OperatorGroup*. These designate
    namespaces that may be accessed by an individual Operator. In other words, an
    Operator belonging to an OperatorGroup will not react to custom resource changes
    in a namespace not indicated by the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you can use OperatorGroups for fine-grained control for a set of namespaces,
    they are most commonly used in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: To scope an Operator to a single namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow an Operator to run globally across all namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following definition creates a group that scopes Operators
    within it to the single namespace `ns-alpha`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Omitting the designator entirely results in a group that will cover all namespaces
    in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_operator_lifecycle_manager_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that, as a Kubernetes resource, the OperatorGroup must still reside in
    a specific namespace. However, the lack of the `targetNamespaces` designation
    means the OperatorGroup will cover all namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The two examples shown here cover the majority of use cases; creating fine-grained
    OperatorGroups scoped to more than one specific namespace is outside the scope
    of this book. You can find more information in [OLM’s GitHub repository](https://oreil.ly/ZBAou).
  prefs: []
  type: TYPE_NORMAL
- en: Installing OLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the rest of this chapter, we explore using and developing for OLM. As OLM
    is not installed by default in most Kubernetes distributions, the first step is
    to install the necessary resources to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: OLM is an evolving project. As such, be sure to consult its GitHub repository
    to find the latest installation instructions for [the current release](https://oreil.ly/It369).
    You can find the most recent releases on the OLM project’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: As of the current release (0.11.0), the installation performs two primary tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, you’ll need to install the CRDs required by OLM. These function as
    the API into OLM and provide the ability to configure external sources that provide
    Operators and the cluster-side resources used to make those Operators available
    to users. You create these through the `kubectl apply` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The examples here use the 0.11.0 release, which was the latest version at the
    time of writing; you can update these commands to use the most up-to-date version
    available at the time you’re reading the book.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to create all of the Kubernetes resources that make up OLM
    itself. These include the Operators that will drive OLM as well as the necessary
    RBAC resources (ServiceAccounts, ClusterRoles, etc.) for it to function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the CRD creation, you perform this step through the `kubectl apply`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify the installation by looking at the resources that were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using OLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve introduced the basic concepts around OLM, let’s see how to use
    it to install an Operator. We’ll use OperatorHub.io as the source repository for
    Operators. We cover OperatorHub.io in more detail in [Chapter 10](ch10.html#getting_involved),
    but for now the important thing to know is that it’s a community-curated list
    of publicly available Operators for use with OLM. In keeping with the Linux package
    analogy from earlier in the chapter, you can think of it as similar to an RPM
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing OLM creates a default catalog source in the `olm` namespace. You
    can verify that this source, named `operatorhubio-catalog`, exists by using the
    CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find further details about the source by using the `describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#comarker1-01)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the display name is simply “Community Operators,” rather than indicating
    anything about OperatorHub.io. This value appears in the output of the next command,
    when we look at the list of possible Operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'This catalog source is configured to read all of the Operators hosted on OperatorHub.io.
    You can use the `packagemanifest` utility API to get a list of the Operators that
    are found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#comarker1-02)'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, there are close to 80 Operators on OperatorHub.io. We
    truncated the output of this command for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, you’ll install the etcd Operator. The first step is to define
    an OperatorGroup to dictate which namespaces the Operator will manage. The etcd
    Operator you’re going to be using is scoped to a single namespace (you’ll see
    later how we determined that), so you’ll create a group for just the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the group using the `kubectl` `apply` command (this example assumes
    the YAML in the previous snippet is saved to a file named *all-og.yaml*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The creation of a subscription triggers the installation of an Operator. Before
    you can do that, you need to determine which channel you want to subscribe to.
    OLM provides channel information in addition to a wealth of other details about
    the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view this information by using the `packagemanifest` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#comarker1-03)'
  prefs: []
  type: TYPE_NORMAL
- en: The examples section of a package manifest contains a series of manifests that
    you can use to deploy custom resources defined by this Operator. For brevity,
    we have omitted them from this output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#comarker2)'
  prefs: []
  type: TYPE_NORMAL
- en: We cut out much of the file for readability. We’ll cover many of these fields
    when we talk about creating the CSV file in [“Writing a Cluster Service Version
    File”](#writing_a_cluster_service_version_file).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#comarker3)'
  prefs: []
  type: TYPE_NORMAL
- en: The install modes section describes the circumstances in which an end user may
    deploy this Operator. We will also cover these later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#comarker4)'
  prefs: []
  type: TYPE_NORMAL
- en: This particular channel offers an Operator that is configured to be run to watch
    the same namespace it is deployed in.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#comarker5)'
  prefs: []
  type: TYPE_NORMAL
- en: Along the same lines, end users cannot install this Operator to monitor all
    namespaces in the cluster. If you look around in the package manifest data you’ll
    find another channel named `clusterwide-alpha` that is suited to this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#comarker6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Name` field in this section indicates the name of the channel which is
    referenced by a subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Since this Operator comes from OperatorHub.io, it can be beneficial to view
    its page on the site directly. All of the data contained in the package manifest
    is displayed on the individual Operator’s page, but formatted in a more easily
    readable manner. You can check this out on the [etcd Operator page](https://oreil.ly/1bjkr).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have decided on a channel, the last step is to create the subscription
    resource itself. Here is an example manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_operator_lifecycle_manager_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This manifest installs the subscription, and thus the Operator deployment itself,
    in the default namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_operator_lifecycle_manager_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the Operator to be installed, as found by the `packagemanifest`
    API call.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_operator_lifecycle_manager_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `source` and `sourceNamespace` describe where to find the catalog source
    that provides the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_operator_lifecycle_manager_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: OLM will install Operators from the `singlenamespace-alpha` channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other resources, you create the subscription using `kubectl` `apply`
    (this command assumes the subscription YAML above is saved in a file named *sub.yaml*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Exploring the Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you create the subscription, a number of things happen. At the highest
    level of the resource hierarchy, OLM creates a ClusterServiceVersion resource
    in the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSV is effectively what the subscription installs—it’s the package, in
    the RPM analogy. OLM performs the Operator installation steps defined in the CSV
    to create the Operator pods themselves. Additionally, OLM will store information
    about events in this process, which you can view using the `describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The output here has been edited to fit the page. Your output will vary slightly
    and contain more data per event.
  prefs: []
  type: TYPE_NORMAL
- en: 'OLM is responsible for following the deployment template contained within the
    CSV to create the Operator pod itself. Continuing down the resource ownership
    hierarchy, you can see that OLM creates a deployment resource as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Viewing the details of the deployment explicitly shows the owner relationship
    between the CSV and this deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Unsurprisingly, the deployment creates a number of pods based on its resource
    definition. In the case of the etcd Operator, the CSV defines the deployment as
    requiring three pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize, creating the subscription caused the following to take place:'
  prefs: []
  type: TYPE_NORMAL
- en: OLM creates a CSV resource in the same namespace as the subscription. This CSV
    contains, among other things, the manifest for the deployment of the Operator
    itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OLM uses the deployment manifest to create a deployment resource for the Operator.
    The owner of that resource is the CSV itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment causes the creation of replica sets and pods for the Operator
    itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting an OLM-deployed Operator isn’t as straightforward as it is when working
    with simple deployment resources.
  prefs: []
  type: TYPE_NORMAL
- en: A deployment resource acts as installation instructions for pods. If a pod is
    removed, either by user intervention or because of an error on the pod itself,
    Kubernetes detects the difference between the desired state of the deployment
    and the actual number of pods.
  prefs: []
  type: TYPE_NORMAL
- en: In much the same way, the CSV resource acts as the installation instructions
    for the Operator. Often, a CSV indicates that a deployment must exist to fulfill
    this plan. If that deployment ceases to exist, OLM takes the necessary steps to
    make the actual state of the system match the CSV’s desired state.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, it’s not sufficient to simply delete the Operator’s deployment resource.
    Instead, an Operator deployed by OLM is deleted by deleting the CSV resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: OLM takes care of deleting the resources that the CSV created when it was originally
    deployed, including the Operator’s deployment resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you’ll need to delete the subscription to prevent OLM from installing
    new CSV versions in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: OLM Bundle Metadata Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An “OLM bundle” provides details on an Operator that can be installed. The
    bundle contains all the necessary information (for all the available versions
    of the Operator) to:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a flexible delivery structure for the Operator by offering one or more
    *channels* that a user can subscribe to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the CRDs required for the Operator to function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instruct OLM on how to create the Operator deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include additional information on each CRD spec field, including hints on how
    to render those fields in a UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three types of files included in an OLM bundle: custom resource definitions,
    Cluster Service Version files, and package manifest files.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom Resource Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the Operator requires its CRDs to function, the OLM bundle includes them.
    OLM installs the CRDs along with the Operator itself. You, as the OLM bundle developer,
    do not need to make any changes or additions to the CRD files beyond what already
    exists to support the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that only CRDs that are owned by the Operator should be included.
    Any dependent CRDs that are provided by other Operators will be installed automatically
    by OLM’s dependency resolution (the notion of required CRDs is addressed in [“Owned
    CRDs”](#owned_crds)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each CRD must be defined in its own file.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Service Version File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CSV file contains the bulk of the metadata about the Operator, including:'
  prefs: []
  type: TYPE_NORMAL
- en: How to deploy the Operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of CRDs that the Operator uses (those that it owns as well as dependencies
    from other Operators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata about the Operator, including a description, logo, its maturity level,
    and related links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the large role this file plays, we cover details on how to write one in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Package Manifest File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The package manifest file describes a list of channels that point to particular
    Operator versions. It is up to the Operator owners to determine the breakdown
    of channels and their respective delivery cadence. We strongly recommend that
    channels set expectations around stability, features, and rate of changes.
  prefs: []
  type: TYPE_NORMAL
- en: Users subscribe to channels. OLM will use the package manifest to determine
    if a new version of the Operator is available in a subscribed-to channel and allow
    the user to take steps to update as appropriate. We’ll get into more detail about
    this file in [“Writing a Package Manifest File”](#writ_pack_manifest_file).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Cluster Service Version File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each version of an Operator will have its own Cluster Service Version file.
    The CSV file is a standard Kubernetes manifest of kind ClusterServiceVersion,
    which is one of the custom resources that OLM provides.
  prefs: []
  type: TYPE_NORMAL
- en: The resources in this file provide OLM with information about a specific Operator
    version, including installation instructions and extra details on how the user
    interacts with the Operator’s CRDs.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a File Skeleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the amount of data included in a CSV file, the easiest starting point
    is to use the Operator SDK to generate a skeleton. The SDK will build this skeleton
    with the basic structure of a Cluster Service Version file, and will populate
    it with as much data as it can determine about the Operator itself. It provides
    a good basis from which you can flesh out the remaining details.
  prefs: []
  type: TYPE_NORMAL
- en: As each CSV corresponds to a particular Operator version, that version information
    is reflected in the filename scheme. The filename pattern is to use the Operator
    name and append the semantic version number. For example, a CSV file for the Visitors
    Site Operator will be named something like *visitors-operator.v1.0.0.yaml*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the Operator SDK to populate the skeleton CSV file with information
    about a specific Operator, you must run the generation command from the root of
    the Operator project source code. The general form of this command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Again, is it up to the Operator’s development team to determine their own version
    numbering policy. For consistency and general user-friendliness, we recommend
    that Operator releases follow [Semantic Versioning](https://semver.org) principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the CSV generation command on the Visitors Site Operator produces the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Even with only the base CSV structure, the generated file is already fairly
    detailed. At a high level, it includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: References to all CRDs the Operator owns (in other words, those defined in the
    Operator project)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A partial definition for the Operator’s Deployment resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of RBAC rules that the Operator requires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicators describing the scope of namespaces the Operator will watch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example custom resource (found in `metadata.annotations.alm-examples`) that
    you can modify for your needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We dive deeper into each of these components and the sorts of changes you should
    make to them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The SDK will not know the name of the image to use for the Operator itself.
    The skeleton file includes the field `image: REPLACE_IMAGE` in the deployment
    descriptor. You must update this value to point to a hosted image of the Operator
    (for example, on Docker Hub or Quay.io) that OLM will deploy.'
  prefs: []
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned, the `metadata.annotations.alm-examples` field contains
    an example for each CRD that the Operator owns. The SDK will initially populate
    this field using the custom resource manifest found in the Operator project’s
    *deploy/crds* directory. Be sure to review and flesh out this example with actual
    data that end users can further customize to their needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from `alm-examples`, you can find the remainder of the Operator’s metadata
    under the `spec` section of the manifest. The output of the SDK’s generation command
    highlights three specific fields as required:'
  prefs: []
  type: TYPE_NORMAL
- en: keywords
  prefs: []
  type: TYPE_NORMAL
- en: A list of categories describing the Operator; compatible UIs use this for discovery
  prefs: []
  type: TYPE_NORMAL
- en: maintainers
  prefs: []
  type: TYPE_NORMAL
- en: A list of name and email pairings for the maintainers of the Operator codebase
  prefs: []
  type: TYPE_NORMAL
- en: provider
  prefs: []
  type: TYPE_NORMAL
- en: The name of the publishing entity for the Operator
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet from the etcd Operator demonstrates the three required fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We also encourage you to provide the following metadata fields, which produce
    a more robust listing in catalogs such as OperatorHub.io:'
  prefs: []
  type: TYPE_NORMAL
- en: displayName
  prefs: []
  type: TYPE_NORMAL
- en: A user-friendly name for the Operator
  prefs: []
  type: TYPE_NORMAL
- en: description
  prefs: []
  type: TYPE_NORMAL
- en: A string describing the Operator’s functionality; you can use YAML constructs
    for multiline strings to provide further display information
  prefs: []
  type: TYPE_NORMAL
- en: version
  prefs: []
  type: TYPE_NORMAL
- en: The semantic version of the Operator, which should be incremented each time
    a new Operator image is published
  prefs: []
  type: TYPE_NORMAL
- en: replaces
  prefs: []
  type: TYPE_NORMAL
- en: The version, if any, of the Operator that this CSV updates
  prefs: []
  type: TYPE_NORMAL
- en: icon
  prefs: []
  type: TYPE_NORMAL
- en: A base64–encoded image used by compatible UIs
  prefs: []
  type: TYPE_NORMAL
- en: maturity
  prefs: []
  type: TYPE_NORMAL
- en: The maturity level of the Operator included in this release, such as `alpha`,
    `beta`, or `stable`
  prefs: []
  type: TYPE_NORMAL
- en: links
  prefs: []
  type: TYPE_NORMAL
- en: A list of relevant links for the Operator, such as documentation, quick start
    guides, or blog entries
  prefs: []
  type: TYPE_NORMAL
- en: minKubeVersion
  prefs: []
  type: TYPE_NORMAL
- en: The minimum version of Kubernetes that the Operator must be deployed on, using
    the format “Major.Minor.Patch” (e.g., 1.13.0)
  prefs: []
  type: TYPE_NORMAL
- en: Owned CRDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to install an Operator, OLM must know about all of the CRDs it uses.
    These come in two forms: those owned by the Operator and those that are used as
    dependencies (in CSV terms, these are referred to as “required” CRDs; we will
    cover these in the next section).'
  prefs: []
  type: TYPE_NORMAL
- en: The SDK skeleton generation adds the `spec.customresourcedefinitions` section
    to the CSV file. It also populates the `owned` section with entries for each CRD
    defined by the Operator, including identifying information such as `kind`, `name`,
    and `version`. However, there are more fields that you must manually add before
    the OLM bundle is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are required fields that you must set for each owned CRD:'
  prefs: []
  type: TYPE_NORMAL
- en: displayName
  prefs: []
  type: TYPE_NORMAL
- en: The user-friendly name of the custom resource
  prefs: []
  type: TYPE_NORMAL
- en: description
  prefs: []
  type: TYPE_NORMAL
- en: Information about what the custom resource represents
  prefs: []
  type: TYPE_NORMAL
- en: resources
  prefs: []
  type: TYPE_NORMAL
- en: A list of Kubernetes resource types that will be created by the custom resource
  prefs: []
  type: TYPE_NORMAL
- en: The `resources` list does not need to be exhaustive. Rather, it should only
    list visible resources that are relevant to the user. For example, you should
    list things an end user interacts with, such as service and deployment resources,
    but omit an internal ConfigMap that the user does not directly manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: You only need to include one instance of each resource type, regardless of how
    many resources of that type are created by the Operator. For example, if the custom
    resource creates multiple deployments, you only need to list the deployment resource
    type once.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example list for a custom resource that creates one or more deployments
    and services is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two more fields you need to add to each owned resource: `specDescriptors`
    and `statusDescriptors`. These fields provide additional metadata about the `spec`
    and `status` fields that will be present in the custom resource. Compatible UIs
    can use this additional information to render an interface for users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each field in the custom resource’s spec, add an entry to the `specDescriptors`
    field. Each entry should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: displayName
  prefs: []
  type: TYPE_NORMAL
- en: The user-friendly name of the field
  prefs: []
  type: TYPE_NORMAL
- en: description
  prefs: []
  type: TYPE_NORMAL
- en: Information about what the field represents
  prefs: []
  type: TYPE_NORMAL
- en: path
  prefs: []
  type: TYPE_NORMAL
- en: The dot-delimited path of the field in the object
  prefs: []
  type: TYPE_NORMAL
- en: x-descriptors
  prefs: []
  type: TYPE_NORMAL
- en: UI component information about the field’s capabilities
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](#commonly_used_spec_descriptors) lists the descriptors that are
    commonly supported by compatible UIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Commonly used spec descriptors
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Descriptor string |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean switch | `urn:alm:descriptor:com.tectonic.ui:booleanSwitch` |'
  prefs: []
  type: TYPE_TB
- en: '| Checkbox | `urn:alm:descriptor:com.tectonic.ui:checkbox` |'
  prefs: []
  type: TYPE_TB
- en: '| Endpoint list | `urn:alm:descriptor:com.tectonic.ui:endpointList` |'
  prefs: []
  type: TYPE_TB
- en: '| Image pull policy | `urn:alm:descriptor:com.tectonic.ui:imagePullPolicy`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Label | `urn:alm:descriptor:com.tectonic.ui:label` |'
  prefs: []
  type: TYPE_TB
- en: '| Namespace selector | `urn:alm:descriptor:com.tectonic.ui:namespaceSelector`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Node affinity | `urn:alm:descriptor:com.tectonic.ui:nodeAffinity` |'
  prefs: []
  type: TYPE_TB
- en: '| Number | `urn:alm:descriptor:com.tectonic.ui:number` |'
  prefs: []
  type: TYPE_TB
- en: '| Password | `urn:alm:descriptor:com.tectonic.ui:password` |'
  prefs: []
  type: TYPE_TB
- en: '| Pod affinity | `urn:alm:descriptor:com.tectonic.ui:podAffinity` |'
  prefs: []
  type: TYPE_TB
- en: '| Pod anti-affinity | `urn:alm:descriptor:com.tectonic.ui:podAntiAffinity`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Resource requirements | `urn:alm:descriptor:com.tectonic.ui:resourceRequirements`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Selector | `urn:alm:descriptor:com.tectonic.ui:selector:` |'
  prefs: []
  type: TYPE_TB
- en: '| Text | `urn:alm:descriptor:com.tectonic.ui:text` |'
  prefs: []
  type: TYPE_TB
- en: '| Update strategy | `urn:alm:descriptor:com.tectonic.ui:updateStrategy` |'
  prefs: []
  type: TYPE_TB
- en: The structure of the `statusDescriptors` field is similar, including the same
    fields you need to specify. The only difference is the set of valid descriptors;
    these are listed in [Table 8-2](#commonly_used_status_descriptors).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Commonly used status descriptors
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Descriptor string |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Conditions | `urn:alm:descriptor:io.kubernetes.conditions` |'
  prefs: []
  type: TYPE_TB
- en: '| k8s phase reason | `urn:alm:descriptor:io.kubernetes.phase:reason` |'
  prefs: []
  type: TYPE_TB
- en: '| k8s phase | `urn:alm:descriptor:io.kubernetes.phase` |'
  prefs: []
  type: TYPE_TB
- en: '| Pod count | `urn:alm:descriptor:com.tectonic.ui:podCount` |'
  prefs: []
  type: TYPE_TB
- en: '| Pod statuses | `urn:alm:descriptor:com.tectonic.ui:podStatuses` |'
  prefs: []
  type: TYPE_TB
- en: '| Prometheus endpoint | `urn:alm:descriptor:prometheusEndpoint` |'
  prefs: []
  type: TYPE_TB
- en: '| Text | `urn:alm:descriptor:text` |'
  prefs: []
  type: TYPE_TB
- en: '| W3 link | `urn:alm:descriptor:org.w3:link` |'
  prefs: []
  type: TYPE_TB
- en: 'As an example, the following snippet contains a subset of the descriptors for
    the etcd Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Required CRDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom resources that are used by an Operator but not owned by it are designated
    as *required*. When installing an Operator, OLM will find the appropriate Operator
    that provides a required CRD and install it. This allows Operators to maintain
    a limited scope while utilizing composition and dependency resolution when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The required section of a CSV is optional. Only Operators that require the use
    of other, non-Kubernetes resources need to include this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each required CRD is specified using its:'
  prefs: []
  type: TYPE_NORMAL
- en: name
  prefs: []
  type: TYPE_NORMAL
- en: The full name used to identify the required CRD
  prefs: []
  type: TYPE_NORMAL
- en: version
  prefs: []
  type: TYPE_NORMAL
- en: The version of the CRD desired
  prefs: []
  type: TYPE_NORMAL
- en: kind
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes resource kind; displayed to users in compatible UIs
  prefs: []
  type: TYPE_NORMAL
- en: displayName
  prefs: []
  type: TYPE_NORMAL
- en: The user-friendly name of the field; displayed to users in compatible UIs
  prefs: []
  type: TYPE_NORMAL
- en: description
  prefs: []
  type: TYPE_NORMAL
- en: Information on how the required CRD is used; displayed to users in compatible
    UIs
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following indicates an EtcdCluster is a required CRD for a
    different Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: One entry is needed under the `required` field for each required CRD.
  prefs: []
  type: TYPE_NORMAL
- en: Install Modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The install modes section of a CSV tells OLM how the Operator can be deployed.
    There are four options, all of which must be present in the `installModes` field
    with their own flag indicating whether or not they are supported. The Operator
    SDK includes a default set of values for each of these options when generating
    a CSV.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following installation modes are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: OwnNamespace
  prefs: []
  type: TYPE_NORMAL
- en: The Operator can be deployed to an OperatorGroup that selects its own namespace.
  prefs: []
  type: TYPE_NORMAL
- en: SingleNamespace
  prefs: []
  type: TYPE_NORMAL
- en: The Operator can be deployed to an OperatorGroup that selects one namespace.
  prefs: []
  type: TYPE_NORMAL
- en: MultiNamespace
  prefs: []
  type: TYPE_NORMAL
- en: The Operator can be deployed to an OperatorGroup that selects more than one
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: AllNamespaces
  prefs: []
  type: TYPE_NORMAL
- en: 'The Operator can be deployed to an OperatorGroup that selects all namespaces
    (defined as `targetNamespace: ""`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the proper way to structure this field, along with
    the default values set by the SDK during generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Versioning and Updating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: True to its name, each Cluster Service Version file represents a single version
    of an Operator. Subsequent versions of the Operator will each have their own CSV
    file. In many cases, this can be a copy of the previous version with the appropriate
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following describes the general changes you need to make between versions
    of an Operator (this is not an exhaustive list; take care to review the entire
    contents of the file to ensure no further changes are required):'
  prefs: []
  type: TYPE_NORMAL
- en: Change the new CSV filename to reflect the new version of the Operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `metadata.name` field of the CSV file with the new version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `spec.version` field with the new version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `spec.replaces` field to indicate the previous version of the CSV
    that is being upgraded by the new version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, the new CSV will refer to a newer image of the Operator itself.
    Be sure to update the `spec.containers.image` field as appropriate to refer to
    the correct image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the event of a CRD change, you may need to update the `specDescriptor` and
    `statusDescriptor` fields of the CRD reference in the CSV file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these changes will result in a new version of the Operator, users cannot
    access that version until it is present in a channel. Update the **.package.yaml*
    file to reference the new CSV file for the appropriate channels (see the next
    section for more information on this file).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Do not modify existing CSV files once they are released and in use by OLM. Make
    changes in a new version of the file instead, and propagate it to users through
    the use of channels.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Package Manifest File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compared to writing a Cluster Service Version file, writing a package manifest
    is significantly easier. A package file requires three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: packageName
  prefs: []
  type: TYPE_NORMAL
- en: The name of the Operator itself; this should match the value used in the CSV
    file
  prefs: []
  type: TYPE_NORMAL
- en: channels
  prefs: []
  type: TYPE_NORMAL
- en: A list of all channels for delivering versions of the Operator
  prefs: []
  type: TYPE_NORMAL
- en: defaultChannel
  prefs: []
  type: TYPE_NORMAL
- en: The name of the channel users should subscribe to by default
  prefs: []
  type: TYPE_NORMAL
- en: 'Each entry in the `channels` field is made up of two items:'
  prefs: []
  type: TYPE_NORMAL
- en: name
  prefs: []
  type: TYPE_NORMAL
- en: The name of the channel; this is what users will subscribe to
  prefs: []
  type: TYPE_NORMAL
- en: currentCSV
  prefs: []
  type: TYPE_NORMAL
- en: The full name (including the Operator name but not the *.yaml* suffix) of the
    CSV file that is currently installed through the channel
  prefs: []
  type: TYPE_NORMAL
- en: It is left to the Operator’s team to determine their policy for what channels
    will be supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example distributes the Visitors Site Operator through two channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Running Locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have written the necessary bundle files, the next step is to build
    the bundle and test it against a local cluster, such as one started by Minikube.
    In the following sections, we’ll describe the process of installing OLM into a
    cluster, building the OLM bundle, and subscribing to a channel to deploy the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers the changes you need to make to the cluster to run OLM,
    as well as configuring it to look at your repository of bundles. You only need
    to complete these steps once for a cluster; we cover iterative development and
    testing of an Operator in [“Building the OLM Bundle”](#building_the_olm_bundle).
  prefs: []
  type: TYPE_NORMAL
- en: Install the Marketplace Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Marketplace Operator imports Operators from an external data store. In this
    chapter, you’ll be using Quay.io to host your OLM bundles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Despite its name, the Marketplace Operator is not tied to a particular source
    of Operators. It simply acts as a conduit to pull Operators from any compatible
    external store. One such site is OperatorHub.io, which we discuss in [Chapter 10](ch10.html#getting_involved).
  prefs: []
  type: TYPE_NORMAL
- en: 'In keeping with the notion that CRDs represent an Operator’s API, installing
    the Marketplace Operator introduces two CRDs:'
  prefs: []
  type: TYPE_NORMAL
- en: The OperatorSource resource describes an external hosting registry for OLM bundles.
    In this example, we use Quay.io, a free image hosting site.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CatalogSourceConfig resource bridges between an OperatorSource and OLM itself.
    An OperatorSource automatically creates CatalogSourceConfig resources, and you
    do not need to explicitly interact with this type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similar to OLM, the Marketplace Operator is an evolving project. As such, be
    sure to consult [its GitHub repository](https://oreil.ly/VNOrU) to find the latest
    installation instructions for the current release.
  prefs: []
  type: TYPE_NORMAL
- en: 'As there are currently no formal releases of the Marketplace Operator, it is
    installed by cloning the upstream repository and using the manifests within:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify the installation by ensuring the `marketplace` namespace was
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Install Operator Courier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Operator Courier is a client-side tool used for building and pushing the OLM
    bundle to a repository. It is also used for verifying the contents of the bundle
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Operator Courier through the Python package installer `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can run Operator Courier from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Retrieve a Quay token
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quay.io is a free hosting site for container images. We will use Quay.io to
    host the OLM bundles to serve them to the Operator Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: New users can sign up for a free Quay.io account [via the website](https://quay.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for Operator Courier to push OLM bundles into your Quay.io account,
    you need an authentication token. While the token is accessible through the web
    UI, you can also use the following script to retrieve it from the command line,
    substituting your username and password as indicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: An interactive version of this script is provided in [this book’s GitHub repository](https://github.com/kubernetes-operators-book/chapters/blob/master/ch08/get-quay-token).
  prefs: []
  type: TYPE_NORMAL
- en: You will use this token later when pushing the bundle to Quay.io, so save it
    somewhere accessible. The output of the script provides a command to save it as
    an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Create the OperatorSource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An OperatorSource resource defines the external data store used to host Operator
    bundles. In this case, you will be defining an OperatorSource to point to your
    Quay.io account, which will provide access to its hosted OLM bundles.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample OperatorSource manifest follows; you should replace both instances
    of `<QUAY_USERNAME>` with your Quay.io username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_operator_lifecycle_manager_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Using your username here isn’t a hard requirement; it’s just a simple way to
    ensure uniqueness for the OperatorSource name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve written the OperatorSource manifest, create the resource using
    the following command (assuming the manifest file is named *operator-source.yaml*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the OperatorSource was deployed correctly, you can look in the `marketplace`
    namespace for a list of all known OperatorSources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#comarker1-04)'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no bundles at the endpoint when you create the source, the status
    will be `Failed`. You can ignore this for now; you’ll refresh this list later,
    once you’ve uploaded a bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The output shown here has been truncated for readability; your results may vary
    slightly.
  prefs: []
  type: TYPE_NORMAL
- en: When the OperatorSource is initially created, it may fail if there are no OLM
    bundles found in the user’s Quay.io application list. In a later step, you will
    create and deploy the bundles, after which the OperatorSource will start correctly.
    We included this step as a prerequisite since you only need to do it once; when
    updating an OLM bundle or creating new ones in the same Quay.io namespace, you
    will reuse the OperatorSource resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the OperatorSource creation results in the creation of a CatalogSource.
    No further action is required for this resource, but you can confirm its existence
    by checking in the `marketplace` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Building the OLM Bundle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve installed the initial prerequisites, the bulk of your time is spent
    on a build and test cycle. This section covers the steps necessary to build and
    host an OLM bundle on Quay.io.
  prefs: []
  type: TYPE_NORMAL
- en: Perform linting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OLM bundles are verified using Operator Courier’s `verify` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Push the bundle to Quay.io
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the metadata files pass verification and are ready to be tested, Operator
    Courier uploads the OLM bundle into your Quay.io account. There are a number of
    required parameters (and some optional arguments) when using the `push` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example push for the Visitors Site Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#comarker1-05)'
  prefs: []
  type: TYPE_NORMAL
- en: '`QUAY_TOKEN` is the full token, including the “basic” prefix. You can use the
    script we introduced earlier in this section to set this variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, bundles pushed to Quay.io in this fashion are marked as private.
    Navigate to the image at [*https://quay.io/application/*](https://quay.io/application/)
    and mark it as public so that it is accessible to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The Operator bundle is now ready for testing. For subsequent versions, update
    the `PACKAGE_VERSION` variable according to the new version of the CSV file (see
    [“Versioning and Updating”](#versioning_updating) for more information) and push
    a new bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Restart the OperatorSource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OperatorSource reads the list of Operators in the configured Quay.io account
    on startup. After uploading a new Operator or a new version of a CSV file, you’ll
    need to restart the OperatorSource pod to pick up the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pod’s name begins with the same name as the OperatorSource. Using the example
    OperatorSource from the previous section, with “jdob” as the Quay.io username,
    the following demonstrates how to restart the OperatorSource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#comarker1-06)'
  prefs: []
  type: TYPE_NORMAL
- en: The newly started pod name suffix differs from the original pod, confirming
    that a new pod has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any point, you can query the OperatorSource to see a list of its known Operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Installing the Operator Through OLM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you’ve configured the Marketplace Operator to retrieve your bundle, test
    it by creating a subscription to one of its supported channels. OLM reacts to
    the subscription and installs the corresponding Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Create the OperatorGroup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need an OperatorGroup to denote which namespaces the Operator should
    watch. It must exist in the namespace where you want to deploy the Operator. For
    simplicity while testing, the example OperatorGroup defined here deploys the Operator
    into the existing `marketplace` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Like with other Kubernetes resources, use the `kubectl` `apply` command to
    create the OperatorGroup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Create the subscription
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A subscription links the previous steps together by selecting an Operator and
    one of its channels. OLM uses this information to start the corresponding Operator
    pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a new subscription to the stable channel for
    the Visitors Site Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_operator_lifecycle_manager_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates the namespace the subscription will be created in.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_operator_lifecycle_manager_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Selects one of the channels defined in the package manifest.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_operator_lifecycle_manager_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies which OperatorSource to look at for the corresponding Operator and
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_operator_lifecycle_manager_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the OperatorSource’s namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the subscription using the `apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'OLM will be notified of the new subscription and will start the Operator pod
    in the `marketplace` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have truncated the output here for readability; your results may vary slightly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Running Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once OLM has started the Operator, you can test it by creating a custom resource
    of the same type that the Operator owns. Refer to Chapters [6](ch06.html#adapter_operators)
    and [7](ch07.html#operators_in_go_with_the_operator_sdk) for more information
    about testing a running Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Visitors Site Operator Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the OLM bundle files for the Visitors Site Operator in [the book’s
    GitHub repository](https://github.com/kubernetes-operators-book/chapters/tree/master/ch08).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two directories of note:'
  prefs: []
  type: TYPE_NORMAL
- en: '*bundle*'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains the actual OLM bundle files, including the CSV, CRD,
    and package files. You can use the process outlined in this chapter to build and
    deploy the Visitors Site Operator using these files.
  prefs: []
  type: TYPE_NORMAL
- en: '*testing*'
  prefs: []
  type: TYPE_NORMAL
- en: This directory contains the additional resources required to deploy an Operator
    from OLM. These include the OperatorSource, OperatorGroup, subscription, and a
    sample custom resource to test the Operator.
  prefs: []
  type: TYPE_NORMAL
- en: Readers are welcome to submit feedback, issues, and questions on these files
    through the Issues tab in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any piece of software, managing installation and upgrades is critical
    for Operators. Operator Lifecycle Manager fills this role, giving you a mechanism
    for discovering Operators, handling updates, and ensuring stability.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[OLM installation](https://oreil.ly/cu1IP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OLM repository](https://oreil.ly/1IN19)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Marketplace Operator repository](https://oreil.ly/VVvFM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Operator Courier repository](https://oreil.ly/d6XdP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
