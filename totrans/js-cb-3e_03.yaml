- en: Chapter 2\. Strings and Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here‚Äôs a trivia question for your next JavaScript party: how many data types
    are there in the world‚Äôs most popular language?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is *eight*, but they might not be what you expect. JavaScript‚Äôs
    eight data types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigInt` (for very large integers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol` (for unique identifiers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object` (the root of every other JavaScript type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined` (a variable that hasn‚Äôt been assigned a value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` (a missing object)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipes in this book feature all of these ingredients. In this chapter,
    you‚Äôll turn your focus to the text-manipulating power of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for an Existing, Nonempty String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to verify that a variable is defined, is a string, and is not empty
    before you use it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you start working with a string, you often need to validate that it‚Äôs
    safe to use. When you do, there are different questions you might ask.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make sure that your variable is a string (not just a variable
    that can be *converted* to a string), you use this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check that you have a nonempty string (not the zero-length string
    `''''`), you can tighten your verification like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you may want to reject strings that are made up of whitespace only,
    in which case you can use the `String.trim()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The order of your conditions is important. JavaScript uses *short-circuit evaluation*.
    That means it will only evaluate the second condition (the length check) if the
    first condition (the type check) succeeds. This is important because the length
    check will fail if `unknownVariable` is a different type of variable, like a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There‚Äôs a potential gap when using the `typeof` operator. It‚Äôs possible to
    circumvent the string test by using a `String` object instead of a string literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now the `typeof` operator will return `*object*` instead of `*string*`, because
    the string primitive is wrapped in a `String` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In modern JavaScript, creating a `String` object instance is discouraged for
    reasons like this. You‚Äôre better off removing this practice from any code you
    encounter than coding around it. However, if you need to accommodate possible
    `String` objects, you can use a more complex test like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code checks that one of two conditions are met: either you have a string
    primitive or an object that has the same prototype as `String`.^([1](ch02.html#idm45475190104344))'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type-checking test in this recipe uses the `typeof` operator. It returns
    the type name of the variable as a lowercase string. The possible values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`function`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These values match the list at the beginning of this chapter, but with two small
    differences. First, there‚Äôs no `*null*`, because null values return the string
    `*object*` instead. (This is considered a bug by many, but it‚Äôs kept for historical
    reasons.) Second, there‚Äôs an added `*function*` data type, even though a function
    is technically a special case of object.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, you‚Äôll see the following old-fashioned string-validation technique.
    It doesn‚Äôt require a variable to actually *be* a string. It simply verifies that
    your value can be treated as a string, and that it isn‚Äôt the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This works because `null` values, `undefined` values, and empty strings (`''`)
    are all *falsy* in JavaScript. If you evaluate any of them in a conditional expression,
    they are treated as false.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has a potential blindspot with the number 0, which always evaluates
    to `false`, skipping the `if` block. To be safe, it‚Äôs better to explicitly convert
    your numeric variables to strings, as described in [‚ÄúConverting a Numeric Value
    to a Formatted String‚Äù](#converting_number_to_string).
  prefs: []
  type: TYPE_NORMAL
- en: Converting a Numeric Value to a Formatted String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a string representation of a number.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript is a loosely typed language, and it will automatically convert any
    value to a string when it needs to‚Äîfor example, if you compare a number to a string
    or join a number to a string with the `+` operator. In fact, one of the easiest
    tricks that JavaScript developers use to convert numbers to strings is to simply
    concatenate an empty string on the beginning or end of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, modern practice favors *explicit* variable conversions. Every JavaScript
    object has a built-in `toString()` method, including the `Number` object. You
    can call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Often, you need to customize the string representation of your number. For example,
    you might want a fixed number of decimal places (like 30.00 instead of 30). This
    might also involve rounding (for example, from 30.009 to 30.01).
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript has three utility methods built into the number data type that can
    help you. All of them create string representations of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.toFixed()`'
  prefs: []
  type: TYPE_NORMAL
- en: Lets you specify the number of digits to keep after the decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.toExponential()`'
  prefs: []
  type: TYPE_NORMAL
- en: Uses scientific notation, and lets you specify the number of digits to show
    after the decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: '`Number.toPrecision()`'
  prefs: []
  type: TYPE_NORMAL
- en: Lets you specify the number of significant digits to keep, without considering
    how large or small your number is.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you aren‚Äôt familiar with *significant digits*, it‚Äôs a scientific concept
    used to make sure calculations keep an appropriate degree of precision. It also
    helps to make sure a measurement is not represented in a way that implies more
    precision than it actually has. (For example, your average weight may be 162.5
    pounds, but it‚Äôs probably not meaningful to say it‚Äôs 162.503018 pounds, nor is
    it helpful to round it to 200 pounds.) Wikipedia explains the [concept in detail](https://oreil.ly/vrrPr).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs an example that demonstrates all three string conversion methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you want to apply formatting like commas, a currency symbol, or some other
    locale-specific details, you need the help of the `Intl.NumberFormat` object.
    Once you create an instance and configure it appropriately, you can use the `Intl.NumberFormat`
    to perform your number-to-string conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to format a number as a US currency string, you use code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *locale* represents a specific geographic or cultural region. Locale identifiers
    combine a language code and a region string. The locale *en-US* represents the
    English language in the United States of America. The local *en_CA* is English
    in Canada, *fr-CA* is French in Canada, *ja-JP* is Japanese in Japan, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your locale, there are some standard number formatting rules that
    apply. For example, numbers in English language regions often use commas to separate
    thousands (as in *1,200.00*), while commas in French language regions often use
    commas instead of a decimal point (as in *1 200,00*). If you create a `Intl.NumberFormat`
    object without any constructor arguments, you get the locale settings of the current
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create an `Intl.NumberFormat` object for a specific locale, with
    no extra options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the *en-US* region, this object will add comma separators, but it won‚Äôt apply
    a fixed number of decimal points or add a currency symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The `Intl.NumberFormat` object supports a number of options. You can change
    the way negative numbers are displayed, set minimum and maximum numbers of digits,
    show percentages, and choose different numbering systems in some languages. You
    can find comprehensive information in the [Mozilla Developer Network reference](https://oreil.ly/JEF4Q).
  prefs: []
  type: TYPE_NORMAL
- en: 'You may see an older version of this technique that uses the `Number.toLocaleString()`
    method. Here‚Äôs an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This approach is perfectly valid, although if you plan to format a long series
    of numbers, creating and reusing a single `Intl.NumberFormat` object will perform
    better.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need formatting support that‚Äôs more extensive than what `Intl.NumberFormat`
    provides, you can use a third-party library like [Numeral.js](https://github.com/adamwdraper/Numeral-js).
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Special Characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to insert a special character, such as a line break, into a string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest approach with many special characters is simple: just paste the
    character you want into your editor. For example, if you need a copyright symbol
    (¬©), first find the character in a desktop utility like charmap (on a Windows
    computer) or just search for ‚Äúcopyright symbol‚Äù in Google. Select the symbol,
    copy it, and then paste it into your code.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use a character that wouldn‚Äôt normally be allowed in your code
    (according to the syntax rules of JavaScript), you need to use one of its *escape
    sequences*‚Äîspecial character code combinations that aren‚Äôt interpreted literally.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you‚Äôre using apostrophes to delimit your strings, you can‚Äôt
    put an apostrophe character directly *in* your string. Instead, you need to use
    the `\''` escape sequence, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now `favoriteMovie` holds the text *My favorite movie is ‚ÄòThe Seventh Seal‚Äô.*
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The escape sequences in JavaScript all begin with the *backslash character*
    (`\`). This character signals that what follows is a sequence of characters that
    needs special handling. [Table¬†2-1](#escape_sequence_list) lists the other escape
    sequences that JavaScript recognizes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Escape sequences
  prefs: []
  type: TYPE_NORMAL
- en: '| Sequence | Character |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\''` | Single quote |'
  prefs: []
  type: TYPE_TB
- en: '| `\"` | Double quote |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | Backslash |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Newline |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Horizontal tab |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Nondestructive backspace* |'
  prefs: []
  type: TYPE_TB
- en: '| `\f` | Form feed* |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | Carriage return^([a](ch02.html#idm45475189621992)) |'
  prefs: []
  type: TYPE_TB
- en: '| `\ddd` | Octal sequence (3 digits: *`ddd`*) |'
  prefs: []
  type: TYPE_TB
- en: '| `\xdd` | Hexadecimal sequence (2 digits: *`dd`*) |'
  prefs: []
  type: TYPE_TB
- en: '| `\udddd` | Unicode sequence (4 hex digits: *`dddd`*) |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch02.html#idm45475189621992-marker)) Some escape sequences (like the
    ones used for backspaces and form feeds) are holdovers from the original ASCII
    character standard and C language. Unless you‚Äôre dealing with a legacy scenario
    (like sending input to a terminal), these escape sequences aren‚Äôt likely to be
    useful in JavaScript. |'
  prefs: []
  type: TYPE_TB
- en: 'The last three escape sequences in [Table¬†2-1](#escape_sequence_list) are patterns
    that require you to supply a numeric value. For example, if you don‚Äôt want to
    use the copy-and-paste trick to add a copyright symbol, you can insert it by using
    the `\u` escape sequence and the copyright symbol‚Äôs Unicode value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now the `copyrightNotice` string is set to *This page ¬© Shelley Powers.*
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For information about inserting even more specialized characters in your strings,
    see [‚ÄúInserting Emojis‚Äù](#inserting_emojis). For an alternate approach to dealing
    with line breaks without using `\n`, see [‚ÄúUsing Template Literals for Clearer
    String Concatenation‚Äù](#using_template_literals).
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Emojis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to insert an extended Unicode character that has a 4-byte encoding,
    like an emoji or certain types of accented non-English letters.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you simply want to create a string with an emoji, the copy-and-paste trick
    from [‚ÄúInserting Special Characters‚Äù](#inserting_special_characters) usually works.
    In a modern code editor, you can write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const hamburger = ''`üçî`'';`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const hamburgerStory = ''I like hamburgers'' + hamburger;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your code font doesn‚Äôt even need to support emojis, because your code editor
    will fall back on the emoji support provided by your operating system. (Of course,
    issues can still occur. For example, you might see a square ‚Äúmissing character‚Äù
    icon on an older system where the emoji isn‚Äôt available.)
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use the Unicode value for the emoji. The problem is that
    you can‚Äôt use a standard `\u` escape sequence to get an emoji, because every emoji
    is stored as a 4-byte value. (By comparison, the Unicode characters that map to
    the keys of your keyboard are usually encoded as 2-byte values.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to use the `String.fromCodePoint()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The hamburger emoji has the hexadecimal code U+1F354\. To use it with `fromCodePoint()`,
    replace the prefix *U+* with *0x*.
  prefs: []
  type: TYPE_NORMAL
- en: Once you‚Äôve created an emoji-enhanced string, you can write it to the developer
    console or show it in a web page, just as you would with an ordinary string composed
    of ordinary characters.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of 2020, there are just over three thousand emojis in the world. You can
    see them, with their corresponding hexadecimal values [at the Full Emoji List](https://oreil.ly/IIguA).
    Just because an emoji exists doesn‚Äôt mean it will be supported on the devices
    where you plan to use it, so test for compliance early.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to do string processing with strings that may include emojis, other
    issues can crawl out of the woodwork. For example, what do you expect this code
    will find?
  prefs: []
  type: TYPE_NORMAL
- en: '`const hamburger = ''`üçî`'';`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const hamburgerLength = hamburger.length;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though the `hamburger` string is just one character, to your code the length
    appears to be 2 because the hamburger emoji takes twice as many bytes in memory.
    This is an unpleasant [*leaky abstraction*](https://oreil.ly/nlmvi) and a limitation
    of JavaScript‚Äôs support for Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: There are workarounds that people have invented to deal with emoji issues, like
    incorrect lengths and problems iterating over characters or slicing strings. But
    making a home brew solution is risky, because there are often strange edge cases.
    Instead, consider a JavaScript library with emoji support like [Grapheme Splitter](https://github.com/orling/grapheme-splitter)
    if you need to manipulate emoji-enriched text.
  prefs: []
  type: TYPE_NORMAL
- en: Using Template Literals for Clearer String Concatenation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a simpler, clearer way to write long string concatenation operations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common task in programming is to combine bits of static text with variables
    to create a single, longer string. The traditional way to assemble this kind of
    string is with the concatentation operator `+`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It‚Äôs not awful, but it can get awkward, particularly as the fixed bits of text
    get longer. It‚Äôs also surprisingly easy to forget to add spaces around the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'A different approach is to use *template literals*, a type of string literal
    that allows embedded expressions. To create a template literal, just replace your
    standard string delimeters (apostrophes or double quotes) with the backtick (`)
    character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now you can insert your variables directly into your template literal. All you
    need to do is wrap each variable in curly braces, preceded by a dollar sign, like
    `${firstName}`. This is called an *expression.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of the template literal approach becomes clearer when you look
    at a full example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It‚Äôs even clearer when you use a modern code editor that colorizes the curly
    brace expressions, making the variables stand out from the literal text.
  prefs: []
  type: TYPE_NORMAL
- en: Template literals also preserve line breaks. In the examples shown here, you
    can‚Äôt see this effect, because we‚Äôve wrapped the code to fit the page. But if
    you deliberately hit Enter to put hard line breaks in your template literal, those
    breaks will be preserved in the string, exactly as if you‚Äôd used the `\n` newline
    escape sequence (see [‚ÄúInserting Special Characters‚Äù](#inserting_special_characters)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Many JavaScript styte guides, including [Airbnb](https://github.com/airbnb/javascript),
    have rules that discourage string concatenation and favor template literals. You
    can use a linter like ESLint ([‚ÄúEnforcing Code Standards with a Linter‚Äù](ch01.html#using_eslint))
    to enforce this practice in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use expressions in a template literal, you aren‚Äôt limited to inserting
    variables as they are. In fact, you can use any code expression that JavaScript
    can evaluate. For example, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, JavaScript executes the addition in the expression `{5+3}`, gets the result,
    and creates the string *The sum of 5 + 3 is 8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to do something more complex, like format strings or manipulate
    objects, you can use an expression that calls a function. For example, if you‚Äôve
    created a `getDaysSince()` function for calculating the difference between dates
    (see [‚ÄúCalculating the Time Elapsed Between Two Dates‚Äù](ch04.html#calculating_time_between_dates)),
    you can use it in a template literal like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The only limit is practical‚Äîin other words don‚Äôt make your expressions so complex
    that the resulting template literal is more difficult to read than code that uses
    the traditional string-concatenation approach.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, JavaScript has no built-in way to format numbers, dates, and currency
    values inside template literal expressions. Plenty of people have speculated that
    future versions of JavaScript will add this capability. There‚Äôs even a JavaScript
    library that uses an awkward extensibility feature called [*tagged templates*](https://github.com/skolmer/es2015-i18n-tag)
    to wedge it in.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a Case-Insensitive String Comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to see if two strings match, while treating uppercase and lowercase
    letters as the same.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The off-the-cuff approach is to use the `String.toLowerCase()` method on both
    strings, and compare the result, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This approach is fairly reliable, but it can suffer from edge cases with different
    languages, accents, and special characters. (For example, check out the [potential
    problems](https://oreil.ly/CiALB) with Turkish.)
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternate, bulletproof approach is to use the `String.localeCompare()` method
    with `sensitivity` set to `*accent*`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If `localeCompare()` deems that two strings match, it returns 0\. Otherwise
    it returns a positive or negative integer indicating whether the compared string
    falls before or after the referenced string in the sort order. (Because we‚Äôre
    using `localeCompare()` to test for equality, the sort order isn‚Äôt important,
    and you can ignore it.)
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter of `localeCompare()` holds a string that specifies the
    locale (as explained in [‚ÄúConverting a Numeric Value to a Formatted String‚Äù](#converting_number_to_string)).
    If you pass `undefined`, then `localeCompare()` uses the locale of the current
    computer, which is almost always what you want.
  prefs: []
  type: TYPE_NORMAL
- en: To perform a case-insensitive comparison, you need to set the `sensitivity`
    property. There are two values that can work. If you set `sensitivity` to `*accent*`,
    characters that have different accents (like *a* and *√°*) are treated as unequal.
    But if you set `sensitivity` to `*base*`, you‚Äôll get a more permissive case-insensitive
    comparison that treats all accented letters as matches.
  prefs: []
  type: TYPE_NORMAL
- en: Checking If a String Contains a Specific Substring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check if one string contains another substring.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you simply need a yes-or-no test, you can use the `String.includes()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you can tell the `includes()` method where to start its search
    by character position. For example, pass in the value 5 and the search skips to
    the sixth character in the string, and continues to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The search that `includes()` performs is case-sensitive. If you want a case-insensitive
    search, you can call `toLowerCase()` on both strings first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `includes()` method doesn‚Äôt provide any information about where a match
    occurs. If you want this information, consider using the `String.indexOf()` method
    instead, which is described in [‚ÄúExtracting a List from a String‚Äù](#extracting_a_list).
  prefs: []
  type: TYPE_NORMAL
- en: Replacing All Occurrences of a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find all occurrences of a specific substring in a string, and replace
    them with something else.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `String.replaceAll()` method to make the change in one step.
    All you need is a substring to search for and another string to swap in its place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, you‚Äôll see the altered string ‚ÄúI know not where I was
    born, save that the castle was somewhat old and somewhat horrible.‚Äù appear in
    the developer console.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `replaceAll()` method has the ability to use a regular expression for searching
    instead of an ordinary string. You can see how this works in [‚ÄúUsing a Regular
    Expression to Replace Patterns in a String‚Äù](#replacing_patterns_string).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consult Recipes and to see how you can find matches in a string and examine
    each one, instead of just replacing them outright.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing HTML Tags with Named Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to insert markup into a web page, and escape the markup (so the browser
    *displays* the angle brackets rather than interpreting them as HTML tags). This
    could be because you want to show some example HTML markup, for example, in a
    tutorial article. Or it may be because you need to safely sanitize outside data,
    like text submitted by a user or pulled out of a database.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `String.replaceAll()` method to convert angle brackets (`< >`) into
    the named HTML entities `&lt;` and `&gt;`. You‚Äôll need to perform two steps, one
    for each substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you examine the string now, you‚Äôll find it holds the text ‚Äú<p>This is a <span>paragraph</span></p>‚Äù,
    which will appear as you expect (with angle brackets shown) in the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform both string substitutions in one step, as long as you can keep
    the code readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first `replaceAll()` returns a new string, and the code calls `replaceAll()`
    on that second string to get a *third* string in this case. This technique of
    calling a method on a value that‚Äôs returned from a method is called *method chaining*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTML escaping is critically important if you‚Äôre inserting raw text into a web
    page. If you don‚Äôt perform this step, you‚Äôve left open a gaping security hole.
    In fact, you should make sure all text content is escaped before you show it in
    a web page, even if you think that text doesn‚Äôt contain any HTML entities (for
    example, even if it‚Äôs just set as a literal in your code). There‚Äôs no telling
    when someone might change the code and substitute a text value from somewhere
    else.
  prefs: []
  type: TYPE_NORMAL
- en: That said, doing HTML escaping on your own usually isn‚Äôt the best approach.
    You need to do it if you are deliberately creating a string that mingles your
    HTML tags with outside content. But ideally you‚Äôll put text in your web page using
    an element‚Äôs `textContent` property instead of its `innerHTML` property. When
    you use `textContent`, the browser escapes the content automatically, which means
    you don‚Äôt need to use `String.replaceAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Chapter¬†12](ch12.html#ch12) for more information about using the HTML DOM
    to insert text content into a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Regular Expression to Replace Patterns in a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to search a string for a pattern, rather than an exact sequence of
    characters. You then want to create a new string, with the pattern replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `String.replace()` or `String.replaceAll()` methods, both of
    which support regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *regular expression* is a sequence of characters that defines a text pattern.
    Regular expressions are a standard that‚Äôs implemented in JavaScript and many other
    programming languages. [Table¬†2-2](#regular_expression_special_characters) gives
    a brief introduction to regular expression syntax.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the regular expression pattern *`t\w{2}e`*. This translates
    into *look for any sequence of characters beginning with *t*, ending with *e*,
    and containing two other alphanumeric characters*. The solution matches *time*,
    but also matches *tame*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs the code that uses this regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the regular expression isn‚Äôt written a string. Instead, it‚Äôs a literal
    that begins and ends with a slash (`/`). JavaScript recognizes this syntax and
    creates a `RegEx` object that uses your expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `g` at the end of the regular expression is an additional detail called
    the *global flag*. It indicates that you are searching the whole string for matches.
    If you don‚Äôt include the `g` flag, you‚Äôll receive an error when you call `replaceAll()`.
    However, you can use a regular expression without the global flag when you use
    the `replace()` method to change just one occurrence of a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you‚Äôd rather create a regular expression without using the `/` delimiter,
    there‚Äôs another option. Instead of writing a regular expression literal, you can
    explicitly create a `RegEx` object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When you use this approach, you don‚Äôt include the surrounding slashes around
    the regular expression, but you do need to escape any backslashes in the pattern
    (by replacing `/` with `//`). In addition, the global flag becomes a second argument
    to the `RegExp` constructor, instead of being added to the end of the regular
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might find that escaping backslashes is awkward or confusing in long, complicated
    regular expressions. If so, you can get around the escaping requirement with a
    template literal (introduced in [‚ÄúUsing Template Literals for Clearer String Concatenation‚Äù](#using_template_literals)).
    The trick is to combine your template literal with the `String.raw()` method.
    Remember to use backticks (`) around the expression string instead of apostrophes
    or quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Extra: Regular Expressions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regular expressions are made up of regular characters that are used alone or
    in combination with special characters. For instance, the following is a regular
    expression for a pattern that matches against a string that contains the word
    *technology* and the word *book*, in that order, and separated by one or more
    whitespace characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The backslash character (`\`) serves two purposes: either it‚Äôs used with a
    regular character, to designate that it‚Äôs a special character, or it‚Äôs used with
    a special character, such as the plus sign (+), to designate that the character
    should be treated literally. In this case, the backslash is used with *s*, which
    transforms the letter *s* to a special character designating a whitespace character
    (space, tab, line feed, or form feed). The +\s+ special character is followed
    by the plus sign, `\s`, which is a signal to match the preceding character (in
    this example, a whitespace character) one or more times. This regular expression
    would work with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It would also work with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It would not work with the following, because there is no whitespace between
    the words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It doesn‚Äôt matter how much whitespace is between *technology* and *book*, because
    of the use of `\s+`. However, using the plus sign does require at least one whitespace
    character.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table¬†2-2](#regular_expression_special_characters) shows the most commonly
    used special characters in JavaScript applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Regular expression special characters
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Matches | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Matches beginning of input | `/^This/` matches *This is‚Ä¶* |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Matches end of input | `/end$/` matches *This is the end* |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Matches zero or more times | `/se*/` matches *seeee* as well as *se*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | Matches zero or one time | `/ap?/` matches *apple* and *and* |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Matches one or more times | `/ap+/` matches *apple* but not *and* |'
  prefs: []
  type: TYPE_TB
- en: '| `{n}` | Matches exactly *n* times | `/ap{2}/` matches *apple* but not *apie*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\{n,\}` | Matches *n* or more times | `/ap{2,}/` matches all p‚Äôs in *apple*
    and *appple* but not *apie* |'
  prefs: []
  type: TYPE_TB
- en: '| `\{n,m\}` | Matches at least *n*, at most *m* times | `/ap{2,4}/` matches
    four p‚Äôs in *apppppple* |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any character except newline | `/a.e/` matches *ape* and *axe* |'
  prefs: []
  type: TYPE_TB
- en: '| `[`‚Ä¶`]` | Any character within brackets | `/a[px]e/` matches *ape* and *axe*
    but not *ale* |'
  prefs: []
  type: TYPE_TB
- en: '| `[^`‚Ä¶`]` | Any character but those within brackets | `/a[^px]/` matches *ale*
    but not *axe* or *ape* |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Matches on word boundary | `/\bno/` matches the first *no* in *nono*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Matches on nonword boundary | `/\Bno/` matches the second *no* in
    *nono* |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Digits from 0 to 9 | `/\d{3}/` matches *123* in *Now in 123* |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | Any nondigit character | `/\D{2,4}/` matches *Now '' in ‚ÄòNow in 123*;
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Matches word character (letters, digits, underscores) | `/\w/` matches
    *j* in *javascript* |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | Matches any nonword character (not letters, digits, or underscores)
    | `\/W/` matches *%* in *100%* |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Matches a line feed |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | A single whitespace character |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | A single character that is not whitespace |  |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | A tab |  |'
  prefs: []
  type: TYPE_TB
- en: '| `(x)` | Capturing parentheses | Remembers the matched characters |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Regular expressions are powerful but can be tricky. They‚Äôre only covered lightly
    in this book. If you want more in-depth coverage of regular expressions, you can
    read the excellent *[Regular Expressions Cookbook](http://shop.oreilly.com/product/0636920023630.do)*
    by Jan Goyvaerts and Steven Levithan (O‚ÄôReilly), or consult an [online reference](https://github.com/ziishaned/learn-regex).
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a List from a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a string with several sentences, one of which includes a list of items.
    The list begins with a colon (:), ends with a period (.), and separates each item
    with a comma (,). You want to extract just the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution requires two actions: extract the string containing the list of
    items, and then convert this string into a list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `String.indexOf()` method twice‚Äîfirst to locate the colon, and again
    to find the first period following the colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these two locations and the `String.slice()` method, you can extract
    the string you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You could write a loop that uses the `indexOf()` method to look for commas,
    and the `slice()` method to split the `list` string into smaller pieces, one for
    each item. But there‚Äôs an easier approach. You can break the string into an array
    using the `String.split()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When you call `split()`, you must choose a delimiter. It could be a space, a
    comma, a series of dashes, or something else. The delimiter is used to carve up
    the string into smaller pieces, and it won‚Äôt appear in the results.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The result of splitting the extracted string is an array of list items. However,
    the items may come with artifacts (in this case, an extra leading space in all
    but the first string). Fortunately, it‚Äôs easy to clean them up.
  prefs: []
  type: TYPE_NORMAL
- en: One obvious approach is to iterate over the array of strings and manually trim
    each one, using the technique described in [‚ÄúRemoving Whitespace from the Beginning
    and End of a String‚Äù](#removing_whitespace). This works, but there‚Äôs an easier
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick is to use the `Array.map()`, which runs a piece of code you supply
    on each element in the array. You need just a single line of code to call the
    `trim()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you aren‚Äôt familiar with the arrow syntax used to supply the trimming function
    in this example, you can read a more detailed explanation of this technique in
    [‚ÄúUsing Arrow Functions‚Äù](ch06.html#arrow_functions).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to find matches in a string is to use regular expressions. For example,
    depending on the way your list is structured, you might be able to use a regular
    expression that grabs words that fall in between commas. Regular expressions are
    introduced in [‚ÄúUsing a Regular Expression to Replace Patterns in a String‚Äù](#replacing_patterns_string),
    and using regular expressions to perform a search is covered in [‚ÄúFinding All
    Instances of a Pattern‚Äù](#finding_and_highlighting_all_instances_o).
  prefs: []
  type: TYPE_NORMAL
- en: Finding All Instances of a Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find all instances of a pattern within a string and iterate over
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a regular expression with the `String.matchAll()` method. The `matchAll()`
    method returns an iterator that lets you loop over all the matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example uses a regular expression to find any word that begins with
    *t* and ends with *e*, with any number of characters in between. It uses the template
    literal syntax from [‚ÄúUsing Template Literals for Clearer String Concatenation‚Äù](#using_template_literals)
    to build a new string with results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results from this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you search with `matchAll()`, each match is an object. As you iterate over
    your matches, you can examine the matched text (`match[0]`), and the index where
    the match was found (`match.index`).
  prefs: []
  type: TYPE_NORMAL
- en: Here‚Äôs something that looks a little peculiar in the current example. Even though
    you‚Äôre looking at one result at a time, you use `match[0]` to get the first item
    from an array. This array exists because a regular expression can *capture* multiple
    portions of a match using parentheses. You can then reference these captured sections
    later. For example, imagine you write a regular expression that matches a row
    of information about a person. With capturing, you can easily grab separate pieces
    of information from each match, like that person‚Äôs name and birth date. When you
    use this technique with `matchAll()`, the matched substrings are provided as `match[1]`,
    `match[2]`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you don‚Äôt want to iterate over the results right away, you can dump
    everything into an array using the spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now you can use `foreach` to loop through your `matches` array at another time.
    But remember, `matches` isn‚Äôt just an array of matching text. It‚Äôs an array of
    match *objects*. As you saw in the original example, each match object has a position
    (`match.index`) and an array with one or more matched groups of text (starting
    with `match[0]`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Highlighting Matches'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let‚Äôs take a look at a more detailed example that shows how you might find and
    highlight text matches on a web page. [Figure¬†2-1](#application_finding_and_highlighting_all)
    shows the application in action on William Wordsworth‚Äôs poem, ‚ÄúThe Kitten and
    the Falling Leaves.‚Äù
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 0201](assets/jsc3_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Application finding and highlighting all matched strings
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This page has a `textarea` and an input text box for entering both a search
    string and a regular expression. The pattern is used to create a `RegExp` object,
    which is then applied against the text in the `textarea` using `matchAll()`, just
    as in the previous (much shorter) example.
  prefs: []
  type: TYPE_NORMAL
- en: As the code examines the matches, it creates a string, consisting of both the
    unmatched text and the matched text. The matched text is surrounded by a `<span>`
    element, with a CSS class used to highlight the text. The resulting string is
    then inserted into the page, using the `innerHTML` property of a `<div>` element
    (see [Example¬†2-1](#highlight_all_matches)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Highlight all matches in a text string
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Figure¬†2-1](#application_finding_and_highlighting_all) this page performs
    a search with this regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The bar (`|`) is a conditional test, and will match a word based on the value
    on either side of the bar. So *leaf* matches, as well as *leaves*, but not *leap*.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Whitespace from the Beginning and End of a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to trim extra spaces that pad the beginning or end of a string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `String.trim()` method. It removes all whitespace from both ends of
    a string, including spaces, tabs, no-break spaces, and line terminator characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `trim()` method is straightforward, but not customizable. If you have even
    slightly more complex string alteration requirements, you‚Äôll need to use a regular
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common problem that thwarts the `trim()` method is removing excess whitespace
    *inside* a string. The `replaceAll()` method can accomplish this task with relative
    ease using a regular expression with the `\s` character to match whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Of course, unwanted artifacts are possible even after processing bad data with
    extra spaces. For example, if there are multiple spaces where you don‚Äôt want *any*
    space ('is long , ¬†¬†¬†with') you‚Äôll still be left with a single space after you
    run the replacement ('is long , with'). The only way to deal with issues like
    these is to manually step through each match, as demonstrated in [‚ÄúFinding All
    Instances of a Pattern‚Äù](#finding_and_highlighting_all_instances_o).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expression syntax is described in [‚ÄúUsing a Regular Expression to Replace
    Patterns in a String‚Äù](#replacing_patterns_string).
  prefs: []
  type: TYPE_NORMAL
- en: Converting the First Letter of a String to Uppercase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make the first letter of a string an uppercase letter, without changing
    the rest of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Split off the first letter and capitalize it with `String.toUpper()`. Join
    the uppercase letter to the remainder of the string, which you can get with `String.slice()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a single character from a string, you can use the string‚Äôs indexer, as
    in `original[0]`. This gets the character in position 0 (which is the first character).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use the `String.charAt()` method, which works in exactly
    the same way.
  prefs: []
  type: TYPE_NORMAL
- en: To get a fragment of a string, you use the `slice()` method. When calling `slice()`,
    you must always specify the index where you want to start your string extraction.
    For example, `text.slice(5)` starts at index position 5, continues to the end
    of the string, and copies that section of the text into a new string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don‚Äôt want `slice()` to continue to the end of the string, you can supply
    an optional second parameter with the index where the string copying should stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The example in this recipe changed a single letter to uppercase. If you want
    to change an entire sentence to use initial capitals (called *title case*), it‚Äôs
    a more complex problem. You might decide to split the string into separate words,
    trim each word, and then join the results, using a variation of the technique
    from [‚ÄúExtracting a List from a String‚Äù](#extracting_a_list).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use `slice()` in conjunction with `indexOf()` to find the location of
    specific bits of text that you want to extract. For an example, see [‚ÄúExtracting
    a List from a String‚Äù](#extracting_a_list).
  prefs: []
  type: TYPE_NORMAL
- en: Validating an Email Address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to catch and reject common errors in email addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions are useful for more than searching. You can also use them
    to validate strings by testing if a string matches a given pattern. In JavaScript,
    you test if a string matches a regular expression using the `RegEx.test()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers use many different regular expressions to validate email addresses.
    The best ones capture obvious mistakes and spurious values, but don‚Äôt get too
    complex. Overly strict regular expressions have, from time to time, inadvertently
    disallowed valid mail addresses. And even if an email address checks out with
    the most stringent test possible, there‚Äôs no way to know if it‚Äôs truly *correct*
    (at least not without sending an email message and requesting a confirmation).
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression in this recipe requires that an email has a sequence
    of at least one nonwhitespace character, followed by the @ character, followed
    by one or more nonwhitespace characters, followed by a period (.), followed again
    by one or more nonwhitespace characters. It catches obviously invalid emails like
    *tomkhangmail.com* or *tomkhan@gmail*.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you won‚Äôt write a regular expression for validation yourself. Instead,
    you‚Äôll use a prewritten expression that matches your data. For a massive collection
    of regular expression resources, visit the [Awesome Regex page](https://github.com/aloisdg/awesome-regex).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expression syntax is described in [‚ÄúUsing a Regular Expression to Replace
    Patterns in a String‚Äù](#replacing_patterns_string).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#idm45475190104344-marker)) In JavaScript, a *prototype* is a
    template for a specific type of object. In a more traditional object-oriented
    language, we would say that objects with the same prototype are instances of the
    same class. [Chapter¬†8](ch08.html#ch08) has many recipes that explore prototypes
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
