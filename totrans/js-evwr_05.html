<html><head></head><body><section data-pdf-bookmark="Chapter 4. Our First GraphQL API" data-type="chapter" epub:type="chapter"><div class="chapter" id="our-first-graphql-api">&#13;
<h1><span class="label">Chapter 4. </span>Our First GraphQL API</h1>&#13;
&#13;
&#13;
<p><a data-primary="GraphQL" data-secondary="API" data-type="indexterm" id="ix_ch04-asciidoc0"/><a data-primary="GraphQL API" data-type="indexterm" id="ix_ch04-asciidoc1"/>Presumably, if you are reading this, you are a human being. As a human you have a number of interests and passions. You also have family members, friends, acquaintances, classmates, and colleagues. Those people also have their own social relationships, interests, and passions. Some of these relationships and interests overlap, while others do not. All together, we each have a connected graph of the people in our lives.</p>&#13;
&#13;
<p>These types of interconnected data are exactly the challenge that&#13;
GraphQL initially set out to solve in API development. By writing a&#13;
GraphQL API we are able to efficiently connect data, which reduces the&#13;
complexity and number of requests while allowing us to serve a client&#13;
precisely the data they need.</p>&#13;
&#13;
<p>Does that all sound like a bit of overkill for a notes application?&#13;
Perhaps it does, but as you’ll see, the tools and techniques provided by the GraphQL JavaScript ecosystem both enable and simplify all types of API development.</p>&#13;
&#13;
<p>In this chapter we’ll build a GraphQL API, using the <code>apollo-server-express</code> package. To do so, we’ll explore fundamental GraphQL topics, write a GraphQL schema, develop code to resolve our schema functions, and access our API using the GraphQL Playground user interface.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Turning Our Server into an API (Sort Of)" data-type="sect1"><div class="sect1" id="idm45339511596008">&#13;
<h1>Turning Our Server into an API (Sort Of)</h1>&#13;
&#13;
<p><a data-primary="application programming interface (API)" data-secondary="turning server into an" data-type="indexterm" id="ix_ch04-asciidoc2"/><a data-primary="GraphQL API" data-secondary="turning server into an API" data-type="indexterm" id="ix_ch04-asciidoc3"/>Let’s begin our API development by turning our Express server into a&#13;
GraphQL server using the<a data-primary="Apollo Server" data-secondary="about" data-type="indexterm" id="idm45339511591480"/> <code>apollo-server-express</code> package.&#13;
<a href="https://oreil.ly/1fNt3">Apollo Server</a> is an&#13;
open source GraphQL server library that works with a large number of&#13;
Node.js server frameworks, including Express, Connect, Hapi, and Koa. It enables us to serve data as a GraphQL API from a Node.js application and also provides helpful tooling such as the GraphQL Playground, a visual helper for working with our API in development.</p>&#13;
&#13;
<p>To write our API we’ll be modifying the web application code&#13;
we wrote in the previous chapter. Let’s start by including the&#13;
<code>apollo-server-express</code> package. Add the following to the top of your&#13;
<em>src/index.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="p">{</code> <code class="nx">ApolloServer</code><code class="p">,</code> <code class="nx">gql</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'apollo-server-express'</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now that we’ve imported <code>apollo-server</code>, we’ll set up a basic&#13;
GraphQL application. GraphQL applications consist of two primary&#13;
components: a schema of type definitions and resolvers, which resolve&#13;
the queries and mutations performed against the data. If that all sounds like nonsense, that’s OK. We’ll implement a “Hello World” API response and will further explore these GraphQL topics throughout the&#13;
development of our API.</p>&#13;
&#13;
<p>To begin, let’s construct a basic schema, which we will store in a&#13;
variable called <code>typeDefs</code>. This schema will describe a single <code>Query</code>&#13;
named <code>hello</code> that will return a string:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Construct a schema, using GraphQL schema language</code>&#13;
<code class="kr">const</code> <code class="nx">typeDefs</code> <code class="o">=</code> <code class="nx">gql</code><code class="sb">`</code>&#13;
<code class="sb">  type Query {</code>&#13;
<code class="sb">    hello: String</code>&#13;
<code class="sb">  }</code>&#13;
<code class="sb">`</code><code class="p">;</code></pre>&#13;
&#13;
<p>Now that we’ve set up our schema, we can add a resolver that will return a value to the user. This will be a simple function that returns the string “Hello world!”:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Provide resolver functions for our schema fields</code>&#13;
<code class="kr">const</code> <code class="nx">resolvers</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Query</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s1">'Hello world!'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Lastly, we’ll integrate Apollo Server to serve our GraphQL API. To do&#13;
so, we’ll add some Apollo Server–specific settings and middleware and&#13;
update our <code>app.listen</code> code:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Apollo Server setup</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ApolloServer</code><code class="p">({</code> <code class="nx">typeDefs</code><code class="p">,</code> <code class="nx">resolvers</code> <code class="p">});</code>&#13;
&#13;
<code class="c1">// Apply the Apollo GraphQL middleware and set the path to /api</code>&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">applyMiddleware</code><code class="p">({</code> <code class="nx">app</code><code class="p">,</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'/api'</code> <code class="p">});</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">({</code> <code class="nx">port</code> <code class="p">},</code> <code class="p">()</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>&#13;
    <code class="sb">`GraphQL Server running at http://localhost:</code><code class="si">${</code><code class="nx">port</code><code class="si">}${</code><code class="nx">server</code><code class="p">.</code><code class="nx">graphqlPath</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p class="pagebreak-before">Putting it all together, our <em>src/index.js</em> file should now look like&#13;
this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'express'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">ApolloServer</code><code class="p">,</code> <code class="nx">gql</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'apollo-server-express'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Run the server on a port specified in our .env file or port 4000</code>&#13;
<code class="kr">const</code> <code class="nx">port</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">4000</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Construct a schema, using GraphQL's schema language</code>&#13;
<code class="kr">const</code> <code class="nx">typeDefs</code> <code class="o">=</code> <code class="nx">gql</code><code class="sb">`</code>&#13;
<code class="sb">  type Query {</code>&#13;
<code class="sb">    hello: String</code>&#13;
<code class="sb">  }</code>&#13;
<code class="sb">`</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Provide resolver functions for our schema fields</code>&#13;
<code class="kr">const</code> <code class="nx">resolvers</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Query</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s1">'Hello world!'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Apollo Server setup</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ApolloServer</code><code class="p">({</code> <code class="nx">typeDefs</code><code class="p">,</code> <code class="nx">resolvers</code> <code class="p">});</code>&#13;
&#13;
<code class="c1">// Apply the Apollo GraphQL middleware and set the path to /api</code>&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">applyMiddleware</code><code class="p">({</code> <code class="nx">app</code><code class="p">,</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'/api'</code> <code class="p">});</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">({</code> <code class="nx">port</code> <code class="p">},</code> <code class="p">()</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>&#13;
    <code class="sb">`GraphQL Server running at http://localhost:</code><code class="si">${</code><code class="nx">port</code><code class="si">}${</code><code class="nx">server</code><code class="p">.</code><code class="nx">graphqlPath</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>If you’ve left the <code>nodemon</code> process running, you can head straight to your&#13;
browser; otherwise, you must type<a data-primary="npm run dev" data-type="indexterm" id="idm45339511106088"/> <code>npm run dev</code> within the terminal&#13;
application to start the server. Then visit <em>http://localhost:4000/api</em>, where you’ll be greeted with the GraphQL Playground (<a data-type="xref" href="#first-graphql-playground">Figure 4-1</a>). This web app, which comes bundled with Apollo Server, is one of the great benefits of working with GraphQL. From here, you can run GraphQL queries and mutations and see the results. You can also click the Schema tab to access automatically created documentation for the API.</p>&#13;
&#13;
<figure><div class="figure" id="first-graphql-playground">&#13;
<img alt="A screenshot of the GraphQL Playground" src="assets/jsev_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>The GraphQL Playground</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>GraphQL Playground has a dark colored default syntax theme. Throughout the book, I’ll be using the “light” theme for its higher contrast. This is configurable in GraphQL Playground’s settings, which can be accessed by clicking the gear icon.</p>&#13;
</div>&#13;
&#13;
<p>We can now write our query against our GraphQL API. To do so, type the following into the GraphQL Playground:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">hello</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When you click the Play button, the query should return the following (<a data-type="xref" href="#hello_query">Figure 4-2</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"data"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="s2">"hello"</code><code class="o">:</code> <code class="s2">"Hello world!"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="hello_query">&#13;
<img alt="The hello query in the GraphQL Playground" src="assets/jsev_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>The hello query</h6>&#13;
</div></figure>&#13;
&#13;
<p>And that’s it! We now have a working GraphQL API that we’ve accessed via the GraphQL Playground. Our API takes a query of <code>hello</code> and returns the string <code>Hello world!</code>. More importantly, we now have the structure in place to build a fully featured API.<a data-startref="ix_ch04-asciidoc3" data-type="indexterm" id="idm45339510972600"/><a data-startref="ix_ch04-asciidoc2" data-type="indexterm" id="idm45339510971896"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="GraphQL Basics" data-type="sect1"><div class="sect1" id="idm45339511595064">&#13;
<h1>GraphQL Basics</h1>&#13;
&#13;
<p><a data-primary="GraphQL API" data-secondary="components of" data-type="indexterm" id="idm45339510969688"/>In the previous section we dove right in and developed our first API,&#13;
but let’s take a few moments to step back and look at the different pieces of a GraphQL API. The two primary building blocks of a GraphQL API are <em>schemas</em> and <em>resolvers</em>. By understanding these two components, you can apply them more effectively to your API design and development.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Schemas" data-type="sect2"><div class="sect2" id="idm45339510931352">&#13;
<h2>Schemas</h2>&#13;
&#13;
<p><a data-primary="GraphQL API" data-secondary="schemas" data-type="indexterm" id="idm45339510929752"/><a data-primary="schemas" data-secondary="GraphQL API" data-type="indexterm" id="idm45339510928776"/>A schema is a written representation of our data and interactions. By&#13;
requiring a schema, GraphQL enforces a strict plan for our API. This is because your API can only return data and perform interactions that are defined within the schema.</p>&#13;
&#13;
<p>The fundamental component of GraphQL schemas are object types. In the&#13;
previous example we created a GraphQL object type of <code>Query</code> with a&#13;
field of <code>hello</code>, which returned a scalar type of <code>String</code>. GraphQL&#13;
contains five built-in scalar types:</p>&#13;
<dl>&#13;
<dt><code>String</code></dt>&#13;
<dd>&#13;
<p>A string with UTF-8 character encoding</p>&#13;
</dd>&#13;
<dt><code>Boolean</code></dt>&#13;
<dd>&#13;
<p>A true or false value</p>&#13;
</dd>&#13;
<dt><code>Int</code></dt>&#13;
<dd>&#13;
<p>A 32-bit integer</p>&#13;
</dd>&#13;
<dt><code>Float</code></dt>&#13;
<dd>&#13;
<p>A floating-point value</p>&#13;
</dd>&#13;
<dt><code>ID</code></dt>&#13;
<dd>&#13;
<p>A unique identifier</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>With these basic components we can construct a schema for an API. We do&#13;
so by first defining the type. Let’s imagine that we’re creating an&#13;
API for a pizza menu. In doing so, we might define a GraphQL schema type&#13;
of <code>Pizza</code> like so:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Pizza</code> <code class="p">{</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, each pizza has a unique ID, a size (such as small, medium, or&#13;
large), a number of slices, and optional toppings. The&#13;
<code>Pizza</code> schema might look something like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Pizza</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code>&#13;
  <code class="nx">size</code><code class="o">:</code> <code class="nb">String</code>&#13;
  <code class="nx">slices</code><code class="o">:</code> <code class="nx">Int</code>&#13;
  <code class="nx">toppings</code><code class="o">:</code> <code class="p">[</code><code class="nb">String</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this schema, some field values are required (such as ID, size, and&#13;
slices), while others may be optional (such as toppings). We can express that a field must contain a value by using an exclamation mark. Let’s update our schema to represent the required values:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Pizza</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code><code class="o">!</code>&#13;
  <code class="nx">size</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
  <code class="nx">slices</code><code class="o">:</code> <code class="nx">Int</code><code class="o">!</code>&#13;
  <code class="nx">toppings</code><code class="o">:</code> <code class="p">[</code><code class="nb">String</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this book, we’ll be writing a basic schema, which will enable&#13;
us to perform the vast majority of operations found in a common API.&#13;
If you’d like to explore all of the GraphQL schema options, I’d&#13;
encourage you to read the <a href="https://oreil.ly/DPT8C">GraphQL&#13;
schema <span class="keep-together">documentation</span></a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Resolvers" data-type="sect2"><div class="sect2" id="resolvers">&#13;
<h2>Resolvers</h2>&#13;
&#13;
<p><a data-primary="GraphQL API" data-secondary="resolvers" data-type="indexterm" id="idm45339510746648"/><a data-primary="resolvers" data-type="indexterm" id="idm45339510745672"/>The second piece of our GraphQL API will be resolvers. Resolvers perform exactly the action their name implies; they <em>resolve</em> the data that the API user has requested. We will write these resolvers by first defining them in our schema and then implementing the logic within our JavaScript code. Our API will contain two types of resolvers: queries and mutations.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Queries" data-type="sect3"><div class="sect3" id="idm45339510743976">&#13;
<h3>Queries</h3>&#13;
&#13;
<p><a data-primary="GraphQL API" data-secondary="queries" data-type="indexterm" id="idm45339510742776"/><a data-primary="queries" data-type="indexterm" id="idm45339510741800"/><a data-primary="resolvers" data-secondary="queries" data-type="indexterm" id="idm45339510741128"/>A query requests specific data from an API, in its desired format. In&#13;
our hypothetical pizza API we may write a query that will return a full list of pizzas on the menu and another that will return detailed&#13;
information about a single pizza. The query will then return an object,&#13;
containing the data that the API user has requested. A query never&#13;
modifies the data, only accesses it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mutations" data-type="sect3"><div class="sect3" id="idm45339510739400">&#13;
<h3>Mutations</h3>&#13;
&#13;
<p><a data-primary="GraphQL API" data-secondary="mutations" data-type="indexterm" id="idm45339510738232"/><a data-primary="mutations" data-type="indexterm" id="idm45339510737256"/><a data-primary="resolvers" data-secondary="mutations" data-type="indexterm" id="idm45339510736584"/>We use a mutation when we want to modify the data in our API. In our&#13;
pizza example, we may write a mutation that changes the toppings for a&#13;
given pizza and another that allows us to adjust the number of slices.&#13;
Similar to a query, a mutation is also expected to return a result in the form of&#13;
an object, typically the end result of the performed action.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adapting Our API" data-type="sect1"><div class="sect1" id="idm45339510734760">&#13;
<h1>Adapting Our API</h1>&#13;
&#13;
<p><a data-primary="GraphQL API" data-secondary="adapting API" data-type="indexterm" id="ix_ch04-asciidoc4"/>Now that you have a good understanding of the components of GraphQL,&#13;
let’s adapt our initial API code for our notes application. To begin,&#13;
we’ll write some code to read and create notes.</p>&#13;
&#13;
<p>The first thing we’ll need is a little bit of data for our API to work&#13;
with. Let’s create an array of “note” objects, which we’ll use as the&#13;
basic data served by our API. As our project evolves, we’ll replace this&#13;
in-memory data representation with a database. For now, we will store&#13;
our data in a variable named <code>notes</code>. Each note in the array will be an&#13;
object with three properties, <code>id</code>, <code>content</code>, and <code>author</code>:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">let</code> <code class="nx">notes</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s1">'1'</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="s1">'This is a note'</code><code class="p">,</code> <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code> <code class="p">},</code>&#13;
  <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s1">'2'</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="s1">'This is another note'</code><code class="p">,</code> <code class="nx">author</code><code class="o">:</code> <code class="s1">'Harlow Everly'</code> <code class="p">},</code>&#13;
  <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s1">'3'</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="s1">'Oh hey look, another note!'</code><code class="p">,</code> <code class="nx">author</code><code class="o">:</code> <code class="s1">'Riley Harrison'</code> <code class="p">}</code>&#13;
<code class="p">];</code></pre>&#13;
&#13;
<p class="pagebreak-before">Now that we have some data, we’ll adapt our GraphQL API to work with&#13;
it. Let’s begin by focusing on our schema. Our schema is&#13;
GraphQL’s representation of our data and how it will be interacted with.&#13;
We know that we will have notes, which will be queried and mutated.&#13;
These notes will, for now, contain an ID, content, and an author field.&#13;
Let’s create a corresponding note type within our <code>typeDefs</code> GraphQL&#13;
schema. This will represent the properties of a note within our API:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Note</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code><code class="o">!</code>&#13;
  <code class="nx">content</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
  <code class="nx">author</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, let’s add a query that will allow us to retrieve the list of all&#13;
notes. Let’s update the <code>Query</code> type to include a <code>notes</code> query, which&#13;
will return the array of note objects:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Query</code> <code class="p">{</code>&#13;
  <code class="nx">hello</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code>&#13;
  <code class="nx">notes</code><code class="o">:</code> <code class="p">[</code><code class="nx">Note</code><code class="o">!</code><code class="p">]</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, we can update our resolver code to perform the work of returning&#13;
the array of data. Let’s update our <code>Query</code> code to include the following&#13;
<code>notes</code> resolver, which returns the raw data object:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">Query</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s1">'Hello world!'</code><code class="p">,</code>&#13;
    <code class="nx">notes</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">notes</code>&#13;
  <code class="p">},</code></pre>&#13;
&#13;
<p>If we now go to the GraphQL playground, running at&#13;
<em>http://localhost:4000/api</em>, we can test the <code>notes</code> query. To do so, type the following query:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">notes</code> <code class="p">{</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">content</code>&#13;
    <code class="nx">author</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">Then, when you click the Play button, you should see a <code>data</code> object&#13;
returned, which contains the data array (<a data-type="xref" href="#first-notes-query">Figure 4-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="first-notes-query">&#13;
<img alt="The notes query in the GraphQL Playground" src="assets/jsev_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>The notes query</h6>&#13;
</div></figure>&#13;
&#13;
<p>To try out one of the coolest aspects of GraphQL, we can remove any of our requested fields, such as <code>id</code> or <code>author</code>. When we do so, the API returns precisely the data that we’ve requested. This allows the client that consumes the data to control the amount of data sent within each request and limit that data to exactly what is required (<a data-type="xref" href="#first-notes-query2">Figure 4-4</a>).</p>&#13;
&#13;
<figure><div class="figure" id="first-notes-query2">&#13;
<img alt="A note query with only content data requested in the GraphQL Playground" src="assets/jsev_0404.png"/>&#13;
<h6><span class="label">Figure 4-4. </span>A notes query with only content data requested</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now that we can query our full list of notes, let’s write some code that&#13;
will allow us to query for a single note. You can imagine the usefulness&#13;
of this from a user interface perspective, for displaying a view that&#13;
contains a single, specific note. To do so, we’ll want to request a note&#13;
with a specific <code>id</code> value. This will require us to use an <a data-primary="arguments" data-type="indexterm" id="idm45339510482392"/><em>argument</em> in&#13;
our GraphQL schema. An argument allows the API consumer to pass specific&#13;
values to the resolver function, providing the necessary information for&#13;
it to resolve. Let’s add a <code>note</code> query, which will take an&#13;
argument of <code>id</code>, with the type <code>ID</code>. We’ll update our <code>Query</code> object&#13;
within our <code>typeDefs</code> to the following, which includes the new <code>note</code>&#13;
query:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Query</code> <code class="p">{</code>&#13;
  <code class="nx">hello</code><code class="o">:</code> <code class="nb">String</code>&#13;
  <code class="nx">notes</code><code class="o">:</code> <code class="p">[</code><code class="nx">Note</code><code class="o">!</code><code class="p">]</code><code class="o">!</code>&#13;
  <code class="nx">note</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="nx">ID</code><code class="o">!</code><code class="p">)</code><code class="o">:</code> <code class="nx">Note</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With our schema updated, we can write a query resolver to return the requested note. To do this, we’ll need to be able to read the API user’s argument values. Helpfully, <a data-primary="Apollo Server" data-secondary="resolver functions" data-type="indexterm" id="idm45339510442312"/><a data-primary="resolvers" data-secondary="Apollo Server functions" data-type="indexterm" id="idm45339510441464"/>Apollo Server&#13;
passes the following useful parameters to our resolver functions:</p>&#13;
<dl>&#13;
<dt><code>parent</code></dt>&#13;
<dd>&#13;
<p>The<a data-primary="args, defined" data-type="indexterm" id="idm45339510437896"/><a data-primary="parent, defined" data-type="indexterm" id="idm45339510437160"/> result of the parent query, which is useful when&#13;
nesting queries.</p>&#13;
</dd>&#13;
<dt><code>args</code></dt>&#13;
<dd>&#13;
<p>These are the arguments passed by the user in the query.</p>&#13;
</dd>&#13;
<dt><code>context</code></dt>&#13;
<dd>&#13;
<p>Information<a data-primary="context function" data-secondary="defined" data-type="indexterm" id="idm45339510433512"/> passed along from the server&#13;
application to the resolver functions. This could include&#13;
things such as the current user or database information.</p>&#13;
</dd>&#13;
<dt><code>info</code></dt>&#13;
<dd>&#13;
<p>Information<a data-primary="info, defined" data-type="indexterm" id="idm45339510430808"/> about the query itself.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>We’ll be exploring these further as needed within our code. If&#13;
you’re curious, you can learn more about these parameters in&#13;
<a href="https://oreil.ly/l6mL4">Apollo&#13;
Server’s documentation</a>. For now, we’ll need only the information&#13;
contained within the second parameter, <code>args</code>.</p>&#13;
&#13;
<p>The <a data-primary="note query, defined" data-type="indexterm" id="idm45339510427768"/><code>note</code> query will take the note <code>id</code> as an argument and find it within our array of <code>note</code> objects. Add the following to the query resolver code:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">note</code><code class="o">:</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">notes</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">note</code> <code class="o">=&gt;</code> <code class="nx">note</code><code class="p">.</code><code class="nx">id</code> <code class="o">===</code> <code class="nx">args</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The resolver code should now look as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">resolvers</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Query</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s1">'Hello world!'</code><code class="p">,</code>&#13;
    <code class="nx">notes</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">notes</code><code class="p">,</code>&#13;
    <code class="nx">note</code><code class="o">:</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">notes</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">note</code> <code class="o">=&gt;</code> <code class="nx">note</code><code class="p">.</code><code class="nx">id</code> <code class="o">===</code> <code class="nx">args</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>To run our query, let’s go back to our web browser and visit the GraphQL Playground at <em>http://localhost:4000/api</em>. We can now query a note with a specific <code>id</code> as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">note</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="s2">"1"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">content</code>&#13;
    <code class="nx">author</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When you run this query, you should receive the results of a note with the requested <code>id</code> value. If you attempt to query for a note that doesn’t exist, you should receive a result with a value of <code>null</code>. To test this, try changing the <code>id</code> value to return different results.</p>&#13;
&#13;
<p class="pagebreak-before">Let’s wrap up our initial API code by introducing the ability to create a new note, using a GraphQL mutation. In that mutation, the user will pass in&#13;
the note’s content. For now, we’ll hardcode the author of the note.&#13;
Let’s begin by updating our <code>typeDefs</code> schema with a <code>Mutation</code> type,&#13;
which we will call <code>newNote</code>:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">type</code> <code class="nx">Mutation</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code><code class="p">(</code><code class="nx">content</code><code class="o">:</code> <code class="nb">String</code><code class="o">!</code><code class="p">)</code><code class="o">:</code> <code class="nx">Note</code><code class="o">!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’ll now write a <a data-primary="mutations" data-secondary="resolver for" data-type="indexterm" id="idm45339510256584"/><a data-primary="resolvers" data-secondary="mutations" data-type="indexterm" id="idm45339510268824"/>mutation resolver, which will take in the note content as an argument, store the note as an object, and add it in memory to our <code>notes</code> array. To do this, we’ll add a <code>Mutation</code> object to our resolvers. Within the <code>Mutation</code> object, we’ll add a function called <a data-primary="newNote" data-type="indexterm" id="idm45339510266392"/><code>newNote</code>, with <code>parent</code> and <code>args</code> parameters. Within this function, we’ll take the argument <code>content</code> and create an object with <code>id</code>, <code>content</code>, and <code>author</code> keys. As you may have noticed, this matches the current schema of a note. We will then push this object to our <code>notes</code> array and return the object. Returning the object allows the GraphQL mutation to receive a response in the intended format. Go ahead and write this code as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">Mutation</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code><code class="o">:</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nx">noteValue</code> <code class="o">=</code> <code class="p">{</code>&#13;
      <code class="nx">id</code><code class="o">:</code> <code class="nb">String</code><code class="p">(</code><code class="nx">notes</code><code class="p">.</code><code class="nx">length</code> <code class="o">+</code> <code class="mi">1</code><code class="p">),</code>&#13;
      <code class="nx">content</code><code class="o">:</code> <code class="nx">args</code><code class="p">.</code><code class="nx">content</code><code class="p">,</code>&#13;
      <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code>&#13;
    <code class="p">};</code>&#13;
    <code class="nx">notes</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">noteValue</code><code class="p">);</code>&#13;
    <code class="k">return</code> <code class="nx">noteValue</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Our <em>src/index.js</em> file will now read like so:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'express'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">ApolloServer</code><code class="p">,</code> <code class="nx">gql</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'apollo-server-express'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Run our server on a port specified in our .env file or port 4000</code>&#13;
<code class="kr">const</code> <code class="nx">port</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">4000</code><code class="p">;</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">notes</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s1">'1'</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="s1">'This is a note'</code><code class="p">,</code> <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code> <code class="p">},</code>&#13;
  <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s1">'2'</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="s1">'This is another note'</code><code class="p">,</code> <code class="nx">author</code><code class="o">:</code> <code class="s1">'Harlow Everly'</code> <code class="p">},</code>&#13;
  <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s1">'3'</code><code class="p">,</code> <code class="nx">content</code><code class="o">:</code> <code class="s1">'Oh hey look, another note!'</code><code class="p">,</code> <code class="nx">author</code><code class="o">:</code> <code class="s1">'Riley Harrison'</code> <code class="p">}</code>&#13;
<code class="p">];</code>&#13;
&#13;
<code class="c1">// Construct a schema, using GraphQL's schema language</code>&#13;
<code class="kr">const</code> <code class="nx">typeDefs</code> <code class="o">=</code> <code class="nx">gql</code><code class="sb">`</code>&#13;
<code class="sb">  type Note {</code>&#13;
<code class="sb">    id: ID!</code>&#13;
<code class="sb">    content: String!</code>&#13;
<code class="sb">    author: String!</code>&#13;
<code class="sb">  }</code>&#13;
&#13;
<code class="sb">  type Query {</code>&#13;
<code class="sb">    hello: String</code>&#13;
<code class="sb">    notes: [Note!]!</code>&#13;
<code class="sb">    note(id: ID!): Note!</code>&#13;
<code class="sb">  }</code>&#13;
&#13;
<code class="sb">  type Mutation {</code>&#13;
<code class="sb">    newNote(content: String!): Note!</code>&#13;
<code class="sb">  }</code>&#13;
<code class="sb">`</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Provide resolver functions for our schema fields</code>&#13;
<code class="kr">const</code> <code class="nx">resolvers</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Query</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s1">'Hello world!'</code><code class="p">,</code>&#13;
    <code class="nx">notes</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">notes</code><code class="p">,</code>&#13;
    <code class="nx">note</code><code class="o">:</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">notes</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">note</code> <code class="o">=&gt;</code> <code class="nx">note</code><code class="p">.</code><code class="nx">id</code> <code class="o">===</code> <code class="nx">args</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">Mutation</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">newNote</code><code class="o">:</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="kd">let</code> <code class="nx">noteValue</code> <code class="o">=</code> <code class="p">{</code>&#13;
        <code class="nx">id</code><code class="o">:</code> <code class="nb">String</code><code class="p">(</code><code class="nx">notes</code><code class="p">.</code><code class="nx">length</code> <code class="o">+</code> <code class="mi">1</code><code class="p">),</code>&#13;
        <code class="nx">content</code><code class="o">:</code> <code class="nx">args</code><code class="p">.</code><code class="nx">content</code><code class="p">,</code>&#13;
        <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code>&#13;
      <code class="p">};</code>&#13;
      <code class="nx">notes</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">noteValue</code><code class="p">);</code>&#13;
      <code class="k">return</code> <code class="nx">noteValue</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Apollo Server setup</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ApolloServer</code><code class="p">({</code> <code class="nx">typeDefs</code><code class="p">,</code> <code class="nx">resolvers</code> <code class="p">});</code>&#13;
&#13;
<code class="c1">// Apply the Apollo GraphQL middleware and set the path to /api</code>&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">applyMiddleware</code><code class="p">({</code> <code class="nx">app</code><code class="p">,</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'/api'</code> <code class="p">});</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">({</code> <code class="nx">port</code> <code class="p">},</code> <code class="p">()</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>&#13;
    <code class="sb">`GraphQL Server running at http://localhost:</code><code class="si">${</code><code class="nx">port</code><code class="si">}${</code><code class="nx">server</code><code class="p">.</code><code class="nx">graphqlPath</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p class="pagebreak-before">With the schema and resolver updated to accept a mutation, let’s try it&#13;
out in GraphQL Playground at <em>http://localhost:4000/api</em>. In the&#13;
playground, click the <code>+</code> sign to create a new tab and write the&#13;
mutation as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code> <code class="p">(</code><code class="nx">content</code><code class="o">:</code> <code class="s2">"This is a mutant note!"</code><code class="p">)</code> <code class="p">{</code>&#13;
   <code class="nx">content</code>&#13;
   <code class="nx">id</code>&#13;
   <code class="nx">author</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When you click the Play button, you should receive a response containing&#13;
the content, ID, and author of our new note. You can also see that the&#13;
mutation worked by rerunning the <code>notes</code> query. To do so, either switch back to the GraphQL Playground tab containing that query, or type the following:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">notes</code> <code class="p">{</code>&#13;
    <code class="nx">content</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">author</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When this query runs, you should now see four notes, including the&#13;
recently added one.</p>&#13;
<div data-type="note" epub:type="note"><h1>Data Storage</h1>&#13;
<p>We are currently storing our data in memory. This means that anytime we restart our server, we will lose that data. We’ll be persisting our data using a database in the next chapter.</p>&#13;
</div>&#13;
&#13;
<p>We’ve now successfully implemented our query and mutation resolvers and tested them within the GraphQL Playground user interface.<a data-startref="ix_ch04-asciidoc4" data-type="indexterm" id="idm45339509766232"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45339510733208">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>In this chapter we’ve successfully built a GraphQL API, using the&#13;
<code>apollo-server-express</code> module. We can now run queries and mutations against an in-memory data object. This setup provides us a solid foundation on which to build any API. In the next chapter we’ll explore the ability to persist data by using a database.<a data-startref="ix_ch04-asciidoc1" data-type="indexterm" id="idm45339509764568"/><a data-startref="ix_ch04-asciidoc0" data-type="indexterm" id="idm45339509763864"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>