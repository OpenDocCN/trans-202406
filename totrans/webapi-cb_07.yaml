- en: Chapter 7\. Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms collect user input that is submitted to a remote URL or API endpoint.
    Modern browsers have many built-in form input types for text, numbers, colors,
    and more. A form is one of the main ways you get input from your user.
  prefs: []
  type: TYPE_NORMAL
- en: FormData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FormData API provides a data model for accessing form data. It saves you
    the trouble of having to look up individual DOM elements and get their values.
  prefs: []
  type: TYPE_NORMAL
- en: Even better, once you have a `FormData` object, you can pass it directly to
    the Fetch API to submit the form. Before submission, you can alter or add to the
    data in the `FormData` object.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prevent users from sending invalid data, you can (and should) add client-side
    validation for your forms. This could be something as simple as marking a field
    as required, or more complex validation logic that involves coordinating multiple
    form values or calling an API.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, a developer would usually need to reach for a JavaScript library
    to perform form validation. This could cause headaches due to data duplication;
    it exists in the form data and an in-memory object used by the validation library.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML5 added more built-in validation options, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Marking a field as required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the minimum and maximum values in a number field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a regular expression to validate the field’s input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options are used as attributes on the `<input>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: The browser shows basic validation error messages (see [Figure 7-1](#browserValidation)),
    but the style may not look good with your app’s design. You can use the Constraint
    Validation API to inspect the built-in validation results as well as perform custom
    validation logic and set your own validation messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![A built-in validation message in Chrome](assets/wacb_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. A built-in validation message in Chrome
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To validate a form, you call its `checkValidity` method. All of the fields within
    the form are validated. If all fields are valid, `checkValidity` returns `true`.
    If one or more fields are invalid, `checkValidity` returns `false` and each invalid
    field triggers an `invalid` event. You can also check a specific element by calling
    `checkValidity` on the form field itself.
  prefs: []
  type: TYPE_NORMAL
- en: Every form field has a `validity` object that reflects the current validity
    state. It has a boolean `valid`, which indicates the form’s overall validity state.
    This object also has additional flags that tell you the nature of the validation
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Populating a Form Field from Local Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to remember a form field’s value in local storage. For example, you
    may want to remember the user name entered in a login form.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When submitting the form, use a `FormData` object to get the field value and
    set it in local storage (see [Example 7-1](#code_rememberUsername)). Then, when
    first loading the page, check for a remembered value. If you find a value, populate
    the form field.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. Remembering the `username` field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you pass a form to the `FormData` constructor, it is populated with the
    form’s current values. You can then use the `get` method to retrieve the desired
    field and set it in local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the form on load is a little different. A `FormData` object is not
    kept in sync with the current form values; rather, it includes the form values
    at the time the `FormData` object was created. The opposite is also true—if you
    set a new value in the `FormData` object, it won’t be updated in the form itself.
    Given this, a `FormData` object won’t help when populating the form. [Example 7-1](#code_rememberUsername)
    uses the form’s `elements` property to look up the `username` field and set its
    value that way.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting a Form with Fetch and the FormData API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to submit a form using the Fetch API. You might want to do this to
    add additional information to the form submission that wouldn’t be included by
    the browser, or because the form submission might need an API token that is stored
    in memory rather than entered in the form.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason you might want to do this is to prevent the browser from redirecting
    to a new page, or causing a full page refresh.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `FormData` object containing the data to be submitted. Add the additional
    required data, then submit the form with the Fetch API (see [Example 7-2](#example7-2)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. Adding data with the FormData API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, when you click the Submit button, the browser gets the form data and
    submits it for you. Here you don’t want that because you need to add the API token.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing the submit handler does is call `preventDefault` on the `submit`
    event. This stops the browser from performing the default submit behavior so that
    you can provide your custom logic. The default behavior here is a full page refresh,
    which is probably not what you want.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a `FormData` object by passing the form object to the `FormData`
    constructor. The resulting object will have the existing form data in it, at which
    point you can add additional data like the API token.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can pass the `FormData` object as the body of a POST request using
    the Fetch API. When submitting a form this way, the body is *not* JSON; rather,
    the browser submits it with a content type of `multipart/form-data`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an object representing your form data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent request body looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Submitting a Form as JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to submit a form to an endpoint that expects JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the FormData API to transform the form data into a JavaScript object, and
    use the Fetch API to send it as JSON (see [Example 7-3](#example7-3)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. Submitting a form as JSON using Fetch
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This approach is similar to sending the `FormData` object directly. The only
    differences are that you are converting the form data to JSON and sending it with
    the correct `Content-Type` header.
  prefs: []
  type: TYPE_NORMAL
- en: You can perform the conversion by creating a new empty object and iterating
    over the key/value pairs in the `FormData`. Each pair is copied into the object.
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of this approach is that you can’t use it with `FormData` having
    multiple values bound to the same key. This happens when you have a group of checkboxes
    with the same name; there are multiple entries with the same key.
  prefs: []
  type: TYPE_NORMAL
- en: You could enhance the conversion to detect this case and set an array of values,
    as shown in [Example 7-4](#form_getAll).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4\. Handling array form values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 7-4](#form_getAll) uses the `FormData`’s `getAll` function, which
    returns an array containing all values bound to the given key. This lets you collect
    all values for a given checkbox group into an array.'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAll` always returns an array. If there’s only one value, it is an array
    with one element. `toObject` checks for this scenario, and if the array only has
    one element, it uses that element as the single value in the resulting object.
    Otherwise, it uses the array of values.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a Form Field Required
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to require a form field to have a value, causing a validation error
    if it is left blank.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `required` attribute on the `<input>` element (see [Example 7-5](#example7-5)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-5\. A required field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_forms_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `required` attribute does not have a value.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a field is marked as `required`, it must have a value. If the field is
    blank, its `validity.valid` property is `false` and its `validity.valueMissing`
    property is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: A required field is only considered empty if the value is an empty string. It
    does not trim whitespace, so a value consisting of a few empty spaces is considered
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: Constraining a Number Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to specify a range of allowed values for a number input (`<input type=​"num⁠ber">`).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `min` and `max` properties to specify the allowed range (see [Example 7-6](#example7-6)).
    These values are inclusive, meaning that the minimum and maximum values themselves
    are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-6\. Specifying a range for a number field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a number input’s value is below the minimum or above the maximum, its `validity.valid`
    property is `false`. If it’s below the minimum, the `rangeUnderflow` validity
    flag is set. Similarly, if it exceeds the maximum, the `rangeOverflow` flag is
    set instead.
  prefs: []
  type: TYPE_NORMAL
- en: When you make an `input` of type `number`, the browser adds a spinner control—clickable
    up and down arrows to increase and decrease the value. This spinner control enforces
    the minimum and maximum values—it refuses to decrease the value if it’s already
    at the minimum or increase the value if it’s already at the maximum. However,
    a user is still free to type any value in the field. They can enter a number outside
    of the allowed range, at which point the validity state is set accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If you want more fine-grained control over allowed values, you can also specify
    a `step` value. This limits the allowed values so that the increment must be a
    multiple of the step. Consider an input with a minimum of 0, a maximum of 4, and
    a step of 2\. The only acceptable values for this field would be 0, 2, and 4.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a Validation Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to limit a text field’s value so that it matches a certain pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `pattern` attribute of the `input` to specify a regular expression (see
    [Example 7-7](#example7-7)). The field is considered invalid unless its value
    matches the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-7\. Limiting a field to alphanumeric characters only
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `username` field is invalid if it contains anything other than alphanumeric
    characters. When invalid, the validity state’s `patternMismatch` flag is set.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a flexible validation option, second only to using your own custom validation
    logic (see [“Using Custom Validation Logic”](#recipe_customValidation)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating a regular expression to validate URLs or email addresses can be tricky.
    To handle these cases, you can set the input’s `type` attribute to `url` or `email`,
    and the browser will validate that the field is a valid URL or email address for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to manage the form validation process and show your own error messages
    in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Constraint Validation API and the `invalid` event to detect and mark
    invalid fields.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to handle validation. Some websites are too eager and show
    an error message before the user gets a chance to enter a value. Consider an input
    of type `email`, which is considered invalid until a valid email address is entered.
    If validation occurs immediately, the user sees an error about an invalid email
    address before they’ve even finished typing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this, the validation approach shown here only validates a field under
    two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: When the form is submitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the field has been focused and then lost focus. These fields are considered
    to have been “touched.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, you’ll need to disable the browser’s built-in validation UI by adding
    the `novalidate` attribute to the form, as shown in [Example 7-8](#example7-8).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-8\. Disabling the browser validation UI
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each field needs a placeholder element to contain the error message, as shown
    in [Example 7-9](#example7-9).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-9\. Adding error message placeholders
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, an error message is associated with an input field by its ID.
    The field with the ID `email` has an error message with ID `email-error`, a `name`
    field has an error message `name-error`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this validation approach, each form element listens for three events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invalid`'
  prefs: []
  type: TYPE_NORMAL
- en: Triggered when the form is validated and the field is marked invalid. This sets
    the error message.
  prefs: []
  type: TYPE_NORMAL
- en: '`input`'
  prefs: []
  type: TYPE_NORMAL
- en: Triggered when the value in the field changes. This performs revalidation if
    necessary and clears the error message if the field becomes valid.
  prefs: []
  type: TYPE_NORMAL
- en: '`blur`'
  prefs: []
  type: TYPE_NORMAL
- en: Triggered when the field loses focus. This sets a `data-should-validate` attribute
    to mark the field as touched, after which it is validated in the `input` event
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: The validation code is shown in [Example 7-10](#code_validationFramework).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-10\. Setting up validation for a form field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This example listens to the `input` event. If your form contains checkboxes
    or radio buttons, you may need to listen for the `change` event instead for those
    elements, depending on the browser. See the [article about `input` events from
    MDN](https://oreil.ly/cFIjY):'
  prefs: []
  type: TYPE_NORMAL
- en: For `<input>` elements with `type=checkbox` or `type=​radio`, the `input` event
    should fire whenever a user toggles  the  control,  per  the  HTML  Living  Standard
     specification. However, historically this has not always been the case. Check
    compatibility, or use the `change` event instead for elements of these types.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To complete the basic validation framework, add the listeners to the form fields,
    listen for the form’s `submit` event, and trigger validation (see [Example 7-11](#example7-11)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-11\. Triggering form validation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This code sets up a good basic validation framework that handles the browser’s
    built-in validation. Before submitting the form, it calls `checkValidity`, which
    starts checking all of the inputs inside the form. The browser triggers an `invalid`
    event for any input that fails validation. To handle this, you can listen for
    the `invalid` event on the input elements themselves. From there, you can render
    an appropriate error message.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has validation errors, you want to clear them as soon as the fields
    become valid. This is why `addValidation` listens for the `input` event—this is
    triggered as soon as the user types something in the input field. From there,
    you can immediately recheck the input’s validity. If it is now valid (`checkValidity`
    returns `true`), you can clear the error message. An input is only revalidated
    if the `data-should-validate` attribute is set to `true`. This attribute is added
    when validation fails during form submission, or when an element loses focus.
    This prevents validation errors from appearing before the user is done typing.
    Once the field loses focus, it starts revalidating on every change.
  prefs: []
  type: TYPE_NORMAL
- en: Using Custom Validation Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to perform a validation check that is not supported by the Constraint
    Validation API. For example, you want to validate that a password and password
    confirmation field have the same value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perform the custom validation logic before calling `checkValidity` on the form.
    If the custom validation check fails, call the input’s `setCustomValidity` method
    to set an appropriate error message. If the check passes, clear any previously
    set validation message (see [Example 7-12](#example7-12)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-12\. Using custom validation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re using the browser’s built-in validation UI, you need to call the form
    field’s `reportValidity` method after setting a custom validity message. If you
    are handling the validation UI yourself, this isn’t needed—but make sure to show
    the error message in the appropriate place.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you call `setCustomValidity` on an element with a non-empty string, the
    element is now considered invalid.
  prefs: []
  type: TYPE_NORMAL
- en: The `validatePasswordsMatch` function examines the values of the `password`
    and `confirmPassword` fields. If they don’t match, it calls `setCustomValidity`
    on the `confirmPassword` field to set a validation error message. If they do match,
    it sets it to an empty string, which marks the field as valid again.
  prefs: []
  type: TYPE_NORMAL
- en: The form’s submit handler calls `validatePasswordsMatch` before performing the
    built-in validation. If the `validatePasswordsMatch` check fails, and a custom
    validity is set, `form.checkValidity` fails and the `invalid` event fires on the
    `confirmPassword` field just like any other invalid element.
  prefs: []
  type: TYPE_NORMAL
- en: Validating a Checkbox Group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to enforce that at least one checkbox in a group of checkboxes must
    be checked. Setting the `required` attribute on checkboxes won’t help here because
    it applies to that individual input only, not the group. The browser checks if
    that input is checked and causes a validation error, even if other checkboxes
    in the group are checked.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `FormData` object to get an array of all selected checkboxes, and set
    a custom validation error if the array is empty.
  prefs: []
  type: TYPE_NORMAL
- en: When performing the custom validation, use the `FormData`’s `getAll` method
    to get an array of the selected checkbox values (see [Example 7-13](#example7-13)).
    If the array is empty, no checkboxes are selected, and this is a validation error.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-13\. Validating a checkbox group
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To keep the validation state of the whole group in one place, set the custom
    validity message on the first checkbox only (assuming a name of `option1`). This
    first checkbox serves as a container for the group’s validation message, which
    is necessary because you can only set validity messages on actual `<input>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Then, listen for the `invalid` and `change` events. On the `invalid` event,
    show the error message. On the `change` event (when a checkbox is toggled), perform
    the custom validation and clear the error message if validation succeeds (see
    [Example 7-14](#example7-14)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-14\. Setting up checkbox validation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add validation to each checkbox field and call the `validateCheckboxes`
    function before checking the form’s validity. [Example 7-15](#example7-15) expects
    that you have an element with the ID `checkbox-error`. If there is a checkbox
    validation error, the message will be set on that element.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-15\. Validating the checkbox form
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `required` attribute on the checkboxes in the group won’t have the
    desired effect. This is good for a single checkbox, like one requiring that a
    user accept a license agreement, but when used on a group, it would make each
    individual checkbox required, and form validation would fail unless *all* of them
    were checked. Because there is no HTML element for a “checkbox group,” you’ll
    need to do a little extra work to get the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This example picks the first checkbox in the group as a “container” for the
    validation message. When the user toggles any of the checkboxes, the browser calls
    the change handler and it looks to see if any of the checkboxes are checked. If
    the selection array is empty, this is an error. The custom validity message is
    always set on the first checkbox only. This is to ensure the message is always
    shown and hidden when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at what would happen if you instead applied the custom validity to
    the checkbox being changed.
  prefs: []
  type: TYPE_NORMAL
- en: If no options are checked and the user submits the form, each checkbox has a
    custom validity error message now. All three options are invalid. If you then
    go and check one of the checkboxes, the checkbox’s `change` event will fire and
    check the checkbox group. Now there is an option selected, so it clears the custom
    validity message. However, the other checkboxes are still in an error state. This
    is essentially now equivalent to having set the `required` attribute on all the
    checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: You could get around this by setting the validation message in *all* checkboxes
    from the `validateCheckboxes` function, but it’s less work to just pick one and
    use that as the target for all custom validation messages. The group as a whole
    has a single error message element that gets populated with the validation error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since this example manages its own validation message, make sure to include
    the `novalidate` attribute on the containing form to avoid showing the browser’s
    default validation UI along with your custom validation error.
  prefs: []
  type: TYPE_NORMAL
- en: Validating a Field Asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your custom validation logic requires an asynchronous operation like making
    a network request. For example, a user signup form has a password field. The signup
    form must call an API to validate that the entered password meets password strength
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perform the network request, then set a custom validity message. Do this in
    a function that returns a `Promise`. In the form’s submit handler, await this
    `Promise` before calling `checkValidity` on the form. If the asynchronous validation
    code set a custom validity message, the form validation triggered by `checkValidity`
    handles it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 7-16](#code_asyncValidation) has the validation logic itself. It calls
    a password strength check API and sets the custom validity message accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-16\. Performing asynchronous password strength validation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure you only send passwords over a secure connection (HTTPS). Otherwise,
    you’re sending the user’s password out in plain text, and this is a dangerous
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: Because the function is marked as `async`, it returns a `Promise`. You just
    need to `await` this `Promise` in the form’s submit handler, as shown in [Example 7-17](#example7-17).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-17\. The `async` form submit handler
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This marks the field as invalid on submission if the password doesn’t meet the
    requirements. You can rerun the validation logic when the field changes, only
    this time you’ll do it on the `blur` event rather than `input` as you did with
    synchronous custom validation (see [Example 7-18](#example7-18)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-18\. Revalidating on `blur`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you did this check on the `input` event, you’d be sending a network request
    every time the user pressed a key. The `blur` event defers the revalidation until
    the field loses focus. It calls the validation API again and checks the new validity
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You could also use a debounced version of the validation function. This would
    revalidate on an input event, but only once the user has stopped typing for a
    certain period of time.
  prefs: []
  type: TYPE_NORMAL
- en: '[This article from freeCodeCamp](https://oreil.ly/kLRJa) goes into detail about
    how to create a debounced function. There are also npm packages available that
    will create a debounced version of a function.'
  prefs: []
  type: TYPE_NORMAL
