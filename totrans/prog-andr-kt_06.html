<html><head></head><body><section data-pdf-bookmark="Chapter 6. Handling Concurrency Using Callbacks" data-type="chapter" epub:type="chapter"><div class="chapter" id="handling_concurrency_id">&#13;
<h1><span class="label">Chapter 6. </span>Handling Concurrency Using Callbacks</h1>&#13;
&#13;
&#13;
<p><a data-primary="callbacks" data-type="indexterm" id="ix_ch06-asciidoc0"/>The idiomatic way of handling concurrency in Kotlin is by using <em>coroutines</em>. However, for some time this has been done in Java using threads and callbacks. So why do we need coroutines?</p>&#13;
&#13;
<p>To answer this question, we will revisit a typical Kotlin implementation on Android and discuss the pitfalls of using&#13;
threads. Knowing the weak points of the traditional approach is the key to understanding the motivation behind the&#13;
design of coroutines.</p>&#13;
&#13;
<p>In Android applications, long-running tasks shouldn’t be done on the UI thread, as you’ve seen in the previous chapter.&#13;
If you block the main thread—the UI thread—your app might not have the resources it needs to draw the screen or&#13;
update it appropriately.  In fact, lint will complain if you attempt to do an obvious IO call (e.g., make an HTTP&#13;
connection) while on the UI thread.</p>&#13;
&#13;
<p>An Android application runs smoothly when the main thread completes all its tasks in less than frame time, which is 16 ms&#13;
on most devices. This is a rather short amount of time, and all blocking calls, like network requests (blocking IO), should&#13;
be performed on a background thread.<sup><a data-type="noteref" href="ch06.html#idm46669752343152" id="idm46669752343152-marker">1</a></sup></p>&#13;
&#13;
<p>When you delegate a task to another thread, you typically call a function which starts the asynchronous job. In some&#13;
cases this is “fire-and-forget,” but you’re usually waiting for a result—and you need to act on it. This is&#13;
done by providing a function which will be called once the job finishes. This function is called a <em>callback</em>.&#13;
A callback often accepts arguments, so the background thread commonly calls the callback with the result of the job.&#13;
Doing computation that calls an arbitrary or injected function when complete is known as the <em>callback pattern</em>.</p>&#13;
&#13;
<p>Using callbacks is quite efficient, though it has some limitations and drawbacks. To illustrate this, we’ll&#13;
implement a simple yet realistic example in Kotlin. Coroutines address all issues with callbacks, but before jumping&#13;
right into coroutines, it’s important to understand which problem they aim to solve.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example-of-Purchase Feature" data-type="sect1"><div class="sect1" id="idm46669752338864">&#13;
<h1>Example-of-Purchase Feature</h1>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="example-of-purchase feature" data-type="indexterm" id="ix_ch06-asciidoc1"/>Suppose you’re working on a paid feature of an Android application. After a user registers, you check the list of purchases this user has already made, then act on it. To get the list of purchases, let’s use an object called&#13;
<code>BillingClient</code>. Note that we’re not talking about the actual <code>BillingClient</code> provided by the Android framework,&#13;
<code>com.android.billingclient.api.BillingClient</code>. We’re using our own, much simpler version of the basic concept, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">BillingClient</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">interface</code> <code class="n">BillingCallback</code> <code class="p">{</code>&#13;
        <code class="k">fun</code> <code class="nf">onInitDone</code><code class="p">(</code><code class="n">provider</code><code class="p">:</code> <code class="n">PurchasesProvider</code><code class="p">?)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="cm">/* Implementations should be nonblocking */</code>&#13;
    <code class="k">fun</code> <code class="nf">init</code><code class="p">(</code><code class="n">callback</code><code class="p">:</code> <code class="n">BillingCallback</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A typical task flow would be:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Initialize a connection to the <code>BillingClient</code>. Wait for it to be ready—your callback provides a&#13;
<code>PurchasesProvider</code>, or null in case of error. For now, we won’t handle errors.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use the returned <code>PurchasesProvider</code> to asynchronously fetch the user’s list of purchases.  Your  program  will &#13;
wait  for  the  response,  which  will  contain  the  list  of purchases and perhaps some additional metadata.</p>&#13;
</li>&#13;
<li>&#13;
<p>React to this new information; you might show a list of purchases with UI to provide even more details, or request&#13;
status, cancel an item in an order, etc.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>For further references, we’ll call the preceding flow our <em>logic</em>.</p>&#13;
&#13;
<p>As you can see, this is just an interface with a single method, taking a <code>BillingCallback</code> as input. The&#13;
<code>BillingCallback</code> is declared inside the <code>BillingClient</code> interface because this callback is only used inside&#13;
<code>BillingClient</code>. When an interface is declared inside a class or interface, it tells you about the relationship between&#13;
the class and the interface: the author intended that the class shouldn’t depend on another entity to provide the&#13;
interface. This avoids the risk of breaking the compatibility between the class and the interface. The two are coupled,&#13;
and if you ship a &#13;
<span class="keep-together"><code>BillingClient</code>,</span> you also ship a <code>BillingCallback</code>.&#13;
Notice that we’re using Kotlin 1.4’s new <code>fun interface</code> instead of a classic <code>interface</code>. This will allow for a concise&#13;
syntax when we’ll provide implementations.&#13;
Also, the documentation of the <code>init</code> method says that implementations should be nonblocking. If you haven’t read the&#13;
previous chapter, it means that whatever thread calls this method, it isn’t blocked waiting for the method to return.</p>&#13;
&#13;
<p>Similarly, our <code>PurchasesProvider</code> is shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">PurchasesProvider</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">interface</code> <code class="n">PurchaseFetchCallback</code> <code class="p">{</code>&#13;
        <code class="k">fun</code> <code class="nf">onPurchaseFetchDone</code><code class="p">(</code><code class="n">purchases</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">fetchPurchases</code><code class="p">(</code><code class="n">user</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">callback</code><code class="p">:</code> <code class="n">PurchaseFetchCallback</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For now, let’s assume that we provide those abstractions and their implementations. Even though a real application would&#13;
use framework-provided classes, the important part of this example is the business logic, not the implementations of&#13;
<code>BillingClient</code> and <code>PurchasesProvider</code>.</p>&#13;
&#13;
<p>As an Android developer, we hope that you’re familiar with the core concepts of Android Jetpack’s <code>ViewModel</code>, but don’t&#13;
worry if this isn’t the case, because the details of <code>ViewModel</code> operation aren’t the focus of this discussion. Even without <code>ViewModel</code>, you’ve probably got some version of MVC or MVP or MVVM, all of which largely follow the same pattern.  The&#13;
view does presentation work, the model does logical work, and the controller or view-model is the glue that connects&#13;
them and serves as the network that allows the two to communicate. The important part is the implementation of the&#13;
<em>logic</em> inside the view-model. Everything else is context or framework code—but still important nevertheless. <a data-type="xref" href="#architecture_diagram_id">Figure 6-1</a> shows the target architecture.</p>&#13;
&#13;
<figure><div class="figure" id="architecture_diagram_id">&#13;
<img alt="pawk 0601" src="assets/pawk_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>MVVM architecture.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Suppose now that you’ve structured your application following the <em>single-activity</em> architecture.<sup><a data-type="noteref" href="ch06.html#idm46669752205232" id="idm46669752205232-marker">2</a></sup> The view should be a fragment that displays the purchases of the current user. The&#13;
lifecycle of the fragment should be taken into account in the design. At any moment, the device could be rotated, and&#13;
the fragment re-created. The user could go back, and the fragment could be put into the back stack, if not destroyed.</p>&#13;
&#13;
<p>This is where <code>LiveData</code>, a lifecycle-aware component, comes into play. Every time the fragment is created, it requests&#13;
an instance of<a data-primary="PurchaseViewModel" data-type="indexterm" id="idm46669752203216"/> <code>PurchaseViewModel</code>. We will explain in more detail how it works later.<a data-startref="ix_ch06-asciidoc1" data-type="indexterm" id="idm46669752201904"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating the App" data-type="sect1"><div class="sect1" id="idm46669752338240">&#13;
<h1>Creating the App</h1>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="app creation" data-type="indexterm" id="ix_ch06-asciidoc3"/>In this section, we’ll show you a typical implementation inside an Android application. If you’re already familiar with&#13;
this, you might jump directly to the next section, where we discuss the implementation of the <em>logic</em>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="View-Model" data-type="sect2"><div class="sect2" id="idm46669752197760">&#13;
<h2>View-Model</h2>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="ViewModel" data-type="indexterm" id="idm46669752196352"/><a data-primary="ViewModel" data-type="indexterm" id="idm46669752195152"/>So the business logic is implemented inside a <code>ViewModel</code> (see <a data-type="xref" href="#handling_concurrency_listing_2_3">Example 6-1</a>).&#13;
The view-model requires a <code>BillingClient</code> instance to be constructor-injected<sup><a data-type="noteref" href="ch06.html#idm46669752192640" id="idm46669752192640-marker">3</a></sup> by some other component, as you’ll see&#13;
shortly. <code>BillingClient</code> is a dependency of the <code>ViewModel</code>, and  <code>PurchaseProvider</code> is a dependency of <code>BillingClient</code>.</p>&#13;
&#13;
<p>The view that interacts with this <code>ViewModel</code> triggers the <code>getUserPurchases</code> method (which we haven’t implemented yet)&#13;
in the getter of the <code>purchasesLiveData</code> property. You may have noticed that the type of the <code>purchasesLiveData</code> property is&#13;
<code>LiveData</code> while the private backing property, <code>_purchases</code>, is a <code>MutableLiveData</code>. This is because the <code>ViewModel</code>&#13;
should be the sole component to change the value of the <code>LiveData</code>. So the exposed type to clients of this <code>ViewModel</code>&#13;
is only <code>LiveData</code>, as shown in <a data-type="xref" href="#handling_concurrency_listing_2_3">Example 6-1</a>.</p>&#13;
<div data-type="example" id="handling_concurrency_listing_2_3">&#13;
<h5><span class="label">Example 6-1. </span><code>PurchasesViewModel</code></h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">PurchasesViewModel</code> <code class="k">internal</code> <code class="n">constructor</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">billingClient</code><code class="p">:</code> <code class="n">BillingClient</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">user</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code> <code class="p">:</code> <code class="n">ViewModel</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">var</code> <code class="py">_purchases</code> <code class="p">=</code> <code class="n">MutableLiveData</code><code class="p">&lt;</code><code class="n">UserPurchases</code><code class="p">&gt;()</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">fun</code> <code class="nf">getUserPurchases</code><code class="p">(</code><code class="n">user</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="c1">// TODO: implement</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">purchasesLiveData</code><code class="p">:</code> <code class="n">LiveData</code><code class="p">&lt;</code><code class="n">UserPurchases</code><code class="p">&gt;</code>&#13;
        <code class="k">get</code><code class="p">()</code> <code class="p">{</code>&#13;
            <code class="n">getUserPurchases</code><code class="p">(</code><code class="n">user</code><code class="p">)</code>&#13;
            <code class="k">return</code> <code class="n">_purchases</code>&#13;
        <code class="p">}</code>&#13;
&#13;
    <code class="n">interface</code> <code class="n">BillingClient</code> <code class="p">{</code> <code class="cm">/* removed for brevity*/</code> <code class="p">}</code>&#13;
&#13;
    <code class="n">interface</code> <code class="n">PurchasesProvider</code> <code class="p">{</code> <code class="cm">/* removed for brevity*/</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>We’re almost done—now all we’re missing is the view.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="View" data-type="sect2"><div class="sect2" id="idm46669752178976">&#13;
<h2>View</h2>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="view" data-type="indexterm" id="ix_ch06-asciidoc4"/>In our architecture, the view is a <code>Fragment</code>. As you can see in the following code, the view depends on the&#13;
view-model. This shows how we can use the view-model from inside the view:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">PurchasesFragment</code><code> </code><code class="p">:</code><code> </code><code class="n">Fragment</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">override</code><code> </code><code class="k">fun</code><code> </code><code class="nf">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">:</code><code> </code><code class="n">Bundle</code><code class="p">?</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="k">super</code><code class="p">.</code><code class="n">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="cm">/* Create a ViewModel the first time this Fragment is created.&#13;
         * Re-created Fragment receives the same ViewModel instance after&#13;
         * device rotation. */</code><code>&#13;
</code><code>        </code><code class="k">val</code><code> </code><code class="py">factory</code><code class="p">:</code><code> </code><code class="n">ViewModelProvider</code><code class="p">.</code><code class="n">Factory</code><code> </code><code class="p">=</code><code> </code><code class="n">PurchaseViewModelFactory</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" href="#callout_handling_concurrency_using_callbacks_CO1-1" id="co_handling_concurrency_using_callbacks_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="k">val</code><code> </code><code class="py">model</code><code> </code><code class="k">by</code><code> </code><code class="n">viewModels</code><code class="p">&lt;</code><code class="n">PurchasesViewModel</code><code class="p">&gt;</code><code> </code><code class="p">{</code><code> </code><code class="n">factory</code><code> </code><code class="p">}</code><code>             </code><a class="co" href="#callout_handling_concurrency_using_callbacks_CO1-2" id="co_handling_concurrency_using_callbacks_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">model</code><code class="p">.</code><code class="n">purchasesLiveData</code><code class="p">.</code><code class="n">observe</code><code class="p">(</code><code class="k">this</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><code class="p">(</code><code class="n">_</code><code class="p">,</code><code> </code><code class="n">purchases</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>           </code><a class="co" href="#callout_handling_concurrency_using_callbacks_CO1-3" id="co_handling_concurrency_using_callbacks_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>            </code><code class="c1">// update UI&#13;
</code><code>            </code><code class="n">println</code><code class="p">(</code><code class="n">purchases</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p>Every time the fragment is created, it subscribes to updates of <code>UserPurchases</code> by following three steps:</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_handling_concurrency_using_callbacks_CO1-1" id="callout_handling_concurrency_using_callbacks_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create a factory for the<a data-primary="ViewModel" data-type="indexterm" id="idm46669751973312"/> <code>ViewModel</code> (remember, the <code>ViewModel</code> has dependencies, and it’s certainly not the responsibility of the <code>Fragment</code> to supply them). Strictly speaking, this factory shouldn’t be created inside the fragment, as the factory is now tightly coupled with your fragment—a <code>PurchasesFragment</code> always uses a <code>PurchaseViewModelFactory</code>. In a test environment, where you should test the view independently, this would be a problem.&#13;
So this factory should be injected inside the <code>Fragment</code> through either a dependency injection framework or manual&#13;
injection. For the sake of simplicity, we’ve decided to create it here inside the fragment.&#13;
For the record, <code>ViewModel</code> factory is shown in <a data-type="xref" href="#handling_concurrency_listing_2_5">Example 6-2</a>.</p></dd>&#13;
<dt><a class="co" href="#co_handling_concurrency_using_callbacks_CO1-2" id="callout_handling_concurrency_using_callbacks_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>An instance of <code>PurchasesViewModel</code> is obtained from the <code>viewModels</code> function. This is the recommended way to get a&#13;
<code>ViewModel</code> instance.</p></dd>&#13;
<dt><a class="co" href="#co_handling_concurrency_using_callbacks_CO1-3" id="callout_handling_concurrency_using_callbacks_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Finally, a <code>LiveData</code> instance is retrieved from the <code>ViewModel</code>, and is <em>observed</em> by an <code>Observable</code> instance using&#13;
the method of the same name (“observe”). In this example, the observer is only a lambda function which prints the list&#13;
of purchases into the console. In a production application you would typically trigger an update of all the related&#13;
views inside the fragment.</p></dd>&#13;
</dl>&#13;
&#13;
<p>A <code>ViewModel</code> also has its own lifecycle, which depends on whether the <code>ViewModel</code> &#13;
<span class="keep-together">is bound</span> to  a  fragment  or  an  activity.  In  this  example,  it  is  bound  to  a  fragment.  &#13;
<span class="keep-together">You can tell</span> that by the use of <code>by</code> <code>viewModels&lt;..&gt;</code>. If instead we had used <code>by</code> &#13;
<span class="keep-together"><code>activityViewModels&lt;..&gt;</code></span>, the view-model would have been bound to the activity.</p>&#13;
&#13;
<p>When bound to the fragment, the <code>ViewModel</code> survives device rotations but is destroyed when it isn’t used anymore (e.g.,&#13;
when all fragments that were bound to it are destroyed, except for device rotation).&#13;
If the <code>ViewModel</code> had been bound to the activity, it would outlive the&#13;
activity on device rotation but would be destroyed in every other scenario where the activity is destroyed.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As a <code>ViewModel</code> is retained through configuration change, which destroys and re-creates the containing activity, it&#13;
should never reference a view, <code>Lifecycle</code> instance, or any class instance that may hold a reference to the activity&#13;
context. It can, however, reference the <code>Application</code> context.</p>&#13;
</div>&#13;
&#13;
<p>If you look at the actual code of the <code>BillingClient</code>, you can see that creating a <code>BillingClient.Builder</code> requires&#13;
that you supply a context.&#13;
It can be an activity context, because internally the builder calls <code>context.getApplicationContext()</code> and this is the&#13;
only context reference kept by the <code>BillingClient</code>. An <code>ApplicationContext</code> remains the same during the whole&#13;
<code>Application</code> lifetime. Therefore, you won’t create a memory leak by referencing the <code>ApplicationContext</code> somewhere in&#13;
your app. This is the reason why it is safe to reference <code>BillingClient</code> inside a <code>ViewModel</code>.</p>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#handling_concurrency_listing_2_5">Example 6-2</a>, the dependencies of the <code>ViewModel</code> are created inside &#13;
<span class="keep-together"><code>PurchaseViewModelFactory</code>.</span></p>&#13;
<div data-type="example" id="handling_concurrency_listing_2_5">&#13;
<h5><span class="label">Example 6-2. </span><code>PurchaseViewModelFactory</code></h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">PurchaseViewModelFactory</code> <code class="p">:</code> <code class="n">ViewModelProvider</code><code class="p">.</code><code class="n">Factory</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">provider</code><code class="p">:</code> <code class="n">PurchasesProvider</code> <code class="p">=</code> <code class="n">PurchasesProviderImpl</code><code class="p">()</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">billingClient</code><code class="p">:</code> <code class="n">BillingClient</code> <code class="p">=</code> <code class="n">BillingClientImpl</code><code class="p">(</code><code class="n">provider</code><code class="p">)</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">user</code> <code class="p">=</code> <code class="s">"user"</code> <code class="c1">// Get in from registration service</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code> <code class="p">:</code> <code class="n">ViewModel</code><code class="p">?&gt;</code> <code class="n">create</code><code class="p">(</code><code class="n">modelClass</code><code class="p">:</code> <code class="n">Class</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;):</code> <code class="n">T</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="p">(</code><code class="n">modelClass</code><code class="p">.</code><code class="n">isAssignableFrom</code><code class="p">(</code><code class="n">PurchasesViewModel</code><code class="o">::</code><code class="k">class</code><code class="p">.</code><code class="n">java</code><code class="p">))</code> <code class="p">{</code>&#13;
            <code class="k">return</code> <code class="n">PurchasesViewModel</code><code class="p">(</code><code class="n">billingClient</code><code class="p">,</code> <code class="n">user</code><code class="p">)</code> <code class="k">as</code> <code class="n">T</code>&#13;
        <code class="p">}</code>&#13;
        <code class="k">throw</code> <code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"Unknown ViewModel class"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p><code>BillingClientImpl</code> is the real implementation of the previously shown <code>BillingClient</code> interface (see&#13;
<a data-type="xref" href="#handling_concurrency_listing_2_6">Example 6-3</a> and <a data-type="xref" href="#handling_concurrency_listing_2_7">Example 6-4</a>).</p>&#13;
<div data-type="example" id="handling_concurrency_listing_2_6">&#13;
<h5><span class="label">Example 6-3. </span><code>BillingClientImpl</code></h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">BillingClientImpl</code><code class="p">(</code><code class="k">private</code> <code class="k">val</code> <code class="py">purchasesProvider</code><code class="p">:</code> <code class="n">PurchasesProvider</code><code class="p">)</code> <code class="p">:</code> <code class="n">BillingClient</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">executor</code> <code class="p">=</code>&#13;
        <code class="n">Executors</code><code class="p">.</code><code class="n">newSingleThreadExecutor</code><code class="p">()</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">init</code><code class="p">(</code><code class="n">callback</code><code class="p">:</code> <code class="n">BillingCallback</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="cm">/* perform asynchronous work here */</code>&#13;
        <code class="n">executor</code><code class="p">.</code><code class="n">submit</code> <code class="p">{</code>&#13;
            <code class="k">try</code> <code class="p">{</code>&#13;
                <code class="n">Thread</code><code class="p">.</code><code class="n">sleep</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code>&#13;
                <code class="n">callback</code><code class="p">.</code><code class="n">onInitDone</code><code class="p">(</code><code class="n">purchasesProvider</code><code class="p">)</code>&#13;
            <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">InterruptedException</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="n">e</code><code class="p">.</code><code class="n">printStackTrace</code><code class="p">()</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
<div data-type="example" id="handling_concurrency_listing_2_7">&#13;
<h5><span class="label">Example 6-4. </span><code>PurchasesProviderImpl</code></h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">PurchasesProviderImpl</code> <code class="p">:</code> <code class="n">PurchasesProvider</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">executor</code> <code class="p">=</code>&#13;
        <code class="n">Executors</code><code class="p">.</code><code class="n">newSingleThreadExecutor</code><code class="p">()</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">fetchPurchases</code><code class="p">(</code>&#13;
        <code class="n">user</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
        <code class="n">callback</code><code class="p">:</code> <code class="n">PurchaseFetchCallback</code>&#13;
    <code class="p">)</code> <code class="p">{</code>&#13;
        <code class="cm">/* perform asynchronous work */</code>&#13;
        <code class="n">executor</code><code class="p">.</code><code class="n">submit</code> <code class="p">{</code>&#13;
            <code class="k">try</code> <code class="p">{</code>&#13;
                <code class="c1">// Simulate blocking IO</code>&#13;
                <code class="n">Thread</code><code class="p">.</code><code class="n">sleep</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code>&#13;
                <code class="n">callback</code><code class="p">.</code><code class="n">onPurchaseFetchDone</code><code class="p">(</code>&#13;
                    <code class="n">listOf</code><code class="p">(</code><code class="s">"Purchase1"</code><code class="p">,</code> <code class="s">"Purchase2"</code><code class="p">)</code>&#13;
                <code class="p">)</code>&#13;
            <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">InterruptedException</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="n">e</code><code class="p">.</code><code class="n">printStackTrace</code><code class="p">()</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>To conform to the application design we established, the <code>init</code> and <code>fetchPurchases</code> methods should be nonblocking. This can be achieved with a background thread. &#13;
<span class="keep-together">For efficiency</span> reasons (see the upcoming section), you may not want to create &#13;
<span class="keep-together">a new thread</span> every time you connect to the <code>BillingClient</code>. Instead you can use a thread pool, which can be created using <code>ThreadPoolExecutor</code> instances directly, &#13;
<span class="keep-together">or many common</span> configurations are available via the factory methods of &#13;
<span class="keep-together"><code>java.util.concurrent.Executors</code>.</span> Using<a data-primary="Executors.newSingleThreadExecutor()" data-type="indexterm" id="idm46669751556176"/>  <code>Executors.newSingleThreadExecutor()</code>, you have a single dedicated thread at your disposal which can be reused for each asynchronous call. You might think that <code>PurchasesProviderImpl</code> and &#13;
<span class="keep-together"><code>BillingClientImpl</code></span> should share the same thread pool. It’s up to you—though for brevity we didn’t do it here. For a production app, you may have multiple &#13;
<span class="keep-together"><code>ThreadPoolExecutor</code>s</span> that service different parts of your app.</p>&#13;
&#13;
<p>If you look at how callbacks are used in those implementations, you can see that they’re called right after&#13;
<a data-primary="Thread.sleep()" data-type="indexterm" id="idm46669751552032"/><code>Thread.sleep()</code> (which simulates a blocking IO call). Unless explicitly posted to the main thread (generally through&#13;
an instance of the <code>Handler</code> class, or through a <code>LiveData</code> instance’s <code>postValue</code> method), callbacks are invoked within the&#13;
context of the background thread. This is critical, and it’s very important to be aware of how to communicate between&#13;
thread contexts, as you’ll see in the next section.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Be aware of which thread runs the provided callback, as it depends on the implementation. Sometimes the&#13;
callback is asynchronously run on the calling thread, whereas it can be synchronously executed on the background thread.<a data-startref="ix_ch06-asciidoc4" data-type="indexterm" id="idm46669751548000"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Implement the Logic" data-type="sect2"><div class="sect2" id="idm46669752178384">&#13;
<h2>Implement the Logic</h2>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="logic implementation" data-type="indexterm" id="idm46669751546016"/><a data-primary="logic implementation" data-type="indexterm" id="idm46669751545168"/>Now that all the necessary components are set in place, the <em>logic</em> can be implemented. The steps are shown in <a data-type="xref" href="#handling_concurrency_listing_3_1">Example 6-5</a>.</p>&#13;
<div data-type="example" id="handling_concurrency_listing_3_1">&#13;
<h5><span class="label">Example 6-5. </span>Logic</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code><code> </code><code class="k">fun</code><code> </code><code class="nf">getUserPurchases</code><code class="p">(</code><code class="n">user</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>   </code><code class="n">billingClient</code><code class="p">.</code><code class="n">init</code><code> </code><code class="p">{</code><code> </code><code class="n">provider</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>                   </code><a class="co" href="#callout_handling_concurrency_using_callbacks_CO2-1" id="co_handling_concurrency_using_callbacks_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>       </code><code class="c1">// this is called from a background thread&#13;
</code><code>       </code><code class="n">provider</code><code class="o">?.</code><code class="n">fetchPurchases</code><code class="p">(</code><code class="n">user</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><code class="n">purchases</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>  </code><a class="co" href="#callout_handling_concurrency_using_callbacks_CO2-2" id="co_handling_concurrency_using_callbacks_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>           </code><code class="n">_purchases</code><code class="p">.</code><code class="n">postValue</code><code class="p">(</code><code class="n">UserPurchases</code><code class="p">(</code><code class="n">user</code><code class="p">,</code><code> </code><code class="n">purchases</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code>       </code><code class="p">}</code><code>&#13;
</code><code>   </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_handling_concurrency_using_callbacks_CO2-1" id="callout_handling_concurrency_using_callbacks_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Call <code>billingClient.init</code> and supply a callback which will be called whenever the client’s initialization process&#13;
finishes. If the client supplies a non-null &#13;
<span class="keep-together"><code>PurchasesProvider</code></span>  instance, proceed with the next step.</p></dd>&#13;
<dt><a class="co" href="#co_handling_concurrency_using_callbacks_CO2-2" id="callout_handling_concurrency_using_callbacks_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>At this point you have the <code>PurchasesProvider</code> instance ready for use. Call <code>fetchPurchases</code>, providing the&#13;
current user as the first parameter, and the callback that should be executed once the provider has done its job. Look&#13;
carefully at the content of the callback:</p></dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">_purchases</code><code class="p">.</code><code class="n">postValue</code><code class="p">(</code><code class="n">UserPurchases</code><code class="p">(</code><code class="n">user</code><code class="p">,</code> <code class="n">purchases</code><code class="p">))</code></pre>&#13;
&#13;
<p>On a <code>MutableLiveData</code> instance, you use either the <code>setValue</code> or the <code>postValue</code> method. The difference between the&#13;
two is that you’re only allowed to use <code>setValue</code> &#13;
<span class="keep-together">if you’re</span> calling it from the main thread. When this isn’t the case,&#13;
using  <code>postValue</code> adds the new value into a queue that the <code>MutableLiveData</code> will process on the next frame of the main&#13;
thread. This is an implementation of the work queue pattern (see <a data-type="xref" href="ch05.html#wqueue">“Work Queues”</a>), and a thread-safe way to assign a new value&#13;
to a &#13;
<span class="keep-together"><code>MutableLiveData</code>.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm46669751438880">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>So this is it. It works—or at least it fulfills the specifications. We invite you to step back a little and look at the big picture. What’s the structure of <code>getUserPurchases</code>? It’s made of a function call, which is provided another function, which itself calls a function, which is provided another function…. It’s like Russian nesting dolls. It’s already a little hard to follow, and adding exception handling can quickly turn it into “nesting hell” (see <a data-type="xref" href="#callbackusage">Figure 6-2</a>). In order to keep our example logic simple and easy to follow, we’ve omitted corner cases where some API calls fail; for example, networking issues or authorization errors make some IO background work brittle and prone to failure, and production code should be able to&#13;
handle this.</p>&#13;
&#13;
<figure><div class="figure" id="callbackusage">&#13;
<img alt="pawk 0602" src="assets/pawk_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>Callback usage.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The code that specifies what happens upon a response of the <code>BillingClient</code> (callback 2) is <em>included</em> in the code of&#13;
the first callback. If you decide to inline all this code, like we did in <a data-type="xref" href="#handling_concurrency_listing_3_1">Example 6-5</a>, you have&#13;
several levels of indentations, which rapidly grow as the problem to solve becomes more complex. On the other hand, if&#13;
you decide to encapsulate the first callback into its own function, you will indeed reduce the indentation level of&#13;
<code>getUserPurchases</code> and its apparent complexity.  At the same time, you would increase the number of directions to follow&#13;
to fully understand the business logic.</p>&#13;
&#13;
<p>This is the first drawback of code using callbacks. It rapidly becomes complex, and may become hard to maintain if not&#13;
administered with caution and thoughtful design. Some would consider that even with careful precautions this path is&#13;
dangerous. As developers, we strive to create a system that we and our coworkers can &#13;
<span class="keep-together">handle.</span></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Using <code>CompletableFuture</code> or another similar library like RxJava, you can rewrite <code>getUserPurchases</code> like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="kt">void</code> <code class="nf">getUserPurchases</code><code class="o">(</code><code class="n">String</code> <code class="n">user</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">billingClient</code><code class="o">.</code><code class="na">initAsync</code><code class="o">()</code>&#13;
    <code class="o">.</code><code class="na">thenCompose</code> <code class="o">{</code> <code class="n">provider</code> <code class="o">-&gt;</code>&#13;
        <code class="n">fetchPurchasesAsync</code><code class="o">(</code><code class="n">provider</code><code class="o">,</code> <code class="n">user</code><code class="o">)</code>&#13;
    <code class="o">}</code>&#13;
    <code class="o">.</code><code class="na">thenAccept</code> <code class="o">{</code> <code class="n">purchases</code> <code class="o">-&gt;</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">purchases</code><code class="o">.</code><code class="na">postValue</code><code class="o">(...)</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>It’s a bit cleaner, with no nested indentations, and even handles exceptions properly. However, you can see that it&#13;
relies on the combinators <code>thenCompose</code> and <code>thenAccept</code>, which operate on <code>CompletableFuture&lt;T&gt;</code>. While our simple example&#13;
uses only two combinators, a lot of them exist, each one for a specific purpose. Some would consider the learning curve&#13;
of another, unfamiliar pattern and API to be a weakness of this pattern.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Structured concurrency" data-type="sect3"><div class="sect3" id="idm46669751331984">&#13;
<h3>Structured concurrency</h3>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="structured concurrency and" data-type="indexterm" id="idm46669751331056"/><a data-primary="structured concurrency" data-secondary="app creation and" data-type="indexterm" id="idm46669751329776"/>Imagine now that some API calls are quite expensive computationally. For example, a user of your app navigates to a view which triggers some of those API calls, but as the content isn’t loading instantly they lose patience and tap back, and&#13;
start a new series of operations in another part of the app. In this situation, you don’t want your expensive API calls to continue running, as they may put unnecessary load on your backend servers, or even on the application itself. Further, what happens if a UI that should be updated when a callback fires no longer exists?  A <code>NullPointerException</code> is probably your best case, and a memory leak your worst. Instead, let’s cancel the procedure initialized inside the view-model. How would you do that? You would have to listen to a particular lifecycle event of the fragment lifecycle termination events: <code>onStop</code>, <code>onPause</code>, or <code>onDestroy</code>. In this specific case, you’d probably want to do that inside <code>onStop</code>, which would be fired just before resources are reclaimed. <code>onPause</code> would fire each time the application in the background in favor of an incoming call or when switching between apps, and <code>onDestroy</code> happens a little later than we need. When the <code>onStop</code> event fires, you should notify the view-model that it should stop any background processing. This requires a thread-safe way of interrupting threads. A volatile <code>isCancelled</code> Boolean would be checked inside the callbacks to decide whether they should proceed or not. So it’s definitely possible, but cumbersome and fragile.</p>&#13;
&#13;
<p class="pagebreak-before">What if this cancellation was done automatically? Imagine that the background processing was tied to the lifecycle of&#13;
the view-model. The moment that the view-model is destroyed, all background processing gets cancelled. It’s not a fairy&#13;
tale—it even has a name: <em>structured concurrency</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Memory leaks" data-type="sect3"><div class="sect3" id="idm46669751322192">&#13;
<h3>Memory leaks</h3>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="memory leaks and" data-type="indexterm" id="idm46669751320960"/><a data-primary="memory leaks" data-secondary="in app creation" data-type="indexterm" id="idm46669751319984"/>Automatically cancelling dangling background threads has another benefit: the less risk of a memory leak. A&#13;
callback might hold a reference on a component which either has a lifecycle or is a child of a component that has one. If this component is eligible for garbage collection, while a reference of that component exists in some running thread, the memory can’t be reclaimed, and you have a memory leak. Using <code>LiveData</code> like in the previous example is safe even if you don’t cancel background tasks. Nevertheless, more generally speaking, it’s never good to leave tasks running for nothing.</p>&#13;
&#13;
<p>Cancellation isn’t the only possible thing that can go wrong. There are other pitfalls to using threads as primitives for&#13;
asynchronous computations (which we’ll refer to as the <em>threading model</em>), and we’ll cover them in the next section.<a data-startref="ix_ch06-asciidoc3" data-type="indexterm" id="idm46669751316816"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Limitations of the Threading Model" data-type="sect1"><div class="sect1" id="idm46669751315856">&#13;
<h1>Limitations of the Threading Model</h1>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="threading model limitations" data-type="indexterm" id="idm46669751314576"/><a data-primary="threading model" data-secondary="limitations of" data-type="indexterm" id="idm46669751313632"/>In an Android application, processes and tasks are always competing for memory. With only one main thread, or UI thread,&#13;
the clever Android developer must find ways to manipulate and handle threading efficiently.</p>&#13;
&#13;
<p>When using a single thread, asynchronous tasks offloaded to that thread execute serially—one task after another. If one of&#13;
the tasks takes forever to execute, the remaining work cannot be processed until that task completes, as shown in <a data-type="xref" href="#figure6_4">Figure 6-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure6_4">&#13;
<img alt="Blocking Work" src="assets/pawk_0603.png"/>&#13;
<h6><span class="label">Figure 6-3. </span>Tasks execute serially inside a thread.</h6>&#13;
</div></figure>&#13;
&#13;
<p>In situations where a background task might take a long time to execute, you need more than one background thread.&#13;
<a data-primary="ThreadPoolExecutor" data-type="indexterm" id="idm46669751308352"/>The <code>ThreadPoolExecutor</code> primitive lets you spin up a number of threads and toss onto it blocks of work to execute, as shown in <a data-type="xref" href="#figure6_5">Figure 6-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure6_5">&#13;
<img alt="ThreadPoolExecutor" src="assets/pawk_0604.png"/>&#13;
<h6><span class="label">Figure 6-4. </span>A <code>ThreadPoolExecutor</code> handles all the heavy lifting of spinning up the threads, load-balancing work across those threads, and even killing those threads.</h6>&#13;
</div></figure>&#13;
&#13;
<p>However, having more threads isn’t always a good thing. Here are some caveats:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>CPUs can only execute a certain number of threads in parallel.</p>&#13;
</li>&#13;
<li>&#13;
<p>Threads themselves are expensive in terms of memory—each thread costs you at least 64 Kb of RAM.</p>&#13;
</li>&#13;
<li>&#13;
<p>When a CPU core switches execution from one thread to another, a <em>thread context switch</em> happens.<sup><a data-type="noteref" href="ch06.html#idm46669751299776" id="idm46669751299776-marker">4</a></sup> Those switches aren’t free. While it’s not a problem when you have a few threads, the impact of thread context switches can be noticeable if you keep adding more threads. You could reach a point were your code is actually slower than if you were using fewer threads.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669751298384">&#13;
<h1>Summary</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You can implement asynchronous logic using callbacks. You might also want to check out some other related framework&#13;
APIs like <code>Handler</code> and <code>HandlerThread</code>. Using callbacks can lead to complex nested function calls, or to situations&#13;
where the flow of the logic is split in several classes and may become hard to follow. If this becomes problematic, one&#13;
solution is to rely on <code>CompletableFuture</code>s, or a similar API; the third-party framework RxJava has this kind of&#13;
functionality, but requires learning yet another set of APIs that can quickly become coupled to your business logic and&#13;
change the way you write your application code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Most often, asynchronous logic is about retrieving and manipulating data which is then rendered as view instances on-screen. To this purpose, Android Jetpack’s <code>ViewModel</code> offers lifecycle-aware components which help you produce more&#13;
organized and maintainable code.</p>&#13;
</li>&#13;
<li>&#13;
<p>When a component reaches the end of its lifecycle, chances are that some related background tasks should now be&#13;
cancelled; otherwise, they just consume memory and increase the risk of memory leaks, or even an application crash.&#13;
<em>Structured concurrency</em> is the ideal solution to this, which we’ll cover in the next chapter.</p>&#13;
</li>&#13;
<li>&#13;
<p>Using threads as concurrency primitives has its limitations. You need to make sure you are not creating too many of&#13;
them because of their memory cost, and performance could suffer due to too many thread-context switches.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Coroutines are meant to address the limitations of the <em>threading model</em>.&#13;
The next four chapters—which focus on coroutines, structured concurrency, channels, and flows—are the “peak”&#13;
of the book and highlight how Kotlin gives Android developers a true advantage in gaining control over asynchronous computations.<a data-startref="ix_ch06-asciidoc0" data-type="indexterm" id="idm46669751288944"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669752343152"><sup><a href="ch06.html#idm46669752343152-marker">1</a></sup> Nonblocking IO using <code>java.nio.channels.SocketChannel</code> can be done on the UI thread without blocking it. However, most of the time when dealing with IO, you will be using blocking APIs like <code>java.io.InputStream</code>.</p><p data-type="footnote" id="idm46669752205232"><sup><a href="ch06.html#idm46669752205232-marker">2</a></sup> A single activity and multiple fragments.</p><p data-type="footnote" id="idm46669752192640"><sup><a href="ch06.html#idm46669752192640-marker">3</a></sup> Developing to interfaces, and not to actual implementations, improves the testability and portability of your code. Inside a test environment, you’re able to swap the actual implementations of the dependencies with custom-mocked ones. By portability, let’s assume you have an interface called <code>AnalyticsManager</code> that provides some methods that you’ll implement to notify your analytics service. Considering that a robust analytics SaaS with dashboards and heavy data visualization and authorization is a heavy lift by itself, most app developers are going to leverage a third-party library to handle that part of their flow. If, for example, you change from one provider to another, as long as you’ve <em>composed</em> your interactions to match the <code>AnalyticsManager</code> interface, your client code never gets touched, or changes, or potentially introduces a new bug; all that’s updated is the business logic of the <code>AnalyticsManager</code> implementation.</p><p data-type="footnote" id="idm46669751299776"><sup><a href="ch06.html#idm46669751299776-marker">4</a></sup> Thread switching involves saving and loading CPU registers and memory maps.</p></div></div></section></body></html>