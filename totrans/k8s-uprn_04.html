<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 4. Common kubectl Commands" data-type="chapter" epub:type="chapter"><div class="chapter" id="common_kubectl">
<h1><span class="label">Chapter 4. </span>Common kubectl Commands</h1>
<p>The <code>kubectl</code> command-line utility is a powerful tool, and in the following chapters, you will use it to create objects and interact with the Kubernetes API. <a data-primary="kubectl tool" data-secondary="commands" data-type="indexterm" id="ix_kubctlcmd"/>Before that, however, it makes sense to go over the basic <code>kubectl</code> commands that apply to all Kubernetes objects.</p>
<section data-pdf-bookmark="Namespaces" data-type="sect1"><div class="sect1" id="idm45664079978464">
<h1>Namespaces</h1>
<p>Kubernetes uses <em>namespaces</em> to organize objects in the cluster.<a data-primary="namespaces" data-secondary="default, changing with kubectl" data-type="indexterm" id="idm45664079976272"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="namespaces" data-type="indexterm" id="idm45664079975328"/> You
can think of each namespace as a folder that holds a set of objects.
By default, the <code>kubectl</code> command-line tool interacts with the <code>default</code>
namespace. If you want to use a different namespace, you can pass
<code>kubectl</code> the <code>--namespace</code> flag. For example, <span class="keep-together"><code>kubectl --namespace=mystuff</code></span> references objects in the <code>mystuff</code> namespace. You can also use the shorthand
<code>-n</code> flag if you’re feeling concise. If you want to interact with all namespaces—for example, to list all Pods in your cluster—you can pass the <code>--all-namespaces</code>
flag.</p>
</div></section>
<section data-pdf-bookmark="Contexts" data-type="sect1"><div class="sect1" id="idm45664079969648">
<h1>Contexts</h1>
<p>If you want to change the default namespace more permanently, you can use a <em>context</em>. <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="contexts" data-type="indexterm" id="idm45664079967504"/><a data-primary="contexts, managing with kubectl" data-type="indexterm" id="idm45664079966224"/>This gets recorded in a <code>kubectl</code> configuration file, usually located at <em>$HOME/.kube/config</em>.  This configuration file also stores how to both find and authenticate to your cluster. For example, you can create a context with a different default namespace for your <code>kubectl</code> commands using:</p>
<pre data-type="programlisting">$ <strong>kubectl config set-context my-context --namespace=mystuff</strong></pre>
<p class="pagebreak-before less_space">This creates a new context, but it doesn’t actually start using it
yet. To use this newly created context, you can run:</p>
<pre data-type="programlisting">$ <strong>kubectl config use-context my-context</strong></pre>
<p>Contexts can also be used to manage different clusters or different
users for authenticating to those clusters using the <code>--users</code> or
<code>--clusters</code> flags with the <code>set-context</code> command.</p>
</div></section>
<section data-pdf-bookmark="Viewing Kubernetes API Objects" data-type="sect1"><div class="sect1" id="idm45664079959200">
<h1>Viewing Kubernetes API Objects</h1>
<p>Everything contained in Kubernetes is represented by a RESTful resource.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="viewing Kubernetes API objects" data-type="indexterm" id="idm45664079957296"/><a data-primary="Kubernetes objects" data-type="indexterm" id="idm45664079956032"/> Throughout this book, we refer to these resources as <em>Kubernetes objects</em>. Each Kubernetes object exists at a unique HTTP path; for example, <em>https://your-k8s.com/api/v1/namespaces/default/pods/my-pod</em> leads to the representation of a Pod in the default namespace named <code>my-pod</code>. The <code>kubectl</code> command makes HTTP requests to these URLs to access the Kubernetes objects that reside at these paths.<a data-primary="Kubernetes objects" data-secondary="viewing with kubectl" data-type="indexterm" id="idm45664079953184"/></p>
<p>The most basic command for viewing Kubernetes objects via <code>kubectl</code> is <code>get</code>. If you run <code>kubectl get &lt;<em>resource-name</em>&gt;</code>, you will get a listing of all resources in the current namespace. If you want to get a specific resource, you can use <code>kubectl get &lt;<em>resource-name</em>&gt; &lt;<em>obj-name</em>&gt;</code>.</p>
<p>By default, <code>kubectl</code> uses a human-readable printer for viewing the
responses from the API server, but this human-readable printer removes
many of the details of the objects to fit each object on one terminal line. One way to get slightly more information is to add the <code>-o wide</code> flag, which gives more details, on a longer line.  <a data-primary="JSON" data-type="indexterm" id="idm45664079946864"/>If you want to view the complete object, you can also view the objects as raw JSON or YAML using the <code>-o json</code> or <code>-o yaml</code> flags, respectively.</p>
<p>A common option for manipulating the output of <code>kubectl</code> is to
remove the headers, which is often useful when combining <code>kubectl</code> with
Unix pipes (e.g., <code>kubectl ... | awk ...</code>). If you specify the <code>--no-headers</code> flag, <code>kubectl</code> will skip the headers at the top of the
human-readable table.<a data-primary="Unix pipes, combining kubectl with" data-type="indexterm" id="idm45664079942288"/></p>
<p>Another common task is extracting specific fields from the object. <code>kubectl</code> uses the <a data-primary="JSONPath query language" data-type="indexterm" id="idm45664079940752"/>JSONPath query language to select fields in the returned object. The complete details of JSONPath are beyond the scope of this chapter, but as an example, this command will extract and print the IP address of the specified Pod:</p>
<pre data-type="programlisting">$ <strong>kubectl get pods my-pod -o jsonpath --template={.status.podIP}</strong></pre>
<p>You can also view multiple objects of different types by using a comma separated list of types, for example:</p>
<pre data-type="programlisting">$ <strong>kubectl get pods,services</strong></pre>
<p>This will display all Pods and services for a given namespace.</p>
<p>If you are<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="describe" data-type="indexterm" id="idm45664079936432"/> interested in more detailed information about a particular
object, use the <code>describe</code> command:</p>
<pre data-type="programlisting">$ <strong>kubectl describe &lt;<em>resource-name</em>&gt; &lt;<em>obj-name</em>&gt;</strong></pre>
<p>This will provide a rich multiline human-readable description of the object as well as any other relevant, related objects and events in the
Kubernetes cluster.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="explain" data-type="indexterm" id="idm45664079932192"/></p>
<p>If you would like to see a list of supported fields for each supported type of Kubernetes object, you can use the <code>explain</code> command:</p>
<pre data-type="programlisting">$ <strong>kubectl explain pods</strong></pre>
<p>Sometimes you want to continually observe the state of a particular Kubernetes
resource to see changes to the resource when they occur. For example, you
might be waiting for your application to restart.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get commands --watch flag" data-type="indexterm" id="idm45664079928560"/> The <code>--watch</code>
flag enables this. You can add this flag to any <code>kubectl get</code> command to
continuously monitor the state of a particular resource.</p>
</div></section>
<section data-pdf-bookmark="Creating, Updating, and Destroying Kubernetes Objects" data-type="sect1"><div class="sect1" id="idm45664079958576">
<h1>Creating, Updating, and Destroying Kubernetes Objects</h1>
<p>Objects in the Kubernetes API are represented as JSON or YAML files.<a data-primary="Kubernetes objects" data-secondary="creating, updating, and destroying with kubectl" data-type="indexterm" id="idm45664079924544"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="creating, updating, and destroying Kubernetes objects" data-type="indexterm" id="idm45664079923392"/><a data-primary="YAML" data-secondary="Kubernetes objects represented as" data-type="indexterm" id="idm45664079922144"/><a data-primary="JSON" data-secondary="Kubernetes objects represented as" data-type="indexterm" id="idm45664079921232"/>
These files are either returned by the server in response to a query
or posted to the server as part of an API request. You can use these
YAML or JSON files to create, update, or delete objects on the Kubernetes
server.</p>
<p>Let’s assume that you have a simple object stored in <em>obj.yaml</em>. You
can use <code>kubectl</code> to create this object in Kubernetes by running:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f obj.yaml</strong></pre>
<p>Notice that you don’t <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="apply -f" data-type="indexterm" id="idm45664079917488"/>need to specify the resource type of the object;
it’s obtained from the object file itself.</p>
<p>Similarly, after you make changes to the object, you can use the <code>apply</code> command again to update the object:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f obj.yaml</strong></pre>
<p>The <code>apply</code> tool will only modify objects that are different from the current
objects in the cluster. If the objects you are creating already exist in the cluster, it will simply exit successfully without making any changes. This makes it useful for loops where you want to ensure the state of the cluster matches the state of the filesystem. You can repeatedly use <code>apply</code> to reconcile state.</p>
<p>If you want to see what the <code>apply</code> command will do without actually making the changes, you can use the <code>--dry-run</code> flag to print the objects to the terminal without actually sending them to the server.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="apply --dry-run" data-type="indexterm" id="idm45664079911360"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you feel like making interactive edits instead of editing a local
file, you <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="edit" data-type="indexterm" id="idm45664079909136"/>can instead use the <code>edit</code> command, which will download the latest object state and then launch an editor that contains the definition:</p>
<pre data-type="programlisting">$ <strong>kubectl edit &lt;<em>resource-name</em>&gt; &lt;<em>obj-name</em>&gt;</strong></pre>
<p>After you save the file, it will be automatically uploaded back to the Kubernetes cluster.</p>
</div>
<p>The <code>apply</code> command also records the history of previous configurations in an
annotation within the object. You can manipulate these records with the
<code>edit-last-applied</code>, <code>set-last-applied</code>, and <code>view-last-applied</code> commands. For example:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f myobj.yaml view-last-applied</strong></pre>
<p>will show you the last state that was applied to the object.</p>
<p>When you want to delete an object, you can simply run:</p>
<pre data-type="programlisting">$ <strong>kubectl delete -f obj.yaml</strong></pre>
<p>It is important to note that <code>kubectl</code> will not prompt you to confirm the deletion.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="delete" data-type="indexterm" id="idm45664079898016"/> Once you issue the command, the object <em>will</em> be deleted.</p>
<p>Likewise, you can delete an object using the resource type and name:</p>
<pre data-type="programlisting">$ <strong>kubectl delete &lt;<em>resource-name</em>&gt; &lt;<em>obj-name</em>&gt;</strong></pre>
</div></section>
<section data-pdf-bookmark="Labeling and Annotating Objects" data-type="sect1"><div class="sect1" id="idm45664079925648">
<h1>Labeling and Annotating Objects</h1>
<p>Labels and annotations are tags for your objects. <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="labeling and annotating objects" data-type="indexterm" id="idm45664079891840"/><a data-primary="Kubernetes objects" data-secondary="labeling and annotating with kubectl" data-type="indexterm" id="idm45664079890576"/>We’ll discuss the differences in <a data-type="xref" href="ch06.xhtml#labels_and_annotations">Chapter 6</a>, but for now, you can update the labels and annotations on any Kubernetes object using the <code>label</code> and <code>annotate</code> commands. For example, to add the <code>color=red</code> label to a Pod named <code>bar</code>, you can run:</p>
<pre data-type="programlisting">$ <strong>kubectl label pods bar color=red</strong></pre>
<p>The syntax <a data-primary="annotations" data-secondary="kubectl annotate command" data-type="indexterm" id="idm45664079885536"/>for annotations is identical.</p>
<p>By default, <code>label</code> and <code>annotate</code> will not let you overwrite an existing label. To do this, you need to add the <code>--overwrite</code> flag.</p>
<p>If you want to remove a label, you can use the <em><code>&lt;label-name&gt;-</code></em> syntax:</p>
<pre data-type="programlisting">$ <strong>kubectl label pods bar color-</strong></pre>
<p>This will remove the <code>color</code> label from the Pod named <code>bar</code>.</p>
</div></section>
<section data-pdf-bookmark="Debugging Commands" data-type="sect1"><div class="sect1" id="idm45664079879072">
<h1>Debugging Commands</h1>
<p><code>kubectl</code> also makes a number of commands available for debugging your
containers. <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="debugging" data-type="indexterm" id="idm45664079876800"/><a data-primary="debugging" data-secondary="kubectl commands for" data-type="indexterm" id="idm45664079875552"/><a data-primary="logs" data-secondary="viewing with kubectl" data-type="indexterm" id="idm45664079874608"/>You can use the following to see the logs for a running container:</p>
<pre data-type="programlisting">$ <strong>kubectl logs &lt;<em>pod-name</em>&gt;</strong></pre>
<p>If you have multiple containers in your Pod, you can choose the container to view using the <code>-c</code> flag.</p>
<p>By default, <code>kubectl logs</code> lists the current logs and exits. If you instead want to continuously stream the logs back to the terminal without exiting, you can add the <code>-f</code> (follow) command-line flag.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="logs" data-type="indexterm" id="idm45664079869472"/></p>
<p>You can also use the <code>exec</code> command to execute <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="exec" data-type="indexterm" id="idm45664079867392"/>a command in a running container:</p>
<pre data-type="programlisting">$ <strong>kubectl exec -it &lt;<em>pod-name</em>&gt; -- bash</strong></pre>
<p>This will provide you with an interactive shell inside the running container so that you can perform more debugging.</p>
<p>If you don’t have bash or some other <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="attach" data-type="indexterm" id="idm45664079863504"/>terminal available within your container, you can always <code>attach</code> to the running
process:</p>
<pre data-type="programlisting">$ <strong>kubectl attach -it <em>&lt;pod-name&gt;</em></strong></pre>
<p>The <code>attach</code> command is similar to <code>kubectl logs</code> but will allow you to send input to the running
process, assuming that process is set up to read from standard input.</p>
<p>You can also copy <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="cp (copy)" data-type="indexterm" id="idm45664079858464"/>files to and from a container using the <code>cp</code> command:</p>
<pre data-type="programlisting">$ <strong>kubectl cp &lt;<em>pod-name&gt;:&lt;/path/to/remote/file&gt; &lt;/path/to/local/file&gt;</em></strong></pre>
<p>This will copy a file from a running container to your local machine. You can also specify directories, or reverse the syntax to copy a file
from your local machine back out to the container.</p>
<p>If you want to access your Pod via the network, you can use the <code>port-forward</code> command to forward network traffic
from the local machine to the Pod.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="port-forward" data-type="indexterm" id="idm45664079853920"/><a data-primary="port forwarding" data-secondary="kubectl port-forward command" data-type="indexterm" id="idm45664079852592"/> This enables you to securely tunnel network traffic through to containers that
might not be exposed anywhere on the public network. For example, the following command:</p>
<pre data-type="programlisting">$ <strong>kubectl port-forward <em>&lt;pod-name&gt;</em> 8080:80</strong></pre>
<p>opens up a connection that forwards traffic from the local machine on port 8080 to the remote container on port 80.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also use the <code>port-forward</code> command with services by specifying <code>services/<em>&lt;service-name&gt;</em></code> instead of <code><em>&lt;pod-name&gt;</em></code>, but
note that if you do port-forward to a service, the requests will only ever be forwarded to a single Pod in that service.<a data-primary="services" data-secondary="using kubectl port-forward command with" data-type="indexterm" id="idm45664079846288"/> They will not go through the service load balancer.</p>
</div>
<p>If you want to view Kubernetes events, you can<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get events" data-type="indexterm" id="idm45664079844512"/><a data-primary="events" data-secondary="viewing with kubectl get events command" data-type="indexterm" id="idm45664079843264"/> use the <code>kubectl get events</code> command to see a list of the latest 10 events on all objects in a given namespace:</p>
<pre data-type="programlisting">$ <strong>kubectl get events</strong></pre>
<p>You can also stream events as they happen by adding <code>--watch</code> to the <code>kubectl get events</code> command. You may also wish to include <code>-A</code> to see events in all namespaces.</p>
<p>Finally, if you are interested in how your cluster is using resources, you can use<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="top" data-type="indexterm" id="idm45664079838528"/><a data-primary="resources" data-secondary="showing usage with kubectl top command" data-type="indexterm" id="idm45664079837280"/> the <code>top</code> command to see the list of resources in use by either nodes or Pods. This <span class="keep-together">command</span>:</p>
<pre data-type="programlisting">$ <strong>kubectl top nodes</strong></pre>
<p>will display the total CPU and memory in use by the nodes in terms of both absolute units (e.g., cores) and percentage
of available resources (e.g., total number of cores). Similarly, this command:</p>
<pre data-type="programlisting">$ <strong>kubectl top pods</strong></pre>
<p>will show all Pods and their resource usage. By default it only displays Pods in the current namespace, but you can
add the <code>--all-namespaces</code> flag to see resource usage by all Pods in the cluster.</p>
<p>These <code>top</code> commands only work if a metrics server is running in your cluster.
Metrics servers are present in nearly every managed Kubernetes environment
and many unmanaged environments as well. But if these commands fail, it may
be because you need to install a metrics server.</p>
</div></section>
<section data-pdf-bookmark="Cluster Management" data-type="sect1"><div class="sect1" id="idm45664079878128">
<h1>Cluster Management</h1>
<p>The <code>kubectl</code> tool can also be used to manage the cluster itself.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="cluster management" data-type="indexterm" id="idm45664079828912"/><a data-primary="clusters" data-secondary="kubectl cluster management commands" data-type="indexterm" id="idm45664079827632"/> The most
common action that people take to manage their cluster is to cordon and
drain a particular node. When you <em>cordon</em> a node, you prevent future
Pods from being scheduled onto that machine. When you <em>drain</em> a node, you
remove any Pods that are currently running on that machine. A good example
use case for these commands would be removing a physical machine for repairs
or upgrades. In that scenario, you can use <code>kubectl cordon</code> followed by <code>kubectl drain</code> to safely remove the machine from the cluster. Once the machine is repaired, you can use <code>kubectl uncordon</code> to re-enable Pods scheduling onto the node. There is no <code>undrain</code> command; Pods will naturally get scheduled onto the empty node as they are created. For something quick affecting a node (e.g., a machine reboot), it is generally unnecessary to cordon or drain; it’s only necessary if the machine will be out of service long enough that you want the Pods to move to a different machine.</p>
</div></section>
<section data-pdf-bookmark="Command Autocompletion" data-type="sect1"><div class="sect1" id="idm45664079823552">
<h1>Command Autocompletion</h1>
<p><code>kubectl</code> supports integration with your shell to enable tab completion for both commands and resources. <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="autocompletion of" data-type="indexterm" id="idm45664079821648"/>Depending on your environment, you may need to install the <code>bash-completion</code> package before you activate command autocompletion.<a data-primary="bash-completion package" data-type="indexterm" id="idm45664079819744"/> You can do this using the appropriate package manager:</p>
<pre data-type="programlisting">
# macOS
$ <strong>brew install bash-completion</strong>

# CentOS/Red Hat
$ <strong>yum install bash-completion</strong>

# Debian/Ubuntu
$ <strong>apt-get install bash-completion</strong>
</pre>
<p>When installing on macOS, make sure to follow the instructions from <code>brew</code> about how to activate tab completion using your <em>${HOME}/.bash_profile</em>.</p>
<p>Once <code>bash-completion</code> is installed, you can temporarily activate it for your terminal using:</p>
<pre data-type="programlisting">$ <strong>source &lt;(kubectl completion bash)</strong></pre>
<p>To make this automatic for every terminal, add it to your <em>${HOME}/.bashrc</em> file:</p>
<pre data-type="programlisting">$ <strong>echo "source &lt;(kubectl completion bash)" &gt;&gt; ${HOME}/.bashrc</strong></pre>
<p>If you use <code>zsh</code>, you can find<a data-primary="zsh shell, command autocompletion" data-type="indexterm" id="idm45664079810656"/> similar <a href="https://oreil.ly/aYujA">instructions online</a>.</p>
</div></section>
<section data-pdf-bookmark="Alternative Ways of Viewing Your Cluster" data-type="sect1"><div class="sect1" id="idm45664079808912">
<h1>Alternative Ways of Viewing Your Cluster</h1>
<p>In addition to <code>kubectl</code>, there are other tools for interacting with your Kubernetes cluster.<a data-primary="clusters" data-secondary="viewing, alternatives to kubectl" data-type="indexterm" id="idm45664079806928"/><a data-primary="editors, plugins for Kubernetes" data-type="indexterm" id="idm45664079805856"/> For example, there are plug-ins for several editors that <a data-primary="IntelliJ" data-type="indexterm" id="idm45664079805040"/><a data-primary="Eclipse" data-type="indexterm" id="idm45664079804288"/><a data-primary="Visual Studio Code" data-type="indexterm" id="idm45664079803616"/>integrate Kubernetes and the editor environment, including:</p>
<ul>
<li>
<p><a href="http://bit.ly/32ijGV1">Visual Studio Code</a></p>
</li>
<li>
<p><a href="http://bit.ly/2Gen1eG">IntelliJ</a></p>
</li>
<li>
<p><a href="http://bit.ly/2XHi6gP">Eclipse</a></p>
</li>
</ul>
<p>If you are using a managed Kubernetes service, most of them also feature a graphical interface to Kubernetes integrated into their web-based user experience. Managed Kubernetes in the public cloud also integrates with  sophisticated monitoring tools that can help you gain insights into how your applications are running.<a data-primary="GUIs (graphical user interfaces)" data-secondary="open source GUIs for Kubernetes" data-type="indexterm" id="idm45664079797824"/><a data-primary="Rancher dashboard" data-type="indexterm" id="idm45664079796816"/><a data-primary="Headlamp project" data-type="indexterm" id="idm45664079796144"/></p>
<p>There are also several open source graphical interfaces for Kubernetes including <a href="https://oreil.ly/mliob">Rancher Dashboard</a> and the <a href="https://oreil.ly/lDvbs">Headlamp project</a>.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45664079793552">
<h1>Summary</h1>
<p><code>kubectl</code> is a powerful tool for managing your applications in your
Kubernetes cluster. This chapter has illustrated many of the common
uses for the tool, but <code>kubectl</code> has a great deal of built-in help
available.<a data-primary="kubectl tool" data-secondary="commands" data-startref="ix_kubctlcmd" data-type="indexterm" id="idm45664079791088"/> You can start viewing this help with:</p>
<pre data-type="programlisting">$ <strong>kubectl help</strong></pre>
<p>or:</p>
<pre data-type="programlisting">$ <strong>kubectl help <em>&lt;command-name&gt;</em></strong></pre>
</div></section>
</div></section></div></body></html>