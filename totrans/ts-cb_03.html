<html><head></head><body><section data-pdf-bookmark="Chapter 2. Basic Types" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch02">&#13;
<h1><span class="label">Chapter 2. </span>Basic Types</h1>&#13;
&#13;
&#13;
<p><a data-primary="basic types" data-secondary="overview" data-type="indexterm" id="id468"/>Now that you are all set up, it’s time to write some TypeScript! Starting out should be easy, but you will soon run into situations where you’re unsure if you’re doing the right thing. Should you use interfaces or type aliases? Should you annotate or let type inference do its magic? What about <code>any</code> and <code>unknown</code>: are they safe to use? Some people on the internet said you should never use them, so why are they part of &#13;
<span class="keep-together">TypeScript?</span></p>&#13;
&#13;
<p>All these questions will be answered in this chapter. We will look at the basic types that make TypeScript and learn how an experienced TypeScript developer will use them. You can use this as a foundation for the upcoming chapters, so you get a feel for how the TypeScript compiler gets to its types and how it interprets your &#13;
<span class="keep-together">annotations.</span></p>&#13;
&#13;
<p>This is about the interaction between your code, the editor, and the compiler. And it’s about going up and down the type hierarchy, as we will see in <a data-type="xref" href="#ch02_item_objects">Recipe 2.3</a>. Whether you’re an experienced TypeScript developer or just starting out, you’ll find useful information in this chapter.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="2.1 Annotating Effectively" data-type="sect1"><div class="sect1" id="ch02_item_annotation">&#13;
<h1>2.1 Annotating Effectively</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id208">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="basic types" data-secondary="annotating effectively" data-type="indexterm" id="ix_0102-asciidoc0"/><a data-primary="type annotations" data-secondary="annotating effectively" data-type="indexterm" id="ix_0102-asciidoc1"/>Annotating types is cumbersome and boring.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id469">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Annotate only when you want your types checked.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id25">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>A type annotation is a way to explicitly tell which types to expect. You know, the prominent stuff in other programming languages, where the verbosity of <code>StringBuilder stringBuilder = new StringBuilder()</code> makes sure that you’re really, really dealing with a <code>StringBuilder</code>. The opposite is type inference, where TypeScript tries to figure out the type for you:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Type inference</code>&#13;
<code class="kd">let</code> <code class="nx">aNumber</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
<code class="c1">// aNumber: number</code>&#13;
&#13;
<code class="c1">// Type annotation</code>&#13;
<code class="kd">let</code> <code class="nx">anotherNumber</code><code class="o">:</code> <code class="kt">number</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>&#13;
<code class="c1">// anotherNumber: number</code></pre>&#13;
&#13;
<p>Type annotations are also the most obvious and visible syntax difference between TypeScript and JavaScript.</p>&#13;
&#13;
<p>When you start learning TypeScript, you might want to annotate everything to express the types you’d expect. This might feel like the obvious choice, but you can also use annotations sparingly and let TypeScript figure out types for you.</p>&#13;
&#13;
<p>A type annotation is a way for you to express where contracts have to be checked. If you add a type annotation to a variable declaration, you tell the compiler to check if types match during the assignment:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">me</code><code class="o">: </code><code class="kr">Person</code> <code class="o">=</code> <code class="nx">createPerson</code><code class="p">();</code></pre>&#13;
&#13;
<p>If <code>createPerson</code> returns something that isn’t compatible with <code>Person</code>, TypeScript will throw an error. Do this if you really want to be sure you’re dealing with the right type.</p>&#13;
&#13;
<p>Also, from this moment on, <code>me</code> is of type <code>Person</code>, and TypeScript will treat it as a &#13;
<span class="keep-together"><code>Person</code></span>. If there are more properties in <code>me</code>—for example, a <code>profession</code>—TypeScript won’t allow you to access them. It’s not defined in <code>Person</code>.</p>&#13;
&#13;
<p>If you add a type annotation to a function signature’s return value, you tell the compiler to check if types match the moment you return that value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">createPerson</code><code class="p">()</code><code class="o">: </code><code class="kr">Person</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">39</code> <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">If you return something that doesn’t match <code>Person</code>, TypeScript will throw an error. Do this if you want to be completely sure that you return the correct type. This especially comes in handy if you are working with functions that construct big objects from various sources.</p>&#13;
&#13;
<p>If you add a type annotation to a function signature’s parameters, you tell the compiler to check if types match the moment you pass along arguments:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">,</code> <code class="nx">person</code><code class="p">.</code><code class="nx">age</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="nx">me</code><code class="p">);</code></pre>&#13;
&#13;
<p>In my opinion this is the most important and unavoidable type annotation. Everything else can be inferred:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// Inferred!</code>&#13;
<code class="c1">// return type is { name: string, age: number }</code>&#13;
<code class="kd">function</code> <code class="nx">createPerson</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">39</code> <code class="p">};</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Inferred!</code>&#13;
<code class="c1">// me: { name: string, age: number}</code>&#13;
<code class="kr">const</code> <code class="nx">me</code> <code class="o">=</code> <code class="nx">createPerson</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Annotated! You have to check if types are compatible</code>&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">,</code> <code class="nx">person</code><code class="p">.</code><code class="nx">age</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// All works</code>&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="nx">me</code><code class="p">);</code></pre>&#13;
&#13;
<p><a data-primary="structural type system" data-type="indexterm" id="ix_0102-asciidoc2"/>You can use inferred object types where you expect an annotation because TypeScript has a <em>structural type system</em>. In a structural type system, the compiler will only take into account the members (properties) of a type, not the actual name.</p>&#13;
&#13;
<p>Types are compatible if all members of the type to check against are available in the type of the value. We also say that the <em>shape</em> or <em>structure</em> of a type has to match:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">User</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">,</code> <code class="nx">person</code><code class="p">.</code><code class="nx">age</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">user</code><code class="o">:</code> <code class="nx">User</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="mi">815</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="nx">user</code><code class="p">);</code> <code class="c1">// works!</code></pre>&#13;
&#13;
<p><code>User</code> has more properties than <code>Person</code>, but all properties that are in <code>Person</code> are also in <code>User</code>, and they have the same type. This is why it’s possible to pass <code>User</code> objects to <code>printPerson</code>, even though the types don’t have any explicit connection.</p>&#13;
&#13;
<p>However, if you pass a literal, TypeScript will complain that there are excess properties that should not be there:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">printPerson</code><code class="p">({</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="mi">1000</code><code class="p">,</code>&#13;
  <code class="c1">// ^- Argument of type '{ name: string; age: number; id: number; }'</code>&#13;
  <code class="c1">//    is not assignable to parameter of type 'Person'.</code>&#13;
  <code class="c1">//    Object literal may only specify known properties,</code>&#13;
  <code class="c1">//    and 'id' does not exist in type 'Person'.(2345)</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>This makes sure that you didn’t expect properties to be present in this type and then wonder why changing them has no effect.</p>&#13;
&#13;
<p>With a structural type system, you can create interesting patterns with carrier variables with the type inferred, and you can reuse the same variable in different parts of your software, with no similar connection to each other:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Studying</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">semester</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Student</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">semester</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">createPerson</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">39</code><code class="p">,</code> <code class="nx">semester</code><code class="o">:</code> <code class="mi">25</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="s2">"XPA"</code> <code class="p">};</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">,</code> <code class="nx">person</code><code class="p">.</code><code class="nx">age</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">studyForAnotherSemester</code><code class="p">(</code><code class="nx">student</code><code class="o">:</code> <code class="nx">Studying</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">student</code><code class="p">.</code><code class="nx">semester</code><code class="o">++</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">isLongTimeStudent</code><code class="p">(</code><code class="nx">student</code><code class="o">:</code> <code class="nx">Student</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">student</code><code class="p">.</code><code class="nx">age</code> <code class="o">-</code> <code class="nx">student</code><code class="p">.</code><code class="nx">semester</code> <code class="o">/</code> <code class="mi">2</code> <code class="o">&gt;</code> <code class="mi">30</code> <code class="o">&amp;&amp;</code> <code class="nx">student</code><code class="p">.</code><code class="nx">semester</code> <code class="o">&gt;</code> <code class="mi">20</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">me</code> <code class="o">=</code> <code class="nx">createPerson</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// All work!</code>&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="nx">me</code><code class="p">);</code>&#13;
<code class="nx">studyForAnotherSemester</code><code class="p">(</code><code class="nx">me</code><code class="p">);</code>&#13;
<code class="nx">isLongTimeStudent</code><code class="p">(</code><code class="nx">me</code><code class="p">);</code></pre>&#13;
&#13;
<p><code>Student</code>, <code>Person</code>, and <code>Studying</code> have some overlap but are unrelated to each other. <code>createPerson</code> returns something that is compatible with all three types. If you have annotated too much, you would need to create a lot more types and a lot more checks than necessary, without any benefit.<a data-startref="02-asciidoc2" data-type="indexterm" id="id470"/></p>&#13;
&#13;
<p>So annotate wherever you want to have your types checked, at least for function &#13;
<span class="keep-together">arguments</span>.<a data-startref="ix_0102-asciidoc1" data-type="indexterm" id="id471"/><a data-startref="ix_0102-asciidoc0" data-type="indexterm" id="id472"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="2.2 Working with any and unknown" data-type="sect1"><div class="sect1" id="ch02_item_any">&#13;
<h1>2.2 Working with any and unknown</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id26">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="any type" data-secondary="unknown type versus" data-type="indexterm" id="ix_0202-asciidoc0"/><a data-primary="basic types" data-secondary="any and unknown" data-type="indexterm" id="ix_0202-asciidoc1"/><a data-primary="top types" data-type="indexterm" id="ix_0202-asciidoc2"/><a data-primary="unknown type" data-secondary="any type versus" data-type="indexterm" id="ix_0202-asciidoc3"/>There are two top types in TypeScript, <code>any</code> and <code>unknown</code>. Which one should you use?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id473">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <code>any</code> if you effectively want to deactivate typing; use <code>unknown</code> when you need to &#13;
<span class="keep-together">be cautious.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id27">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Both <code>any</code> and <code>unknown</code> are top types, which means that every value is compatible with <code>any</code> or <code>unknown</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">name</code><code class="o">:</code> <code class="kr">any</code> <code class="o">=</code> <code class="s2">"Stefan"</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">person</code><code class="o">:</code> <code class="kr">any</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code> <code class="p">};</code>&#13;
<code class="kr">const</code> <code class="nx">notAvailable</code><code class="o">:</code> <code class="kr">any</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code></pre>&#13;
&#13;
<p>Since <code>any</code> is a type every value is compatible with, you can access any property without restriction:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">name</code><code class="o">:</code> <code class="kr">any</code> <code class="o">=</code> <code class="s2">"Stefan"</code><code class="p">;</code>&#13;
<code class="c1">// This is ok for TypeScript, but will crash in JavaScript</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">.</code><code class="nx">profession</code><code class="p">.</code><code class="nx">experience</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">level</code><code class="p">);</code></pre>&#13;
&#13;
<p><code>any</code> is also compatible with every subtype, except <code>never</code>. This means you can narrow the set of possible values by assigning a new type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">me</code><code class="o">:</code> <code class="kr">any</code> <code class="o">=</code> <code class="s2">"Stefan"</code><code class="p">;</code>&#13;
<code class="c1">// Good!</code>&#13;
<code class="kr">const</code> <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="nx">me</code><code class="p">;</code>&#13;
<code class="c1">// Bad, but ok for the type system.</code>&#13;
<code class="kr">const</code> <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code> <code class="o">=</code> <code class="nx">me</code><code class="p">;</code></pre>&#13;
&#13;
<p>Being so permissive, <code>any</code> can be a constant source of potential errors and pitfalls since you effectively deactivate type-checking.</p>&#13;
&#13;
<p><a data-primary="any type" data-secondary="uses for" data-type="indexterm" id="id474"/>While everybody seems to agree that you shouldn’t use <code>any</code> in your codebases, there are some situations where <code>any</code> is really useful:</p>&#13;
<dl>&#13;
<dt>Migration</dt>&#13;
<dd>&#13;
<p>When you go from JavaScript to TypeScript, chances are that you already have a large codebase with a lot of implicit information on how your data structures and objects work. It might be a chore to get everything spelled out in one go. <code>any</code> can help you migrate to a safer codebase incrementally.</p>&#13;
</dd>&#13;
<dt>Untyped third-party dependencies</dt>&#13;
<dd>&#13;
<p>You might have a JavaScript dependency that still refuses to use TypeScript (or something similar). Or even worse: there are no up-to-date types for it. Definitely Typed is a great resource, but it’s also maintained by volunteers. It’s a formalization of something that exists in JavaScript but is not directly derived from it. There might be errors (even in such popular type definitions like React’s), or they just might not be up to date!</p>&#13;
&#13;
<p>This is where <code>any</code> can help you. When you know how the library works, if the documentation is good enough to get you going, and if you use it sparingly, <code>any</code> can be an option instead of fighting types.</p>&#13;
</dd>&#13;
<dt>JavaScript prototyping</dt>&#13;
<dd>&#13;
<p>TypeScript works a bit differently from JavaScript and needs to make a lot of trade-offs to ensure that you don’t run into edge cases. This also means that if you write certain things that would work in JavaScript, you’d get errors in &#13;
<span class="keep-together">TypeScript:</span></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">person</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">key</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">person</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
<code class="c1">// Element implicitly has an 'any' --^</code>&#13;
<code class="c1">// type because expression of type 'string'</code>&#13;
<code class="c1">// can't be used to index type 'Person'.</code>&#13;
<code class="c1">// No index signature with a parameter of type 'string'</code>&#13;
<code class="c1">// was found on type 'Person'.(7053)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Find out why this is an error in <a data-type="xref" href="ch09.html#ch09_working_with_object_keys">Recipe 9.1</a>. In cases like this, <code>any</code> can help you to switch off type-checking for a moment because you know what you’re doing. And since you can go from every type to <code>any</code>, but also back to every other type, you have little, explicit unsafe blocks throughout your code where you are in charge of what’s happening:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">person</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">key</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">person</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Once you know this part of your code works, you can start adding the right types, work around TypeScript’s restrictions, and type assertions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">person</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">key</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">person</code><code class="p">[</code><code class="nx">key</code> <code class="kr">as</code> <code class="kr">keyof</code> <code class="nx">Person</code><code class="p">]</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Whenever you use <code>any</code>, make sure you activate the <code>noImplicitAny</code> flag in your <em>tsconfig.json</em>; it is activated by default in <code>strict</code> mode. TypeScript needs you to explicitly annotate <code>any</code> when you don’t have a type through inference or annotation. This helps find potentially problematic situations later on.</p>&#13;
&#13;
<p class="pagebreak-before"><a data-primary="unknown type" data-type="indexterm" id="id475"/>An alternative to <code>any</code> is <code>unknown</code>. It allows for the same values, but the things you can do with it are very different. Where <code>any</code> allows you to do everything, <code>unknown</code> allows you to do nothing. All you can do is pass values around; the moment you want to call a function or make the type more specific, you first need to do type-checks:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">me</code><code class="o">:</code> <code class="kr">unknown</code> <code class="o">=</code> <code class="s2">"Stefan"</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="nx">me</code><code class="p">;</code>&#13;
<code class="c1">//    ^- Type 'unknown' is not assignable to type 'string'.(2322)</code>&#13;
<code class="kr">const</code> <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code> <code class="o">=</code> <code class="nx">me</code><code class="p">;</code>&#13;
<code class="c1">//    ^- Type 'unknown' is not assignable to type 'number'.(2322)</code></pre>&#13;
&#13;
<p>Type-checks and control flow analysis help you do more with <code>unknown</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">doSomething</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kr">unknown</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">value</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// value: string</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"It's a string"</code><code class="p">,</code> <code class="nx">value</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">());</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">value</code> <code class="o">===</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// value: number</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"it's a number"</code><code class="p">,</code> <code class="nx">value</code> <code class="o">*</code> <code class="mi">2</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If your apps work with a lot of different types, <code>unknown</code> is great for making sure that you can carry values throughout your code but don’t run into any safety problems because of <code>any</code>’s permissiveness.<a data-startref="ix_0202-asciidoc3" data-type="indexterm" id="id476"/><a data-startref="ix_0202-asciidoc2" data-type="indexterm" id="id477"/><a data-startref="ix_0202-asciidoc1" data-type="indexterm" id="id478"/><a data-startref="ix_0202-asciidoc0" data-type="indexterm" id="id479"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="2.3 Choosing the Right Object Type" data-type="sect1"><div class="sect1" id="ch02_item_objects">&#13;
<h1>2.3 Choosing the Right Object Type</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id28">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="{} (empty object) type" data-type="indexterm" id="ix_0902-asciidoc0"/><a data-primary="basic types" data-secondary="choosing the right object type" data-type="indexterm" id="ix_0902-asciidoc1"/><a data-primary="empty object ({}) type" data-type="indexterm" id="ix_0902-asciidoc2"/><a data-primary="Object interface" data-type="indexterm" id="ix_0902-asciidoc3"/>You want to allow for values that are JavaScript objects, but there are three different object types: <code>object</code>, <code>Object</code>, and <code>{}</code>. Which one should you use?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id480">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <code>object</code> for compound types like objects, functions, and arrays. Use <code>{}</code> for everything that has a value.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id29">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>TypeScript divides its types into two branches. <a data-primary="primitive types" data-type="indexterm" id="id481"/>The first branch, <em>primitive types</em>, includes <code>number</code>, <code>boolean</code>, <code>string</code>, <code>symbol</code>, <code>bigint</code>, and some subtypes. <a data-primary="compound types" data-type="indexterm" id="id482"/>The second branch, <em>compound types</em>, includes everything that is a subtype of an object and is ultimately composed of other compound types or primitive types. <a data-primary="type hierarchy" data-type="indexterm" id="id483"/><a data-type="xref" href="#img-type-hierarchy">Figure 2-1</a> provides &#13;
<span class="keep-together">an overview.</span></p>&#13;
&#13;
<figure><div class="figure" id="img-type-hierarchy">&#13;
<img alt="tscb 0201" src="assets/tscb_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>The type hierarchy in TypeScript</h6>&#13;
</div></figure>&#13;
&#13;
<p>In some situations you want to target values that are <em>compound types</em>, either because you want to modify certain properties or because you just want to be safe that you don’t pass any primitive values. For example <code>Object.create</code> creates a new object and takes its prototype as the first argument. This can only be a <em>compound type</em>; otherwise, your runtime JavaScript code would crash:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>&#13;
<code class="c1">// Uncaught TypeError: Object prototype may only be an Object or null: 2</code>&#13;
<code class="c1">//    at Function.create (&lt;anonymous&gt;)</code></pre>&#13;
&#13;
<p>In TypeScript, three types seem to do the same thing: The empty object type <code>{}</code>, the uppercase O <code>Object</code> interface, and the lowercase O <code>object</code> type. Which one do you use for compound types?</p>&#13;
&#13;
<p><code>{}</code> and <code>Object</code> allow for roughly the same values, which are everything but <code>null</code> or <code>undefined</code> (given that <code>strict</code> mode or <code>strictNullChecks</code> is activated):</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">obj</code><code class="o">:</code> <code class="p">{};</code> <code class="c1">// Similar to Object</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="mi">32</code><code class="p">;</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="s2">"Hello"</code><code class="p">;</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">)</code> <code class="p">};</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code> <code class="c1">// Error</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code> <code class="c1">// Error</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code> <code class="p">};</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="p">[];</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="sr">/.*/</code><code class="p">;</code></pre>&#13;
&#13;
<p>The <code>Object</code> interface is compatible with all values that have the <code>Object</code> prototype, which is every value from every primitive and compound type.</p>&#13;
&#13;
<p>However, <code>Object</code> is a defined interface in TypeScript, and it has some requirements for certain functions. For example, the <code>toString</code> method, which is <code>toString() =&gt; string</code> and part of any non-nullish value, is part of the <code>Object</code> prototype. If you assign a value with a different <code>tostring</code> method, TypeScript will error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">okObj</code><code class="o">:</code> <code class="p">{}</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code> <code class="c1">// OK</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">obj</code><code class="o">:</code> <code class="nb">Object</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="c1">// ^-  Type 'boolean' is not assignable to type 'string'.ts(2322)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>Object</code> can cause some confusion due to this behavior, so in most cases, you’re good with <code>{}</code>.</p>&#13;
&#13;
<p>TypeScript also has a <em>lowercase</em> <code>object</code> type. This is more the type you’re looking for, as it allows for any compound type but no primitive types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">obj</code><code class="o">:</code> <code class="nx">object</code><code class="p">;</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="mi">32</code><code class="p">;</code> <code class="c1">// Error</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="s2">"Hello"</code><code class="p">;</code> <code class="c1">// Error</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code> <code class="c1">// Error</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">)</code> <code class="p">};</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>  <code class="c1">// Error</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code> <code class="c1">// Error</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code> <code class="p">};</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="p">[];</code>&#13;
<code class="nx">obj</code> <code class="o">=</code> <code class="sr">/.*/</code><code class="p">;</code></pre>&#13;
&#13;
<p>If you want a type that excludes functions, regexes, arrays, and the like, see <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, where we create one on our own.<a data-startref="ix_0902-asciidoc3" data-type="indexterm" id="id484"/><a data-startref="ix_0902-asciidoc2" data-type="indexterm" id="id485"/><a data-startref="ix_0902-asciidoc1" data-type="indexterm" id="id486"/><a data-startref="ix_0902-asciidoc0" data-type="indexterm" id="id487"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="2.4 Working with Tuple Types" data-type="sect1"><div class="sect1" id="ch02_item_tuple_types">&#13;
<h1>2.4 Working with Tuple Types</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id30">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="arrays" data-secondary="annotating with tuple types" data-type="indexterm" id="ix_0302-asciidoc0"/><a data-primary="basic types" data-secondary="tuple types" data-type="indexterm" id="ix_0302-asciidoc1"/><a data-primary="tuple types" data-seealso="variadic tuple types" data-type="indexterm" id="ix_0302-asciidoc2"/>You are using JavaScript arrays to organize your data. The order is important, and so are the types at each position. But TypeScript’s type inference makes it really cumbersome to work with.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id488">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Annotate with tuple types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id31">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="arrays" data-secondary="tuple types and" data-type="indexterm" id="ix_0302-asciidoc3"/>Like objects, JavaScript arrays are a popular way to organize data in a complex object. Instead of writing a typical <code>Person</code> object as we did in other recipes, you can store entries element by element:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Stefan"</code><code class="p">,</code> <code class="mi">40</code><code class="p">];</code> <code class="c1">// name and age</code></pre>&#13;
&#13;
<p>The benefit of using arrays over objects is that array elements don’t have property names. When you assign each element to variables using destructuring, it becomes really easy to assign custom names:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// objects.js</code>&#13;
<code class="c1">// Using objects</code>&#13;
<code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">age</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">person</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// Stefan</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">age</code><code class="p">);</code> <code class="c1">// 40</code>&#13;
&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">anotherName</code> <code class="o">=</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">anotherAge</code> <code class="o">=</code> <code class="nx">age</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">person</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">anotherName</code><code class="p">);</code> <code class="c1">// Stefan</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">anotherAge</code><code class="p">);</code> <code class="c1">// 40</code>&#13;
&#13;
<code class="c1">// arrays.js</code>&#13;
<code class="c1">// Using arrays</code>&#13;
<code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Stefan"</code><code class="p">,</code> <code class="mi">40</code><code class="p">];</code> <code class="c1">// name and age</code>&#13;
&#13;
<code class="kr">const</code> <code class="p">[</code><code class="nx">name</code><code class="p">,</code> <code class="nx">age</code><code class="p">]</code> <code class="o">=</code> <code class="nx">person</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// Stefan</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">age</code><code class="p">);</code> <code class="c1">// 40</code>&#13;
&#13;
<code class="kr">const</code> <code class="p">[</code><code class="nx">anotherName</code><code class="p">,</code> <code class="nx">anotherAge</code><code class="p">]</code> <code class="o">=</code> <code class="nx">person</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">anotherName</code><code class="p">);</code> <code class="c1">// Stefan</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">anotherAge</code><code class="p">);</code> <code class="c1">// 40</code></pre>&#13;
&#13;
<p>For APIs where you need to assign new names constantly, using arrays is very comfortable, as explained in <a data-type="xref" href="ch10.html#ch10">Chapter 10</a>.</p>&#13;
&#13;
<p>When using TypeScript and relying on type inference, however, this pattern can cause some issues. By default, TypeScript infers the array type from an assignment. Arrays are open-ended collections with the same element in each position:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Stefan"</code><code class="p">,</code> <code class="mi">40</code><code class="p">];</code>&#13;
<code class="c1">// person: (string | number)[]</code></pre>&#13;
&#13;
<p>So TypeScript thinks that <code>person</code> is an array, where each element can be either a string or a number, and it allows for plenty of elements after the original two. This means when you’re destructuring, each element is also of type <code>string</code> or <code>number</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="p">[</code><code class="nx">name</code><code class="p">,</code> <code class="nx">age</code><code class="p">]</code> <code class="o">=</code> <code class="nx">person</code><code class="p">;</code>&#13;
<code class="c1">// name: string | number</code>&#13;
<code class="c1">// age: string | number</code></pre>&#13;
&#13;
<p>That makes a comfortable pattern in JavaScript really cumbersome in Typescript. You would need to do control flow checks to narrow the type to the actual one, where it should be clear from the assignment that this is not necessary.</p>&#13;
&#13;
<p>Whenever you think you need to do extra work in JavaScript just to satisfy TypeScript, there’s usually a better way. In that case, you can use tuple types to be more specific about how your array should be interpreted.</p>&#13;
&#13;
<p>Tuple types are a sibling of array types that work on a different semantic. While arrays can be potentially endless in size and each element is of the same type (no matter how broad), tuple types have a fixed size, and each element has a distinct type.</p>&#13;
&#13;
<p>All you need to do to get tuple types is to explicitly annotate:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">person</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Stefan"</code><code class="p">,</code> <code class="mi">40</code><code class="p">];</code>&#13;
&#13;
<code class="kr">const</code> <code class="p">[</code><code class="nx">name</code><code class="p">,</code> <code class="nx">age</code><code class="p">]</code> <code class="o">=</code> <code class="nx">person</code><code class="p">;</code>&#13;
<code class="c1">// name: string</code>&#13;
<code class="c1">// age: number</code></pre>&#13;
&#13;
<p>Fantastic! Tuple types have a fixed length; this means the length is also encoded in the type. So assignments that go out of bounds are not possible; TypeScript will throw an error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">person</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="mi">41</code><code class="p">;</code> <code class="c1">// OK!</code>&#13;
<code class="nx">person</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code> <code class="c1">// Error</code>&#13;
<code class="c1">//^- Type 'false' is not assignable to type 'undefined'.(2322)</code></pre>&#13;
&#13;
<p>TypeScript also allows you to add labels to tuple types. This is just metainformation for editors and compiler feedback, but it allows you to be clearer about what to expect from each element:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">[</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">];</code></pre>&#13;
&#13;
<p>This will help you and your colleagues to understand what to expect, just like with object types.</p>&#13;
&#13;
<p>Tuple types can also be used to annotate function arguments. This function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">hello</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">msg</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>can also be written with tuple types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">hello</code><code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="p">[</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">msg</code><code class="o">:</code> <code class="kt">string</code><code class="p">])</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And you can be very flexible in defining it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">h</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code>&#13;
<code class="c1">// equal to</code>&#13;
<code class="kd">function</code> <code class="nx">h</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="p">...</code><code class="nx">r</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">])</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code>&#13;
<code class="c1">// equal to</code>&#13;
<code class="kd">function</code> <code class="nx">h</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="p">...</code><code class="nx">r</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">])</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code>&#13;
<code class="c1">// equal to</code>&#13;
<code class="kd">function</code> <code class="nx">h</code><code class="p">(...</code><code class="nx">r</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">])</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-primary="rest elements" data-type="indexterm" id="id489"/>These are also known as <em>rest</em> elements, something that we have in JavaScript that allow you to define functions with an almost limitless argument list; when it is the last element, the <em>rest</em> element sucks all excess arguments in. When you need to collect arguments in your code, you can use a tuple before you apply them to your function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">person</code><code class="o">:</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Stefan"</code><code class="p">,</code> <code class="mi">40</code><code class="p">];</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">hello</code><code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="p">[</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">msg</code><code class="o">:</code> <code class="kt">string</code><code class="p">])</code><code class="o">:</code> <code class="p">{</code>&#13;
 <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">hello</code><code class="p">(...</code><code class="nx">person</code><code class="p">);</code></pre>&#13;
&#13;
<p>Tuple types are useful for many scenarios. For more information about tuple types, see Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch07.html#ch07">7</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch10.html#ch10">10</a><a data-startref="ix_0302-asciidoc3" data-type="indexterm" id="id490"/>.<a data-startref="ix_0302-asciidoc2" data-type="indexterm" id="id491"/><a data-startref="ix_0302-asciidoc1" data-type="indexterm" id="id492"/><a data-startref="ix_0302-asciidoc0" data-type="indexterm" id="id493"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="2.5 Understanding Interfaces Versus Type Aliases" data-type="sect1"><div class="sect1" id="ch02_item_interfaces_vs_types">&#13;
<h1>2.5 Understanding Interfaces Versus Type Aliases</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id32">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="basic types" data-secondary="interfaces versus type aliases" data-type="indexterm" id="ix_0402-asciidoc0"/><a data-primary="interfaces, type aliases versus" data-type="indexterm" id="ix_0402-asciidoc1"/><a data-primary="type aliases, interfaces versus" data-type="indexterm" id="ix_0402-asciidoc2"/>TypeScript declares object types in two ways: interfaces and type aliases. Which one should you use?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id494">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use type aliases for types within your project’s boundary, and use interfaces for contracts that are meant to be consumed by others.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id33">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Both approaches to defining object types have been the subject of many blog articles over the years. And all of them became outdated over time. As of this writing there is little difference between type aliases and interfaces. And everything that <em>was</em> different has been gradually aligned.</p>&#13;
&#13;
<p>Syntactically, the difference between interfaces and type aliases is nuanced:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">PersonAsType</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">address</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
  <code class="nx">greet</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">PersonAsInterface</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">address</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
  <code class="nx">greet</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can use interfaces and type aliases for the same things, in the same scenarios:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>In an implements declaration for classes</p>&#13;
</li>&#13;
<li>&#13;
<p>As a type annotation for object literals</p>&#13;
</li>&#13;
<li>&#13;
<p>For recursive type structures</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-primary="declaration merging" data-type="indexterm" id="ix_0402-asciidoc3"/>However, there is one important difference that can cause side effects you usually don’t want to deal with: interfaces allow for declaration merging, but type aliases don’t. Declaration merging allows for adding properties to an interface even after it has been declared:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="typescript" data-type="programlisting"><code class="kr">interface</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Person is now { name: string; age: number; }</code></pre>&#13;
&#13;
<p>TypeScript often uses this technique in <em>lib.d.ts</em> files, making it possible to just add deltas of new JavaScript APIs based on ECMAScript versions. This is a great feature if you want to extend, for example, <code>Window</code>, but it can backfire in other scenarios, for example:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Some data we collect in a web form</code>&#13;
<code class="kr">interface</code> <code class="nx">FormData</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">address</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// A function that sends this data to a backend</code>&#13;
<code class="kd">function</code> <code class="nx">send</code><code class="p">(</code><code class="nx">data</code><code class="o">:</code> <code class="nx">FormData</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">entries</code><code class="p">())</code> <code class="c1">// this compiles!</code>&#13;
  <code class="c1">// but crashes horrendously in runtime</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So, where does the <code>entries()</code> method come from? It’s a DOM API! <code>FormData</code> is one of the interfaces provided by browser APIs, and there are a lot of them. They are globally available, and nothing keeps you from extending those interfaces. And you get no notification if you do.</p>&#13;
&#13;
<p>You can of course argue about proper naming, but the problem persists for all interfaces that you make available globally, maybe from some dependency where you aren’t even aware they add an interface to the global space.</p>&#13;
&#13;
<p>Changing this interface to a type alias immediately makes you aware of this problem:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormData</code> <code class="o">=</code> <code class="p">{</code>&#13;
<code class="c1">//   ^-- Duplicate identifier 'FormData'.(2300)</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">address</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Declaration merging is a fantastic feature if you are creating a library that is consumed by other parts in your project, maybe even other projects written entirely by other teams. It allows you to define an interface that describes your application but allows your users to adapt it to reality. Think of a plug-in system, where loading new modules enhances functionality: declaration merging is a feature that you do not want to miss.<a data-startref="ix_0402-asciidoc3" data-type="indexterm" id="id495"/></p>&#13;
&#13;
<p>Within your module’s boundaries, however, using type aliases prevents you from accidentally reusing or extending already declared types. Use type aliases when you don’t expect others to consume them.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Performance" data-type="sect3"><div class="sect3" id="id34">&#13;
<h3>Performance</h3>&#13;
&#13;
<p>Using type aliases over interfaces has sparked some discussion, as interfaces have been considered much more performant in their evaluation than type aliases, even resulting in a performance recommendation on the official <a href="https://oreil.ly/8Y0hP">TypeScript wiki</a>. This recommendation should be taken with a grain of salt.</p>&#13;
&#13;
<p>On creation, simple type aliases may perform faster than interfaces because interfaces are never closed and might be merged with other declarations. But interfaces may perform faster in other places because they’re known ahead of time to be object types. Ryan Canavaugh from the TypeScript team expects performance differences to be measurable with an extraordinary number of interfaces or type aliases to be declared: around five thousand according to <a href="https://oreil.ly/Y_2oS">this tweet</a>.</p>&#13;
&#13;
<p>If your TypeScript code base doesn’t perform well, it’s not because you declared too many type aliases instead of interfaces, or vice versa.<a data-startref="ix_0402-asciidoc2" data-type="indexterm" id="id496"/><a data-startref="ix_0402-asciidoc1" data-type="indexterm" id="id497"/><a data-startref="ix_0402-asciidoc0" data-type="indexterm" id="id498"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="2.6 Defining Function Overloads" data-type="sect1"><div class="sect1" id="ch02_item_function_overloads">&#13;
<h1>2.6 Defining Function Overloads</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id209">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="APIs" data-secondary="function overloads and" data-type="indexterm" id="ix_0502-asciidoc0"/><a data-primary="basic types" data-secondary="defining function overloads" data-type="indexterm" id="ix_0502-asciidoc1"/><a data-primary="function arguments" data-secondary="defining function overloads" data-type="indexterm" id="ix_0502-asciidoc2"/><a data-primary="function overloads" data-secondary="defining" data-type="indexterm" id="ix_0502-asciidoc3"/>Your function’s API is very flexible and allows for arguments of various types, where context is important. This is hard to type in just a single function signature.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id499">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use function overloads.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id35">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>JavaScript is very flexible when it comes to function arguments. You can pass basically any parameters, of any length. As long as the function body treats the input correctly, you’re good. This allows for very ergonomic APIs, but it’s also very tough to type.</p>&#13;
&#13;
<p>Think of a conceptual task runner. With a <code>task</code> function you define new tasks by name and either pass a callback or pass a list of other tasks to be executed. Or both—a list of tasks that needs to be executed <em>before</em> the callback runs:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">task</code><code class="p">(</code><code class="s2">"default"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"scripts"</code><code class="p">,</code> <code class="s2">"styles"</code><code class="p">]);</code>&#13;
&#13;
<code class="nx">task</code><code class="p">(</code><code class="s2">"scripts"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"lint"</code><code class="p">],</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">task</code><code class="p">(</code><code class="s2">"styles"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>If you’re thinking, “this looks a lot like Gulp six years ago,” you’re right. Its flexible API where you couldn’t do much wrong was also one of the reasons Gulp was so &#13;
<span class="keep-together">popular.</span></p>&#13;
&#13;
<p>Typing functions like this can be a nightmare. Optional arguments, different types at the same position—this is tough to do even if you use union types:<sup><a data-type="noteref" href="ch02.html#id500" id="id500-marker">1</a></sup></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">CallbackFn</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">task</code><code class="p">(</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">param2</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">|</code> <code class="nx">CallbackFn</code><code class="p">,</code> <code class="nx">param3</code><code class="o">?:</code> <code class="nx">CallbackFn</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
<code class="c1">//...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This catches all variations from the preceding example, but it’s also wrong, as it allows for combinations that don’t make any sense:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">task</code><code class="p">(</code>&#13;
  <code class="s2">"what"</code><code class="p">,</code>&#13;
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Two callbacks?"</code><code class="p">);</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"That's not supported, but the types say yes!"</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Thankfully, TypeScript has a way to solve problems like this: function overloads. Its name hints at similar concepts from other programming languages: the same defintion but with different behavior. The biggest difference in TypeScript, as opposed to other programming languages, is that function overloads work only on a type system level and have no effect on the actual implementation.</p>&#13;
&#13;
<p>The idea is that you define every possible scenario as its own function signature. The last function signature is the actual implementation:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="typescript" data-type="programlisting"><code class="c1">// Types for the type system</code>&#13;
<code class="kd">function</code> <code class="nx">task</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">dependencies</code><code class="o">:</code> <code class="kt">string</code><code class="p">[])</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">task</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="kd">function</code> <code class="nx">task</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">dependencies</code><code class="o">:</code> <code class="kt">string</code><code class="p">[],</code> <code class="nx">callback</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="c1">// The actual implementation</code>&#13;
<code class="kd">function</code> <code class="nx">task</code><code class="p">(</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">param2</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">|</code> <code class="nx">CallbackFn</code><code class="p">,</code> <code class="nx">param3</code><code class="o">?:</code> <code class="nx">CallbackFn</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
<code class="c1">//...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A couple of things are important to note here.</p>&#13;
&#13;
<p>First, TypeScript only picks up the declarations before the actual implementation as possible types. If the actual implementation signature is also relevant, duplicate it.</p>&#13;
&#13;
<p>Also, the actual implementation function signature can’t be anything. TypeScript checks if the overloads can be implemented with the implementation signature.</p>&#13;
&#13;
<p>If you have different return types, it is your responsibility to make sure that inputs and outputs match:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code>&#13;
<code class="kd">function</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code>&#13;
<code class="kd">function</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="k">if</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="s2">"this also works"</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="mi">1337</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">typeSaysNumberButItsAString</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">typeSaysStringButItsANumber</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(</code><code class="s2">"Hello world"</code><code class="p">);</code></pre>&#13;
&#13;
<p>The implementation signature usually works with a very broad type, which means you have to do a lot of checks that you would need to do in JavaScript anyway. This is good as it urges you to be extra careful.</p>&#13;
&#13;
<p>If you need overloaded functions as their own type, to use them in annotations and assign multiple implementations, you can always create a type alias:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">TaskFn</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">dependencies</code><code class="o">:</code> <code class="kt">string</code><code class="p">[])</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">dependencies</code><code class="o">:</code> <code class="kt">string</code><code class="p">[],</code> <code class="nx">callback</code><code class="o">:</code> <code class="nx">CallbackFn</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, you only need the type system overloads, not the actual &#13;
<span class="keep-together">implementation definition</span>.<a data-startref="ix_0502-asciidoc3" data-type="indexterm" id="id501"/><a data-startref="ix_0502-asciidoc2" data-type="indexterm" id="id502"/><a data-startref="ix_0502-asciidoc1" data-type="indexterm" id="id503"/><a data-startref="ix_0502-asciidoc0" data-type="indexterm" id="id504"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="2.7 Defining this Parameter Types" data-type="sect1"><div class="sect1" id="ch02_item_this_types">&#13;
<h1>2.7 Defining this Parameter Types</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id36">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="basic types" data-secondary="this parameter types" data-type="indexterm" id="ix_0602-asciidoc0"/><a data-primary="this object pointer" data-secondary="this parameter types" data-type="indexterm" id="ix_0602-asciidoc1"/><a data-primary="this parameter types" data-type="indexterm" id="ix_0602-asciidoc2"/>You are writing callback functions that make assumptions about <code>this</code>, but you don’t know how to define <code>this</code> when writing the function standalone.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id505">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Define a <code>this</code> parameter type at the beginning of a function signature.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id37">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>One source of confusion for aspiring JavaScript developers is the ever-changing nature of the <code>this</code> object pointer:</p>&#13;
<blockquote>&#13;
<p>Sometimes when writing JavaScript, I want to shout, “This is ridiculous!” But then I never know what <em>this</em> refers to.</p>&#13;
<p data-type="attribution">Unknown JavaScript developer</p>&#13;
</blockquote>&#13;
&#13;
<p>The preceding statement is true especially if your background is a class-based object-oriented programming language, where <code>this</code> always refers to an instance of a class. <code>this</code> in JavaScript is entirely different but not necessarily harder to understand. What’s more, TypeScript can greatly help get more closure about <code>this</code> in usage.</p>&#13;
&#13;
<p><code>this</code> lives within the scope of a function, and that points to an object or value bound to that function. In regular objects, <code>this</code> is pretty straightforward:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">author</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="c1">// function shorthand</code>&#13;
  <code class="nx">hi</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">author</code><code class="p">.</code><code class="nx">hi</code><code class="p">();</code> <code class="c1">// prints 'Stefan'</code></pre>&#13;
&#13;
<p>But functions are values in JavaScript, and they can be bound to a different context, effectively changing the value of <code>this</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">author</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">hi</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">pet</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Finni"</code><code class="p">,</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"Cat"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">hi</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">pet</code><code class="p">);</code> <code class="c1">// prints "Finni"</code>&#13;
<code class="nx">hi</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">author</code><code class="p">);</code> <code class="c1">// prints "Stefan"</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">boundHi</code> <code class="o">=</code> <code class="nx">hi</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="nx">author</code><code class="p">);</code>&#13;
&#13;
<code class="nx">boundHi</code><code class="p">();</code> <code class="c1">// prints "Stefan"</code></pre>&#13;
&#13;
<p>It doesn’t help that the semantics of <code>this</code> change again if you use arrow functions instead of regular functions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">hi</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">hi_timeout</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">setTimeout</code><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
    <code class="p">},</code> <code class="mi">0</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">hi_timeout_arrow</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
    <code class="p">},</code> <code class="mi">0</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">)</code>&#13;
<code class="nx">person</code><code class="p">.</code><code class="nx">hi</code><code class="p">();</code> <code class="c1">// prints "Stefan"</code>&#13;
<code class="nx">person</code><code class="p">.</code><code class="nx">hi_timeout</code><code class="p">();</code> <code class="c1">// prints "undefined"</code>&#13;
<code class="nx">person</code><code class="p">.</code><code class="nx">hi_timeout_arrow</code><code class="p">();</code> <code class="c1">// prints "Stefan"</code></pre>&#13;
&#13;
<p>With TypeScript, we can get more information on what <code>this</code> is and, more importantly, what it’s supposed to be through <code>this</code> parameter types.</p>&#13;
&#13;
<p>Take a look at the following example. We access a button element via DOM APIs and bind an event listener to it. Within the callback function, <code>this</code> is of type <code>HT⁠ML⁠Bu⁠tt⁠on​El⁠em⁠ent⁠</code>, which means you can access properties like <code>classList</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"button"</code><code class="p">);</code>&#13;
<code class="nx">button</code><code class="o">?</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">this</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">toggle</code><code class="p">(</code><code class="s2">"clicked"</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p><a data-primary="addEventListener function" data-type="indexterm" id="id506"/>The information on <code>this</code> is provided by the <code>addEventListener</code> function. If you extract your function in a refactoring step, you retain the functionality, but TypeScript will error, as it loses context for <code>this</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"button"</code><code class="p">);</code>&#13;
<code class="nx">button</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="nx">handleToggle</code><code class="p">);</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">handleToggle</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">this</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">toggle</code><code class="p">(</code><code class="s2">"clicked"</code><code class="p">);</code>&#13;
<code class="c1">// ^- 'this' implicitly has type 'any'</code>&#13;
<code class="c1">//     because it does not have a type annotation</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The trick is to tell TypeScript that <code>this</code> is supposed to be a specific type. You can do this by adding a parameter at the very first position in your function signature named <code>this</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"button"</code><code class="p">);</code>&#13;
<code class="nx">button</code><code class="o">?</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="nx">handleToggle</code><code class="p">);</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">handleToggle</code><code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">HTMLButtonElement</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">this</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">toggle</code><code class="p">(</code><code class="s2">"clicked"</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This argument gets removed once compiled. TypeScript now has all the information it needs to make sure <code>this</code> needs to be of type <code>HTMLButtonElement</code>, which also means that you get errors once you use <code>handleToggle</code> in a different context:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">handleToggle</code><code class="p">();</code>&#13;
<code class="c1">// ^- The 'this' context of type 'void' is not</code>&#13;
<code class="c1">//    assignable to method's 'this' of type 'HTMLButtonElement'.</code></pre>&#13;
&#13;
<p>You can make <code>handleToggle</code> even more useful if you define <code>this</code> to be <code>HTMLElement</code>, a supertype of <code>HTMLButtonElement</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"button"</code><code class="p">);</code>&#13;
<code class="nx">button</code><code class="o">?</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="nx">handleToggle</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">input</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"input"</code><code class="p">);</code>&#13;
<code class="nx">input</code><code class="o">?</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="nx">handleToggle</code><code class="p">);</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">handleToggle</code><code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">this</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">toggle</code><code class="p">(</code><code class="s2">"clicked"</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When working with <code>this</code> parameter types, you might want to use two helper types that can either extract or remove <code>this</code> parameters from your function type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">handleToggle</code><code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">this</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">toggle</code><code class="p">(</code><code class="s2">"clicked"</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ToggleFn</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">handleToggle</code><code class="p">;</code>&#13;
<code class="c1">// (this: HTMLElement) =&gt; void</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">WithoutThis</code> <code class="o">=</code> <code class="nx">OmitThisParameter</code><code class="o">&lt;</code><code class="nx">ToggleFn</code><code class="o">&gt;</code>&#13;
<code class="c1">// () = &gt; void</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ToggleFnThis</code> <code class="o">=</code> <code class="nx">ThisParameterType</code><code class="o">&lt;</code><code class="nx">ToggleFn</code><code class="o">&gt;</code>&#13;
<code class="c1">// HTMLElement</code></pre>&#13;
&#13;
<p>There are more helper types for <code>this</code> in classes and objects. See more in Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04_this_type">4.8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11.html#ch11_this_return">11.8</a>.<a data-startref="ix_0602-asciidoc2" data-type="indexterm" id="id507"/><a data-startref="ix_0602-asciidoc1" data-type="indexterm" id="id508"/><a data-startref="ix_0602-asciidoc0" data-type="indexterm" id="id509"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="2.8 Working with Symbols" data-type="sect1"><div class="sect1" id="ch02_item_symbols">&#13;
<h1>2.8 Working with Symbols</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id38">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="basic types" data-secondary="working with symbols" data-type="indexterm" id="ix_0702-asciidoc0"/><a data-primary="symbol type" data-type="indexterm" id="ix_0702-asciidoc1"/>You see the type <code>symbol</code> popping up in some error messages, but you don’t know what symbols mean or how you can use them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id510">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create symbols for object properties you want to be unique and not iterable. They’re great for storing and accessing sensitive information.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id39">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><code>symbol</code> is a primitive data type in JavaScript and TypeScript, which, among other things, can be used for object properties. Compared to <code>number</code> and <code>string</code>, symbols have some unique features.</p>&#13;
&#13;
<p><a data-primary="Symbol() factory function" data-type="indexterm" id="id511"/>Symbols can be created using the <code>Symbol()</code> factory function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">TITLE</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'title'</code><code class="p">)</code></pre>&#13;
&#13;
<p><code>Symbol</code> has no constructor function. The parameter is an optional description. By calling the factory function, <code>TITLE</code> is assigned the unique value of this freshly created symbol. This symbol is now unique and distinguishable from all other symbols, and it doesn’t clash with any other symbols that have the same description:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">ACADEMIC_TITLE</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'title'</code><code class="p">)</code>&#13;
<code class="kr">const</code> <code class="nx">ARTICLE_TITLE</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'title'</code><code class="p">)</code>&#13;
&#13;
<code class="k">if</code><code class="p">(</code><code class="nx">ACADEMIC_TITLE</code> <code class="o">===</code> <code class="nx">ARTICLE_TITLE</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// This is never true</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The description helps you to get info on the symbol during development time:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ACADEMIC_TITLE</code><code class="p">.</code><code class="nx">description</code><code class="p">)</code> <code class="c1">// title</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ACADEMIC_TITLE</code><code class="p">.</code><code class="nx">toString</code><code class="p">())</code> <code class="c1">// Symbol(title)</code></pre>&#13;
&#13;
<p>Symbols are great if you want to have comparable values that are exclusive and unique. For runtime switches or mode comparisons:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// A really bad logging framework</code>&#13;
<code class="kr">const</code> <code class="nx">LEVEL_INFO</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'INFO'</code><code class="p">)</code>&#13;
<code class="kr">const</code> <code class="nx">LEVEL_DEBUG</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'DEBUG'</code><code class="p">)</code>&#13;
<code class="kr">const</code> <code class="nx">LEVEL_WARN</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'WARN'</code><code class="p">)</code>&#13;
<code class="kr">const</code> <code class="nx">LEVEL_ERROR</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'ERROR'</code><code class="p">)</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">,</code> <code class="nx">level</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code><code class="p">(</code><code class="nx">level</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="nx">LEVEL_WARN</code><code class="o">:</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">warn</code><code class="p">(</code><code class="nx">msg</code><code class="p">);</code> <code class="k">break</code>&#13;
    <code class="k">case</code> <code class="nx">LEVEL_ERROR</code><code class="o">:</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">msg</code><code class="p">);</code> <code class="k">break</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="nx">LEVEL_DEBUG</code><code class="o">:</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">);</code>&#13;
      <code class="kr">debugger</code><code class="p">;</code> <code class="k">break</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="nx">LEVEL_INFO</code><code class="o">:</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Symbols also work as property keys but are not iterable, which is great for &#13;
<span class="keep-together">serialization:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">print</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'print'</code><code class="p">)</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Stefan'</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
  <code class="p">[</code><code class="nx">print</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> is </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">age</code><code class="si">}</code><code class="sb"> years old`</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">user</code><code class="p">)</code> <code class="c1">// { name: 'Stefan', age: 40 }</code>&#13;
<code class="nx">user</code><code class="p">[</code><code class="nx">print</code><code class="p">]()</code> <code class="c1">// Stefan is 40 years old</code></pre>&#13;
&#13;
<p>A global symbols registry allows you to access tokens across your whole application:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s1">'print'</code><code class="p">)</code> <code class="c1">// creates a global symbol</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Stefan'</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">37</code><code class="p">,</code>&#13;
  <code class="c1">// uses the global symbol</code>&#13;
  <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s1">'print'</code><code class="p">)]</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> is </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">age</code><code class="si">}</code><code class="sb"> years old`</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The first call to <code>Symbol.for</code> creates a symbol, and the second call uses the same symbol. If you store the symbol value in a variable and want to know the key, you can use <code>Symbol.keyFor()</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">usedSymbolKeys</code> <code class="o">=</code> <code class="p">[]</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">extendObject</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">symbol</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">//Oh, what symbol is this?</code>&#13;
  <code class="kr">const</code> <code class="nx">key</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">.</code><code class="nx">keyFor</code><code class="p">(</code><code class="nx">symbol</code><code class="p">)</code>&#13;
  <code class="c1">//Alright, let's better store this</code>&#13;
  <code class="k">if</code><code class="p">(</code><code class="o">!</code><code class="nx">usedSymbolKeys</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">key</code><code class="p">))</code> <code class="p">{</code>&#13;
    <code class="nx">usedSymbolKeys</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">obj</code><code class="p">[</code><code class="nx">symbol</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// now it's time to retreive them all</code>&#13;
<code class="kd">function</code> <code class="nx">printAllValues</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">usedSymbolKeys</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">key</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="nx">key</code><code class="p">)])</code>&#13;
  <code class="p">})</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Nifty!</p>&#13;
&#13;
<p>TypeScript has full support for symbols, and they are prime citizens in the type system. <code>symbol</code> itself is a data type annotation for all possible symbols. See the <code>ex⁠ten⁠d​Ob⁠je⁠ct</code> function in the preceding code block. To allow for all symbols to extend our object, we can use the <code>symbol</code> type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">sym</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'foo'</code><code class="p">)</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">extendObject</code><code class="p">(</code><code class="nx">obj</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="nx">sym</code><code class="o">:</code> <code class="nx">symbol</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">obj</code><code class="p">[</code><code class="nx">sym</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">extendObject</code><code class="p">({},</code> <code class="nx">sym</code><code class="p">,</code> <code class="mi">42</code><code class="p">)</code> <code class="c1">// Works with all symbols</code></pre>&#13;
&#13;
<p>There’s also the subtype <code>unique symbol</code>. A <code>unique symbol</code> is closely tied to the declaration, allowed only in <code>const</code> declarations, and referencing this exact symbol and nothing else.</p>&#13;
&#13;
<p>You can think of a nominal type in TypeScript for a very nominal value in JavaScript.</p>&#13;
&#13;
<p>To get to the type of <code>unique symbol</code>, you need to use the <code>typeof</code> operator:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">PROD</code><code class="o">:</code> <code class="nx">unique</code> <code class="nx">symbol</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'Production mode'</code><code class="p">)</code>&#13;
<code class="kr">const</code> <code class="nx">DEV</code><code class="o">:</code> <code class="nx">unique</code> <code class="nx">symbol</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'Development mode'</code><code class="p">)</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">showWarning</code><code class="p">(</code><code class="nx">msg</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">mode</code><code class="o">:</code> <code class="k">typeof</code> <code class="nx">DEV</code> <code class="o">|</code> <code class="k">typeof</code> <code class="nx">PROD</code><code class="p">)</code> <code class="p">{</code>&#13;
 <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>At the time of writing, the only possible nominal type is TypeScript’s structural &#13;
<span class="keep-together">type system.</span></p>&#13;
&#13;
<p>Symbols stand at the intersection between nominal and opaque types in TypeScript and JavaScript. They are the closest things we get to nominal type-checks at runtime.<a data-startref="ix_0702-asciidoc1" data-type="indexterm" id="id512"/><a data-startref="ix_0702-asciidoc0" data-type="indexterm" id="id513"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="2.9 Understanding Value and Type Namespaces" data-type="sect1"><div class="sect1" id="ch02_item_namespaces">&#13;
<h1>2.9 Understanding Value and Type Namespaces</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id40">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="basic types" data-secondary="value and type namespaces" data-type="indexterm" id="ix_0802-asciidoc0"/><a data-primary="namespaces" data-secondary="value and type" data-type="indexterm" id="ix_0802-asciidoc1"/><a data-primary="type namespaces" data-type="indexterm" id="ix_0802-asciidoc2"/><a data-primary="value namespaces" data-type="indexterm" id="ix_0802-asciidoc3"/>It’s confusing that you can use certain names as type annotations and not others.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id514">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Learn about type and value namespaces, and which names contribute to what.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id41">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>TypeScript is a superset of JavaScript, which means it adds more things to an already existing and defined language. Over time you learn to spot which parts are JavaScript and which parts are TypeScript.</p>&#13;
&#13;
<p>It really helps to see TypeScript as this additional layer of types upon regular JavaScript, a thin layer of metainformation that will be peeled off before your JavaScript code runs in one of the available runtimes. Some people even speak about TypeScript code “erasing to JavaScript” once compiled.</p>&#13;
&#13;
<p>TypeScript being this layer on top of JavaScript also means that different syntax contributes to different layers. While a <code>function</code> or <code>const</code> creates a name in the JavaScript part, a <code>type</code> declaration or an <code>interface</code> contributes a name in the TypeScript layer:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Collection is in TypeScript land! --&gt; type</code>&#13;
<code class="kr">type</code> <code class="nx">Collection</code> <code class="o">=</code> <code class="nx">Person</code><code class="p">[]</code>&#13;
&#13;
<code class="c1">// printCollection is in JavaScript land! --&gt; value</code>&#13;
<code class="kd">function</code> <code class="nx">printCollection</code><code class="p">(</code><code class="nx">coll</code><code class="o">:</code> <code class="nx">Collection</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(...</code><code class="nx">coll</code><code class="p">.</code><code class="nx">entries</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We also say that declarations contribute a name to either the <em>type namespace</em> or the <em>value namespace</em>. Since the type layer is on top of the value layer, it’s possible to consume values in the type layer, but not vice versa. We also have explicit keywords for that:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// a value</code>&#13;
<code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// a type</code>&#13;
<code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">person</code><code class="p">;</code></pre>&#13;
&#13;
<p><code>typeof</code> creates a name available in the type layer from the value layer below.</p>&#13;
&#13;
<p>It gets irritating when there are declaration types that create both types and values. Classes, for instance, can be used in the TypeScript layer as a type as well as in JavaScript as a value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// declaration</code>&#13;
<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">n</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">n</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// used as a value</code>&#13;
<code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// used as a type</code>&#13;
<code class="kr">type</code> <code class="nx">Collection</code> <code class="o">=</code> <code class="nx">Person</code><code class="p">[];</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printPersons</code><code class="p">(</code><code class="nx">coll</code><code class="o">:</code> <code class="nx">Collection</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And naming conventions can trick you. Usually, we define classes, types, interfaces, enums, and so on with a capital first letter. And even if they may contribute values, they for sure contribute types. Well, until you write uppercase functions for your React app, as the convention dictates.</p>&#13;
&#13;
<p>If you’re used to using names as types and values, you’re going to scratch your head if you suddenly get a good old “TS2749: <em>YourType</em> refers to a value, but is being used as a type” error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">PersonProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Person</code><code class="p">({</code> <code class="nx">name</code> <code class="p">}</code><code class="o">: </code><code class="kr">Person</code><code class="nx">Props</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">PrintComponentProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">collection</code><code class="o">: </code><code class="kr">Person</code><code class="p">[];</code>&#13;
  <code class="c1">//          ^- 'Person' refers to a value,</code>&#13;
  <code class="c1">//              but is being used as a type</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is where TypeScript can get really confusing. What is a type, what is a value, why do we need to separate them, and why doesn’t this work like in other programming languages? Suddenly, you are confronted with <code>typeof</code> calls or even the <code>InstanceType</code> helper type, because you realize that classes actually contribute two types (see <a data-type="xref" href="ch11.html#ch11">Chapter 11</a>).</p>&#13;
&#13;
<p>Classes contribute a name to the type namespace, and since TypeScript is a structural type system, they allow values that have the same shape as an instance of a certain class. So this is allowed:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">n</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">n</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">));</code> <code class="c1">// ok</code>&#13;
<code class="nx">printPerson</code><code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code> <code class="p">});</code> <code class="c1">// also ok</code></pre>&#13;
&#13;
<p>However, <code>instanceof</code> checks, which are working entirely in the value namespace and just have implications in the type namespace, would fail, as objects with the same shape may have the same properties but are not an actual <em>instance</em> of a class:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">checkPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">person</code> <code class="k">instanceof</code> <code class="nx">Person</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">checkPerson</code><code class="p">(</code><code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">));</code> <code class="c1">// true</code>&#13;
<code class="nx">checkPerson</code><code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code> <code class="p">});</code> <code class="c1">// false</code></pre>&#13;
&#13;
<p>So it’s useful to understand what contributes types and what contributes value. <a data-type="xref" href="#table2_1">Table 2-1</a>, adapted from the TypeScript docs, sums it up nicely.</p>&#13;
<table id="table2_1">&#13;
<caption><span class="label">Table 2-1. </span>Type and value namespaces</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Declaration type</th>&#13;
<th>Type</th>&#13;
<th>Value</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Class</p></td>&#13;
<td><p>X</p></td>&#13;
<td><p>X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Enum</p></td>&#13;
<td><p>X</p></td>&#13;
<td><p>X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Interface</p></td>&#13;
<td><p>X</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Type Alias</p></td>&#13;
<td><p>X</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Function</p></td>&#13;
<td/>&#13;
<td><p>X</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Variable</p></td>&#13;
<td/>&#13;
<td><p>X</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>If you stick with functions, interfaces (or type aliases, see <a data-type="xref" href="#ch02_item_interfaces_vs_types">Recipe 2.5</a>), and variables at the beginning, you will get a feel for what you can use where. If you work with classes, think about the implications a bit longer.<a data-startref="ix_0802-asciidoc3" data-type="indexterm" id="id515"/><a data-startref="ix_0802-asciidoc2" data-type="indexterm" id="id516"/><a data-startref="ix_0802-asciidoc1" data-type="indexterm" id="id517"/><a data-startref="ix_0802-asciidoc0" data-type="indexterm" id="id518"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id500"><sup><a href="ch02.html#id500-marker">1</a></sup> Union types are a way to combine two different types into one (see more in <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>).</p></div></div></section></body></html>