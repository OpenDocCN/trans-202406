<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Operators Teach Kubernetes New Tricks" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_introduction">&#13;
<h1><span class="label">Chapter 1. </span>Operators Teach Kubernetes New Tricks</h1>&#13;
&#13;
&#13;
<p>An Operator is a way to package, run, and maintain a Kubernetes application. A Kubernetes application is not only deployed on Kubernetes, it is designed to use and to operate in concert with Kubernetes facilities and tools.</p>&#13;
&#13;
<p>An Operator builds on Kubernetes abstractions to automate the entire lifecycle of the software it manages. Because they extend Kubernetes, Operators provide application-specific automation in terms familiar to a large and growing community. For application programmers, Operators make it easier to deploy and run the foundation services on which their apps depend. For infrastructure engineers and vendors, Operators provide a consistent way to distribute software on Kubernetes clusters and reduce support burdens by identifying and correcting application problems before the pager beeps.</p>&#13;
&#13;
<p>Before we begin to describe how Operators do these jobs, let’s define a few Kubernetes terms to provide context and a shared language to describe Operator concepts and components.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Kubernetes Works" data-type="sect1"><div class="sect1" id="idm45261343044408">&#13;
<h1>How Kubernetes Works</h1>&#13;
&#13;
<p>Kubernetes automates the lifecycle of a stateless application, such as a static web server.<a data-primary="Kubernetes" data-secondary="how it works" data-type="indexterm" id="ix_Kubehow"/> Without state, any instances of an application are interchangeable. This simple web server retrieves files and sends them on to a visitor’s browser. Because the server is not tracking state or storing input or data of any kind, when one server instance fails, Kubernetes can replace it with another.<a data-primary="replicas" data-type="indexterm" id="idm45261343004744"/> Kubernetes refers to these instances, each a copy of an application running on the cluster, as <em>replicas</em>.</p>&#13;
&#13;
<p>A Kubernetes cluster is a collection of computers, called <em>nodes</em>. All cluster work runs on one, some, or all of a cluster’s nodes. The basic unit of work, and of replication, is the <em>pod</em>. A pod is a group of one or more Linux containers with common resources like networking, storage, and access to shared memory.<a data-primary="pods" data-type="indexterm" id="idm45261343001800"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <a href="https://oreil.ly/ziz5q">Kubernetes pod documentation</a> is a good starting point for more information about the pod abstraction.</p>&#13;
</div>&#13;
&#13;
<p>At a high level, a Kubernetes cluster can be divided into two planes.<a data-primary="control plane" data-type="indexterm" id="idm45261342998888"/> The <em>control plane</em> is, in simple terms, Kubernetes itself. A collection of pods comprises the control plane and implements the Kubernetes application programming interface (API) and cluster orchestration logic.</p>&#13;
&#13;
<p>The <em>application plane</em>, or <em>data plane</em>, is everything else.<a data-primary="application plane" data-seealso="data plane" data-type="indexterm" id="idm45261342996040"/><a data-primary="data plane" data-type="indexterm" id="idm45261342995032"/> It is the group of nodes where application pods run. One or more nodes are usually dedicated to running applications, while one or more nodes are often sequestered to run only control plane pods. As with application pods, multiple replicas of control plane components can run on multiple controller nodes to provide redundancy.</p>&#13;
&#13;
<p>The <em>controllers</em> of the control plane implement control loops that repeatedly compare the desired state of the cluster to its actual state. <a data-primary="controllers" data-type="indexterm" id="idm45261342992904"/>When the two diverge, a controller takes action to make them match. Operators extend this behavior. The schematic in <a data-type="xref" href="#fig1-1">Figure 1-1</a> shows the major control plane components, with worker nodes running application workloads.</p>&#13;
&#13;
<p>While a strict division between the control and application planes is a convenient mental model and a common way to deploy a Kubernetes cluster to segregate workloads, the control plane components are a collection of pods running on nodes, like any other application. In small clusters, control plane components are often sharing the same node or two with application workloads.</p>&#13;
&#13;
<p>The conceptual model of a cordoned control plane isn’t quite so tidy, either. The kube let agent running on every node is part of the control plane, for example. Likewise, an Operator is a type of controller, usually thought of as a control plane component. Operators can blur this distinct border between planes, however. Treating the control and application planes as isolated domains is a helpful simplifying abstraction, not an absolute truth.</p>&#13;
&#13;
<figure><div class="figure" id="fig1-1">&#13;
<img alt="Figure 1-1: Kubernetes Control Plane and Worker Nodes" src="assets/kuop_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>Kubernetes control plane and worker nodes</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example: Stateless Web Server" data-type="sect1"><div class="sect1" id="idm45261343043784">&#13;
<h1>Example: Stateless Web Server</h1>&#13;
&#13;
<p>Since you haven’t set up a cluster yet, the examples in this chapter are more like terminal<a data-primary="web servers, stateless" data-type="indexterm" id="idm45261342985816"/> <a data-primary="stateless web server, with Kubernetes" data-type="indexterm" id="idm45261342984984"/>excerpt “screenshots” that show what basic interactions between Kubernetes and an application look like. You are not expected to execute these commands as you are those throughout the rest of the book. In this first example, Kubernetes manages a relatively simple application and no Operators are involved.</p>&#13;
&#13;
<p>Consider a cluster running a single replica of a stateless, static web server:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get pods&gt;</strong>&#13;
NAME                        READY     STATUS    RESTARTS   AGE&#13;
&#13;
staticweb-69ccd6d6c-9mr8l   1/1       Running   <code>0</code>          23s&#13;
</pre>&#13;
&#13;
<p>After declaring there should be three replicas, the cluster’s actual state differs from the desired state, and Kubernetes starts two new instances of the web server to reconcile the two, scaling the web server deployment:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl scale deployment staticweb --replicas=3</strong>&#13;
$ <strong>kubectl get pods</strong>&#13;
NAME                        READY   STATUS    RESTARTS   AGE&#13;
staticweb-69ccd6d6c-4tdhk   1/1     Running   <code>0</code>          6s&#13;
staticweb-69ccd6d6c-9mr8l   1/1     Running   <code>0</code>          100s&#13;
staticweb-69ccd6d6c-m9qc7   1/1     Running   <code>0</code>          6s&#13;
</pre>&#13;
&#13;
<p>Deleting one of the web server pods triggers work in the control plane to restore the desired state of three replicas. Kubernetes starts a new pod to replace the deleted one. In this excerpt, the replacement pod shows a <code>STATUS</code> of <code>ContainerCreating</code>:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl delete pod staticweb-69ccd6d6c-9mr8l</strong>&#13;
$ <strong>kubectl get pods</strong>&#13;
NAME                        READY   STATUS                RESTARTS   AGE&#13;
staticweb-69ccd6d6c-4tdhk   1/1     Running               <code>0</code>          2m8s&#13;
staticweb-69ccd6d6c-bk27p   0/1     ContainerCreating     <code>0</code>          14s&#13;
staticweb-69ccd6d6c-m9qc7   1/1     Running               <code>0</code>          2m8s&#13;
</pre>&#13;
&#13;
<p>This static site’s web server is interchangeable with any other replica, or with a new pod that replaces one of the replicas. It doesn’t store data or maintain state in any way. Kubernetes doesn’t need to make any special arrangements to replace a failed pod, or to scale the application by adding or removing replicas of the server.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stateful Is Hard" data-type="sect1"><div class="sect1" id="idm45261342852120">&#13;
<h1>Stateful Is Hard</h1>&#13;
&#13;
<p>Most applications have state. They also have particulars of startup, component interdependence, and configuration. They often have their own notion of what “cluster” means. They need to reliably store critical and sometimes voluminous data. Those are just three of the dimensions in which real-world applications must maintain state. It would be ideal to manage these applications with uniform mechanisms while automating their complex storage, networking, and cluster connection requirements.</p>&#13;
&#13;
<p>Kubernetes cannot know all about every stateful, complex, clustered application while also remaining general, adaptable, and simple. It aims instead to provide a set of flexible abstractions, covering the basic application concepts of scheduling, replication, and failover automation, while providing a clean extension mechanism for more advanced or application-specific operations. Kubernetes, on its own, does not and should not know the configuration values for, say, a PostgreSQL database cluster, with its arranged memberships and stateful, persistent storage.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operators Are Software SREs" data-type="sect1"><div class="sect1" id="idm45261342848936">&#13;
<h1>Operators Are Software SREs</h1>&#13;
&#13;
<p>Site Reliability Engineering (SRE) is a set of patterns and principles for running large systems.<a data-primary="Operators" data-secondary="as software SREs" data-type="indexterm" id="idm45261342847528"/><a data-primary="site reliability engineers (SREs), Operators as" data-type="indexterm" id="idm45261342846552"/> Originating at Google, SRE has had a pronounced influence on industry practice. Practitioners must interpret and apply SRE philosophy to particular circumstances, but a key tenet is automating systems administration by writing software to run your software. Teams freed from rote maintenance work have more time to create new features, fix bugs, and generally improve their products.</p>&#13;
&#13;
<p>An Operator is like an automated Site Reliability Engineer for its application. It encodes in software the skills of an expert administrator. An Operator can manage a cluster of database servers, for example. It knows the details of configuring and managing its application, and it can install a database cluster of a declared software version and number of members. An Operator continues to monitor its application as it runs, and can back up data, recover from failures, and upgrade the application over time, automatically. Cluster users employ <code>kubectl</code> and other standard tools to work with Operators and the applications they manage, because Operators extend Kubernetes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Operators Work" data-type="sect1"><div class="sect1" id="idm45261342843416">&#13;
<h1>How Operators Work</h1>&#13;
&#13;
<p>Operators work by extending the Kubernetes control plane and API. In its simplest form, an Operator adds an endpoint to the Kubernetes API, called<a data-primary="custom resources (CRs)" data-type="indexterm" id="idm45261342841928"/><a data-primary="CRs" data-see="custom resources" data-type="indexterm" id="idm45261342841224"/> a <em>custom resource</em> (CR), along with a control plane component that monitors and maintains resources of the new type.<a data-primary="controllers" data-secondary="Operators as custom controllers watching a custom resource" data-type="indexterm" id="idm45261342839624"/> This Operator can then take action based on the resource’s state. This is illustrated in <a data-type="xref" href="#fig1-2">Figure 1-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig1-2">&#13;
<img alt="Figure 1-2: Operators are Custom Controllers watching a Custom Resource" src="assets/kuop_0102.png"/>&#13;
<h6><span class="label">Figure 1-2. </span>Operators are custom controllers watching a custom resource</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes CRs" data-type="sect2"><div class="sect2" id="idm45261342835416">&#13;
<h2>Kubernetes CRs</h2>&#13;
&#13;
<p>CRs are the API extension mechanism in Kubernetes.<a data-primary="custom resource definitions (CRDs)" data-type="indexterm" id="idm45261342834008"/><a data-primary="Kubernetes" data-secondary="custom resources" data-type="indexterm" id="idm45261342833336"/><a data-primary="CRD" data-see="custom resource definitions" data-type="indexterm" id="idm45261342832392"/> A <em>custom resource definition</em> (CRD) defines a CR; it’s analogous to a schema for the CR data. Unlike members of the official API, a given CRD doesn’t exist on every Kubernetes cluster. CRDs extend the API of the particular cluster where they are defined. CRs provide endpoints for reading and writing structured data. A cluster user can interact with CRs with <code>kubectl</code> or another Kubernetes client, just like any other API resource.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Operators Are Made" data-type="sect1"><div class="sect1" id="idm45261342829672">&#13;
<h1>How Operators Are Made</h1>&#13;
&#13;
<p>Kubernetes compares a set of resources to reality; that is, the running state of the cluster. It takes actions to make reality match the desired state described by those resources. Operators extend that pattern to specific applications on specific clusters. An Operator is a custom Kubernetes controller watching a CR type and taking application-specific actions to make reality match the <code>spec</code> in that resource.</p>&#13;
&#13;
<p>Making an Operator means creating a CRD and providing a program that runs in a loop watching CRs of that kind. What the Operator does in response to changes in the CR is specific to the application the Operator manages. The actions an Operator performs can include almost anything: scaling a complex app, application version upgrades, or even managing kernel modules for nodes in a computational cluster with specialized hardware.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example: The etcd Operator" data-type="sect1"><div class="sect1" id="idm45261342826296">&#13;
<h1>Example: The etcd Operator</h1>&#13;
&#13;
<p>etcd is a distributed key-value store. <a data-primary="etcd key-value store" data-secondary="example, etcd Operator" data-type="indexterm" id="idm45261340261800"/><a data-primary="Operators" data-secondary="etcd Operator example" data-type="indexterm" id="idm45261340260824"/>In other words, it’s a kind of lightweight database cluster. An etcd cluster usually requires a knowledgeable administrator to manage it. An etcd administrator must know how to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Join a new node to an etcd cluster, including configuring its endpoints, making connections to persistent storage, and making existing members aware of it.</p>&#13;
</li>&#13;
<li>&#13;
<p>Back up the etcd cluster data and configuration.</p>&#13;
</li>&#13;
<li>&#13;
<p>Upgrade the etcd cluster to new etcd versions.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The etcd Operator knows how to perform those tasks. An Operator knows about its application’s internal state, and takes regular action to align that state with the desired state expressed in the specification of one or more custom resources.</p>&#13;
&#13;
<p>As in the previous example, the shell excerpts that follow are illustrative, and you won’t be able to execute them without prior setup. You’ll do that setup and run an Operator in <a data-type="xref" href="ch02.html#running_operators">Chapter 2</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Case of the Missing Member" data-type="sect2"><div class="sect2" id="idm45261340254056">&#13;
<h2>The Case of the Missing Member</h2>&#13;
&#13;
<p>Since the etcd Operator understands etcd’s state, it can recover from an etcd cluster member’s failure in the same way Kubernetes replaced the deleted stateless web server pod in our earlier example. Assume there is a three-member etcd cluster managed by the etcd Operator.<a data-primary="pods" data-secondary="etcd cluster members and Operator running as" data-type="indexterm" id="idm45261340252184"/> The Operator itself and the etcd cluster members run as pods:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get pods</strong>&#13;
NAME                              READY     STATUS    RESTARTS   AGE&#13;
etcd-operator-6f44498865-lv7b9    1/1       Running   <code>0</code>          1h&#13;
example-etcd-cluster-cpnwr62qgl   1/1       Running   <code>0</code>          1h&#13;
example-etcd-cluster-fff78tmpxr   1/1       Running   <code>0</code>          1h&#13;
example-etcd-cluster-lrlk7xwb2k   1/1       Running   <code>0</code>          1h&#13;
</pre>&#13;
&#13;
<p>Deleting an etcd pod triggers a reconciliation, and the etcd Operator knows how to recover to the desired state of three replicas—something Kubernetes can’t do alone. But unlike with the blank-slate restart of a stateless web server, the Operator has to arrange the new etcd pod’s cluster membership, configuring it for the existing endpoints and establishing it with the remaining etcd members:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl delete pod example-etcd-cluster-cpnwr62qgl</strong>&#13;
$ <strong>kubectl get pods</strong>&#13;
NAME                              READY     STATUS            RESTARTS  AGE&#13;
etcd-operator-6f44498865-lv7b9    1/1       Running           <code>0</code>         1h&#13;
example-etcd-cluster-fff78tmpxr   1/1       Running           <code>0</code>         1h&#13;
example-etcd-cluster-lrlk7xwb2k   1/1       Running           <code>0</code>         1h&#13;
example-etcd-cluster-r6cb8g2qqw   0/1       PodInitializing   <code>0</code>         4s  <a class="co" href="#c01-i" id="comarker1-i"><img alt="1" src="assets/1.png"/></a>&#13;
</pre>&#13;
<dl class="calloutlist">&#13;
 <dt><a class="co" href="#comarker1-i" id="c01-i"><img alt="1" src="assets/1.png"/></a></dt>&#13;
  <dd><p>The replacement pod is in the <code>PodInitializing</code> state.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The etcd API remains available to clients as the Operator repairs the etcd cluster. In <a data-type="xref" href="ch02.html#running_operators">Chapter 2</a>, you’ll deploy the etcd Operator and put it through its paces while using the etcd API to read and write data. For now, it’s worth remembering that adding a member to a running etcd cluster isn’t as simple as just running a new etcd pod, and the etcd Operator hides that complexity and automatically heals the etcd cluster.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Who Are Operators For?" data-type="sect1"><div class="sect1" id="idm45261340235624">&#13;
<h1>Who Are Operators For?</h1>&#13;
&#13;
<p>The Operator pattern arose in response to infrastructure engineers and developers wanting to extend Kubernetes to provide features specific to their sites and software. Operators make it easier for cluster administrators to enable, and developers to use, foundation software pieces like databases and storage systems with less management overhead. If the “killernewdb” database server that’s perfect for your application’s backend has an Operator to manage it, you can deploy killernewdb without needing to become an expert killernewdb DBA.</p>&#13;
&#13;
<p>Application developers build Operators to manage the applications they are delivering, simplifying the deployment and management experience on their customers’ Kubernetes clusters. Infrastructure engineers create Operators to control deployed services and systems.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operator Adoption" data-type="sect2"><div class="sect2" id="idm45261340232936">&#13;
<h2>Operator Adoption</h2>&#13;
&#13;
<p>A wide variety of developers and companies have adopted the Operator pattern, and there are already many Operators available that make it easier to use key services as components of your applications.<a data-primary="Operators" data-secondary="adoption of" data-type="indexterm" id="idm45261340231384"/> CrunchyData has developed an Operator that manages PostgreSQL database clusters.<a data-primary="MongoDB, Operators for" data-type="indexterm" id="idm45261340230280"/><a data-primary="Redis, Operators for" data-type="indexterm" id="idm45261340229512"/> There are popular Operators for MongoDB and Redis. Rook manages Ceph storage on Kubernetes clusters, while other Operators provide on-cluster management of external storage services like Amazon S3.<a data-primary="storage, Operators for" data-type="indexterm" id="idm45261340228504"/></p>&#13;
&#13;
<p>Moreover, Kubernetes-based distributions like Red Hat’s OpenShift use Operators to build features atop a Kubernetes core, keeping the OpenShift web console available and up to date, for example. On the user side, OpenShift has added mechanisms for point-and-click Operator installation and use in the web console, and for Operator developers to hook into the <a href="https://operatorhub.io">OperatorHub.io</a>, discussed in <a data-type="xref" href="ch08.html#operator_lifecyle_manager">Chapter 8</a> and <a data-type="xref" href="ch10.html#getting_involved">Chapter 10</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Let’s Get Going!" data-type="sect1"><div class="sect1" id="idm45261340224232">&#13;
<h1>Let’s Get Going!</h1>&#13;
&#13;
<p>Operators need a Kubernetes cluster to run on. In the next chapter we’ll show you a few different ways to get access to a cluster, whether it’s a local virtual Kubernetes on your laptop, a complete installation on some number of nodes, or an external service. Once you have admin access to a Kubernetes cluster, you will deploy the etcd Operator and see how it manages an etcd cluster on your behalf.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>