- en: Chapter 6\. Exploring Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章\. 探索 Docker
- en: Now that you have some experience working with containers and images, we can
    explore some of Docker’s other capabilities. In this chapter, we’ll continue to
    use the `docker` command-line tool to talk to the running `dockerd` server that
    you’ve configured while visiting some of the other fundamental commands.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了一些使用容器和镜像的经验，我们可以探索 Docker 的其他能力。在本章中，我们将继续使用 `docker` 命令行工具与您配置的运行中的
    `dockerd` 服务器交互，同时介绍一些其他基本命令。
- en: 'Docker provides commands to do several additional things easily:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了几个额外的命令来轻松执行一些其他任务：
- en: Printing the Docker version
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 Docker 版本
- en: Viewing the server information
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看服务器信息
- en: Downloading image updates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载镜像更新
- en: Inspecting containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查容器
- en: Entering a running container
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入运行中的容器
- en: Returning a result
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回结果
- en: Viewing logs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看日志
- en: Monitoring statistics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控统计信息
- en: And much more…
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有很多其他内容……
- en: Let’s take a look at these as well as some of the additional community tooling
    that augments Docker’s native capabilities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起查看这些以及一些增强 Docker 本地功能的额外社区工具。
- en: Printing the Docker Version
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印 Docker 版本
- en: If you completed the last chapter, you have a working Docker daemon on a Linux
    server or VM, and you’ve started a base container to make sure it’s all working.
    If you haven’t set that up already and you want to try out the steps in the rest
    of the book, you’ll want to follow the installation steps in [Chapter 3](ch03.html#installing_docker)
    before you move on with this section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经完成了上一章，那么您的 Linux 服务器或虚拟机上已经安装了一个可工作的 Docker 守护程序，并且您已经启动了一个基础容器来确保一切正常运行。如果您还没有完成这些设置，并且想要尝试本书剩余部分的步骤，您需要先按照[第三章](ch03.html#installing_docker)中的安装步骤进行设置。
- en: The absolute simplest thing you can do with Docker is print the versions of
    the various components. It might not sound like much, but this is a useful tool
    to have because Docker is built from a multitude of components whose versions
    will directly dictate what functionality is available to you. Knowing how to show
    the version will also help you troubleshoot certain types of connection issues
    between the client and server. For example, the Docker client might give you a
    cryptic message about mismatched API versions, and it’s nice to be able to translate
    that into Docker versions so you know which component needs updating. This command
    talks to the remote Docker server, so if the client can’t connect to the server
    for any reason, the client will report an error and then only print out the client
    version information. If you find that you are having connectivity problems, you
    should probably revisit the steps in the last chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 最简单的事情之一是打印各个组件的版本。这听起来可能不是很重要，但这是一个有用的工具，因为 Docker 是由多个组件构建而成，它们的版本直接决定了您能够使用的功能。知道如何显示版本还将帮助您解决客户端和服务器之间某些类型的连接问题。例如，Docker
    客户端可能会给您一个关于不匹配 API 版本的神秘消息，了解 Docker 版本后，您就能知道哪个组件需要更新。这个命令与远程 Docker 服务器通信，所以如果客户端因任何原因无法连接服务器，客户端将报告错误，然后仅打印客户端版本信息。如果发现您遇到连接问题，您应该重新查看上一章的步骤。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can always directly log in to the Docker server and run `docker` commands
    from a shell on the server if you are troubleshooting issues or simply do not
    want to use the `docker` client to connect to a remote system. On most Docker
    servers, this will require either `root` privileges or membership in the `docker`
    group to connect to the Unix domain socket that Docker is listening on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在解决问题或者不想使用 `docker` 客户端连接到远程系统时，您可以直接登录到 Docker 服务器，并从服务器上的 shell 运行 `docker`
    命令。在大多数 Docker 服务器上，这将需要 `root` 权限或者连接到 Docker 正在监听的 Unix 域套接字的 `docker` 组成员身份。
- en: 'Since we just installed all of the Docker components at the same time, when
    we run `docker version`, we should see that all of our versions match:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚同时安装了所有 Docker 组件，当我们运行 `docker version` 时，我们应该看到所有版本都匹配：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how we have different sections representing the client and server. In
    this case, we have a matching client and server since we just installed them together.
    But it’s important to note that this won’t always be the case. Hopefully, in your
    production systems, you can manage to keep the same version running on most systems.
    But it’s not uncommon for development environments and build systems to have slightly
    different versions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们有不同部分表示客户端和服务器。在这种情况下，我们有一个匹配的客户端和服务器，因为我们刚刚一起安装它们。但是需要注意的是，这种情况并不总是如此。希望在您的生产系统中，您能够确保大多数系统运行相同版本。但是在开发环境和构建系统中，具有稍微不同版本的情况并不罕见。
- en: API clients and libraries will usually work across a large number of Docker
    versions, depending on which API version they require. In the `Server` section,
    we can see that the current API version is 1.41 and the minimum API it will serve
    is 1.12\. This is useful information when you’re working with third-party clients,
    and now you know how to verify this information.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: API 客户端和库通常可以在大量 Docker 版本上工作，具体取决于它们所需的 API 版本。在`Server`部分中，我们可以看到当前 API 版本是
    1.41，并且它将服务的最低 API 版本是 1.12。这些信息在您与第三方客户端合作时非常有用，现在您知道如何验证这些信息了。
- en: Server Information
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器信息
- en: 'We can also find out a lot about the Docker server via the Docker client. Later
    we’ll talk more about what all of this means, but you can find out which filesystem
    backend the Docker server is running, which kernel version it is on, which operating
    system it is running on, which plug-ins are installed, which runtime is being
    used, and how many containers and images are currently stored there. `docker system
    info` will present you with something similar to this, which has been shortened
    for brevity:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Docker 客户端，我们还可以了解很多关于 Docker 服务器的信息。稍后我们会详细讨论所有这些内容的含义，但是您可以了解到 Docker 服务器正在运行哪种文件系统后端，它的内核版本是多少，它运行的操作系统是什么，安装了哪些插件，正在使用哪种运行时，以及当前存储了多少容器和镜像。`docker
    system info`将为您提供类似于以下内容的信息，为了简洁起见，这里进行了缩写：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Depending on how your Docker daemon is set up, this might look somewhat different.
    Don’t be concerned about that; this is just to give you an example. Here we can
    see that our server is a Docker Desktop release running the 5.10.104 Linux kernel
    and backed with the `overlay2` filesystem driver. We also have a few images and
    containers on the server. With a fresh install, this number should be zero.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的 Docker 守护程序设置方式，显示可能会有所不同。不必担心这一点；这只是为了给您一个示例。在这里，我们可以看到我们的服务器是运行 5.10.104
    Linux 内核和支持`overlay2`文件系统驱动的 Docker Desktop 版本。我们在服务器上还有一些镜像和容器。在全新安装时，这个数字应该是零。
- en: The information about plug-ins is worth pointing out here. It’s telling us about
    all the things this installation of Docker supports. On a fresh install, things
    will look more or less like this, depending on which new plug-ins are distributed
    with Docker. Docker itself is made up of many different plug-ins all working together.
    This is powerful because it means it’s also possible to install several other
    plug-ins contributed by members of the community. It’s useful to be able to see
    which are installed even if you just want to make sure Docker has recognized one
    that you recently added.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要指出插件的信息。它告诉我们这个 Docker 安装支持的所有内容。在刚安装时，情况看起来会差不多，这取决于 Docker 随附的新插件。Docker
    本身由许多不同的插件组成，它们共同工作。这很强大，因为这意味着也可以安装社区成员贡献的其他几个插件。即使您只想确保 Docker 已识别最近添加的插件，了解安装了哪些插件也很有用。
- en: 'In most installations, */var/lib/docker* will be the default root directory
    used to store images and containers. If you need to change this, you can edit
    your Docker startup scripts to launch the daemon, with the `--data-root` argument
    pointing to a new storage location. To test this by hand, you could run something
    like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数安装中，*/var/lib/docker* 将是用于存储镜像和容器的默认根目录。如果需要更改此设置，可以编辑 Docker 启动脚本以启动守护进程，并使用`--data-root`参数指向新的存储位置。要手动测试这一点，可以运行类似以下命令：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: By default, [the configuration file for the Docker server](https://oreil.ly/jp7iK)^([1](ch06.html#idm46803145473376))
    can be found in */etc/docker/daemon.json*. Most of the arguments that we discuss
    passing directly to `dockerd` can be permanently set in this file. If you are
    using Docker Desktop, you are advised to modify this file in the Docker Desktop
    UI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，[Docker 服务器的配置文件](https://oreil.ly/jp7iK)^([1](ch06.html#idm46803145473376))可以在*/etc/docker/daemon.json*中找到。我们讨论的大多数传递给`dockerd`的参数可以在这个文件中永久设置。如果你使用的是Docker
    Desktop，建议你在Docker Desktop的用户界面中修改这个文件。
- en: We will talk more about runtimes later, but here you can see that we have three
    runtimes installed. The `runc` runtime is the default Docker runtime. If you think
    of Linux containers, you are usually thinking about the type of container that
    `runc` builds. On this server, we also have the `io.containerd.runc.v2` and `io.containerd.runtime.v1.linux`
    runtimes installed. We’ll talk more about some other runtimes in [Chapter 11](ch11.html#advanced_topics).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会详细讨论运行时，但在这里你可以看到我们安装了三个运行时。`runc`运行时是默认的Docker运行时。如果你考虑Linux容器，你通常是在考虑`runc`构建的容器类型。在这台服务器上，我们还安装了`io.containerd.runc.v2`和`io.containerd.runtime.v1.linux`运行时。我们将在[第11章](ch11.html#advanced_topics)进一步讨论一些其他运行时。
- en: Downloading Image Updates
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载镜像更新
- en: We’re going to use an Ubuntu base image for the following examples. Even if
    you already grabbed the `ubuntu:latest` base image once, you can `pull` it again
    and it will automatically pick up any updates that have been published since you
    last ran it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中使用一个Ubuntu基础镜像。即使你已经拉取过`ubuntu:latest`基础镜像一次，你可以再次`pull`它，它将自动获取自上次运行以来发布的任何更新。
- en: 'This is because `latest` is a tag that, by convention, is supposed to represent
    the latest build of the container. However, the `latest` tag is controversial,
    since it is not permanently pinned to a specific image and can have different
    meanings across different projects. Some people use it to point to the most recent
    stable release, some use it to point to the last build produced by their CI/CD
    system, and others simply refuse to tag any of their images with `latest`. That
    being said, it is still in wide use and can be useful in preproduction environments
    where the convenience of using it outweighs the lack of assurances that a real
    version provides:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`latest`是一个标签，按照约定应该表示容器的最新构建版本。然而，`latest`标签备受争议，因为它并没有永久固定到特定的镜像上，并且在不同项目中可能有不同的含义。有些人使用它指向最新的稳定版本，有些人用它指向他们CI/CD系统产生的最后一次构建，还有些人干脆拒绝给他们的镜像打`latest`标签。尽管如此，它仍然被广泛使用，并且在预生产环境中使用它的便利性超过了真实版本提供的保证的缺失：
- en: 'Invoking `docker image pull` will look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`docker image pull`看起来是这样的：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That command pulled down only the layers that have changed since we last ran
    the command. You might see a longer or shorter list, or even an empty list, depending
    on when you last pulled the image, what changes have been pushed to the registry
    since then, and how many layers the target image contains.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令只会下载自上次运行命令以来发生变化的层级。根据你上次拉取镜像的时间、注册表中推送的变更以及目标镜像包含的层级数量，你可能会看到一个更长或更短的列表，甚至是一个空列表。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: It’s good to remember that even though you pulled `latest`, Docker won’t automatically
    keep the local image up to date for you. You’ll be responsible for doing that
    yourself. However, if you deploy an image based on a newer copy of `ubuntu:latest`,
    the Docker client will download the missing layers during the deployment just
    like you would expect. Keep in mind that this is the behavior of the Docker client,
    and other libraries or API tools may not behave this way. It’s highly recommended
    that you always deploy production code using a fixed version tag rather than the
    `latest` tag. This helps guarantee that you get the version you expect and there
    are no unexpected surprises.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，即使你拉取了`latest`，Docker也不会自动为你保持本地镜像的更新。你需要自己负责更新。然而，如果你部署了基于更新版的`ubuntu:latest`的镜像，Docker客户端会在部署过程中下载缺失的层级，就像你期望的那样。请记住，这是Docker客户端的行为，其他库或API工具可能不会以这种方式行为。强烈建议你始终使用固定版本标签而不是`latest`标签来部署生产代码。这有助于确保你获得你期望的版本，并且没有意外的惊喜。
- en: 'In addition to referring to items in the registry by the `latest` tag or another
    version number tag, you can refer to them by their content-addressable tag, which
    looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过`latest`标签或其他版本号标签引用注册表中的项目外，你还可以通过它们的内容可寻址标签引用它们，看起来像这样：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These are generated as a hashed sum of the contents of the image and are a
    very precise identifier. This is by far the safest way to refer to Docker images
    when you need to make sure you are getting the exact version you expect because
    these can’t be moved like a version tag. The syntax for pulling them from the
    registry is very similar, but note the `@` in the tag:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些哈希是基于镜像内容的哈希总和生成的，是非常精确的标识符。这是确保获取您期望的确切版本时，远远比版本标签更安全的方式，因为这些标签不能像版本标签那样被移动。从注册表中拉取它们的语法非常相似，但请注意标签中的
    `@`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unlike most Docker commands where you may shorten the hash, you cannot do that
    with SHA-256 hashes. You must use the full hash here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 Docker 命令不同，您可能会缩短哈希，但在这里不能使用 SHA-256 哈希。您必须使用完整的哈希。
- en: Inspecting a Container
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查一个容器
- en: Once you have a container created, running or not, you can now use `docker`
    to see how it was configured. This is often useful in debugging and also has some
    other information that can be useful for identifying a container.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了一个容器，无论是正在运行还是没有运行，现在可以使用 `docker` 命令来查看它的配置。这通常在调试中非常有用，还提供了一些其他可以用来识别容器的信息。
- en: 'For this example, go ahead and start up a container:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个例子，继续启动一个容器：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can list all our running containers with `docker container ls` to ensure
    everything is running as expected, and to copy the container ID:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker container ls` 列出所有正在运行的容器，以确保一切都按预期运行，并复制容器 ID：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, our ID is `3c4f916619a5`. We could also use `angry_mestorf`, which
    is the dynamic name assigned to our container. Many underlying tools need the
    unique container ID though, so it’s useful to get into the habit of looking at
    that first. As we mentioned earlier, the ID as shown is the truncated (or short)
    version, but Docker treats these interchangeably with the long versions. As is
    the case in many version control systems, this hash is just the prefix of a much
    longer hash. Internally, the kernel uses a 64-byte hash to identify the container.
    But that’s painful for humans to use, so Docker supports the shortened hash.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的 ID 是 `3c4f916619a5`。我们还可以使用 `angry_mestorf`，这是分配给我们的容器的动态名称。然而，许多底层工具需要唯一的容器
    ID，所以养成首先查看它的习惯是很有用的。正如我们之前提到的，如显示的那样，ID 是截断（或短）版本，但 Docker 在长版本和短版本之间是可以互换使用的。与许多版本控制系统一样，这个哈希只是更长哈希的前缀。内核在内部使用一个
    64 字节的哈希来标识容器。但是这对人类来说是痛苦的，所以 Docker 支持缩短的哈希。
- en: 'The output to `docker container inspect` is pretty verbose, so we’ll cut it
    down in the following code block to a few values worth pointing out. You should
    look at the full output to see what else you think is interesting:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container inspect` 的输出非常详细，所以我们将在下面的代码块中精简为几个值值得注意。您应该查看完整的输出，以查看您认为有趣的其他内容：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that long `"Id"` string. That’s the full unique identifier of this container.
    Luckily we can use the short version, even if that’s still not especially convenient.
    We can also see that the exact time when the container was created is much more
    precise than what `docker container ls` gives us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那个长长的 `"Id"` 字符串。那是这个容器的完整唯一标识符。幸运的是，我们可以使用短版本，即使这仍然不是特别方便。我们还可以看到容器创建的确切时间比
    `docker container ls` 给出的时间要精确得多。
- en: 'Some other interesting things are shown here as well: the top-level command
    in the container, the environment that was passed to it at creation time, the
    image on which it’s based, and the hostname inside the container. All of these
    are configurable at container creation time if you need to do so. The usual method
    for passing configuration to containers, for example, is via environment variables,
    so being able to see how a container was configured via `docker container inspect`
    can reveal a lot when you’re debugging.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还显示了一些其他有趣的东西：容器中的顶层命令、在创建时传递给它的环境、基于的镜像以及容器内部的主机名。所有这些在容器创建时都是可配置的，如果需要的话。例如，通过环境变量传递配置给容器的通常方法，所以通过
    `docker container inspect` 查看容器配置的能力，在调试时可以揭示很多信息。
- en: You can go ahead and stop the current container by running something like `docker
    container stop 3c4f916619a5`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行类似 `docker container stop 3c4f916619a5` 的命令停止当前容器。
- en: Exploring the Shell
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Shell
- en: 'Let’s get a container running with just an interactive `bash` shell so we can
    take a look around. We’ll do that, as we did before, by running something like
    this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只用一个交互式的 `bash` shell 来运行一个容器，这样我们可以四处看看。我们将像之前那样运行以下类似的内容：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That will run an Ubuntu 22.04 LTS container with the bash shell as the top-level
    process. By specifying the `22.04` tag, we can be sure to get a particular version
    of the image. So, when we start that container, what processes are running?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会运行一个 Ubuntu 22.04 LTS 容器，并将 bash shell 设置为顶层进程。通过指定 `22.04` 标签，我们可以确保获得特定版本的镜像。那么，当我们启动该容器时，会运行哪些进程呢？
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Wow, that’s not much, is it? It turns out that when we told `docker` to start
    `bash`, we didn’t get anything but that. We’re inside a whole Linux distribution
    image, but no other processes started for us automatically. We only got what we
    asked for. It’s good to keep that in mind going forward.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这真不多，是吧？事实证明，当我们告诉 `docker` 启动 `bash` 时，除此之外我们什么也没有得到。我们身处一个完整的 Linux 发行版镜像中，但没有其他进程会自动为我们启动。我们只得到了我们所请求的内容。在今后的操作中，记住这一点是很重要的。
- en: Warning
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Linux containers don’t, by default, start anything in the background as a full
    VM would. They’re a lot lighter weight than that and therefore don’t start an
    `init` system. You can, of course, run a whole `init` system if you need to, or
    the [`tini init` system](https://github.com/krallin/tini) that is built into Docker,
    but you have to ask for it. We’ll talk about that more in [Chapter 7](ch07.html#debug_docker).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 容器默认不像完整的虚拟机那样在后台启动任何东西。它们比虚拟机轻量得多，因此不会启动 `init` 系统。当然，如果需要，你可以运行一个完整的
    `init` 系统，或者内置在 Docker 中的 [`tini init` 系统](https://github.com/krallin/tini)，但你必须明确请求。我们将在[第7章](ch07.html#debug_docker)中更详细地讨论这个问题。
- en: That’s how we get a shell running in a container. Feel free to poke around and
    see what else looks interesting inside the container. You might have a pretty
    limited set of commands available. You’re in a base Ubuntu distribution, though,
    so you can fix that by using `apt-get update`, followed by `apt-get install…`
    to download more packages. However, these applications are only going to be around
    for the life of this container. You’re modifying the top layer of the container,
    not the base image! Containers are by nature ephemeral, so anything you do inside
    this container won’t outlast it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在容器中运行 shell 的方式。随意探索并看看容器内还有什么其他有趣的东西。你可能只能使用有限的一组命令。不过，由于你位于基础的 Ubuntu
    发行版中，你可以通过 `apt-get update`，然后 `apt-get install…` 来下载更多的软件包。但是这些应用程序只会存在于此容器的生命周期内。你修改的是容器的顶层层，而不是基础镜像！容器本质上是短暂的，因此你在容器内所做的任何操作都不会超出其生命周期。
- en: 'When you are done in the container, make sure to `exit` the shell, which will
    then naturally stop the container:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在容器中完成操作后，确保使用 `exit` 命令退出 shell，这样容器就会自然停止：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Returning a Result
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回结果
- en: 'How inefficient would it be to spin up a whole VM to run one command and get
    the results? You usually wouldn’t want to do this because it would be very time-consuming
    and would require booting a whole operating system to simply execute one command.
    But Docker and Linux containers do not work the same way as VMs do: containers
    are very lightweight and don’t have to boot up like an operating system does.
    Running something like a quick background job and waiting for the exit code is
    a normal use case for a Linux container. You can think of it as a way to get remote
    access to a containerized system and have access to any of the individual commands
    inside that container with the ability to pipe data to and from them and return
    exit codes.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为了运行一个命令并获取结果而启动一个完整的虚拟机，效率会有多低呢？通常情况下，你不会希望这样做，因为这将非常耗时，并且需要启动一个完整的操作系统来执行一个简单的命令。但是
    Docker 和 Linux 容器的工作方式不同于虚拟机：容器非常轻量化，不需要像操作系统那样启动。运行像是快速后台作业并等待退出代码的操作是 Linux
    容器的正常用例。你可以把它看作是一种远程访问容器化系统的方式，并且可以访问容器内的任何单个命令，并能够将数据传输到其中并返回退出代码。
- en: 'This can be useful in lots of scenarios: you might, for instance, have system
    health checks run this way remotely or have a series of machines with processes
    that you spin up via Docker to process a workload and then return. The `docker`
    command-line tools proxy the results to the local machine. If you run the remote
    command in foreground mode and don’t specify doing otherwise, `docker` will redirect
    its `stdin` to the remote process, and the remote process’s `stdout` and `stderr`
    to your terminal. The only things we have to do to get this functionality are
    to run the command in the foreground and not allocate a TTY on the remote. This
    is also the default configuration! No command-line options are required.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这在许多场景下非常有用：例如，您可能会远程运行系统健康检查，或者有一系列通过 Docker 启动以处理工作负载并返回的机器上的进程。`docker` 命令行工具会代理结果到本地机器。如果以前台模式运行远程命令并且没有指定其他操作，`docker`
    将重定向其 `stdin` 到远程进程，并将远程进程的 `stdout` 和 `stderr` 输出到您的终端。要实现此功能，我们只需在前台运行命令，并在远程不分配
    TTY 的情况下。这也是默认配置！不需要任何命令行选项。
- en: 'When we run these commands, Docker creates a new container, executes the command
    that we requested inside the container’s namespaces and cgroups, removes the container,
    and then exits so that nothing is left running or taking up unnecessary disk space
    between invocations. The following code should give you an idea of the types of
    things that you can do:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这些命令时，Docker 创建一个新的容器，在容器的命名空间和 cgroups 中执行我们请求的命令，然后删除容器，以便在调用之间不会留下任何正在运行或占用不必要的磁盘空间。以下代码应该让您对可以执行的类型有一个大致的了解：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we executed `/bin/false` on the remote server, which will always exit with
    a status of `1`. Notice how `docker` proxied that result to us in the local terminal.
    Just to prove that it returns other results, we also run `/bin/true`, which will
    always return a `0`. And there it is.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在远程服务器上执行了 `/bin/false`，它将始终以 `1` 的状态退出。请注意 `docker` 如何将该结果代理到我们的本地终端。为了证明它返回其他结果，我们还运行了
    `/bin/true`，它将始终返回 `0`。就是这样。
- en: Then we actually ask `docker` to run `cat /etc/passwd` on the remote container.
    What we get is a printout of the */etc/passwd* file contained inside that container’s
    filesystem. Because that’s just regular output on *stdout*, we can pipe it into
    local commands just like we would anything else.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实际上要求 `docker` 在远程容器上运行 `cat /etc/passwd`。我们得到的是包含在该容器文件系统中 */etc/passwd*
    文件的打印输出。因为这只是标准输出的常规输出，我们可以像处理其他任何东西一样将其管道传递到本地命令中。
- en: Warning
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The previous code pipes the output into the local `wc` command, not a `wc` command
    in the container. The pipe itself is not passed to the container. If you want
    to pass the whole command, including the pipes, to the server, you need to invoke
    a complete shell on the remote side and pass a quoted command, like `bash -c "<your
    command> | <something else>"`. In the previous code, that would be `docker container
    run ubuntu:22.04 /bin/` `bash -c "` `/bin/cat /etc/passwd | wc -l"`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将输出通过管道传递给本地的 `wc` 命令，而不是容器中的 `wc` 命令。管道本身不会传递到容器中。如果您想将整个命令（包括管道）传递到服务器端，您需要在远程端调用一个完整的
    shell 并传递带引号的命令，如 `bash -c "<your command> | <something else>"`。在前面的代码中，这将是 `docker
    container run ubuntu:22.04 /bin/` `bash -c "` `/bin/cat /etc/passwd | wc -l"`。
- en: Getting Inside a Running Container
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入运行中的容器
- en: You can pretty easily get a shell running in a new container, based on almost
    any image, as we demonstrated earlier with `docker container run`. But it’s not
    the same as getting a new shell inside an existing container that is actively
    running your application. Every time you use `docker container run`, you get a
    new container. But if you have an existing container that is running an application
    and you need to debug it from inside the container, you need something else.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以很容易地在基于几乎任何镜像的新容器中运行 shell，就像我们之前使用 `docker container run` 所演示的那样。但是，在已经运行您的应用程序的现有容器内部获取新的
    shell 并不相同。每次使用 `docker container run`，都会得到一个新的容器。但是，如果您有一个正在运行应用程序的现有容器，并且需要从容器内部调试它，您需要其他方法。
- en: Using `docker container exec` is the Docker-native way to get a new interactive
    process in a container, but there is also a more Linux-native way to do it, called
    `nsenter`. We will take a look at `docker container exec` in this section and
    cover `nsenter` later in [“nsenter”](ch11.html#nsenter).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker container exec` 是 Docker 的本地方式在容器中获取新的交互式进程，但还有一种更适合 Linux 的方式，称为
    `nsenter`。我们将在本节中查看 `docker container exec`，稍后在 [“nsenter”](ch11.html#nsenter)
    中介绍 `nsenter`。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering why you would ever want to do this. In development, this
    can be very useful when you are actively building and testing your application.
    This is the mechanism that [development containers](https://containers.dev) use
    in IDEs like [Visual Studio Code](https://code.visualstudio.com/docs/devcontainers/containers).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么要这样做。在开发中，当你积极地构建和测试你的应用程序时，这是非常有用的。这是[开发容器](https://containers.dev)在像[Visual
    Studio Code](https://code.visualstudio.com/docs/devcontainers/containers)这样的IDE中使用的机制。
- en: In production, it isn’t considered good practice to SSH into your production
    servers, and this is roughly the same thing; but there are times when it’s very
    important to see what’s going on inside the actual environment, and this can help
    you out in those situations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，SSH登录到生产服务器并不被认为是一个好的做法，这大致相同；但在某些情况下，看看实际环境内发生了什么非常重要，这时可以帮助你解决问题。
- en: docker container exec
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker container exec
- en: First, let’s take a look at the easiest and best way to get inside a running
    container. The `dockerd` server and `docker` command-line tool support remotely
    executing a new process in a running container via the `docker container exec`
    command. So let’s start up a container in background mode and then enter it using
    `docker container exec` and invoking a shell.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看最简单和最佳的进入运行中容器的方法。`dockerd`服务器和`docker`命令行工具支持通过`docker container exec`命令在运行中的容器中远程执行新进程。因此，让我们在后台模式下启动一个容器，然后使用`docker
    container exec`进入它并调用一个shell。
- en: 'The command you invoke doesn’t have to be a shell: it’s possible to run individual
    commands inside the container and see their results outside it using `docker container
    exec`. But if you want to get inside the container to look around, a shell is
    the easiest way to do that.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用的命令不一定要是一个shell：可以在容器内运行单独的命令，并在容器外查看它们的结果，使用`docker container exec`。但如果你想进入容器查看情况，shell是最简单的方法。
- en: 'To run `docker container exec`, we’ll need our container’s ID. For this demo,
    let’s create a container that will just run the `sleep` command for 600 seconds:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`docker container exec`，我们需要我们容器的ID。对于这个演示，让我们创建一个只运行`sleep`命令600秒的容器：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The short ID for this container is `9f09ac4bcaa0`. We can now use that to get
    inside the container with `docker container exec`. The command line for that,
    unsurprisingly, looks a lot like the command line for `docker container run`.
    We request an interactive session and a pseudo-TTY with the `-i` and `-t` flags:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器的短ID是`9f09ac4bcaa0`。现在我们可以使用它来使用`docker container exec`进入容器。这个命令行，毫不奇怪地，看起来非常像`docker
    container run`的命令行。我们请求一个交互式会话和一个伪终端，使用`-i`和`-t`标志：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that we got a command line back that tells us the ID of the container
    we’re running inside. That’s pretty useful for keeping track of where we are.
    We can now run a normal Linux `ps` to see what else is running inside our container.
    We should see the `sleep` process that was created when the container was originally
    started:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们得到了一个命令行回显，告诉我们我们正在运行的容器的ID。这对于跟踪我们所在位置非常有用。现在我们可以运行一个普通的Linux `ps`命令，看看我们的容器内还有什么正在运行。我们应该能看到在容器最初启动时创建的`sleep`进程：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Type `exit` to get out of the container when you are done.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成时，键入`exit`以退出容器。
- en: Warning
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You can also run additional processes in the background via `docker container
    exec`. You use the `-d` option just like with `docker container run`. But you
    should think hard about doing that for anything but debugging because you lose
    the repeatability of the image deployment if you depend on this mechanism. Other
    people would then have to know what to pass to `docker container exec` to get
    the desired functionality. If you’re tempted to do this, you would probably reap
    bigger gains from rebuilding your container image to launch both processes in
    a repeatable way. If you need to signal to the software inside the container to
    take some action like rotating logs or reloading a configuration, it is cleaner
    to leverage `docker container kill -s <SIGNAL>` with the standard Unix signal
    name to pass information to the process inside the container.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过`docker container exec`在后台运行额外的进程。你可以像使用`docker container run`一样使用`-d`选项。但是除了调试之外，你应该仔细考虑这样做，因为这会导致镜像部署的可重复性丧失。其他人将不得不知道如何通过`docker
    container exec`传递参数以获得所需的功能。如果你想这样做，重建容器镜像以可重复地启动这两个进程可能会带来更大的收益。如果需要通知容器内的软件执行某些操作，比如旋转日志或重新加载配置，最好使用`docker
    container kill -s <SIGNAL>`与标准Unix信号名称传递信息给容器内的进程。
- en: docker volume
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker volume
- en: Docker supports a `volume` subcommand that makes it possible to list all of
    the volumes stored in your root directory and then discover additional information
    about them, including where they are physically stored on the server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 支持一个 `volume` 子命令，可以列出存储在根目录中的所有卷，然后发现关于它们的附加信息，包括它们在服务器上物理存储的位置。
- en: These volumes are not bind-mounted; instead, they are special data containers
    that provide a useful method for persisting data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些卷不是绑定挂载的；相反，它们是提供一种持久化数据的有用方法的特殊数据容器。
- en: 'If we run a normal `docker` command that bind-mounts a directory, we’ll notice
    that it does not create any Docker volumes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行一个普通的 `docker` 命令来绑定挂载一个目录，我们会注意到它不会创建任何 Docker 卷：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, you can easily create a new volume with a command like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以轻松地通过类似这样的命令创建一个新的卷：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you then list all your volumes, you should see something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果然后列出所有的卷，您应该会看到类似这样的内容：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now you can start a container with this data volume attached to it by running
    the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过运行以下命令启动一个附加了此数据卷的容器：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That container created a file in the data volume and then immediately exited.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器在数据卷中创建了一个文件，然后立即退出。
- en: 'If we now mount that data volume to a different container, we will see that
    our data is still there:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将该数据卷挂载到另一个容器，我们将看到我们的数据仍然存在：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And finally, you can delete the data volume when you are done with it by running
    the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您完成时，可以通过运行以下命令删除数据卷：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you try to delete a volume that is in use by a container (whether it is
    running or not), you’ll get an error like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试删除一个被容器使用的卷（无论它是正在运行还是未运行），您将会收到如下错误：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These commands should help you explore your containers in great detail. Once
    we’ve explained namespaces more in [Chapter 11](ch11.html#advanced_topics), you’ll
    get a better understanding of exactly how all these pieces interact and combine
    to create a container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令应该帮助您详细探索您的容器。一旦我们在[第11章](ch11.html#advanced_topics)中更详细地解释了命名空间，您将更好地理解所有这些部分如何交互和组合以创建一个容器。
- en: Logging
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: Logging is a critical part of any production application. When things go wrong,
    logs can be a critical tool in restoring service, so they need to be done well.
    There are some common ways in which we expect to interact with application logs
    on Linux systems, some better than others. If you’re running an application process
    on a box, you might expect the output to go to a local logfile that you could
    read through. Or perhaps you might expect the output to simply be logged to the
    kernel buffer where it can be read from `dmesg`. Or, as on many modern Linux distributions
    with `systemd`, you might expect logs to be available from `journalctl`. Because
    of the container’s restrictions and how Docker is constructed, none of these will
    work without at least some configuration on your part. But that’s OK because logging
    has first-class support in Docker.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是任何生产应用程序的关键部分。当出现问题时，日志可以是恢复服务的关键工具，因此需要做好。有一些常见的方式，我们期望在 Linux 系统上与应用程序日志交互，有些更好，有些不如。如果您在一台机器上运行应用程序进程，您可能期望输出被记录到一个本地日志文件中，您可以通过它来阅读。或者也许您期望输出简单地记录到内核缓冲区中，从那里可以读取
    `dmesg`。或者，就像许多现代 Linux 发行版中使用 `systemd` 一样，您可能期望从 `journalctl` 中获取日志。由于容器的限制以及
    Docker 的构造方式，如果没有您的一些配置，这些方式都不会起作用。但这没关系，因为日志记录在 Docker 中有一流的支持。
- en: Docker makes logging easier in a few critical ways. First, it captures all of
    the normal text output from applications in the containers it manages. Anything
    sent to `stdout` or `stderr` in the container is captured by the Docker daemon
    and streamed into a configurable logging backend. Secondly, like many other parts
    of Docker, this system is pluggable, and there are lots of powerful options available
    to you as plug-ins. But let’s not dive into the deep end just yet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在几个关键方面使日志记录变得更加简单。首先，它捕获了容器中应用程序的所有普通文本输出。任何发送到容器中的 `stdout` 或 `stderr`
    的内容都会被 Docker 守护程序捕获，并流式传输到可配置的日志后端。其次，像 Docker 的许多其他部分一样，这个系统是可插拔的，有许多强大的选项作为插件供您选择。但是，让我们暂时不要深入讨论。
- en: docker container logs
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker container logs
- en: 'We’ll start with the simplest Docker use case: the default logging mechanism.
    There are limitations to this mechanism, which we’ll explain in a minute, but
    for the most common use cases, it works well, and it’s very convenient. If you
    are running Docker in development, this is probably the only logging strategy
    you’ll use there. This logging method has been there from the very beginning and
    is well understood and supported. The mechanism is the `json-file` method. The
    `docker container logs` command exposes most users to this.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的 Docker 使用案例开始：默认的日志记录机制。虽然这种机制有一些限制，我们马上会解释，但对于大多数常见的用例，它工作得很好，并且非常方便。如果您在开发中使用
    Docker，这可能是您唯一使用的日志策略。此日志方法从一开始就存在，并且得到了很好的理解和支持。该机制是 `json-file` 方法。`docker container
    logs` 命令向大多数用户公开了这一点。
- en: As implied by the name, when you run the default `json-file` logging plug-in,
    your application’s logs are streamed by the Docker daemon into a JSON file for
    each container. This lets us retrieve logs for any container at any time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，当您运行默认的 `json-file` 日志插件时，Docker 守护程序将您的应用程序日志流式传输到每个容器的一个 JSON 文件中。这使我们可以随时检索任何容器的日志。
- en: 'We can display some logs by starting an `nginx` container:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启动 `nginx` 容器来显示一些日志：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and then:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is nice because Docker allows you to get the logs remotely, right from
    the command line, on demand. That’s very useful for low-volume logging.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为 Docker 允许您随时从命令行远程获取日志。这对低容量日志记录非常有用。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To limit the log output to more recent logs, you can use the `--since` option
    to display logs only after a specified RFC 3339 date (e.g., 2002-10-02T10:00:00-05:00),
    Unix timestamp (e.g., 1450071961), standard timestamp (e.g., 20220731), or Go
    duration string (e.g., 5m45s). You can also use `--tail` followed by the number
    of lines you would like to tail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要将日志输出限制为更近期的日志，请使用 `--since` 选项，仅显示指定 RFC 3339 日期（例如，2002-10-02T10:00:00-05:00）、Unix
    时间戳（例如，1450071961）、标准时间戳（例如，20220731）或 Go 时长字符串（例如，5m45s）。您还可以使用 `--tail` 后跟您希望追踪的行数。
- en: 'The actual files backing this logging are on the Docker server itself, by default
    in */var/lib/docker/containers/`<container_id>`/* where the `*<container_id>*`
    is replaced by the actual container ID. If you take a look at the file named `*<container_id>*-json.log`,
    you’ll see that it’s a file with each line representing a JSON object. It will
    look something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此日志的实际文件位于 Docker 服务器本身，默认情况下在 */var/lib/docker/containers/`<container_id>`/*，其中
    `*<container_id>*` 将被实际的容器 ID 替换。如果您查看名为 `*<container_id>*-json.log` 的文件，您将看到它是一个每行代表一个
    JSON 对象的文件。它看起来会像这样：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That `log` field is exactly what was sent to `stdout` on the process in question;
    the `stream` field tells us that this was `stdout` and not `stderr`, and the precise
    time that the Docker daemon received it is provided in the `time` field. It’s
    an uncommon format for logging, but it’s structured rather than just a raw stream,
    which is beneficial if you want to do anything with the logs later.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `log` 字段就是发送到所讨论进程的 `stdout` 的内容；`stream` 字段告诉我们这是 `stdout` 而不是 `stderr`，Docker
    守护程序接收到它的精确时间在 `time` 字段中提供。这是一种不常见的日志格式，但它是结构化的而不是原始流，如果以后要对日志做任何处理，则非常有益。
- en: 'Like a logfile, you can also tail the Docker logs live with `docker container
    logs -f`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 就像日志文件一样，您也可以使用 `docker container logs -f` 实时追踪 Docker 日志：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This looks identical to the usual `docker container logs`, but the client will
    continue to wait for, and then display, new messages as they are received from
    the server, much like the Linux command line `tail -f`. You can type Ctrl-C to
    exit the logs stream at any time:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与通常的 `docker container logs` 没什么两样，但客户端会继续等待并显示从服务器接收到的新消息，就像 Linux 命令行中的
    `tail -f`。您可以随时键入 Ctrl-C 退出日志流：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: By configuring the tag log option similar to `--log-opt tag="{{.ImageName}}/{{.ID}}"`,
    it is possible to change the default log tag (which every log line will start
    with) to something more useful. By default, Docker logs will be tagged with the
    first 12 characters of the container ID.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置类似于 `--log-opt tag="{{.ImageName}}/{{.ID}}"` 的标签日志选项，可以将默认的日志标签（每行日志都以此标签开头）更改为更有用的内容。默认情况下，Docker
    日志将以容器 ID 的前 12 个字符作为标签。
- en: For single-host logging, this mechanism is pretty good. Its shortcomings are
    around log rotation, remote access to the logs once they’ve been rotated, and
    disk space usage for high-volume logging. Despite being backed by a JSON file,
    this mechanism performs well enough that most production applications can log
    this way if that’s the solution that works for you. But if you have a more complex
    environment, you’re going to want something more robust and with centralized logging
    capabilities.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单主机日志记录，这种机制效果相当不错。它的缺点在于日志轮转、一旦轮转后远程访问日志、以及高容量日志的磁盘空间使用。尽管是由 JSON 文件支持，但如果这种解决方案适合你，大多数生产应用程序可以使用这种方式记录日志。但是，如果你有一个更复杂的环境，你可能需要更强大和具有集中日志功能的解决方案。
- en: Warning
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The default settings for `dockerd` do not currently enable log rotation. You’ll
    want to make sure you specify the `--log-opt` `max-size` and `--log-opt` `max-file`
    settings via the command line or the *daemon.json* configuration file if you are
    running in production. Those settings limit the largest file size before rotation
    and the maximum number of logfiles to keep, respectively. `max-file` does not
    do anything unless you’ve also set `max-size` to tell Docker when to rotate the
    logs. When this is enabled, the `docker container logs` mechanism will return
    data only from the current logfile.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置中，`dockerd` 不会自动启用日志轮转。如果在生产环境中运行，建议通过命令行或者 *daemon.json* 配置文件指定 `--log-opt`
    `max-size` 和 `--log-opt` `max-file` 设置。这些设置分别限制了日志轮转前的最大文件大小和要保留的日志文件的最大数量。除非你同时设置了
    `max-size` 来告诉 Docker 何时轮转日志，否则 `max-file` 是无效的。启用后，`docker container logs` 机制将仅返回当前日志文件中的数据。
- en: More Advanced Logging
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高级的日志记录
- en: For those times when the default mechanism isn’t enough—and at scale, it’s probably
    not—Docker also supports configurable logging backends. This list of plug-ins
    is constantly growing. Currently supported are the `json-file` we described earlier,
    as well as `syslog`, `fluentd`, `journald`, `gelf`, `awslogs`, `splunk`, `gcplogs`,
    `local`, and `logentries`, which are used for sending logs to various popular
    logging frameworks and services.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认机制不足以应对的情况下（在大规模使用时，可能会出现这种情况），Docker 还支持可配置的日志后端。这些插件列表正在不断增加。目前支持的包括我们早些描述的
    `json-file`，以及 `syslog`、`fluentd`、`journald`、`gelf`、`awslogs`、`splunk`、`gcplogs`、`local`
    和 `logentries`，它们用于将日志发送到各种流行的日志框架和服务。
- en: That’s a big list of plug-ins we just threw out there. The supported option
    that currently is the simplest for running Docker at scale is sending your container
    logs to `syslog` directly from Docker. You can specify this on the Docker command
    line with the `--log-driver=syslog` option or set it as the default in the *daemon.json*
    file for all containers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一个庞大的插件列表。目前支持的最简单的选项，用于在大规模上运行 Docker，是直接将容器日志通过 `syslog` 发送。你可以在 Docker
    命令行中使用 `--log-driver=syslog` 选项指定它，或者在 *daemon.json* 文件中为所有容器设置为默认值。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The *daemon.json* file is the configuration for the `dockerd` server. It can
    usually be found in the */etc/docker/* directory on the server. For Docker Desktop,
    this file can be edited in Preferences → Docker Engine from the UI. If you change
    this file, you will need to restart Docker Desktop or the `dockerd` daemon.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*daemon.json* 文件是 `dockerd` 服务器的配置文件。通常可以在服务器的 */etc/docker/* 目录中找到这个文件。对于
    Docker Desktop 用户，可以在 UI 的 Preferences → Docker Engine 中编辑此文件。如果更改了此文件，需要重新启动
    Docker Desktop 或 `dockerd` 守护进程。'
- en: There are also several third-party plug-ins available. We’ve seen mixed results
    from third-party plug-ins, primarily because they complicate installing and maintaining
    Docker. However, you may find that there is a third-party implementation that’s
    perfect for your system, and it might be worth the installation and maintenance
    hassle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 同样有几个第三方插件可用。我们从第三方插件中看到了不同的结果，主要是因为它们使 Docker 的安装和维护变得复杂。但是，你可能会发现有一个适合你系统的第三方实现，值得安装和维护的麻烦。
- en: Warning
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Some caveats apply to all of the logging drivers. For example, Docker supports
    only one at a time. This means that you can use the `syslog` or `gelf` logging
    driver, but not along with the `json-file` driver. Unless you run `json-file`
    or `journald`, you will lose the ability to use the `docker container logs` command!
    This may not be expected and is a big consideration when you are changing the
    driver.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有日志驱动程序都适用一些注意事项。例如，Docker 一次只能支持一个日志驱动程序。这意味着你可以使用 `syslog` 或 `gelf` 日志驱动程序，但不能与
    `json-file` 驱动程序同时使用。除非你运行 `json-file` 或 `journald`，否则将失去使用 `docker container
    logs` 命令的能力！这可能会出乎意料，并且在更改驱动程序时是一个重要的考虑因素。
- en: Some plug-ins are designed to send the logs to a remote endpoint and keep a
    local JSON copy for the `docker container logs` command, but you will need to
    determine if the plug-in that you want to use supports this. There are too many
    gotchas to go through for each driver, but you should keep in mind the trade-off
    between guaranteed delivery of logs and the potential for breaking your Docker
    deployment. UDP-based solutions or other nonblocking options are recommended.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一些插件设计用于将日志发送到远程端点，并保留本地的 JSON 复制以供 `docker container logs` 命令使用，但您需要确定要使用的插件是否支持此功能。对于每个驱动程序来说，要注意很多潜在问题，但您应该牢记日志的可靠传递与可能破坏
    Docker 部署之间的权衡。建议使用基于 UDP 的解决方案或其他非阻塞选项。
- en: Traditionally, most Linux systems have some kind of syslog receiver, whether
    it be `syslog`, `rsyslog`, or any of the many other options. This protocol in
    its various forms has been around for a long time and is fairly well supported
    by most deployments. When migrating to Docker from a traditional Linux or Unix
    environment, many companies already have syslog infrastructure in place, which
    means this is often the easiest migration path as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，大多数 Linux 系统都有某种形式的 syslog 接收器，无论是 `syslog`、`rsyslog` 还是其他许多选项。这种协议以其各种形式已存在很长时间，并且在大多数部署中得到了相当好的支持。从传统的
    Linux 或 Unix 环境迁移到 Docker 时，许多公司已经拥有 syslog 基础设施，这通常也是最简单的迁移路径。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Many newer Linux distributions are based on the `systemd` init system and therefore
    use `journald` for logging by default, which is different from `syslog`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 许多较新的 Linux 发行版基于 `systemd` 初始化系统，因此默认使用 `journald` 进行日志记录，这与 `syslog` 不同。
- en: While syslog is a traditional solution, it has its problems. The Docker syslog
    driver supports TLS, TCP, and UDP connection options, which sounds great, but
    you should be cautious about streaming logs from Docker to a remote log server
    over TCP or TLS. The problem with this is that they are both run on top of connection-oriented
    TCP sessions, and Docker tries to connect to the remote logging server at the
    time of container startup. If it fails to make the connection, it will block trying
    to start the container. If you are running this as your default logging mechanism,
    this can strike at any time on any deployment.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 syslog 是一种传统解决方案，但它也存在问题。Docker syslog 驱动支持 TLS、TCP 和 UDP 连接选项，听起来很不错，但您应该对通过
    TCP 或 TLS 从 Docker 流式传输日志到远程日志服务器持谨慎态度。问题在于它们都在基于连接的 TCP 会话之上运行，并且 Docker 尝试在容器启动时连接到远程日志服务器。如果连接失败，它将阻塞容器启动。如果您将其作为默认的日志记录机制运行，这可能随时影响到任何部署。
- en: This is not a particularly usable state for production systems, and thus it
    is recommended that you use the UDP option for syslog logging if you intend to
    use the `syslog` driver. This does mean your logs are not encrypted and do not
    have guaranteed delivery. There are various philosophies around logging, and you’ll
    need to balance your need for logs against the reliability of your system. We
    tend to recommend erring on the side of reliability, but if you run in a secure
    audit environment, you may have different priorities.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这对生产系统来说并不是特别可用的状态，因此建议如果打算使用 `syslog` 驱动，则使用 UDP 选项进行 syslog 日志记录。这意味着您的日志不会加密，并且不能保证传递。关于日志记录有各种哲学观点，您需要在日志需求与系统可靠性之间取得平衡。我们倾向于建议在可靠性方面出错，但如果您在安全审计环境中运行，则可能有不同的优先级。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can log directly to a remote syslog-compatible server from a single container
    by setting the log option `syslog-address` similar to this: `--log-opt syslog-address=udp://192.168.42.42:123`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过设置类似于 `--log-opt syslog-address=udp://192.168.42.42:123` 的日志选项 `syslog-address`，直接将日志记录到单个容器的远程
    syslog 兼容服务器。
- en: 'One final caveat to be aware of regarding most of the logging plug-ins: they
    are blocking by default, which means that logging back-pressure can cause issues
    with your application. You can change this behavior by setting `--log-opt mode=non-blocking`
    and then setting the maximum buffer size for logs to something like `--log-opt
    max-buffer-size=4m`. Once these are set, the application will no longer block
    when that buffer fills up. Instead, the oldest loglines in memory will be dropped.
    Again, reliability needs to be weighed here against your business’s need to receive
    all the logs.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关于大多数日志插件需要注意的最后一个警告是：它们默认是阻塞的，这意味着日志回压可能会影响您的应用程序。您可以通过设置`--log-opt mode=non-blocking`来更改此行为，然后设置日志的最大缓冲区大小为`--log-opt
    max-buffer-size=4m`之类的值。一旦设置了这些参数，当缓冲区填满时，应用程序将不再阻塞。相反，内存中最旧的日志行将被丢弃。同样，可靠性需要与您的业务需要接收所有日志进行权衡。
- en: Warning
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Some third-party libraries and programs write to the filesystem for various
    (and sometimes unexpected) reasons. If you are trying to design clean containers
    that do not write directly into the container filesystem, you should consider
    utilizing the `--read-only` and `--mount type=tmpfs` options to `docker container
    run` that we discussed in [Chapter 4](ch04.html#docker_images). Writing logs *inside*
    the container is not recommended. It makes them hard to get to, prevents them
    from being preserved beyond the container life span, and can wreak havoc with
    the Docker filesystem backend.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一些第三方库和程序会因各种（有时是意外的）原因写入文件系统。如果您试图设计不直接向容器文件系统写入的清洁容器，则应考虑使用我们在[第4章](ch04.html#docker_images)讨论的`--read-only`和`--mount
    type=tmpfs`选项来运行`docker container`。不推荐在容器内部写入日志。这使得日志难以获取，阻止它们在容器生命周期之外被保留，并且可能会对Docker文件系统后端造成严重影响。
- en: Monitoring Docker
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控Docker
- en: Among the most important requirements for production systems is that they are
    observable and measurable. A production system where you are blind to how it’s
    behaving won’t serve you well. In modern operations environments, we want to monitor
    everything meaningful and report as many useful statistics as we can. Docker supports
    container health checks and some basic reporting capabilities via `docker container
    stats` and `docker system events`. We’ll show you those and then look at a community
    offering from Google that does some nice graphing output, and then we’ll take
    a look at a—currently experimental—feature of Docker that exports container metrics
    to the Prometheus monitoring system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产系统来说，最重要的要求之一是它们必须是可观察和可测量的。如果你对系统行为一无所知，那么这样的生产系统将无法为你服务。在现代运维环境中，我们希望监控所有有意义的事物，并尽可能报告尽可能多的有用统计信息。Docker支持容器健康检查，并通过`docker
    container stats`和`docker system events`提供一些基本的报告功能。我们将会展示这些功能，然后看看来自Google的社区提供的一些漂亮的图形输出，然后我们将查看Docker的一个当前实验性特性，该特性将容器指标导出到Prometheus监控系统中。
- en: Container Statistics
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器统计信息
- en: Let’s start with the CLI tools that ship with Docker itself. The `docker` CLI
    has an endpoint for viewing important statistics of running containers. The command-line
    tool can stream from this endpoint and every few seconds report back on one or
    more listed containers, giving basic statistics information about what’s happening.
    `docker container stats`, like the Linux `top` command, takes over the current
    terminal and updates the same lines on the screen with the current information.
    It’s hard to show that in print so we’ll just give an example, but this updates
    every few seconds by default.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Docker自带的CLI工具开始。`docker` CLI具有一个端点，用于查看运行容器的重要统计信息。这个命令行工具可以从该端点流式传输，并每隔几秒报告一次一个或多个列出的容器的基本统计信息，显示正在发生的事情。`docker
    container stats`类似于Linux的`top`命令，接管当前终端并更新屏幕上的相同行以显示当前信息。这很难在打印中显示，所以我们只给出一个例子，但默认情况下每隔几秒更新一次。
- en: Command-line statistics
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行统计信息
- en: 'Start an active container:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个活动容器：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then run the `stats` command to look at the new container:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行`stats`命令查看新容器：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can type Ctrl-C to exit the `stats` stream at any time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时输入Ctrl-C退出`stats`流。
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can use the `--no-stream` option to get a single-point-in-time set of statistics
    that will not update and will return you back to the command line after the command
    completes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--no-stream`选项获取一个单点时间的统计信息集，该选项不会更新，并在命令完成后将您返回到命令行。
- en: 'Let’s break that rather dense output down into some manageable chunks. We have
    the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个相当密集的输出分解成几个易于处理的部分。我们有以下内容：
- en: The container ID (but not the name).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的 ID（但不包括名称）。
- en: The amount of CPU it’s currently consuming. One hundred percent is equivalent
    to one whole CPU core.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它当前消耗的 CPU 量。百分之百相当于一个完整的 CPU 核心。
- en: The amount of memory it has in use, followed by the maximum amount it’s allowed
    to use.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它正在使用的内存量，以及它被允许使用的最大量。
- en: Network and block I/O statistics.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络和块 I/O 统计。
- en: The number of active processes inside the container.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器内部活跃进程的数量。
- en: Some of these will be more useful than others for debugging, so let’s take a
    look at what you can do with them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些对于调试来说会比其他的更有用，所以让我们看看你可以用它们做些什么。
- en: One of the more helpful pieces of output here is the percentage of memory used
    versus the limit that was set for the container. One common problem with running
    production containers is that overly aggressive memory limits can cause the Linux
    kernel’s OOM killer to stop the container over and over again. The `stats` command
    can help you identify and troubleshoot these types of issues.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里更有帮助的一个输出部分是内存使用百分比与为容器设置的限制之间的比例。运行生产容器时的一个常见问题是过于激进的内存限制可能导致 Linux 内核的 OOM
    杀手一遍又一遍地停止容器。`stats` 命令可以帮助你识别和解决这类问题。
- en: Concerning I/O statistics, if you run all of your applications in containers,
    then this summary can make it very clear where your I/O is going from the system.
    Before containers, this was much harder to figure out!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 I/O 统计，如果你将所有应用程序都运行在容器中，那么这个摘要可以非常清楚地显示系统的 I/O 流向何处。在容器出现之前，这个任务要困难得多！
- en: The number of active processes inside the container helps debug as well. If
    you have an application that is spawning children without reaping them, this can
    expose it pretty quickly.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 容器内部活跃进程的数量也有助于调试。如果你有一个应用程序在生成子进程但没有清理它们，这很快就能暴露出来。
- en: One great feature of `docker container stats` is that it can show not just one
    container but all of them in a single summary. That can be pretty revealing, even
    on boxes where you think you know what they are doing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container stats` 的一个很棒的特性是它可以在单个摘要中展示所有容器，而不仅仅是一个。即使在你认为你了解它们在做什么的主机上，这可能会非常具有启发性。'
- en: That is all useful and easy to digest because it’s human formatted and available
    on the command line. But there is an additional endpoint on the Docker API that
    provides a *lot* more information than is shown in the client. We’ve steered away
    from directly utilizing the API in this book so far, but in this case, the data
    provided by the API is so much richer than the client that we’ll go ahead and
    use `curl` to make an API request and see what our container is doing. It’s nowhere
    near as nice to read, but there is a lot more detail.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都非常有用且易于理解，因为它是以人类可读的方式格式化并在命令行上可用。但是 Docker API 上还有一个额外的端点提供的信息比客户端显示的要多得多。到目前为止，我们在本书中避免直接使用
    API，但在这种情况下，API 提供的数据比客户端更丰富，所以我们将使用 `curl` 发送一个 API 请求来看看我们的容器在做什么。它不像阅读起来那么美好，但是提供了更多的详细信息。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that basically everything that the `docker` client can do can be done
    directly through the Docker APIs. This means that you can programmatically do
    very similar things in your applications if there is a need.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`docker` 客户端可以做的基本上所有事情都可以直接通过 Docker API 完成。这意味着如果有需要，你可以在你的应用程序中以编程方式做非常类似的事情。
- en: The example in [“stats API endpoint”](#stats_api_endpoint) is a good intro to
    calling the API directly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[“统计 API 端点”](#stats_api_endpoint) 中的例子是直接调用 API 的一个很好的介绍。'
- en: stats API endpoint
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统计 API 端点
- en: The `/stats/` endpoint that we’ll hit on the API will continue to stream statistics
    to us as long as we keep the connection open. Since as humans we can’t easily
    parse the JSON, we’ll just ask for one line and then use the tool `jq` to “pretty-print”
    it. For this command to work, you’ll need to have `jq` installed (version 2.6
    or later). If you don’t and you still want to see the JSON output, you can skip
    the pipe to `jq`, but you’ll get plain, ugly JSON back. If you already have a
    favorite JSON pretty printer, feel free to use that instead.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 API 上命中的 `/stats/` 端点会继续向我们流式传输统计信息，只要我们保持连接打开。由于作为人类我们不容易解析 JSON，我们只会请求一行，然后使用工具
    `jq` 来“漂亮打印”它。为了使此命令正常工作，你需要安装 `jq`（版本 2.6 或更高）。如果你没有安装 `jq`，但仍然想看到 JSON 输出，可以跳过到
    `jq` 的管道，但会得到简单且难看的 JSON。如果你已经有一个喜欢的 JSON 美化打印程序，随意使用那个代替。
- en: Most Docker daemons will be installed with the API available only on the Unix
    domain socket and not published on TCP. So we’ll use `curl` from the Docker server
    host itself to call the API. If you plan to monitor this endpoint in production,
    you would need to expose the Docker API on a TCP port. This is not something that
    we recommend, but the [Docker documentation](https://dockr.ly/2Lzuox2) will walk
    you through this.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Docker守护程序只会在Unix域套接字上提供API，而不会在TCP上发布。因此，我们将从Docker服务器主机本身使用`curl`调用API。如果您计划在生产环境中监视此端点，您需要在TCP端口上公开Docker
    API。这不是我们推荐的做法，但[Docker文档](https://dockr.ly/2Lzuox2)会指导您完成这一步骤。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not on the Docker server or using Docker Desktop locally, you may
    need to inspect the contents of the `DOCKER_HOST` environment variable, using
    something like `echo $DOCKER_HOST`, to discover the hostname or IP address of
    the Docker server that you are using.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不在Docker服务器上或者在本地使用Docker Desktop，您可能需要检查`DOCKER_HOST`环境变量的内容，使用类似`echo $DOCKER_HOST`的命令，以发现您正在使用的Docker服务器的主机名或IP地址。
- en: 'First, start up a container that you can read statistics from:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动一个容器，您可以从中读取统计信息：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that the container is running, you can get an ongoing stream of statistics
    about the container in JSON format by running something like `curl` with your
    container’s name or hash.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在容器正在运行，您可以通过运行类似`curl`加上您容器的名称或哈希来获取有关容器的JSON格式的持续统计信息流。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the following examples, we are running `curl` against the Docker socket,
    but you could just as easily run it against the Docker port if it is available.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们正在针对Docker套接字运行`curl`，但如果可用的话，您也可以轻松地针对Docker端口运行它。
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This JSON stream of statistics will not stop on its own. So for now, we can
    use the Ctrl-C key combination to stop it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON统计流不会自行停止。因此，现在我们可以使用Ctrl-C键组合来停止它。
- en: 'To get a single group of statistics, we can run something similar to this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一组统计信息，我们可以运行类似于这样的命令：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And finally, if we have [jq](https://stedolan.github.io/jq) or another tool
    capable of pretty-printing JSON, we can make this output human readable, as shown
    here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们有[jq](https://stedolan.github.io/jq)或另一个能够漂亮打印JSON的工具，我们可以使这个输出变得人类可读，如下所示：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There is *a lot* of information in there. We’ve cut it down to prevent wasting
    any more trees or electrons than necessary, but even so, there is a lot to digest.
    The main idea is to let you see how much data is available from the API about
    each container. We won’t spend much time going into the details, but you can get
    quite detailed memory usage information, as well as block I/O and CPU usage information.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 其中包含*大量*的信息。我们已经削减了内容，以防止浪费任何不必要的树木或电子，但即便如此，仍有很多需要消化的内容。主要思想是让您看到API关于每个容器的可用数据量。我们不会花太多时间详细介绍，但您可以获得相当详细的内存使用信息，以及块I/O和CPU使用信息。
- en: If you are doing your own monitoring, this is a great endpoint to hit as well.
    A drawback, however, is that it’s one endpoint per container, so you can’t get
    the statistics about all containers from a single call.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在进行自己的监控，这也是一个很好的端点。然而，缺点是每个容器只有一个端点，因此您无法通过一次调用获取有关所有容器的统计信息。
- en: Container Health Checks
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器健康检查
- en: As with any other application, when you launch a container it is possible that
    it will start and run but never actually enter a healthy state where it could
    receive traffic. Production systems also fail, and your application may become
    unhealthy at some point during its life, so you need to be able to deal with that.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他应用程序一样，当您启动一个容器时，它有可能会启动并运行，但实际上永远不会进入一个健康状态，从而无法接收流量。生产系统也会出现故障，您的应用程序在其生命周期中的某个时刻可能会变得不健康，因此您需要能够处理这种情况。
- en: Many production environments have standardized ways to health-check applications.
    Unfortunately, there’s no clear standard for how to do that across organizations,
    and it’s unlikely that many companies do it in the same way. For this reason,
    monitoring systems have been built to handle that complexity so that they can
    work in a lot of different production systems. It’s a clear place where a standard
    would be a big win.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 许多生产环境都有标准化的方法来检查应用程序的健康状况。不幸的是，跨组织之间并没有明确的标准来执行这项任务，许多公司也不太可能以相同的方式执行。因此，监控系统已经被构建来处理这种复杂性，以便它们可以在许多不同的生产系统中工作。这是一个明显的地方，标准化将是一个巨大的胜利。
- en: To help remove this complexity and standardize on a universal interface, Docker
    has added a health-check mechanism. Following the shipping container metaphor,
    Linux containers should really look the same to the outside world no matter what
    is inside the container, so Docker’s health-check mechanism not only standardizes
    health checking for containers but also maintains the isolation between what is
    inside the container and what it looks like on the outside. This means that containers
    from Docker Hub or other shared repositories can implement a standardized health-checking
    mechanism, and it will work in any other Docker environment designed to run production
    containers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助简化这个复杂性并标准化一个通用接口，Docker添加了一个健康检查机制。遵循航运集装箱的隐喻，Linux容器无论内部是什么，对外界看起来应该都是一样的，所以Docker的健康检查机制不仅标准化了容器的健康检查，还保持了容器内外部分离。这意味着来自Docker
    Hub或其他共享存储库的容器可以实现一个标准化的健康检查机制，在任何设计用于运行生产容器的Docker环境中都可以工作。
- en: Health checks are a build-time configuration item and are created with a `HEALTHCHECK`
    definition in the *Dockerfile*. This directive tells the Docker daemon what command
    it can run inside the container to ensure the container is in a healthy state.
    As long as the command exits with a code of zero (0), Docker will consider the
    container to be healthy. Any other exit code will indicate to Docker that the
    container is not in a healthy state, at which point appropriate action can be
    taken by a scheduler or monitoring system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是构建时的配置项，可以在*Dockerfile*中使用`HEALTHCHECK`定义创建。这个指令告诉Docker守护程序可以在容器内运行哪个命令来确保容器处于健康状态。只要命令以零（0）的代码退出，Docker就会认为容器是健康的。任何其他退出代码将向Docker表明容器处于非健康状态，此时调度程序或监控系统可以采取适当的措施。
- en: 'We will be using the following project to explore Docker Compose in a few chapters.
    But, for the moment, it includes a useful example of Docker health checks. Go
    ahead and pull down a copy of the code, and then navigate into the *rocketchat-hubot-demo/mongodb/docker/*
    directory:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几章中使用以下项目来探索Docker Compose。但是目前，它包含了一个有关Docker健康检查的实用示例。继续下载代码的副本，然后进入*rocketchat-hubot-demo/mongodb/docker/*目录：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this directory, you will see a *Dockerfile* and a script called `docker-healthcheck`.
    If you view the *Dockerfile*, this is all that you will see:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中，你会看到一个*Dockerfile*和一个名为`docker-healthcheck`的脚本。如果查看*Dockerfile*，你会看到以下内容：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is very short because we are basing this on the [upstream Mongo image](https://oreil.ly/Is1yt),^([2](ch06.html#idm46803143337184))
    and our image inherits a lot of things from that, including the entry point, default
    command, and port to expose.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常简短，因为我们是基于[上游Mongo镜像](https://oreil.ly/Is1yt)^([2](ch06.html#idm46803143337184))，而我们的镜像继承了许多东西，包括入口点、默认命令和要公开的端口。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Bitnami significantly refactored their container repositories in early 2023,
    so this link points to a slightly newer version of the *Dockerfile* that targets
    MongoDB 5.0\. We are using MongoDB 4.4 in this example, but the link should still
    get the point across.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Bitnami在2023年初显著重构了他们的容器存储库，因此这个链接指向一个稍新的*Dockerfile*版本，针对的是MongoDB 5.0。在这个示例中，我们使用的是MongoDB
    4.4，但这个链接仍然能够传达出重要的信息。
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Be aware that Docker will forward traffic to a container’s ports even when the
    container and underlying processes are still spinning up.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使容器和底层进程仍在启动过程中，Docker也会将流量转发到容器的端口。
- en: So, in our *Dockerfile* we are only adding a single script that can health-check
    our container, and defining a health-check command that runs that script.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的*Dockerfile*中，我们只添加了一个能够健康检查我们容器的脚本，并定义了一个运行该脚本的健康检查命令。
- en: 'You can build the container like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样构建容器：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And then run the container and look at the `docker container ls` output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行容器并查看`docker container ls`的输出：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should notice that the `STATUS` column now has a `health` section in parentheses.
    Initially, this will display `health: starting` as the container is starting up.
    You can change the amount of time that Docker waits for the container to initialize
    using the `--health-start-period` argument to `docker container run`. The status
    will change to `healthy` once the container is up and the health check is successful.
    It might take this container 40+ seconds to transition into a healthy state:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '您应该注意到`STATUS`列现在在括号中有一个`health`部分。最初，这将显示`health: starting`，因为容器正在启动。您可以使用`docker
    container run`的`--health-start-period`参数更改 Docker 等待容器初始化的时间。一旦容器启动并且健康检查成功，状态将变为`healthy`。这个容器可能需要40秒以上才能转换为健康状态：'
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can query this status directly, using the `docker container inspect` command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接查询此状态，使用`docker container inspect`命令：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If your container begins failing its health check, the status will change to
    `unhealthy`, and you can then determine how to handle the situation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的容器开始失败其健康检查，状态将变为`unhealthy`，然后您可以确定如何处理这种情况：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: At this point, you can stop the container by simply running `docker container
    stop mongo-hc`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可以通过简单运行`docker container stop mongo-hc`来停止容器。
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As with most systems, you can configure a lot of details about your health checks,
    including how often Docker checks the health (`--health-interval`), how many failures
    are required to cause the container to be marked unhealthy (`--health-retries`),
    and more. You can even disable the health check completely (`--no-healthcheck`)
    if needed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数系统一样，您可以配置关于健康检查的许多细节，包括 Docker 检查健康的频率（`--health-interval`）、需要多少次失败才会导致容器标记为不健康（`--health-retries`）等等。如果需要，甚至可以完全禁用健康检查（`--no-healthcheck`）。
- en: This feature is very useful, and you should strongly consider using it in all
    of your containers. This will help you improve both the reliability of your environment
    and the visibility you have into how things are running in it. It is also supported
    by many production schedulers and monitoring systems, so it should be easy to
    implement.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能非常有用，您应该强烈考虑在所有容器中使用它。这将帮助您提高环境的可靠性和您对其运行情况的可见性。它也受到许多生产调度程序和监控系统的支持，因此应该很容易实现。
- en: Warning
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As always, the usefulness of a health check is largely determined by how well
    written it is and how accurately it determines the state of the service.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，健康检查的实用性很大程度上取决于其编写质量以及准确地确定服务状态的能力。
- en: docker system events
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker 系统事件
- en: The `dockerd` daemon internally generates an events stream around the container
    lifecycle. This is how various parts of the system find out what is going on in
    other parts. You can also tap into this stream to see what lifecycle events are
    happening for containers on your Docker server. This, as you probably expect by
    now, is implemented in the `docker` CLI tool as another command-line argument.
    When you run this command, it will block and continually stream messages to you.
    Behind the scenes, this is a long-lived HTTP request to the Docker API that returns
    messages in JSON blobs as they occur. The `docker` CLI tool decodes them and prints
    some data to the terminal.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`dockerd`守护程序在容器生命周期周围内部生成一个事件流。这是系统各部分了解其他部分正在发生什么的方式。您还可以利用这个流来查看 Docker
    服务器上容器的生命周期事件。正如您现在可能期望的那样，这是在`docker`CLI工具中作为另一个命令行参数实现的。运行此命令时，它将阻塞并持续向您传送消息。在幕后，这是对
    Docker API 的一个长时间的 HTTP 请求，以 JSON 块的形式返回消息。`docker`CLI工具解码它们并将一些数据打印到终端上。'
- en: This events stream is useful in monitoring scenarios or triggering additional
    actions, like wanting to be alerted when a job completes. For debugging purposes,
    it allows you to see when a container died even if Docker restarts it later. Down
    the road, this is a place where you might also find yourself directly implementing
    some tooling against the API.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件流在监控场景或触发额外操作方面非常有用，比如想在作业完成时收到警报。出于调试目的，它允许您查看容器何时死亡，即使 Docker 后来重新启动它。在未来，这可能是您直接针对
    API 实现一些工具的地方。
- en: 'In one terminal, go ahead and run the `events` command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个终端中，继续运行`events`命令：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You will notice that nothing happens.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到什么都没有发生。
- en: 'In another terminal, go ahead and launch the following short-lived container:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，继续启动以下短暂存在的容器：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the original terminal that is running the `events` command, you should now
    see something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`events`命令的原始终端中，您现在应该看到类似于这样的内容：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can type Ctrl-C to exit the events stream at any time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时输入Ctrl-C来退出事件流。
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As with the Docker statistics, you can access the Docker system events via `curl`
    using a command like `curl --no-buffer -XGET --unix-socket /var/run/docker.sock
    [*http://docker/events*](http://docker/events)`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker统计信息一样，你可以使用`curl`通过类似`curl --no-buffer -XGET --unix-socket /var/run/docker.sock
    [*http://docker/events*](http://docker/events)`的命令访问Docker系统事件。
- en: In this example, we ran a short-lived container that simply counted 5 seconds
    and then exited.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们运行了一个短暂存在的容器，只是简单地计数了5秒，然后退出。
- en: The `container create`, `container attach`, `network connect`, and `container
    start` events are all the steps required to get the container into a running state.
    When the container exits, the events stream logs a `container die`, `network disconnect`,
    and `container destroy` message. Each one of these marks a step in completely
    tearing down the container. Docker also helpfully tells us the ID of the image
    that the container is running on. This can be useful for tying deployments to
    events, for example, because a deployment usually involves a new image.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`container create`、`container attach`、`network connect`和`container start`事件是将容器置于运行状态所需的所有步骤。当容器退出时，事件流将记录`container
    die`、`network disconnect`和`container destroy`消息。每一个步骤都标志着完全拆除容器的一部分。Docker还友好地告诉我们容器正在运行的镜像的ID。例如，这对于将部署与事件相关联非常有用，因为部署通常涉及新的镜像。'
- en: If you have a server where containers are not staying up, the `docker system
    events` stream is pretty helpful in seeing what’s going on and when. But if you’re
    not watching it at the time, Docker very helpfully caches some of the events,
    and you can still get at them for some time afterward. You can ask it to display
    events after a time with the `--since` option, or before with the `--until` option.
    You can also use both to limit the window to a narrow scope of time when an issue
    you are investigating may have occurred. Both options take ISO time formats like
    those in the previous example (e.g., 2018-02-18T14:03:31-08:00).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务器上的容器无法持续运行，那么`docker system events`流对于查看发生了什么以及何时发生的情况非常有帮助。但是如果你当时没有在观看它，Docker会非常友好地缓存一些事件，并且你仍然可以在一段时间后获取它们。你可以使用`--since`选项来显示一段时间后的事件，或者使用`--until`选项来显示一段时间前的事件。你也可以同时使用两者来限制窗口，以便在调查的问题可能发生的狭窄时间范围内使用。这两个选项都接受ISO时间格式，就像前面的例子中的格式一样（例如，2018-02-18T14:03:31-08:00）。
- en: Tip
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'There are a few specific event types that you should go out of your way to
    monitor:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特定的事件类型，你应该特别注意监控：
- en: '`container oom`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`container oom`'
- en: Appears when a container runs out of memory
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器内存耗尽时出现
- en: '`container exec_create`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`container exec_create`'
- en: '`container exec_start`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`container exec_start`'
- en: '`container exec_die`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`container exec_die`'
- en: Appear when someone has used `docker container exec` to enter a container, which
    could signal a security incident
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人使用`docker container exec`进入容器时出现，这可能表示安全事件
- en: cAdvisor
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cAdvisor
- en: '`docker container stats` and `docker system events` are useful but don’t get
    us graphs to look at yet. And graphs are pretty helpful when we’re trying to see
    trends. Of course, other people have filled some of this gap. When you begin to
    explore the options for monitoring Docker, you will find that many of the major
    monitoring tools now provide some functionality to help you improve the visibility
    into your containers’ performance and ongoing state.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container stats`和`docker system events`很有用，但是它们目前还不能为我们生成图表。而当我们试图查看趋势时，图表非常有帮助。当然，其他人已经填补了部分这方面的空白。当你开始探索监控Docker的选项时，你会发现许多主要的监控工具现在都提供了一些功能，帮助你提高对容器性能和持续状态的可见性。'
- en: In addition to the commercial tooling provided by companies like Datadog, GroundWork,
    and New Relic, there are plenty of options for free, open source tools like Prometheus
    or even Nagios. We’ll talk about Prometheus in [“Prometheus Monitoring”](#prom_monitoring).
    Soon after Docker was introduced, Google released its internal container monitoring
    tool as a well-maintained open source project on GitHub, called [cAdvisor](https://github.com/google/cadvisor).
    Although cAdvisor can be run outside of Docker, by now you’re probably not surprised
    to hear that the easiest implementation of cAdvisor is to simply run it as a Linux
    container.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Datadog、GroundWork和New Relic等公司提供的商业工具外，还有许多免费的开源工具可供选择，例如Prometheus或者甚至是Nagios。我们将在[“Prometheus监控”](#prom_monitoring)中讨论Prometheus。在Docker推出后不久，Google将其内部的容器监控工具作为一个维护良好的开源项目发布在GitHub上，称为[cAdvisor](https://github.com/google/cadvisor)。虽然cAdvisor可以在Docker之外运行，但现在你可能不会感到意外，cAdvisor最简单的实现方式是将其作为Linux容器简单运行。
- en: To install cAdvisor on most Linux systems, all you need to do is run this code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要在大多数 Linux 系统上安装 cAdvisor，您只需运行此代码。
- en: Warning
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This command is intended to be run directly on a Linux Docker server. It will
    not work properly when run from a Windows or macOS system.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令旨在直接在 Linux Docker 服务器上运行。当从 Windows 或 macOS 系统运行时，其功能将无法正常工作。
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'On Red Hat Enterprise Linux (RHEL)-based systems, you may need to add the following
    line to the `docker container run` command shown here: `--volume=/cgroup:/cgroup
    \`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Red Hat Enterprise Linux (RHEL) 的系统上，您可能需要在这里显示的`docker container run`命令中添加以下行：`--volume=/cgroup:/cgroup
    \`。
- en: Once you have done this, you will be able to navigate to your Docker host on
    port 8080 to see the cAdvisor web interface (e.g., *http://172.17.42.10:8080/*)
    and the various detailed charts it has for the host and individual containers
    (see [Figure 6-1](#figure6-1)).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，您就可以访问端口为 8080 的 Docker 主机，查看 cAdvisor 的 Web 界面（例如，*http://172.17.42.10:8080/*）以及主机和各个容器的各种详细图表（参见[图
    6-1](#figure6-1)）。
- en: '![cAdvisor CPU Graphs](assets/dur3_0601.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![cAdvisor CPU 图表](assets/dur3_0601.png)'
- en: Figure 6-1\. cAdvisor CPU graphs (example)
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. cAdvisor CPU 图表（示例）
- en: 'cAdvisor provides a REST API endpoint, which can easily be queried for detailed
    information by your monitoring systems:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 提供了一个 REST API 端点，您可以通过监控系统轻松查询详细信息：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can find details about the cAdvisor API in [the official documentation](https://github.com/google/cadvisor/blob/master/docs/api_v2.md).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[官方文档](https://github.com/google/cadvisor/blob/master/docs/api_v2.md)中找到有关
    cAdvisor API 的详细信息。
- en: The amount of detail provided by cAdvisor should be sufficient for many of your
    graphing and monitoring needs.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 提供的详细信息应该足以满足您的大部分图形和监控需求。
- en: Prometheus Monitoring
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prometheus 监控
- en: The [Prometheus](https://prometheus.io) monitoring system has become a popular
    solution for monitoring distributed systems. It works largely on a pull model,
    where it reaches out and gathers statistics from endpoints on a timed basis. Docker
    has an endpoint that was built for Prometheus and makes it easy to integrate your
    container stats into a Prometheus monitoring system. At the time of this writing,
    the endpoint is currently experimental and not enabled in the `dockerd` server
    by default. Our brief experience with it shows that it seems to work well, and
    it’s a pretty slick solution, as we’ll show you. We should point out that this
    solution is for monitoring the `dockerd` server, in contrast to the other solutions,
    which exposed information about the containers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[Prometheus](https://prometheus.io) 监控系统已经成为监控分布式系统的流行解决方案。它主要基于拉取模型，定期从端点获取统计信息。Docker
    提供了一个为 Prometheus 构建的端点，可以轻松地将容器统计信息集成到 Prometheus 监控系统中。在撰写本文时，该端点目前处于试验阶段，并且未在`dockerd`服务器中默认启用。我们简要体验了一下，看起来效果不错，是一个相当不错的解决方案，我们会为您展示。需要指出的是，这个解决方案是用于监控`dockerd`服务器，与其他暴露容器信息的解决方案有所不同。'
- en: To export metrics to Prometheus, we need to reconfigure the `dockerd` server
    to enable the experimental features and to expose the metrics listener on a port
    of our choice. This is nice because we don’t have to expose the whole Docker API
    on a TCP listener to get metrics out of the system—a security win at the expense
    of a little more configuration. To do that, we can either provide the `--experimental`
    and `--metrics-addr=` options on the command line, or we can put them into the
    *daemon.json* file that the daemon uses to configure itself. Because many current
    distributions run `systemd`, and changing configurations there is highly dependent
    on your installation, we’ll use the *daemon.json* option since it’s more portable.
    We’ll demonstrate this on Ubuntu Linux 22.04 LTS. On this distribution, the file
    is usually not present to begin with. So let’s put one there using your favorite
    editor.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要将指标导出到 Prometheus，我们需要重新配置`dockerd`服务器以启用实验功能，并将指标监听器暴露在我们选择的端口上。这很好，因为我们无需在
    TCP 监听器上暴露整个 Docker API 来获取系统的指标，这在安全性上是一种胜利，虽然需要稍微多一点的配置。为此，我们可以在命令行上提供`--experimental`和`--metrics-addr=`选项，或者我们可以将它们放入
    *daemon.json* 文件中，该文件用于配置守护程序自身。由于许多当前的发行版运行`systemd`，并且在那里更改配置高度依赖于您的安装方式，我们将使用
    *daemon.json* 选项，因为它更具可移植性。我们将在 Ubuntu Linux 22.04 LTS 上演示此操作。在这个发行版上，通常初始时该文件是不存在的。因此，让我们使用您喜欢的编辑器放置一个。
- en: Tip
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As previously mentioned, the *daemon.json* file for Docker Desktop can be edited
    in Preferences → Docker Engine from the UI. If you change this file, you will
    need to restart Docker Desktop or the `dockerd` daemon.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可以在 UI 的 Preferences → Docker Engine 中编辑 Docker Desktop 的 *daemon.json*
    文件。如果更改了此文件，则需要重新启动 Docker Desktop 或 `dockerd` 守护程序。
- en: 'Adjust or add the following lines to the *daemon.json* file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 调整或添加以下行到 *daemon.json* 文件中：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You should now have a file that contains only what you just pasted and nothing
    else.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一个只包含你刚刚粘贴的内容，没有别的内容的文件。
- en: Warning
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Any time you make a service available on the network, you need to consider what
    security risks you might introduce. We believe the benefit of making metrics available
    is worth the trade-off, but you should think through the repercussions in your
    scenario. For example, making metrics available on the public internet is probably
    not a good idea in almost all cases.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网络上提供服务时，你需要考虑可能引入的安全风险。我们认为公开指标的好处值得权衡，但你应该仔细考虑在你的场景中可能带来的后果。例如，在公共互联网上公开指标在几乎所有情况下可能都不是一个好主意。
- en: When we restart Docker, we’ll now have a listener on all addresses on port 9323\.
    That’s where Prometheus will connect to get the metrics. But first, we need to
    restart the `dockerd` server. Docker Desktop automatically takes care of the restart
    for you, but if you are on the Linux Docker server, then you can run something
    like `sudo systemctl restart docker` to restart the daemon. You should not get
    any errors returned from the restart. If you do, you likely have something set
    incorrectly in the *daemon.json* file.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新启动 Docker 时，我们现在将在端口 9323 上的所有地址上拥有一个监听器。这就是 Prometheus 将连接以获取指标的地方。但首先，我们需要重新启动
    `dockerd` 服务器。Docker Desktop 会自动为您处理重启，但如果您在 Linux Docker 服务器上，则可以运行类似 `sudo systemctl
    restart docker` 来重新启动守护程序。如果您在重启过程中没有收到任何错误返回，则说明您在 *daemon.json* 文件中可能设置了一些不正确的内容。
- en: 'Now you can test the metrics endpoint with `curl`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用 `curl` 测试指标端点：
- en: '[PRE54]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you run this locally, you should get very similar output. It might not be
    identical, and that’s OK as long as you get something that is not an error message.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本地运行此操作，则应该会得到非常相似的输出。它可能不完全相同，但只要您得到的不是错误消息，那就没问题。
- en: 'So now we have a place where Prometheus can get to our statistics. But we need
    to have Prometheus running somewhere, right? We can easily do that by spinning
    up a container. But first, we need to write a simple config. We’ll put it in */tmp/prometheus/prometheus.yaml*.
    You can use your favorite editor to put the following into the file:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个地方，Prometheus 可以获取我们的统计数据了。但我们需要在某个地方运行 Prometheus，对吧？我们可以轻松地通过启动一个容器来实现这一点。但首先，我们需要写一个简单的配置。我们将其放在
    */tmp/prometheus/prometheus.yaml* 中。你可以使用你喜欢的编辑器将以下内容放入文件中：
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For Docker Desktop, you can also use `host.docker.internal:9323` or `gateway.docker.internal:9323`
    in place of the `172.17.0.1:9323` shown here. Both of these hostnames will point
    to the container’s IP address.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Docker Desktop，你也可以使用 `host.docker.internal:9323` 或 `gateway.docker.internal:9323`
    来替换这里显示的 `172.17.0.1:9323`。这两个主机名将指向容器的 IP 地址。
- en: As noted in the file, you should use the IP address of your `docker0` bridge
    here, or the IP address of your `ens3` or `eth0` interface since `localhost` and
    `127.0.0.1` are not routable from the container. The address we used here is the
    usual default for `docker0`, so it’s probably the right one for you.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如文件中所述，在这里你应该使用你的 `docker0` 桥接口的 IP 地址，或者你的 `ens3` 或 `eth0` 接口的 IP 地址，因为 `localhost`
    和 `127.0.0.1` 从容器中不可路由。我们在这里使用的地址是 `docker0` 的通常默认地址，所以这可能是适合你的正确地址。
- en: 'Now that we’ve written that out, we need to start up the container using this
    config:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经写好了，我们需要使用这个配置启动容器：
- en: '[PRE56]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That will run the container and volume-mount the config file we made into the
    container so that it will find the settings it needs to monitor our Docker endpoint.
    If it starts up cleanly, you should now be able to open your browser and navigate
    to port 9090 on your host. There you will get a Prometheus window, something like
    [Figure 6-2](#figure6-2).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行容器并将我们制作的配置文件挂载到容器中，以便它能找到监视我们的 Docker 端点所需的设置。如果它干净地启动，您现在应该能够打开浏览器并导航到主机的端口
    9090。在那里，你将得到一个 Prometheus 窗口，类似于 [Figure 6-2](#figure6-2)。
- en: In the following figure, you’ll see that we’ve selected one of the metrics,
    the `engine_daemon_events_total`, and graphed it over a short period. You can
    easily query any of the other metrics in the drop-down. Further work and exploration
    with Prometheus would allow you to define alerts and alerting policies based on
    these metrics as well. And it is easy to monitor so much more than just the `dockerd`
    server. You can also expose metrics for Prometheus from your applications. If
    you’re intrigued and want to look at something more advanced, you might take a
    look at [dockprom](https://github.com/stefanprodan/dockprom), which leverages
    Grafana to make nice dashboards and also queries your container metrics like those
    in the Docker API `/stats` endpoint.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，你会看到我们选择了一个指标，`engine_daemon_events_total`，并在短时间内对其进行了图示。你可以轻松查询下拉菜单中的任何其他指标。进一步的工作和探索
    Prometheus 将允许你基于这些指标定义警报和警报策略。同样，监控的内容不仅仅是 `dockerd` 服务器。你还可以从你的应用程序中暴露 Prometheus
    指标。如果你感兴趣并想了解更高级的内容，可能会看看 [dockprom](https://github.com/stefanprodan/dockprom)，它利用
    Grafana 创建漂亮的仪表板，还能查询 Docker API `/stats` 端点中的容器指标。
- en: '![Prometheus web UI](assets/dur3_0602.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![Prometheus web UI](assets/dur3_0602.png)'
- en: Figure 6-2\. Prometheus event graph (example)
  id: totrans-307
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2. Prometheus 事件图（示例）
- en: Exploration
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索
- en: 'This should give you all the basics you need to start running containers. It’s
    probably worth downloading a container or two from the Docker Hub registry and
    exploring a bit on your own to get used to the commands we just learned. There
    are many other things you can do with Docker, including but not limited to the
    following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能为你提供开始运行容器所需的所有基础知识。你可能值得从 Docker Hub 注册中心下载一个或两个容器，并自己探索一下，以便习惯我们刚学到的命令。使用
    Docker，你可以做的事情还有很多，包括但不限于以下几点：
- en: Copying files in and out of the container with `docker container cp`
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `docker container cp` 在容器内外复制文件
- en: Saving an image to a tarball with `docker image save`
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `docker image save` 将镜像保存为 tarball
- en: Loading an image from a tarball with `docker image import`
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `docker image import` 从 tarball 加载镜像
- en: Docker has a huge feature set that you will likely grow into over time. Each
    new release adds more functionality as well. We’ll get into a lot more detail
    later on about many of the other commands and features, but keep in mind that
    Docker’s whole feature set is very large.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 拥有庞大的功能集，随着时间的推移，你会逐渐熟悉这些功能。每个新版本都会增加更多功能。我们将在后面详细介绍许多其他命令和功能，但请记住，Docker
    的全部功能集非常庞大。
- en: Wrap-Up
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the next chapter, we’ll dive into more technical details about how Docker
    works and how you can use this knowledge to debug your containerized applications.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 Docker 的更多技术细节，了解 Docker 是如何工作的，以及如何利用这些知识来调试你的容器化应用程序。
- en: '^([1](ch06.html#idm46803145473376-marker)) Full URL: [*https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file*](https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#idm46803145473376-marker)) 完整网址：[*https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file*](https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file)
- en: '^([2](ch06.html#idm46803143337184-marker)) Full URL: [*https://github.com/bitnami/containers/blob/f9fb3f8a6323fb768fd488c77d4f111b1330bd0e/bitnami/mongodb/5.0/debian-11/Dockerfile*](https://github.com/bitnami/containers/blob/f9fb3f8a6323fb768fd488c77d4f111b1330bd0e/bitnami/mongodb/5.0/debian-11/Dockerfile)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#idm46803143337184-marker)) 完整网址：[*https://github.com/bitnami/containers/blob/f9fb3f8a6323fb768fd488c77d4f111b1330bd0e/bitnami/mongodb/5.0/debian-11/Dockerfile*](https://github.com/bitnami/containers/blob/f9fb3f8a6323fb768fd488c77d4f111b1330bd0e/bitnami/mongodb/5.0/debian-11/Dockerfile)
