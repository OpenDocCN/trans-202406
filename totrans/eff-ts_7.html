<html><head></head><body><section data-pdf-bookmark="Chapter 7. Writing and Running Your Code" data-type="chapter" epub:type="chapter" class="praise"><div class="praise" id="ch-write-run">
<h1 class="calibre14"><span class="calibre">Chapter 7. </span>Writing and Running Your Code</h1>


<p class="author1">This chapter is a bit of a grab bag: it covers some issues that come up in writing code (not types) as well as issues you may run into when you run your code.</p>






<section data-pdf-bookmark="Item 53: Prefer ECMAScript Features to TypeScript Features" data-type="sect1" class="praise"><div class="praise" id="avoid-non-ecma">
<h1 class="calibre16">Item 53: Prefer ECMAScript Features to TypeScript Features</h1>

<p class="author1">The<a data-primary="ECMAScript" data-type="indexterm" id="ecma07" class="calibre9"/><a data-primary="code, writing and running" data-secondary="ECMAScript versus TypeScript features" data-type="indexterm" id="CWRecma07" class="calibre9"/><a data-primary="TypeScript" data-secondary="relationship to JavaScript" data-type="indexterm" id="idm45331646894024" class="calibre9"/><a data-primary="JavaScript" data-secondary="relationship to TypeScript" data-type="indexterm" id="idm45331646893064" class="calibre9"/> relationship between TypeScript and JavaScript has changed over time. When Microsoft first started work on TypeScript in 2010, the prevailing attitude around JavaScript was that it was a problematic language that needed to be fixed. It was common for frameworks and source-to-source compilers to add missing features like classes, decorators, and a module system to JavaScript. TypeScript was no different. Early versions included home-grown versions of classes, enums, and modules.</p>

<p class="author1">Over time TC39, the standards body that governs JavaScript, added many of these same features to the core JavaScript language. And the features they added were not compatible with the versions that existed in TypeScript. This left the TypeScript team in an awkward predicament: adopt the new features from the standard or break existing code?</p>

<p class="author1">TypeScript has largely chosen to do the latter and eventually articulated its current governing principle: TC39 defines the runtime while TypeScript innovates solely in the type space.</p>

<p class="author1">There are a few remaining features from before this decision. It’s important to recognize and understand these, because they don’t fit the pattern of the rest of the language. In general, I recommend avoiding them to keep the relationship between TypeScript and JavaScript as clear as possible.</p>








<section class="praise" data-pdf-bookmark="Enums" data-type="sect2"><div class="praise" id="idm45331646889256">
<h2 class="calibre31">Enums</h2>

<p class="author1">Many<a data-primary="enums (enumerations)" data-type="indexterm" id="idm45331646886936" class="calibre9"/> languages model types that can take on a small set of values using <em class="calibre3">enumerations</em> or <em class="calibre3">enums</em>. TypeScript adds them to JavaScript:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">enum</code> <code class="nx">Flavor</code> <code class="p">{</code>
  <code class="nx">VANILLA</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
  <code class="nx">CHOCOLATE</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
  <code class="nx">STRAWBERRY</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">flavor</code> <code class="o">=</code> <code class="nx">Flavor</code><code class="p">.</code><code class="nx">CHOCOLATE</code><code class="p">;</code>  <code class="c">// Type is Flavor</code>

<code class="nx">Flavor</code>  <code class="c">// Autocomplete shows: VANILLA, CHOCOLATE, STRAWBERRY</code>
<code class="nx">Flavor</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>  <code class="c">// Value is "VANILLA"</code></pre>

<p class="author1">The argument for enums is that they provide more safety and transparency than bare numbers. But enums in TypeScript have some quirks. There are actually several variants on enums that all have subtly different behaviors:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">A number-valued enum (like <code class="calibre18">Flavor</code>). Any number is assignable to this, so it’s not very safe. (It was designed this way to make bit flag structures possible.)</p>
</li>
<li class="calibre12">
<p class="author1">A string-valued enum. This does offer type safety, and also more transparent values at runtime. But it’s not structurally typed, unlike every other type in TypeScript (more on this momentarily).</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">const enum</code>. Unlike regular enums, const enums go away completely at runtime. If you changed to <code class="calibre18">const enum Flavor</code> in the previous example, the compiler would rewrite <code class="calibre18">Flavor.CHOCOLATE</code> as <code class="calibre18">0</code>. This also breaks our expectations around how the compiler behaves and still has the divergent behaviors between <code class="calibre18">string</code> and <code class="calibre18">number</code>-valued enums.</p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">const enum</code> with the <code class="calibre18">preserveConstEnums</code> flag set. This emits runtime code for <code class="calibre18">const enum</code>s, just like for a regular <code class="calibre18">enum</code>.</p>
</li>
</ul>

<p class="author1">That string-valued enums are nominally typed comes as a particular surprise, since every other type in TypeScript uses structural typing for assignability (see <a href="ch01.html#structural" class="calibre9">Item 4</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">enum</code> <code class="nx">Flavor</code> <code class="p">{</code>
  <code class="nx">VANILLA</code> <code class="o">=</code> <code class="s">'vanilla'</code><code class="p">,</code>
  <code class="nx">CHOCOLATE</code> <code class="o">=</code> <code class="s">'chocolate'</code><code class="p">,</code>
  <code class="nx">STRAWBERRY</code> <code class="o">=</code> <code class="s">'strawberry'</code><code class="p">,</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">flavor</code> <code class="o">=</code> <code class="nx">Flavor</code><code class="p">.</code><code class="nx">CHOCOLATE</code><code class="p">;</code>  <code class="c">// Type is Flavor</code>
    <code class="nx">flavor</code> <code class="o">=</code> <code class="s">'strawberry'</code><code class="p">;</code>
 <code class="c">// ~~~~~~ Type '"strawberry"' is not assignable to type 'Flavor'</code></pre>

<p class="author1">This has implications when you publish a library. Suppose you have a function that takes a <code class="calibre18">Flavor</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">scoop</code><code class="p">(</code><code class="nx">flavor</code>: <code class="nx">Flavor</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

<p class="author1">Because a <code class="calibre18">Flavor</code> at runtime is really just a string, it’s fine for your JavaScript users to call it with one:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="nx">scoop</code><code class="p">(</code><code class="s">'vanilla'</code><code class="p">);</code>  <code class="c">// OK in JavaScript</code></pre>

<p class="author1">but your TypeScript users will need to import the <code class="calibre18">enum</code> and use that instead:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">scoop</code><code class="p">(</code><code class="s">'vanilla'</code><code class="p">);</code>
   <code class="c">// ~~~~~~~~~ '"vanilla"' is not assignable to parameter of type 'Flavor'</code>

<code class="kd">import</code> <code class="p">{</code><code class="nx">Flavor</code><code class="p">}</code> <code class="nx">from</code> <code class="s">'ice-cream'</code><code class="p">;</code>
<code class="nx">scoop</code><code class="p">(</code><code class="nx">Flavor</code><code class="p">.</code><code class="nx">VANILLA</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">These divergent experiences for JavaScript and TypeScript users are a reason to avoid string-valued enums.</p>

<p class="author1">TypeScript offers an alternative to enums that is less common in other languages: a union of literal types.</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Flavor</code> <code class="o">=</code> <code class="s">'vanilla'</code> <code class="o">|</code> <code class="s">'chocolate'</code> <code class="o">|</code> <code class="s">'strawberry'</code><code class="p">;</code>

<code class="kd">let</code> <code class="nx">flavor</code>: <code class="nx">Flavor</code> <code class="o">=</code> <code class="s">'chocolate'</code><code class="p">;</code>  <code class="c">// OK</code>
    <code class="nx">flavor</code> <code class="o">=</code> <code class="s">'mint chip'</code><code class="p">;</code>
 <code class="c">// ~~~~~~ Type '"mint chip"' is not assignable to type 'Flavor'</code></pre>

<p class="author1">This offers as much safety as the enum and has the advantage of translating more directly to JavaScript. It also offers similarly strong autocomplete in your editor:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">scoop</code><code class="p">(</code><code class="nx">flavor</code>: <code class="nx">Flavor</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">flavor</code> <code class="o">===</code> <code class="s">'v</code>
<code class="s">                   // Autocomplete here suggests '</code><code class="nx">vanilla</code><code class="si">'</code>
<code class="p">}</code></pre>

<p class="author1">For more on this approach, see <a href="ch04.html#avoid-strings" class="calibre9">Item 33</a>.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Parameter Properties" data-type="sect2"><div class="praise" id="idm45331646888632">
<h2 class="calibre31">Parameter Properties</h2>

<p class="author1">It’s<a data-primary="classes" data-secondary="parameter properties" data-type="indexterm" id="idm45331646598552" class="calibre9"/><a data-primary="parameter properties" data-type="indexterm" id="idm45331646597544" class="calibre9"/><a data-primary="properties" data-secondary="parameter properties" data-type="indexterm" id="idm45331646596872" class="calibre9"/><a data-primary="classes" data-secondary="this" data-type="indexterm" id="idm45331646557224" class="calibre9"/> common to assign properties to a constructor parameter when initializing a class:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript provides a more compact syntax for this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{}</code>
<code class="p">}</code></pre>

<p class="author1">This is called a “parameter property,” and it is equivalent to the code in the first example. There are a few issues to be aware of with parameter properties:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">They are one of the few constructs which generates code when you compile to JavaScript (<code class="calibre18">enum</code>s are another). Generally compilation just involves erasing types.</p>
</li>
<li class="calibre12">
<p class="author1">Because the parameter is only used in generated code, the source looks like it has unused parameters.</p>
</li>
<li class="calibre12">
<p class="author1">A mix of parameter and non-parameter properties can hide the design of your classes.</p>
</li>
</ul>

<p class="author1">For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="p">[</code><code class="kd">this</code><code class="p">.</code><code class="nx">first</code><code class="p">,</code> <code class="kd">this</code><code class="p">.</code><code class="nx">last</code><code class="p">]</code> <code class="o">=</code> <code class="nx">name</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">' '</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">This class has three properties (<code class="calibre18">first</code>, <code class="calibre18">last</code>, <code class="calibre18">name</code>), but this is hard to read off the code because only two are listed before the constructor. This gets worse if the constructor takes other parameters, too.</p>

<p class="author1">If your class consists <em class="calibre3">only</em> of parameter properties and no methods, you might consider making it an <code class="calibre18">interface</code> and using object literals. Remember that the two are assignable to one another because of structural typing <a href="ch01.html#structural" class="calibre9">Item 4</a>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">p</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Jed Bartlet'</code><code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">Opinions are divided on parameter properties. While I generally avoid them, others appreciate the saved keystrokes. Be aware that they do not fit the pattern of the rest of TypeScript, and may in fact obscure that pattern for new developers. Try to avoid hiding the design of your class by using a mix of parameter and non-parameter properties.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Namespaces and Triple-Slash Imports" data-type="sect2"><div class="praise" id="idm45331646600056">
<h2 class="calibre31">Namespaces and Triple-Slash Imports</h2>

<p class="author1">Before<a data-primary="namespace" data-secondary="triple-slash imports and" data-type="indexterm" id="idm45331646400440" class="calibre9"/><a data-primary="triple-slash imports" data-type="indexterm" id="idm45331646399464" class="calibre9"/> ECMAScript 2015, JavaScript didn’t have an official module system. Different environments added this missing feature in different ways: Node.js used <code class="calibre18">require</code> and <code class="calibre18">module.exports</code> whereas AMD used a <code class="calibre18">define</code> function with a callback.</p>

<p class="author1">TypeScript also filled this gap with its own module system. This was done using a <code class="calibre18">module</code> keyword and “triple-slash” imports. After ECMAScript 2015 added an official module system, TypeScript added <code class="calibre18">namespace</code> as a synonym for <code class="calibre18">module</code>, to avoid confusion:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">namespace</code> <code class="nx">foo</code> <code class="p">{</code>
  <code class="kd">function</code> <code class="nx">bar() {</code><code class="p">}</code>
<code class="p">}</code></pre>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/// &lt;reference path="other.ts"/&gt;</code>
<code class="nx">foo</code><code class="p">.</code><code class="nx">bar</code><code class="p">();</code></pre>

<p class="author1">Outside of type declarations, triple-slash imports and the <code class="calibre18">module</code> keyword are just a historical curiosity. In your own code, you should use ECMASCript 2015–style modules (<code class="calibre18">import</code> and <code class="calibre18">export</code>). See <a href="ch08.html#write-modern-js" class="calibre9">Item 58</a>.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Decorators" data-type="sect2"><div class="praise" id="idm45331646314232">
<h2 class="calibre31">Decorators</h2>

<p class="author1">Decorators<a data-primary="decorators" data-type="indexterm" id="idm45331646350872" class="calibre9"/> can be used to annotate or modify classes, methods, and properties. For example, you could define a <code class="calibre18">logged</code> annotation that logs all calls to a method on a class:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Greeter</code> <code class="p">{</code>
  <code class="nx">greeting</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">message</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">=</code> <code class="nx">message</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">@logged</code>
  <code class="nx">greet() {</code>
    <code class="kd">return</code> <code class="s">"Hello, "</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">logged</code><code class="p">(</code><code class="nx">target</code>: <code class="nx">any</code><code class="p">,</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">descriptor</code>: <code class="nx">PropertyDescriptor</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">fn</code> <code class="o">=</code> <code class="nx">target</code><code class="p">[</code><code class="nx">name</code><code class="p">];</code>
  <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">`Calling </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
    <code class="kd">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="kd">this</code><code class="p">,</code> <code class="nx">arguments</code><code class="p">);</code>
  <code class="p">};</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">new</code> <code class="nx">Greeter</code><code class="p">(</code><code class="s">'Dave'</code><code class="p">).</code><code class="nx">greet</code><code class="p">());</code>
<code class="c">// Logs:</code>
<code class="c">// Calling greet</code>
<code class="c">// Hello, Dave</code></pre>

<p class="author1">This<a data-primary="tsconfig.json" data-secondary="experimentalDecorators property" data-type="indexterm" id="idm45331646281192" class="calibre9"/> feature was initially added to support the<a data-primary="Angular" data-type="indexterm" id="idm45331646157656" class="calibre9"/> Angular framework and requires the <code class="calibre18">experimentalDecorators</code> property to be set in <code class="calibre18">tsconfig.json</code>. Their implementation has not yet been standardized by TC39 at the time of this writing, so any code you write today using decorators is liable to break or become non-standard in the future. Unless you’re using Angular or another framework that requires annotations and until they’re standardized, don’t use TypeScript’s decorators.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331646155576">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">By and large, you can convert TypeScript to JavaScript by removing all the types from your code.</p>
</li>
<li class="calibre12">
<p class="author1">Enums, parameter properties, triple-slash imports, and decorators are historical exceptions to this rule.</p>
</li>
<li class="calibre12">
<p class="author1">In order to keep TypeScript’s role in your codebase as clear as possible, I recommend avoiding these features.<a data-primary="" data-startref="CWRecma07" data-type="indexterm" id="idm45331646151240" class="calibre9"/><a data-primary="" data-startref="ecma07" data-type="indexterm" id="idm45331646150264" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 54: Know How to Iterate Over Objects" data-type="sect1" class="praise"><div class="praise" id="iterate-objects">
<h1 class="calibre16">Item 54: Know How to Iterate Over Objects</h1>

<p class="author1">This<a data-primary="in construct" data-secondary="in (for-in)" data-type="indexterm" id="idm45331646147080" class="calibre9"/><a data-primary="code, writing and running" data-secondary="iterating over objects" data-type="indexterm" id="idm45331646146072" class="calibre9"/><a data-primary="let k: keyof T" data-type="indexterm" id="idm45331646145160" class="calibre9"/><a data-primary="for-in loops" data-type="indexterm" id="idm45331646144488" class="calibre9"/><a data-primary="Object.entries" data-type="indexterm" id="idm45331646143816" class="calibre9"/><a data-primary="objects" data-secondary="iterating over" data-type="indexterm" id="idm45331646143144" class="calibre9"/> code runs fine, and yet TypeScript flags an error in it. Why?</p>

<pre data-code-language="ts" data-type="programlisting" id="one-two-three" class="calibre17"><code class="kd">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">one</code><code class="o">:</code> <code class="s">'uno'</code><code class="p">,</code>
  <code class="nx">two</code><code class="o">:</code> <code class="s">'dos'</code><code class="p">,</code>
  <code class="nx">three</code><code class="o">:</code> <code class="s">'tres'</code><code class="p">,</code>
<code class="p">};</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">k</code> <code class="kd">in</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>
         <code class="c">// ~~~~~~ Element implicitly has an 'any' type</code>
         <code class="c">//        because type ... has no index signature</code>
<code class="p">}</code></pre>

<p class="author1">Inspecting the <code class="calibre18">obj</code> and <code class="calibre18">k</code> symbols gives a clue:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>
<code class="c">// const obj: {</code>
<code class="c">//     one: string;</code>
<code class="c">//     two: string;</code>
<code class="c">//     three: string;</code>
<code class="c">// }</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">k</code> <code class="kd">in</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>  <code class="c">// const k: string</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">The type of <code class="calibre18">k</code> is <code class="calibre18">string</code>, but you’re trying to index into an object whose type only has three specific keys: <code class="calibre18">'one'</code>, <code class="calibre18">'two'</code>, and <code class="calibre18">'three'</code>. There are strings other than these three, so this has to fail.</p>

<p class="author1">Plugging in a narrower type declaration for <code class="calibre18">k</code> fixes the issue:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">k</code>: <code class="nx">keyof</code> <code class="kd">typeof</code> <code class="nx">obj</code><code class="p">;</code>  <code class="c">// Type is "one" | "two" | "three"</code>
<code class="kd">for</code> <code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

<p class="author1">So the real question is: why is the type of <code class="calibre18">k</code> in the first example inferred as <code class="calibre18">string</code> rather than <code class="calibre18">"one" | "two" | "three"</code>?</p>

<p class="author1">To understand, let’s look at a slightly different example involving an interface and a function:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ABC</code> <code class="p">{</code>
  <code class="nx">a</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">b</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">c</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">abc</code>: <code class="nx">ABC</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">k</code> <code class="kd">in</code> <code class="nx">abc</code><code class="p">)</code> <code class="p">{</code>  <code class="c">// const k: string</code>
    <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">abc</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>
           <code class="c">// ~~~~~~ Element implicitly has an 'any' type</code>
           <code class="c">//        because type 'ABC' has no index signature</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">It’s the same error as before. And you can “fix” it using the same sort of declaration (<code class="calibre18">let k: keyof ABC</code>). But in this case TypeScript is right to complain. Here’s why:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="p">{</code><code class="nx">a</code><code class="o">:</code> <code class="s">'a'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s">'b'</code><code class="p">,</code> <code class="nx">c</code>: <code class="nx">2</code><code class="p">,</code> <code class="nx">d</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">()};</code>
<code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">The<a data-primary="assignable to" data-type="indexterm" id="idm45331645889576" class="calibre9"/> function <code class="calibre18">foo</code> can be called with any value <em class="calibre3">assignable</em> to <code class="calibre18">ABC</code>, not just a value with “a,” “b,” and “c” properties. It’s entirely possible that the value will have other properties, too (see <a href="ch01.html#structural" class="calibre9">Item 4</a>). To allow for this, TypeScript gives <code class="calibre18">k</code> the only type it can be confident of, namely, <code class="calibre18">string</code>.</p>

<p class="author1">Using the <code class="calibre18">keyof</code> declaration would have another downside here:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">abc</code>: <code class="nx">ABC</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">k</code>: <code class="nx">keyof</code> <code class="nx">ABC</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">abc</code><code class="p">)</code> <code class="p">{</code>  <code class="c">// let k: "a" | "b" | "c"</code>
    <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">abc</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>  <code class="c">// Type is string | number</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">If <code class="calibre18">"a" | "b" | "c"</code> is too narrow for <code class="calibre18">k</code>, then <code class="calibre18">string | number</code> is certainly too narrow for <code class="calibre18">v</code>. In the preceding example one of the values is a <code class="calibre18">Date</code>, but it could be anything. The types here give a false sense of certainty that could lead to chaos at runtime.</p>

<p class="author1">So what if you just want to iterate over the object’s keys and values without type errors? <code class="calibre18">Object.entries</code> lets you iterate over both simultaneously:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">abc</code>: <code class="nx">ABC</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="p">[</code><code class="nx">k</code><code class="p">,</code> <code class="nx">v</code><code class="p">]</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">entries</code><code class="p">(</code><code class="nx">abc</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">k</code>  <code class="c">// Type is string</code>
    <code class="nx">v</code>  <code class="c">// Type is any</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">While these types may be hard to work with, they are at least honest!</p>

<p class="author1">You<a data-primary="prototype pollution" data-type="indexterm" id="idm45331645726280" class="calibre9"/> should also be aware of the possibility of <em class="calibre3">prototype pollution</em>. Even in the case of an object literal that you define, for-in can produce additional keys:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">Object.prototype.z = 3;</strong> // Please don't do this!
&gt; <strong class="calibre32">const obj = {x: 1, y: 2};</strong>
&gt; <strong class="calibre32">for (const k in obj) { console.log(k); }</strong>
x
y
z</pre>

<p class="author1">Hopefully this doesn’t happen in a nonadversarial environment (you should never add enumerable properties to <code class="calibre18">Object.prototype</code>), but it is another reason that for-in produces <code class="calibre18">string</code> keys even for object literals.</p>

<p class="author1">If you want to iterate over the keys and values in an object, use either a <code class="calibre18">keyof</code> declaration (<code class="calibre18">let k: keyof T</code>) or <code class="calibre18">Object.entries</code>. The former is appropriate for constants or other situations where you know that the object won’t have additional keys and you want precise types. The latter is more generally appropriate, though the key and value types are more difficult to work with.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331645719576">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Use <code class="calibre18">let k: keyof T</code> and a for-in loop to iterate objects when you know exactly what the keys will be. Be aware that any objects your function receives as parameters might have additional keys.</p>
</li>
<li class="calibre12">
<p class="author1">Use <code class="calibre18">Object.entries</code> to iterate over the keys and values of any object.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 55: Understand the DOM hierarchy" data-type="sect1" class="praise"><div class="praise" id="understand-the-dom">
<h1 class="calibre16">Item 55: Understand the DOM hierarchy</h1>

<p class="author1">Most<a data-primary="code, writing and running" data-secondary="DOM hierarchy" data-type="indexterm" id="CWRdom07" class="calibre9"/><a data-primary="DOM hierarchy" data-type="indexterm" id="DOM07" class="calibre9"/><a data-primary="TypeScript" data-secondary="writing for browsers" data-type="indexterm" id="TSbrowser07" class="calibre9"/> of the items in this book are agnostic about where you run your TypeScript: in a web browser, on a server, on a phone. This one is different. If you’re not working in a browser, skip ahead!</p>

<p class="author1">The DOM hierarchy is always present when you’re running JavaScript in a web browser. When you use <code class="calibre18">document.getElementById</code> to get an element or <code class="calibre18">document.createElement</code> to create one, it’s always a particular kind of element, even if you’re not entirely familiar with the taxonomy. You call the methods and use the properties that you want and hope for the best.</p>

<p class="author1">With<a data-primary="Node" data-type="indexterm" id="idm45331645706360" class="calibre9"/><a data-primary="Element" data-type="indexterm" id="idm45331645705624" class="calibre9"/><a data-primary="EventTarget" data-type="indexterm" id="idm45331645704952" class="calibre9"/> TypeScript, the hierarchy of DOM elements becomes more visible. Knowing your <code class="calibre18">Node</code>s from your <code class="calibre18">Element</code>s and <code class="calibre18">EventTarget</code>s will help you debug type errors and decide when type assertions are appropriate. Because so many APIs are based on the DOM, this is relevant even if you’re using a framework like<a data-primary="React library" data-secondary="DOM hierarchy and" data-type="indexterm" id="idm45331645702680" class="calibre9"/> React or d3.</p>

<p class="author1">Suppose you want to track a user’s mouse as they drag it across a <code class="calibre18">&lt;div&gt;</code>. You write some seemingly innocuous JavaScript:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">handleDrag</code><code class="p">(</code><code class="nx">eDown</code><code class="o">:</code> <code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">targetEl</code> <code class="o">=</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">currentTarget</code><code class="p">;</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">dragStart</code> <code class="o">=</code> <code class="p">[</code><code class="nx">eDown</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
  <code class="kd">const</code> <code class="nx">handleUp</code> <code class="o">=</code> <code class="p">(</code><code class="nx">eUp</code><code class="o">:</code> <code class="nx">Event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
    <code class="nx">targetEl</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">dragEnd</code> <code class="o">=</code> <code class="p">[</code><code class="nx">eUp</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eUp</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'dx, dy = '</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="nx">dragEnd</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">-</code> <code class="nx">dragStart</code><code class="p">[</code><code class="nx">i</code><code class="p">]));</code>
  <code class="p">}</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'surface'</code><code class="p">);</code>
<code class="nx">div</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mousedown'</code><code class="p">,</code> <code class="nx">handleDrag</code><code class="p">);</code></pre>

<p class="author1">TypeScript’s type checker flags no fewer than 11 errors in these 14 lines of code:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">handleDrag</code><code class="p">(</code><code class="nx">eDown</code>: <code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">targetEl</code> <code class="o">=</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">currentTarget</code><code class="p">;</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
<code class="c">// ~~~~~~~           Object is possibly 'null'.</code>
<code class="c">//         ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget'</code>
  <code class="kd">const</code> <code class="nx">dragStart</code> <code class="o">=</code> <code class="p">[</code>
     <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
        <code class="c">// ~~~~~~~                Property 'clientX' does not exist on 'Event'</code>
        <code class="c">//                ~~~~~~~ Property 'clientY' does not exist on 'Event'</code>
  <code class="kd">const</code> <code class="nx">handleUp</code> <code class="o">=</code> <code class="p">(</code><code class="nx">eUp</code>: <code class="nx">Event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
<code class="c">//  ~~~~~~~~           Object is possibly 'null'.</code>
<code class="c">//           ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget'</code>
    <code class="nx">targetEl</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
<code class="c">//  ~~~~~~~~ Object is possibly 'null'</code>
    <code class="kd">const</code> <code class="nx">dragEnd</code> <code class="o">=</code> <code class="p">[</code>
       <code class="nx">eUp</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eUp</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
        <code class="c">// ~~~~~~~                Property 'clientX' does not exist on 'Event'</code>
        <code class="c">//              ~~~~~~~   Property 'clientY' does not exist on 'Event'</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'dx, dy = '</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="nx">dragEnd</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">-</code> <code class="nx">dragStart</code><code class="p">[</code><code class="nx">i</code><code class="p">]));</code>
  <code class="p">}</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
<code class="c">// ~~~~~~~ Object is possibly 'null'</code>
<code class="p">}</code>

   <code class="kd">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'surface'</code><code class="p">);</code>
   <code class="nx">div</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mousedown'</code><code class="p">,</code> <code class="nx">handleDrag</code><code class="p">);</code>
<code class="c">// ~~~ Object is possibly 'null'</code></pre>

<p class="author1">What went wrong? What’s this <code class="calibre18">EventTarget</code>? And why might everything be <code class="calibre18">null</code>?</p>

<p class="author1">To understand the <code class="calibre18">EventTarget</code> errors it helps to dig into the DOM hierarchy a bit. Here’s some HTML:</p>

<pre data-code-language="html" data-type="programlisting" class="calibre17"><code class="nt">&lt;p</code> <code class="na">id=</code><code class="s">"quote"</code><code class="nt">&gt;</code>and <code class="nt">&lt;i&gt;</code>yet<code class="nt">&lt;/i&gt;</code> it moves<code class="nt">&lt;/p&gt;</code></pre>

<p class="author1">If you open your browser’s JavaScript console and get a reference to the <code class="calibre18">p</code> element, you’ll see that it’s an <code class="calibre18">HTMLParagraphElement</code>:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">p</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementsByTagName</code><code class="p">(</code><code class="s">'p'</code><code class="p">)[</code><code class="mi">0</code><code class="p">];</code>
<code class="nx">p</code> <code class="kd">instanceof</code> <code class="nx">HTMLParagraphElement</code>
<code class="c">// True</code></pre>

<p class="author1">An <code class="calibre18">HTMLParagraphElement</code> is<a data-primary="HTMLElement" data-type="indexterm" id="idm45331645360904" class="calibre9"/> a subtype of <code class="calibre18">HTMLElement</code>, which is a subtype of <code class="calibre18">Element</code>, which is a subtype of <code class="calibre18">Node</code>, which is a subtype of <code class="calibre18">EventTarget</code>. Here are some examples of types along the hierarchy:</p>
<table class="calibre34">
<caption class="calibre35"><span class="calibre">Table 7-1. </span>Types in the DOM Hierarchy</caption>
<thead class="calibre36">
<tr class="calibre37">
<th class="calibre38">Type</th>
<th class="calibre38">Examples</th>
</tr>
</thead>
<tbody class="calibre39">
<tr class="calibre37">
<td class="calibre40"><p class="author1">EventTarget</p></td>
<td class="calibre40"><p class="author1"><code class="calibre41">window</code>, <code class="calibre41">XMLHttpRequest</code></p></td>
</tr>
<tr class="calibre42">
<td class="calibre40"><p class="author1">Node</p></td>
<td class="calibre40"><p class="author1"><code class="calibre41">document</code>, <code class="calibre41">Text</code>, <code class="calibre41">Comment</code></p></td>
</tr>
<tr class="calibre37">
<td class="calibre40"><p class="author1">Element</p></td>
<td class="calibre40"><p class="author1"><em class="calibre3">includes HTMLElements, SVGElements</em></p></td>
</tr>
<tr class="calibre42">
<td class="calibre40"><p class="author1">HTMLElement</p></td>
<td class="calibre40"><p class="author1"><code class="calibre41">&lt;i&gt;</code>, <code class="calibre41">&lt;b&gt;</code></p></td>
</tr>
<tr class="calibre37">
<td class="calibre40"><p class="author1">HTMLButtonElement</p></td>
<td class="calibre40"><p class="author1"><code class="calibre41">&lt;button&gt;</code></p></td>
</tr>
</tbody>
</table>

<p class="author1">An <code class="calibre18">EventTarget</code> is the most generic of DOM types. All you can do with it is add event listeners, remove them, and dispatch events. With this in mind, the <code class="calibre18">classList</code> errors start to make a bit more sense:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">handleDrag</code><code class="p">(</code><code class="nx">eDown</code>: <code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">targetEl</code> <code class="o">=</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">currentTarget</code><code class="p">;</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
<code class="c">// ~~~~~~~           Object is possibly 'null'</code>
<code class="c">//         ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget'</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">As its name implies, an <code class="calibre18">Event</code>’s <code class="calibre18">currentTarget</code> property is an <code class="calibre18">EventTarget</code>. It could even be <code class="calibre18">null</code>. TypeScript has no reason to believe that it has a <code class="calibre18">classList</code> property. While an <code class="calibre18">EventTarget</code>s <em class="calibre3">could</em> be an <code class="calibre18">HTMLElement</code> in practice, from the type system’s perspective there’s no reason it couldn’t be <code class="calibre18">window</code> or <code class="calibre18">XMLHTTPRequest</code>.</p>

<p class="author1">Moving up the hierarchy we come to <code class="calibre18">Node</code>. A couple of examples of <code class="calibre18">Node</code>s that are not <code class="calibre18">Element</code>s are text fragments and comments. For instance, in this HTML:</p>

<pre data-code-language="html" data-type="programlisting" class="calibre17"><code class="nt">&lt;p&gt;</code>
  And <code class="nt">&lt;i&gt;</code>yet<code class="nt">&lt;/i&gt;</code> it moves
  <code class="c1">&lt;!-- quote from Galileo --&gt;</code>
<code class="nt">&lt;/p&gt;</code></pre>

<p class="author1">the outermost element is an <code class="calibre18">HTMLParagraphElement</code>. As you can see here, it has <code class="calibre18">children</code> and <code class="calibre18">childNodes</code>:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">p.children</strong>
HTMLCollection [i]
&gt; <strong class="calibre32">p.childNodes</strong>
NodeList(5) [text, i, text, comment, text]</pre>

<p class="author1"><code class="calibre18">children</code> returns an <code class="calibre18">HTMLCollection</code>, an array-like structure containing just the child <code class="calibre18">Element</code>s (<code class="calibre18">&lt;i&gt;yet&lt;/i&gt;</code>). <code class="calibre18">childNodes</code> returns a <code class="calibre18">NodeList</code>, an Array-like collection of <code class="calibre18">Node</code>s. This includes not just <code class="calibre18">Element</code>s (<code class="calibre18">&lt;i&gt;yet&lt;/i&gt;</code>) but also text fragments (“And,” “it moves”) and comments (“quote from Galileo”).</p>

<p class="author1">What’s the difference between an <code class="calibre18">Element</code> and an <code class="calibre18">HTMLElement</code>? There are non-HTML <code class="calibre18">Element</code>s including the whole hierarchy of SVG tags. These are <code class="calibre18">SVGElement</code>s, which are another type of <code class="calibre18">Element</code>. What’s the type of an <code class="calibre18">&lt;html&gt;</code> or <code class="calibre18">&lt;svg&gt;</code> tag? They’re <code class="calibre18">HTMLHtmlElement</code> and <code class="calibre18">SVGSvgElement</code>.</p>

<p class="author1">Sometimes these specialized classes will have properties of their own—for example, an <code class="calibre18">HTMLImageElement</code> has a <code class="calibre18">src</code> property, and an <code class="calibre18">HTMLInputElement</code> has a <code class="calibre18">value</code> property. If you want to read one of these properties off a value, its type must be specific enough to have that property.</p>

<p class="author1">TypeScript’s type declarations for the DOM make liberal use of literal types to try to get you the most specific type possible. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">getElementsByTagName</code><code class="p">(</code><code class="s">'p'</code><code class="p">)[</code><code class="mi">0</code><code class="p">];</code>  <code class="c">// HTMLParagraphElement</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s">'button'</code><code class="p">);</code>  <code class="c">// HTMLButtonElement</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s">'div'</code><code class="p">);</code>  <code class="c">// HTMLDivElement</code></pre>

<p class="author1">but this is not always possible, notably with <code class="calibre18">document.getElementById</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'my-div'</code><code class="p">);</code>  <code class="c">// HTMLElement</code></pre>

<p class="author1">While type assertions are generally frowned upon (<a href="ch02_split_000.html#prefer-declarations-to-assertions" class="calibre9">Item 9</a>), this is a case where you know more than TypeScript does and so they are appropriate. There’s nothing wrong with this, so long as you know that <code class="calibre18">#my-div</code> is a div:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'my-div'</code><code class="p">)</code> <code class="kd">as</code> <code class="nx">HTMLDivElement</code><code class="p">;</code></pre>

<p class="author1">with <code class="calibre18">strictNullChecks</code> enabled, you will need to consider the case that <code class="calibre18">document.getElementById</code> returns <code class="calibre18">null</code>. Depending on whether this can really happen, you can either add an if statement or an assertion (<code class="calibre18">!</code>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'my-div'</code><code class="p">)</code><code class="o">!</code><code class="p">;</code></pre>

<p class="author1">These types are not specific to TypeScript. Rather, they are generated from the formal specification of the DOM. This is an example of the advice of <a href="ch04.html#consider-codegen" class="calibre9">Item 35</a> to generate types from specs when possible.</p>

<p class="author1">So much for the DOM hierarchy. What about the <code class="calibre18">clientX</code> and <code class="calibre18">clientY</code> errors?</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">handleDrag</code><code class="p">(</code><code class="nx">eDown</code>: <code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
  <code class="kd">const</code> <code class="nx">dragStart</code> <code class="o">=</code> <code class="p">[</code>
     <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
        <code class="c">// ~~~~~~~                Property 'clientX' does not exist on 'Event'</code>
        <code class="c">//                ~~~~~~~ Property 'clientY' does not exist on 'Event'</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">In<a data-primary="Event" data-type="indexterm" id="idm45331644967480" class="calibre9"/> addition to the hierarchy for <code class="calibre18">Node</code>s and <code class="calibre18">Element</code>s, there is also a hierarchy for <code class="calibre18">Event</code>s. The Mozilla documentation currently lists no fewer than 52 types of <code class="calibre18">Event</code>!</p>

<p class="author1">Plain<a data-primary="MouseEvent" data-type="indexterm" id="idm45331644944216" class="calibre9"/> <code class="calibre18">Event</code> is the most generic type of event. More specific types include:</p>
<dl class="praise">
<dt class="calibre19"><code class="calibre18">UIEvent</code></dt>
<dd class="calibre20">
<p class="author1">Any sort of user interface event</p>
</dd>
<dt class="calibre19"><code class="calibre18">MouseEvent</code></dt>
<dd class="calibre20">
<p class="author1">An event triggered by the mouse such as a click</p>
</dd>
<dt class="calibre19"><code class="calibre18">TouchEvent</code></dt>
<dd class="calibre20">
<p class="author1">A touch event on a mobile device</p>
</dd>
<dt class="calibre19"><code class="calibre18">WheelEvent</code></dt>
<dd class="calibre20">
<p class="author1">An event triggered by rotating the scroll wheel</p>
</dd>
<dt class="calibre19"><code class="calibre18">KeyboardEvent</code></dt>
<dd class="calibre20">
<p class="author1">A key press</p>
</dd>
</dl>

<p class="author1">The problem in <code class="calibre18">handleDrag</code> is that the events are declared as <code class="calibre18">Event</code>, while <code class="calibre18">clientX</code> and <code class="calibre18">clientY</code> exist only on the more specific <code class="calibre18">MouseEvent</code> type.</p>

<p class="author1">So how can you fix the example from the start of this item? TypeScript’s declarations for the DOM make extensive use of context (<a href="ch03.html#context-inference" class="calibre9">Item 26</a>). Inlining the mousedown handler gives TypeScript more information to work with and removes most of the errors. You can also declare the parameter type to be <code class="calibre18">MouseEvent</code> rather than <code class="calibre18">Event</code>. Here’s a version that uses both techniques to fix the errors:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addDragHandler</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mousedown'</code><code class="p">,</code> <code class="nx">eDown</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">dragStart</code> <code class="o">=</code> <code class="p">[</code><code class="nx">eDown</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
    <code class="kd">const</code> <code class="nx">handleUp</code> <code class="o">=</code> <code class="p">(</code><code class="nx">eUp</code>: <code class="nx">MouseEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">el</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
      <code class="nx">el</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
      <code class="kd">const</code> <code class="nx">dragEnd</code> <code class="o">=</code> <code class="p">[</code><code class="nx">eUp</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eUp</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'dx, dy = '</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="nx">dragEnd</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">-</code> <code class="nx">dragStart</code><code class="p">[</code><code class="nx">i</code><code class="p">]));</code>
    <code class="p">}</code>
    <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
  <code class="p">});</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'surface'</code><code class="p">);</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">div</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">addDragHandler</code><code class="p">(</code><code class="nx">div</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">if</code> statement at the end handles the possibility that there is no <code class="calibre18">#surface</code> element. If you know that this element exists, you could use an assertion instead (<code class="calibre18">div!</code>). <code class="calibre18">addDragHandler</code> requires a non-null <code class="calibre18">HTMLElement</code>, so this is an example of pushing <code class="calibre18">null</code> values to the perimeter (<a href="ch04.html#null-values-to-perimeter" class="calibre9">Item 31</a>).</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331644784984">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">The DOM has a type hierarchy that you can usually ignore while writing JavaScript. But these types become more important in TypeScript. Understanding them will help you write TypeScript for the browser.</p>
</li>
<li class="calibre12">
<p class="author1">Know the differences between <code class="calibre18">Node</code>, <code class="calibre18">Element</code>, <code class="calibre18">HTMLElement</code>, and <code class="calibre18">EventTarget</code>, as well as those between <code class="calibre18">Event</code> and <code class="calibre18">MouseEvent</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Either use a specific enough type for DOM elements and Events in your code or give TypeScript the context to infer it.<a data-primary="" data-startref="CWRdom07" data-type="indexterm" id="idm45331644777880" class="calibre9"/><a data-primary="" data-startref="DOM07" data-type="indexterm" id="idm45331644776904" class="calibre9"/><a data-primary="" data-startref="TSbrowser07" data-type="indexterm" id="idm45331644775960" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 56: Don’t Rely on Private to Hide Information" data-type="sect1" class="praise"><div class="praise" id="private-rely">
<h1 class="calibre16">Item 56: Don’t Rely on Private to Hide Information</h1>

<p class="author1">JavaScript<a data-primary="classes" data-secondary="private fields" data-type="indexterm" id="idm45331644773464" class="calibre9"/><a data-primary="code, writing and running" data-secondary="hiding information" data-type="indexterm" id="idm45331644772456" class="calibre9"/><a data-primary="private field modifier" data-type="indexterm" id="idm45331644771544" class="calibre9"/><a data-primary="public field modifier" data-type="indexterm" id="idm45331644770872" class="calibre9"/><a data-primary="protected field modifier" data-type="indexterm" id="idm45331644770200" class="calibre9"/> has historically lacked a way to make properties of a class private. The usual workaround is a convention of prefixing fields that are not part of a public API with underscores:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Foo</code> <code class="p">{</code>
  <code class="nx">_private</code> <code class="o">=</code> <code class="s">'secret123'</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">But this only discourages users from accessing private data. It is easy to circumvent:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Foo</code><code class="p">();</code>
<code class="nx">f</code><code class="p">.</code><code class="nx">_private</code><code class="p">;</code>  <code class="c">// 'secret123'</code></pre>

<p class="author1">TypeScript adds <code class="calibre18">public</code>, <code class="calibre18">protected</code>, and <code class="calibre18">private</code> field modifiers that seem to provide some enforcement:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Diary</code> <code class="p">{</code>
  <code class="kd">private</code> <code class="nx">secret</code> <code class="o">=</code> <code class="s">'cheated on my English test'</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">diary</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Diary</code><code class="p">();</code>
<code class="nx">diary</code><code class="p">.</code><code class="nx">secret</code>
   <code class="c">// ~~~~~~ Property 'secret' is private and only</code>
   <code class="c">//        accessible within class 'Diary'</code></pre>

<p class="author1">But <code class="calibre18">private</code> is a feature of the type system and, like all features of the type system, it goes away at runtime (see <a href="ch01.html#independent" class="calibre9">Item 3</a>). Here’s<a data-primary="ES2017" data-type="indexterm" id="idm45331644707912" class="calibre9"/> what this snippet looks like when TypeScript compiles it to JavaScript (with <code class="calibre18">target=ES2017</code>):</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Diary</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">secret</code> <code class="o">=</code> <code class="s">'cheated on my English test'</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">diary</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Diary</code><code class="p">();</code>
<code class="nx">diary</code><code class="p">.</code><code class="nx">secret</code><code class="p">;</code></pre>

<p class="author1">The <code class="calibre18">private</code> indicator is gone, and your secret is out! Much like the <code class="calibre18">_private</code> convention, TypeScript’s access modifiers only discourage you from accessing private data. With a type assertion, you can even access a private property from within TypeScript:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Diary</code> <code class="p">{</code>
  <code class="kd">private</code> <code class="nx">secret</code> <code class="o">=</code> <code class="s">'cheated on my English test'</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">diary</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Diary</code><code class="p">();</code>
<code class="p">(</code><code class="nx">diary</code><code class="si"> </code><code class="kd">as</code> <code class="nx">any</code><code class="p">).</code><code class="nx">secret</code>  <code class="c">// OK</code></pre>

<p class="author1">In other words, <em class="calibre3">don’t rely on <code class="calibre23">private</code> to hide information!</em></p>

<p class="author1">So<a data-primary="closures" data-type="indexterm" id="idm45331644515368" class="calibre9"/> what should you do if you want something more robust? The traditional answer has been to take advantage of one of JavaScript’s most reliable ways to hide information: closures. You can create one in a constructor:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">hash</code><code class="p">(</code><code class="nx">text</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>

<code class="kd">class</code> <code class="nx">PasswordChecker</code> <code class="p">{</code>
  <code class="nx">checkPassword</code><code class="o">:</code> <code class="p">(</code><code class="nx">password</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">boolean</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">passwordHash</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">checkPassword</code> <code class="o">=</code> <code class="p">(</code><code class="nx">password</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="nx">hash</code><code class="p">(</code><code class="nx">password</code><code class="p">)</code> <code class="o">===</code> <code class="nx">passwordHash</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">checker</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">PasswordChecker</code><code class="p">(</code><code class="nx">hash</code><code class="p">(</code><code class="s">'s3cret'</code><code class="p">));</code>
<code class="nx">checker</code><code class="p">.</code><code class="nx">checkPassword</code><code class="p">(</code><code class="s">'s3cret'</code><code class="p">);</code>  <code class="c">// Returns true</code></pre>

<p class="author1">JavaScript offers no way to access the <code class="calibre18">passwordHash</code> variable from outside of the constructor of <code class="calibre18">PasswordChecker</code>. This does have a few downsides, however: specifically, because <code class="calibre18">passwordHash</code> can’t be seen outside the constructor, every method that uses it also has to be defined there. This results in a copy of each method being created for every class instance, which will lead to higher memory use. It also prevents other instances of the same class from accessing private data. Closures may be inconvenient, but they will certainly keep your data private!</p>

<p class="author1">A<a data-primary="# (private field prefix)" data-type="indexterm" id="idm45331644403832" class="calibre9"/> newer option is to use private fields, a proposed language feature that is solidifying as this book goes to print. In this proposal, to make a field private both for type checking and at runtime, prefix it with a <code class="calibre18">#</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">PasswordChecker</code> <code class="p">{</code>
  <code class="si">#</code><code class="nx">passwordHash</code>: <code class="nx">number</code><code class="p">;</code>

  <code class="kd">constructor</code><code class="p">(</code><code class="nx">passwordHash</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="si">#</code><code class="nx">passwordHash</code> <code class="o">=</code> <code class="nx">passwordHash</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">checkPassword</code><code class="p">(</code><code class="nx">password</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">hash</code><code class="p">(</code><code class="nx">password</code><code class="p">)</code> <code class="o">===</code> <code class="kd">this</code><code class="p">.</code><code class="si">#</code><code class="nx">passwordHash</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">checker</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">PasswordChecker</code><code class="p">(</code><code class="nx">hash</code><code class="p">(</code><code class="s">'s3cret'</code><code class="p">));</code>
<code class="nx">checker</code><code class="p">.</code><code class="nx">checkPassword</code><code class="p">(</code><code class="s">'secret'</code><code class="p">);</code>  <code class="c">// Returns false</code>
<code class="nx">checker</code><code class="p">.</code><code class="nx">checkPassword</code><code class="p">(</code><code class="s">'s3cret'</code><code class="p">);</code>  <code class="c">// Returns true</code></pre>

<p class="author1">The <code class="calibre18">#passwordHash</code> property is not accessible from outside the class. In contrast to the closure technique, it <em class="calibre3">is</em> accessible from class methods and from other instances of the same class. For ECMAScript targets that don’t natively support private fields, a fallback implementation using <code class="calibre18">WeakMap</code>s is used instead. The upshot is that your data is still private. This proposal was stage 3 and support was being added to TypeScript as this book went to print. If you’d like to use it, check the TypeScript release notes to see if it’s generally available.</p>

<p class="author1">Finally, if<a data-primary="security" data-type="indexterm" id="idm45331644298424" class="calibre9"/> you are worried about <em class="calibre3">security</em>, rather than just encapsulation, then there are others concerns to be aware of such as modifications to built-in prototypes and functions.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331644297016">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">The <code class="calibre18">private</code> access modifier is only enforced through the type system. It has no effect at runtime and can be bypassed with an assertion. Don’t assume it will keep data hidden.</p>
</li>
<li class="calibre12">
<p class="author1">For more reliable information hiding, use a closure.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 57: Use Source Maps to Debug TypeScript" data-type="sect1" class="praise"><div class="praise" id="source-maps-debug">
<h1 class="calibre16">Item 57: Use Source Maps to Debug TypeScript</h1>

<p class="author1">When<a data-primary="code, writing and running" data-secondary="debugging with source maps" data-type="indexterm" id="CWRdebug07" class="calibre9"/><a data-primary="debugging" data-secondary="with source maps" data-secondary-sortas="source maps" data-type="indexterm" id="Dsourcem07" class="calibre9"/><a data-primary="source maps" data-type="indexterm" id="sm07" class="calibre9"/> you run TypeScript code, you’re actually running the JavaScript that the TypeScript compiler generates. This is true of any source-to-source compiler, be it a minifier, a compiler, or a preprocessor. The hope is that this is mostly transparent, that you can pretend that the TypeScript source code is being executed without ever having to look at the JavaScript.</p>

<p class="author1">This works well until you have to debug your code. Debuggers generally work on the code you’re executing and don’t know about the translation process it went through. Since JavaScript is such a popular target language, browser vendors collaborated to solve this problem. The result is source maps. They map positions and symbols in a generated file back to the corresponding positions and symbols in the original source. Most browsers and many IDEs support them. If you’re not using them to debug your TypeScript, you’re missing out!</p>

<p class="author1">Suppose you’ve created a small script to add a button to an HTML page that increments every time you click it:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addCounter</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">clickCount</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s">'button'</code><code class="p">);</code>
  <code class="nx">button</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Click me'</code><code class="p">;</code>
  <code class="nx">button</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'click'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">clickCount</code><code class="o">++</code><code class="p">;</code>
    <code class="nx">button</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">`Click me (</code><code class="si">${</code><code class="nx">clickCount</code><code class="si">}</code><code class="s">)`</code><code class="p">;</code>
  <code class="p">});</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">button</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">addCounter</code><code class="p">(</code><code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">);</code></pre>

<p class="author1">If you load this in your browser and open the debugger, you’ll see the generated JavaScript. This closely matches the original source, so debugging isn’t too difficult, as you can see in <a data-type="xref" href="#efts-07in01" class="calibre9">Figure 7-1</a>.</p>

<figure class="calibre28"><div class="figure" id="efts-07in01">
<img alt="efts 07in01" src="assets/efts_07in01.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 7-1. </span>Debugging generated JavaScript using Chrome’s developer tools. For this simple example, the generated JavaScript closely resembles the TypeScript source.</h6>
</div></figure>

<p class="author1">Let’s make the page more fun by fetching an interesting fact about each number from numbersapi.com:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addCounter</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">clickCount</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">triviaEl</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s">'p'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s">'button'</code><code class="p">);</code>
  <code class="nx">button</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Click me'</code><code class="p">;</code>
  <code class="nx">button</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'click'</code><code class="p">,</code> <code class="kd">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">clickCount</code><code class="o">++</code><code class="p">;</code>
    <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">`http://numbersapi.com/</code><code class="si">${</code><code class="nx">clickCount</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">trivia</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
    <code class="nx">triviaEl</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="nx">trivia</code><code class="p">;</code>
    <code class="nx">button</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">`Click me (</code><code class="si">${</code><code class="nx">clickCount</code><code class="si">}</code><code class="s">)`</code><code class="p">;</code>
  <code class="p">});</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">triviaEl</code><code class="p">);</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">button</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">If you open up your browser’s debugger now, you’ll see that the generated source has gotten dramatically more complicated (see <a data-type="xref" href="#efts-07in02" class="calibre9">Figure 7-2</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-07in02">
<img alt="efts 07in02" src="assets/efts_07in02.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 7-2. </span>In this case the TypeScript compiler has generated JavaScript that doesn’t closely resemble the original TypeScript source. This will make debugging more difficult.</h6>
</div></figure>

<p class="author1">To support <code class="calibre18">async</code> and <code class="calibre18">await</code> in older browsers, TypeScript has rewritten the event handler as a state machine. This has the same behavior, but the code no longer bears such a close resemblance to the original source.</p>

<p class="author1">This<a data-primary="tsconfig.json" data-secondary="sourceMap option" data-type="indexterm" id="idm45331644069240" class="calibre9"/> is where source maps can help. To tell TypeScript to generate one, set the <code class="calibre18">sourceMap</code> option in your <em class="calibre3">tsconfig.json</em>:</p>

<pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"sourceMap"</code><code class="p">:</code> <code class="kd">true</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">Now when you run <code class="calibre18">tsc</code>, it generates two output files for each <em class="calibre3">.ts</em> file: a <em class="calibre3">.js</em> file and a <em class="calibre3">.js.map</em> file. The latter is the source map.</p>

<p class="author1">With this file in place, a new <em class="calibre3">index.ts</em> file appears in your browser’s debugger. You can set breakpoints and inspect variables in it, just as you’d hope (see <a data-type="xref" href="#efts-07in03" class="calibre9">Figure 7-3</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-07in03">
<img alt="efts 07in03" src="assets/efts_07in03.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 7-3. </span>When a source map is present, you can work with the original TypeScript source in your debugger, rather than the generated JavaScript.</h6>
</div></figure>

<p class="author1">Note that <em class="calibre3">index.ts</em> appears in italics in the file list on the left. This indicates that it isn’t a “real” file in the sense that the web page included it. Rather, it was included via the source map. Depending on your settings, <em class="calibre3">index.js.map</em> will contain either a reference to <em class="calibre3">index.ts</em> (in which case the browser loads it over the network) or an inline copy of it (in which case no request is needed).</p>

<p class="author1">There are a few things to be aware of with source maps:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">If you are using a bundler or minifier with TypeScript, it may generate a source map of its own. To get the best debugging experience, you want this to map all the way back to the original TypeScript sources, not the generated JavaScript. If your bundler has built-in support for TypeScript, then this should just work. If not, you may need to hunt down some flags to make it read source map inputs.</p>
</li>
<li class="calibre12">
<p class="author1">Be aware of whether you’re serving source maps in production. The browser won’t load source maps unless the debugger is open, so there’s no performance impact for end users. But if the source map contains an inline copy of your original source code, then there may be content that you didn’t intend to publicize. Does the world really need to see your snarky comments or internal bug tracker URLs?</p>
</li>
</ul>

<p class="author1">You can also debug NodeJS programs using source maps. This is typically done via your editor or by connecting to your node process from a browser’s debugger. Consult the Node docs for details.</p>

<p class="author1">The type checker can catch many errors before you run your code, but it is no substitute for a good debugger. Use source maps to get a great TypeScript debugging experience.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331644042296">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Don’t debug generated JavaScript. Use source maps to debug your TypeScript code at runtime.</p>
</li>
<li class="calibre12">
<p class="author1">Make sure that your source maps are mapped all the way through to the code that you run.</p>
</li>
<li class="calibre12">
<p class="author1">Depending on your settings, your source maps might contain an inline copy of your original code. Don’t publish them unless you know what you’re doing!<a data-primary="" data-startref="sm07" data-type="indexterm" id="idm45331644037928" class="calibre9"/><a data-primary="" data-startref="Dsourcem07" data-type="indexterm" id="idm45331644036952" class="calibre9"/><a data-primary="" data-startref="CWRdebug07" data-type="indexterm" id="idm45331644036008" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>







</div></section></body></html>