<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 6. Labels and Annotations" data-type="chapter" epub:type="chapter"><div class="chapter" id="labels_and_annotations">
<h1><span class="label">Chapter 6. </span>Labels and Annotations</h1>
<p>Kubernetes was made to grow with you as your application scales in both size and complexity.<a data-primary="labels" data-type="indexterm" id="ix_lbl"/>  Labels and annotations are fundamental concepts in Kubernetes that let you work in sets of things that map to how <em>you</em> think about your application.  You can organize, mark, and cross-index all of your resources to represent the groups that make the most sense for your application.</p>
<p><em>Labels</em> are key/value pairs that can be attached to Kubernetes objects such as Pods and ReplicaSets. They can be arbitrary and are useful for attaching identifying information to Kubernetes objects. Labels provide the foundation for grouping objects.</p>
<p><em>Annotations</em>, on the other hand, provide a storage <a data-primary="annotations" data-type="indexterm" id="idm45664078601664"/>mechanism that resembles labels: key/value pairs designed to hold nonidentifying information that tools and libraries can leverage. Unlike labels, annotations are
not meant for querying, filtering, or otherwise differentiating Pods from each
other.</p>
<section data-pdf-bookmark="Labels" data-type="sect1"><div class="sect1" id="idm45664078600704">
<h1>Labels</h1>
<p>Labels provide identifying metadata for objects. These are fundamental qualities of the object that will be used for grouping, viewing, and operating. The motivations for labels grew out of Google’s experience in running large and complex applications.<a data-primary="labels" data-secondary="reasons for using" data-type="indexterm" id="idm45664078599008"/>  A couple of lessons emerged from this experience:</p>
<ul>
<li>
<p>Production abhors a singleton. When deploying software, users often start with a single instance.<a data-primary="singletons" data-type="indexterm" id="idm45664078596768"/>  However, as
the application matures, these singletons often multiply and become sets of objects. With this in mind, Kubernetes uses labels to deal with sets of objects instead of single instances.</p>
</li>
<li>
<p>Any hierarchy imposed by the system will fall short for many users.  In addition, user groupings and hierarchies change over time.  For instance, a user may start out with the idea that all apps are made up of many services. However, over time, a service may be shared across multiple apps.  Kubernetes labels are flexible enough to adapt to these situations and more.</p>
</li>
</ul>
<p>See the great site reliability book <a class="orm:hideurl" href="http://shop.oreilly.com/product/0636920041528.do"><em>Site Reliability Engineering</em></a> by Betsy Beyer et al. (O’Reilly) for deeper background on how Google approaches production 
<span class="keep-together">systems</span>.</p>
<p>Labels have simple syntax.<a data-primary="labels" data-secondary="key/value pairs, rules for" data-type="indexterm" id="idm45664078591808"/> They are key/value pairs, where both the key and value are represented by strings. Label keys can be broken down into two parts: an optional prefix and a name, separated by a slash. The prefix, if specified, must be a DNS subdomain with a 253-character limit. <a data-primary="DNS" data-secondary="subdomains, in label prefix" data-type="indexterm" id="idm45664078590736"/>The key name is required and have a maximum length of 63 characters. Names must also start and end with an alphanumeric character and permit the use of dashes (<code>-</code>), underscores (<code>_</code>), and dots (<code>.</code>) between characters.</p>
<p>Label values are strings with a maximum length of 63 characters. The contents of the label values follow the same rules as label keys. <a data-type="xref" href="#label_examples_table">Table 6-1</a> shows some valid label keys and values.</p>
<table id="label_examples_table">
<caption><span class="label">Table 6-1. </span>Label examples</caption>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>acme.com/app-version</code></p></td>
<td><p><code>1.0.0</code></p></td>
</tr>
<tr>
<td><p><code>appVersion</code></p></td>
<td><p><code>1.0.0</code></p></td>
</tr>
<tr>
<td><p><code>app.version</code></p></td>
<td><p><code>1.0.0</code></p></td>
</tr>
<tr>
<td><p><code>kubernetes.io/cluster-service</code></p></td>
<td><p><code>true</code></p></td>
</tr>
</tbody>
</table>
<p>When domain names are used in labels and annotations, they are expected to be aligned to that particular entity in some way.<a data-primary="domain names" data-secondary="in labels and annotations" data-secondary-sortas="labels" data-type="indexterm" id="idm45664078500208"/><a data-primary="annotations" data-secondary="domain names in" data-type="indexterm" id="idm45664078498992"/> For example, a project might define a canonical set of labels used to identify the various stages of application deployment such as staging, canary, and production.<a data-primary="cloud" data-secondary="provider-specific annotations" data-type="indexterm" id="idm45664078497920"/> Or a cloud provider might define provider-specific annotations that extend Kubernetes objects to activate features specific to their service.</p>
<section data-pdf-bookmark="Applying Labels" data-type="sect2"><div class="sect2" id="idm45664078496544">
<h2>Applying Labels</h2>
<p>Here we create a few deployments (a way to create an array of Pods) with some
interesting labels.<a data-primary="labels" data-secondary="applying" data-type="indexterm" id="idm45664078494800"/><a data-primary="deployments" data-secondary="creating for alpaca and bandicoot, using interesting labels" data-type="indexterm" id="idm45664078493824"/>  We’ll take two apps (called <code>alpaca</code> and <code>bandicoot</code>) and
have two environments and two versions for each.</p>
<p>First, create the <code>alpaca-prod</code> deployment and set the <code>ver</code>, <code>app</code>, and <code>env</code> labels:</p>
<pre data-type="programlisting">$ <strong>kubectl run alpaca-prod \
  --image=gcr.io/kuar-demo/kuard-amd64:blue \
  --replicas=2 \
  --labels="ver=1,app=alpaca,env=prod"</strong></pre>
<p>Next, create the <code>alpaca-test</code> deployment and set the <code>ver</code>, <code>app</code>, and <code>env</code> labels with the appropriate values:</p>
<pre data-type="programlisting">$ <strong>kubectl run alpaca-test \
  --image=gcr.io/kuar-demo/kuard-amd64:green \
  --replicas=1 \
  --labels="ver=2,app=alpaca,env=test"</strong></pre>
<p>Finally, create two deployments for <code>bandicoot</code>.  Here we name the
environments <code>prod</code> and <code>staging</code>:</p>
<pre data-type="programlisting">$ <strong>kubectl run bandicoot-prod \
  --image=gcr.io/kuar-demo/kuard-amd64:green \
  --replicas=2 \
  --labels="ver=2,app=bandicoot,env=prod"</strong>
$ <strong>kubectl run bandicoot-staging \
  --image=gcr.io/kuar-demo/kuard-amd64:green \
  --replicas=1 \
  --labels="ver=2,app=bandicoot,env=staging"</strong></pre>
<p>At this point, you should have four deployments—<code>alpaca-prod</code>, <code>alpaca-test</code>, <code>bandicoot-prod</code>, and <code>bandicoot-staging</code>:</p>
<pre data-type="programlisting">$ <strong>kubectl get deployments --show-labels</strong>

NAME                ... LABELS
alpaca-prod         ... app=alpaca,env=prod,ver=1
alpaca-test         ... app=alpaca,env=test,ver=2
bandicoot-prod      ... app=bandicoot,env=prod,ver=2
bandicoot-staging   ... app=bandicoot,env=staging,ver=2</pre>
<p>We can visualize this as a Venn diagram based on the labels (<a data-type="xref" href="#fig0601">Figure 6-1</a>).</p>
<figure><div class="figure" id="fig0601">
<img alt="" height="526" src="assets/kur3_0601.png" width="1287"/>
<h6><span class="label">Figure 6-1. </span>Visualization of labels applied to our deployments</h6>
</div></figure>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Modifying Labels" data-type="sect2"><div class="sect2" id="idm45664078495952">
<h2>Modifying Labels</h2>
<p>You can also apply or update labels on objects <a data-primary="labels" data-secondary="modifying" data-type="indexterm" id="idm45664078473008"/>after you create them:</p>
<pre data-type="programlisting">$ <strong>kubectl label deployments alpaca-test "canary=true"</strong></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>There is a caveat here. <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="label" data-type="indexterm" id="idm45664078469856"/>In this example, the <code>kubectl label</code> command will only change the label on the deployment itself; it won’t affect any objects that the deployment creates, such as ReplicaSets and Pods.  To change those, you’ll need to change the template embedded in the deployment (see <a data-type="xref" href="ch10.xhtml#deployments_chapter">Chapter 10</a>).</p>
</div>
<p>You can <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get deployments" data-type="indexterm" id="idm45664078466688"/>also use the <code>-L</code> option to <code>kubectl get</code> to show a label value as a column:</p>
<pre data-type="programlisting">$ <strong>kubectl get deployments -L canary</strong>

NAME                DESIRED   CURRENT   ... CANARY
alpaca-prod         2         2         ... &lt;none&gt;
alpaca-test         1         1         ... true
bandicoot-prod      2         2         ... &lt;none&gt;
bandicoot-staging   1         1         ... &lt;none&gt;</pre>
<p>You can remove a<a data-primary="dash-suffix, removing a label with" data-type="indexterm" id="idm45664078462528"/> label by applying a dash-suffix:</p>
<pre data-type="programlisting">$ <strong>kubectl label deployments alpaca-test "canary-"</strong></pre>
</div></section>
<section data-pdf-bookmark="Label Selectors" data-type="sect2"><div class="sect2" id="idm45664078460432">
<h2>Label Selectors</h2>
<p>Label selectors are used to filter Kubernetes objects based on a set of labels. Selectors use a simple syntax for Boolean expressions.<a data-primary="labels" data-secondary="label selectors" data-type="indexterm" id="ix_lblsel"/> They are used both by end users (via tools like <code>kubectl</code>) and by different types of objects (such as how a ReplicaSet relates to its Pods).<a data-primary="selectors (label)" data-see="labels" data-type="indexterm" id="idm45664078456544"/></p>
<p>Each deployment (via a ReplicaSet) creates a set of Pods using the labels specified in the template embedded in the deployment.<a data-primary="ReplicaSets" data-type="indexterm" id="idm45664078455008"/>  This is configured by the <code>kubectl run</code> command.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="run" data-type="indexterm" id="idm45664078453792"/></p>
<p>Running the <code>kubectl get pods</code> command should return all the Pods currently running in the cluster.<a data-primary="Pods" data-secondary="returning all currently running in a cluster with kubectl get pods" data-type="indexterm" id="idm45664078451680"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get pods" data-type="indexterm" id="idm45664078450736"/> We should have a total of six <code>kuard</code> Pods across our three <span class="keep-together">environments</span>:</p>
<pre data-type="programlisting">$ <strong>kubectl get pods --show-labels</strong>

NAME                              ... LABELS
alpaca-prod-3408831585-4nzfb      ... app=alpaca,env=prod,ver=1,...
alpaca-prod-3408831585-kga0a      ... app=alpaca,env=prod,ver=1,...
alpaca-test-1004512375-3r1m5      ... app=alpaca,env=test,ver=2,...
bandicoot-prod-373860099-0t1gp    ... app=bandicoot,env=prod,ver=2,...
bandicoot-prod-373860099-k2wcf    ... app=bandicoot,env=prod,ver=2,...
bandicoot-staging-1839769971-3ndv ... app=bandicoot,env=staging,ver=2,...</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You may see a new label that you haven’t seen before: <code>pod-template-hash</code>.  This label<a data-primary="pod-template-hash label" data-type="indexterm" id="idm45664078445632"/> is applied by the deployment so it can keep track of which Pods were
generated from which template versions.  This allows the deployment to manage updates cleanly, as will be covered in depth in <a data-type="xref" href="ch10.xhtml#deployments_chapter">Chapter 10</a>.</p>
</div>
<p>If we want to list<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get pods" data-type="indexterm" id="idm45664078443424"/> only Pods that have the <code>ver</code> label set to <code>2</code>, we
could use the <code class="keep-together">--selector</code> flag:</p>
<pre data-type="programlisting">$ <strong>kubectl get pods --selector="ver=2"</strong>

NAME                                 READY     STATUS    RESTARTS   AGE
alpaca-test-1004512375-3r1m5         1/1       Running   0          3m
bandicoot-prod-373860099-0t1gp       1/1       Running   0          3m
bandicoot-prod-373860099-k2wcf       1/1       Running   0          3m
bandicoot-staging-1839769971-3ndv5   1/1       Running   0          3m</pre>
<p>If we specify two selectors separated by a comma, only the objects that satisfy both will be returned.  This is a logical AND operation:</p>
<pre data-type="programlisting">$ <strong>kubectl get pods --selector="app=bandicoot,ver=2"</strong>

NAME                                 READY     STATUS    RESTARTS   AGE
bandicoot-prod-373860099-0t1gp       1/1       Running   0          4m
bandicoot-prod-373860099-k2wcf       1/1       Running   0          4m
bandicoot-staging-1839769971-3ndv5   1/1       Running   0          4m</pre>
<p>We can also ask if a label is one of a set of values.  Here we ask for all Pods where the <code>app</code> label is set to <code>alpaca</code> or <code>bandicoot</code> (which will be all six Pods):</p>
<pre data-type="programlisting">$ <strong>kubectl get pods --selector="app in (alpaca,bandicoot)"</strong>

NAME                                 READY     STATUS    RESTARTS   AGE
alpaca-prod-3408831585-4nzfb         1/1       Running   0          6m
alpaca-prod-3408831585-kga0a         1/1       Running   0          6m
alpaca-test-1004512375-3r1m5         1/1       Running   0          6m
bandicoot-prod-373860099-0t1gp       1/1       Running   0          6m
bandicoot-prod-373860099-k2wcf       1/1       Running   0          6m
bandicoot-staging-1839769971-3ndv5   1/1       Running   0          6m</pre>
<p>Finally, we can ask if a label is set at all.<a data-primary="canary label" data-type="indexterm" id="idm45664078433952"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get deployments" data-type="indexterm" id="idm45664078433248"/>  Here we are asking for all of the deployments with the <code>canary</code> label set to anything:</p>
<pre data-type="programlisting">$ <strong>kubectl get deployments --selector="canary"</strong>

NAME          DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
alpaca-test   1         1         1            1           7m</pre>
<p>There are also “negative” versions of each <a data-primary="selector operators" data-type="indexterm" id="idm45664078429696"/><a data-primary="labels" data-secondary="label selectors" data-tertiary="label operators" data-type="indexterm" id="idm45664078428992"/>of these, as shown in <a data-type="xref" href="#selector-operators-table">Table 6-2</a>.</p>
<table id="selector-operators-table">
<caption><span class="label">Table 6-2. </span>Selector operators</caption>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>key=value</code></p></td>
<td><p><code>key</code> is set to <code>value</code></p></td>
</tr>
<tr>
<td><p><code>key!=value</code></p></td>
<td><p><code>key</code> is not set to <code>value</code></p></td>
</tr>
<tr>
<td><p><code>key in (value1, value2)</code></p></td>
<td><p><code>key</code> is one of <code>value1</code> or <code>value2</code></p></td>
</tr>
<tr>
<td><p><code>key notin (value1, value2)</code></p></td>
<td><p><code>key</code> is not one of <code>value1</code> or <code>value2</code></p></td>
</tr>
<tr>
<td><p><code>key</code></p></td>
<td><p><code>key</code> is set</p></td>
</tr>
<tr>
<td><p><code>!key</code></p></td>
<td><p><code>key</code> is not set</p></td>
</tr>
</tbody>
</table>
<p>For example, asking if a key, in this case <code>canary</code>, is not set <a data-primary="labels" data-secondary="label selectors" data-tertiary="negative and positive versions of" data-type="indexterm" id="idm45664078408544"/>can look like:</p>
<pre data-type="programlisting">$ <strong>kubectl get deployments --selector='!canary'</strong></pre>
<p>You can combine positive and negative selectors:</p>
<pre data-type="programlisting">$ <strong>kubectl get pods -l 'ver=2,!canary'</strong></pre>
</div></section>
<section data-pdf-bookmark="Label Selectors in API Objects" data-type="sect2"><div class="sect2" id="idm45664078459520">
<h2>Label Selectors in API Objects</h2>
<p>A Kubernetes object uses a label selector to refer to a set of other Kubernetes objects.<a data-primary="Kubernetes objects" data-secondary="label selectors in" data-type="indexterm" id="idm45664078403472"/><a data-primary="labels" data-secondary="label selectors" data-tertiary="in API objects" data-tertiary-sortas="API" data-type="indexterm" id="idm45664078402496"/>  Instead of a simple string as described in the previous section, we use a parsed structure.</p>
<p>For historical reasons (Kubernetes doesn’t break API compatibility!), there are two forms. Most objects support a newer, more powerful set of selector operators. A selector of <code>app=alpaca,ver in (1, 2)</code> would be converted to this:</p>
<pre data-type="programlisting">selector:
  matchLabels:
    app: alpaca
  matchExpressions:
    - {key: ver, operator: In, values: [1, 2]}</pre>
<p>This example uses compact YAML syntax.  This is an item in a list
(<span class="keep-together"><code>matchExpressions</code></span>) that is a map with three entries.  The last entry (<code>values</code>) has a value that is a list with two items. All of the terms are evaluated as a logical AND.  The only way to represent the <code>!=</code> operator is to convert it to a <code>NotIn</code> expression with a single value.<a data-primary="NotIn expression, using to represent != operator" data-type="indexterm" id="idm45664078396080"/></p>
<p>The older form of specifying selectors (used in <code>ReplicationController</code>s and services) only supports the <code>=</code> operator.<a data-primary="equals operator (=) in older label selectors" data-type="indexterm" id="idm45664078393840"/>  The <code>=</code> operator selects target objects where its set of key/value pairs all match the object. The selector <code>app=alpaca,ver=1</code> would be represented like this:</p>
<pre data-type="programlisting">selector:
  app: alpaca
  ver: 1</pre>
</div></section>
<section data-pdf-bookmark="Labels in the Kubernetes Architecture" data-type="sect2"><div class="sect2" id="idm45664078391200">
<h2>Labels in the Kubernetes Architecture</h2>
<p>In addition to <a data-primary="labels" data-secondary="label selectors" data-startref="ix_lblsel" data-type="indexterm" id="idm45664078389904"/>enabling users to organize their infrastructure, labels play a
critical role in linking various related Kubernetes objects.<a data-primary="labels" data-secondary="in the Kubernetes architecture" data-secondary-sortas="Kubernetes" data-type="indexterm" id="idm45664078388352"/> Kubernetes is a purposefully decoupled system. There is no hierarchy and all components operate independently. However, in many cases, objects need to relate to one another, and these relationships are defined by labels and label selectors.</p>
<p>For example, ReplicaSets, which create and maintain multiple replicas of a Pod, find the Pods that they are managing via a selector.<a data-primary="ReplicaSets" data-secondary="using label selector to find Pods they’re managing" data-type="indexterm" id="idm45664078386160"/> Likewise, a service load balancer finds the Pods to which it should bring traffic via a selector query. When a Pod is created, it can use a node selector to identify a particular set of nodes onto which it can be scheduled. When people want to restrict network traffic in their cluster, they use Network Policy in conjunction with specific labels to identify Pods that should or should not be allowed to communicate with each other.</p>
<p>Labels are a powerful and ubiquitous glue that holds a Kubernetes application together. Though your application will likely start out with a simple set of labels and queries, you should expect it to grow in size and sophistication with time.<a data-primary="labels" data-startref="ix_lbl" data-type="indexterm" id="idm45664078384384"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Annotations" data-type="sect1"><div class="sect1" id="idm45664078600112">
<h1>Annotations</h1>
<p>Annotations provide a place to store additional metadata for Kubernetes objects where the sole purpose of the metadata is assisting tools and libraries.<a data-primary="annotations" data-type="indexterm" id="ix_anno"/>  They are a way for other programs driving Kubernetes via an API to store some opaque data with an object.  Annotations can be used for the tool itself or to pass configuration information between external systems.</p>
<p>While labels are used to identify and group objects, annotations are used to provide extra information about where an object came from, how to use it, or policy around that object.  There is overlap, and it is a matter of taste as to when to use an annotation or a label.  When in doubt, add information to an object as an annotation and promote it to a label if you find yourself wanting to use it in a selector.</p>
<p>Annotations are used to:</p>
<ul>
<li>
<p>Keep track of a “reason” for the latest update to an object.</p>
</li>
<li>
<p>Communicate a specialized scheduling policy to a specialized scheduler.</p>
</li>
<li>
<p>Extend data about the last tool to update the resource and how it was
updated (used for detecting changes by other tools and doing a smart
merge).</p>
</li>
<li>
<p>Attach build, release, or image information that isn’t appropriate for labels (may include a Git hash, timestamp, pull request number, etc.).</p>
</li>
<li>
<p>Enable the Deployment object (see <a data-type="xref" href="ch10.xhtml#deployments_chapter">Chapter 10</a>) to keep track of ReplicaSets that it is managing for rollouts.</p>
</li>
<li>
<p>Provide extra data to enhance the visual quality or usability of a UI.  For example, objects could include a link to an icon (or a base64-encoded version of an icon).</p>
</li>
<li>
<p>Prototype alpha functionality in Kubernetes (instead of creating a first-class API field, the parameters for that functionality are encoded in an annotation).</p>
</li>
</ul>
<p>Annotations are used in various places in Kubernetes, with the primary use case being rolling deployments. During rolling deployments, annotations are used to track rollout status and provide the necessary information required to roll back a deployment to a previous state.</p>
<p>Avoid using the Kubernetes API server as a general-purpose
database.  Annotations are good for small bits of data that are highly
associated with a specific resource.  If you want to store data in Kubernetes but you don’t have an obvious object to associate it with, consider storing that data in some other, more appropriate <span class="keep-together">database</span>.</p>
<p>Annotation keys use the same format as label keys. However, because they are often used to communicate information between tools, the “namespace” part of the key is more important.  Example keys include <code>deployment.kubernetes.io/revision</code> or <code>kubernetes.io/change-cause</code>.</p>
<p>The value component of an annotation is a free-form string field. While this allows maximum flexibility as users can store arbitrary data, because this is arbitrary text, there is no validation of any format.  For example, it is not uncommon for a JSON document to be encoded as a string and stored in an annotation. It is important to note that the Kubernetes server has no knowledge of the required format of annotation values. If annotations are used to pass or store data, there is no guarantee the data is valid. This can make tracking down errors more difficult.</p>
<p>Annotations are defined in the common <code>metadata</code> section in every Kubernetes object:</p>
<pre data-type="programlisting">...
metadata:
  annotations:
    example.com/icon-url: "https://example.com/icon.png"
...</pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Annotations are very convenient and provide powerful loose coupling, but use them judiciously to avoid an untyped mess of data.</p>
</div>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Cleanup" data-type="sect1"><div class="sect1" id="idm45664078382688">
<h1>Cleanup</h1>
<p>It is easy to clean up all of the deployments that we started in this chapter:</p>
<pre data-type="programlisting">$ <strong>kubectl delete deployments --all</strong></pre>
<p>If you want to be more selective, you can use the <code>--selector</code> flag to choose which deployments to delete.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="delete deployments --all" data-type="indexterm" id="idm45664078360432"/></p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45664078358864">
<h1>Summary</h1>
<p>Labels are used to identify and optionally group objects in a Kubernetes
cluster. <a data-primary="labels" data-type="indexterm" id="idm45664078357568"/>They are also used in selector queries to provide flexible runtime grouping of objects, such as Pods.</p>
<p>Annotations provide object-scoped key/value metadata storage used by automation tooling and client libraries. They can also be used to hold configuration data for external tools such as third-party schedulers and monitoring tools.</p>
<p>Labels and annotations are vital to understanding how key components in a
Kubernetes cluster work together to ensure the desired cluster state. Using them properly unlocks the true power of Kubernetes’s flexibility and provides a starting point for building automation tools and deployment workflows.<a data-primary="annotations" data-startref="ix_anno" data-type="indexterm" id="idm45664078355584"/></p>
</div></section>
</div></section></div></body></html>