- en: Chapter 5\. Sharding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a single instance of MySQL, performance depends on queries, data, access
    patterns, and hardware. When direct and indirect query optimization—assiduously
    applied—no longer deliver acceptable performance, you have reached the relative
    limit of single-instance MySQL performance for the application workload. To surpass
    that relative limit, you must divide the application workload across multiple
    instances of MySQL to achieve MySQL at scale.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*Sharding* a database is the common and widely used technique of *scaling out*
    (or, *horizontal scaling*): increasing performance by distributing the workload
    across multiple databases. (By contrast, *scaling up*, or *vertical scaling*,
    increases performance by increasing hardware capacity.) Sharding divides one database
    into many databases. Each database is a shard, and each shard is typically stored
    on a separate MySQL instance running on separate hardware. Shards are physically
    separate but logically the same (very large) database.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL at scale requires sharding. I’m going to repeat that sentence several
    times in this chapter because it’s a fact that engineers hesitate to accept. Why?
    Because sharding is not an intrinsic feature or capability of MySQL. Consequently,
    sharding is complex and entirely application-specific, which means there’s no
    easy solution. But don’t be discouraged: sharding is a solved problem. Engineers
    have been scaling out MySQL for decades.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces the basic mechanics of sharding to achieve MySQL at
    scale. There are four major sections. The first explains why a single database
    does not scale—why sharding is necessary. The second completes the analogy from
    Chapters [3](ch03.html#ch03) and [4](ch04.html#ch04): why pebbles (database shards)
    are better than boulders (huge databases). The third is a brief introduction to
    the complex topic of relational database sharding. The fourth presents alternatives
    to sharding.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Why a Single Database Does Not Scale
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nobody questions that a single application can overload a single server—that’s
    why scaling out is necessary for all types of servers and applications, not just
    MySQL. Sharding is therefore necessary because it’s how MySQL scales out: more
    databases. But it’s reasonable to wonder why a single MySQL database does not
    scale given that very powerful hardware is available and some benchmarks demonstrate
    incredible performance on that hardware. Five reasons follow, beginning with the
    most fundamental: the application workload can significantly outpace the speed
    and capacity of single-server hardware.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Application Workload
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 5-1](#hw-no-load) is a simple illustration of hardware capacity on
    a single server with zero load.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0501](assets/emsp_0501.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Hardware without load
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 5-1](#hw-no-load) is intentionally simple—but not simplistic—because
    it subtly conveys a critically important point: *hardware capacity is finite and
    limited*. The circle represents the limits of the hardware. Let’s presume the
    hardware is dedicated to running a single MySQL instance for one application—no
    virtualization, crypto coin mining, or other load. Everything that runs on the
    hardware must fit inside the circle. Since this is dedicated hardware, the only
    thing running on it is the application workload shown in [Figure 5-2](#hw-normal-load):
    queries, data, and access patterns.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0502](assets/emsp_0502.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Hardware with standard MySQL workload
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It’s no coincidence that *Queries* refer to [Chapter 2](ch02.html#ch02), *Data*
    to [Chapter 3](ch03.html#ch03), and *Access Patterns* to [Chapter 4](ch04.html#ch04).
    These constitute the application workload: everything that causes load on MySQL
    which, in turn, causes load on the hardware (CPU utilization, disk I/O, and so
    forth). The box sizes are important: the bigger the box, the bigger the load.
    In [Figure 5-2](#hw-normal-load), the workload is within the capacity of the hardware,
    with a little room to spare because the operating system needs hardware resources,
    too.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Queries, data, and access patterns are inextricable with respect to performance.
    (I proved this with `TRUNCATE TABLE` in [“Indirect Query Optimization”](ch01.html#indirect-query-optimization).)
    Data size is a common reason for scaling out because, as shown in [Figure 5-3](#hw-too-much-data),
    it causes the workload to exceed the capacity of a single server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0503](assets/emsp_0503.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Hardware with too much data
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Data size cannot increase without eventually affecting queries and access patterns.
    Buying a bigger hard drive won’t solve the problem because, as [Figure 5-3](#hw-too-much-data)
    shows, there’s plenty of capacity for the data, but the data is not the only part
    of the workload.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](#hw-all-data) illustrates a common misconception that leads engineers
    to think that a single database can scale to maximum data size, which is currently
    64 TB for a single InnoDB table.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0504](assets/emsp_0504.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Hardware with only data (scaling misconception)
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Data is only one part of the workload, and the other two parts (queries and
    access patterns) cannot be ignored. Realistically, for acceptable performance
    with a lot of data on a single sever, the workload must look like [Figure 5-5](#hw-large-data).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0505](assets/emsp_0505.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. Hardware with large data
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the queries are simple and have exceptionally good indexes, and the access
    patterns are trivial (for example, very low-throughput reads), then a single server
    can store a lot of data. This isn’t just a clever illustration; real applications
    have workloads like [Figure 5-5](#hw-large-data).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: These five illustrations reveal that a single database cannot scale because
    the application workload—which comprises queries, data, and access patterns—must
    fit within the capacity of the hardware. After [“Better, Faster Hardware!”](ch02.html#better-faster-hardware)
    and [“Better, Faster Hardware?”](ch04.html#better-faster-hardware-again), you
    already know that hardware won’t solve this problem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: MySQL at scale requires sharding because application workloads can significantly
    outpace the speed and capacity of single-server hardware.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks Are Synthetic
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Benchmarks use synthetic (fake) queries, data, and access patterns. These are
    necessarily fake because they’re not real applications and certainly not your
    application. Therefore, benchmarks cannot tell you—or even suggest—how your application
    will perform and scale—even on the same hardware. Moreover, benchmarks largely
    focus on one or more access pattern (see [“Data Access Patterns”](ch04.html#access-patterns)),
    which produces a workload like the one pictured in [Figure 5-6](#hw-benchmark).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0506](assets/emsp_0506.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6\. Hardware with benchmark workload
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most applications don’t have a workload where performance is dominated by one
    or more access pattern. But it’s common for benchmarks because it allows MySQL
    experts to stress and measure a particular aspect of MySQL. For example, if a
    MySQL expert wants to measure the effectiveness of a new page flushing algorithm,
    they might use a 100% write-only workload with a few perfectly optimized queries
    and very little data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'But let me be perfectly clear: benchmarks are important and necessary for MySQL
    experts and the MySQL industry. (As mentioned in [“MySQL Tuning”](ch02.html#mysql-tuning),
    benchmarking is laboratory work.) Benchmarks are used to do the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Compare hardware (one storage device against another)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare server optimizations (one flushing algorithm against another)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare different data stores (MySQL versus PostgreSQL—the classic rivalry)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test MySQL at the limit (see [“Performance Destabilizes at the Limit”](ch04.html#perf-at-the-limit))
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That work is incredibly important for MySQL, and it’s why MySQL is capable
    of amazing performance. But conspicuously absent from that list is anything related
    to your application and its particular workload. Consequently, whatever amazing
    MySQL performance you read or hear about in benchmarks will not translate to your
    application, and the very same experts producing those benchmarks will tell you:
    MySQL at scale requires sharding.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Writes
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writes are difficult to scale on a single MySQL instance for several reasons:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Single writable (source) instance
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'For high availability, MySQL in production employs several instances connected
    in a replication topology. But writes are effectively limited to a single MySQL
    instance to avoid *write conflicts*: multiple writes to the same row at the same
    time. MySQL supports multiple writable instances, but you will have a difficult
    time finding anyone who uses this feature because write conflicts are too troublesome.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Transactions and locking
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Transactions use locking to guarantee consistency—the *C* in an ACID-compliant
    database. Writes must acquire row locks, and sometimes they lock significantly
    more rows than you might expect—[“Row Locking”](ch08.html#row-locking) explains
    why. Locks lead to lock contention, which makes access pattern trait [“Concurrency”](ch04.html#ap-concurrency)
    a critical factor in how well writes scale. If the workload is write-heavy on
    the same data, even the best hardware in the world won’t help.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Page flushing (durability)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '*Page flushing* is the delayed process by which MySQL persists changes (from
    writes) to disk. The entire process is too complex to explain in this section,
    but the salient point is: page flushing is the bottleneck of write performance.
    Although MySQL is very efficient, the process is inherently slow because it must
    ensure that data is *durable*: persisted to disk. Without durability, writes are
    incredibly fast due to caching, but durability is a requirement because all hardware
    crashes eventually.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Write amplification
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '*Write amplification* refers to writes requiring more writes. Secondary indexes
    are the simplest example. If a table has 10 secondary indexes, a single write
    could write 10 additional writes to update those indexes. Page flushing (durability)
    incurs additional writes, and replication incurs even more writes. This is not
    unique to MySQL; it affects other data stores, too.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Replication
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Replication is required for high availability, so all writes must replicate
    to other MySQL instances—replicas. [Chapter 7](ch07.html#ch07) addresses replication,
    but here are a few salient points with respect to scaling writes. MySQL supports
    asynchronous replication, semisynchronous replication, and [Group Replication](https://oreil.ly/oeJtD).
    Asynchronous replication has a small effect on write performance because data
    changes are written and flushed to binary logs on transaction commit—but after
    that, there’s no effect. Semisynchronous replication has a greater effect on write
    performance: it attenuates transaction throughput to network latency because every
    commit must be acknowledged by at least one replica. Since network latency measures
    in milliseconds, the effect on write performance is noticeable, but it’s a worthwhile
    trade-off because it guarantees that no committed transactions are lost, which
    is not true for asynchronous replication. Group Replication is more complex and
    it’s more difficult to scale writes. For various reasons explained in [Chapter 7](ch07.html#ch07),
    I do not cover Group Replication in this book.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: These five reasons are formidable challenges to scaling writes on a single MySQL
    instance—even for MySQL experts. MySQL at scale requires sharding to overcome
    these challenges and scale write performance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Schema Changes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Schema changes are more than routine; they’re practically required. Furthermore,
    it’s not uncommon for the largest tables to change frequently because their size
    reflects their usage, and usage leads to development, which leads to changes.
    Even if you manage to overcome all other obstacles and scale a single table to
    an enormous size, the time required to change that table will be untenable. How
    long? It can take days or weeks to alter a large table.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The long wait is not a problem for MySQL or the application because online schema
    change (OSC) tools like [pt-online-schema-change](https://oreil.ly/tSrrr) and
    [`gh-ost`](https://oreil.ly/nUuvv) and certain built-in [online DDL operations](https://oreil.ly/5KiA7)
    can run for days or weeks while allowing the application to function normally—​which
    is why they’re called *online*. But it is a problem for engineers developing the
    application because waiting that long does not go unnoticed; rather, it tends
    to become an increasingly annoying blocker to you, other engineers, and possibly
    other teams.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, just a few weeks ago I helped a team alter several tables, each
    with one *billion* rows, that had failed to complete after nearly two weeks of
    trying (for various technical reasons not related to MySQL). The blocker went
    far beyond the table or the team: long story short, it blocked an organization-level
    goal—months of work by several other teams. Luckily, the needed schema change
    happened to be an instant [online DDL operation](https://oreil.ly/5KiA7). But
    instant schema changes are exceedingly rare, so don’t count on them. Instead,
    don’t let a table become so large that you cannot alter it in a reasonable amount
    of time—whatever you, your team, and your company deem *reasonable*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: MySQL at scale requires sharding because engineers cannot wait days or weeks
    to change a schema.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you directly and indirectly optimize queries with exacting precision and
    unmitigated meticulousness, you can scale up a single database to a size that
    people won’t believe until you show them. But the illustrations of hardware and
    workload in [“Application Workload”](#scale-up-app-workload) do not depict the
    following *operations* (or *ops* as they’re more commonly called):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Backup and restore
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebuilding failed instances
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading MySQL
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL shutdown, startup, and crash recovery
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The larger the database, the longer those operations take. As an application
    developer, you might not manage any of those operations, but they will affect
    you unless the engineers managing the database are exceptionally adept at—and
    deeply committed to—zero-downtime operations. Cloud providers, for example, are
    neither adept nor committed; they only attempt to minimize downtime, which can
    mean anything from 20 seconds to hours of the database being offline.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL at scale requires sharding to efficiently manage the data, which leads
    us to the next section: pebbles, not boulders.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Pebbles, Not Boulders
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s significantly easier to move pebbles than boulders. I belabor this analogy
    because it’s apt: MySQL at scale is achieved by using many small instances. (To
    refresh your memory on the analogy, read the introductory sections of Chapters
    [3](ch03.html#ch03) and [4](ch04.html#ch04).)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '*Small*, in this context, means two things:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The application workload runs with acceptable performance on the hardware.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard operations (including OSC) take an acceptable amount of time.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At first glance, that makes *small* seem so relative that it’s useless, but
    in practice the limited range of hardware capacity significantly narrows the scope
    to an almost objective measure. For example, at the time of this writing, I advise
    engineers to limit the total data size of a single MySQL instance to 2 or 4 TB:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 2 TB
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: For average queries and access patterns, commodity hardware is sufficient for
    acceptable performance, and operations complete in reasonable time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 4 TB
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: For exceptionally optimized queries and access patterns, mid- to high-end hardware
    is sufficient for acceptable performance, but operations might take slightly longer
    than acceptable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经过特别优化的查询和访问模式，中高端硬件足以保证可接受的性能，但操作可能比预期稍慢一些。
- en: These limits only reflect the hardware capacity that you can readily purchase
    today (December 2021). Years ago, the limits were significantly lower. (Remember
    when disks would physically spin and make crackling sounds? Weird.) Years from
    now, the limits will be significantly greater.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制仅反映了您可以随时购买的硬件容量（2021年12月）。多年前，限制显著较低。（还记得磁盘物理旋转并发出咔哒声的时候吗？奇怪。）多年后，限制将显著增加。
- en: 'Once a database is sharded, the number of shards is trivial to the application
    because it accesses them programmatically. But to operations—especially the engineers
    operating the MySQL instances—the *size* of shards is critically important: it’s
    significantly easier to manage a 500 GB database than a 7 TB database. And since
    operations are automated, it’s easy to mange any number of small databases.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据库被分片，应用程序对分片数量的访问是程序化的。但对于运维人员——尤其是操作MySQL实例的工程师来说——分片的*大小*至关重要：管理一个500GB数据库比管理一个7TB数据库要容易得多。由于运维是自动化的，管理任意数量的小数据库也很容易。
- en: MySQL performance is truly unlimited when sharded and operated as many small
    databases—pebbles, not boulders.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL在进行分片和操作许多小数据库（鹅卵石而非巨石）时的性能确实是无限的。
- en: 'Sharding: A Brief Introduction'
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分片：简介
- en: The solution and implementation of sharding are necessarily coupled to the application
    workload. This is true even for the alternative solutions presented in the next
    section, [“Alternatives”](#shard-alt). Consequently, no one can tell you how to
    shard, and there are no fully-automated solutions. Prepare for a long but worthwhile
    journey.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 分片的解决方案和实施与应用程序工作负载紧密相关。即使是下一节提到的替代解决方案[“替代方案”](#shard-alt)，情况也是如此。因此，没有人可以告诉您如何进行分片，并且没有完全自动化的解决方案。做好漫长但值得的旅程准备。
- en: 'Sharding has two paths from idea to implementation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 分片有两种从想法到实施的路径：
- en: Designing a new application for sharding
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 设计用于分片的新应用程序
- en: The first and rarest path is when an application is designed from the beginning
    for sharding. If you’re developing a new application, I highly encourage you to
    take this path *if needed* because it’s incomparably easier to shard from the
    start than to migrate later.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种也是最罕见的路径是从一开始就为分片设计应用程序。如果您正在开发新应用程序，我强烈建议您选择*如果需要*采用这种方法，因为从一开始进行分片比以后迁移要容易得多。
- en: 'To determine whether sharding is needed, estimate data size and growth for
    the next four years. If the estimated data size in four years fits within the
    capacity of your hardware *today*, then sharding might not be needed. I call this
    the *four-year fit*. Also try to estimate the four-year fit for the other two
    aspects of the application workload: queries and access patterns. These are difficult
    to estimate (and likely to change) for a new application, but you should have
    some ideas and expectations because they’re a necessary part of designing and
    implementing an application.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定是否需要分片，请估算未来四年的数据大小和增长情况。如果估算的四年后数据大小仍在您*今天*硬件的容量范围内，则可能不需要分片。我称之为*四年适配*。还要尝试估算应用工作负载的另外两个方面的四年适配：查询和访问模式。对于新应用程序来说，这些很难估算（而且可能会变化），但您应该有一些想法和期望，因为它们是设计和实施应用程序的必要部分。
- en: 'Also consider whether the data set is bounded or unbounded. A *bounded data
    set* has an intrinsic maximum size or intrinsically slow growth. For example,
    the number of new smart phones released every year is very small, and its growth
    is intrinsically slow because there’s no reason to believe that manufacturers
    will ever release thousands of new phones per year. An *unbounded data set* has
    no intrinsic limits. For example, pictures are unbounded: people can post unlimited
    pictures. Since hardware capacity is bounded, applications should always define
    and impose extrinsic limits on unbounded data sets. Never let data grow unbounded.
    An unbounded data set strongly indicates the need for sharding, unless old data
    is frequently deleted or archived (see [“Delete or Archive Data”](ch03.html#delete-or-archive)).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Migrating an existing application to sharding
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The second and more common path is migrating an existing database and application
    to sharding. This path is significantly more difficult, time-consuming, and risky
    because, by the time it’s required, the database is large—MySQL is hauling a boulder
    uphill. With a team of experienced developers, plan for the migration to take
    a year or longer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, I cannot cover how to migrate a single database to a sharded
    database because it’s a bespoke process: it depends on the sharding solution and
    application workload. But one thing is certain: you will copy data from the original
    (single) database to the new shards—probably many times—because the initial migration
    is essentially the first resharding, which is a challenge addressed in [“Resharding”](#resharding).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Sharding is a complex process for either path. To begin, choose a shard key
    and strategy, and understand the challenges that you will face. This knowledge
    gives the journey a destination: a sharded database that you can operate with
    relative ease. Then chart a path from one database to that destination.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Shard Key
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To shard MySQL, the application must programmatically map data to shards. Therefore,
    the most fundamental decision is the *shard key*: the column (or columns) by which
    the data is sharded. The shard key is used with a sharding strategy (discussed
    in the next section) to map data to shards. The application, not MySQL, is responsible
    for mapping and accessing data by shard key because MySQL has no built-in concept
    of sharding—MySQL is oblivious to sharding.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The term *shard* is used interchangeably for the database or the MySQL instance
    where the database is stored.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'An ideal shard key has three properties:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '*High cardinality*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'An ideal shard key has high cardinality (see [“Extreme Selectivity”](ch02.html#extreme-selectivity))
    so that data is evenly distributed across shards. A great example is a website
    that lets you watch videos: it could assign each video a unique identifier like
    `dQw4w9WgXcQ`. The column that stores that identifier is an ideal shard key because
    every value is unique, therefore cardinality is maximal.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '*Reference application entities*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'An ideal shard key references application entities so that access patterns
    do *not* cross shards. A great example is an application that stores payments:
    although each payment is unique (maximal cardinality), the customer is the application
    entity. Therefore, the primary access pattern for the application is by customer,
    not by payment. Sharding by customer is ideal because all payments for a single
    customer should be located on the same shard.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '*Small*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'An ideal shard key is as small as possible because it’s heavily used: most—if
    not all—queries include the shard key to avoid scatter queries—one of several
    [“Challenges”](#sharding-challenges).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'It should go without saying, but to ensure that it has been said: an ideal
    shard key, in combination with the sharding strategy, avoids or mitigates the
    [“Challenges”](#sharding-challenges), especially transactions and joins.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Spend ample time to identify or create the ideal shard key for your application.
    This decision is half of the foundation: the other half is the sharding strategy
    that uses the shard key.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Strategies
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sharding strategy maps data to shards by shard key value. The application
    implements the sharding strategy to route queries to the shard with the data corresponding
    to the shard key value. This decision is the other half of the foundation. Once
    the shard key and strategy are implemented, it’s exceedingly difficult to change,
    so choose very carefully.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three common strategies: hash, range, and lookup (or directory).
    All three are widely used. The best choice depends on the application access patterns—especially
    row access (see [“Row Access”](ch04.html#ap-row-access)), as mentioned in the
    next three sections.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Hash
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hash sharding maps hash key values to shards using a hashing algorithm (to produce
    an integer hash value), the modulo operator (`mod`), and the number of shards
    (`N`). [Figure 5-7](#hash-sharding-img) depicts the strategy starting with the
    hash key value at top and following the solid arrows to a shard at bottom.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0507](assets/emsp_0507.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7\. Hash sharding
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A hashing algorithm outputs a hash value using the shard key value as input.
    The hash value (which is an integer) `mod` the number of shards (`N`) returns
    the shard number: an integer between zero and N – 1, inclusive. In [Figure 5-7](#hash-sharding-img),
    the hash value `75482 mod 3 = 2`, so the data for the shard key value is located
    on shard `2`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: How to map shard numbers to MySQL instances is your choice. For example, you
    could deploy a map of shard numbers to MySQL hostnames with each application instance.
    Or, applications could query a service like [etcd](https://etcd.io) to discover
    how shard numbers map to MySQL instances.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re thinking, “Won’t changing the number of shards (`N`) affect the mapping
    of data to shards?” you are correct. For example, `75483 mod 3 = 0`, but increase
    the number of shards to five and the same shard key value maps to a new shard
    number: `75483 mod 5 = 3`. Luckily, this is a solved problem: a *consistent hashing
    algorithm* outputs a consistent hash value independent of `N`. The key word is
    *consistent*: it’s still possible, but far less likely, that hash values will
    change when shards change. Since shards are likely to change, you should choose
    a consistent hashing algorithm.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Hash sharding works for all shard keys because it abstracts the value to an
    integer. That doesn’t mean it’s better or faster, only that it’s easier because
    the hashing algorithm automatically maps all shard key values. However, *automatically*
    is also its downside because, as [“Rebalancing”](#rebalancing) discusses, it’s
    virtually impossible to manually relocate data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Point access (see [“Row Access”](ch04.html#ap-row-access)) works well with hash
    sharding because one row can map to only one shard. By contrast, range access
    is probably infeasible with hash sharding—unless the ranges are *very* small—because
    of [“Cross-shard queries”](#cross-shard-queries) (one of the common challenges).
    Random access is probably infeasible, too, for the same reason.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Range
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Range sharding defines contiguous key value ranges and maps a shard to each,
    as depicted in [Figure 5-8](#range-sharding-img).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0508](assets/emsp_0508.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. Range sharding
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You must define the key value ranges in advance. This gives you flexibility
    when mapping data to shards, but it requires a thorough knowledge of data distribution
    to ensure that the data is evenly distributed across shards. Since data distribution
    changes, expect to deal with resharding (see [“Resharding”](#resharding)). A benefit
    to range sharding is that, unlike hash sharding, you can change (redefine) the
    ranges, which helps to manually relocate data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'All data can be sorted and divided into ranges, but this doesn’t make sense
    for some data, like random identifiers. And some data appears random but, upon
    closer inspection, is actually closely ordered. For example, here are three UUIDs
    generated by MySQL:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Can you spot the differences? Those three UUIDs appear random but would most
    likely sort into the same range, depending on the range size. At scale, this would
    map most data to the same shard, thereby defeating the purpose of sharding. (UUID
    algorithms vary: some intentionally generate closely ordered values, while others
    intentionally generate randomly ordered values.)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Range sharding works best when:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The range of shard key values is bounded
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can determine the range (minimum and maximum values)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You know the distribution of values, and it’s mostly even
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range and distribution are unlikely to change
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, stock data could be sharded by stock symbols ranging from `AAAA`
    to `ZZZZ`. Although the distribution is probably less in the `Z` range, overall
    it will be even enough to ensure that one shard is not significantly larger or
    accessed more frequently than the other shards.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Point access (see [“Row Access”](ch04.html#ap-row-access)) works well with
    range sharding as long as row access distributes evenly over the ranges, avoiding
    hot shards—a common challenge discussed in [“Rebalancing”](#rebalancing). Range
    access works well with range sharding as long as the row ranges are within the
    shard ranges; if not, [“Cross-shard queries”](#cross-shard-queries) become a problem.
    Random access is probably infeasible for the same reason: cross-shard queries.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Lookup
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lookup (or directory) sharding is custom mapping of shard key values to shards.
    [Figure 5-9](#lookup-sharding-img) depicts a lookup table that maps country code
    top-level domains to shards.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0509](assets/emsp_0509.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9\. Lookup (directory) sharding
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Lookup sharding is the most flexible, but it requires maintaining a lookup
    table. A *lookup table* functions as a key-value map: shard key values are the
    keys, and database shards are the values. You can implement a lookup table as
    a database table, a data structure in a durable cache, a configuration file deployed
    with the application, and so forth.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in the lookup table can be singular values (as shown in [Figure 5-9](#lookup-sharding-img))
    or ranges. If the keys are ranges, then it’s essentially range sharding, but the
    lookup table gives you more control of the ranges. But that control has a cost:
    changing ranges means resharding—one of the common challenges. If the keys are
    singular values, then lookup sharding is sensible when the number of unique shard
    key values is manageable. For example, a website that stores public health statistics
    in the United States could shard by state and county name because there are fewer
    than 3,500 counties total, and they almost never change.^([1](ch05.html#idm45829111349312))
    Lookup sharding has an advantage that makes it a good choice for this example:
    it’s trivial to map all the counties with very low population to one shard, whereas
    this custom mapping isn’t possible with hash or range sharding.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'All three row access patterns (see [“Row Access”](ch04.html#ap-row-access))
    work with lookup sharding, but how well they work depends on the size and complexity
    of the lookup table you need to create and maintain to map shard key values to
    database shards. The notable mention is random access: lookup sharding allows
    you to map (or remap) shard key values to alleviate cross-shard queries caused
    by random access, which is nearly impossible with hash and range sharding.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Challenges
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If sharding were perfect, you would shard only once, and every shard would
    have equal data size and access. That might be the case when you first shard,
    but it won’t remain the case. The following challenges will affect your application
    and sharded database, so plan ahead: know how you will avoid or mitigate them.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transactions do not work across shards. This is more of a blocker than a challenge
    because there is essentially no workaround short of implementing a two-phase commit
    in the application, which is perilous and far beyond the scope of this book.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: I strongly recommend that you avoid this blocker. Review your application transactions
    (see [“Reporting”](ch08.html#trx-reporting)) and the data they access. Then choose
    a shard key and strategy that work given how the transactions access data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Joins
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A SQL statement cannot join tables across shards. The solution is a *cross-shard
    join*: the application join results from multiple queries executed on multiple
    shards. It’s not a trivial solution—it might even be complex depending on the
    join—but it’s feasible. Apart from complexity, the main concern is consistency:
    since transactions do not work across shards, the results from each shard are
    not a consistent view of all data.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: A cross-shard join is a special-purpose cross-shard query (joining the results
    is the special purpose); therefore, it’s susceptible to the same challenges.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Cross-shard queries
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *cross-shard query* requires the application to access more than one shard.
    The term refers to application access, not literal queries, because a single query
    cannot execute on more than one MySQL instance. (A more accurate term would be
    *cross-shard application access*.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-shard queries incur latency: delay inherent to accessing multiple MySQL
    instances. Sharding is most effective when cross-shard queries are the exception,
    not the norm.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'If sharding were perfect, every application request would access *only one*
    shard. That’s the goal, but don’t drive yourself crazy trying to achieve it because
    some applications, even when efficiently sharded, must access multiple shards
    to accomplish certain requests. A peer-to-peer payment application is a good example.
    Each customer is a well delineated application entity: all data related to a customer
    should be located on the same shard, which entails that the data is sharded by
    customer. But customers interact by sending and receiving money. Inevitably, the
    application will access at least two shards: one for the customer sending money,
    and another for the customer receiving the money. Cross-shard queries should be
    minimized, but again: don’t drive yourself crazy trying to eliminate them, especially
    if the application logic necessitates them for certain requests.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'A related challenge is *scatter queries* (or *scatter-gather queries*): queries
    that require the application to access many (or all) shards. (Again, the term
    refers to application access, not literal queries.) A moderate number of cross-shard
    queries is inevitable and acceptable, but scatter queries are antithetical to
    the purpose and benefits of sharding. Therefore, you should both prevent and eliminate
    scatter queries. If you cannot—if the application requires scatter queries—then
    sharding is probably not the correct solution, or the access pattern needs to
    be changed (see [“Data Access Patterns”](ch04.html#access-patterns)).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Resharding
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Resharding* (or a *shard split*) divides one shard into two or more new shards.
    Resharding is necessary to accommodate data growth, and it can also be used to
    redistribute data across shards. If and when resharding is necessary depends on
    capacity planning: the estimated rate of data growth and how many shards are created
    initially. For example, I’ve seen a team split a database into four shards then
    reshard less than two years later because data size increased much faster than
    estimated. By contrast, I’ve seen a team split a database into 64 shards to accommodate
    more than five years of estimated data growth. If you can afford extra shards
    at the beginning (when you first shard), then create enough shards for at least
    four years of data growth—don’t wildly overestimate, but estimate generously.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the dark secret of sharding: sharding begets more sharding. If you’re
    wondering, “Can I shard once and be done?” the answer is “probably not.” Since
    your database grew to the point of needing to shard, it’s likely to keep growing
    and keep needing more shards—unless you become fervent about the idea that less
    data is better (see [“Less Data Is Better”](ch03.html#less-data-is-better)).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Resharding is a challenge because it requires a data migration process from
    the old shard to the new shards. Describing how to migrate data is beyond the
    scope of this book, but I will point out three high-level requirements:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: An initial bulk data copy from old to new shards
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sync changes on old shard to new shards (during and after data copy)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cutover process to switch to new shards
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep MySQL expertise is required to migrate data safely and correctly. Since
    data migrations are specific to the application and infrastructure, you won’t
    find any books or other resources that detail the process. If necessary, hire
    a MySQL consultant to help design a process. Also check out [Ghostferry](https://oreil.ly/7aM3I)
    by the engineers at Shopify who are experts in MySQL sharding.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Rebalancing
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Rebalancing* relocates data in order to distribute access more evenly. Rebalancing
    is necessary to handle *hot shards*: shards with significantly more access than
    other shards. Although the shard key and sharding strategy determine how data
    is distributed, the application and its users determine how data is accessed.
    If one shard (a hot shard) contains all the most frequently accessed data, then
    performance is not evenly distributed, which defeats the purpose of scaling out.
    The goal is equal access—and equal performance—on all shards.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebalancing depends on the sharding strategy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Hash
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s virtually impossible to relocate data with hash sharding because the hashing
    algorithm automatically maps data to shards. One solution (or workaround) is to
    use a lookup table that contains relocated shard keys. The application checks
    the lookup table first: if the shard key is present, it uses the shard indicated
    by the lookup table; otherwise, it uses the hashing algorithm.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Range
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Relocating data with range sharding is possible (but nontrivial) by redefining
    the ranges to divide the hot shard into smaller, separate shards. This is the
    same process as resharding.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Lookup
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Relocating data with lookup sharding is relatively easy because you control
    the mapping of data to shards. Therefore, you update the lookup table to remap
    the shard key value corresponding to the hot data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Physically relocating the hot data requires the same (or similar) data migration
    process used for resharding.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Online schema changes
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Altering a table on one database is easy, but how do you alter it on every shard?
    You run the OSC on each shard, but that’s not the challenge. The challenge is
    automating the OSC process to run on multiple shards, and keeping track of which
    shards have been altered. For MySQL, there are no open source solutions at the
    time of this writing; you must develop a solution. (However, a couple of the alternatives
    to MySQL in the next section have a solution.) This is the least complex challenge
    of sharding, but it’s a challenge nevertheless. It cannot be overlooked because
    schema changes are routine.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharding is complex, and it’s not directly valuable to users or customers. It’s
    valuable to the application to keep scaling, but it’s exacting work for engineers.
    Unsurprisingly, alternative solutions are increasingly popular and robust. However,
    don’t be too quick to trust your data to new technology. MySQL is eminently reliable
    and deeply understood—a very mature technology—which makes it a safe and reasonable
    choice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: NewSQL
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*NewSQL* refers to a relational, ACID-compliant data store with built-in support
    for scaling out. In other words, it’s a SQL database that you don’t have to shard.
    If you’re thinking, “Wow! Then why use MySQL at all?” the following five points
    explain why MySQL—sharded or not—is still the most popular open source database
    in the world:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '*Maturity*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL hails from the 1970s and MySQL from the 1990s. Database maturity means
    two things: you can trust the data store not to lose or corrupt your data, and
    there is deep knowledge about every aspect of the data store. Pay close attention
    to the maturity of NewSQL data stores: when was the first truly stable GA (generally
    available) release? What has the cadence and quality of releases been since then?
    What deep and authoritative knowledge is publicly available?'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: SQL compatibility
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: NewSQL data stores use SQL (it’s in the name, after all) but compatibility varies
    significantly. Do not expect any NewSQL data store to be a drop-in replacement
    for MySQL.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '*Complex operations*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Built-in support for scaling out is achieved with a distributed system. That
    usually entails multiple different yet coordinated components. (If MySQL is as
    a solo saxophonist, then NewSQL is as a five-piece band.) If the NewSQL data store
    is fully managed, then perhaps its complexity doesn’t matter. But if you have
    to manage it, then read its documentation to understand how it’s operated.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*Distributed system performance*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the Universal Scalability Law ([Equation 4-1](ch04.html#usl)):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: <math><mrow><mi>X</mi> <mrow><mo>(</mo> <mi>N</mi> <mo>)</mo></mrow> <mo>=</mo>
    <mfrac><mrow><mi>γ</mi><mi>N</mi></mrow> <mrow><mn>1</mn><mo>+</mo><mi>α</mi><mo>(</mo><mi>N</mi><mo>-</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>β</mi><mi>N</mi><mo>(</mo><mi>N</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '`N` represents software load (concurrent requests, running processes, and forth),
    or hardware processors, *or nodes in a distributed system*. If the application
    has queries that require a response time less than 10 milliseconds, a NewSQL data
    store might not work because of the latency inherent in distributed systems. But
    that level of response time is not the bigger, more common problem that NewSQL
    solves: built-in scale out to large data size (relative to a single instance)
    with reasonable response time (75 ms, for example).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*Performance characteristics*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: What accounts for the response time (performance) of a query? For MySQL, the
    high-level constituents are indexes, data, access patterns, and hardware—everything
    in the previous four chapters. Add to those some lower-level details—like [“Leftmost
    Prefix Requirement”](ch02.html#LPR), [“Working set size”](ch03.html#working-set-size),
    and [“MySQL Does Nothing”](ch04.html#mysql-does-nothing)—and you understand MySQL
    performance and how to improve it. A NewSQL data store will have new and different
    performance characteristics. For example, indexes always provide the most and
    the best leverage, but they can work differently for a NewSQL data store because
    of how the data is stored and accessed in the distributed system. Likewise, some
    access patterns that are good on MySQL are bad on NewSQL, and vice versa.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Those five points are a disclaimer: NewSQL is a promising technology that you
    should investigate as an alternative to sharding MySQL, but NewSQL is not an effortless
    drop-in replacement for MySQL.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of this writing, there are only two viable open source NewSQL solutions
    that are MySQL-compatible: [TiDB](https://oreil.ly/GSCc0) and [CockroachDB](https://oreil.ly/wKZ2Z).
    Both of these solutions are exceptionally new for a data store: CockroachDB v1.0
    GA released May 10, 2017; and TiDB v1.0 GA released October 16, 2017. Therefore,
    be cautious and diligent using TiDB and CockroachDB until at least 2027—even MySQL
    was 10 years old by the time it was mainstream in the early 2000s. If you use
    TiDB or CockroachDB, please write about what you learn and, if possible, contribute
    to these open source projects.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A middleware solution works between the application and the MySQL shards. It
    attempts to hide or abstract the details of sharding, or at least make sharding
    easier. When direct, manual sharding is too difficult, and NewSQL is infeasible,
    a middleware solution could help bridge the gap. The two leading open source solutions
    are [Vitess](https://oreil.ly/6AvRY) and [ProxySQL](https://oreil.ly/5iTkH), and
    they are entirely different. ProxySQL *can* shard and Vitess *is* sharding.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'ProxySQL, as its name suggests, is a proxy that supports sharding by several
    mechanisms. To get an idea how it works, read [“Sharding in ProxySQL”](https://oreil.ly/N0eYa)
    and [“MySQL Sharding with ProxySQL”](https://oreil.ly/KDvjE). Using a proxy in
    front of MySQL is similar to the classic Vim versus Emacs rift minus all the vitriol:
    engineers do a lot of great work with both editors; it’s just a matter of personal
    preference. Likewise, companies are successful with and without a proxy; it’s
    just a matter of personal preference.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Vitess is a purpose-built MySQL sharding solution. Since sharding is complex,
    Vitess is not without its own complexity, but its greatest advantage is that it
    addresses all challenges, especially resharding and rebalancing. Moreover, Vitess
    was created by MySQL experts at YouTube who deeply understand MySQL at massive
    scale.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Before you shard, be sure to evaluate ProxySQL and Vitess. Any middleware solution
    entails additional infrastructure to learn and maintain, but the benefits can
    outweigh the costs because manually sharding MySQL also costs significant engineering
    time, effort, and serenity.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sharding focuses on one application (or service) and its data, especially data
    size and access. But sometimes the real problem is the application: it has too
    much data or access because it serves too many purposes or business functions.
    Avoiding monolithic applications is standard engineering design and practice,
    but that doesn’t mean it’s always achieved. Before you shard, review the application
    design and its data to ensure that parts cannot be factored out into a separate
    microservice. This is a lot easier than sharding because the new microservice
    and its database are completely independent—no shard key or strategy required.
    It might also be the case that the new microservice has completely different access
    patterns (see [“Data Access Patterns”](ch04.html#access-patterns)) that allow
    it to use less hardware while storing more data—or perhaps the new microservice
    doesn’t need a relational data store.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Use MySQL
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to [“Don’t Use MySQL”](ch04.html#dont-use-mysql), a completely honest
    assessment of the alternatives to sharding MySQL must conclude with: don’t use
    MySQL if another data store or technology works better. If your path is designing
    a new application for sharding, then definitely evaluate other solutions. Sharding
    MySQL is a solved problem, but it’s never a quick or easy solution. If your path
    is migrating an existing application to sharding, then you should still consider
    the trade-offs of sharding MySQL against migrating to another solution. That sounds
    burdensome at scale—and it is—but companies do it all the time, and so can you.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced the basic mechanics of sharding MySQL to achieve MySQL
    at scale. The essential takeaway points are:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: MySQL scales out by sharding.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharding divides one database into many databases.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single database does not scale primarily because the combination of queries,
    data, and access patterns—the application workload—significantly outpace the speed
    and capacity of single-server hardware.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s significantly easier to manage many small databases (shards) than one huge
    database—pebbles, not boulders.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is sharded (divided) by a shard key, which you must choose carefully.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shard key is used with a sharding strategy to map data (by shard key) to
    shards.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common sharding strategies are hash (a hashing algorithm), range, and
    lookup (directory).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharding has several challenges that must be addressed.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are alternatives to sharding that you should evaluate.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter looks into MySQL server metrics.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Practice: Four-Year Fit'
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal of this practice is to determine the four-year fit of the data size.
    From [“Sharding: A Brief Introduction”](#sharding-intro), the four-year fit is
    an estimate of data size or access in four years applied to the capacity of your
    hardware *today*. Sharding might not be required if the estimated data size or
    access fits (figuratively) within your hardware capacity today. (Refer back to
    [“Application Workload”](#scale-up-app-workload) for the discussion of hardware
    fit.)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目标是确定数据大小的四年适配性。从 [“分片：简介”](#sharding-intro) 中，四年适配是将四年后的数据大小或访问量估计应用到今天硬件的容量上。如果估计的数据大小或访问量（比喻地）符合今天的硬件容量，则可能不需要分片。（参考
    [“应用工作负载”](#scale-up-app-workload) 讨论硬件适配性。）
- en: You will need historical data sizes to complete this practice. If you’re not
    already measuring and recording data sizes, then jump ahead to [“Data Size”](ch06.html#metrics-data-size)
    to learn how.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要历史数据大小来完成这个练习。如果你还没有在测量和记录数据大小，那么可以直接跳转到 [“数据大小”](ch06.html#metrics-data-size)
    了解如何进行。
- en: 'The simplest possible calculation is sufficient. If, for example, a database
    has historically increased by 10 GB every month, then the database will be 12
    months × 4 years × 10 GB/month = 480 GB *larger* in four years—if no data is deleted
    or archived (see [“Delete or Archive Data”](ch03.html#delete-or-archive)). If
    the database is 100 GB today, then 580 GB in four years fits: you don’t need to
    shard any time soon (four-year fit for access load notwithstanding) because MySQL
    on hardware *today* can easily handle 580 GB of data.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的计算已经足够了。例如，如果一个数据库历史上每个月增加 10 GB，那么四年后数据库将增加 12 个月 × 4 年 × 10 GB/月 = 480
    GB *更大* ——如果没有数据被删除或归档（参见 [“删除或归档数据”](ch03.html#delete-or-archive)）。如果数据库今天是 100
    GB，那么四年后的 580 GB 是合适的：你不需要很快进行分片（尽管需要四年内适应访问负载），因为今天的 MySQL 在硬件上轻松处理 580 GB 的数据。
- en: 'If your four-year fit for data size indicates that you might need to shard,
    take it seriously and dive deeper to determine for sure: is the database on a
    steady path to becoming too large for a single MySQL instance? If yes, then *shard
    early* because sharding is essentially a complex data migration process; therefore,
    the less data, the easier the process. If not, then congratulations: ensuring
    that the system will continue to scale for years to come is an expert practice
    in all fields of engineering.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的四年数据大小适配表明可能需要分片，那么请认真对待并深入研究以确定确切的情况：数据库是否正在稳定地变得过大以至于单个 MySQL 实例无法处理？如果是，那么*早点分片*，因为分片本质上是一个复杂的数据迁移过程；因此，数据越少，这个过程就越容易。如果不是，那么恭喜：确保系统将来几年继续扩展是所有工程领域的专家实践。
- en: ^([1](ch05.html#idm45829111349312-marker)) County names are unique only within
    a state, which is why the state name is required.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm45829111349312-marker)) 县名在一个州内是唯一的，这就是为什么需要州名的原因。
