- en: Chapter 2\. Running Your First BPF Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BPF VM is capable of running instructions in response to events triggered
    by the kernel. However, not all BPF programs have access to all events triggered
    by the kernel. When you load a program into the BPF VM, you need to decide which
    type of program you’re running. This informs the kernel about where your program
    is going to be triggered. It also tells the BPF verifier which helpers are going
    to be allowed in your program. When you choose the program type, you’re also choosing
    the interface that your program is implementing. This interface ensures that you
    have access to the appropriate type of data, and whether your program can access
    network packets directly or not.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we show you how to write your first BPF programs. We also guide
    you around the different types of BPF programs that you can create (as of the
    writing of this book). Over the years, the kernel developers have been adding
    different entry points to which you can attach BPF programs. This work is not
    complete yet, and they are finding new ways to take advantage of BPF every day.
    We’re going to focus on some of the most useful types of programs in this chapter,
    with the intention of giving you a taste of what you can do with BPF. We go over
    many additional examples in future chapters on how to write BPF programs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also cover the role that the BPF verifier plays in running
    your programs. This component validates that your code is safe to execute and
    helps you to write programs that won’t cause unexpected results, such as memory
    exhaustion or sudden kernel crashes. But let’s begin with the basics of writing
    your own BPF programs from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Writing BPF Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common way to write BPF programs is by using a subset of C compiled
    with LLVM. LLVM is a general-purpose compiler that can emit different types of
    bytecode. In this case, LLVM will output BPF assembly code that we will load into
    the kernel later. We’re not going to show you much BPF assembly in this book.
    After a long discussion, we decided that it’s better to show you examples of how
    to use it in specific circustances, but you can easily find several references
    online or in the BPF man pages. We do show short examples of BPF assembly in future
    chapters, where writing assembly is more appropriate than C, like Seccomp filters
    to control incoming system calls in the kernel. We talk more about Seccomp in
    [Chapter 8](ch08.html#kernel_security).
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel provides the syscall `bpf` to load programs into the BPF VM after
    they are compiled. This syscall is used for other operations besides loading programs,
    and you’ll see more usage examples in later chapters. The kernel also provides
    several utilities that abstract the loading of BPF programs for you. In this first
    code example we use those helpers to show you the “Hello World” example of BPF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are a few interesting concepts in this first program. We’re using the
    attribute `SEC` to inform the BPF VM when we want to run this program. In this
    case, we will run this BPF program when a tracepoint in an `execve` system call
    is detected. Tracepoints are static marks in the kernel’s binary code that allow
    developers to inject code to inspect the kernel’s execution. We talk in detail
    about tracepoints in [Chapter 4](ch04.html#tracing_with_bpf), but for now you
    need to know only that `execve` is an instruction that executes other programs.
    So we’re going to see the message `Hello, BPF World!` every time the kernel detects
    that a program executes another program.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this example we also specify the license for this program. Because
    the Linux kernel is licensed under GPL, it can load only programs licensed as
    GPL too. If we set the license to something else, the kernel will refuse to load
    our program. We’re using `bpf_trace_printk` to print a message in the kernel tracing
    log; you can find this log in */sys/kernel/debug/tracing/trace_pipe*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to use `clang` to compile this first program into a valid ELF binary
    file. This is the format that the kernel expects to load. We’re going to save
    our first program in a file called `bpf_program.c` so we can compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You’ll find some scripts to compile these programs in the [GitHub repository
    with the code example for the book](https://oreil.ly/lbpf-repo), so you don’t
    need to memorize this `clang` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have compiled our first BPF program, we need to load it in the
    kernel. As we mentioned, we use a special helper that the kernel provides to abstract
    the boilerplate of compiling and loading the program. This helper is called `load_bpf_file`,
    and it takes a binary file and tries to load it in the kernel. You can find this
    helper in the [GitHub repository with all the examples in the book](https://oreil.ly/lbpf-repo),
    in the *bpf_load.h* file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re going to use a script to compile this program and link it as an ELF binary.
    In this case, we don’t need to specify a target, because this program won’t be
    loaded in the BPF VM. We need to use an external library, and writing a script
    makes it easier to put it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to run this program, you can execute this final binary by using
    `sudo`: `sudo ./loader`. `sudo` is a Linux command that’s going to give you root
    privileges in your computer. If you don’t run this program with `sudo`, you’ll
    get an error message because most BPF programs can be loaded in the kernel only
    by a user who has root privileges.'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this program, you’ll start to see our `Hello, BPF World!` message
    after a few seconds, even if you’re not doing anything with your computer. This
    is because programs running behind the scenes in your computer might be executing
    other programs.
  prefs: []
  type: TYPE_NORMAL
- en: When you stop this program, the message will stop showing up in your terminal.
    BPF programs are unloaded from the VM as soon as the programs that load them terminate.
    In the coming chapters, we explore how to make BPF programs persistent, even after
    their loaders terminate, but we don’t want to introduce too many concepts just
    yet. This is an important concept to keep in mind because in many situations,
    you’ll want your BPF programs to run in the background, collecting data from your
    system, regardless of whether other processes are running.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the basic structure for a BPF program, we can dive into
    which types of programs you can write, which will give you access to different
    subsystems within the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: BPF Program Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there is no clear categorization within programs, you’ll quickly realize
    that all the types covered in this section are divided in two categories, depending
    on what their main purpose is.
  prefs: []
  type: TYPE_NORMAL
- en: The first category is *tracing*. Many of the programs that you can write will
    help you better understand what’s happening in your system. They give you direct
    information about the behavior of your system and the hardware it’s running on.
    They can access memory regions related to specific programs, and extract execution
    traces from running processes. They also give you direct access to the resources
    allocated for each specific process, from file descriptors to CPU and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: The second category is *networking*. These types of programs allow you to inspect
    and manipulate the network traffic in your system. They let you filter packets
    coming from the network interface, or even reject those packets completely. Different
    types of programs can be attached to different stages of network processing within
    the kernel. This has advantages and disadvantages. For example, you can attach
    BPF programs to network events as soon as your network driver receives a packet,
    but this program will have access to less information about the packet, because
    the kernel doesn’t have enough information to offer you yet. On the other end
    of the spectrum, you can attach BPF programs to network events immediately before
    they are passed to user-space. In this case, you’ll have much more information
    about the packet, which will help you make better-informed decisions, but you’ll
    need to pay the cost of completely processing the packet.
  prefs: []
  type: TYPE_NORMAL
- en: The list of program types that we show next is not divided into categories;
    we’re introducing these types in the chronological order in which they were added
    to the kernel. We’ve moved the least used of these programs to the end of this
    section, and we’ll focus for now on the ones that will be more useful for you.
    If you’re curious about any program that we’re not covering in detail here, you
    can learn more about all of them in [`man 2 bpf`](https://oreil.ly/qXl0F).
  prefs: []
  type: TYPE_NORMAL
- en: Socket Filter Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_SOCKET_FILTER` was the first program type to be added to the
    Linux kernel. When you attach a BPF program to a raw socket, you get access to
    all the packets processed by that socket. Socket filter programs don’t allow you
    to modify the contents of those packets or to change the destination for those
    packets; they give you access to them for observability purposes only. The metadata
    that your program receives contains information related to the network stack such
    as the protocol type that’s being used to deliver the packet.'
  prefs: []
  type: TYPE_NORMAL
- en: We cover socket filtering and other network programs in more detail in [Chapter 6](ch06.html#linux_networking).
  prefs: []
  type: TYPE_NORMAL
- en: Kprobe Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ll see in [Chapter 4](ch04.html#tracing_with_bpf), in which we talk about
    tracing, kprobes are functions that you can attach dynamically to certain call
    points in the kernel. BPF kprobe program types allow you to use BPF programs as
    kprobe handlers. They are defined with the type `BPF_PROG_TYPE_KPROBE`. The BPF
    VM ensures that your kprobe programs are always safe to run, which is an advantage
    from traditional kprobe modules. You still need to remember that kprobes are not
    considered stable entry points in the kernel, so you’ll need to ensure that your
    kprobe BPF programs are compatible with the specific kernel versions that you’re
    using.
  prefs: []
  type: TYPE_NORMAL
- en: When you write a BPF program that’s attached to a kprobe, you need to decide
    whether it will be executed as the first instruction in the function call or when
    the call completes. You need to declare this behavior in the section header of
    your BPF program. For example, if you want to inspect the arguments when the kernel
    invokes an `exec` syscall, you’ll attach the program at the beginning of the call.
    In this case, you need to set the section header `SEC("kprobe/sys_exec")`. If
    you want to inspect the returned value of invoking an `exec` syscall, you need
    to set the section header `SEC("kretprobe/sys_exec")`.
  prefs: []
  type: TYPE_NORMAL
- en: We talk a lot more about kprobes in later chapters of this book. They are a
    fundamental piece to understanding tracing with BPF.
  prefs: []
  type: TYPE_NORMAL
- en: Tracepoint Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of program allows you to attach BPF programs to the tracepoint handler
    provided by the kernel. Tracepoint programs are defined with the type `BPF_PROG_TYPE_TRACEPOINT`.
    As you’ll see in [Chapter 4](ch04.html#tracing_with_bpf), tracepoints are static
    marks in the kernel’s codebase that allow you to inject arbitrary code for tracing
    and debugging purposes. They are less flexible than kprobes, because they need
    to be defined by the kernel beforehand, but they are guaranteed to be stable after
    their introduction in the kernel. This gives you a much higher level of predictability
    when you want to debug your system.
  prefs: []
  type: TYPE_NORMAL
- en: All tracepoints in your system are defined within the directory */sys/kernel/debug/tracing/events*.
    There you’ll find each subsystem that includes any tracepoints and that you can
    attach a BPF program to. One interesting fact is that BPF declares its own tracepoints,
    so you can write BPF programs that inspect the behavior of other BPF programs.
    The BPF tracepoints are defined in */sys/kernel/debug/tracing/events/bpf*. There,
    for example, you can find the tracepoint definition for *bpf_prog_load*. This
    means you can write a BPF program that inspects when other BPF programs are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Like kprobes, tracepoints are another fundamental piece to understand tracing
    with BPF. We talk more about them in the coming chapters and show you how to write
    programs to take advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: XDP Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XDP programs allow you to write code that’s executed very early on when a network
    packet arrives at the kernel. They are defined with the type `BPF_PROG_TYPE_XDP`.
    It exposes only a limited set of information from the packet given that the kernel
    has not had much time to process the information itself. Because the packet is
    executed early on, you have a much higher level of control over how to handle
    that packet.
  prefs: []
  type: TYPE_NORMAL
- en: XDP programs define several actions that you can control and that allow you
    to decide what to do with the packet. You can return `XDP_PASS` from your XDP
    program, which means that the packet should be passed to the next subsystem in
    the kernel. You can also return `XDP_DROP`, which means that the kernel should
    ignore this packet completely and do nothing else with it. You can also return
    `XDP_TX`, which means that the packet should be forwarded back to the network
    interface card (NIC) that received the packet in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: This level of control opens the door to many interesting programs in the networking
    layer. XDP has become one of the main components in BPF, which is why we’ve included
    a specific chapter about it in this book. In [Chapter 7](ch07.html#express_data_path_XDP),
    we discuss many powerful use cases for XDP, like implementing programs to protect
    your network against distributed denial-of-service (DDoS) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Perf Event Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These types of BPF programs allow you to attach your BPF code to *Perf events*.
    They are defined with the type `BPF_PROG_TYPE_PERF_EVENT`. Perf is an internal
    profiler in the kernel that emits performance data events for hardware and software.
    You can use it to monitor many things, from your computer’s CPU to any software
    running on your system. When you attach a BPF program to Perf events, your code
    will be executed every time Perf generates data for you to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: Cgroup Socket Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These types of programs allow you to attach BPF logic to control groups (cgroups).
    They are defined with the type `BPF_PROG_TYPE_CGROUP_SKB`. They allow cgroups
    to control network traffic within the processes that they contain. With these
    programs, you can decide what to do with a network packet before it’s delivered
    to a process in the cgroup. Any packet that the kernel tries to deliver to any
    process in the same cgroup will pass through one of these filters. At the same
    time, you can decide what to do when a process in the cgroup sends a network packet
    through that interface.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, their behavior is similar to `BPF_PROG_TYPE_SOCKET_FILTER` programs.
    The main difference is that `BPF_PROG_TYPE_CGROUP_SKB` programs are attached to
    all processes within a cgroup, rather than specific processes; this behavior applies
    to current and future sockets created in the given cgroup. BPF programs attached
    to cgroups become useful in container environments where groups of processes are
    constrained by cgroups and where you can apply the same policies to all of them
    without having to identify each one independently. [Cillium](https://github.com/cilium/cilium),
    a popular open source project that provides load balancing and security capabilities
    for Kubernetes, uses cgroup socket programs extensively to apply its policies
    in groups rather than in isolated containers.
  prefs: []
  type: TYPE_NORMAL
- en: Cgroup Open Socket Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These types of programs allow you to execute code when any process in a cgroup
    opens a network socket. This behavior is similar to the programs attached to cgroup
    socket buffers, but instead of giving you access to the packets as they come through
    the network, they allow you to control what happens when a process opens a new
    socket. They are defined with the type `BPF_PROG_TYPE_CGROUP_SOCK`. This is useful
    to provide security and access control over groups of programs that can open sockets
    without having to restrict capabilities per process individually.
  prefs: []
  type: TYPE_NORMAL
- en: Socket Option Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These types of programs allow you to modify socket connection options at runtime,
    while a packet transits through several stages in the kernel’s networking stack.
    They are attached to cgroups, much like `BPF_PROG_TYPE_CGROUP_SOCK` and `BPF_PROG_TYPE_CGROUP_SKB`,
    but unlike those program types, they can be invoked several times during the connection’s
    lifecycle. These programs are defined with the type `BPF_PROG_TYPE_SOCK_OPS`.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a BPF program with this type, your function call receives an
    argument called `op` that represents the operation that the kernel is about to
    execute with the socket connection; therefore, you know at which point the program
    is invoked in the connection’s lifecycle. With this information in hand, you can
    access data such as network IP addresses and connection ports, and you can modify
    the connection options to set timeouts and alter the round-trip delay time for
    a given packet.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Facebook uses this to set short recovery time objectives (RTOs)
    for connections within the same datacenter. The RTO is the time that a system,
    or network connection in this case, is expected to be recovered after a failure.
    This objective also represents how long the system can be unavailable before suffering
    from unacceptable consequences. In Facebook’s case, it assumes that machines in
    the same datacenter should have a short RTO, and Facebook modifies this threshold
    by using a BPF program.
  prefs: []
  type: TYPE_NORMAL
- en: Socket Map Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_SK_SKB` programs give you access to socket maps and socket redirects.
    As you’ll learn in the next chapter, socket maps allow you to keep references
    to several sockets. When you have these references, you can use special helpers
    to redirect an incoming packet from a socket to a different socket. This is interesting
    when you want to implement load-balancing capabilities with BPF. By keeping track
    of several sockets, you can forward network packets between them without leaving
    the kernel-space. Projects like Cillium and [Facebook’s Katran](https://oreil.ly/wDtfR)
    make extensive use of these types of programs for network traffic control.'
  prefs: []
  type: TYPE_NORMAL
- en: Cgroup Device Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of program allows you to decide whether an operation within a cgroup
    can be executed for a given device. These programs are defined with the type `BPF_PROG_TYPE_CGROUP_DEVICE`.
    The first implementation of cgroups (v1) has a mechanism that allows you to set
    permissions for specific devices; however, the second iteration of cgroups lacks
    this feature. This type of program was introduced to supply that functionality.
    At the same time, being able to write a BPF program gives you more flexibility
    to set those permissions when you need them.
  prefs: []
  type: TYPE_NORMAL
- en: Socket Message Delivery Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These types of programs let you control whether a message sent to a socket
    should be delivered. They are defined with the type `BPF_PROG_TYPE_SK_MSG`. When
    the kernel creates a socket, it stores the socket in the aforementioned socket
    map. This map gives the kernel quick access to specific groups of sockets. When
    you attach a socket message BPF program to a socket map, all messages sent to
    those sockets will be filtered by the program before delivering them. Before filtering
    messages, the kernel copies the data in the message so that you can read it and
    decide what to do with it. These programs have two possible return values: `SK_PASS`
    and `SK_DROP`. You use the first one if you want the kernel to send the message
    to the socket, and you use the latter one if you want the kernel to ignore the
    message and not deliver it to the socket.'
  prefs: []
  type: TYPE_NORMAL
- en: Raw Tracepoint Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked earlier about a type of program that accesses tracepoints in the kernel.
    The kernel developers added a new tracepoint program to address the need of accessing
    the tracepoint arguments in the raw format held by the kernel. This format gives
    you access to more detailed information about the task that the kernel is executing;
    however, it has a small performance overhead. Most of the time, you’ll want to
    use regular tracepoints in your programs to avoid that performance overhead, but
    it’s good to keep in mind that you can also access the raw arguments when needed
    by using raw tracepoints. These programs are defined with the type `BPF_PROG_TYPE_RAW_TRACEPOINT`.
  prefs: []
  type: TYPE_NORMAL
- en: Cgroup Socket Address Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This type of program allows you to manipulate the IP addresses and port numbers
    that user-space programs are attached to when they are controlled by specific
    cgroups. There are use cases when your system uses several IP addresses when you
    want to ensure that a specific set of user-space programs use the same IP address
    and port. These BPF programs give you the flexibility to manipulate those bindings
    when you put those user-space programs in the same cgroup. This ensures that all
    incoming and outgoing connections from those applications use the IP and port
    that the BPF program provides. These programs are defined with the following type:
    `BPF_PROG_TYPE_CGROUP_SOCK_ADDR`.'
  prefs: []
  type: TYPE_NORMAL
- en: Socket Reuseport Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SO_REUSEPORT` is an option in the kernel that allows multiple processes in
    the same host to be bound to the same port. This option allows higher performance
    in accepted network connections when you want to distribute load across multiple
    threads.'
  prefs: []
  type: TYPE_NORMAL
- en: The `BPF_PROG_TYPE_SK_REUSEPORT` program type allows you to write BPF programs
    that hook into the logic that the kernel uses to decide whether it’s going to
    reuse a port. You can prevent programs from reusing the same port if your BPF
    program returns `SK_DROP`, and you also can inform the kernel to follow its own
    reuse routine when you return `SK_PASS` from these BPF programs.
  prefs: []
  type: TYPE_NORMAL
- en: Flow Dissection Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The flow dissector is a component of the kernel that keeps track of the different
    layers that a network packet needs to go through, from when it arrives to your
    system to when it’s delivered to a user-space program. It allows you to control
    the flow of the packet using different classification methods. The built-in dissector
    in the kernel is called the *Flower classifier*, and it’s used by firewalls and
    other filtering devices to decide what to do with specific packets.
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_FLOW_DISSECTOR` programs are designed to hook logic in the flow
    dissector path. They provide security guarantees that the built-in dissector cannot
    provide, such as ensuring that the program always terminates, which might not
    be guaranteed in the built-in dissector. These BPF programs can modify the flow
    that network packets follow within the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: Other BPF Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve talked about program types that we’ve seen used in different environments,
    but it’s worth noting that there are a few other additional BPF program types
    that we haven’t covered yet. These are programs that we mention only briefly here:'
  prefs: []
  type: TYPE_NORMAL
- en: Traffic classifier programs
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_SCHED_CLS` and `BPF_PROG_TYPE_SCHED_ACT` are two types of BPF
    programs that allow you to classify network traffic and modify some properties
    of the packets in the socket buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight tunnel programs
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_LWT_IN`, `BPF_PROG_TYPE_LWT_OUT`, `BPF_PROG_TYPE_LWT_XMIT` and
    `BPF_PROG_TYPE_LWT_SEG6LOCAL` are types of BPF programs that allow you to attach
    code to the kernel’s lightweight tunnel infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: Infrared device programs
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_LIRC_MODE2` programs allow you to attach BPF programs via connections
    to infrared devices, such as remote controllers, for fun.'
  prefs: []
  type: TYPE_NORMAL
- en: These programs are specialized, and their usage has not been widely adopted
    for the community.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we talk about how BPF guarantees that your programs won’t cause a catastrophic
    failure in your system after the kernel loads them. This is an important topic
    because understanding how a program loads also influences how to write those programs.
  prefs: []
  type: TYPE_NORMAL
- en: The BPF Verifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allowing anyone to execute arbitrary code inside the Linux kernel always sounds
    like a terrible idea at first. The risk of running BPF programs in production
    systems would be too high if it weren’t for the BPF verifier. In the words of
    Dave S. Miller, one of the kernel networking maintainers, “The only thing sitting
    between our eBPF programs and a deep dark chasm of destruction is the eBPF verifier.”
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the BPF verifier is also a program running on your system, and it’s
    the object of high scrutiny to ensure that it does its job correctly. In the past
    years, security researchers have discovered some vulnerabilities in the verifier
    that allowed attackers to access random memory in the kernel, even as unprivileged
    users. You can read more about vulnerabilities like that one in the Common Vulnerabilities
    and Exposures (CVE) catalog, a list of known security threads sponsored by the
    United States Department of Homeland Security. For example, CVE-2017-16995 describes
    how any user could read and write kernel memory and bypass the BPF verifier.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we guide you through the measures that the verifier takes to
    prevent problems like the one just described.
  prefs: []
  type: TYPE_NORMAL
- en: The first check that the verifier performs is a static analysis of the code
    that the VM is going to load. The objective of this first check is to ensure that
    the program has an expected end. To do this, the verifier creates a direct acyclic
    graph (DAG) with the code. Each instruction that the verifier analyzes becomes
    a node in the graph, and each node is linked to the next instruction. After the
    verifier generates this graph, it performs a depth first search (DFS) to ensure
    that the program finishes and the code doesn’t include dangerous paths. This means
    it will traverse each branch of the graph, all the way to the bottom of the branch,
    to guarantee that there are no recursive cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the conditions why the verifier might reject your code during this
    first check:'
  prefs: []
  type: TYPE_NORMAL
- en: The program doesn’t include control loops. To ensure that the program doesn’t
    get stuck in an infinite loop, the verifier rejects any kind of control loop.
    There have been proposals to allow loops in BPF programs, but as of this writing,
    none of them has been adopted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program doesn’t try to execute more instructions than the maximum allowed
    by the kernel. At this time, the maximum number of instructions to execute is
    4,096\. This limitation is in place to prevent BPF from running forever. In [Chapter 3](ch03.html#bpf_maps),
    we discuss how to nest different BPF programs to work around this limitation in
    a safe way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program doesn’t include any unreachable instruction, such as conditions
    or functions that are never executed. This prevents loading dead code in the VM,
    which would also delay the termination of the BPF program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program doesn’t try to jump outside its bounds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second check that the verifier performs is a dry run of the BPF program.
    This means that the verifier will try to analyze every instruction that the program
    is going to execute to ensure that it doesn’t execute any invalid instruction.
    This execution also checks that all memory pointers are accessed and dereferenced
    correctly. Finally, the dry run informs the verifier about the control flows in
    the program to ensure that no matter which control path the program takes, it
    arrives to the `BPF_EXIT` instruction. To do this, the verifier keeps track of
    all visited branch paths in a stack, which it evaluates before taking a new path
    to ensure that it doesn’t visit a specific path more than once. After these two
    checks pass, the verifier considers the program to be safe to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bpf` syscall allows you to debug the verifier’s checks if you’re interested
    in seeing how your programs are analyzed. When you load a program with this syscall,
    you can set several attributes that will make the verifier print its operation
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `log_level` field tells the verifier whether to print any log. It will print
    its log when you set it to 1, and it won’t print anything if you set it to 0\.
    If you want to print the verifier log, you also need to provide a log buffer and
    its size. This buffer is a multiline string that you can print to inspect the
    decisions that the verifier took.
  prefs: []
  type: TYPE_NORMAL
- en: The BPF verifier plays a big role in keeping your system secure and available
    while you run arbitrary programs within the kernel, although it might be difficult
    to understand why it makes some decisions sometimes. Don’t despair if you bump
    into verification issues trying to load your programs. During the rest of this
    book, we guide you through safe examples that will help you understand how to
    write your own programs in a secure way too.
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers how BPF structures program information in memory. The
    way a program structured will help make clear how to access the BPF internals,
    helping you debug and understand how programs behave.
  prefs: []
  type: TYPE_NORMAL
- en: BPF Type Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BPF Type Format (BTF) is a collection of metadata structures that enhances
    the debug information for BPF programs, maps, and functions. BTF includes source
    information, so tools like BPFTool, which we talk about in [Chapter 5](ch05.html#bpf_utilities),
    can show you a much richer interpretation of BPF data. This metadata is stored
    in the binary program under a special “.BFT” metadata section. BTF information
    is useful to make your programs easier to debug, but it increases the size of
    binary files significantly because it needs to keep track of type information
    for everything declared in your program. The BPF verifier also uses this information
    to ensure that the structure types defined by your program are correct.
  prefs: []
  type: TYPE_NORMAL
- en: BTF is used exclusively to annotate C types. BPF compilers like LLVM know how
    to include that information for you, so you don’t need to go through the cumbersome
    task of adding that information to each structure. However, in some cases, the
    toolchain still needs some annotations to enhance your programs. In later chapters
    we describe how those annotations come into play and how tools like BPFTool display
    this information.
  prefs: []
  type: TYPE_NORMAL
- en: BPF Tail Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BPF programs can call other BPF programs by using *tail calls*. This is a powerful
    feature because it allows you to assemble more complex programs by combining smaller
    BPF functions. Kernel versions prior to 5.2 have a hard limit on the number of
    machine instructions that a BPF program can generate. This limit was set to 4,096
    to ensure that programs can terminate in a reasonable amount of time. However,
    as people built more complex BPF programs, they needed a way to extend the instruction
    limit imposed by the kernel, and this is where tail calls come into play. The
    instruction limit increases to one million instructions starting in version 5.2
    of the kernel. Tail call nesting is also limited, to 32 calls in this case, which
    means that you can combine up to 32 programs in a chain to generate a more complex
    solution to your problems.
  prefs: []
  type: TYPE_NORMAL
- en: When you call a BPF program from another BPF program, the kernel resets the
    program context completely. It’s important to keep this in mind because you’ll
    probably need a way to share information between programs. The context object
    that each BPF program receives as its argument won’t help us with this data sharing
    problem. In the next chapter, we talk about BPF maps as a way to share information
    between programs. There we also show you an example of how to use tail calls to
    jump from one BPF program to another.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we guided you through the first code examples to understand
    BPF programs. We also described all the types of programs that you can write with
    BPF. Don’t worry if some of the concepts presented here don’t make sense yet;
    as we advance through the book, we show you more examples of those programs. We
    also covered the important verification steps that BPF takes to ensure that your
    programs are safe to run.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we dive a little bit more into those programs and show more
    examples. We also talk about how BPF programs communicate with their counterparts
    in user-space and how they share information.
  prefs: []
  type: TYPE_NORMAL
