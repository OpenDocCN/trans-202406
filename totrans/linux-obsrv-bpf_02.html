<html><head></head><body><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Introduction"><div class="chapter" id="introduction">
<h1><span class="label">Chapter 1. </span>Introduction</h1>


<p>Over the past few decades computing systems have only grown in complexity. Reasoning about how software behaves has created multiple business categories, all of them trying solve the challenges of gaining insight into complex systems. One approach to get this visibility is to analyze the logs of data generated by all applications running in a computing system.<a data-type="indexterm" data-primary="logs" id="idm46623568915016"/> Logs are a great source of information. They can give you precise data about how an application is behaving. However, they constrain you because you get only the information that the engineers who built the application exposed in those logs. Gathering any additional information in log format from any system can be as challenging as decompiling the program and looking at the execution flow. <a data-type="indexterm" data-primary="metrics" id="idm46623568913768"/>Another popular approach is to use metrics to reason why a program behaves the way it does. Metrics differ from logs in the data format; whereas logs give you explicit data, metrics aggregate data to measure how a program behaves at a specific point in time.</p>

<p><em>Observability</em> is an emergent practice that approaches this problem from an different angle.<a data-type="indexterm" data-primary="observability, defined" id="idm46623568604584"/> People define observability as the capacity that we have to ask arbitrary questions and receive complex answers from any given system. A key difference between observability, logs, and metrics aggregation is the data that you collect. Given that by practicing observability you need to answer any arbitrary question at any point in time, the only way to reason about data is by collecting all of the data that your system can generate and aggregating it only when it’s necessary to answer your <span class="keep-together">questions</span>.</p>

<p>Nassim Nicholas Taleb, the author of best-seller books like <em>Antifragile: Things That Gain From Disorder</em> (Penguin Random House), popularized the term <em>Black Swan</em> for unexpected events, with major consequences, that could have been expected if they had been observed before they happened.<a data-type="indexterm" data-primary="Taleb, Nassim Nicholas" id="idm46623568601128"/><a data-type="indexterm" data-primary="black swan" id="idm46623568600424"/> In his book <em>The Black Swan</em> (Penguin Random House), he rationalizes how having relevant data could help in risk mitigation for these rare events. Black Swan events are more common than we think in software engineering, and they are inevitable. Because we can assume that we cannot prevent these kinds of events, our only option is to have as much information as possible about them to address them without affecting business systems in a critical way. Observability helps us build robust systems and mitigate future Black Swan events because it’s based on the premise that you’re collecting any data that can answer any future question. The study of Black Swan events and practicing observability converges in one central point, which is in the data that you gather from your systems.</p>

<p>Linux containers are an abstraction on top of a set of features on the Linux kernel to isolate and manage computer processes.<a data-type="indexterm" data-primary="containers" id="idm46623568597640"/> The kernel, traditionally in charge of resource management, also provides task isolation and security.<a data-type="indexterm" data-primary="kernel" id="idm46623568596696"/> In Linux, the main features that containers are based on are namespaces and cgroups. Namespaces are the components that isolate tasks from one another.<a data-type="indexterm" data-primary="namespaces" id="idm46623568595720"/> In a sense, when you’re inside a namespace, you experience the operating system like there were no other tasks running on the computer. <a data-type="indexterm" data-primary="cgroups" id="idm46623568594760"/>Cgroups are the components that provide resource management.<a data-type="indexterm" data-primary="resource management" data-secondary="cgroups" id="idm46623568593960"/> From an operational point of view, they give you fine-grained control over any resource usage, such as CPU, disk I/O, network, and so on. In the past decade, with the raise in popularity of Linux containers, there has been a shift in the way software engineers design large distributed systems and compute platforms. Multitenant computing has grown completely reliant on these features in the kernel.</p>

<p>By relying so much on the low-level capabilities of the Linux kernel, we’ve tapped into a new source of complexity and information that we need to consider when we design observable systems. The kernel is an evented system, which means that all work is described and executed based on events.<a data-type="indexterm" data-primary="events-based systems" id="idm46623568591912"/> Opening files is a kind of event, executing an arbitrary instruction by a CPU is an event, receiving a network packet is an event, and so on. Berkeley Packet Filter (BPF) is a subsystem in the kernel that can inspect those new sources of information.<a data-type="indexterm" data-primary="BPF" id="idm46623568590808"/><a data-type="indexterm" data-primary="Berkeley Packet Filter" data-see="BPF" id="idm46623568590136"/> BPF allows you to write programs that are safely executed when the kernel triggers any event. BPF gives you strong safety guarantees to prevent you from injecting system crashes and malicious behavior in those programs. BPF is enabling a new wave of tools to help system developers observe and work with these new platforms.</p>

<p>In this book, we show you the power that BPF offers you to make any computing system more observable. We also show you how to write BPF programs with the help of multiple programming languages. We’ve put the code for your programs on GitHub, so you don’t need to copy and paste it. You can find it in a Git repository <a href="https://oreil.ly/lbpf-repo">companion to this book</a>.</p>

<p>But before we begin to focus on the technical aspects of BPF, let’s look at how everything began.</p>






<section data-type="sect1" data-pdf-bookmark="BPF’s History"><div class="sect1" id="idm46623568449624">
<h1>BPF’s History</h1>

<p>In 1992,<a data-type="indexterm" data-primary="BPF" data-secondary="history of" id="idm46623568447896"/> Steven McCanne and Van Jacobson wrote the paper “The BSD Packet Filter: A New Architecture for User-Level Packet Capture.” In this paper, the authors described how they implemented a network packet filter for the Unix kernel that was 20 times faster than the state of the art in packet filtering at the time. Packet filters have a specific purpose: to provide applications that monitor the system’s network with direct information from the kernel. With this information, applications could decide what to do with those packets.<a data-type="indexterm" data-primary="packet filtering" data-secondary="BPF innovations in" id="idm46623568446216"/> BPF introduced two big innovations in packet filtering:</p>

<ul>
<li>
<p>A new virtual machine (VM) designed to work efficiently with register-based CPUs.<a data-type="indexterm" data-primary="virtual machine (VM)" id="idm46623568444040"/></p>
</li>
<li>
<p>The usage of per-application buffers that could filter packets without copying all the packet information. This minimized the amount of data BPF required to make decisions.</p>
</li>
</ul>

<p>These drastic improvements made all Unix systems adopt BPF as the technology of choice for network packet filtering, abandoning old implementations that consumed more memory and were less performant. This implementation is still present in many derivatives of that Unix kernel, including the Linux kernel.</p>

<p>In early 2014, Alexei Starovoitov introduced the extended BPF implementation. This new design was optimized for modern hardware, making its resulting instruction set faster than the machine code generated by the old BPF interpreter.<a data-type="indexterm" data-primary="eBPF" data-secondary="introduction of" id="idm46623568440648"/> This extended version also increased the number of registers in the BPF VM from two 32-bit registers to ten 64-bit registers. The increase in the number of registers, and in their width, opened the possibility to write more complex programs, because developers were free to exchange more information using function parameters. These changes, among other improvements, made the extended BPF version up to four times faster than the original BPF implementation.</p>

<p>The initial goal for this new implementation was to optimize the internal BPF instruction set that processed network filters. At this point, BPF was still restricted to kernel-space, and only a few programs in user-space could write BPF filters for the kernel to process, like Tcpdump and Seccomp, which we talk about in later chapters. Today, these programs still generate bytecode for the old BPF interpreter, but the kernel translates those instructions to the much improved internal representation.</p>

<p>In June 2014, the extended version of BPF was exposed to user-space. This was an inflection point for the future of BPF. As Alexei wrote in the patch that introduced these changes, “This patch set demonstrates the potential of eBPF.”</p>

<p>BPF became a top-level kernel subsystem, and it stopped being limited to the networking stack. BPF programs began to look more like kernel modules, with a big emphasis on safety and stability. Unlike kernel modules, BPF programs don’t require you to recompile your kernel, and they are guaranteed to complete without crashing.</p>

<p>The BPF verifier, which we talk about in the next chapter, added these required safety guarantees. It ensures that any BPF program will complete without crashing, and it ensures that programs don’t try to access memory out of range. These advantages come with certain restrictions, though: programs have a maximum size allowed, and loops need to be bounded to ensure that the system’s memory is never exhausted by a bad BPF program.</p>

<p>With the changes to make BPF accessible from user-space, the kernel developers also added a new system call (syscall), <code>bpf</code>. This new syscall will be the central piece of communication between user-space and the kernel. We discuss how to use this syscall to work with BPF programs and maps in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#running_your_first_BPF_programs">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#bpf_maps">3</a> of this book.</p>

<p>BPF maps will become the main mechanism to exchange data between the kernel and user-space.<a data-type="indexterm" data-primary="maps (BPF)" id="idm46623568431720"/> <a data-type="xref" href="ch02.html#running_your_first_BPF_programs">Chapter 2</a> demonstrates how to use these specialized structures to collect information from the kernel as well as send information to BPF programs that are already running in the kernel.</p>

<p>The extended BPF version is the starting point for this book. In the past five years, BPF has evolved significantly since the introduction of this extended version, and we cover in detail the evolution of BPF programs, BPF maps, and kernel subsystems that have been affected by this evolution.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Architecture"><div class="sect1" id="idm46623568449064">
<h1>Architecture</h1>

<p>BPF’s architecture within the kernel is fascinating.<a data-type="indexterm" data-primary="BPF" data-secondary="architecture within the kernel" id="idm46623568427720"/> We dive into its specific details through the entire book, but we want to give you a quick overview about how it works in this chapter.</p>

<p>As we mentioned earlier, BPF is a highly advanced VM, running code instructions in an isolated environment.<a data-type="indexterm" data-primary="Java Virtual Machine (JVM)" id="idm46623568425928"/> In a sense, you can think of BPF like how you think about the Java Virtual Machine (JVM), a specialized program that runs machine code compiled from a high-level programming language.<a data-type="indexterm" data-primary="compilers" data-secondary="support for BPF" id="idm46623568424872"/> Compilers like LLVM, and GNU Compiler Collection (GCC) in the near future, provide support for BPF, allowing you to compile C code into BPF instructions. After your code is compiled, BPF uses a verifier to ensure that the program is safe to run by the kernel. It prevents you from running code that might compromise your system by crashing the kernel. If your code is safe, the BPF program will be loaded in the kernel.<a data-type="indexterm" data-primary="compilers" data-secondary="JIT compiler for BPF instructions" id="idm46623568423368"/> The Linux kernel also incorporates a just-in-time (JIT) compiler for BPF instructions. The JIT will transform the BPF bytecode into machine code directly after the program is verified, avoiding this overhead on execution time. One interesting aspect of this architecture is that you don’t need to restart your system to load BPF programs; you can load them on demand, and you can also write your own init scripts that load BPF programs when your system starts.</p>

<p>Before the kernel runs any BPF program, it needs to know which execution point the program is attached to.<a data-type="indexterm" data-primary="execution points" id="idm46623568421288"/> There are multiple attachment points in the kernel, and the list is growing. The execution points are defined by the BPF program types; we discuss them in the next chapter. When you choose an execution point, the kernel also makes available specific function helpers that you can use to work with the data that your program receives, making execution points and BPF programs tightly coupled.</p>

<p>The final component in BPF’s architecture is responsible for sharing data between the kernel and user-space.<a data-type="indexterm" data-primary="kernel" data-secondary="sharing data between user-space and" id="idm46623568419528"/><a data-type="indexterm" data-primary="user-space" data-secondary="sharing data between kernel and" id="idm46623568418536"/> This component is called a BPF <em>map</em>, and we talk about maps in <a data-type="xref" href="ch03.html#bpf_maps">Chapter 3</a>. BPF maps are bidirectional structures to share data. This means that you can write and read them from both sides, the kernel and user-space. There are several types of structures, from simple arrays and hash maps to specialized maps, that allow you to save entire BPF programs in them.</p>

<p>We cover every component in BPF’s architecture in more detail as the book progresses. You’ll also learn to take advantage of BPF’s extensibility and data sharing, with specific examples covering topics ranging from stack trace analysis to network filtering and runtime isolation.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46623568415064">
<h1>Conclusion</h1>

<p>We wrote this book to help you become familar with the basic BPF concepts that you’re going to need in your day-to-day work with this Linux subsystem. BPF is still a technology in development, and new concepts and paradigms are growing as we are writing this book. Ideally, this book will help you expand your knowledge easily by giving you a solid base of BPF’s foundational components.</p>

<p>The next chapter dives directly into the structure of BPF programs and how the kernel runs them. It also covers the points in the kernel where you can attach those programs. This will help you become familiar with all the data that your programs can consume and how to use it.</p>
</div></section>







</div></section></body></html>