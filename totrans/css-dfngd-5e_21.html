<html><head></head><body><section data-pdf-bookmark="Chapter 21. CSS At-Rules" data-type="chapter" epub:type="chapter"><div class="chapter" id="css-at-rules">&#13;
<h1><span class="label">Chapter 21. </span>CSS At-Rules</h1>&#13;
&#13;
&#13;
<p>For 20 chapters now, we’ve explored the <a data-primary="at-rules" data-type="indexterm" id="ix_at-rules_ch21"/>properties, values, and selectors that can be combined to create CSS rules.  These are what we might call <em>normal rules</em> or <em>regular rules</em>, and they’re powerful, but sometimes more is needed.  Sometimes there needs to be a way to encapsulate certain styles in conditional blocks, such that styles can be applied at certain page widths or only if a given CSS feature is recognized by the browser processing the stylesheet.</p>&#13;
&#13;
<p>These are almost invariably enclosed in <em>at-rules</em>, so called because they start with an at (<code>@</code>) symbol.  You’ve seen some of these in previous chapters, such as <code>@font-face</code> and <code>@counter-style</code>, but there are still more that aren’t so tightly bound to specifics of styling.  This chapter explores the three powerful at-rules <code>@media</code>, <code>@container</code>, and <code>@supports</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Media Queries" data-type="sect1"><div class="sect1" id="idm45176027954512">&#13;
<h1>Media Queries</h1>&#13;
&#13;
<p>Thanks to the <a data-primary="media queries (@media)" data-type="indexterm" id="ix_media_qs"/><a data-primary="at-rules" data-secondary="media queries" data-type="indexterm" id="ix_atrule_media"/>mechanisms defined in HTML and CSS called <em>media queries</em>, you can restrict any set of styles (including entire stylesheets) to a specific medium, such as screen or print, and to a specific set of media conditions. These mechanisms allow you to define a combination of media types and conditions such as display size or color depth, to pick two examples. We’ll cover the basic form before exploring the more complex forms.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Basic Media Queries" data-type="sect2"><div class="sect2" id="basic-media-queries">&#13;
<h2>Basic Media Queries</h2>&#13;
&#13;
<p class="pagebreak-after">For <a data-primary="media queries (@media)" data-secondary="media attribute" data-type="indexterm" id="ix_media_q_attr"/><a data-primary="&lt;style&gt; element" data-primary-sortas="style element" data-type="indexterm" id="ix_style_elem_media"/><a data-primary="&lt;link&gt; tag" data-primary-sortas="link tag" data-type="indexterm" id="idm45176027944704"/>HTML-based stylesheets, you can impose medium restrictions through the <code>media</code> attribute. This works the same for both the <code>&lt;link&gt;</code> and <code>&lt;style&gt;</code> elements:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">link</code> <code class="na">rel</code><code class="o">=</code><code class="s">"stylesheet"</code> <code class="na">media</code><code class="o">=</code><code class="s">"print"</code>&#13;
    <code class="na">href</code><code class="o">=</code><code class="s">"article-print.css"</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">style</code> <code class="na">media</code><code class="o">=</code><code class="s">"print"</code><code class="p">&gt;</code>&#13;
    <code class="nt">body</code> <code class="p">{</code><code class="k">font-family</code><code class="o">:</code> <code class="nb">sans-serif</code><code class="p">;}</code>&#13;
<code class="nt">&lt;/style&gt;</code></pre>&#13;
&#13;
<p>The <code>media</code> attribute<a data-primary="media attribute" data-type="indexterm" id="ix_media_attr_ch21"/> can accept a single medium value or a comma-separated list of values. Thus, to link in a stylesheet that should be used in only the <code>screen</code> and <code>print</code> media, you would write this:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">link</code> <code class="na">rel</code><code class="o">=</code><code class="s">"stylesheet"</code> <code class="na">media</code><code class="o">=</code><code class="s">"screen, print"</code>&#13;
    <code class="na">href</code><code class="o">=</code><code class="s">"visual.css"</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>In a <a data-primary="at-rules" data-secondary="@import" data-secondary-sortas="import" data-type="indexterm" id="idm45176027910752"/><a data-primary="@import rule" data-primary-sortas="import rule" data-type="indexterm" id="idm45176027876448"/>stylesheet itself, you can also impose medium restrictions on <code>@import</code> rules:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="cp">@import url(visual.css) screen;</code>&#13;
<code class="cp">@import url(article-print.css) print;</code></pre>&#13;
&#13;
<p>Remember <a data-primary="all media type" data-type="indexterm" id="idm45176027845200"/>that if you don’t add medium information to a stylesheet, it will be applied in <em>all</em> media. Therefore, if you want one set of styles to apply only onscreen, and another to apply only in print, you need to add medium information to both stylesheets. For &#13;
<span class="keep-together">example:</span></p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">link</code> <code class="na">rel</code><code class="o">=</code><code class="s">"stylesheet"</code> <code class="na">media</code><code class="o">=</code><code class="s">"screen"</code>&#13;
    <code class="na">href</code><code class="o">=</code><code class="s">"article-screen.css"</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">link</code> <code class="na">rel</code><code class="o">=</code><code class="s">"stylesheet"</code> <code class="na">media</code><code class="o">=</code><code class="s">"print"</code>&#13;
    <code class="na">href</code><code class="o">=</code><code class="s">"article-print.css"</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>If you were to remove the <code>media</code> attribute from the first <code>&lt;link&gt;</code> element in this example, the rules found in the stylesheet <em>article-screen.css</em> would be applied in <em>all</em> media.</p>&#13;
&#13;
<p>CSS also defines syntax for <code>@media</code> blocks. This allows you to define styles for multiple media within the same stylesheet. Consider this basic example:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">style</code><code class="p">&gt;</code>&#13;
<code class="nt">body</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="k">@media</code> <code class="nt">screen</code> <code class="p">{</code>&#13;
    <code class="nt">body</code> <code class="p">{</code><code class="k">font-family</code><code class="o">:</code> <code class="nb">sans-serif</code><code class="p">;}</code>&#13;
    <code class="nt">h1</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="nt">print</code> <code class="p">{</code>&#13;
    <code class="nt">body</code> <code class="p">{</code><code class="k">font-family</code><code class="o">:</code> <code class="nb">serif</code><code class="p">;}</code>&#13;
    <code class="nt">h1</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code> <code class="k">border-bottom</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">&lt;/style&gt;</code></pre>&#13;
&#13;
<p>Here we see that in all media, the <code>&lt;body&gt;</code> element is given a white background and a black foreground by the first rule.  This happens because its stylesheet, the one defined by the <code>style</code> attribute, has no <code>media</code> attribute and thus defaults to <code>all</code>. Next, a block of rules is provided for the <code>screen</code> medium alone, followed by another block of rules that applies only in the <code>print</code> medium.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The indentation shown in these blocks is solely for purposes of clarity. You don’t have to indent the rules found inside an <code>@media</code> block, but you’re welcome to do so if it makes your CSS easier to read.</p>&#13;
</div>&#13;
&#13;
<p>The <code>@media</code> blocks can be any size, containing any number of rules. When authors have control over a single stylesheet, such as in a shared hosting environment or a CMS that restricts what users can edit, <code>@media</code> blocks may be the only way to define medium-specific styles. This is also the case when CSS is used to style a document using an XML language that does not contain a <code>media</code> attribute or its equivalent.</p>&#13;
&#13;
<p>These are the three most widely recognized media types:</p>&#13;
<dl>&#13;
<dt><code>all</code></dt>&#13;
<dd>&#13;
<p>Use in all presentational media.</p>&#13;
</dd>&#13;
<dt><code>print</code></dt>&#13;
<dd>&#13;
<p>Use <a data-primary="print media type" data-type="indexterm" id="idm45176027676912"/>when printing the document for sighted users, and also when displaying a print preview of the document.</p>&#13;
</dd>&#13;
<dt><code>screen</code></dt>&#13;
<dd>&#13;
<p>Use <a data-primary="screen media type" data-seealso="viewport" data-type="indexterm" id="idm45176027674528"/>when presenting the document in a screen medium like a desktop computer monitor or a handheld device. All web browsers running on such systems are screen-medium user agents.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>It’s entirely possible that new media types will be added over time, so remember that this limited list may not always be so limited.  It’s fairly easy to imagine <code>augmented-reality</code> as a media type, for example, since text in AR displays would likely need to be of higher contrast in order to stand out against the background reality.</p>&#13;
&#13;
<p>HTML4 defined a list of media types that CSS originally recognized, but most have been deprecated and should be avoided. These are <code>aural</code>, <code>braille</code>, <code>embossed</code>, <code>handheld</code>, <code>projection</code>, <code>speech</code>, <code>tty</code>, and <code>tv</code>. If you have old stylesheets that use these media types, they should almost certainly be converted to one of the three recognized media types, if &#13;
<span class="keep-together">possible.</span></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of 2022, a couple of browsers still support <code>projection</code>, which allows a document to be presented as a slideshow.  Several mobile-device browsers also support the <code>handheld</code> type, but not in &#13;
<span class="keep-together">consistent</span> ways.</p>&#13;
</div>&#13;
&#13;
<p>It’s possible in some circumstances to combine media types into comma-separated lists, though the rationale for doing so isn’t terribly compelling, given the small number of media types currently available.  For example, styles could be restricted to only screen and print media in the following ways:<a data-primary="" data-startref="ix_media_q_attr" data-type="indexterm" id="idm45176027664128"/><a data-primary="" data-startref="ix_style_elem_media" data-type="indexterm" id="idm45176027663152"/><a data-primary="" data-startref="ix_media_attr_ch21" data-type="indexterm" id="idm45176027662208"/></p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">link</code> <code class="na">rel</code><code class="o">=</code><code class="s">"stylesheet"</code> <code class="na">media</code><code class="o">=</code><code class="s">"screen, print"</code>&#13;
    <code class="na">href</code><code class="o">=</code><code class="s">"article.css"</code><code class="p">&gt;</code></pre>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@import</code> <code class="sx">url(article.css)</code> <code class="nt">print</code><code class="o">,</code> <code class="nt">screen</code><code class="p">;</code>&#13;
&#13;
<code class="k">@media</code> <code class="nt">screen</code><code class="o">,</code><code class="nt">print</code> <code class="p">{</code>&#13;
    <code class="c">/* styles go here */</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Complex Media Queries" data-type="sect2"><div class="sect2" id="complex-media-queries">&#13;
<h2>Complex Media Queries</h2>&#13;
&#13;
<p>In the <a data-primary="media queries (@media)" data-secondary="complex" data-type="indexterm" id="ix_media_q_complex"/>previous section, you saw how multiple media types could be chained together with a comma.  We might call that a <em>compound media query</em>, because it allows us to address multiple media at once.  There is a great deal more to media queries, though: it’s possible to apply styles based not just media types, but also features of those media, such as display size or color depth.</p>&#13;
&#13;
<p>This is a great deal of power, and it’s not enough to rely on commas to make it all happen.  Thus, CSS includes the logical operator <code>and</code> to pair media types with features of those media.</p>&#13;
&#13;
<p>Let’s see how this plays out in practice.  Here are two essentially equivalent ways of applying an external stylesheet when rendering the document on a color printer:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">link</code> <code class="na">href</code><code class="o">=</code><code class="s">"print-color.css"</code>&#13;
    <code class="na">media</code><code class="o">=</code><code class="s">"print and (color)"</code> <code class="na">rel</code><code class="o">=</code><code class="s">"stylesheet"</code><code class="p">&gt;</code></pre>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="cp">@import url(print-color.css) print and (color);</code></pre>&#13;
&#13;
<p>Anywhere a media type can be given, a media query can be constructed. This means that, following on the examples of the previous section, it is possible to list more than one query in a comma-separated list:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">link</code> <code class="na">href</code><code class="o">=</code><code class="s">"print-color.css"</code>&#13;
   <code class="na">media</code><code class="o">=</code><code class="s">"print and (color), screen and (color)"</code> <code class="na">rel</code><code class="o">=</code><code class="s">"stylesheet"</code><code class="p">&gt;</code></pre>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="cp">@import url(print-color.css) print and (color), screen and (color);</code></pre>&#13;
&#13;
<p>If even one of the media queries evaluates to <code>true</code>, the associated stylesheet is applied. Thus, given the previous <code>@import</code>, <em>print-color.css</em> will be applied if rendering to a color printer <em>or</em> to a color screen environment. If printing on a black-and-white printer, both queries will evaluate to <code>false</code> and <em>print-color.css</em> will not be applied to the document. The same holds true in a grayscale screen environment, any speech media environment, and so forth.</p>&#13;
&#13;
<p>Each media descriptor is composed of a media type and one or more listed media features, with each media feature descriptor enclosed in parentheses. If no media type is provided, it is assumed to be <code>all</code>, which makes the following two examples equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@media</code> <code class="nt">all</code> <code class="nt">and</code> <code class="p">(</code><code class="n">min</code><code class="o">-</code><code class="n">resolution</code><code class="o">:</code> <code class="m">96dpi</code><code class="p">)</code> <code class="p">{</code><code class="err">…</code><code class="p">}</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="n">min</code><code class="o">-</code><code class="n">resolution</code><code class="o">:</code> <code class="m">96dpi</code><code class="p">)</code> <code class="p">{</code><code class="err">…</code><code class="p">}</code></pre>&#13;
&#13;
<p>Generally <a data-primary="color descriptor, @media" data-type="indexterm" id="idm45176027422016"/><a data-primary="colors" data-secondary="@media" data-secondary-sortas="media" data-type="indexterm" id="idm45176027421408"/>speaking, a media feature descriptor is formatted like a property-value pair in CSS, only enclosed by parentheses. A few differences exist, most notably that some features can be specified without an accompanying value. For example, any color-based medium will be matched using <code>(color)</code>, whereas any color medium using a 16-bit color depth is matched using <code>(color: 16)</code>. In effect, the use of a descriptor without a value is a true/false test for that descriptor: <code>(color)</code> means “is this medium in color?”</p>&#13;
&#13;
<p>Multiple feature descriptors can be linked with the <code>and</code> logical keyword. In fact, there are two logical keywords in media queries:</p>&#13;
<dl>&#13;
<dt><code>and</code></dt>&#13;
<dd>&#13;
<p>Links <a data-primary="and logical keyword" data-type="indexterm" id="idm45176027453280"/>together two or more media features in such a way that all of them must be true for the query to be true.  For example, <code>(color) and (orientation: landscape) and (min-device-width: 800px)</code> means that all three conditions must be satisfied: if the media environment has color, is in landscape orientation, <em>and</em> the device’s display is at least 800 pixels wide, then the stylesheet is used.</p>&#13;
</dd>&#13;
<dt><code>not</code></dt>&#13;
<dd>&#13;
<p>Negates <a data-primary="not logical keyword" data-type="indexterm" id="idm45176027450080"/>the entire query so that if all of the conditions are true, the stylesheet is not applied. For example, <code>not (color) and (orientation: landscape) and (min-device-width: 800px)</code> means that if the three conditions are satisfied, the statement is negated.  Thus, if the media environment has color, is in landscape orientation, and the device’s display is at least 800 pixels wide, then the stylesheet is <em>not</em> used.  In all other cases, it will be used.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>CSS <a data-primary="or logical keyword" data-type="indexterm" id="idm45176027447648"/>has no <code>or</code> logical keyword, as its role is served by the comma, as shown previously.</p>&#13;
&#13;
<p>Note that the <code>not</code> keyword can be used only at the beginning of a media query. It is not presently legal to write something like <code>(color) and not (min-device-width: 800px)</code>. In such cases, the entire query block will be ignored.</p>&#13;
&#13;
<p>Let’s consider an example of how all this plays out:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@media</code> <code class="nt">screen</code> <code class="nt">and</code> <code class="p">(</code><code class="n">min</code><code class="o">-</code><code class="n">resolution</code><code class="o">:</code> <code class="m">72dpi</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nc">.cl01</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="nt">screen</code> <code class="nt">and</code> <code class="p">(</code><code class="n">min</code><code class="o">-</code><code class="n">resolution</code><code class="o">:</code> <code class="m">32767dpi</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nc">.cl02</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="nt">not</code> <code class="nt">print</code> <code class="p">{</code>&#13;
	<code class="nc">.cl03</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="nt">not</code> <code class="nt">print</code> <code class="nt">and</code> <code class="p">(</code><code class="n">monochrome</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nc">.cl04</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#mediaqueries-logical-operators">Figure 21-1</a> shows the result, but bear in mind that, even though you may be reading this on printed paper, the actual image was generated with a screen-medium browser (Firefox Nightly, as it happens) displaying an HTML document with the previous CSS applied to it.  So everything you see in <a data-type="xref" href="#mediaqueries-logical-operators">Figure 21-1</a> was operating under a <code>screen</code> medium.</p>&#13;
&#13;
<figure><div class="figure" id="mediaqueries-logical-operators">&#13;
<img alt="css5 2101" src="assets/css5_2101.png"/>&#13;
<h6><span class="label">Figure 21-1. </span>Logical operators in media queries</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first line is italicized because the screen on which the file was displayed had a resolution equal to or greater than 72 dots per inch.  Its resolution was not, however, <code>32767dpi</code> or higher, so the second media block is skipped and thus the second line stays un-italicized.  The third line is italicized because, being a screen display, it was <code>not print</code>.  The last line is italicized because it was either not print or not monochrome—in this case, not monochrome.</p>&#13;
&#13;
<p>Another keyword, <code>only</code>, was designed to create deliberate backward incompatibility. Yes, really.</p>&#13;
<dl>&#13;
<dt><code>only</code></dt>&#13;
<dd>&#13;
<p>Used to <a data-primary="only keyword" data-type="indexterm" id="idm45176027298752"/>hide a stylesheet from browsers old enough that they understand media queries but not media types.  (This is almost never a problem in modern usage, but the capability was created and so we document it here.)  In browsers that <em>do</em> understand media types, the <code>only</code> keyword is ignored and the stylesheet is applied.  In browsers that do not understand media types, the <code>only</code> keyword creates an apparent media type of <code>only all</code>, which is not valid.<a data-primary="" data-startref="ix_media_q_complex" data-type="indexterm" id="idm45176027296128"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Special Value Types" data-type="sect2"><div class="sect2" id="special-value-types">&#13;
<h2>Special Value Types</h2>&#13;
&#13;
<p>Two <a data-primary="media queries (@media)" data-secondary="special value types" data-type="indexterm" id="idm45176027293840"/>value types were introduced by media queries. These types are used in conjunction with specific media features, which are explained later in the chapter:</p>&#13;
<dl>&#13;
<dt>&lt;<em><code>ratio</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>Two <a data-primary="&lt;ratio&gt; value type" data-primary-sortas="ratio value type" data-type="indexterm" id="idm45176027290656"/>numbers separated by a forward slash (<code>/</code>), defined in <a data-type="xref" href="ch05.html#values_and_units">Chapter 5</a>.</p>&#13;
</dd>&#13;
<dt>&lt;<em><code>resolution</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>A resolution<a data-primary="&lt;resolution&gt; value type" data-primary-sortas="resolution value type" data-type="indexterm" id="idm45176027286032"/> value is a positive &lt;<em><code>integer</code></em>&gt; followed by either of the unit identifiers <code>dpi</code> or <code>dpcm</code>.  In CSS terms, a <em>dot</em> is any display unit, the most familiar of which is the pixel.  As usual, whitespace is not permitted between the &lt;<em><code>integer</code></em>&gt; and the identifier.  Therefore, a display that has exactly 150 pixels (dots) per inch is matched with <code>150dpi</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Keyword Media Features" data-type="sect2"><div class="sect2" id="keyword-media-feature-descriptors">&#13;
<h2>Keyword Media Features</h2>&#13;
&#13;
<p>So far you’ve <a data-primary="media queries (@media)" data-secondary="media feature descriptors and values" data-type="indexterm" id="ix_media_desc_value"/>seen several media features in the examples, but not a complete list of the possible features and their values. Let’s fix that now!</p>&#13;
&#13;
<p>Note that none of the following values can be negative, and that media features are always enclosed in parentheses:</p>&#13;
<dl>&#13;
<dt>Media feature: <code>any-hover</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>none</code> | <code>hover</code></dt>&#13;
<dd>&#13;
<p>Checks for any <a data-primary="any-hover descriptor, @media" data-type="indexterm" id="idm45176027273440"/>available input mechanism that can hover over elements (i.e., trigger a <code>:hover</code> state). The <code>none</code> value means there are no such mechanisms, or no mechanisms that can do so conveniently.  Compare with the <code>hover</code> media feature, which restricts checking to the primary input mechanism.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>any-pointer</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values:  <code>none</code> | <code>coarse</code> | <code>fine</code></dt>&#13;
<dd>&#13;
<p>Checks for an <a data-primary="any-pointer descriptor, @media" data-type="indexterm" id="idm45176027266880"/>input mechanism that creates an onscreen pointer. The <code>none</code> values indicates no such devices, <code>coarse</code> indicates at least one device with limited accuracy (e.g., a finger), and <code>fine</code> indicates at least one device with high accuracy (e.g., a mouse).  Compare with <code>pointer</code>, which restricts checking to the primary input mechanism.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>color-gamut</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>srgb</code> | <code>p3</code> | <code>rec2020</code></dt>&#13;
<dd>&#13;
<p>Tests the <a data-primary="color-gamut descriptor, @media" data-type="indexterm" id="idm45176027260016"/>range of colors supported by both the browser and the output device.  As of late 2022, the majority of displays support the <code>srgb</code> and <code>p3</code> gamuts. The <code>p3</code> value refers to the Display P3 color space, which is a superset of sRGB. The <code>rec2020</code> value refers to the gamut specified by the ITU-R Recommendation BT.2020 Color Space, which is a superset of P3. The <code>color-gamut</code> media feature is not supported by Firefox as of late 2022.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>display-mode</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>fullscreen</code> | <code>standalone</code> | <code>minimal-ui</code> | <code>browser</code></dt>&#13;
<dd>&#13;
<p>Tests the <a data-primary="display-mode descriptor, @media" data-type="indexterm" id="idm45176027252496"/>display mode of the top-level browsing context and any child browsing contexts.  This corresponds to the Web Application Manifest specification’s &#13;
<span class="keep-together"><code>display</code></span> member, and is commonly used to check if a progressive web application visitor is browsing a website or on an installed application, but applies whether or not a manifest has been defined.  See <a data-type="xref" href="#forced_colors_contrast_and_display_mode">“Forced Colors, Contrast, and Display Mode”</a> for details.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>dynamic-range</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>standard</code> | <code>high</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="dynamic-range descriptor, @media" data-type="indexterm" id="idm45176027245920"/>whether the browsing context supports a high dynamic range for visual output.  The <code>high</code> value means the media environment supports high peak brightness, a high contrast ratio, and a 24-bit color depth or higher.  There are no precisely defined values for high peak brightness or color contrast, so this is left to browsers to decide. Any device that matches <code>high</code> will also match <code>standard</code>. The <code>dynamic-range</code> media feature achieved widespread browser support in early 2022.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>forced-colors</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>none</code> | <code>active</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="forced-colors descriptor, @media" data-type="indexterm" id="idm45176027239616"/>whether the browser is in <em>forced-color</em> mode, which forces browser-default values for a set of CSS properties such as <code>color</code> and <code>background-color</code>, and specific values for a handful of others, and may also trigger a <code>prefers-color-scheme</code> value.  See <a data-type="xref" href="#forced_colors_contrast_and_display_mode">“Forced Colors, Contrast, and Display Mode”</a> for details. The <code>forced-colors</code> media feature is not supported by WebKit as of late 2022.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>grid</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>0</code> | <code>1</code></dt>&#13;
<dd>&#13;
<p>Refers <a data-primary="grid descriptor, @media" data-type="indexterm" id="idm45176027232032"/>to the presence (or absence) of a grid-based output device, such as a TTY terminal. This does <em>not</em> refer to CSS Grid. A grid-based device will return <code>1</code>; otherwise, <code>0</code> is returned. This media feature can be used in place of the old <code>tty</code> media descriptor.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>hover</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>none</code> | <code>hover</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="hover descriptor, @media" data-type="indexterm" id="idm45176027225504"/>whether the user’s <em>primary</em> input mechanism can hover over elements. The <code>none</code> value means the primary mechanism cannot hover, or cannot do so conveniently; an example of the latter is a mobile device that pretends to hover when an inconvenient tap-and-hold action is performed. The <code>hover</code> value means hovering is convenient, such as with a mouse.  Compare to <code>any-hover</code>, which checks whether any mechanism permits hovering, not just the primary.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>inverted-colors</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>none</code> | <code>inverted</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="" data-startref="inverted-colors descriptor, @media" data-type="indexterm" id="idm45176027219216"/>whether colors are being inverted by the underlying operating system. The <code>none</code> value means colors are being displayed normally; <code>inverted</code> means that all pixels in the display area are being inverted. The <code>inverted-colors</code> media feature is supported only in WebKit as of late 2022.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>orientation</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>portrait</code> | <code>landscape</code></dt>&#13;
<dd>&#13;
<p>Refers<a data-primary="orientation descriptor, @media" data-type="indexterm" id="idm45176027212576"/> to the orientation of the user agent’s display area, where <code>portrait</code> is returned if the media feature <code>height</code> is equal to or greater than the media feature <code>width</code>. Otherwise, the result is <code>landscape</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>overflow-block</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>none</code> | <code>scroll</code> | <code>optional-paged</code> | <code>paged</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="overflow-block descriptor, @media" data-type="indexterm" id="idm45176027205264"/>how the output device handles content that overflows along the block axis. The <code>none</code> value means the overflowed content cannot be accessed; <code>scroll</code> means the content can be accessed by scrolling to it in some way; <code>optional-paged</code> means the user can scroll to the content, but page breaks can be manually triggered using properties like <code>break-inside</code>; <code>paged</code> means overflowing content can be accessed only by “paging” to see the content, as in an ebook. The <code>overflow-block</code> media feature is supported only in Firefox as of late 2022.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>overflow-inline</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>none</code> | <code>scroll</code> </dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="overflow-inline descriptor, @media" data-type="indexterm" id="idm45176027197728"/>to see how the output device handles content that overflows along the inline axis.  The <code>none</code> value means the overflowed content cannot be accessed; <code>scroll</code> means the content can be accessed by scrolling to it in some way. The <code>overflow-inline</code> media feature is supported only in Firefox as of late 2022.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>pointer</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>none</code> | <code>coarse</code> | <code>fine</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="pointer descriptor, @media" data-type="indexterm" id="idm45176027190880"/>whether the <em>primary</em> input mechanism creates an onscreen pointer. The <code>none</code> value means the primary input device generates no pointer, <code>coarse</code> means it does but with limited accuracy, and <code>fine</code> means it does with high accuracy (e.g., a mouse).  Compare to <code>any-pointer</code>, which checks whether any mechanism creates a pointer, not just the primary.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>prefers-color-scheme</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>light</code> | <code>dark</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="prefers-color-scheme descriptor, @media" data-type="indexterm" id="idm45176027184128"/>which color scheme the user has selected at the browser or operating system level (i.e., Light mode or Dark mode).  Thus, the author can define specific color values for, say, <code>prefers-color-scheme: dark</code>.  Safari adds a <code>no-preference</code> value, but this has not been standardized or adopted by other browsers as of late 2022.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>prefers-contrast</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>no-preference</code> | <code>less</code> | <code>more</code> | <code>custom</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="prefers-contrast descriptor, @media" data-type="indexterm" id="idm45176027177520"/>whether the user has set a preference for high-contrast output, at either the browser or operating system level (e.g., Windows High Contrast mode).  See <a data-type="xref" href="#forced_colors_contrast_and_display_mode">“Forced Colors, Contrast, and Display Mode”</a> for details.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>prefers-reduced-motion</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>no-preference</code> | <code>reduce</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="prefers-reduced-motion descriptor, @media" data-type="indexterm" id="idm45176027172112"/>whether the user has set a preference regarding motion, at either the browser or operating system level. The <code>reduce</code> value means the user has indicated they wish motion to be reduced or eliminated, possibly because of vestibular disorders that create discomfort when viewing motion onscreen.  Transitions and animations should most often be put into a <code>prefers-reduced-motion: reduce</code> block for accessibility reasons.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>scan</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>progressive</code> | <code>interlace</code></dt>&#13;
<dd>&#13;
<p>Refers <a data-primary="scan descriptor, @media" data-type="indexterm" id="idm45176027166640"/>to the scanning process used in an output device. The <code>interlace</code> value is the type generally used in CRT and some plasma displays. As of late 2022, all known implementations match the <code>progressive</code> value, making this media feature somewhat useless.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>scripting</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>none</code> | <code>initial-only</code> | <code>enabled</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="scripting descriptor, @media" data-type="indexterm" id="idm45176027160784"/>whether a scripting language such as JavaScript is available. The <code>initial-only</code> value means scripting can be performed only at page load, but not thereafter. The <code>scripting</code> media feature is not supported by any browser as of late 2022.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media feature: <code>update</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>none</code> | <code>slow</code> | <code>fast</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="update descriptor, @media" data-type="indexterm" id="idm45176027154368"/>whether the content’s appearance can be changed after page load. The <code>none</code> value means no updates are possible, such as in print media. The <code>slow</code> value means changes are possible but cannot be animated smoothly because of device or browser constraints. The <code>fast</code> value means smooth animations are possible. The <code>update</code> media feature is supported only by Firefox as of late 2022.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
</dl>&#13;
<dl class="pagebreak-before">&#13;
<dt>Media feature: <code>video-dynamic-range</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: <code>standard</code> | <code>high</code></dt>&#13;
<dd>&#13;
<p>Checks <a data-primary="video-dynamic-range descriptor, @media" data-type="indexterm" id="idm45176027147568"/>whether the browsing context supports a high dynamic range for visual output on videos.  This is useful because some devices render video separately from other graphics, and so may support a different dynamic range for video than for other content. The <code>high</code> value means the media environment supports high peak brightness, a high contrast ratio, and a 24-bit color depth or higher.  There are no precisely defined values for high peak brightness or color contrast, so this is left to browsers to decide. Any device that matches <code>high</code> will also match <code>standard</code>. The <code>video-dynamic-range</code> media feature achieved widespread browser support in early 2022.<a data-primary="" data-startref="ix_media_desc_value" data-type="indexterm" id="idm45176027145040"/></p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Forced Colors, Contrast, and Display Mode" data-type="sect2"><div class="sect2" id="forced_colors_contrast_and_display_mode">&#13;
<h2>Forced Colors, Contrast, and Display Mode</h2>&#13;
&#13;
<p>Three of the <a data-primary="media queries (@media)" data-secondary="user preference and media features" data-type="indexterm" id="ix_media_q_user_pref"/>previously defined media features relate to user preference in their display, and allow you to detect those preferences so you may style accordingly.  Two are closely intertwined, so we’ll start with them.</p>&#13;
&#13;
<p>If a user has gone to the effort of defining a specific set of colors to be used in the display of their content, such as with Windows High Contrast mode, then <code>forced-colors: active</code> will be matched, as will <code>prefers-contrast: custom</code>. You can use one or both of these queries to apply specific styles under such conditions.</p>&#13;
&#13;
<p>If <code>forced-colors: active</code> returns true, the following CSS properties will be forced to use the browser (or operating system) default values, overriding any values you may have declared:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>background-color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>column-rule-color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>outline-color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>text-decoration-color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>text-emphasis-color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>-webkit-tap-highlight-color</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Also, the SVG <code>fill</code> and <code>stroke</code> attributes will be ignored and set to their default values.</p>&#13;
&#13;
<p class="pagebreak-before">Additionally, the following property-value combinations are enforced over whatever the author has declared:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>box-shadow: none</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>text-shadow: none</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>background-image: none</code> for values that are not URL-based (e.g., gradients)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>color-scheme: light dark</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>scrollbar-color: auto</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This means that, to pick one example, any element whose hover or focus styles depend on changing the color of a border will fail to have an effect.  Thus, you could provide a change of font weight and border style (not color) instead:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">]</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">nav</code> <code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">]</code><code class="nd">:is</code><code class="o">(</code><code class="nd">:hover</code><code class="o">,</code> <code class="nd">:focus</code><code class="o">)</code> <code class="p">{</code><code class="k">border-color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
&#13;
<code class="k">@media</code> <code class="p">(</code><code class="n">forced</code><code class="o">-</code><code class="n">colors</code><code class="o">:</code> <code class="n">active</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nd">:hover</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;</code> <code class="k">border-style</code><code class="o">:</code> <code class="nb">dashed</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is an example of the sorts of changes you should make to accommodate forced-color situations, providing greater usability through small changes.  You <em>should not</em> use this query to set up an entire separate design for users who have forced certain colors.</p>&#13;
&#13;
<p>As noted previously, if a user has set things up such that <code>forced-colors: active</code> is triggered, <code>prefers-contrast: custom</code> will also be triggered.  The meanings of this media feature’s values are as follows:</p>&#13;
<dl>&#13;
<dt><code>no-preference</code></dt>&#13;
<dd>&#13;
<p>The browser and/or operating system are not aware of a user preference with regards to color contrast.</p>&#13;
</dd>&#13;
<dt><code>less</code></dt>&#13;
<dd>&#13;
<p>The user has requested interfaces with less contrast than usual.  Examples of this could be users with a propensity for migraine headaches or dyslexia, as some (not all) dyslexics find high-contrast text difficult to parse.</p>&#13;
</dd>&#13;
<dt><code>more</code></dt>&#13;
<dd>&#13;
<p>The user has requested interfaces with more contrast than usual.</p>&#13;
</dd>&#13;
<dt><code>custom</code></dt>&#13;
<dd>&#13;
<p>The user has defined a specific set of colors that are not matched by either <code>more</code> or <code>less</code>, such as the Windows High Contrast mode.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>It is possible to query for any value by not supplying a value, which is especially useful in this scenario.  You might cater to both low- and high-contrast users as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="sx">url(/assets/img/mosaic.png)</code> <code class="nb">repeat</code><code class="p">;}</code>&#13;
&#13;
<code class="k">@media</code> <code class="p">(</code><code class="n">prefers</code><code class="o">-</code><code class="n">contrast</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">body</code> <code class="p">{</code><code class="k">background-image</code><code class="o">:</code> <code class="nb">none</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>display-mode</code> media feature is entirely different from the previous two features.  The <code>display-mode</code> media feature lets authors determine the kind of display environment being used and act accordingly.</p>&#13;
&#13;
<p>First let’s define what the various values mean:</p>&#13;
<dl>&#13;
<dt><code>fullscreen</code></dt>&#13;
<dd>&#13;
<p>The application takes up the entire available display area and does not show any application chrome (e.g., address bar, back button, status bar, etc.).</p>&#13;
</dd>&#13;
<dt><code>standalone</code></dt>&#13;
<dd>&#13;
<p>The application appears like a native standalone application.  This removes application chrome such as address bar, but will make operating-system-derived navigation elements like back buttons available.</p>&#13;
</dd>&#13;
<dt><code>minimal-ui</code></dt>&#13;
<dd>&#13;
<p>The application appears similar to a native standalone application, but provides a way to access application chrome for things like address bars, the application’s navigation controls, and so on.  System-specific interface controls for things like “share” or “print” may also be included.</p>&#13;
</dd>&#13;
<dt><code>browser</code></dt>&#13;
<dd>&#13;
<p>The application appears as normal, showing the entire application chrome including things like the complete address bar with forward/back/home buttons, scrollbar gutters, and so on.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>These various states can be triggered either by the user putting the browser into a given mode (e.g., the user hitting F11 on Windows to enter full-screen mode), or by a Web Application Manifest’s <code>display</code> member.  The values are exactly the same in all respects; in fact, the Web Application Manifest specification just points to the values defined in the CSS Media Queries Level 5 specification.</p>&#13;
&#13;
<p>Thus, you can do things like define different layouts for different display modes.  Here’s a brief example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="c">/* add column and row templates here */</code><code class="p">}</code>&#13;
&#13;
<code class="k">@media</code> <code class="p">(</code><code class="k">display</code><code class="o">-</code><code class="n">mode</code><code class="o">:</code> <code class="n">fullscreen</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">body</code> <code class="p">{</code> <code class="c">/* different column and row templates here */</code><code class="p">}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="k">display</code><code class="o">-</code><code class="n">mode</code><code class="o">:</code> <code class="n">standalone</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">body</code> <code class="p">{</code> <code class="c">/* more different column and row templates here */</code><code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This can be especially useful if you intend to have your design used in multiple contexts, such as in web browsers, as web apps, on kiosks, and so on.<a data-primary="" data-startref="ix_media_q_user_pref" data-type="indexterm" id="idm45176026946880"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Ranged Media Features" data-type="sect2"><div class="sect2" id="ranged_descriptors">&#13;
<h2>Ranged Media Features</h2>&#13;
&#13;
<p>Now we <a data-primary="media queries (@media)" data-secondary="ranged media features" data-type="indexterm" id="ix_media_q_ranged"/>turn our attention to the media features that allow ranges, and have <code>min-</code> and &#13;
<span class="keep-together"><code>-max</code></span> variants in addition to accepting values like lengths or ratios.  They also have a more compact way of formatting value comparisons, which are discussed in an upcoming &#13;
<span class="keep-together">section.</span></p>&#13;
<dl>&#13;
<dt>Media features: <code>width</code>, <code>min-width</code>, <code>max-width</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>length</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The <a data-primary="width descriptor, @media" data-type="indexterm" id="idm45176026891088"/>&#13;
width of the viewport of the user agent. In a screen-media web browser, this is the width of the viewport <em>plus</em> any scrollbars. In paged media, this is the width of the page box, which is the area of the page in which content is rendered. Thus, <code>(min-width: 100rem)</code> applies when the viewport is greater than or equal to &#13;
<span class="keep-together">100 rem</span> wide.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media features: <code>height</code>, <code>min-height</code>, <code>max-height</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>length</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The height of the viewport of the user agent. In a screen-media web browser, this is the height of the viewport plus any scrollbars. In paged media, this is the height of the page box. Thus, <code>(height: 60rem)</code> applies when the viewport’s height is precisely 60 rems tall.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media features: <code>aspect-ratio</code>, <code>min-aspect-ratio</code>, <code>max-aspect-ratio</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>ratio</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The <a data-primary="aspect-ratio descriptor, @media" data-type="indexterm" id="idm45176026879136"/>ratio that results from comparing the <code>width</code> media feature to the <code>height</code> media feature (see the definition of &lt;<em><code>ratio</code></em>&gt; in <a data-type="xref" href="#special-value-types">“Special Value Types”</a>). Thus, <code>(min-aspect-ratio: 2/1)</code> applies to any viewport whose width-to-height ratio is at least 2:1.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media features: <code>color</code>, <code>min-color</code>, <code>max-color</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>integer</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The <a data-primary="colors" data-secondary="@media" data-secondary-sortas="media" data-type="indexterm" id="idm45176026871136"/><a data-primary="color descriptor, @media" data-type="indexterm" id="idm45176026869888"/>presence of color-display capability in the output device, with an <em>optional</em> number value representing the number of bits used in each color component. Thus, <code>(color)</code> applies to any device with any color depth at all, whereas <code>(min-color: 4)</code> means there must be at least 4 bits used per color component. Any device that does not support color will return <code>0</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media features: <code>color-index</code>, <code>min-color-index</code>, <code>max-color-index</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>integer</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The <a data-primary="color-index descriptor, @media" data-type="indexterm" id="idm45176026863008"/>total number of colors available in the output device’s color lookup table. Any device that does not use a color lookup table will return <code>0</code>. Thus, <code>(min-color-index: 256)</code> applies to any device with a minimum of 256 colors &#13;
<span class="keep-together">available.</span></p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media features: <code>monochrome</code>, <code>min-monochrome</code>, <code>max-monochrome</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>integer</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The <a data-primary="monochrome descriptor, @media" data-type="indexterm" id="idm45176026856144"/>presence of a monochrome display, with an <em>optional</em> number of bits per pixel in the output device’s frame buffer. Any device that is not monochrome will return <code>0</code>. Thus, <code>(monochrome)</code> applies to any monochrome output device, whereas <code>(min-monochrome: 2)</code> means any monochrome output device with a minimum of 2 bits per pixel in the frame buffer.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media features: <code>resolution</code>, <code>min-resolution</code>, <code>max-resolution</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>resolution</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The <a data-primary="resolution descriptor, @media" data-type="indexterm" id="idm45176026848992"/>resolution of the output device in terms of pixel density, measured in either dots per inch (dpi) or dots per centimeter (dpcm); see the definition of &lt;<em><code>resolution</code></em>&gt; in the next section for details. If an output device has pixels that are not square, the least dense axis is used; for example, if a device is 100 dpcm along one axis and 120 dpcm along the other, <code>100</code> is the value returned. Additionally, in such nonsquare cases, a bare <code>resolution</code> feature query—that is, one without a value—can never match (though <code>min-resolution</code> and <code>max-resolution</code> can). Note that resolution values must be not only nonnegative, but also nonzero.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>With ranged media feature values, it’s common to want to restrict rules to a specific range with a maximum and minimum.  For example, you might want to apply a certain margin between two display widths, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@media</code> <code class="p">(</code><code class="k">min-width</code><code class="o">:</code> <code class="m">20em</code><code class="p">)</code> <code class="nt">and</code> <code class="p">(</code><code class="k">max-width</code><code class="o">:</code> <code class="m">45em</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">body</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">:</code> <code class="m">0.75em</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Media Queries Level 4 defines a much more compact way to say the same thing, using standard mathematical expressions like equals, greater than, less than, and so on.  Thus, the previous example could be rewritten as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@media</code> <code class="p">(</code><code class="m">20em</code> <code class="o">&lt;</code> <code class="n">width</code> <code class="o">&lt;</code> <code class="m">45em</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">body</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">:</code> <code class="m">0.75em</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In other <a data-primary="&gt; (greater-than sign)" data-type="indexterm" id="idm45176026773536"/><a data-primary="greater-than sign (&gt;)" data-type="indexterm" id="idm45176026772928"/>words, “width is greater than 20 em and less than 45 em.”  If you want to have the rules in that media block apply at exactly 20 and 45 em of width, the <code>&lt;</code> symbols would be written as <code>&lt;=</code> instead.</p>&#13;
&#13;
<p>This syntax can be used to limit in only one direction, so to speak, as this example &#13;
<span class="keep-together">illustrates:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@media</code> <code class="p">(</code><code class="n">width</code> <code class="o">&lt;</code> <code class="m">64rem</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* tiny-width styles go here */</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="n">width</code> <code class="o">&gt;</code> <code class="m">192rem</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* enormous-width styles go here */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Any media feature that accepts a range as a value (see the preceding section) can use this syntax format.  This effectively does away with the need for <code>min-</code> and <code>max-</code> prefixes on the feature name, as well as for complex <code>and</code> constructions.</p>&#13;
&#13;
<p>You can also do multiple ranged queries by chaining them with the <code>and</code> combinator, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@media</code> <code class="p">(</code><code class="m">20em</code> <code class="o">&lt;</code> <code class="n">width</code> <code class="o">&lt;</code> <code class="m">45em</code><code class="p">)</code> <code class="nt">and</code> <code class="p">(</code><code class="n">resolution</code> <code class="o">=&lt;</code> <code class="m">600dpi</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">body</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">:</code> <code class="m">0.75em</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This will add an inline margin to the <code>&lt;body&gt;</code> element only when the width of the display area is between 20 and 45 em, and the output resolution is below 600 dots per inch.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of early 2023, the Chrome and Firefox browser families support the compact range syntax, and Safari has it in its nightly builds.  We hope this is supported everywhere soon after (or even before!) this edition is published.<a data-primary="" data-startref="ix_media_q_ranged" data-type="indexterm" id="idm45176026679984"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deprecated Media Features" data-type="sect2"><div class="sect2" id="deprecated_descriptors">&#13;
<h2>Deprecated Media Features</h2>&#13;
&#13;
<p>The <a data-primary="media queries (@media)" data-secondary="deprecated media features" data-type="indexterm" id="idm45176026653760"/>following media features have been deprecated, so browser support for them could disappear at any time.  We include them here since you may come across them in legacy CSS, and will need to know what they were intended to do so you can replace them with something more up-to-date.</p>&#13;
<dl>&#13;
<dt>Media features: <code>device-width</code>, <code>min-device-width</code>, <code>max-device-width</code></dt>&#13;
<dt>Best replaced by: <code>width</code>, <code>min-width</code>, <code>max-width</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>length</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The <a data-primary="device-width descriptor, @media" data-type="indexterm" id="idm45176026640176"/>width of the complete rendering area of the output device. In screen media, this is the width of the screen (i.e., a handheld device screen’s or desktop monitor’s horizontal measurement). In paged media, this is the width of the page itself. Thus, <code>(max-device-width: 1200px)</code> applies when the device’s output area is less than or equal to 1,200 pixels wide.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media features: <code>device-height</code>, <code>min-device-height</code>, <code>max-device-height</code></dt>&#13;
<dt>Best replaced by: <code>height</code>, <code>min-height</code>, <code>max-height</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>length</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The <a data-primary="device-height descriptor, @media" data-type="indexterm" id="idm45176026633104"/>height of the complete rendering area of the output device. In screen media, this is the height of the screen (i.e., a handheld device screen’s or desktop monitor’s vertical measurement). In paged media, this is the height of the page itself. Thus, <code>(max-device-height: 400px)</code> applies when the device’s output area is less than or equal to 400 pixels tall.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Media features: <code>device-aspect-ratio</code>, <code>min-device-aspect-ratio</code>, <code>max-device-aspect-ratio</code></dt>&#13;
<dt>Best replaced by: <code>aspect-ratio</code>, <code>min-aspect-ratio</code>, <code>max-aspect-ratio</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Values: &lt;<em><code>ratio</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>The <a data-primary="device-aspect-ratio descriptor, @media" data-type="indexterm" id="idm45176026625648"/>ratio that results from comparing the <code>device-width</code> media feature to the <code>device-height</code> media feature (see the definition of &lt;<em><code>ratio</code></em>&gt; in <a data-type="xref" href="#special-value-types">“Special Value Types”</a>). Thus, <code>(device-aspect-ratio: 16/9)</code> applies to any output device whose display area width-to-height ratio is <em>exactly</em> 16:9.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Responsive Styling" data-type="sect2"><div class="sect2" id="idm45176026621264">&#13;
<h2>Responsive Styling</h2>&#13;
&#13;
<p>Media <a data-primary="media queries (@media)" data-secondary="responsive styling using" data-type="indexterm" id="idm45176026619600"/><a data-primary="responsive styling, media features" data-type="indexterm" id="idm45176026618576"/>queries are the foundation on which the practice of <em>responsive web design</em> is built.  By applying different sets of rules depending on the display environment, it’s possible to marry “mobile-friendly” and “desktop-friendly” styles into a single stylesheet.</p>&#13;
&#13;
<p>We put these terms in quotes because, as you may have seen in your own life, the lines between what’s mobile and what’s desktop are blurred.  A laptop with a touch-sensitive screen that folds all the way back can act as both a tablet and a laptop, for example.  CSS doesn’t (yet) have a way of detecting whether a hinge is open past a certain point, nor whether the device is held in hand or sitting on a flat surface.  Instead, inferences are drawn from aspects of the media environment, like display size or display orientation.</p>&#13;
&#13;
<p>A fairly common pattern in responsive design is to define <em>breakpoints</em> for each <code>@media</code> block.  This often takes the form of certain pixel widths, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="c">/* …common styles here… */</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="k">max-width</code><code class="o">:</code> <code class="m">400px</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* …small-screen styles here… */</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="k">min-width</code><code class="o">:</code> <code class="m">401px</code><code class="p">)</code> <code class="nt">and</code> <code class="p">(</code><code class="k">max-width</code><code class="o">:</code> <code class="m">1000px</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* …medium-screen styles here… */</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="k">min-width</code><code class="o">:</code> <code class="m">1001px</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* …big-screen styles here… */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This makes certain assumptions about what a device can display and how it will report that, however.  For example, the iPhone 6 Plus had a resolution of 1,242 × 2,208, which it downsampled to 1,080 × 1,920.  Even at the downsampled resolution, that’s enough pixels across to qualify for big-screen styles in the previous example.</p>&#13;
&#13;
<p>But wait!  The iPhone 6 Plus also maintained an internal coordinate system of points that measured 414 × 736.  If it decided to use those as its definition of pixels, which would be entirely valid, then it would get only the small-screen styles.</p>&#13;
&#13;
<p>The point here isn’t to single out the iPhone 6 Plus as uniquely bad, which it wasn’t, but to illustrate the uncertainties of relying on pixel-based media queries.  Browser makers have gone to some effort to make their browsers behave with some semblance of sanity, but never quite as much as we’d like, and you never know when a new device’s assumptions will clash with your own.</p>&#13;
&#13;
<p>Other methods are available, though they come with their own uncertainties.  Instead of pixels, you might try em-based measures, something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="c">/* …common styles here… */</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="k">max-width</code><code class="o">:</code> <code class="m">20em</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* …small-screen styles here… */</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="k">min-width</code><code class="o">:</code> <code class="m">20.01em</code><code class="p">)</code> <code class="nt">and</code> <code class="p">(</code><code class="k">max-width</code><code class="o">:</code> <code class="m">50em</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* …medium-screen styles here… */</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="k">min-width</code><code class="o">:</code> <code class="m">50.01em</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* …big-screen styles here… */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This ties the breakpoints to text display size rather than pixels, which is more robust.  This isn’t perfect either, though: it relies on a sensible approach to determining the em width of, say, a smartphone.  It also directly relies on the actual font family and size used by the device, which varies from one device to another.</p>&#13;
&#13;
<p>Here’s another seemingly simple query set with potentially surprising results:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="c">/* …common styles here… */</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="n">orientation</code><code class="o">:</code> <code class="nb">landscape</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* …wider-than-taller styles here… */</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="p">(</code><code class="n">orientation</code><code class="o">:</code> <code class="nb">portrait</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* …taller-than-wider styles here… */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This feels like a good way to tell whether a smartphone is in use: after all, most of them are taller than they are wide, and most people don’t turn them sideways to read.  The wrinkle is that the <code>orientation</code> feature refers to the <code>height</code> and <code>width</code>; that is, <code>orientation</code> is <code>portrait</code> if <code>height</code> is equal to or larger than <code>width</code>.  Not <code>device-height</code> and <code>device-width</code>, but <code>height</code> and <code>width</code>, which refer to the display area of the user agent.</p>&#13;
&#13;
<p>That means a desktop browser window whose display area (the part inside the browser chrome) is taller than it is wide, or even perfectly square, will get the portrait styles.  So if you assume “portrait equals smartphone,” some of your desktop users could get a &#13;
<span class="keep-together">surprise.</span></p>&#13;
&#13;
<p>The basic point here is that responsive styling is powerful, and as with any powerful tool, its use requires a fair amount of thought and care.  Carefully considering the implications of each combination of feature queries is the minimum requirement for successful responsiveness.<a data-primary="" data-startref="ix_atrule_media" data-type="indexterm" id="idm45176026464784"/><a data-primary="" data-startref="ix_media_qs" data-type="indexterm" id="idm45176026463808"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Paged Media" data-type="sect1"><div class="sect1" id="paged-media">&#13;
<h1>Paged Media</h1>&#13;
&#13;
<p>In CSS terms, a <em>paged medium</em> is any <a data-primary="paged media" data-type="indexterm" id="ix_paged_media"/><a data-primary="at-rules" data-secondary="paged media" data-type="indexterm" id="ix_atrule_paged_media"/><a data-primary="continuous versus paged media" data-type="indexterm" id="idm45176026458768"/>medium that handles a document’s presentation as a series of discrete “pages.” This is different from the screen, which is a <em>continuous medium</em>: documents are presented as a single, scrollable “page.” An analog example of a continuous medium is a papyrus scroll. Printed material, such as books, magazines, and laser printouts, are all paged media. So too are slideshows, which show a series of slides one at a time. Each slide is a “page” in CSS terms.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Print Styles" data-type="sect2"><div class="sect2" id="print-styles">&#13;
<h2>Print Styles</h2>&#13;
&#13;
<p>Even in <a data-primary="printing" data-secondary="paged media styles" data-type="indexterm" id="idm45176026455888"/><a data-primary="paged media" data-secondary="print styles for" data-type="indexterm" id="idm45176026419152"/>the paperless future, the most commonly encountered paged medium is a printout of a document—a web page, a word-processing document, a spreadsheet, or something else that has been committed to the thin wafers of a dead tree. You can do several things to make printouts of your documents more pleasing for the user, from adjusting page breaking to creating styles meant specifically for print.</p>&#13;
&#13;
<p>Note that print styles would also be applied to the document display in a print preview mode. Thus, it’s possible in some circumstances to see print styles on a monitor.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Differences Between Screen and Print" data-type="sect2"><div class="sect2" id="differences-between-screen-and-print">&#13;
<h2>Differences Between Screen and Print</h2>&#13;
&#13;
<p>Beyond the <a data-primary="paged media" data-secondary="screen versus print" data-type="indexterm" id="idm45176026415488"/>obvious physical differences, stylistic differences also exist between screen and print design. The most basic involves font choices. Most designers will tell you that sans-serif fonts are best suited for screen design, but serif fonts are more readable in print. Thus, you might set up a print stylesheet that uses Times instead of Verdana for the text in your document.</p>&#13;
&#13;
<p>Another major difference involves <a data-primary="fonts" data-secondary="sizing" data-type="indexterm" id="idm45176026414128"/>font sizing. If you’ve spent any time at all doing web design, you’ve probably heard again and again (and again) that points are a horrible choice for font sizing on the web. This is basically true, especially if you want your text to be consistently sized between browsers and operating systems. However, print design is not web design any more than web design is print design.</p>&#13;
&#13;
<p>Using points, or even centimeters or picas, is perfectly OK in print design because printing devices know the physical size of their output area. If a printer has been loaded with 8.5 × 11 inch paper, that printer knows it has a printing area that will fit within the edges of a piece of paper. It also knows how many dots there are in an inch, since it knows the dpi it’s capable of generating. This means that it can cope with physical-world length units like points.</p>&#13;
&#13;
<p>Many a print stylesheet has started with this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code> <code class="p">{</code><code class="k">font</code><code class="o">:</code> <code class="m">12pt</code> <code class="s2">"Times New Roman"</code><code class="o">,</code> <code class="s2">"TimesNR"</code><code class="o">,</code> <code class="n">Times</code><code class="o">,</code> <code class="nb">serif</code><code class="p">;}</code></pre>&#13;
&#13;
<p>It’s so traditional, it just might bring a tear of joy to the eye of a graphic artist reading over your shoulder. But make sure they understand that points are acceptable only because of the nature of the print medium—they’re still not good for web design.</p>&#13;
&#13;
<p>Alternatively, the lack of <a data-primary="colors" data-secondary="background" data-type="indexterm" id="idm45176026386800"/><a data-primary="backgrounds" data-secondary="colors" data-type="indexterm" id="idm45176026385952"/>backgrounds in most printouts might bring a tear of frustration to that designer’s eye. To save users ink, most web browsers are preconfigured not to print background colors and images. If the user wants to see those backgrounds in the printout, they have to change an option in the <span class="keep-together">preferences.</span></p>&#13;
&#13;
<p>CSS can’t do anything to force the printing of backgrounds. However, you can use a print stylesheet to make backgrounds unnecessary. For example, you might include this rule in your print stylesheet:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code> <code class="cp">!important</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">transparent</code> <code class="cp">!important</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will do its utmost to ensure that all of your elements print out as black text and remove any backgrounds you might have assigned in an all-medium stylesheet. It also makes sure that if you have a web design that puts yellow text on a dark gray background, a user with a color printer won’t get yellow text on a white piece of paper.</p>&#13;
&#13;
<p>One other difference between paged media and continuous media is that multicolumn layouts are even harder to use in paged media. Suppose you have an article with text formatted as two columns. In a printout, the left side of each page will contain the first column, and the right side the second. This would force the user to read the left side of every page, then go back to the beginning of the printout and read the right side of every page. This is annoying enough on the web, but on paper it’s much worse.</p>&#13;
&#13;
<p>One solution is to use CSS for laying out your two columns (by using flexbox, perhaps) and then write a print stylesheet that restores the content to a single column. Thus, you might write something like this for the screen stylesheet:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">article</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#leftcol</code> <code class="p">{</code><code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="m">45%</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#rightcol</code> <code class="p">{</code><code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="m">5</code> <code class="m">45%</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Then in your print stylesheet, you would write the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">article</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">block</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Alternatively, in user agents that support it, you might define actual multicolumn layout for both screen and print, and trust the user agents to do the right thing.</p>&#13;
&#13;
<p>We could spend an entire chapter on the details of print design, but that really isn’t the purpose of this book. Let’s start exploring the details of paged-media CSS and leave the design discussions for another book.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Page Size" data-type="sect2"><div class="sect2" id="defining-the-page-size">&#13;
<h2>Page Size</h2>&#13;
&#13;
<p>In much the <a data-primary="paged media" data-secondary="page size" data-type="indexterm" id="ix_paged_media_size"/>same way as it defines the element box, CSS defines a <em>page box</em> that describes the components of a page. A page box is composed of two main regions:</p>&#13;
<dl>&#13;
<dt>Page area</dt>&#13;
<dd>&#13;
<p>The <a data-primary="page area" data-type="indexterm" id="idm45176026256688"/>portion of the page in which the content is laid out. This is roughly analogous to the content area of a normal element box, to the extent that the edges of the page area act as the initial containing block for layout within a page.</p>&#13;
</dd>&#13;
<dt>Margin area</dt>&#13;
<dd>&#13;
<p>The <a data-primary="margin area, paged media" data-type="indexterm" id="idm45176026254544"/>area that surrounds the page area.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#pagesize-page-box">Figure 21-2</a> shows the page box model.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="pagesize-page-box">&#13;
<img alt="css5 2102" src="assets/css5_2102.png"/>&#13;
<h6><span class="label">Figure 21-2. </span>The page box</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">The <code>@page</code> block<a data-primary="@page block rule" data-primary-sortas="page block rule" data-type="indexterm" id="ix_page_block_rule"/> is the method by which settings are made, and the <code>size</code> property<a data-primary="size property" data-type="indexterm" id="idm45176026246928"/> is used to define the actual dimensions of the page box. Here’s a simple example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="p">{</code><code class="nt">size</code><code class="o">:</code> <code class="nt">7</code><code class="nc">.5in</code> <code class="nt">10in</code><code class="o">;</code> <code class="nt">margin</code><code class="o">:</code> <code class="nt">0</code><code class="nc">.5in</code><code class="o">;</code><code class="p">}</code></pre>&#13;
&#13;
<p><code>@page</code> is a block like <code>@media</code> is a block, and it can contain any set of styles.  One of them, <code>size</code>, makes sense only in the context of an <code>@page</code> block.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of late 2022, only Chromium-based browsers support <code>size</code>.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176026221968">&#13;
<h1>size</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>auto</code> | &lt;<em><code>length</code></em>&gt;{1,2} | [ &lt;<em><code>page-size</code></em>&gt; || [ <code>portrait</code> | <code>landscape</code> ] ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>The page area</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>&lt;<em><code>page-size</code></em>&gt; is one of a defined set of standard pages sizes; see <a data-type="xref" href="#page-size-keywords">Table 21-1</a> for details</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This descriptor defines the size of the page area. The value <code>landscape</code> is meant to cause the layout to be rotated 90 degrees, whereas <code>portrait</code> is the normal orientation for Western-language printing. Thus, you could cause a document to be printed sideways by declaring the following, with the result shown in <a data-type="xref" href="#pagesize-landscape">Figure 21-3</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="p">{</code><code class="nt">size</code><code class="o">:</code> <code class="nt">landscape</code><code class="o">;</code><code class="p">}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="pagesize-landscape">&#13;
<img alt="css5 2103" src="assets/css5_2103.png"/>&#13;
<h6><span class="label">Figure 21-3. </span>Landscape page sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p>In addition to <code>landscape</code> and <code>portrait</code>, predefined page-size keywords are available.  These are summarized in <a data-type="xref" href="#page-size-keywords">Table 21-1</a>.</p>&#13;
<table id="page-size-keywords">&#13;
<caption><span class="label">Table 21-1. </span>Page-size keywords</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Keyword</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>A5</code></p></td>&#13;
<td><p>International Standards Organization (ISO) A5 size, 148 mm wide x 210 mm tall (5.83 in x 8.27 in)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>A4</code></p></td>&#13;
<td><p>ISO A2 size, 210 mm x 297 mm (8.27 in x 11.69 in)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>A3</code></p></td>&#13;
<td><p>ISO A3 size, 297 mm x 420 mm (11.69 in x 16.54 in)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>B5</code></p></td>&#13;
<td><p>ISO B5 size, 176 mm x 250 mm (6.93 in x 9.84 in)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>B4</code></p></td>&#13;
<td><p>ISO B4 size, 250 mm x 353 mm (9.84 in x 13.9 in)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>JIS-B5</code></p></td>&#13;
<td><p>ISO Japanese Industrial Standards (JIS) B5 size, 182 mm x 257 mm (7.17 in x 10.12 in)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>JIS-B4</code></p></td>&#13;
<td><p>ISO JIS B4 size, 257 mm x 364 mm (10.12 in x 14.33 in)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>letter</code></p></td>&#13;
<td><p>North American letter size, 8.5 in x 11 in (215.9 mm x 279.4 mm)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>legal</code></p></td>&#13;
<td><p>North American legal size, 8.5 in x 14 in (215.9 mm x 355.6 mm)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>ledger</code></p></td>&#13;
<td><p>North American ledger size, 11 in x 17 in (279.4 mm x 431.8 mm)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Any one of the keywords can be used to declare a page size.  The following defines a page to be JIS B5 size:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="p">{</code><code class="nt">size</code><code class="o">:</code> <code class="nt">JIS-B5</code><code class="o">;</code><code class="p">}</code></pre>&#13;
&#13;
<p>These keywords can be combined with the <code>landscape</code> and <code>portrait</code> keywords; thus, to define landscape-oriented North American legal pages, the following is used:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="p">{</code><code class="nt">size</code><code class="o">:</code> <code class="nt">landscape</code> <code class="nt">legal</code><code class="o">;</code><code class="p">}</code></pre>&#13;
&#13;
<p>Besides using keywords, it’s also possible to define page sizes using length units. The width is given first, and then the height.  Therefore, the following defines a page area 8 inches wide by 10 inches tall:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="p">{</code><code class="nt">size</code><code class="o">:</code> <code class="nt">8in</code> <code class="nt">10in</code><code class="o">;</code><code class="p">}</code></pre>&#13;
&#13;
<p>The defined area is usually centered within the physical page, with equal amounts of whitespace on each side.  If the defined <code>size</code> is larger than the printable area of the page, the user agent has to decide what to do to resolve the situation.  There is no defined behavior here, so it’s really dealer’s choice.<a data-primary="" data-startref="ix_paged_media_size" data-type="indexterm" id="idm45176026077696"/><a data-primary="" data-startref="ix_size_prop" data-type="indexterm" id="idm45176026076848"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Page Margins and Padding" data-type="sect2"><div class="sect2" id="idm45176026075648">&#13;
<h2>Page Margins and Padding</h2>&#13;
&#13;
<p>Related to <code>size</code>, CSS <a data-primary="margins" data-secondary="paged media" data-type="indexterm" id="idm45176026050736"/><a data-primary="paged media" data-secondary="margins" data-type="indexterm" id="idm45176026049728"/>includes the ability to style the margin area of the page box. If you want to make sure that only a small bit at the center of every 8.5 × 11 inch page is used to print, you could write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="p">{</code><code class="nt">margin</code><code class="o">:</code> <code class="nt">3</code><code class="nc">.75in</code><code class="o">;</code><code class="p">}</code></pre>&#13;
&#13;
<p>This would leave a printing area 1 inch wide by 3.5 inches tall.</p>&#13;
&#13;
<p>It is possible to use the length units <code>em</code> and <code>ex</code> to describe either the margin area or the page area, at least in theory.  The size used is taken from the page context’s font, which is to say, the base font size used for the content displayed on the page.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Named Page Types" data-type="sect2"><div class="sect2" id="selecting-page-types">&#13;
<h2>Named Page Types</h2>&#13;
&#13;
<p>CSS <a data-primary="paged media" data-secondary="named page types" data-type="indexterm" id="ix_paged_media_name"/>enables you to create different page types using named <code>@page</code> rules. Let’s say you have a document on astronomy that is several pages long, and in the middle of it, a fairly wide table contains a list of the physical characteristics of all the moons of Saturn. You want to print out the text in portrait mode, but the table needs to be landscape. Here’s how you’d start:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="nt">normal</code> <code class="p">{</code><code class="nt">size</code><code class="o">:</code> <code class="nt">portrait</code><code class="o">;</code> <code class="nt">margin</code><code class="o">:</code> <code class="nt">1in</code><code class="o">;</code><code class="p">}</code>&#13;
<code class="k">@page</code> <code class="nt">rotate</code> <code class="p">{</code><code class="nt">size</code><code class="o">:</code> <code class="nt">landscape</code><code class="o">;</code> <code class="nt">margin</code><code class="o">:</code> <code class="nt">0</code><code class="nc">.5in</code><code class="o">;</code><code class="p">}</code></pre>&#13;
&#13;
<p>Now you just need to apply these page types as needed. The table of Saturn’s moons has an <code>id</code> of <code>moon-data</code>, so you write the following rules:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code> <code class="p">{</code><code class="k">page</code><code class="o">:</code> <code class="n">normal</code><code class="p">;}</code>&#13;
<code class="nt">table</code><code class="nf">#moon-data</code> <code class="p">{</code><code class="k">page</code><code class="o">:</code> <code class="n">rotate</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This <a data-primary="page property" data-type="indexterm" id="idm45176025959920"/>causes the table to be printed in landscape orientation, but the rest of the document to be in portrait orientation. The <code>page</code> propery is what makes this possible.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176025923024">&#13;
<h1>page</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>identifier</code></em>&gt; | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Block-level elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>As you can see from looking at the value definition, the whole reason <code>page</code> exists is to let you assign named page types to various elements in your document.</p>&#13;
&#13;
<p>You can use more generic page types through special pseudo-classes. The <code>:first</code> page pseudo-class lets you apply special styles to the first page in the document. For example, you might want to give the first page a larger top margin than other pages. Here’s how:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="p">{</code><code class="nt">margin</code><code class="o">:</code> <code class="nt">3cm</code><code class="o">;</code><code class="p">}</code>&#13;
<code class="k">@page</code> <code class="nd">:first</code> <code class="p">{</code><code class="nt">margin-top</code><code class="o">:</code> <code class="nt">6cm</code><code class="o">;</code><code class="p">}</code></pre>&#13;
&#13;
<p>This will yield a 3 cm margin on all pages, with the exception of a 6 cm top margin on the first page.</p>&#13;
&#13;
<p>In addition to styling the first page, you can also style left and right pages, emulating the pages to the left and right of a book’s spine. You can style these differently using <code>:left</code> and <code>:right</code>. For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="nd">:left</code> <code class="p">{</code><code class="nt">margin-left</code><code class="o">:</code> <code class="nt">3cm</code><code class="o">;</code> <code class="nt">margin-right</code><code class="o">:</code> <code class="nt">5cm</code><code class="o">;</code><code class="p">}</code>&#13;
<code class="k">@page</code> <code class="nd">:right</code> <code class="p">{</code><code class="nt">margin-left</code><code class="o">:</code> <code class="nt">5cm</code><code class="o">;</code> <code class="nt">margin-right</code><code class="o">:</code> <code class="nt">3cm</code><code class="o">;</code><code class="p">}</code></pre>&#13;
&#13;
<p>These rules will have the effect of putting larger margins between the content of the left and right pages, on the sides where the spine of a book would be. This is a common practice when pages are to be bound together into a book of some type.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of early 2023 the Firefox family doesn’t support <code>:first</code>, <code>:left</code>, or <code>:right</code>.<a data-primary="" data-startref="ix_page_block_rule" data-type="indexterm" id="idm45176025824160"/><a data-primary="" data-startref="ix_paged_media_name" data-type="indexterm" id="idm45176025823152"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Page Breaking" data-type="sect2"><div class="sect2" id="page-breaking">&#13;
<h2>Page Breaking</h2>&#13;
&#13;
<p>In a <a data-primary="page-break-before property" data-type="indexterm" id="ix_page_break_bef_prop"/><a data-primary="page-break-after property" data-type="indexterm" id="ix_page_break_aft_prop"/><a data-primary="paged media" data-secondary="page breaking" data-type="indexterm" id="ix_paged_media_break"/><a data-primary="breaks" data-secondary="page" data-type="indexterm" id="ix_break_page"/>paged medium, it’s a good idea to exert some influence over the way page breaks are placed. You can affect page breaking by using the properties <code>page-break-before</code> and <code>page-break-after</code>, both of which accept the same set of values.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176025814448">&#13;
<h1>page-break-before, page-break-after</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>auto</code> | <code>always</code> | <code>avoid</code> | <code>left</code> | <code>right</code> | <code>inherit</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Nonfloated block-level elements with a <code>position</code> value of <code>relative</code> or <code>static</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The default value of <code>auto</code> means that a page break is not forced to come before or after an element. This is the same as any normal printout. The <code>always</code> value causes a page break to be placed before (or after) the styled element.</p>&#13;
&#13;
<p>For example, say the page title is an <code>&lt;h1&gt;</code> element, and the section titles are all <code>&lt;h2&gt;</code> elements. We might want a page break right before the beginning of each section of a document and after the document title. This would result in the following rules, illustrated in <a data-type="xref" href="#pagebreaking-breaks">Figure 21-4</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">page-break-after</code><code class="o">:</code> <code class="nb">always</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">page-break-before</code><code class="o">:</code> <code class="nb">always</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="pagebreaking-breaks">&#13;
<img alt="css5 2104" src="assets/css5_2104.png"/>&#13;
<h6><span class="label">Figure 21-4. </span>Inserting page breaks</h6>&#13;
</div></figure>&#13;
&#13;
<p>If we want the document title to be centered in its page, we’d add rules to that effect. Since we don’t, we just get a straightforward rendering of each page.</p>&#13;
&#13;
<p>The values <code>left</code> and <code>right</code> operate in the same manner as always, except they further define the type of page on which printing can resume. Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">page-break-before</code><code class="o">:</code> <code class="nb">left</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will force every <code>&lt;h2&gt;</code> element to be preceded by enough page breaks that the <code>&lt;h2&gt;</code> will be printed at the top of a left page—that is, a page surface that would appear to the left of a spine if the output were bound. In double-sided printing, this would mean printing on the back of a piece of paper.</p>&#13;
&#13;
<p>So let’s assume that, in printing, the element just before an <code>&lt;h2&gt;</code> is printed on a right page. The previous rule would cause a single page break to be inserted before the <code>&lt;h2&gt;</code>, thus pushing it to the next page. If the next <code>&lt;h2&gt;</code> is preceded by an element on a left page, however, the <code>&lt;h2&gt;</code> would be preceded by two page breaks, thus placing it at the top of the next left page. The right page between the two would be intentionally left blank. The value <code>right</code> has the same basic effect, except it forces an element to be printed at the top of a right page preceded by either one or two page breaks.</p>&#13;
&#13;
<p>The companion to <code>always</code> is <code>avoid</code>, which directs the user agent to do its best to avoid placing a page break either before or after an element. To extend the previous example, suppose you have subsections whose titles are <code>&lt;h3&gt;</code> elements. You want to keep these titles together with the text that follows them, so you want to avoid a page break following an <code>&lt;h3&gt;</code> whenever possible:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h3</code> <code class="p">{</code><code class="k">page-break-after</code><code class="o">:</code> <code class="nb">avoid</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Note, though, that the value is called <code>avoid</code>, not <code>never</code>. There is no way to absolutely guarantee that a page break will never be inserted before or after a given element. Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">9.5in</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">8in</code><code class="p">;</code> <code class="k">page-break-before</code><code class="o">:</code> <code class="nb">avoid</code><code class="p">;}</code>&#13;
<code class="nt">h4</code> <code class="p">{</code><code class="k">page-break-after</code><code class="o">:</code> <code class="nb">avoid</code><code class="p">;}</code>&#13;
<code class="nt">h4</code> <code class="o">+</code> <code class="nt">img</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">10.5in</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Now, suppose further that an <code>&lt;h4&gt;</code> is placed between two images, and its height calculates to be half an inch. Each image will have to be printed on a separate page, but the <code>&lt;h4&gt;</code> can go only two places: at the bottom of the page holding the first element, or on the page after it. If it’s placed after the first image, it has to be followed by a page break, since there’s no room for the second image to follow it.</p>&#13;
&#13;
<p>On the other hand, if the <code>&lt;h4&gt;</code> is placed on a new page following the first image, there won’t be room on that same page for the second image. So, again, a page break will occur after the <code>&lt;h4&gt;</code>. And, in either case, at least one image, if not both, will be preceded by a page break. There’s only so much the user agent can do, given a situation like this one.<a data-primary="" data-startref="ix_page_break_aft_prop" data-type="indexterm" id="idm45176025654208"/><a data-primary="" data-startref="ix_page_break_bef_prop" data-type="indexterm" id="idm45176025653232"/></p>&#13;
&#13;
<p>Situations such as these are rare, but they can happen—for example, in a document containing nothing but tables preceded by headings. The tables could print in such a way that they force a heading element to be followed by a page break, even though the author requested such break placement be avoided.</p>&#13;
&#13;
<p>The <a data-primary="page-break-inside property" data-type="indexterm" id="idm45176025651488"/>same sorts of issues can arise with the other page-break property,&#13;
<code>page-break-inside</code>. Its possible values are more limited than those of its cousins.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176025650144">&#13;
<h1>page-break-inside</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>auto</code> | <code>avoid</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Nonfloated block-level elements with a <code>position</code> value of <code>relative</code> or <code>static</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>With <code>page-break-inside</code>, you pretty much have one option other than the default: you can request that a user agent try to avoid placing page breaks within an element. If you have a series of <code>aside</code> divisions, and you don’t want them broken across two pages, then you could declare the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nc">.aside</code> <code class="p">{</code><code class="k">page-break-inside</code><code class="o">:</code> <code class="nb">avoid</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Again, this is a suggestion more than an actual rule. If an aside turns out to be longer than a page, the user agent can’t help but place a page break inside the element.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Orphans and Widows" data-type="sect2"><div class="sect2" id="orphans-and-widows">&#13;
<h2>Orphans and Widows</h2>&#13;
&#13;
<p>There are two <a data-primary="widows property" data-type="indexterm" id="ix_widows_prop"/><a data-primary="orphans property" data-type="indexterm" id="ix_orphan_prop"/><a data-primary="paged media" data-secondary="orphan and widow handling" data-type="indexterm" id="ix_paged_media_widow"/>properties common to both traditional print typography and desktop publishing  that provide influence over page breaking: <code>widows</code> and <code>orphans</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176025580336">&#13;
<h1>widows, orphans</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>integer</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>2</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Block-level elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>These properties have similar aims but approach them from different angles. The value of <code>widows</code> defines the minimum number of line boxes found in an element that can be placed at the top of a page without forcing a page break to come before the element. The <code>orphans</code> property has the reverse effect: it gives the minimum number of line boxes that can appear at the bottom of a page without forcing a page break before the element.</p>&#13;
&#13;
<p>Let’s take <code>widows</code> as an example. Suppose you declare the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">widows</code><code class="o">:</code> <code class="m">4</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This means that any paragraph can have no fewer than four line boxes appear at the top of a page. If the layout of the document would lead to fewer line boxes, the entire paragraph is placed at the top of the page.</p>&#13;
&#13;
<p>Consider the situation shown in <a data-type="xref" href="#widows-counting">Figure 21-5</a>. Cover up the top part of the figure with your hand so that only the second page is visible. Notice that there are two line boxes there, from the end of a paragraph that started on the previous page. Given the default <code>widows</code> value of <code>2</code>, this is an acceptable rendering. However, if the value were <code>3</code> or higher, the entire paragraph would appear at the top of the second page as a single block. This would require that a page break be inserted before the paragraph in question.</p>&#13;
&#13;
<figure><div class="figure" id="widows-counting">&#13;
<img alt="css5 2105" src="assets/css5_2105.png"/>&#13;
<h6><span class="label">Figure 21-5. </span>Counting the widows and orphans</h6>&#13;
</div></figure>&#13;
&#13;
<p>Refer back to <a data-type="xref" href="#widows-counting">Figure 21-5</a>, and this time cover up the second page with your hand. Notice the four line boxes at the bottom of the page, at the beginning of the last paragraph. This is fine as long as the value of <code>orphans</code> is <code>4</code> or less. If it were <code>5</code> or higher, the paragraph would again be preceded by a page break and be laid out as a single block at the top of the second page.</p>&#13;
&#13;
<p>One potential pitfall is that both <code>orphans</code> and <code>widows</code> must be satisfied. If you declare the following, most paragraphs would be without an interior page break:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">widows</code><code class="o">:</code> <code class="m">30</code><code class="p">;</code> <code class="k">orphans</code><code class="o">:</code> <code class="m">30</code><code class="p">;}</code></pre>&#13;
&#13;
<p>It would take a pretty lengthy paragraph to allow an interior page break, given those values. If the intent is to prevent interior breaking, that intent would be better expressed as the follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">page-break-inside</code><code class="o">:</code> <code class="nb">avoid</code><code class="p">;}</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Both <code>widows</code> and <code>orphans</code> have long been supported in most browsers, except for the Firefox family, which still does not seem to support them as of early 2023.<a data-primary="" data-startref="ix_paged_media_widow" data-type="indexterm" id="idm45176025492336"/><a data-primary="" data-startref="ix_widows_prop" data-type="indexterm" id="idm45176025491360"/><a data-primary="" data-startref="ix_orphan_prop" data-type="indexterm" id="idm45176025486704"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Page-Breaking Behavior" data-type="sect2"><div class="sect2" id="page-breaking-behavior">&#13;
<h2>Page-Breaking Behavior</h2>&#13;
&#13;
<p>Because CSS allows for some odd page-breaking styles, it defines a set of behaviors regarding allowed page breaks and “best” page breaks. These behaviors serve to guide user agents in how they should handle page breaking in various circumstances.</p>&#13;
&#13;
<p>Page <a data-primary="margin-bottom property" data-type="indexterm" id="idm45176025483248"/><a data-primary="margin-top property" data-type="indexterm" id="idm45176025482512"/>breaks are permitted in only two generic places. The first of these is between two block-level boxes. If a page break falls between two block boxes, the <code>margin-bottom</code> value of the element before the page break is reset to <code>0</code>, as is the <code>margin-top</code> of the element following the page break. However, two rules affect whether a page break can fall between two element boxes:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If the <a data-primary="page-break-after property" data-type="indexterm" id="idm45176025447984"/><a data-primary="page-break-before property" data-type="indexterm" id="idm45176025447376"/><a data-primary="forced page break" data-type="indexterm" id="idm45176025446768"/>value of <code>page-break-after</code> for the first element—or the value of <code>page-break-before</code> for the second element—is <code>always</code>, <code>left</code>, or <code>right</code>, a page break will be placed between the elements. This is true regardless of the value for the other element, even if it’s <code>avoid</code>. (This is a <em>forced</em> page break.)</p>&#13;
</li>&#13;
<li>&#13;
<p>If the value of the first element’s <code>page-break-after</code> value is <code>auto</code>, and the same is true for the second element’s <code>page-break-before</code> value, and they do not share an ancestor element whose <code>page-break-inside</code> value is not <code>avoid</code>, then a page break may be placed between them.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="#pagebreaking-potential">Figure 21-6</a> illustrates all the possible page-break placements between elements in a hypothetical document. Forced page breaks are represented as a filled square, whereas potential (unforced) page breaks are shown as an open square.</p>&#13;
&#13;
<p>Second, page breaks are allowed between two line boxes inside a block-level box. This, too, is governed by a pair of rules:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A page break may appear between two line boxes only if the number of line boxes between the start of the element and the line box before the page break would be less than the value of <code>orphans</code> for the element.  Similarly, a page break can be placed only where the number of line boxes between the line box after the page break and the end of the element is less than the value of <code>widows</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A page <a data-primary="page-break-inside property" data-type="indexterm" id="idm45176025435856"/>break can be placed between line boxes if the value of <code>page-break-inside</code> for the element is not <code>avoid</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="pagebreaking-potential">&#13;
<img alt="css5 2106" src="assets/css5_2106.png"/>&#13;
<h6><span class="label">Figure 21-6. </span>Potential page-break placement between block boxes</h6>&#13;
</div></figure>&#13;
&#13;
<p>In both cases, the second of the two rules controlling page-break placement is ignored if no page-break placement can satisfy all the rules. Thus, if an element has been given <code>page-break-inside: avoid</code> but the element is longer than a full page, a page break will be permitted inside the element, between two line boxes.  In other words, the second rule regarding page-break placement between line boxes is ignored.</p>&#13;
&#13;
<p>If ignoring the second rule in each pair of rules still does not yield good page-break placement, other rules can also be ignored. In such a situation, the user agent is likely to ignore all page-break property values and proceed as if they were all <code>auto</code>, although this approach is not defined (or required) by the CSS specification.</p>&#13;
&#13;
<p>In addition to the previously explored rules, CSS defines a set of&#13;
best page-breaking behaviors:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Break as few times as possible.</p>&#13;
</li>&#13;
<li>&#13;
<p>Make all pages that don’t end with a forced break appear to have about the same height.</p>&#13;
</li>&#13;
<li>&#13;
<p>Avoid breaking inside a block that has a border.</p>&#13;
</li>&#13;
<li>&#13;
<p>Avoid breaking inside a table.</p>&#13;
</li>&#13;
<li>&#13;
<p>Avoid breaking inside a floated element.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>These recommendations aren’t required of user agents, but they offer logical guidance that should lead to ideal page-breaking behaviors.<a data-primary="" data-startref="ix_break_page" data-type="indexterm" id="idm45176025424176"/><a data-primary="" data-startref="ix_paged_media_break" data-type="indexterm" id="idm45176025423168"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Repeated Elements" data-type="sect2"><div class="sect2" id="repeated-elements">&#13;
<h2>Repeated Elements</h2>&#13;
&#13;
<p>A very <a data-primary="paged media" data-secondary="repeated elements on every page" data-type="indexterm" id="idm45176025420512"/>common desire in paged media is the ability to have a <em>running head</em>. This is an element that appears on every page, such as the document’s title or the author’s name. This is possible in CSS by using a fixed-position element:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nf">#runhead</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">fixed</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will place any <code>&lt;div&gt;</code> with an <code>id</code> of <code>runhead</code> at the top-right corner of every page box when the document is outputted to a paged medium.  The same rule would place the element in the top-right corner of the viewport in a continuous medium, such as a web browser. Any element positioned in this way will appear on every page. It is not possible to&#13;
copy an element to become a repeated element. Thus, given the following, the <code>&lt;h1&gt;</code> element will appear as a running head on every page, including the first one:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">fixed</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">100%</code><code class="p">;</code> <code class="k">text-align</code><code class="o">:</code> <code class="nb">center</code><code class="p">;</code>&#13;
    <code class="k">font-size</code><code class="o">:</code> <code class="m">80%</code><code class="p">;</code> <code class="k">border-bottom</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The drawback is that the <code>&lt;h1&gt;</code> element, being positioned on the first page, cannot be printed as anything except the running head.</p>&#13;
&#13;
<p>Eventually, we will be able to add content directly into the margins of a printed page with the <code>@page</code>’s margin at-rules. The following would place “table of contents” in the top middle of a printed page containing an element with <code>page: toc</code> set:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@page</code> <code class="nt">toc</code> <code class="p">{</code>&#13;
    <code class="nt">size</code><code class="o">:</code> <code class="nt">a4</code> <code class="nt">portrait</code><code class="o">;</code>&#13;
    <code class="k">@top-middle</code> <code class="p">{</code>&#13;
        <code class="nt">content</code><code class="o">:</code> <code class="s2">"Table of contents"</code><code class="o">;</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Elements Outside the Page" data-type="sect2"><div class="sect2" id="elements-outside-the-page">&#13;
<h2>Elements Outside the Page</h2>&#13;
&#13;
<p>All <a data-primary="paged media" data-secondary="elements outside the page" data-type="indexterm" id="idm45176025309648"/>this talk of positioning elements in a paged medium leads to an interesting question: what happens if an element is positioned outside the page box? You don’t even need positioning to create such a situation. Think about a <code>&lt;pre&gt;</code> element that contains a line with 411 characters. This is likely to be wider than any standard piece of paper, and so the element will be wider than the page box. What will happen then?</p>&#13;
&#13;
<p>As it turns out, CSS doesn’t say exactly what user agents should do, so it’s up to each one to come up with a solution. For a very wide <code>&lt;pre&gt;</code> element, the user agent might clip the element to the page box and throw away the rest of the content. It could also generate extra pages to display the leftover part of the element.</p>&#13;
&#13;
<p>CSS has a few general recommendations for handling content outside the page box, and two that are really important. First, content should be allowed to protrude slightly from a page box in order to allow bleeding. This implies that no extra page would be generated for the portions of such content that exceed the page box but do not extend all the way off the page.</p>&#13;
&#13;
<p>Second, user agents are cautioned not to generate large numbers of empty pages for the sole purpose of honoring positioning information. Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">1500in</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Assuming that the page boxes are 10 inches high, the user agent would have to precede an <code>&lt;h1&gt;</code> with 150 page breaks (and thus 150 blank pages) just to honor that rule. Instead, a user agent might choose to skip the blank pages and output only the last one, which actually contains the <code>&lt;h1&gt;</code> element.</p>&#13;
&#13;
<p>The other two recommendations in the specification state that user agents should not position elements in strange places just to avoid rendering them, and that content placed outside a page box can be rendered in any of a number of ways. (Some of the commentary in CSS is useful and intriguing, but some seems to exist solely to cheerily state the &#13;
<span class="keep-together">obvious.</span>)<a data-primary="" data-startref="ix_atrule_paged_media" data-type="indexterm" id="idm45176025284672"/><a data-primary="" data-startref="ix_paged_media" data-type="indexterm" id="idm45176025252880"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Container Queries" data-type="sect1"><div class="sect1" id="container-queries">&#13;
<h1>Container Queries</h1>&#13;
&#13;
<p>As <a data-primary="container queries" data-type="indexterm" id="ix_container_queries"/><a data-primary="at-rules" data-secondary="container queries" data-type="indexterm" id="ix_atrule_contain"/>media queries are to media contexts, so container queries are to containment contexts.  Rather than saying you want to change the layout of a piece of your design because of changes in the display size, you can have those changes come from changes in their parent element’s size.</p>&#13;
&#13;
<p>For example, you might have a page header containing a logo, some navbar links, and a search box.  By default, the search box is narrow, so as not to take up too much space.  Once it gains focus, though, it gets wider.  In this situation, you might want to change the layout and sizing of the logo and links, thus giving way to the search box without disappearing entirely or being overlaid.  Here’s how you could set that up:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;header</code><code class="w"> </code><code class="na">id=</code><code class="s">"site"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;nav&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"…"</code><code class="nt">&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"/i/logo.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"ConHugeCo"</code><code class="nt">&gt;&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"…"</code><code class="nt">&gt;</code>Products<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"…"</code><code class="nt">&gt;</code>Services<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="cm">&lt;!-- and so on --&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/nav&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;form&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="cm">&lt;!-- search form is here --&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/form&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/header&gt;</code><code class="w"/></pre>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code><code class="nf">#site</code> <code class="nt">nav</code> <code class="p">{</code><code class="n">container</code><code class="o">:</code> <code class="n">headernav</code> <code class="o">/</code> <code class="k">size</code><code class="p">;}</code>&#13;
&#13;
<code class="k">@container</code> <code class="nt">headernav</code> <code class="p">(</code><code class="n">width</code> <code class="o">&lt;</code> <code class="m">50%</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* style changes to be applied to elements when the nav element</code>&#13;
<code class="c">	   shrinks in inline size below half-width */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s explore the new properties that container queries introduce, and then dig into the query block syntax.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Container queries gained widespread browser support in mid- to late 2022, so be careful when using them if you have users with browsers older than that. That said, container queries are supported in all evergreen browsers.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Container Types" data-type="sect2"><div class="sect2" id="defining-container-types">&#13;
<h2>Defining Container Types</h2>&#13;
&#13;
<p>There are a <a data-primary="container queries" data-secondary="types of containers" data-type="indexterm" id="ix_contain_q_types"/>couple of ways to define the type of container, while also setting the kinds of containment (see <code>contain</code> in <a data-type="xref" href="ch20.html#filters-compositing">Chapter 20</a>) that are enabled for the container.  It’s all managed through the <code>container-type</code> property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176025107712">&#13;
<h1>container-type</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p><code>normal</code> | <code>size</code> | <code>inline-size</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>normal</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>When using the default value, <code>normal</code>, a container can be queried on specific property-value combinations.  Suppose you want to apply certain styles if a container has a specific side padding value.  That would look something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code><code class="nf">#site</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">type</code><code class="o">:</code> <code class="n">normal</code><code class="p">;</code> <code class="c">/* default value */</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">name</code><code class="o">:</code> <code class="n">headernav</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">@container</code> <code class="nt">headernav</code> <code class="nt">style</code><code class="p">(</code><code class="n">padding</code><code class="o">-</code><code class="nb">inline</code><code class="o">:</code> <code class="m">1em</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* style changes to be applied to elements when the nav element</code>&#13;
<code class="c">	   specifically has 1em inline padding, and no other value(s) */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Inside a <code>style()</code> function, any property and value combination can be used, including those involving custom properties, and will match as long as that precise combination is in effect.  You could, for example, change the color of heading text based on the value of a text-sizing custom property:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">main</code> <code class="o">&gt;</code> <code class="nt">section</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">:</code> <code class="n">pagesection</code> <code class="o">/</code> <code class="n">normal</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">@container</code> <code class="nt">pagesection</code> <code class="nt">style</code><code class="p">(</code><code class="o">--</code><code class="n">textSize</code><code class="o">:</code> <code class="nb">x-small</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">h1</code><code class="o">,</code> <code class="nt">h2</code><code class="o">,</code> <code class="nt">h3</code><code class="o">,</code> <code class="nt">h4</code><code class="o">,</code> <code class="nt">h5</code><code class="o">,</code> <code class="nt">h6</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@container</code> <code class="nt">pagesection</code> <code class="nt">style</code><code class="p">(</code><code class="o">--</code><code class="n">textSize</code><code class="o">:</code> <code class="n">normal</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">h1</code><code class="o">,</code> <code class="nt">h2</code><code class="o">,</code> <code class="nt">h3</code><code class="o">,</code> <code class="nt">h4</code><code class="o">,</code> <code class="nt">h5</code><code class="o">,</code> <code class="nt">h6</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="m">#222</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@container</code> <code class="nt">pagesection</code> <code class="nt">style</code><code class="p">(</code><code class="o">--</code><code class="n">textSize</code><code class="o">:</code> <code class="n">x</code><code class="o">-</code><code class="n">big</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">h1</code><code class="o">,</code> <code class="nt">h2</code><code class="o">,</code> <code class="nt">h3</code><code class="o">,</code> <code class="nt">h4</code><code class="o">,</code> <code class="nt">h5</code><code class="o">,</code> <code class="nt">h6</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="m">#444</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can also query specific sizing values, such as <code>(width: 30em)</code>, but that queries only the value of the CSS property, not the rendered size of the container.  If you want to perform range-based sizing queries, you’ll have to use one of the other values of <code>container-type</code>: <code>size</code> or <code>inline-size</code>.</p>&#13;
&#13;
<p>If you declare <code>container-type: size</code>, you’re able to query on both the inline and block axes.  Thus you could, for example, set up a query that relates to both sizes of the container like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code><code class="nf">#site</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">type</code><code class="o">:</code> <code class="k">size</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">name</code><code class="o">:</code> <code class="n">headernav</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">@container</code> <code class="nt">headernav</code> <code class="p">(</code><code class="nb">block</code><code class="o">-</code><code class="k">size</code> <code class="o">&lt;</code> <code class="m">6rem</code><code class="p">)</code> <code class="nt">and</code> <code class="p">(</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code> <code class="o">&lt;</code> <code class="m">50vmin</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* style changes to be applied to elements when the nav element</code>&#13;
<code class="c">	   has a block size below 6rem AND an inline size below 50vmin */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you care about only the inline size, using <code>inline-size</code> instead might make more sense, as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code><code class="nf">#site</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">type</code><code class="o">:</code> <code class="nb">inline</code><code class="o">-</code><code class="k">size</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">name</code><code class="o">:</code> <code class="n">headernav</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">@container</code> <code class="nt">headernav</code> <code class="p">(</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code> <code class="o">=&gt;</code> <code class="m">50vmin</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* style changes to be applied to elements when the nav element</code>&#13;
<code class="c">	   has an inline size greater than or equal to 50vmin */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What’s the real difference, besides one of them allowing for block-axis queries?  Both values set layout and style containment (see the <code>contain</code> property in <a data-type="xref" href="ch20.html#filters-compositing">Chapter 20</a>), but <code>size</code> sets size containment, whereas <code>inline-size</code> sets inline-size containment.  This makes some sense, given their respective names.  If you’re always going to do only inline querying, use <code>inline-size</code> so as to keep the block direction uncontained.</p>&#13;
&#13;
<p>Throughout this section, we’ve been setting a container name without having really talked about it, so let’s talk about it now.<a data-primary="" data-startref="ix_contain_q_types" data-type="indexterm" id="idm45176024746400"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Container Names" data-type="sect2"><div class="sect2" id="defining-container-names">&#13;
<h2>Defining Container Names</h2>&#13;
&#13;
<p>To refer to a <a data-primary="container queries" data-secondary="naming containers" data-type="indexterm" id="ix_contain_q_name"/>container, that container needs a name, and that’s what <code>container-name</code> provides. It even lets you assign multiple names to the same element.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176024730960">&#13;
<h1>container-name</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p><code>none</code> ‖ &lt;<em><code>custom-ident</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>You cannot use the keywords <code>and</code>, <code>none</code>, <code>not</code>, nor <code>or</code> in the &lt;<em><code>custom-ident</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Pretty much anytime you set a container, you should set a container name—or names. Both of the following rules are legal:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code> <code class="p">{</code><code class="n">container</code><code class="o">-</code><code class="n">name</code><code class="o">:</code> <code class="n">pageHeader</code><code class="p">;}</code>&#13;
<code class="nt">footer</code> <code class="p">{</code><code class="n">container</code><code class="o">-</code><code class="n">name</code><code class="o">:</code> <code class="n">pageFooter</code> <code class="n">full</code><code class="o">-</code><code class="n">width</code> <code class="n">nav_element</code><code class="p">;}</code></pre>&#13;
&#13;
<p>OK, you probably shouldn’t be mixing camelCase, dash-separated, and underscore_separated naming conventions, but otherwise, everything’s fine. The <code>&lt;header&gt;</code> elements will be given the container name <code>pageHeader</code>, while <code>&lt;footer&gt;</code> elements will be given all three container names listed.  This allows you to apply different container queries for different things, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@container</code> <code class="nt">pageFooter</code> <code class="p">(</code><code class="n">width</code> <code class="o">&lt;</code> <code class="m">40em</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* rules for elements in narrow footers go here */</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@container</code> <code class="nt">nav_element</code> <code class="p">(</code><code class="k">height</code> <code class="o">&gt;</code> <code class="m">5rem</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* rules for elements in tall elements that contain navigation go here */</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@container</code> <code class="nt">full-width</code> <code class="nt">style</code><code class="p">(</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* rules for elements in full-width containers go here */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can turn this around and assign the same container name to a bunch of elements:<a data-primary="" data-startref="ix_contain_q_name" data-type="indexterm" id="idm45176024642528"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code><code class="nf">#page</code><code class="o">,</code> <code class="nc">.full-width</code><code class="o">,</code> <code class="nt">full-bleed</code><code class="o">,</code> <code class="nt">footer</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">name</code><code class="o">:</code> <code class="n">full</code><code class="o">-</code><code class="n">width</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">@container</code> <code class="nt">full-width</code> <code class="nt">style</code><code class="p">(</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">solid</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* rules for elements in full-width containers go here */</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Container Shorthand" data-type="sect2"><div class="sect2" id="the-container-shorthand">&#13;
<h2>Using Container Shorthand</h2>&#13;
&#13;
<p>Now let’s <a data-primary="container queries" data-secondary="shorthand property" data-type="indexterm" id="idm45176024552672"/><a data-primary="container property" data-type="indexterm" id="idm45176024551664"/>bring these two properties together into a single shorthand, <code>container</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176024550352">&#13;
<h1>container</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p>&lt;<em><code>container-name</code></em>&gt; [ / &lt;<em><code>container-type</code></em>&gt; ]?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>You cannot use the keywords <code>and</code>, <code>none</code>, <code>not</code>, nor <code>or</code> in the &lt;<em><code>container-name</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>If you want to define the container name and type in one handy declaration, this is the property for you.  As an example, the following two rules are precisely equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code><code class="nf">#page</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">name</code><code class="o">:</code> <code class="n">headerNav</code><code class="p">;</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">type</code><code class="o">:</code> <code class="k">size</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">header</code><code class="nf">#page</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">:</code> <code class="n">headerNav</code> <code class="o">/</code> <code class="k">size</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the <code>container</code> value, the name must always be present and must always come first.  If a container type is defined, it must come second and follow a forward slash (<code>/</code>).  If no container type is given, the initial value of <code>normal</code> is used.  Thus, the following rules are precisely equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">footer</code><code class="nf">#site</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">name</code><code class="o">:</code> <code class="n">footerNav</code><code class="p">;</code>&#13;
	<code class="n">container</code><code class="o">-</code><code class="n">type</code><code class="o">:</code> <code class="n">normal</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">footer</code><code class="nf">#site</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">:</code> <code class="n">footerNav</code> <code class="o">/</code> <code class="n">normal</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">footer</code><code class="nf">#site</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">:</code> <code class="n">footerNav</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As with <code>container-name</code>, you can include a space-separated list of names, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">footer</code><code class="nf">#site</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">:</code> <code class="n">footerNav</code> <code class="n">fullWidth</code> <code class="n">linkContainer</code> <code class="o">/</code> <code class="n">normal</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So those are the ways to set container names and types.  You’ve seen that the &#13;
<span class="keep-together"><code>@container</code></span> block is used to invoke these, and now it’s time to discuss exactly how that works.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Container At-Rules" data-type="sect2"><div class="sect2" id="container-at-blocks">&#13;
<h2>Using Container At-Rules</h2>&#13;
&#13;
<p>The <a data-primary="container queries" data-secondary="at-rules for" data-type="indexterm" id="ix_contain_q_atrules"/>syntax of container query blocks will seem familiar if you read the earlier sections on media queries, because the syntax is nearly the same.  The only real difference is that container queries use an optional container name and the <code>style()</code> function. Here’s the basic syntax format:</p>&#13;
<pre data-type="programlisting">&#13;
@container <em><code>&lt;container-name&gt;</code></em>? <em><code>&lt;container-condition&gt;</code></em> {&#13;
	/* CSS rules go here */&#13;
}&#13;
</pre>&#13;
&#13;
<p>You don’t have to include a container name, but if you do, it must go first.  (We’ll talk about what happens if you don’t in just a bit.)  There must, however, be a condition of some sort—some sort of query.  It wouldn’t be a container query without one, after all.</p>&#13;
&#13;
<p>As with <a data-primary="not logical keyword" data-type="indexterm" id="idm45176024369152"/>media queries, you can use the <code>and</code>, <code>not</code>, and <code>or</code> modifiers to set up your queries.  Suppose you want to match a container that does <em>not</em> have a dashed border.  That goes something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@container</code> <code class="nt">not</code> <code class="nt">style</code><code class="p">(</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">dashed</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* CSS rules go here */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Or perhaps you want to apply some rules when a container named <code>fullWidth</code> is in a certain size range but also doesn’t have a dashed border:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@container</code> <code class="nt">fullWidth</code> <code class="p">(</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code> <code class="o">&gt;</code> <code class="m">30em</code><code class="p">)</code> <code class="nt">and</code> <code class="nt">not</code> <code class="nt">style</code><code class="p">(</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">dashed</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c">/* CSS rules go here */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note <a data-primary="container queries" data-secondary="naming containers" data-type="indexterm" id="idm45176024293616"/>that you can list only one container name; there is no way to combine them in a single query block, whether with commas or logical combinators like <code>and</code>. As with all query blocks, though, you can nest container queries, such as these:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@container</code> <code class="nt">fullWidth</code> <code class="p">(</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code> <code class="o">&gt;</code> <code class="m">30em</code><code class="p">)</code> <code class="nt">and</code> <code class="nt">not</code> <code class="nt">style</code><code class="p">(</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">dashed</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="k">@container</code> <code class="nt">headerNav</code> <code class="p">(</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code> <code class="o">&gt;</code> <code class="m">30em</code><code class="p">)</code> <code class="p">{</code>&#13;
		<code class="c">/* CSS rules go here */</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This will be matched, and the styles applied, to elements when they have a <code>fullWidth</code> container with an inline size above 30 em and a not-dashed border style, and also a <code>headerNav</code> container with an inline size above 30 em.  And the same element could be both containers!</p>&#13;
&#13;
<p>This brings us to the question of how, exactly, an element knows which containers are being queried.  Let’s extend an earlier example a bit and fill in the actual CSS rules:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@container</code> <code class="nt">fullWidth</code> <code class="p">(</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code> <code class="o">&gt;</code> <code class="m">30em</code><code class="p">)</code> <code class="nt">and</code> <code class="nt">not</code> <code class="nt">style</code><code class="p">(</code><code class="k">border-style</code><code class="o">:</code> <code class="nb">dashed</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">nav</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code> <code class="n">gap</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>How does a given <code>&lt;nav&gt;</code> element on the page know when it’s matched by a container query?  By looking up its ancestor tree to see if there are any containers above it in the tree.  If there are, and they match the name that appears in the container block surrounding it, and the specified query matches the container type, then the query is made.  If it returns true, the styles in the container block are applied. Let’s see that in action. Here’s a document skeleton:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting">html<code class="w"/>&#13;
<code class="w">  </code>body<code class="w"/>&#13;
<code class="w">    </code>header.page<code class="w"/>&#13;
<code class="w">      </code>img<code class="w"/>&#13;
<code class="w">      </code>nav<code class="w"/>&#13;
<code class="w">        </code>(links<code class="w"> </code>here)<code class="w"/>&#13;
<code class="w">    </code>main<code class="w"/>&#13;
<code class="w">      </code>h1<code class="w"/>&#13;
<code class="w">      </code>aside<code class="w"/>&#13;
<code class="w">        </code>nav<code class="w"/>&#13;
<code class="w">      </code>p<code class="w"/>&#13;
<code class="w">      </code>p<code class="w"/>&#13;
<code class="w">      </code>p<code class="w"/>&#13;
<code class="w">      </code>p<code class="w"/>&#13;
<code class="w">    </code>footer.page<code class="w"/>&#13;
<code class="w">      </code>nav<code class="w"/>&#13;
<code class="w">        </code>(links<code class="w"> </code>here)<code class="w"/>&#13;
<code class="w">      </code>img<code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">To that markup, we’ll apply the following styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code><code class="nc">.page</code> <code class="p">{</code><code class="n">container</code><code class="o">:</code> <code class="n">headerNav</code> <code class="n">fullWidth</code> <code class="o">/</code> <code class="k">size</code><code class="p">;}</code>&#13;
<code class="nt">footer</code><code class="nc">.page</code> <code class="p">{</code><code class="n">container</code><code class="o">:</code> <code class="n">fullWidth</code> <code class="o">/</code> <code class="k">size</code><code class="p">;}</code>&#13;
<code class="nt">body</code><code class="o">,</code> <code class="nt">main</code> <code class="p">{</code><code class="n">container</code><code class="o">-</code><code class="n">type</code><code class="o">:</code> <code class="n">normal</code><code class="p">;}</code>&#13;
&#13;
<code class="nt">nav</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code> <code class="n">gap</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;}</code>&#13;
&#13;
<code class="k">@container</code> <code class="nt">fullWidth</code> <code class="p">(</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code> <code class="o">&lt;</code> <code class="m">30em</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">nav</code> <code class="p">{</code><code class="k">flex-direction</code><code class="o">:</code> <code class="n">column</code><code class="p">;</code> <code class="n">padding</code><code class="o">-</code><code class="nb">block</code><code class="o">:</code> <code class="m">4em</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@container</code> <code class="nt">headerNav</code> <code class="p">(</code><code class="nb">block</code><code class="o">-</code><code class="k">size</code> <code class="o">&gt;</code> <code class="m">25vh</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">nav</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="nb">smaller</code><code class="p">;</code> <code class="n">padding</code><code class="o">-</code><code class="nb">block</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@container</code> <code class="nt">style</code><code class="p">(</code><code class="k">background-color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;)</code> <code class="p">{</code>&#13;
	<code class="nt">nav</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
	<code class="nt">nav</code> <code class="nt">a</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">inherit</code><code class="p">;</code> <code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the markup, we have three <code>&lt;nav&gt;</code> elements, and in the CSS we have three container blocks.  Let’s consider the blocks one by one.</p>&#13;
&#13;
<p>The first container query block says to all <code>&lt;nav&gt;</code> elements, “If you have a container with a name of <code>fullWidth</code>, and that container’s inline size is less than 30 em, then you get these styles.”  The header and footer <code>&lt;nav&gt;</code> elements do have containers named <code>fullWidth</code>: the <code>&lt;header&gt;</code> and <code>&lt;footer&gt;</code> elements both have that name.  Their container types are also <code>size</code>, so checking the inline size is valid.  So they check the inline sizes of their respective containers to see if the styles will be applied.</p>&#13;
&#13;
<p>Note that this happens per container.  The header might be 40 em wide and the footer only 25 em wide because of other layout styles (a grid template, for example).  In that case, the change of flex direction will be applied to the footer’s <code>&lt;nav&gt;</code>, but not the header’s <code>&lt;nav&gt;</code>.  As for the <code>&lt;nav&gt;</code> inside the <code>&lt;main&gt;</code> element, it doesn’t have any containers labeled <code>fullWidth</code>, so it gets skipped over regardless of the condition query.</p>&#13;
&#13;
<p>The second container query block says to all <code>&lt;nav&gt;</code> elements, “If you have a container named <code>headerNav</code>, and that container’s block size is greater than 25 vh, you get these styles.”  The only container on the page with a container name of <code>headerNav</code> is the <code>&lt;header class="page"&gt;</code>, so its <code>&lt;nav&gt;</code> checks the block size of the container, and applies the styles if the container’s block size is above 25 vh.  The other two <code>&lt;nav&gt;</code> elements skip this entirely, because none of their containers are named <code>headerNav</code>.</p>&#13;
&#13;
<p>The third container query block is more vague.  It says to all <code>&lt;nav&gt;</code> elements, “If you have a container and its background is blue, then you get these styles.”  Note that there’s no container name, so the header <code>&lt;nav&gt;</code> checks its nearest-ancestor container, which is <code>header.page</code>, to see if it’s set to <code>background-color: blue</code>.  Let’s assume it isn’t, so these styles aren’t applied.</p>&#13;
&#13;
<p class="pagebreak-before">The same thing happens for the <code>&lt;nav&gt;</code> inside the <code>&lt;main&gt;</code> and the footer, as well any <code>&lt;a&gt;</code> elements inside them.  We already established that its background color isn’t blue in the previous paragraph, so if <code>&lt;main&gt;</code> or the footer have their background color set to <code>blue</code>, then their respective <code>&lt;nav&gt;</code> elements and their links will get those styles; otherwise, they won’t.</p>&#13;
&#13;
<p>Remember that a container query matters only if an element matches the selectors inside the query block.  Imagine someone writing something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@container</code> <code class="p">(</code><code class="n">orientation</code><code class="o">:</code> <code class="nb">portrait</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">body</code> <code class="o">&gt;</code> <code class="nt">main</code> <code class="o">&gt;</code> <code class="nt">aisde</code><code class="nc">.sidebar</code> <code class="nt">ol</code> <code class="nt">li</code> <code class="o">&gt;</code> <code class="nt">ul</code> <code class="nt">li</code> <code class="o">&gt;</code> <code class="nt">ol</code> <code class="p">{</code>&#13;
		<code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Only an element that matches that long and very specific selector can check its containers to see if any of them are in <code>portrait</code> orientation, and even an element that matches the selector won’t get the styles if it doesn’t have any containers.  Otherwise, the query is kind of moot.  This speaks to the necessity of making sure your selectors will match before you worry about querying any containers, and then making sure your matched elements have containers to query.<a data-primary="" data-startref="ix_contain_q_atrules" data-type="indexterm" id="idm45176023839344"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Container Query Features" data-type="sect2"><div class="sect2" id="container-query-features">&#13;
<h2>Defining Container Query Features</h2>&#13;
&#13;
<p>You can <a data-primary="container queries" data-secondary="features" data-type="indexterm" id="idm45176023837216"/>check seven features in a container query, most of which you’ve seen previously, but a couple of which we haven’t touched on.  They’re summarized here:</p>&#13;
<dl>&#13;
<dt>Feature: <code>block-size</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Value: &lt;<em><code>length</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>Queries the block size of the query container’s content box.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Feature: <code>inline-size</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Value: &lt;<em><code>length</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>Queries the inline size of the query container’s content box.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Feature: <code>width</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Value: &lt;<em><code>length</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>Queries the physical width of the query container’s content box.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Feature: <code>height</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Value: &lt;<em><code>length</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>Queries the physical height of the query container’s content box.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Feature: <code>aspect-ratio</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Value: &lt;<em><code>ratio</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>Queries the ratio of the physical width as compared to the physical height of the query container’s content box.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
<dt>Feature: <code>orientation</code></dt>&#13;
<dd>&#13;
<dl>&#13;
<dt>Value: <code>portrait</code> | <code>landscape</code></dt>&#13;
<dd>&#13;
<p>Queries the physical width and height of the query container’s content box.  The container is considered to be <code>landscape</code> if its width is greater than its height; otherwise, the container is considered to be <code>portrait</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>These do not have <code>min-</code> and <code>max-</code> prefixed variants.  Instead, the math-style range notation we covered previously is used.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Container Length Units" data-type="sect2"><div class="sect2" id="container-units">&#13;
<h2>Setting Container Length Units</h2>&#13;
&#13;
<p>In <a data-primary="units of measure" data-secondary="lengths for container queries" data-type="indexterm" id="idm45176023805680"/><a data-primary="container queries" data-secondary="length units" data-type="indexterm" id="ix_contain_q_length"/>addition to querying containers, you can also style elements with length values based on their containers’ sizes, very much like the viewport-relative length units discussed in <a data-type="xref" href="ch05.html#values_and_units">Chapter 5</a>. These are as follows:</p>&#13;
<dl>&#13;
<dt><code>cqb</code></dt>&#13;
<dd>&#13;
<p>1% of the container’s block size</p>&#13;
</dd>&#13;
<dt><code>cqi</code></dt>&#13;
<dd>&#13;
<p>1% of the container’s inline size</p>&#13;
</dd>&#13;
<dt><code>cqh</code></dt>&#13;
<dd>&#13;
<p>1% of the container’s physical height</p>&#13;
</dd>&#13;
<dt><code>cqw</code></dt>&#13;
<dd>&#13;
<p>1% of the container’s physical width</p>&#13;
</dd>&#13;
<dt><code>cqmin</code></dt>&#13;
<dd>&#13;
<p>Equivalent to <code>cqb</code> or <code>cqi</code>, whichever is <em>smaller</em></p>&#13;
</dd>&#13;
<dt><code>cqmax</code></dt>&#13;
<dd>&#13;
<p>Equivalent to <code>cqb</code> or <code>cqi</code>, whichever is <em>larger</em></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Thus you could set up an element such that at smaller container sizes, its children are the full width of the container, but at larger sizes they’re some fraction of the container’s width.  This could be done with grid tracks, for example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nc">.card</code> <code class="p">{</code>&#13;
	<code class="n">container</code><code class="o">:</code> <code class="n">card</code> <code class="o">/</code> <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">@container</code> <code class="nt">card</code> <code class="p">(</code><code class="n">width</code> <code class="o">&gt;</code> <code class="m">45em</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="nt">div</code><code class="nc">.card</code> <code class="o">&gt;</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
		<code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code>&#13;
		<code class="k">grid-template-columns</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="m">30</code><code class="n">cqw</code><code class="p">);</code>&#13;
		<code class="k">justify-content</code><code class="o">:</code> <code class="n">space</code><code class="o">-</code><code class="n">between</code><code class="p">;</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, if the container is above 45 em in width, a <code>&lt;ul&gt;</code> that is a child of <code>div.card</code> will be turned into a grid container, with columns that are sized based on the container’s width.  This is illustrated in <a data-type="xref" href="#container-query-units">Figure 21-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="container-query-units">&#13;
<img alt="css5 2107" src="assets/css5_2107.png"/>&#13;
<h6><span class="label">Figure 21-7. </span>Using container query units</h6>&#13;
</div></figure>&#13;
&#13;
<p>The advantage here is mostly in applications like web components, for which it may be desirable to size elements based on the size of the container, even though the container may appear in a wide variety of sizing conditions.<a data-primary="" data-startref="ix_atrule_contain" data-type="indexterm" id="idm45176023746928"/><a data-primary="" data-startref="ix_container_queries" data-type="indexterm" id="idm45176023745952"/><a data-primary="" data-startref="ix_contain_q_length" data-type="indexterm" id="idm45176023745008"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Feature Queries (@supports)" data-type="sect1"><div class="sect1" id="feature_queries">&#13;
<h1>Feature Queries (@supports)</h1>&#13;
&#13;
<p>CSS has the <a data-primary="@supports (feature query) rule" data-primary-sortas="supports (feature query) rule" data-type="indexterm" id="ix_supports_feat_queries"/><a data-primary="feature queries" data-type="indexterm" id="ix_feat_queries"/><a data-primary="at-rules" data-secondary="feature queries" data-type="indexterm" id="ix_atrule_feat_queries"/>ability to apply rules when certain CSS property-value combinations are supported by the user agent.  These are known as <em>feature queries</em>.</p>&#13;
&#13;
<p>Say you want to apply color to an element only if <code>color</code> is a supported property. (Which it certainly should be!) That would look like the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@supports</code> <code class="p">(</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nt">body</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>&#13;
    <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
    <code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">navy</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This says, in effect, “If you recognize and can do something with the property-value combination <code>color: black</code>, apply these styles.  Otherwise, skip these styles.”  In user agents that don’t understand <code>@supports</code>, the entire block is skipped over.</p>&#13;
&#13;
<p>Feature queries are a perfect way to progressively enhance your styles.  For example, suppose you want to add some grid layout to your existing float-and-inline-block layout.  You can keep the old layout scheme and then later in the stylesheet include a block like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@supports</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code> <code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nt">section</code><code class="nf">#main</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;}</code>&#13;
    <code class="c">/* styles to switch off old layout positioning */</code>&#13;
    <code class="c">/* grid layout styles */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This block of styles will be applied in browsers that understand grid display, overriding the old styles that governed page layout, and then applying the styles needed to make things work in a grid-based future.  Browsers too old to understand grid layout are too old to understand <code>@supports</code>, so they’ll skip the whole block entirely, as if it had never been there.</p>&#13;
&#13;
<p>Feature queries can be embedded inside each other, and indeed can be embedded inside media blocks, as well as vice versa.  You could write screen and print styles based on flexible-box layout, and wrap those media blocks in an <code>@supports (display: flex)</code> block:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@supports</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">@media</code> <code class="nt">screen</code> <code class="p">{</code>&#13;
        <code class="c">/* screen flexbox styles go here */</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">@media</code> <code class="nt">print</code> <code class="p">{</code>&#13;
        <code class="c">/* print flexbox styles go here */</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Conversely, you could add <code>@supports()</code> blocks inside various responsive-design media query blocks:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@media</code> <code class="nt">screen</code> <code class="nt">and</code> <code class="p">(</code><code class="k">max-width</code><code class="o">:</code> <code class="m">30em</code><code class="p">){</code>&#13;
    <code class="k">@supports</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="c">/* small-screen flexbox styles go here */</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@media</code> <code class="nt">screen</code> <code class="nt">and</code> <code class="p">(</code><code class="k">min-width</code><code class="o">:</code> <code class="m">30em</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">@supports</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="c">/* large-screen flexbox styles go here */</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The way you organize these blocks is really up to you.  The same holds true for container queries, which can be nested inside feature queries, or vice versa.  In fact, you can nest the various kinds of queries inside each other, or themselves, in any combination that makes sense for your situation (and to you).</p>&#13;
&#13;
<p>As with <a data-primary="and logical keyword" data-type="indexterm" id="idm45176023500880"/>media queries, feature queries also permit logical operators.  Suppose we want to apply styles only if a user agent supports both grid layout <em>and</em> CSS shapes.  Here’s how that might go:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@supports</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">)</code> <code class="nt">and</code> <code class="p">(</code><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">())</code> <code class="p">{</code>&#13;
    <code class="c">/* grid-and-shape styles go here */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is essentially equivalent to writing the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@supports</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">@supports</code> <code class="p">(</code><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">())</code> <code class="p">{</code>&#13;
        <code class="c">/* grid-and-shape styles go here */</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>However, there’s more than “and” operations available.  CSS Shapes (covered in detail in <a data-type="xref" href="ch20.html#filters-compositing">Chapter 20</a>) are a good example of why “or” is useful, because for a long time WebKit supported CSS shapes only via vendor-prefixed properties.  So if you want to use shapes, you can use a feature query like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@supports</code> <code class="p">(</code><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">())</code> <code class="nt">or</code>&#13;
          <code class="p">(</code><code class="k">-webkit-shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">())</code> <code class="p">{</code>&#13;
        <code class="c">/* shape styles go here */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You’d still have to make sure to use both prefixed and unprefixed versions of the shape properties, but this would let you add support for those properties backward in the WebKit release line while supporting other browsers that also support shapes via nonprefixed properties.</p>&#13;
&#13;
<p>All this is handy because at times you might want to apply different properties than those you’re testing.  So, to go back to grid layout for a second, you might want to change the margins and so forth on your layout elements when a grid is in use.  Here’s a simplified version of that approach:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nf">#main</code> <code class="p">{</code><code class="k">overflow</code><code class="o">:</code> <code class="nb">hidden</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.column</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">left</code><code class="p">;</code> <code class="k">margin-right</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.column</code><code class="nd">:last-child</code> <code class="p">{</code><code class="k">margin-right</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
&#13;
<code class="k">@supports</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nt">div</code><code class="nf">#main</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">;</code> <code class="n">gap</code><code class="o">:</code> <code class="m">1em</code> <code class="m">0</code><code class="p">;</code>&#13;
            <code class="k">overflow</code><code class="o">:</code> <code class="nb">visible</code><code class="p">;}</code>&#13;
    <code class="nt">div</code><code class="nf">#main</code> <code class="nt">div</code><code class="nc">.column</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It’s <a data-primary="not logical keyword" data-type="indexterm" id="idm45176023328864"/>possible to use negation as well.  For example, you could apply the following styles when grid layout is <em>not</em> supported:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@supports</code> <code class="nt">not</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* grid-not-supported styles go here */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can combine your logical operators into a single query, but parentheses are required to keep the logic straight.  Suppose we want a set of styles to be applied when color is supported, and when one of either grid or flexible box layout is supported.  That’s written &#13;
<span class="keep-together">like this:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@supports</code> <code class="p">(</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">)</code> <code class="nt">and</code> <code class="p">((</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">)</code> <code class="n">or</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="c">/* styles go here */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notice that <a data-primary="or logical keyword" data-type="indexterm" id="idm45176023209328"/>there’s another set of parentheses around the “or” part of the logic, enclosing the grid and flex tests.  Those extra parentheses are required. Without them, the entire expression will fail, and the styles inside the block will be skipped.  In other words, <em>don’t</em> do this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="c">/* the following will not work and is a bad idea */</code>&#13;
<code class="k">@supports</code> <code class="p">(</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">)</code> <code class="nt">and</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">)</code> <code class="nt">or</code> <code class="p">(</code><code class="k">display</code><code class="o">:</code> <code class="nb">grid</code><code class="p">)</code> <code class="p">{</code></pre>&#13;
&#13;
<p>Finally, you might wonder why both a property and value are required in feature query tests.  After all, if you’re using shapes, all you need to test for is <code>shape-outside</code>, right?  It’s because a browser can easily support a property without supporting all its values.  Grid layout is a perfect example.  Suppose you try to test for grid support like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@supports</code> <code class="p">(</code><code class="k">display</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c">/* grid styles go here */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Well, even Internet Explorer 4 supported <code>display</code>.  Any browser that understands <code>@supports</code> will certainly understand <code>display</code> and many of its values—but maybe not <code>grid</code>.  That’s why property and value are always tested in feature queries.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Remember that these are <em>feature</em> queries, not <em>correctness</em> queries.  A browser can understand the feature you’re testing for, but implement it with bugs, or parse it correctly without actually supporting the intended behavior.  In other words, you’re not getting an assurance from the browser that it supports something correctly.  All a positive feature-query result means is that the browser understands what you’ve said.<a data-primary="" data-startref="ix_atrule_feat_queries" data-type="indexterm" id="idm45176023151872"/><a data-primary="" data-startref="ix_feat_queries" data-type="indexterm" id="idm45176023150896"/><a data-primary="" data-startref="ix_supports_feat_queries" data-type="indexterm" id="idm45176023149952"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other At-Rules" data-type="sect1"><div class="sect1" id="other-at-rules">&#13;
<h1>Other At-Rules</h1>&#13;
&#13;
<p>A variety of other at-rules were covered in other parts of the book:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>@counter-style</code> (see <a data-type="xref" href="ch16.html#lists-and-generated-content">Chapter 16</a>)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>@font-face</code> (see <a data-type="xref" href="ch14.html#fonts">Chapter 14</a>)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>@font-feature-values</code> (see <a data-type="xref" href="ch14.html#fonts">Chapter 14</a>)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>@import</code> (see <a data-type="xref" href="ch01.html#css_fundamentals">Chapter 1</a>)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>@layer</code> (see <a data-type="xref" href="ch04.html#specificity_comma_inheritance">Chapter 4</a>)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Two more were not covered elsewhere, so we’ll cover them here.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining a Character Set for a Stylesheet" data-type="sect2"><div class="sect2" id="idm45176023088784">&#13;
<h2>Defining a Character Set for a Stylesheet</h2>&#13;
&#13;
<p>The <code>@charset</code> at-rule<a data-primary="at-rules" data-secondary="@charset" data-secondary-sortas="charset" data-type="indexterm" id="idm45176023086832"/><a data-primary="@charset rule" data-primary-sortas="charset rule" data-type="indexterm" id="idm45176023085552"/> is a way to set a specific character set for a stylesheet.  For example, you may have received a stylesheet in the UTF-16 character encoding.  That would be marked as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="cp">@charset "UTF-16";</code></pre>&#13;
&#13;
<p>In a departure from the rest of CSS, the syntax here is very exacting.  There must be exactly one space (which must be the space defined by Unicode code point U+0020) between the <code>@charset</code> and the quoted value, the value must be quoted, and it can be quoted using only double quotes.  In addition, you cannot have space of any kind before the <code>@charset</code>; it must be the first thing on the line.</p>&#13;
&#13;
<p>Furthermore, if you need to include <code>@charset</code>, it must be the very first thing in the stylesheet, before any other at-rule or regular rule.  If you list more than one <code>@charset</code>, the first will be used, and the rest ignored.</p>&#13;
&#13;
<p>And finally, the only acceptable values are character encodings defined in the <a href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">Internet Assigned Numbers Authority (IANA) Registry</a>.</p>&#13;
&#13;
<p>Use of <code>@charset</code> is vanishingly rare, so unless explicitly declaring the encoding of a specific stylesheet is absolutely required to make things work, don’t worry about it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining a Namespace for Selectors" data-type="sect2"><div class="sect2" id="idm45176023078752">&#13;
<h2>Defining a Namespace for Selectors</h2>&#13;
&#13;
<p>The <code>@namespace</code> at-rule<a data-primary="at-rules" data-secondary="@namespace for selectors" data-secondary-sortas="namespace for selectors" data-type="indexterm" id="idm45176023076032"/><a data-primary="@namespace rule" data-primary-sortas="namespace rule" data-type="indexterm" id="idm45176023074784"/><a data-primary="selectors" data-secondary="@namespace rule for" data-secondary-sortas="namespace rule for" data-type="indexterm" id="idm45176023073840"/> allows you to use XML namespaces in your stylesheets.  The value of <code>@namespace</code> is the URL of a document defining the namespace, like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;style&gt;</code><code class="w"/>&#13;
@namespace<code class="w"> </code>xhtml<code class="w"> </code>url(http://www.w3.org/1999/xhtml);<code class="w"/>&#13;
@namespace<code class="w"> </code>svg<code class="w"> </code>url(http://www.w3.org/2000/svg);<code class="w"/>&#13;
&#13;
xhtml|a<code class="w"> </code>{color:<code class="w"> </code>navy;}<code class="w"/>&#13;
svg|a<code class="w"> </code>{color:<code class="w"> </code>red;}<code class="w"/>&#13;
a<code class="w"> </code>{background:<code class="w"> </code>yellow;}<code class="w"/>&#13;
<code class="nt">&lt;/style&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Given the previous CSS, <code>&lt;a&gt;</code> elements in XHTML would be navy on yellow, and <code>&lt;a&gt;</code> elements in SVG would be red on yellow.  This is why selectors without namespaces work across all markup languages: no namespace means no restriction.</p>&#13;
&#13;
<p>Any <code>@namespace</code> at-rules must come after any <code>@charset</code> or <code>@import</code> at-rules, but before any other stylesheet content, whether other at-rules or normal rules. The <code>@namespace</code> at-rule is rarely used outside of test pages, but if you need to use it, the capability is there.<a data-primary="" data-startref="ix_at-rules_ch21" data-type="indexterm" id="idm45176023028192"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45176023027088">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Thanks to the flexibility of at-rules, it is possible to provide a wide range of design experiences from within a single set of styles.  Whether reorganizing a page to account for varying display sizes, reworking the color scheme to support grayscale printing, or restyling content based on elements that contain them, you have the ability to do a great deal to make your work the best it can be.</p>&#13;
</div></section>&#13;
</div></section></body></html>