<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Data Enrichment"><div class="chapter" id="data_enrichment">
<h1><span class="label">Chapter 5. </span>Data Enrichment</h1>
<p><a contenteditable="false" data-primary="data enrichment" data-type="indexterm" id="ch05.html0"/>Falco’s architecture allows you to capture events from different data sources, as you’ve learned. This process delivers raw data, which can be very rich but isn’t very useful for runtime security unless paired with the right context. That’s why Falco first extracts and then enriches the raw data with contextual information, so that the rule author can comfortably use it. Typically, we refer to this information as the event <em>metadata</em>. Getting metadata can be a complex task, and getting it efficiently is even more complex.</p>
<p>You’ve already seen that the system-state collection capabilities in <em>libscap</em> and the state engine implemented by <em>libsinsp</em> (discussed in <a data-type="xref" href="ch03.xhtml#understanding_falcoapostr">Chapter 3</a>) are central to this activity, but there’s much more to discover. In this chapter, we’ll delve into the design aspects of the Falco stack to help you better understand how data enrichment works. In particular, we will show you <em>libsinsp</em>’s efficient layered approach to obtaining system, container, and Kubernetes metadata for system call (syscall) events. This is what enables you to access the information you need relating to different contexts (depending on your use case), such as a container’s ID or the name of a Pod where a suspicious event occurred. Finally, we’ll show you how plugins, Falco’s other main data source, can implement their own data enrichment mechanisms, opening up infinite possibilities.</p>
<section data-type="sect1" data-pdf-bookmark="Understanding Data Enrichment for Syscalls"><div class="sect1" id="understanding_data_enrichment_for_sysca">
<h1>Understanding Data Enrichment for Syscalls</h1>
<p><a contenteditable="false" data-primary="data enrichment for syscalls" data-type="indexterm" id="ch05.html1"/><a contenteditable="false" data-primary="system calls" data-secondary="data enrichment for syscalls" data-type="indexterm" id="ch05.html2"/>Understanding how data enrichment works will help you to fully understand Falco’s mechanics. Moreover, although data enrichment usually works out of the box, each context Falco supports has its own implementation and may need a specific configuration. Knowing the implementation details will help you troubleshoot and fine-tune Falco.</p>
<p><a contenteditable="false" data-primary="data enrichment" data-secondary="defined" data-type="indexterm" id="idm45324227558128"/><em>Data enrichment</em> in Falco refers to the process of providing the rule engine with event metadata obtained by decoding the raw data or collecting it from complementary sources. You can then use this metadata as fields in both rule conditions and output formatting. Falco organizes the collected metadata in a set of field classes, so you can easily recognize which context they belong to. (You can find the complete list of supported fields in <a data-type="xref" href="ch06.xhtml#fields_and_filters">Chapter 6</a> or, if you have a Falco installation at your fingertips, by typing <code><strong>falco --list</strong></code>.)</p>
<p>One of the most significant examples of data enrichment is when using system calls as a data source, which you learned about in <a data-type="xref" href="ch04.xhtml#data_source">Chapter 4</a>. Since syscalls are essential to every application, they occur in just about every context. Information directly provided by a syscall would not be useful without context, however, so it therefore becomes critical to collect and connect the surrounding information.</p>
<p><a contenteditable="false" data-primary="metadata" data-secondary="syscalls and" data-type="indexterm" id="idm45324227552848"/><a data-type="xref" href="#contextual_metadata_for_system_calls">Table 5-1</a> shows the different categories of metadata that Falco collects for syscalls, and the field classes associated with each data enrichment layer.</p>
<table class="border" id="contextual_metadata_for_system_calls">
<caption><span class="label">Table 5-1. </span>Contextual metadata for system calls</caption>
<thead>
<tr>
<th>Context</th>
<th>Metadata</th>
<th>Field classes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Operating system</td>
<td>Processes and threads<br/>File descriptors<br/>Users and groups<br/>Network interfaces</td>
<td><code>proc</code>, <code>thread</code>, <code>fd</code>, <code>fdlist</code>,  <code>user</code>, <code>group</code></td>
</tr>
<tr>
<td>Container</td>
<td>ID and name<br/>Type <br/>Image name<br/>Privileged<br/>Mount points<br/>Health checks</td>
<td><code>container</code></td>
</tr>
<tr>
<td>Kubernetes</td>
<td>Namespace<br/>Pod<br/>ReplicationController<br/>Service<br/>ReplicaSet<br/>Deployment</td>
<td><code>k8s</code></td>
</tr>
</tbody>
</table>
<p>The enrichment process happens in user space and involves several components of Falco’s stack. Most importantly, the metadata must be immediately available every time the rule engine requests it. Collecting it from other complementary sources on the fly would thus not be feasible, as attempting to do so would risk blocking the rule engine and the entire flow of incoming events.</p>
<p>For that reason, data enrichment involves two distinct phases. The first initializes a local state by collecting in bulk the data that is present when Falco starts, and the second continuously updates the local state while Falco runs. Having a local state allows Falco to extract metadata immediately. This design is shared among all implementation layers, as you will discover in the following sections.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="kubernetes_support_and_the_kubernetes_a">
<h5>Kubernetes Support and the Kubernetes Audit Log Data Source</h5>
<p><a contenteditable="false" data-primary="Kubernetes" data-secondary="Kubernetes support versus Kubernetes audit log" data-type="indexterm" id="idm45324227531136"/>In the Falco documentation, you will find mention of both Kubernetes support and <a href="https://oreil.ly/f565p">Kubernetes Audit Events support</a>. You might think enabling Kubernetes support implies adding support for Kubernetes audit logs as a data source, but they’re actually two distinct features.</p>
<p>Kubernetes support only concerns Falco’s ability to enrich an event originating from a syscall with Kubernetes metadata. In rules, that metadata is available through the <code>k8s</code> field class. That’s what we’ll talk about in this chapter.</p>
<p>On the other hand, the Kubernetes audit log is an independent data source,<sup><a data-type="noteref" id="ch01fn5-marker" href="ch05.xhtml#ch01fn5">1</a></sup> providing events that do not originate from a syscall. You can quickly identify rules that use this data source because they include <code>source: k8s_audit</code>. To use the Kubernetes audit log as a data source, you must enable support for audit logging in Kubernetes and use Falco’s <a href="https://oreil.ly/p7OsC"><code>k8saudit</code> plugin</a>; Kubernetes then directly feeds Falco with events, sending them via a webhook. The Kubernetes audit log data source already provides all the necessary context data along with the originating event, and therefore no specific enrichment mechanism is needed. The metadata is accessible through the <code>ka</code> field class.</p>
<p>You can enable the two features (support for Kubernetes and for the audit log as a data source) separately, since they are not dependent on each other.</p>
</div></aside>
<section data-type="sect2" data-pdf-bookmark="Operating System Metadata"><div class="sect2" id="operating_system_metadata">
<h2>Operating System Metadata</h2>
<p><a contenteditable="false" data-primary="data enrichment for syscalls" data-secondary="operating system metadata" data-type="indexterm" id="ch05.html3"/><a contenteditable="false" data-primary="libsinsp" data-secondary="data enrichment and" data-type="indexterm" id="ch05.html4"/><a contenteditable="false" data-primary="metadata" data-secondary="operating system metadata" data-type="indexterm" id="ch05.html5"/><a contenteditable="false" data-primary="operating system metadata, data enrichment and" data-type="indexterm" id="ch05.html6"/>As you learned in <a data-type="xref" href="ch03.xhtml#understanding_falcoapostr">Chapter 3</a>, <em>libscap</em> and <em>libsinsp</em> work together to provide all the necessary infrastructure to create and update contextual information in a hierarchical structure composed of several state tables (see <a data-type="xref" href="ch03.xhtml#the_libsinsp_state_hierarchy">Figure 3-4</a> if you need a refresher). Those tables include information about:</p>
<ul>
<li><p>Processes and threads</p></li>
<li><p>File descriptors</p></li>
<li><p>Users and groups</p></li>
<li><p>Network interfaces</p></li>
</ul>
<p>At a high level, the mechanism for collecting system information is relatively simple. <a contenteditable="false" data-primary="process information pseudo-filesystem (procfs)" data-type="indexterm" id="idm45324227508576"/>At start time, one of <em>libscap</em>’s tasks is to scan the <a href="https://oreil.ly/xso1E"><em>process information pseudo-filesystem</em></a>, or <em>procfs</em>, which provides a user-space interface to the Linux kernel data structures and contains most of the information to initialize the state tables. It also collects system information (not available in <em>/proc</em>) using functions provided by the standard C library, which in turn obtains the data from the underlying operating system (for example, <code>getpwent</code> and <code>getgrent</code> for users and groups lists, respectively, and <code>getifaddrs</code> for the network interfaces list). At this point, the initialization phase is complete.</p>
<div data-type="tip"><h6>Tip</h6>
<p><em>libscap</em> and <em>libsinsp</em> rely on the host’s procfs to access the host’s system information. That happens by default when Falco runs on the host since it can directly access the host’s <em>/proc</em>. However, when Falco runs in a container, the <em>/proc</em> inside the container refers to a different namespace. In such a situation, you can configure <em>libscap</em> via the <code>HOST_ROOT</code> environment variable to read from an alternative path. If you set <code>HOST_ROOT</code>, <em>libscap</em> will use its value as a base path when looking for system paths. For example, when running Falco in a container, the usual approach is to mount the host’s <em>/proc</em> to <em>/host/proc</em> inside the container and set <code>HOST_ROOT</code> to <em>/host</em>. With this setup, <em>libscap</em> will read from <em>/host/proc</em>, and thus it will use the information provided by the host’s procfs.</p>
</div>
<p>Afterward, <em>libsinsp</em> comes into play with its state engine (see <a data-type="xref" href="#system_state_collection_before_left_par">Figure 5-1</a>). It updates the tables by inspecting the constantly captured stream of syscalls provided by the driver, which runs in kernel space. After the initialization phase, Falco will not need to make any syscalls or tap into the system to obtain updates from the Linux kernel. This approach has the double benefit of not creating noise in the system and having a low impact on performance. Furthermore, this technique enables <em>libsinsp</em> to discover system changes with low latency, allowing Falco to function as a streaming engine (one of its most important design goals).</p>
<p>The last important thing to note is that <em>libsinsp</em> updates the state tables before dispatching the event to the rule engine. This ensures that when the conditions or output require metadata, it will always be available and consistent. You can then find the system metadata grouped in the set of field classes you saw in <a data-type="xref" href="#contextual_metadata_for_system_calls">Table 5-1</a>: <code>proc</code>, <code>thread</code>, <code>fd</code>, <code>fdlist</code>, <code>user</code>, and <code>group</code>.</p>
<p>This set of information represents the basic metadata that enables a rule author to make a syscall event usable. Think about it: how would you use a numeric file descriptor in a rule? A filename is much better!</p>
<figure><div id="system_state_collection_before_left_par" class="figure">
<img src="Images/pcns_0501.png" alt="" width="600" height="503"/>
<h6><span class="label">Figure 5-1. </span>System state collection before (1) and after (2) the initialization phase</h6>
</div></figure>
<p>The system information (i.e., the state tables) produced by this data enrichment layer is also essential for collecting contextual information at the container level. We’ll look at that next.<a contenteditable="false" data-primary="" data-startref="ch05.html6" data-type="indexterm" id="idm45324227485776"/><a contenteditable="false" data-primary="" data-startref="ch05.html5" data-type="indexterm" id="idm45324227484304"/><a contenteditable="false" data-primary="" data-startref="ch05.html4" data-type="indexterm" id="idm45324227482928"/><a contenteditable="false" data-primary="" data-startref="ch05.html3" data-type="indexterm" id="idm45324227481552"/></p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Container Metadata"><div class="sect2" id="container_metadata">
<h2>Container Metadata</h2>
<p><a contenteditable="false" data-primary="container metadata" data-secondary="data enrichment and" data-type="indexterm" id="ch05.html7"/><a contenteditable="false" data-primary="data enrichment for syscalls" data-secondary="container metadata" data-type="indexterm" id="ch05.html8"/>Additional fundamental contextual information resides in the container runtime layer. <a contenteditable="false" data-primary="container runtime" data-type="indexterm" id="idm45324227474992"/>A <em>container runtime</em> is a software component that can run containers on a host operating system. It is commonly responsible for managing container images and the lifecycles of containers running on your system. It is also responsible for managing a set of information related to each running container and providing that information to other applications.</p>
<p>Because Falco is a cloud native runtime security tool, it needs to be able to deal with container information. <a contenteditable="false" data-primary="libsinsp" data-secondary="container metadata and" data-type="indexterm" id="idm45324227472320"/>To achieve this goal, <em>libsinsp</em> works with the most commonly used container runtime environments, including Docker, Podman, and CRI-compatible<sup><a data-type="noteref" id="ch01fn6-marker" href="ch05.xhtml#ch01fn6">2</a></sup> runtimes like containerd and CRI-O.</p>
<p>When <em>libsinsp</em> finds a running container runtime on the host, the container metadata enrichment functionality works out of the box in almost all cases. For example, <em>libsinsp</em> tries to use Docker’s Unix socket at <em>/var/run/docker.sock</em>; if this exists, <em>libsinsp</em> automatically connects to it and starts grabbing container metadata. <em>libsinsp</em> does the same for Podman and containerd. For other CRI-compatible runtimes, you will need to pass the socket path to Falco using the <code>--cri</code> command-line flag (for CRI-O, for example, you would pass <code>/var/run/crio/crio.sock</code>).</p>
<div data-type="tip"><h6>Tip</h6>
<p>If the <code>HOST_ROOT</code> environment variable is set, <em>libsinsp</em> will use its value as the base path when looking for those Unix sockets. For example, when running Falco in a container, it’s common to set <code>HOST_ROOT=/host</code> and mount <em>/var/run/docker.sock</em> to <em>/host/var/run/docker.sock</em> inside the container.</p>
</div>
<p>Regardless of which container runtime you are using, at initialization <em>libsinsp</em> requests a list of all running containers, which it uses to initialize an internal cache. At the same time, <em>libsinsp</em> updates the state table of running processes and threads, associating each of them with its respective container ID, if any.</p>
<p><em>libsinsp</em> handles subsequent updates by using the syscalls stream coming from the driver (similar to what it does for system information). Since container information is always associated with a process, <em>libsinsp</em> tracks all new processes and threads. When it detects one, it looks up the corresponding container ID in the internal cache. If the container ID is not in the cache, <em>libsinsp</em> queries the container runtime to gather the missing data.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="dealing_with_missing_metadata">
<h5>Dealing with Missing Metadata</h5>
<p><a contenteditable="false" data-primary="container metadata" data-secondary="dealing with missing metadata" data-type="indexterm" id="idm45324227455792"/>The process of querying the container runtime happens asynchronously to avoid blocking the stream of events. In some environments, this operation is not fast enough to be completed asynchronously, so attempting it leads to empty container metadata fields. For CRI-compatible runtimes, Falco provides an option to disable asynchronous metadata fetching:</p>
<pre data-type="programlisting">--disable-cri-async</pre>
<p>Although you won’t generally need to use this, it can be helpful if you need to wait for all the container metadata to be fetched before moving to the next input event so that no metadata is lost. However, you might see a performance penalty depending on the number of containers and the frequency with which they are created, started, and stopped. Disabling asynchronous fetching can be helpful when debugging or in systems with a very low syscall rate. In other circumstances, performance may be significantly degraded.</p>
</div></aside>
<p>Ultimately, each syscall-generated event that occurs in a container has a process or thread ID that maps to a container ID and, consequently, to the container metadata (as shown in <a data-type="xref" href="#container_info_in_the_libsinsp_state_hi">Figure 5-2</a>). So, when the rule engine requires this metadata, <em>libsinsp</em> looks it up from the state tables and returns system information along with the container metadata. You will find the available container metadata grouped in the field class <code>container</code>, which can be used in both conditions and output formatting.</p>
<figure><div id="container_info_in_the_libsinsp_state_hi" class="figure">
<img src="Images/pcns_0502.png" alt="" width="600" height="384"/>
<h6><span class="label">Figure 5-2. </span>Container info in the libsinsp state hierarchy</h6>
</div></figure>
<p>Note that the field <code>container.id</code> can contain either the container ID <em>or</em> the special value <code>host</code>. This special value indicates that the event did not happen inside a container. The condition <code>container.id != host</code> is a common way to express a rule that applies only in the context of a container.<a contenteditable="false" data-primary="" data-startref="ch05.html8" data-type="indexterm" id="idm45324227445712"/><a contenteditable="false" data-primary="" data-startref="ch05.html7" data-type="indexterm" id="idm45324227444336"/></p>
<p>In the final data enrichment layer, Falco collects the Kubernetes metadata associated with system calls. We’ll look at how this works next.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Kubernetes Metadata"><div class="sect2" id="kubernetes_metadata">
<h2>Kubernetes Metadata</h2>
<p><a contenteditable="false" data-primary="data enrichment for syscalls" data-secondary="Kubernetes metadata" data-type="indexterm" id="ch05.html9"/><a contenteditable="false" data-primary="Kubernetes metadata" data-secondary="data enrichment" data-type="indexterm" id="ch05.html10"/>Kubernetes, the flagship project of the Cloud Native Computing Foundation, is an open source platform for managing workloads and services. It has introduced many new concepts that make it easier to manage and scale clusters and is the most popular container orchestration system today.</p>
<p><a contenteditable="false" data-primary="Pods (Kubernetes object)" data-type="indexterm" id="idm45324227436736"/>One of the essential features of Kubernetes is encapsulating your applications in objects called <em>Pods</em>, which contain one or more containers. Pods are ephemeral objects that you can quickly deploy and easily replicate. <em>Services</em> in Kubernetes are an abstraction that allows you to expose a set of Pods as a single network service. Finally, Kubernetes lets you arrange those and many other objects into <em>namespaces</em>, which are objects that allow partitioning of a single cluster into multiple virtual clusters.</p>
<p>While these concepts greatly facilitate managing and automating clusters, they also introduce a set of contextual information about how and where your application is running. Awareness of this information is essential, since knowing that something has happened in your Kubernetes cluster is of little use if you don’t know where it happened (for example, in which namespace or Pod). Falco collects information such as the container image name, Pod name, namespace, labels, annotations, and exposed service names so it can offer as accurate a view as possible of your deployments and applications. This is important for runtime alerting and protection of your infrastructure, because you’re typically much more interested in what service or deployment is showing a strange behavior than in getting a container ID or some other hard-to-link piece of information. As a cloud native tool, Falco can readily obtain this metadata and attach it to the event.</p>
<p>Similar to the operating system and container metadata collection mechanisms you saw in the previous sections, this feature allows Falco to enrich syscall events by adding Kubernetes metadata. For full Kubernetes support, you must opt in by passing two command-line options to Falco:</p>
<dl>
<dt><code>--k8s-api</code> (or just <code>-k</code>)</dt>
<dd><p>This enables Kubernetes support by connecting to the API server specified as an argument (e.g., <code>http://admin:password@127.0.0.1:8080</code>).</p></dd>
<dt><code>--k8s-api-cert</code> (or just <code>-K</code>)</dt>
<dd><p>This provides certificate materials to authenticate the user and (optionally) verify the Kubernetes API server’s identity.</p></dd>
</dl>
<p>Further details are provided in <a data-type="xref" href="ch10.xhtml#configuring_and_running">Chapter 10</a>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>When Falco is running in a Pod, Kubernetes injects that information in the container, so you just need to set:</p>
<pre data-type="programlisting">-k https://$(KUBERNETES_SERVICE_HOST) 
-K /var/run/secrets/kubernetes.io/serviceaccount/token</pre>
<p>Most installation methods use this strategy to fetch those values automatically.</p>
</div>
<p><a contenteditable="false" data-primary="libsinsp" data-secondary="Kubernetes metadata collection" data-type="indexterm" id="idm45324227423888"/>Once Kubernetes support is configured, <em>libsinsp</em> will get all the necessary data from Kubernetes to create and maintain a local copy of the state of the cluster. However, unlike the other enrichment mechanisms that get metadata locally from the host, <em>libsinsp</em> has to connect to the Kubernetes API server (usually a remote endpoint) to get cluster information. Because of this difference, the implementation design needs to take performance and scalability concerns into account.</p>
<p class="pagebreak-before">A typical Falco deployment (pictured in <a data-type="xref" href="#a_falco_deployment_using_a_daemonset_to">Figure 5-3</a>) runs one Falco sensor on every node in the cluster. At startup, each sensor connects to the API server to collect the cluster data and build the initial state locally. From then on, each sensor will use the <a href="https://oreil.ly/g0hCZ">Kubernetes watch API</a> to periodically update the local state.</p>
<figure><div id="a_falco_deployment_using_a_daemonset_to" class="figure">
<img src="Images/pcns_0503.png" alt="" width="600" height="345"/>
<h6><span class="label">Figure 5-3. </span>A Falco deployment using a <a href="https://oreil.ly/WTTGU">DaemonSet</a> to ensure that all nodes run a copy of a Pod</h6>
</div></figure>
<p>Since Falco sensors are distributed in the cluster (one per node) and grab data from the API server—and because collecting some resource types from Kubernetes may result in huge responses that severely impact both the API server and Falco—<em>libsinsp</em> has mechanisms to avoid congestion. First, it waits for a short time between downloading each chunk. Falco allows you to fine-tune that wait time, along with several other parameters, by changing a value in <em>/etc/falco/falco.yaml</em>.</p>
<p>More importantly, it’s possible to request <em>only</em> the relevant metadata for the targeted node from the API server. This is helpful because Falco’s architecture is distributed, so each sensor needs data only from the node on which the event occurred. This optimization is fundamental if you want to scale Falco on a cluster with thousands of nodes. To enable it, add the <code>--k8s-node</code> flag to the Falco command-line arguments, passing the current node name as the value. You can usually obtain this name easily from the Kubernetes <a href="https://oreil.ly/F1Dnv">Downward API</a>.<sup><a data-type="noteref" id="ch01fn7-marker" href="ch05.xhtml#ch01fn7">3</a></sup></p>
<p>If you don’t include the <code>--k8s-node</code> flag, <em>libsinsp</em> will still be able to get the data from Kubernetes, but each Falco sensor will have to request the whole cluster’s data. This can introduce a performance penalty on large clusters, so we strongly discourage it. (You will learn more about running Falco on a production Kubernetes cluster in <a data-type="xref" href="part03.xhtml#iii_running_falco_in_production">Part III</a>.)</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="an_alternative_way_to_acquire_kubernete">
<h5>An Alternative Way to Acquire Kubernetes Metadata</h5>
<p><a contenteditable="false" data-primary="Kubernetes metadata" data-secondary="alternate means of acquiring" data-type="indexterm" id="idm45324227406400"/>Although the method described in this section is the recommended way to obtain Kubernetes metadata, there’s another, leaner working mode worth mentioning. <em>lib⁠s­insp</em> is smart enough to get a subset of the metadata even without connecting to the Kubernetes API server. That’s possible because the <a href="https://oreil.ly/sUOMa">kubelet</a> annotates some metadata directly on the container: specifically the ID, name, namespace, and labels of the Pod (which are usually the most relevant context information). Since <em>libsinsp</em> retrieves those annotations using the container runtime API, it also tries to use them when possible and falls back to the Kubernetes API server when the missing data is needed. This strategy is always enabled, so you won’t need to configure it.</p>
<p>You can think of this as an optimization, but also as a feature. If the immediately available metadata is enough for your use case (for example, if you’re using a custom ruleset that doesn’t need the complete set of Kubernetes metadata), you don’t have to enable full support for Kubernetes. If you don’t, you will still get the ID, name, namespace, and labels of the Pod.</p>
</div></aside>
<p><a contenteditable="false" data-primary="k8s filter class fields" data-type="indexterm" id="idm45324227401792"/>When Kubernetes metadata is available, you will find it grouped in the <code>k8s</code> field class. Many of the Falco default rules include <code>k8s</code> fields in their conditions. Falco, when used with the <code>-pk</code> command-line option, automatically appends the most crucial Kubernetes metadata to the output of all notifications, as you can see in the following example, which we’ve pretty-printed to improve readability (more on this in <a data-type="xref" href="ch10.xhtml#output_settings">“Output Settings”</a>):</p>
<pre data-type="programlisting">15:29:40.515013896: Notice System user ran an interactive command
	(user=bin user_loginuid=-1 command=login container_id=46c99eea62a8
	image=docker.io/library/nginx)
	k8s.ns=default k8s.pod=my-app-84d64cb8fb-zmxgz
	container=46c99eea62a8</pre>
<p>This output is the result of the complex mechanism you’ve just learned about that allows you to obtain accurate and contextualized information to immediately identify what event has just occurred, and where.</p>
<p>So far, we’ve only discussed Falco’s data enrichment process for system calls. Although that’s likely to be the most relevant information for most users, you should know that Falco also offers custom enrichment mechanisms. We’ll take a quick look at how to implement those next<a contenteditable="false" data-primary="" data-startref="ch05.html10" data-type="indexterm" id="idm45324227395872"/><a contenteditable="false" data-primary="" data-startref="ch05.html9" data-type="indexterm" id="idm45324227394496"/>.<a contenteditable="false" data-primary="" data-startref="ch05.html2" data-type="indexterm" id="idm45324227392992"/><a contenteditable="false" data-primary="" data-startref="ch05.html1" data-type="indexterm" id="idm45324227391584"/></p>
</div></section>
</div></section>
<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Data Enrichment with Plugins"><div class="sect1" id="data_enrichment_with_plugins">
<h1>Data Enrichment with Plugins</h1>
<p><a contenteditable="false" data-primary="data enrichment with plugins" data-type="indexterm" id="idm45324227388560"/><a contenteditable="false" data-primary="plugins" data-secondary="data enrichment with" data-type="indexterm" id="idm45324227387392"/>Plugins can extend Falco by adding new data sources and defining new fields to describe how to use these new events. As you’ll recall from <a data-type="xref" href="ch04.xhtml#data_source">Chapter 4</a>, a plugin that offers the field extraction capability works on events provided by other plugins or core libraries. While it might not seem obvious yet, a plugin with this capability has everything it takes to provide a custom data-enrichment mechanism. First, it can receive data from any data source. Second, it can define new fields. Fundamentally, it allows the plugin author to implement logic to return the values of those fields, thus potentially providing additional metadata. This opens the door to the possibility of implementing custom data enrichment.</p>
<p><a contenteditable="false" data-primary="libsinsp" data-secondary="plugin function for field extraction" data-type="indexterm" id="idm45324227384480"/>When such a plugin runs, <em>libsinsp</em> calls the plugin function for field extraction for each incoming event. The function receives the raw payload of the event and the list of fields the rule engine needs. The plugin API interface does not impose any other constraints to make the extraction process work. Although data enrichment is possible in the flow just described, the plugin author will still have to consider all the implications of the use case; for example, the plugin will need to manage the local state and subsequent updates. Extracting fields and enriching the event is thus entirely up to the plugin author. The APIs merely provide the essential tools.</p>
<p><a data-type="xref" href="ch14.xhtml#falco_development">Chapter 14</a> shows you how to implement a plugin. If you’re interested in doing that, however, our advice is to read the next chapter about fields and filters first, so you have a more complete picture of how extracting data works.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000004">
<h1>Conclusion</h1>
<p>This chapter illustrated how Falco works internally to provide a rich set of metadata. Falco makes this metadata available as fields you can use in rules’ conditions. Read on to discover how to use fields to filter only those events that are really pertinent to your needs.<a contenteditable="false" data-primary="" data-startref="ch05.html0" data-type="indexterm" id="idm45324227378912"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn5"><sup><a href="ch05.xhtml#ch01fn5-marker">1</a></sup> In older Falco versions, the Kubernetes audit log was a built-in data source. From Falco 0.32, this data source has been refactored out as a plugin.</p><p data-type="footnote" id="ch01fn6"><sup><a href="ch05.xhtml#ch01fn6-marker">2</a></sup> The <a href="https://oreil.ly/fiCGp">Container Runtime Interface (CRI)</a> is a plugin interface introduced by Kubernetes that enables the kubelet to use any container runtimes implementing the CRI.</p><p data-type="footnote" id="ch01fn7"><sup><a href="ch05.xhtml#ch01fn7-marker">3</a></sup> The Downward API allows containers to consume information about themselves or the cluster without using the Kubernetes API server. Among other things, it allows exposing the current node name through an environment variable that can be then used in Falco command-line arguments.</p></div></div></section></div></body></html>