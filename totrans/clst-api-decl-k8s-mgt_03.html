<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
      lang="en"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Cluster API and Declarative Kubernetes Management</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. How Cluster API Works"><div class="chapter" id="how_cluster_api_works">
      <h1><span class="label">Chapter 3. </span>How Cluster API Works</h1>
      <p>Cluster API manages clusters using a structure analogous to Kubernetes itself. Where Kubernetes uses a small number of management nodes to oversee a larger number of worker nodes, Cluster API uses a <em>management cluster</em> to oversee <em>workload clusters</em>. The Cluster API providers and controllers run in the management cluster, ensuring that each workload cluster matches its declared state.</p>
      <p>The desired states for a workload cluster and all its nodes are defined in YAML manifest files based on the schemas of CRDs that define cluster components. When you create a cluster, you use manifest files to declaratively configure its control plane, worker nodes, and other resources. The management cluster then uses a controller to manage each resource based on its CRD. <a data-type="xref" href="#fig_1_cluster_api_architecture">Figure 3-1</a> shows the overall architecture of a Cluster API <span class="keep-together">deployment</span>. </p>
      <figure><div id="fig_1_cluster_api_architecture" class="figure">
        <img alt="Cluster API architecture" src="assets/cdkm_0301.png" width="600" height="336"/>
        <h6><span class="label">Figure 3-1. </span>Cluster API architecture</h6>
      </div></figure>
      <p>Cluster API can manage multiple workload clusters in completely different environments. Infrastructure providers implement the abstraction that lets the team manage these differentiated clusters with a single consistent interface. Each host or infrastructure provider creates its own Cluster API provider implementation and its own versions of CRDs. </p>
      <p>Colloquially, the term <em>infrastructure provider</em> can refer to either the infrastructure host or the module that provisions cluster components on the host. To avoid confusion, the module is sometimes referred to as an <em>infrastructure provider implementation</em><em>. </em>There is already a rich ecosystem for Cluster API providers such as CAPA (AWS provider), CAPV (VMware vSphere provider), CAPZ (Azure provider), CAPMAAS (Canonical MAAS provider), and so on.</p>
      <section data-type="sect1" data-pdf-bookmark="Management Cluster"><div class="sect1" id="management_cluster">
        <h1>Management Cluster</h1>
        <p>In a Cluster API deployment, the management cluster runs all the providers and controllers that manage workload cluster lifecycles and handle the particulars of the infrastructure where each cluster is installed.</p>
        <p><a data-type="xref" href="#fig_2_management_cluster_architecture">Figure 3-2</a> shows the architecture of a management cluster.</p>
        <figure><div id="fig_2_management_cluster_architecture" class="figure">
          <img alt="Management cluster architecture" src="assets/cdkm_0302.png" width="600" height="302"/>
          <h6><span class="label">Figure 3-2. </span>Management cluster architecture</h6>
        </div></figure>
        <p>The Cluster API Core Manager manages the lifecycle of each cluster using controllers to bring the cluster to match the state defined in YAML manifests that implement instances of Cluster API CRDs.</p>
        <p>Cluster API manages the control plane on each workload cluster using the Kubernetes <code>KubeadmControlPlane</code> controller. The providers handle bootstrap configurations and infrastructure.</p>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Cluster API Tools"><div class="sect1" id="cluster_api_tools">
        <h1>Cluster API Tools</h1>
        <p>Cluster API provides a number of tools for managing workload clusters. The main way that an administrator interacts with a cluster is through the command-line tool <code>clusterctl</code>. For managing control planes on workload clusters, Cluster API also provides the <code>kubeadm</code>-based control plane. </p>
        <section data-type="sect2" data-pdf-bookmark="clusterctl"><div class="sect2" id="clusterctl">
          <h2>clusterctl</h2>
          <p>The command-line tool <code>clusterctl</code> simplifies the tasks of configuring, creating, deploying, and managing clusters by generating CRDs for you so that you don’t have to write your own manifest files. You can use <code>clusterctl</code> to install Cluster API components, transform a Kubernetes cluster into a management cluster, create workload clusters, upgrade clusters, and move workload clusters from one management cluster to another. </p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="kubeadm-Based Control Plane"><div class="sect2" id="kubeadm_based_control_plane">
          <h2>kubeadm-Based Control Plane</h2>
          <p>The <code>kubeadm</code>-based control plane (KCP) is a declarative API for managing Kubernetes control planes. You can use KCP to deploy, scale, and manage all the control plane components, including the API server, scheduler, controller manager, etcd data store, and networking services. KCP provides fine-grained control over the configuration of the control plane.</p>
          <p>With KCP, you can also distribute control plane nodes across failure domains (usually availability zones) to make multiple control plane failures less likely. You specify the number of control plane nodes and where to deploy them declaratively, and the control plane controller ensures that the nodes are maintained there.</p>
        </div></section>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Working with Cluster API"><div class="sect1" id="working_with_cluster_api">
        <h1>Working with Cluster API</h1>
        <p>Deploying Cluster API involves two Kubernetes clusters: one is a temporary cluster called the <em>bootstrap cluster</em>, which you use to create a second cluster that becomes the permanent Cluster API management cluster. The bootstrap cluster generates the cluster certificates, initializes the management cluster’s control plane, and installs core Kubernetes components.</p>
        <p class="pagebreak-before">The high-level steps to deploy Cluster API are:</p>
        <ol>
          <li>
            <p>Create a Kubernetes cluster to use as a temporary bootstrap cluster.</p>
          </li>
          <li>
            <p>Make the bootstrap cluster into a Cluster API management cluster.</p>
          </li>
          <li>
            <p>Use Cluster API on the temporary management cluster to bring up a workload cluster.</p>
          </li>
          <li>
            <p>Transfer Cluster API resources from the temporary management cluster to the workload cluster and convert the workload cluster into your permanent management cluster.</p>
          </li>
        </ol>
        <p>You can use a few simple <code>clusterctl</code> commands to perform these steps. After the new management cluster takes over, <code>clusterctl</code> automatically destroys the temporary management cluster.</p>
        <p>Once you have the permanent Cluster API management cluster running, you can create workload clusters. Clusters and their components are defined in YAML manifests based on the CRDs. You can use <code>clusterctl</code> to generate YAML manifests, specifying the infrastructure, Kubernetes version, number of control and worker nodes, and so on. Cluster API uses the <code>Machine</code>, <code>MachineSet</code>, and <code>MachineDeployment</code> CRDs to bring up the nodes and start the <span class="keep-together">cluster</span>.</p>
      </div></section>
    </div></section></div>
</div>
</body>
</html>