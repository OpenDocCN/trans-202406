- en: Chapter 4\. Cruising the Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the movie *The Adventures of Buckaroo Banzai Across the 8th Dimension*,
    a classic cult comedy from 1984, the swashbuckling title character offers the
    following Zen-like words of wisdom: “Remember, no matter where you go…there you
    are.” Buckaroo could very well have been talking about the Linux filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It’s also the case that wherever you are in the Linux filesystem—your current
    directory—you will eventually go somewhere else (to another directory). The faster
    and more efficiently you can perform this navigation, the more productive you
    can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The techniques in this chapter will help you navigate the filesystem more quickly
    with less typing. They look deceptively simple but have *enormous* bang for the
    buck, with small learning curves and big payoffs. These techniques fall into two
    broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving quickly to a specific directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning rapidly to a directory you’ve visited before
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a quick refresher on Linux directories, see [Appendix A](app01.xhtml#appendix_linux).
    If you use a shell other than `bash`, see [Appendix B](app02.xhtml#appendix_shells)
    for additional notes.
  prefs: []
  type: TYPE_NORMAL
- en: Visiting Specific Directories Efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ask 10 Linux experts what is the most tedious aspect of the command line,
    seven of them will say, “Typing long directory paths.”^([1](ch04.xhtml#idm46586641926592))
    After all, if your work files are in */home/smith/Work/Projects/Apps/Neutron-Star/src/include*,
    your financial documents are in */home/smith/Finances/Bank/Checking/Statements*,
    and your videos are in */data/Arts/Video/Collection*, it’s no fun to retype these
    paths over and over. In this section, you’ll learn techniques to navigate to a
    given directory efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Jump to Your Home Directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin with the basics. No matter where you go in the filesystem, you
    can return to your home directory by running `cd` with no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To jump to subdirectories within your home directory from anywhere in the filesystem,
    refer to your home directory with a shorthand rather than an absolute path such
    as */home/smith*. One shorthand is the shell variable `HOME`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another is a tilde:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `$HOME` and `~` are expressions expanded by the shell, a fact that you
    can verify by echoing them to stdout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The tilde can also refer to another user’s home directory if you place it immediately
    in front of their username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Move Faster with Tab Completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re entering `cd` commands, save typing by pressing the Tab key to
    produce directory names automatically. As a demonstration, visit a directory that
    contains subdirectories, such as */usr*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to visit the subdirectory *share*. Type `sha` and press the
    Tab key once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell completes the directory name for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This handy shortcut is called *tab completion*. It works immediately when the
    text that you’ve typed matches a single directory name. When the text matches
    multiple directory names, your shell needs more information to complete the desired
    name. Suppose you had typed only `s` and pressed Tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell cannot complete the name *share* (yet) because other directory names
    begin with `s` too: *sbin* and *src*. Press Tab a second time and the shell prints
    all possible completions to guide you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'and waits for your next action. To resolve the ambiguity, type another character,
    `h`, and press Tab once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell completes the name of the directory for you, from *sh* to *share*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In general, press Tab once to perform as much completion as possible, or press
    twice to print all possible completions. The more characters you type, the less
    ambiguity and the better the match.
  prefs: []
  type: TYPE_NORMAL
- en: Tab completion is great for speeding up navigation. Instead of typing a lengthy
    path like */home/smith/Projects/Web/src/include*, type as little as you want and
    keep pressing the Tab key. You’ll get the hang of it quickly with practice.
  prefs: []
  type: TYPE_NORMAL
- en: Tab Completion Varies by Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tab completion isn’t just for `cd` commands. It works for most commands, though
    its behavior may differ. When the command is `cd`, the Tab key completes directory
    names. For other commands that operate on files, such as `cat`, `grep`, and `sort`,
    tab completion expands filenames too. If the command is `ssh` (secure shell),
    it completes hostnames. If the command is `chown` (change the owner of a file),
    it completes usernames. You can even create your own completion rules for speed,
    as we’ll see in [Example 4-1](#ex_qcd). Also see `man bash` and read its topic
    “programmable completion.”
  prefs: []
  type: TYPE_NORMAL
- en: Hop to Frequently Visited Directories Using Aliases or Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you visit a faraway directory frequently, such as */home/smith/Work/⁠Projects​/Web/src/include*,
    create an alias that performs the `cd` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply run the alias anytime to reach your destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, create a variable to hold the directory path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Edit Frequently Edited Files with an Alias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the reason for visiting a directory frequently is to edit a particular
    file. If that’s the case, consider defining an alias to edit that file by absolute
    path without changing directory. The following alias definition lets you edit
    *$HOME/.bashrc*, no matter where you are in the filesystem, by running `rcedit`.
    No `cd` is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you regularly visit lots of directories with long paths, you can create
    aliases or variables for each of them. This approach has some disadvantages, however:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s hard to remember all those aliases/variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might accidentally create an alias with the same name as an existing command,
    causing a conflict.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative is to create a shell function like the one in [Example 4-1](#ex_qcd),
    which I’ve named `qcd` (“quick cd”). This function accepts a string key as an
    argument, such as `work` or `recipes`, and runs `cd` to a selected directory path.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. A function for `cd`-ing to faraway directories
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Store the function in a shell configuration file such as *$HOME/.bashrc* (see
    [“Environments and Initialization Files, the Short Version”](ch02.xhtml#section_environments1)),
    source it, and it’s ready to run. Type `qcd` followed by one of the supported
    keys to quickly visit the associated directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a bonus, the script’s final line runs the command `complete`, a shell builtin
    that sets up customized tab completion for `qcd`, so it completes the four supported
    keys. Now you don’t have to remember `qcd`’s arguments! Just type `qcd` followed
    by a space and press the Tab key twice, and the shell will print all the keys
    for your reference, and you can complete any of them in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Make a Big Filesystem Feel Smaller with CDPATH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `qcd` function handles only the directories that you specify. The shell
    provides a more general `cd`-ing solution without this shortcoming, called a *cd
    search path*. This shell feature transformed how I navigate the Linux filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have an important subdirectory that you visit often, named *Photos*.
    It’s located at */home/smith/Family/Memories/Photos*. As you cruise around the
    filesystem, anytime you want to get to the *Photos* directory, you may have to
    type a long path, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Wouldn’t it be great if you could shorten this path to just *Photos*, no matter
    where you are in the filesystem, and reach your subdirectory?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, this command would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'unless you happen to be in the correct parent directory (*~/Family/Memories*)
    or some other directory with a *Photos* subdirectory by coincidence. Well, with
    a little setup, you can instruct `cd` to search for your *Photos* subdirectory
    in locations other than your current directory. The search is lightning fast and
    looks only in parent directories that you specify. For example, you could instruct
    `cd` to search *$HOME/Family/Memories* in addition to the current directory. Then,
    when you type `cd Photos` from elsewhere in the filesystem, `cd` will succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A cd search path works like your command search path, `$PATH`, but instead
    of finding commands, it finds subdirectories. Configure it with the shell variable
    `CDPATH`, which has the same format as `PATH`: a list of directories separated
    by colons. If your `CDPATH` consists of these four directories, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'and you type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'then `cd` will check the existence of the following directories in order, until
    it finds one or it fails entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Photos* in the current directory'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*$HOME/Photos*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*$HOME/Projects/Photos*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*$HOME/Family/Memories/Photos*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/usr/local/Photos*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, `cd` succeeds on its fourth try and changes directory to *$HOME/Family/Memories/Photos*.
    If two directories in `$CDPATH` have a subdirectory named *Photos*, the earlier
    parent wins.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Ordinarily, a successful `cd` prints no output. When `cd` locates a directory
    using your `CDPATH`, however, it prints the absolute path on stdout to inform
    you of your new current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Fill `CDPATH` with your most important or frequently used parent directories,
    and you can `cd` into any of their subdirectories from anywhere in the filesystem,
    no matter how deep they are, without typing most of the path. Trust me, this is
    *awesome*, and the following case study should prove it.
  prefs: []
  type: TYPE_NORMAL
- en: Organize Your Home Directory for Fast Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use `CDPATH` to simplify the way you navigate your home directory. With
    a little configuration, you can make many directories within your home directory
    easily accessible with minimal typing, no matter where you are in the filesystem.
    This technique works best if your home directory is well organized with at least
    two levels of subdirectories. [Figure 4-1](#fig_cs_cdpath) shows an example of
    a well-organized directory layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![Two levels of subdirectories in the directory /home/smith](Images/elcl_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Two levels of subdirectories in the directory */home/smith*
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The trick is to set up your `CDPATH` to include, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$HOME`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your choice of subdirectories of `$HOME`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The relative path for a parent directory, indicated by two dots (`..`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By including `$HOME`, you can jump immediately to any of its subdirectories
    (*Family*, *Finances*, *Linux*, *Music*, and *Work*) from anywhere else in the
    filesystem without typing a leading path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By including subdirectories of `$HOME` in your `CDPATH`, you can jump into
    *their* subdirectories in one shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'All the directories in your `CDPATH` so far are absolute paths in `$HOME` and
    its subdirectories. By including the relative path `..` however, you empower new
    `cd` behavior in *every* directory. No matter where you are in the filesystem,
    you can jump to any *sibling* directory (*../`sibling`*) by name without typing
    the two dots, because `cd` will search your current parent. For example, if you’re
    in */usr/bin* and want to move to */usr/lib*, all you need is `cd lib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you’re a programmer working on code that has subdirectories *src*, *include*,
    and *docs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'you can jump between the subdirectories concisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A `CDPATH` for the tree in [Figure 4-1](#fig_cs_cdpath) might contain six items:
    your home directory, four of its subdirectories, and the relative path for a parent
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After sourcing the configuration file, you can `cd` to a large number of important
    directories without typing long directory paths, just short directory names. Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: This technique works best if all subdirectories beneath the `CDPATH` directories
    have unique names. If you have duplicate names, such as *$HOME/Music* and *$HOME/Linux/Music*,
    you might not get the behavior you want. The command `cd Music` will always check
    *$HOME* before *$HOME/Linux* and consequently will not locate *$HOME/Linux/Music*
    by search.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check for duplicate subdirectory names in the first two levels of `$HOME`,
    try this brash one-liner. It lists all subdirectories and sub-subdirectories of
    `$HOME`, isolates the sub-subdirectory names with `cut`, sorts the list, and counts
    occurrences with `uniq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recognize this duplicate-checking technique from [“Detecting Duplicate
    Files”](ch01.xhtml#sec_duplicate_files). If the output displays any counts greater
    than 1, you have duplicates. I realize this command includes a few features I
    haven’t covered yet. You’ll learn double ampersand (`&&`) in [“Technique #1: Conditional
    Lists”](ch07.xhtml#section_conditional_lists) and the parentheses in [“Technique
    #10: Explicit Subshells”](ch07.xhtml#section_explicit_subshells).'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to Directories Efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve just seen how to visit a directory efficiently. Now I’ll show you how
    to revisit a directory quickly when you need to go back.
  prefs: []
  type: TYPE_NORMAL
- en: Toggle Between Two Directories with “cd -”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you’re working in a deep directory and you run `cd` to go somewhere
    else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'and then think, “No, wait, I want to go back to the *Statements* directory
    where I just was.” Don’t retype the long directory path. Just run `cd` with a
    dash as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This command returns your shell to its previous directory and helpfully prints
    its absolute path so you know where you are.
  prefs: []
  type: TYPE_NORMAL
- en: 'To jump back and forth between a pair of directories, run `cd -` repeatedly.
    This is a time-saver when you’re doing focused work in two directories in a single
    shell. There’s a catch, however: the shell remembers just one previous directory
    at a time. For example, if you are toggling between */usr/local/bin* and */etc*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'and you run `cd` without arguments to jump to your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'the shell has now forgotten */usr/local/bin* as a previous directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The next technique overcomes this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Toggle Among Many Directories with pushd and popd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `cd -` command toggles between two directories, but what if you have three
    or more to keep track of? Suppose you’re creating a local website on your Linux
    computer. This task often involves four or more directories:'
  prefs: []
  type: TYPE_NORMAL
- en: The location of live, deployed web pages, such as */var/www/html*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web-server configuration directory, often */etc/apache2*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location of SSL certificates, often */etc/ssl/certs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your work directory, such as *~/Work/Projects/Web/src*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Believe me, it’s tedious to keep typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you have a large, windowing display, you can ease the burden by opening a
    separate shell window for each directory. But if you’re working in a single shell
    (say, over an SSH connection), take advantage of a shell feature called a *directory
    stack*. It lets you quickly travel among multiple directories with ease, using
    the built-in shell commands `pushd`, `popd`, and `dirs`. The learning curve is
    maybe 15 minutes, and the huge payoff in speed lasts a lifetime.^([2](ch04.xhtml#idm46586641478816))
  prefs: []
  type: TYPE_NORMAL
- en: A *directory stack* is a list of directories that you’ve visited in the current
    shell and decided to keep track of. You manipulate the stack by performing two
    operations called *pushing* and *popping*. Pushing a directory adds it to the
    beginning of the list, which is traditionally called the *top* of the stack. Popping
    removes the topmost directory from the stack.^([3](ch04.xhtml#idm46586641470176))
    Initially, the stack contains only your current directory, but you can add (push)
    and remove (pop) directories and rapidly `cd` among them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Every running shell maintains its own directory stack.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll begin with the basic operations (pushing, popping, viewing) and then get
    to the good stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Push a directory onto the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The command `pushd` (short for “push directory”) does all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a given directory to the top of the stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performs a `cd` to that directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prints the stack from top to bottom for your reference
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I’ll build a directory stack of four directories, pushing them onto the stack
    one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The shell prints the stack after each `pushd` operation. The current directory
    is the leftmost (top) directory.
  prefs: []
  type: TYPE_NORMAL
- en: View a directory stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Print a shell’s directory stack with the `dirs` command. It does not modify
    the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to print the stack from top to bottom, use the `-p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'and even pipe the output to the command `nl` to number the lines from zero
    onward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Even simpler, run `dirs -v` to print the stack with numbered lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer this top-down format, consider making an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Pop a directory from the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `popd` command (“pop directory”) is the reverse of `pushd`. It does all
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Removes one directory from the top of the stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performs a `cd` to the new top directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prints the stack from top to bottom for your reference
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, if your stack has four directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'then repeatedly running `popd` will traverse these directories from top to
    bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `pushd` and `popd` commands are such time-savers that I recommend creating
    two-character aliases that are as quick to type as `cd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Swap directories on the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you can build and empty the directory stack, let’s focus on practical
    use cases. `pushd` with no arguments swaps the top two directories in the stack
    and navigates to the new top directory. Let’s jump between */etc/apache2* and
    your work directory several times by simply running `pushd`. See how the third
    directory */var/www/html* remains in the stack as the first two directories swap
    positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `pushd` behaves similarly to the `cd -` command, toggling between
    two directories, but it does not have the limitation of remembering just one directory.
  prefs: []
  type: TYPE_NORMAL
- en: Turn a mistaken cd into a pushd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose you are jumping among several directories with `pushd` and you accidentally
    run `cd` instead and lose a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops, the accidental `cd` command replaced *~/Work/Projects/Web/src* in the
    stack with */etc/ssl/certs*. But don’t worry. You can add the missing directory
    back to the stack without typing its long path. Just run `pushd` twice, once with
    a dash argument and once without:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s dissect why this works:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `pushd` returns to your shell’s previous directory, *~/Work/Projects/Web/src*,
    and pushes it onto the stack. `pushd`, like `cd`, accepts a dash as an argument
    to mean “go back to my previous directory.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `pushd` command swaps the top two directories, bringing you back
    to */etc/ssl/certs*. The end result is that you’ve restored *~/Work/Projects/Web/src*
    to the second position in the stack, exactly where it would have been if you hadn’t
    made your mistake.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This “oops, I forgot a pushd” command is useful enough that it’s worth an alias.
    I call it `slurp` because in my mind, it “slurps back” a directory that I lost
    by mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Go deeper into the stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if you want to `cd` between directories in the stack other than the top
    two? `pushd` and `popd` accept a positive or negative integer argument to operate
    further into the stack. The command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: shifts *`N`* directories from the top of the stack to the bottom and then performs
    a `cd` to the new top directory. A negative argument (*`-N`*) shifts directories
    in the opposite direction, from the bottom to the top, before performing the `cd`.^([4](ch04.xhtml#idm46586641309520))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In this manner, you can jump to any other directory in the stack with a simple
    command. If your stack is long, however, it may be difficult to judge a directory’s
    numeric position by eye. So, print the numeric position of each directory with
    `dirs -v`, as you did in [“View a directory stack”](#sec_viewing_directory_stack):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To shift */var/www/html* to the top of the stack (and make it your current directory),
    run `pushd +3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To jump to the directory at the bottom of the stack, run `pushd -0` (dash zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You also can remove directories from the stack beyond the top directory, using
    `popd` with a numeric argument. The command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'removes the directory in position *N* from the stack, counting down from the
    top. A negative argument (*`-N`*) counts up from the bottom of the stack instead.
    Counting begins at zero, so `popd +1` removes the second directory from the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the techniques in this chapter are easy to grasp with a bit of practice
    and will save you lots of time and typing. The techniques I’ve found particularly
    life changing are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CDPATH` for rapid navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pushd` and `popd` for rapid returns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The occasional `cd -` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch04.xhtml#idm46586641926592-marker)) I made this up, but it’s surely
    true.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.xhtml#idm46586641478816-marker)) An alternative is to open multiple
    virtual displays using command-line programs like `screen` and `tmux`, which are
    called *terminal multiplexers*. They’re more effort to learn than directory stacks
    but worth a look.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch04.xhtml#idm46586641470176-marker)) If you know stacks from computer
    science, a directory stack is precisely a stack of directory names.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch04.xhtml#idm46586641309520-marker)) Programmers may recognize these
    operations as rotating the stack.
  prefs: []
  type: TYPE_NORMAL
