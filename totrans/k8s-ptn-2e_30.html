<html><head></head><body><section data-pdf-bookmark="Chapter 24. Network Segmentation" data-type="chapter" epub:type="chapter"><div class="chapter" id="NetworkSegmentation">&#13;
<h1><span class="label">Chapter 24. </span>Network Segmentation</h1>&#13;
&#13;
&#13;
<p>Kubernetes<a data-primary="Network Segmentation" data-type="indexterm" id="netseg24"/> is a great platform for running distributed applications that communicate with one another over the network.&#13;
By default, the network space within Kubernetes is flat, which means that every Pod can connect to every other Pod in the cluster.&#13;
In this chapter, we will explore how to structure this network space for improved security and a lightweight multitenancy model.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902087924176">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>Namespaces<a data-primary="problems" data-secondary="network spaces, improving security" data-type="indexterm" id="idm45902087922704"/> are a crucial part of Kubernetes, allowing you to group your workloads together. However, they only provide a grouping concept, imposing isolation constraints on the containers associated with specific namespaces. In Kubernetes, every Pod can talk to every other Pod, regardless of their namespace. This default behavior has security implications, particularly when multiple independent applications operated by different teams run in the same cluster.</p>&#13;
&#13;
<p>Restricting network access to and from Pods is essential for enhancing the security of your application because not everyone may be allowed to access your application via an ingress. Outgoing egress network traffic for Pods should also be limited to what is necessary to minimize the blast radius of a security breach.</p>&#13;
&#13;
<p>Network segmentation plays a vital role in multitenancy setups where multiple parties share the same cluster. For example, the following sidebar addresses some of the challenges of multitenancy on Kubernetes, such as creating network boundaries for applications.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="network-segmentation-multi-tenancy">&#13;
<h1>Multitenancy with Kubernetes</h1>&#13;
<p><em>Multitenancy</em> refers<a data-primary="multitenancy" data-type="indexterm" id="idm45902087918480"/> to platform’s ability to support multiple isolated user groups, also known as<a data-primary="tenants" data-type="indexterm" id="idm45902087917616"/> <em>tenants</em>. Kubernetes does not provide extensive support for multitenancy out of the box, and the concept itself can be complex and difficult to define. The Kubernetes documentation on <a href="https://oreil.ly/T1cCG">Multitenancy</a> covers various aspects and the support within the platform, including namespaces and access control (<a data-type="xref" href="ch26.html#AccessControl">Chapter 26</a>), quotas to prevent noisy neighbor issues, storage and network isolation, and handling of shared resources like cluster-wide DNS or CustomResourceDefinitions. In this chapter, we will focus on the network isolation aspects, which offer a softer approach to multitenancy. Stricter isolation requirements may require a more encapsulated approach, such as a virtual control plane per tenant, as provided by <a href="https://oreil.ly/aVbiM">vcluster</a>.</p>&#13;
</div></aside>&#13;
&#13;
<p>In the past, shaping the network topology was primarily the responsibility of administrators who managed firewalls and iptable rules. The challenge with this model is that administrators need to understand the networking requirements of the applications. In addition, the network graph can get very complex in a microservices world with many dependencies, requiring deep domain knowledge about the application. In this sense, the developer must communicate and sync information about dependencies with administrators. A DevOps setup can help, but the definition of network topologies is still far away from the application itself and can change dynamically over time.</p>&#13;
&#13;
<p>So, what does defining and establishing a network segmentation look like in a Kubernetes world?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902087913008">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>The good news is that Kubernetes<a data-primary="Shift Left model" data-type="indexterm" id="idm45902087911504"/> shifts left these networking tasks so that developers using Kubernetes fully define their applications’ networking topology. You have already seen this process model described briefly in <a data-type="xref" href="ch23.html#ProcessContainment">Chapter 23</a>, when we discussed the <em>Process Containment</em> pattern.</p>&#13;
&#13;
<p>The essence of this <em>Network Segmentation</em> pattern is how we, as developers, can define the network segmentation for our applications by creating “application firewalls.”</p>&#13;
&#13;
<p class="pagebreak-before">There are two ways to implement this feature that are complementary and can be applied together. The first is through the use of core Kubernetes features that operate on the L3/L4 networking layers.<sup><a data-type="noteref" href="ch24.html#idm45902087907696" id="idm45902087907696-marker">1</a></sup> By defining resources of the type NetworkPolicy, developers can create ingress and egress firewall rules for workload Pods.</p>&#13;
&#13;
<p>The other method involves the use of a<a data-primary="service meshes" data-type="indexterm" id="idm45902087906512"/> service mesh and targets the L7 protocol layer, specifically HTTP-based communication. This allows for filtering based on HTTP verbs and other L7 protocol parameters. We will explore<a data-primary="Istio" data-type="indexterm" id="idm45902087905680"/> Istio’s AuthenticationPolicy later in this chapter.</p>&#13;
&#13;
<p>To start, let’s focus on how to use NetworkPolicies to define the network boundaries for your application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Network Policies" data-type="sect2"><div class="sect2" id="idm45902087904176">&#13;
<h2>Network Policies</h2>&#13;
&#13;
<p>NetworkPolicy<a data-primary="network policies" data-type="indexterm" id="netpol23"/> is a Kubernetes resource type that allows users to define rules for inbound and outbound network connections for Pods. These rules act like a custom firewall and determine which Pods can be accessed and which destinations they can connect to. The user-defined rules are picked up by the<a data-primary="Container Network Interface (CNI)" data-type="indexterm" id="idm45902087901040"/><a data-primary="CNI (Container Network Interface)" data-type="indexterm" id="idm45902087900304"/> Container Network Interface (CNI) add-on used by Kubernetes for its internal networking. However, not all CNI plugins support NetworkPolicies; for example, the popular Flannel CNI plugin does not support it, but many others, like Calico, do. All hosted Kubernetes cloud offerings support NetworkPolicy (either directly or by configuring an add-on) as well as other distributions like Minikube.</p>&#13;
&#13;
<p>The NetworkPolicy definition consists of a selector for Pods and lists of inbound (ingress) or outbound (egress) rules.</p>&#13;
&#13;
<p>The<a data-primary="Pod selector" data-type="indexterm" id="idm45902087898560"/> <em>Pod selector</em> is used to match the Pods to which the NetworkPolicy should be applied. This selection is done by using labels, which are metadata attached to Pods. The labels allow for a flexible and dynamic grouping of Pods, meaning that the same NetworkPolicy can be applied to multiple Pods that share the same labels and are running in the same namespace as the NetworkPolicy. Pod selectors are described in detail in <a data-type="xref" href="ch01.html#intro-labels">“Labels”</a>.</p>&#13;
&#13;
<p>The list of <em>ingress</em> and <em>egress</em> rules defines which inbound and outbound connections are allowed for the Pods matched by the Pod selector. These rules specify which sources and destinations are allowed to connect to and from the Pods. For example, a rule could allow connections from a specific IP address or range of addresses, or it could block connections to a specific destination.</p>&#13;
&#13;
<p class="less_space pagebreak-before">Let’s start with the simple example in <a data-type="xref" href="#ex-network-segmentation-simple">Example 24-1</a> that allows access to all database Pods only from backend Pods and nothing else.</p>&#13;
<div data-type="example" id="ex-network-segmentation-simple">&#13;
<h5><span class="label">Example 24-1. </span>Simple NetworkPolicy allowing ingress traffic</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NetworkPolicy</code><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">allow-database</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">        </code><a class="co" href="#callout_network_segmentation_CO1-1" id="co_network_segmentation_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chili-shop</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">id</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">database</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">ingress</code><code class="p">:</code><code class="w">            </code><a class="co" href="#callout_network_segmentation_CO1-2" id="co_network_segmentation_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">from</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">    </code><a class="co" href="#callout_network_segmentation_CO1-3" id="co_network_segmentation_CO1-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chili-shop</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">id</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_network_segmentation_CO1-1" id="callout_network_segmentation_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Selector matching all Pods with the label <code>id: database</code> and <code>app: chili-shop</code>. All those Pods are affected by this NetworkPolicy.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO1-2" id="callout_network_segmentation_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>List of sources that are allowed for incoming traffic.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO1-3" id="callout_network_segmentation_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Pod selector that will allow all Pods of the type <code>backend</code> to access the selected database Pods.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p><a data-type="xref" href="#img-network-segmentation-ingress">Figure 24-1</a> shows how the backend Pods can access the database Pods but frontend Pods can’t.</p>&#13;
&#13;
<figure><div class="figure" id="img-network-segmentation-ingress">&#13;
<img alt="Stages that need to be passed by a request to the Kubernetes API server" src="assets/kup2_2401.png"/>&#13;
<h6><span class="label">Figure 24-1. </span>NetworkPolicy for ingress traffic</h6>&#13;
</div></figure>&#13;
&#13;
<p>NetworkPolicy objects are namespace-scoped and match only Pods from within the NetworkPolicy’s namespace.&#13;
Unfortunately, there is no way to define cluster-wide defaults for all namespaces.&#13;
However, some CNI plugins like Calico support customer extensions for defining cluster-wide behavior.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Network segment definition with labels" data-type="sect3"><div class="sect3" id="network-segmentation-labeling">&#13;
<h3>Network segment definition with labels</h3>&#13;
&#13;
<p>In <a data-type="xref" href="#ex-network-segmentation-simple">Example 24-1</a>, we can see how<a data-primary="label selectors" data-secondary="network segmentation" data-type="indexterm" id="idm45902087762816"/> label selectors are used to dynamically define groups of Pods. This is a powerful concept in Kubernetes that allows users to easily create distinct networking segments.</p>&#13;
&#13;
<p>Developers are typically the best ones to know which Pods belong to a specific application and how they communicate with one another. By carefully labeling the Pods, users can directly translate the dependency graphs of distributed applications into NetworkPolicies. These policies can then be used to define the network boundaries for an application, with well-defined entry and exit points.</p>&#13;
&#13;
<p>To create network segmentation using labels, it’s common to label all Pods in the application with a unique <code>app</code> label. The <code>app</code> label can be used in the selector of the NetworkPolicy to ensure that all Pods belonging to the application are covered by the policy. For example, in <a data-type="xref" href="#ex-network-segmentation-simple">Example 24-1</a>, the network segment is defined using an <code>app</code> label with the value <code>chili-shop</code>.</p>&#13;
&#13;
<p>There are two common ways to consistently label workloads:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Using workload-unique labels, you can directly model the dependency graph between application components such as other microservices or a database. These workloads can consist of multiple Pods, for example, when deployed in high availability. This technique is used to model the permission graph in <a data-type="xref" href="#ex-network-segmentation-simple">Example 24-1</a>, where we use a label <code>type</code> to identify the application component. Only one type of workload (e.g., Deployment or StatefulSet) is expected to carry the label <code>type: database</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>In a more loosely coupled approach, you can define specific <code>role</code> or <code>permissions</code> labels that need to be attached to every workload that plays a certain role. <a data-type="xref" href="#ex-network-segmentation-simple-role">Example 24-2</a> shows an example of this setup. This approach is more flexible and allows for new workloads to be added without updating the NetworkPolicy. However, the more straightforward approach of directly connecting workloads is often easier to understand by simply looking at the NetworkPolicy without having to look up all workloads that apply to a role.</p>&#13;
</li>&#13;
</ul>&#13;
<div class="less_space pagebreak-before" data-type="example" id="ex-network-segmentation-simple-role">&#13;
<h5><span class="label">Example 24-2. </span>Role-based network segment definition</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">label</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chili-shop</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">id</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">role-database-client</code><code class="p">:</code><code class="w"> </code><code class="s">'</code><code class="s">true</code><code class="s">'</code><code class="w">       </code><a class="co" href="#callout_network_segmentation_CO2-1" id="co_network_segmentation_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">role-cache-client</code><code class="p">:</code><code class="w"> </code><code class="s">'</code><code class="s">true</code><code class="s">'</code><code class="w">&#13;
</code><code class="p">...</code><code class="l-Scalar-Plain">.</code><code class="w">&#13;
</code><code class="nn">---</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NetworkPolicy</code><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">allow-database-client</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chili-shop</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">id</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">database</code><code class="w">                     </code><a class="co" href="#callout_network_segmentation_CO2-2" id="co_network_segmentation_CO2-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">ingress</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">from</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chili-shop</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">role-database-client</code><code class="p">:</code><code class="w"> </code><code class="s">'</code><code class="s">true</code><code class="s">'</code><code class="w"> </code><a class="co" href="#callout_network_segmentation_CO2-3" id="co_network_segmentation_CO2-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_network_segmentation_CO2-1" id="callout_network_segmentation_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Add all roles that enable this backend Pod to access the requested services.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO2-2" id="callout_network_segmentation_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Selector matching the database Pods—i.e., Pods with the label <code>id: database</code>.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO2-3" id="callout_network_segmentation_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Every Pod that is a database client (<code>role-database-client: 'true'</code>) is allowed to send traffic to the backend Pod.</p></dd>&#13;
</dl></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deny-all as default policy" data-type="sect3"><div class="sect3" id="idm45902087635104">&#13;
<h3>Deny-all as default policy</h3>&#13;
&#13;
<p>In<a data-primary="deny-all policy" data-type="indexterm" id="idm45902087633664"/> Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#ex-network-segmentation-simple">24-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#ex-network-segmentation-simple-role">24-2</a>, we have seen how to individually configure the allowed incoming connections for a selected set of Pods.&#13;
This setup works fine as long as you don’t forget to configure one Pod, since the default mode, when NetworkPolicy is not configured in the namespace, does not restrict incoming and outgoing traffic (allow-all).&#13;
Also, for Pods that we might create in the future, it is problematic that it might be necessary to remember to add the respective NetworkPolicy.</p>&#13;
&#13;
<p>Therefore, it is highly recommended to start with a deny-all policy, as shown in <a data-type="xref" href="#ex-network-segmentation-deny-all">Example 24-3</a>.</p>&#13;
<div class="less_space pagebreak-before" data-type="example" id="ex-network-segmentation-deny-all">&#13;
<h5><span class="label">Example 24-3. </span>Deny-all policy for incoming traffic</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NetworkPolicy</code><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">deny-all</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="w">     </code><a class="co" href="#callout_network_segmentation_CO3-1" id="co_network_segmentation_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">ingress</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="p-Indicator">]</code><code class="w">         </code><a class="co" href="#callout_network_segmentation_CO3-2" id="co_network_segmentation_CO3-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_network_segmentation_CO3-1" id="callout_network_segmentation_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>An empty selector matches every Pod.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO3-2" id="callout_network_segmentation_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>An empty list of ingress rules implies that all incoming traffic gets dropped.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The list of allowed ingresses is set to an empty list (<code>[]</code>), which implies there is no ingress rule that allows incoming traffic.&#13;
Note that an empty list <code>[]</code> is different from a list with a single empty element <code>[ {} ]</code>, which achieves the exact opposite since the single empty rule matches everything.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Ingress" data-type="sect3"><div class="sect3" id="idm45902087530928">&#13;
<h3>Ingress</h3>&#13;
&#13;
<p><a data-type="xref" href="#ex-network-segmentation-simple">Example 24-1</a> covers<a data-primary="ingress network traffic" data-type="indexterm" id="idm45902087496656"/> the primary use case of a policy that covers ingress traffic. We have already explained the <code>podSelector</code> field and given an example of an <code>ingress</code> list that matches Pods that are allowed to send traffic to the Pod under configuration.&#13;
The selected Pod can receive traffic if any of the configured ingress rules in the list are matched.</p>&#13;
&#13;
<p>Besides selecting Pods, you have additional options to configure the ingress rules.&#13;
We already saw the <code>from</code> field for an ingress rule that can contain a <code>podSelector</code> for selecting all Pods that pass this rule. In addition, a <code>namespaceSelector</code> can be given to choose the namespaces in which the <code>podSelector</code> should be applied to identify the Pods that can send traffic.</p>&#13;
&#13;
<p><a data-type="xref" href="#table-network-segmentation-ingress-rules">Table 24-1</a> shows the effect of the various combinations of <code>podSelector</code> and <code>name​sp⁠aceSelector</code>.&#13;
Combining both fields allows for very flexible setups.</p>&#13;
<table id="table-network-segmentation-ingress-rules">&#13;
<caption><span class="label">Table 24-1. </span>Combinations of setting <code>podSelector</code> and <code>namespaceSelector</code> <code>({}: empty</code>, <code>{...}: non-empty</code>, <code>---: unset</code>)</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>podSelector</th>&#13;
<th>namespaceSelector</th>&#13;
<th>Behavior</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>{}</p></td>&#13;
<td><p>{}</p></td>&#13;
<td><p>Every Pod in every namespace</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>{}</p></td>&#13;
<td><p>{ …​ }</p></td>&#13;
<td><p>Every Pod in the matched namespaces</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>{ …​ }</p></td>&#13;
<td><p>{ }</p></td>&#13;
<td><p>Every matching Pod in all namespaces</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>{ …​ }</p></td>&#13;
<td><p>{ …​ }</p></td>&#13;
<td><p>Every matching Pod in the matching namespaces</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>---</p></td>&#13;
<td><p>{ …​ } / {}</p></td>&#13;
<td><p>Every Pod in the matching namespace/all namespaces</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>{ …​ } / {}</p></td>&#13;
<td><p>---</p></td>&#13;
<td><p>Matching Pods/every Pod in the NetworkPolicy’s namespace</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>As an alternative for selecting Pods from the cluster, a range of IP addresses can be specified with a field <code>ipBlock</code>. We show IP ranges in <a data-type="xref" href="#ex-network-segmentation-egress-ipblock">Example 24-5</a>.</p>&#13;
&#13;
<p>Another option is to restrict the traffic to specific ports to the selected Pod. We can specify this list with a <code>ports</code> field that contains all allowed ports.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Egress" data-type="sect3"><div class="sect3" id="idm45902087468192">&#13;
<h3>Egress</h3>&#13;
&#13;
<p>Not<a data-primary="egress network traffic" data-type="indexterm" id="idm45902087466528"/> only can incoming traffic be regulated, but so can any request that a Pod sends in the outgoing direction.&#13;
Egress rules are configured precisely with the same options as ingress rules.&#13;
And as with ingress rules, starting with a very restrictive policy is recommended.&#13;
However, denying all outgoing traffic is not practical.&#13;
Every Pod needs interaction with Pods from the system namespace for DNS lookups.&#13;
Also, if we use ingress rules to restrict incoming traffic, we would have to add mirrored egress rules for the source Pods.&#13;
So let’s be pragmatic and allow all egress within the cluster, forbid everything outside the cluster, and let ingress rules define the network boundaries.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-network-segmentation-internal-egress">Example 24-4</a> shows the definition of such a rule.</p>&#13;
<div data-type="example" id="ex-network-segmentation-internal-egress">&#13;
<h5><span class="label">Example 24-4. </span>Allow all internal egress traffic</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NetworkPolicy</code><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">egress-allow-internal-only</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">policyTypes</code><code class="p">:</code><code class="w">              </code><a class="co" href="#callout_network_segmentation_CO4-1" id="co_network_segmentation_CO4-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">Egress</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="w">           </code><a class="co" href="#callout_network_segmentation_CO4-2" id="co_network_segmentation_CO4-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">egress</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">to</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">namespaceSelector</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="w"> </code><a class="co" href="#callout_network_segmentation_CO4-3" id="co_network_segmentation_CO4-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_network_segmentation_CO4-1" id="callout_network_segmentation_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Add only <code>Egress</code> as policy type; otherwise, Kubernetes assumes that you want to specify ingress and egress.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO4-2" id="callout_network_segmentation_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Apply NetworkPolicy to all Pods in the NetworkPolicy’s namespace.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO4-3" id="callout_network_segmentation_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Allow egress to every Pod in every other namespace.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p class="pagebreak-before"><a data-type="xref" href="#img-network-segmentation-egress">Figure 24-2</a> illustrates the effect of this NetworkPolicy and how it prevents Pods from connecting to external services.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="img-network-segmentation-egress">&#13;
<img alt="NetworkPolicy that allows only internal egress traffic" src="assets/kup2_2402.png"/>&#13;
<h6><span class="label">Figure 24-2. </span>NetworkPolicy that allows only internal egress traffic</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>policyTypes</code> field in a NetworkPolicy determines the type of traffic the policy affects. It is a list that can contain the elements <code>Egress</code> and/or <code>Ingress</code>, and it specifies which rules are included in the policy. If the field is omitted, the default value is determined based on the presence of the <code>ingress</code> and <code>egress</code> rule sections:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If an <code>ingress</code> section is present, the default value of <code>policyTypes</code> is <code>[Ingress]</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If an <code>egress</code> section is provided, the default value of <code>policyTypes</code> is <code>[Ingress, Egress]</code> regardless of whether ingress rules are provided.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This default behavior implies that to define an egress-only policy, you must explicitly set <code>policyTypes</code> to <code>[Egress]</code>,  as in <a data-type="xref" href="#ex-network-segmentation-internal-egress">Example 24-4</a>. Failing to do so would imply an empty <code>ingress</code> rules set, effectively forbidding all incoming traffic.</p>&#13;
&#13;
<p>With this restriction for cluster-internal egress traffic in place, we can selectively activate access to external IP addresses for certain Pods that might require cluster-external network access.&#13;
In <a data-type="xref" href="#ex-network-segmentation-egress-ipblock">Example 24-5</a>, such an IP range block for allowing external egress access is defined.</p>&#13;
<div class="less_space pagebreak-before" data-type="example" id="ex-network-segmentation-egress-ipblock">&#13;
<h5><span class="label">Example 24-5. </span>NetworkPolicy that allows access to all IP addresses, with some exceptions</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NetworkPolicy</code><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">allow-external-ips</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">egress</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">to</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">ipBlock</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">cidr</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">0.0.0.0/0</code><code class="w">   </code><a class="co" href="#callout_network_segmentation_CO5-1" id="co_network_segmentation_CO5-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">except</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">192.168.0.0/16</code><code class="w">  </code><a class="co" href="#callout_network_segmentation_CO5-2" id="co_network_segmentation_CO5-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">172.23.42.0/24</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_network_segmentation_CO5-1" id="callout_network_segmentation_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Allow access to all IP addresses…​</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO5-2" id="callout_network_segmentation_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>…​except IP addresses that belong to these subnets.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Some care must be taken if you decide to choose more strict egress rules and also want to restrict the cluster’s internal egress traffic. First, it is essential to always allow access to the DNS server in the kube-system namespace. This configuration is best done by allowing access to port 53 for UDP and TCP to all ports in the system namespace.</p>&#13;
&#13;
<p>For operators and controllers, the Kubernetes API server needs to be accessible.&#13;
Unfortunately, no unique label would select the API server in the kube-system namespace, so the filtering should happen on the API server’s IP address. The IP address can best be fetched from the <code>kubernetes</code> endpoints in the default namespace with<a data-primary="kubectl" data-secondary="Network Segmentation" data-type="indexterm" id="idm45902087235136"/> <code>kubectl get endpoints -n default kubernetes</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tooling" data-type="sect3"><div class="sect3" id="idm45902087467600">&#13;
<h3>Tooling</h3>&#13;
&#13;
<p>Setting up the network topology with NetworkPolicies gets complex quickly since it involves creating many NetworkPolicy resources. It is best to start with some simple use cases that you can adapt to your specific needs. <a href="https://oreil.ly/NvQFm">Kubernetes Network Policy Recipes</a> is a good starting point.</p>&#13;
&#13;
<p>Commonly, NetworkPolicies are defined along with the application’s architecture.&#13;
However, sometimes you must retrofit the policy schemas to an existing solution.&#13;
In this case, policy advisor tools can be beneficial.&#13;
They work by recording the network activity when playing through typical use cases.&#13;
A comprehensive integration test suite with good test coverage pays off to catch all corner cases involving network connections.&#13;
As of 2023, several tools can help you audit network traffic to create network policies.</p>&#13;
&#13;
<p><a href="https://oreil.ly/nlVOx">Inspektor Gadget</a> is a great tool suite for debugging and inspecting Kubernetes resources.&#13;
It is entirely based on eBPF programs that enable kernel-level observability and provides a bridge from kernel features to high-level Kubernetes resources.&#13;
One of Inspektor Gadget’s features is to monitor network activity and record all UDP and TCP traffic for generating Kubernetes network policies.&#13;
This technique works well but depends on the quality and depth of covered use cases.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902087229616">&#13;
<h1>What Is eBPF?</h1>&#13;
<p>eBPF is a Linux technology that can run sandboxed programs in kernel space.<sup><a data-type="noteref" href="ch24.html#idm45902087228288" id="idm45902087228288-marker">2</a></sup> This technique extends the kernel’s capabilities safely and allows for much faster innovation on top of this interface.</p>&#13;
&#13;
<p>To some degree, eBPF is the next-generation plugin architecture for the Linux kernel.&#13;
The flexibility of this API has fostered the evolution of many eBPF projects that cover a wide area of use cases, including observability and security.</p>&#13;
</div></aside>&#13;
&#13;
<p>Another great eBPF-based platform is <a href="https://cilium.io">Cilium</a>, which has a dedicated audit mode that tracks all network traffic and matches it against a given network policy.&#13;
By starting with a deny-all policy and audit mode enabled, Cilium will record all policy violations but will not block the traffic otherwise.&#13;
The audit report helps create the proper NetworkPolicy to fit the traffic patterns exercised.</p>&#13;
&#13;
<p>These are only two examples of the rich and growing landscape of tools for&#13;
policy recommendation, simulations, and auditing.</p>&#13;
&#13;
<p>Now that you have seen how we can model the network boundaries for our application on the TCP/UDP and IP levels, let’s move up some levels in the OSI stack.<a data-primary="" data-startref="netpol23" data-type="indexterm" id="idm45902087223536"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authentication Policies" data-type="sect2"><div class="sect2" id="idm45902087903552">&#13;
<h2>Authentication Policies</h2>&#13;
&#13;
<p>Until now, we<a data-primary="authentication policies" data-type="indexterm" id="idm45902087220832"/> looked at how we can control the network traffic between Pods on the TCP/IP level.&#13;
However, it is sometimes beneficial to base the network restrictions on filtering on higher-level protocol parameters.&#13;
This advanced network control requires knowledge of higher-level protocols like HTTP and the ability to inspect incoming and outgoing traffic.&#13;
Kubernetes does not support this out of the box. Luckily, a whole family of add-ons extends Kubernetes to provide this functionality: service meshes.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902087219840">&#13;
<h1>Service Mesh</h1>&#13;
<p>Some<a data-primary="service meshes" data-type="indexterm" id="idm45902087218320"/> operational requirements like security, observability, or reliability affect all your applications.&#13;
A service mesh takes care of these aspects in a generic way so that applications can focus on their business logic.&#13;
Service meshes<a data-primary="Network Segmentation" data-secondary="Ambassador" data-type="indexterm" id="idm45902087217488"/><a data-primary="Network Segmentation" data-secondary="Sidecar" data-type="indexterm" id="idm45902087216512"/><a data-primary="Network Segmentation" data-secondary="Adapter" data-type="indexterm" id="idm45902087215568"/><a data-primary="Ambassador" data-secondary="Network Segmentation" data-type="indexterm" id="idm45902087214624"/><a data-primary="Ambassador" data-type="indexterm" id="idm45902087213680"/><a data-primary="Sidecar" data-type="indexterm" id="idm45902087213008"/><a data-primary="Sidecar" data-secondary="Network Segmentation" data-type="indexterm" id="idm45902087212336"/><a data-primary="Adapter" data-secondary="Network Segmentation" data-type="indexterm" id="idm45902087211392"/><a data-primary="Adapter" data-type="indexterm" id="idm45902087210448"/> usually work by injecting sidecar containers into the workload Pods that act as the ambassador from <a data-type="xref" href="ch18.html#Ambassador">Chapter 18</a> and adapter from <a data-type="xref" href="ch17.html#Adapter">Chapter 17</a> to intercept L7 incoming and outgoing traffic. Newer techniques to intercept the network traffic include node-wide proxies and a mesh data plane.</p>&#13;
&#13;
<p>Prominent examples of service meshes are Istio, Gloo Mesh, and Linkerd. Still, many more are listed in the <a href="https://oreil.ly/x_2rg">CNCF Cloud Native Interactive Landscape</a>.</p>&#13;
</div></aside>&#13;
&#13;
<p>We chose<a data-primary="Istio" data-type="indexterm" id="istio23"/> Istio as our example service mesh, but you will find similar functionalities in other service meshes.&#13;
We won’t go into much detail about service meshes or Istio. Instead, we’ll focus on a particular custom resource of Istio that helps us shape the networking segments on the HTTP protocol level.</p>&#13;
&#13;
<p>Istio has a rich feature set for enabling authentication, transport security via mTLS, identity management with CERT rotations, and authorization.</p>&#13;
&#13;
<p>As with other Kubernetes extensions, Istio leverages the Kubernetes API machinery by introducing its own CustomResourceDefinitions (CRDs) that are explained in detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch28.html#Operator">Chapter 28, “Operator”</a>.&#13;
Authorization in Istio is configured with the AuthorizationPolicy resource.&#13;
While AuthorizationPolicy is only one component in Istio’s security model, it can be used alone and allows for partitioning the network space based on HTTP.</p>&#13;
&#13;
<p>The schema of AuthorizationPolicy is very similar to NetworkPolicy but is more flexible and includes HTTP-specific filters.&#13;
NetworkPolicy and AuthorizationPolicy should be used together. This can lead to a tricky debugging setup when two configurations must be checked and verified in parallel.&#13;
Traffic will pass through to a Pod only if the two user-defined firewalls spanned by NetworkPolicy and AuthorizationPolicy definition will allow it.</p>&#13;
&#13;
<p>An AuthorizationPolicy is a namespaced resource and contains a set of rules that control whether or not traffic is allowed or denied to a particular set of Pods in a Kubernetes cluster.&#13;
The policy consists of the following three parts:</p>&#13;
<dl>&#13;
<dt>Selector</dt>&#13;
<dd>&#13;
<p>Specifies which Pods the policy applies to. If no selector is specified, the policy applies to all Pods in the same namespace as the policy. If the policy is created in Istio’s root namespace (<code>istio-system</code>), it applies to all matching Pods in all namespaces.</p>&#13;
</dd>&#13;
<dt>Action</dt>&#13;
<dd>&#13;
<p>Defines what should be done with the traffic that matches the rules. The possible actions are <code>ALLOW</code>, <code>DENY</code>, <code>AUDIT</code> (for logging only), and <code>CUSTOM</code> (for user-defined actions).</p>&#13;
</dd>&#13;
<dt>List of rules</dt>&#13;
<dd>&#13;
<p>These are evaluated for incoming traffic. All of the rules must be satisfied for the action to be taken. Each rule has three components: a <code>from</code> field that specifies the source of the request, a <code>to</code> field that specifies the HTTP operation that the request must match, and an optional <code>when</code> field for additional conditions (e.g., the identity associated with the request must match a particular value).</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#ex-network-segmentation-authorization-policy">Example 24-6</a> shows a typical example that allows the monitoring operator access to application endpoints for collecting metric data.</p>&#13;
<div data-type="example" id="ex-network-segmentation-authorization-policy">&#13;
<h5><span class="label">Example 24-6. </span>Authorization for a Prometheus setup</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">security.istio.io/v1beta1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">AuthorizationPolicy</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus-scraper</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">istio-system</code><code class="w">   </code><a class="co" href="#callout_network_segmentation_CO6-1" id="co_network_segmentation_CO6-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w">                 </code><a class="co" href="#callout_network_segmentation_CO6-2" id="co_network_segmentation_CO6-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">has-metrics</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">true</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">action</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ALLOW</code><code class="w">             </code><a class="co" href="#callout_network_segmentation_CO6-3" id="co_network_segmentation_CO6-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">from</code><code class="p">:</code><code class="w">                   </code><a class="co" href="#callout_network_segmentation_CO6-4" id="co_network_segmentation_CO6-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">source</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">prometheus</code><code class="s">"</code><code class="p-Indicator">]</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">to</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">operation</code><code class="p">:</code><code class="w">            </code><a class="co" href="#callout_network_segmentation_CO6-5" id="co_network_segmentation_CO6-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">methods</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"</code><code class="s">GET</code><code class="s">"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">paths</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">/metrics/*</code><code class="s">"</code><code class="p-Indicator">]</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_network_segmentation_CO6-1" id="callout_network_segmentation_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>When created in the namespace <code>istio-system</code>, the policy applies to all matching Pods in all namespaces.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO6-2" id="callout_network_segmentation_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The policy is applied to all Pods with a <code>has-metrics</code> label set to <code>true</code>.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO6-3" id="callout_network_segmentation_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The action should allow the request to pass if the rules match.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO6-4" id="callout_network_segmentation_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Every request coming from a Pod from the <code>prometheus</code> namespace…​</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO6-5" id="callout_network_segmentation_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>…​can perform a GET request on the <code>/metrics</code> endpoint.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>In <a data-type="xref" href="#ex-network-segmentation-authorization-policy">Example 24-6</a>, every Pod that carries the label <code>has-metrics: "true"</code>  allows traffic to its <code>/metrics</code> endpoint from each Pod of the <code>prometheus</code> namespace.</p>&#13;
&#13;
<p>This policy has an effect only if, by default, all requests are denied. As for NetworkPolicy, the best starting point is to define a deny-all policy, as shown in <a data-type="xref" href="#ex-network-segmentation-istio-deny-all">Example 24-7</a>, and then selectively build up the network topology by allowing dedicated routes.</p>&#13;
<div data-type="example" id="ex-network-segmentation-istio-deny-all">&#13;
<h5><span class="label">Example 24-7. </span>Deny-all policy as the default</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">security.istio.io/v1beta1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">AuthorizationPolicy</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">deny-all</code><code class="w">&#13;
</code><code class="w"> </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">istio-system</code><code class="w"> </code><a class="co" href="#callout_network_segmentation_CO7-1" id="co_network_segmentation_CO7-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w"> </code><code class="nt">selector</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="w">            </code><a class="co" href="#callout_network_segmentation_CO7-2" id="co_network_segmentation_CO7-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w"> </code><code class="nt">action</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DENY</code><code class="w">            </code><a class="co" href="#callout_network_segmentation_CO7-3" id="co_network_segmentation_CO7-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w"> </code><code class="nt">rules</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="p-Indicator">]</code><code class="w">             </code><a class="co" href="#callout_network_segmentation_CO7-4" id="co_network_segmentation_CO7-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_network_segmentation_CO7-1" id="callout_network_segmentation_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The policy applies to all namespaces since it is created in <code>istio-system</code>.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO7-2" id="callout_network_segmentation_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>An empty selector always matches.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO7-3" id="callout_network_segmentation_CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Deny access for all Pods that match the selector.</p></dd>&#13;
<dt><a class="co" href="#co_network_segmentation_CO7-4" id="callout_network_segmentation_CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>An empty rule that will always match.</p></dd>&#13;
</dl></div>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Istio follows NetworkPolicy’s semantics that an empty rule list [] never matches. In contrast, a list with a single empty rule [{}] always matches.</p>&#13;
</div>&#13;
&#13;
<p>With the help of the proper labeling schema, AuthorizationPolicy helps define the application’s network segments that are independent and isolated from one another.&#13;
All that we said in <a data-type="xref" href="#network-segmentation-labeling">“Network segment definition with labels”</a> also applies here.</p>&#13;
&#13;
<p>However, AuthorizationPolicy can also be used for application-level authorization when we add an identity check to the rules.&#13;
One crucial difference to the authorization that we describe in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch26.html#AccessControl">Chapter 26, “Access Control”</a>, is that AuthorizationPolicy is about <em>application authorization</em>, while the Kubernetes RBAC model is about securing the access to the Kubernetes API server. Access control is primarily helpful for operators monitoring their custom resources.<a data-primary="" data-startref="istio23" data-type="indexterm" id="idm45902086906336"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902087221840">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>In the early days of computing, network topologies were defined by physical wiring and devices like switches.&#13;
This approach is secure but not very flexible.&#13;
With the advent of virtualization, these devices were replaced by software-backed constructs to provide network security.&#13;
<em>Software-defined networking</em> (SDN)<a data-primary="SDN (software-defined networking)" data-type="indexterm" id="idm45902086903744"/><a data-primary="software-defined networking (SDN)" data-type="indexterm" id="idm45902086902976"/> is a type of computer networking architecture that allows network administrators to manage network services through abstraction of lower-level functionality.&#13;
This abstraction is typically achieved by separating the control plane, which makes decisions about how data should be transmitted, from the data plane, which actually sends the data. Even with the use of SDN, administrators are still needed to set up and rearrange networking boundaries to effectively manage the network.</p>&#13;
&#13;
<p>Kubernetes has the ability to overlay its flat cluster-internal network with network segments defined by users through the Kubernetes API.&#13;
This is the next step in the evolution of network user interfaces.&#13;
It shifts the responsibility to developers who understand the security requirements of their applications.&#13;
This shift-left approach is beneficial in a world of microservices with many distributed dependencies and a complex network of connections.&#13;
NetworkPolicies for L3/L4 network segmentation and AuthenticationPolicies for more granular control of network boundaries are essential for implementing this <em>Network Segmentation</em> pattern.</p>&#13;
&#13;
<p>With the advent of eBPF-based platforms on top of Kubernetes, there is additional support for finding suitable network models. Cilium is an example of a platform that combines L3/L4 and L7 firewalling into a single API, making it easier to implement the pattern described in this chapter in future versions of Kubernetes.<a data-primary="" data-startref="netseg24" data-type="indexterm" id="idm45902086900416"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902086899184">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/gwU-y">Network Segmentation Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/P5r0X">Network Policies</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/qR0O9">The Kubernetes Network Model</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/NhrWK">Kubernetes Network Policy Recipes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/BzlSd">Using Network Policies</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/r-dn7">Why You Should Test Your Kubernetes Network Policies</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/_5cWc">Using the eBPF Superpowers to Generate Kubernetes Security Policies</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/5VbP4">Using Advise Network-Policy</a> with Inspektor Gadget</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/-jKvO">You and Your Security Profiles; Generating Security Policies with the Help of eBPF</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/r-4pI">kube-iptables-tailer</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/9lqlu">Creating Policies from Verdicts</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/69M7s">Istio: Authorization Policy</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/bLq35">Istio: Authentication Policies</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/X00FG">SIG Multitenancy Working Group</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45902087907696"><sup><a href="ch24.html#idm45902087907696-marker">1</a></sup> Level 3 and Level 4 of the OSI Network stack are mostly about IP and TCP/UDP, respectively.</p><p data-type="footnote" id="idm45902087228288"><sup><a href="ch24.html#idm45902087228288-marker">2</a></sup> eBPF was originally an<a data-primary="extended Berkeley Packet Filter (eBF)" data-type="indexterm" id="idm45902087227728"/><a data-primary="eBPF (extended Berkeley Packet Filter)" data-type="indexterm" id="idm45902087227024"/> acronym for “extended Berkeley Packet Filter” but is nowadays used as an independent term on its own.</p></div></div></section></body></html>