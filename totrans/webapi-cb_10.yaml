- en: Chapter 10\. Working with Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading and writing files are part of many applications. In the past, you couldn’t
    really work with local files within the browser. To read data, you’d upload a
    file to a backend server, which would process it and return data to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: To write data, the server would send a downloadable file. Without browser plug-ins,
    there wasn’t a way to work directly with files.
  prefs: []
  type: TYPE_NORMAL
- en: Today, browsers have first-class support for reading and writing files. The
    `file` input type opens a file chooser and provides data about the selected file.
    You can also limit the supported files to specific extensions or MIME types. From
    there, the File API can read the contents of the file into memory.
  prefs: []
  type: TYPE_NORMAL
- en: Taking it a step further, the File System API enables your JavaScript code to
    interact directly with the local filesystem, without needing a file input to select
    a file first (though, depending on settings, the user may need to grant permission!).
  prefs: []
  type: TYPE_NORMAL
- en: You can use these APIs to create text editors, image viewers, audio or video
    players, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Text from a File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to load some text data from the user’s local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use an `<input type="file">` to select the file (see [Example 10-1](#example10-1)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-1\. A file input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you click on the file input, the browser will show a dialog where you can
    browse files and folders on the local system. The exact dialog shown will depend
    on the browser and operating system version. Navigate to, and select, the desired
    file. One you have a selected file, use a `FileReader` as shown in [Example 10-2](#code_loadPlainText)
    to read the file’s text content.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-2\. Loading plain text from a file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `FileReader` is an object that reads files asynchronously. It can read a file’s
    content in several different ways, depending on the type of file. [Example 10-2](#code_loadPlainText)
    uses the `readAsText` method, which retrieves the file content as plain text.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a binary file, such as a ZIP archive or image, you can use `readAsBinaryString`.
    An image can be read as a data URL with Base64-encoded image data using `readAsDataURL`,
    which you’ll see in [“Loading an Image as a Data URL”](#recipe_loadImage).
  prefs: []
  type: TYPE_NORMAL
- en: This API is event based, so the `readFileContent` function takes a callback
    function that is called with the content when it’s ready.
  prefs: []
  type: TYPE_NORMAL
- en: You could also wrap this with a `Promise` to make a `Promise`-based API, as
    shown in [Example 10-3](#example10-3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-3\. Promisified `readFileContent` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you have the text content, you can add it to the page in several ways.
    You could set it as the `textContent` of a DOM node, or you could even load it
    into a `textarea` to make the content editable.
  prefs: []
  type: TYPE_NORMAL
- en: Loading an Image as a Data URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to let the user select a local image file, then display that image
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `readAsDataURL` method of `FileReader` to get a Base64-encoded data
    URL, then set that as the `src` attribute of an `img` tag (see Examples [10-4](#example10-4)
    and [10-5](#example10-5)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-4\. File input and image placeholder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_files_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Restricts the file chooser to only allow images to be selected. A wildcard pattern
    is used here, but you can also specify an exact MIME type such as `image/png`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-5\. Loading an image into the page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A data URL has the `data` URL scheme. It specifies the data’s MIME type, then
    the image data is included in Base64-encoded format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When the `FileReader` returns the image encoded as a data URL, the data URL
    is set as the image element’s `src` attribute. This renders the image in the page.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that this is all being done locally in the user’s browser.
    Nothing is being uploaded to a remote server, as the File API works on the local
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Uploading a File with the Fetch API”](ch04.html#recipe_uploadFetch) in [Chapter 4](ch04.html#ch_network)
    shows an example of using an `<input type="file">` to upload file data to a remote
    server, though this uses the FormData API instead of the File API.'
  prefs: []
  type: TYPE_NORMAL
- en: For more details about data URLs and Base64 encoding, see [this article from
    MDN](https://oreil.ly/kMtDy).
  prefs: []
  type: TYPE_NORMAL
- en: Loading a Video as an Object URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want the user to select a video file, then play it in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an object URL for the `File` object, and set it as the `src` attribute
    of a `<video>` element.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll need a `<video>` element and an `<input type="file">` to select
    the video file (see [Example 10-6](#example10-6)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-6\. The video player markup
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_files_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Only allows the selection of video files
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_files_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Tells the browser to include playback controls
  prefs: []
  type: TYPE_NORMAL
- en: Next, listen for the file input’s `change` event and create an object URL, as
    shown in [Example 10-7](#example10-7).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-7\. Playing the video file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object URL is a special URL that refers to the file content. You can do this
    without a `FileReader`, since the file itself has a `createObjectURL` method.
    This URL can be passed to the `<video>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Loading an Image with Drag and Drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to be able to drag an image file into the browser window and display
    that image on the page when it is dropped.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define an element to serve as the drop area, and a placeholder image element
    (see [Example 10-8](#example10-8)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-8\. The drop target and image elements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that this example still includes a file `input`. This is so that those
    using assistive technologies can also upload an image without having to attempt
    a drag and drop operation. Because the drop target is a label, containing the
    file input, you can click anywhere inside the drop target to open the file chooser.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a function that receives the image file and reads it as a data
    URL (see [Example 10-9](#example10-9)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-9\. Reading the dropped file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, create handler functions for the `dragover` and `drop` events. These events
    are attached to the drop target element (see [Example 10-10](#example10-10)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-10\. Adding the drag and drop code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, make sure to wire up the fallback file input. You just need to get
    the selected file, then pass it to the `showDroppedFile` method to provide the
    same result (see [Example 10-11](#example10-11)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-11\. Handling the file input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, when you drag an image into a page, the browser navigates away from
    the current page. The URL changes to the path of the file, and the image is shown
    in the browser window. In this example, you instead want to load the image data
    into an `<img>` element and stay on the current page.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the default behavior, the drop handler calls `preventDefault` on
    the drop event. To fully prevent the behavior, you also need to call `preventDefault`
    on the `dragover` event, which is why you need the second event listener. This
    makes it so that the element can actually receive `drop` events.
  prefs: []
  type: TYPE_NORMAL
- en: Checking and Requesting Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check—and request if necessary—permissions to access a file on the
    local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Show a file picker, and when a file is selected, call `queryPermission` to check
    for existing permission. If the permission check returns `prompt`, call `requestPermission`
    to show a permission request (see [Example 10-12](#example10-12)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-12\. Selecting and checking permissions for a file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This API may not be supported by all browsers yet. See [CanIUse](https://oreil.ly/AfNpL)
    for the latest compatibility data.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `queryPermission` function returns either `granted` (the permission was
    previously granted), `denied` (access is denied), or `prompt` (need to ask for
    permission).
  prefs: []
  type: TYPE_NORMAL
- en: The requested mode is `readwrite`, which means the browser is able to write
    to your local filesystem if you grant the permission. This is why the permission
    check is important from a security and privacy perspective.
  prefs: []
  type: TYPE_NORMAL
- en: '`queryPermission` checks the permission only and does not show a prompt. If
    this comes back as `prompt`, you can then call `requestPermission`, which shows
    a permission request in the browser. The file is considered writable if either
    call returns `granted`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting API Data to a File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are requesting JSON data from an API, and you want to give the user an option
    to download the raw JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let the user select an output file, then write the JSON data to the local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This API may not be supported by all browsers yet. See [CanIUse](https://oreil.ly/tsT_j)
    for the latest compatibility data.
  prefs: []
  type: TYPE_NORMAL
- en: First, define a helper function that shows the file picker and returns the file
    that was selected (see [Example 10-13](#example10-13)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-13\. Selecting an output file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, define a function that uses this helper, and perform the actual export
    (see [Example 10-14](#example10-14)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-14\. Exporting data to a local file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a good approach for allowing a user to back up or export their data
    from your app. Some regulations, like the General Data Protection Regulation (GDPR)
    in the European Union, require you to make a user’s data available for download.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, text data is being written to the stream, which is of type `FileSystem`
    `WritableFileStream`. These streams also support writing `ArrayBuffer`, `TypedArray`,
    `DataView`, and `Blob` objects.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create the text to write to the file, `exportData` is calling `JSON.stringify`
    with some extra arguments. The second `null` argument is the `replacer` function,
    which you saw in [Chapter 2](ch02.html#ch_webStorage). This argument has to be
    provided in order to provide the third argument, which specifies the amount of
    indentation whitespace to apply. This creates a more readable output format.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, this API is still considered experimental. You should
    avoid using it in a production application until it has better browser support.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting API Data with a Download Link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to provide export functionality but don’t want to worry about filesystem
    permissions, like in [“Exporting API Data to a File”](#recipe_fileExport).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Put the API data into a `Blob` object, and create an object URL to set as a
    link’s `href` attribute. Then you can export the data with a normal browser file
    download, without needing filesystem permissions.
  prefs: []
  type: TYPE_NORMAL
- en: First, add a placeholder link to the page, which becomes the export link (see
    [Example 10-15](#example10-15)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-15\. The placeholder export link
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_files_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `download` attribute provides a default filename to use when downloading.
  prefs: []
  type: TYPE_NORMAL
- en: After you fetch the data from the API and render it in the UI, create the `Blob`
    and object URL (see [Example 10-16](#example10-16)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-16\. Preparing the export link
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method of exporting requires no special permission. When the link is clicked,
    and it has the object URL set, it downloads the `Blob`’s contents as a file, using
    the suggested filename of *users.json*.
  prefs: []
  type: TYPE_NORMAL
- en: A `Blob` is a special object that holds some piece data. Usually this is binary
    data like a file or image, but you can also create a `Blob` with string content,
    which is what this recipe does.
  prefs: []
  type: TYPE_NORMAL
- en: The `Blob` resides in memory, and the created object URL links to it. Once the
    object URL is set in the link element, it becomes an export download link. When
    the link is clicked, the object URL returns the raw string data. Since the link
    has a `download` attribute, it is downloaded to a local file.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent memory leaks, clean up the old URL by calling `URL.revokeObjectURL`
    and passing the object URL as its argument. You can do this once you no longer
    need the object URL—for example, after the user downloads the file or before leaving
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a File with Drag and Drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to allow the user to drag and drop a file, such as an image, then upload
    that file to a remote service.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pass the received `File` object to the Fetch API in the handle for the `drop`
    event (see [Example 10-17](#example10-17)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-17\. Uploading a dropped file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you call `getAsFile` on the data transfer object, you get a `File` object.
    `File` extends from `Blob`, so you can use the Fetch API to send the file (`Blob`)
    contents to a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: This example checks the MIME type of the uploaded file and will only upload
    it if it is an image file.
  prefs: []
  type: TYPE_NORMAL
