- en: Chapter 18\. Resource Requirements, Limits, and Quotas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Workload executed in Pods will consume a certain amount of resources (e.g.,
    CPU and memory). You should define resource requirements for those applications.
    On a container level, you can define a minimum amount of resources needed to run
    the application, as well as the maximum amount of resources the application is
    allowed to consume. Application developers should determine the right-sizing with
    load tests or at runtime by monitoring the resource consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kubernetes measures CPU resources in millicores and memory resources in bytes.
    That’s why you might see resources defined as 600m or 100Mi. For a deep dive on
    those resource units, it’s worth cross-referencing the section [“Resource units
    in Kubernetes”](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes)
    in the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes  administrators  can  put  measures  in  place  to  enforce  the
     use  of  available resource capacity. We’ll discuss two Kubernetes primitives
    in this realm, the ResourceQuota and the LimitRange. The ResourceQuota defines
    aggregate resource constraints on a namespace level. A LimitRange is a policy
    that constrains or defaults the resource allocations for a single object of a
    specific type (such as for a Pod or a PersistentVolumeClaim).
  prefs: []
  type: TYPE_NORMAL
- en: Working with Resource Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s recommended practice that you specify resource requests and limits for
    every container. Determining those resource expectations is not always easy, specifically
    for applications that haven’t been exercised in a production environment yet.
    Load testing the application early during the development cycle can help with
    analyzing the resource needs. Further adjustments can be made by monitoring the
    application’s resource consumption after deploying it to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Container Resource Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One metric that comes into play for workload scheduling is the *resource request*
    defined by the containers in a Pod. Commonly used resources that can be specified
    are CPU and memory. The scheduler ensures that the node’s resource capacity can
    fulfill the resource requirements of the Pod. More specifically, the scheduler
    determines the sum of resource requests per resource type across all containers
    defined in the Pod and compares them with the node’s available resources.
  prefs: []
  type: TYPE_NORMAL
- en: Each container in a Pod can define its own resource requests. [Table 18-1](#options_resource_requests)
    describes the available options including an example value.
  prefs: []
  type: TYPE_NORMAL
- en: Table 18-1\. Options for resource requests
  prefs: []
  type: TYPE_NORMAL
- en: '| YAML attribute | Description | Example value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.cpu` | CPU resource type | `500m` (five
    hundred millicpu) |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  prefs: []
  type: TYPE_TB
- en: To clarify the uses of these resource requests, we’ll look at an example definition.
    The Pod YAML manifest shown in [Example 18-1](#setting_container_resource_requests)
    defines two containers, each with its own resource requests. Any node that is
    allowed to run the Pod needs to be able to support a minimum memory capacity of
    320Mi and 1250m CPU, the sum of resources across both containers.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-1\. Setting container resource requests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It’s certainly possible that a Pod cannot be scheduled due to insufficient resources
    available on the nodes. In those cases, the event log of the Pod will indicate
    this situation with the reasons `PodExceedsFreeCPU` or `PodExceedsFreeMemory`.
    For more information on how to troubleshoot and resolve this situation, see the
    relevant [section in the documentation](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#troubleshooting).
  prefs: []
  type: TYPE_NORMAL
- en: Defining Container Resource Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another metric you can set for a container is the *resource limits*. Resource
    limits ensure that the container cannot consume more than the allotted resource
    amounts. For example, you could express that the application running in the container
    should be constrained to 1000m of CPU and 512Mi of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the container runtime used by the cluster, exceeding any of the
    allowed resource limits results in a termination of the application process running
    in the container or results in the system preventing the allocation of resources
    beyond the limits. For an in-depth discussion on how resource limits are treated
    by the container runtime Docker Engine, see the [documentation](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#how-pods-with-resource-limits-are-run).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 18-2](#options_resource_limits) describes the available options including
    an example value.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 18-2\. Options for resource limits
  prefs: []
  type: TYPE_NORMAL
- en: '| YAML attribute | Description | Example value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.cpu` | CPU resource type | `500m` (500
    millicpu) |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  prefs: []
  type: TYPE_TB
- en: '[Example 18-2](#setting_container_resource_limits) shows the definition of
    limits in action. Here, the container named `business-app` cannot use more than
    512Mi of memory. The container named `ambassador` defines a limit of 128Mi of
    memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-2\. Setting container resource limits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Defining Container Resource Requests and Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To provide Kubernetes with the full picture of your application’s resource expectations,
    you must specify resource requests and limits for every container. [Example 18-3](#settings_container_resource_requests_limits)
    combines resource requests and limits in a single YAML manifest.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-3\. Setting container resource requests and limits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning static container resource requirements is an approximation process.
    You want maximizing an efficient utilization of resources in your Kubernetes cluster.
    Unfortunately, the Kubernetes documentation does not offer a lot of guidance on
    best practices. The blog post [“For the Love of God, Stop Using CPU Limits on
    Kubernetes”](https://home.robusta.dev/blog/stop-using-cpu-limits) provides the
    following guidance:'
  prefs: []
  type: TYPE_NORMAL
- en: Always define memory requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always define memory limits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always set your memory requests equal to your limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always define CPU requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use CPU limits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After launching your application to production, you still need to monitor your
    application resource consumption patterns. Review resource consumption at runtime
    and keep track of actual scheduling behavior and potential undesired behaviors
    once the application receives load. Finding a happy medium can be frustrating.
    Projects like [Goldilocks](https://www.fairwinds.com/blog/introducing-goldilocks-a-tool-for-recommending-resource-requests)
    and [KRR](https://github.com/robusta-dev/krr) emerged to provide recommendations
    and guidance on appropriately determining resource requests. Other options, like
    the [container resize policies](https://kubernetes.io/docs/tasks/configure-pod-container/resize-container-resources/#container-resize-policies)
    introduced in Kubernetes 1.27, allow for more fine-grained control over how containers’
    CPU and memory resources are resized automatically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Resource Quotas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Kubernetes primitive ResourceQuota establishes the usable, maximum amount
    of resources per namespace. Once put in place, the Kubernetes scheduler will take
    care of enforcing those rules. The following list should give you an idea of the
    rules that can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting an upper limit for the number of objects that can be created for a specific
    type (e.g., a maximum of three Pods).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the total sum of compute resources (e.g., 3Gi of RAM).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expecting a Quality of Service (QoS) class for a Pod (e.g., `BestEffort` to
    indicate that the Pod must not make any memory or CPU limits or requests).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ResourceQuotas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a ResourceQuota object is usually a task that a Kubernetes administrator
    would take on, but it’s relatively easy to define and create such an object. First,
    create the namespace the quota should apply to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, define the ResourceQuota in YAML. To demonstrate the functionality of
    a ResourceQuota, add constraints to the namespace, as shown in [Example 18-4](#resource_quota).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-4\. Defining hard resource limits with a ResourceQuota
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_resource_requirements__limits__and_quotas_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Limit the number of Pods to 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_resource_requirements__limits__and_quotas_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the minimum resources requested across all Pods in a non-terminal state
    to 1 CPU and 1024Mi of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_resource_requirements__limits__and_quotas_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the maximum resources used by all Pods in a non-terminal state to 4 CPUs
    and 4096Mi of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re ready to create a ResourceQuota for the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Rendering ResourceQuota Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can render a table overview of used resources vs. hard limits using the
    `kubectl describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Hard column lists the same values you provided with the ResourceQuota definition.
    Those values won’t change also long as you don’t modify the object’s specification.
    Under the Used column, you can find the actual aggregate resource consumption
    within the namespace. At this time, all values are 0 given that no Pods have been
    created yet.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a ResourceQuota’s Runtime Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the quota rules in place for the namespace `team-awesome`, we’ll want to
    see its enforcement in action. We’ll start by creating more than the maximum number
    of Pods, which is two. To test this, we can create Pods with any definition we
    like. For example, we use a bare-bones definition that runs the image `nginx:1.25.3`
    in the container, as shown in [Example 18-5](#pod_without_resource_requirements).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-5\. A Pod without resource requirements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From that YAML definition stored in *nginx-pod.yaml*, let’s create a Pod and
    see what happens. In fact, Kubernetes will reject the creation of the object with
    the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because we defined minimum and maximum resource quotas for objects in the namespace,
    we have to ensure that Pod objects actually define resource requests and limits.
    Modify the initial definition by updating the instruction under `resources`, as
    shown in [Example 18-6](#pod_with_resource_requirements).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-6\. A Pod with resource requirements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be able to create two uniquely named Pods—`nginx1` and `nginx2`—with
    that manifest; the combined resource requirements still fit with the boundaries
    defined in the ResourceQuota:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be able to imagine what would happen if we tried to create another
    Pod with the definition of `nginx1` and `nginx2`. It will fail for two reasons.
    The first reason is that we’re not allowed to create a third Pod in the namespace,
    as the maximum number is set to two. The second reason is that we’d exceed the
    allotted maximum for `requests.cpu` and `requests.memory`. The following error
    message provides us with this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Working with Limit Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how a resource quota can restrict the consumption
    of resources within a specific namespace in aggregate. For individual Pod objects,
    the resource quota cannot set any constraints. That’s where the limit range comes
    in. The enforcement of LimitRange rules happens during the [admission control
    phase](ch17.xhtml#admission_control_phase) when processing an API request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The LimitRange is a Kubernetes primitive that constrains or defaults the resource
    allocations for specific object types:'
  prefs: []
  type: TYPE_NORMAL
- en: Enforces minimum and maximum compute resources usage per Pod or container in
    a namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforces minimum and maximum storage request per PersistentVolumeClaim in a
    namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforces a ratio between request and limit for a resource in a namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets default requests/limits for compute resources in a namespace and automatically
    injects them into containers at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining more than one LimitRange in a namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is best to create only a single LimitRange object per namespace. Default
    resource requests and limits specified by multiple LimitRange objects in the same
    namespace causes non-deterministic selection of those rules. Only one of the default
    definitions will win, but you can’t predict which one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating LimitRanges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LimitRange offers a list of configurable constraint attributes. All are
    described in great detail in the Kubernetes API documentation for a [LimitRangeSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#limitrangeitem-v1-core).
    [Example 18-7](#limit_range) shows a YAML manifest for a LimitRange that uses
    some of the constraint attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-7\. A limit range defining multiple constraint criteria
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_resource_requirements__limits__and_quotas_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The context to apply the constraints to. In this case, to a container running
    in a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_resource_requirements__limits__and_quotas_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The default CPU resource request value assigned to a container if not provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_resource_requirements__limits__and_quotas_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The default CPU resource limit value assigned to a container if not provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_resource_requirements__limits__and_quotas_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum and maximum CPU resource request and limit value assignable to a
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we can create an object from the manifest with the `kubectl create`
    or `kubectl apply` command. The definition of the LimitRange has been stored in
    the file *cpu-resource-constraint-limitrange.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The constraints will be applied automatically when creating new objects. Changing
    the constraints for an existing LimitRange object won’t have any effect on already
    running Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering LimitRange Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Live LimitRange objects can be inspected using the `kubectl describe` command.
    The following command renders the details of the LimitRange object named `cpu-resource-constraint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output of the command renders each limit constraint on a single line. Any
    constraint attribute that has not been set explicitly by the object will show
    a dash character (`-`) as the assigned value.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a LimitRange’s Runtime Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s demonstrate what effect the LimitRange has on the creation of Pods. We
    will walk through two different use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically setting resource requirements if they have not been provided by
    the Pod definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preventing the creation of a Pod if the declared resource requirements are forbidden
    by the LimitRange.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting default resource requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LimitRange defines a default CPU resource request of 200m and a default
    CPU resource limit of 200m. That means if a Pod is about to be created, and it
    doesn’t define a CPU resource request and limit, the LimitRange will automatically
    assign the default values.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 18-8](#pod_no_resource_requirements) shows a Pod definition without
    resource requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-8\. A Pod defining no resource requirements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the object from the contents stored in the file *nginx-without-resource-requirements.yaml*
    will work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The Pod object will be mutated in two ways. First, the default resource requirements
    set by the LimitRange are applied. Second, an annotation with the key `kubernetes.io/limit-ranger`
    will be added that provides meta information on what has been changed. You can
    find both pieces of information in the output of the `describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Enforcing resource requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LimitRange can enforce resource limits as well. For the LimitRange object
    we created earlier, the minimum amount of CPU was set to 100m, and the maximum
    amount of CPU was set to 2\. To see the enforcement behavior in action, we’ll
    create a new Pod as shown in [Example 18-9](#pod_with_resource_requirements2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-9\. A Pod defining CPU resource requests and limits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The resource requirements of this Pod do not follow the constraints expected
    by the LimitRange object. The CPU resource request is less than 100m, and the
    CPU resource limit is higher than 2\. As a result, the object won’t be created
    and an appropriate error message will be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The error message provides some guidance on expected resource definitions. Unfortunately,
    the message doesn’t point to the name of the LimitRange object enforcing those
    expectations. Proactively check if a LimitRange object has been created for the
    namespace and what parameters have been set using `kubectl get limitranges`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resource requests are one of the many factors that the kube-scheduler algorithm
    considers when making decisions on which node a Pod can be scheduled. A container
    can specify requests using `spec.containers[].resources.requests`. The scheduler
    chooses a node based on its available hardware capacity. The resource limits ensure
    that the container cannot consume more than the allotted resource amounts. Limits
    can be defined for a container using the attribute `spec.con⁠tainers[].resources.limits`.
    Should an application consume more than the allowed amount of resources (e.g.,
    due to a memory leak in the implementation), the container runtime will likely
    terminate the application process.
  prefs: []
  type: TYPE_NORMAL
- en: A resource quota defines the computing resources (e.g., CPU, RAM, and ephemeral
    storage) available to a namespace to prevent unbounded consumption by Pods running
    it. Accordingly, Pods have to work within those resource boundaries by declaring
    their minimum and maximum resource expectations. You can also limit the number
    of resource types (like Pods, Secrets, or ConfigMaps) that are allowed to be created.
    The Kubernetes scheduler will enforce those boundaries upon a request for object
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: The limit range is different from the ResourceQuota in that it defines resource
    constraints for a single object of a specific type. It can also help with governance
    for objects by specifying resource default values that should be applied automatically
    should the API create request not provide the information.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Experience the effects of resource requirements on scheduling and autoscaling
  prefs: []
  type: TYPE_NORMAL
- en: A container defined by a Pod can specify resource requests and limits. Work
    through scenarios where you define those requirements individually and together
    for single- and multi-container Pods. Upon creation of the Pod, you should be
    able to see the effects on scheduling the object on a node. Furthermore, practice
    how to identify the available resource capacity of a node.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the purpose and runtime effects of resource quotas
  prefs: []
  type: TYPE_NORMAL
- en: A ResourceQuota defines the resource boundaries for objects living within a
    namespace. The most commonly used boundaries apply to computing resources. Practice
    defining them and understand their effect on the creation of Pods. It’s important
    to know the command for listing the hard requirements of a ResourceQuota and the
    resources currently in use. You will find that a ResourceQuota offers other options.
    Discover them in more detail for a broader exposure to the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the purpose and runtime effects of limit ranges
  prefs: []
  type: TYPE_NORMAL
- en: A LimitRange can specify resource constraints and defaults of specific primitives.
    Should you run into a situation where you receive an error message upon creation
    of an object, check if a limit range object enforces those constraints. Unfortunately,
    the error message does not point out the object that enforces it so you may have
    to proactively list LimitRange objects to identify the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_014.xhtml#appendix_a_resource_requirements_limits_quotas).
  prefs: []
  type: TYPE_NORMAL
- en: You have been tasked with creating a Pod for running an application in a container.
    During application development, you ran a load test for figuring out the minimum
    amount of resources needed and the maximum amount of resources the application
    is allowed to grow to. Define those resource requests and limits for the Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a Pod named `hello-world` running the container image `bmuschko/nodejs-hello-world:1.0.0`.
    The container exposes the port 3000.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a Volume of type `emptyDir` and mount it in the container path `/var/log`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the container, specify the following minimum number of resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'CPU: 100m'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory: 500Mi'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ephemeral storage: 1Gi'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the container, specify the following maximum number of resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Memory: 500Mi'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ephemeral storage: 2Gi'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the Pod from the YAML manifest. Inspect the Pod details. Which node does
    the Pod run on?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, you will create a resource quota with specific CPU and memory
    limits for a new namespace. Pods created in the namespace will have to adhere
    to those limits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a ResourceQuota named `app` under the namespace `rq-demo` using the
    following YAML definition in the file *resourcequota.yaml*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new Pod that exceeds the limits of the resource quota requirements,
    e.g., by defining 1Gi of memory but stays below the CPU, e.g., 0.5\. Write down
    the error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the request limits to fulfill the requirements to ensure that the Pod
    can be created successfully. Write down the output of the command that renders
    the used amount of resources for the namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A LimitRange can restrict resource consumption for Pods in a namespace, and
    assign default computing resources if no resource requirements have been defined.
    You will practice the effects of a LimitRange on the creation of a Pod in different
    scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch18/limitrange* of the checked-out GitHub
    repository [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide).
    Inspect the YAML manifest definition in the file *setup.yaml*. Create the objects
    from the YAML manifest file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new Pod named `pod-without-resource-requirements` in the namespace
    `d92` that uses the container image `nginx:1.23.4-alpine` without any resource
    requirements. Inspect the Pod details. What resource definitions do you expect
    to be assigned?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new Pod named `pod-with-more-cpu-resource-requirements` in the namespace
    `d92` that uses the container image `nginx:1.23.4-alpine` with a CPU resource
    request of 400m and limits of 1.5\. What runtime behavior do you expect to see?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new Pod named `pod-with-less-cpu-resource-requirements` in the namespace
    `d92` that uses the container image `nginx:1.23.4-alpine` with a CPU resource
    request of 350m and limits of 400m. What runtime behavior do you expect to see?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
