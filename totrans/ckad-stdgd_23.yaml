- en: Chapter 23\. Network Policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The uniqueness of the IP address assigned to a Pod is maintained across all
    nodes and namespaces. This is accomplished by allocating a dedicated subnet to
    each registered node during its creation. The Container Network Interface (CNI)
    plugin handles the leasing of IP addresses from the assigned subnet when a new
    Pod is created on a node. Consequently, Pods on a node can seamlessly communicate
    with all other Pods running on any node within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Network policies in Kubernetes function similarly to firewall rules, specifically
    designed for governing Pod-to-Pod communication. These policies include rules
    specifying the direction of network traffic (ingress and/or egress) for one or
    multiple Pods within a namespace or across different namespaces. Additionally,
    these rules define the targeted ports for communication. This fine-grained control
    enhances security and governs the flow of traffic within the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Network Policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within a Kubernetes cluster, any Pod can talk to any other Pod without restrictions
    using its [IP address or DNS name](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pods),
    even across namespaces. Not only does unrestricted inter-Pod communication pose
    a potential security risk, it also makes it harder to understand the mental communication
    model of your architecture. A network policy defines the rules that control traffic
    from and to a Pod, as illustrated in [Figure 23-1](#network_policies_from_to_pods).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 2301](Images/ckd2_2301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-1\. Network policies define traffic from and to a Pod
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For example, there’s no good reason to allow a backend application running in
    a Pod to talk directly to the frontend application running in another Pod. The
    communication should be directed from the frontend Pod to the backend Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Installing an Network Policy Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A network policy cannot work without a network policy controller. The network
    policy controller evaluates the collection of rules defined by a network policy.
    You can find instructions for a wide range of network policy controllers in the
    [Kubernetes documentation](https://kubernetes.io/docs/tasks/administer-cluster/network-policy-provider/).
  prefs: []
  type: TYPE_NORMAL
- en: '[Cilium](https://cilium.io/) is a CNI that implements a network policy controller.
    You can install Cilium on cloud provider and on-prem Kubernetes clusters. Refer
    to the [installation instructions](https://docs.cilium.io/en/stable/gettingstarted/k8s-install-default/)
    for detailed information. Once it is installed, you should find at least two Pods
    running Cilium and the Cilium Operator in the `kube-system` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can now assume that the rules defined by network policy objects will be
    evaluated. Additionally, you can use the Cilium command line tool to validate
    the proper installation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Network Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Label selection plays a crucial role in defining which Pods a network policy
    applies to. We already saw the concept in action in other contexts (e.g., the
    [Deployment](ch10.xhtml#deployments) and the [Service](ch21.xhtml#services)).
    Furthermore, a network policy defines the direction of the traffic, to allow or
    disallow. In the context of a network policy, incoming traffic is called *ingress*,
    and outgoing traffic is called *egress*. For ingress and egress, you can whitelist
    the sources of traffic like Pods, IP addresses, or ports.
  prefs: []
  type: TYPE_NORMAL
- en: Network policies do not apply to Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, you’d set up Service objects to funnel network traffic to Pods
    based on label and port selection. Network policies do not involve Services at
    all. All rules are namespace- and Pod-specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of network policies is best explained by example. Let’s say you’re
    dealing with the following scenario: you’re running a Pod that exposes an API
    to other consumers. For example, a Pod that processes payments for other applications.
    The company you’re working for is migrating applications from a legacy payment
    processor to a new one. Therefore, you’ll want to allow access only from the applications
    that are capable of properly communicating with it. Right now, you have two consumers—a
    grocery store and a coffee shop—each running their application in a separate Pod.
    The coffee shop is ready to consume the API of the payment processor, but the
    grocery store isn’t. [Figure 23-2](#network_policy_api_allow) shows the Pods and
    their assigned labels.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 2302](Images/ckd2_2302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-2\. Limiting traffic to and from a Pod
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Before creating a network policy, we’ll stand up the Pods to represent the
    scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Given Kubernetes’ default behavior of allowing unrestricted Pod-to-Pod communication,
    the three Pods will be able to talk to one another. The following commands verify
    the behavior. The grocery store and coffee shop Pods perform a `wget` call to
    the payment processor Pod’s IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You cannot create a new network policy with the imperative `create` command.
    Instead, you will have to use the declarative approach. The YAML manifest in [Example 23-1](#network_policy),
    stored in the file *networkpolicy-api-allow.yaml*, shows a network policy for
    the scenario described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-1\. Declaring a NetworkPolicy with YAML
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_network_policies_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Selects the Pod the policy should apply to by label selection.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_network_policies_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows incoming traffic from the Pod with matching labels within the same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: A network policy defines a couple of important attributes, which together form
    its set of rules. [Table 23-1](#network_policy_spec_attributes) shows the attributes
    on the `spec` level.
  prefs: []
  type: TYPE_NORMAL
- en: Table 23-1\. Spec attributes of a network policy
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `podSelector` | Selects the Pods in the namespace to apply the network policy
    to. |'
  prefs: []
  type: TYPE_TB
- en: '| `policyTypes` | Defines the type of traffic (i.e., ingress and/or egress)
    the network policy applies to. |'
  prefs: []
  type: TYPE_TB
- en: '| `ingress` | Lists the rules for incoming traffic. Each rule can define `from`
    and `ports` sections. |'
  prefs: []
  type: TYPE_TB
- en: '| `egress` | Lists the rules for outgoing traffic. Each rule can define `to`
    and `ports` sections. |'
  prefs: []
  type: TYPE_TB
- en: You can specify ingress and egress rules independently using `spec.ingress.from[]`
    and `spec.egress.to[]`. Each rule consists of a Pod selector, an optional namespace
    selector, or a combination of both. [Table 23-2](#network_policy_to_from_selectors)
    lists the relevant attributes for the `to` and `from` selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Table 23-2\. Attributes of a network policy `to` and `from` selectors
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `podSelector` | Selects Pods by label(s) in the same namespace as the network
    policy that should be allowed as ingress sources or egress destinations. |'
  prefs: []
  type: TYPE_TB
- en: '| `namespaceSelector` | Selects namespaces by label(s) for which all Pods should
    be allowed as ingress sources or egress destinations. |'
  prefs: []
  type: TYPE_TB
- en: '| `namespaceSelector` and `podSelector` | Selects Pods by label(s) within namespaces
    by label(s). |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s see the effect of the network policy in action. Create the network policy
    object from the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The network policy prevents calling the payment processor from the grocery
    store Pod. Accessing the payment processor from the coffee shop Pod works perfectly,
    as the network policy’s Pod selector matches the Pod’s assigned label `app=coffee-shop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As a developer, you may be dealing with network policies that have been set
    up for you by other team members or administrators. You need to know about the
    `kubectl` commands for listing and inspecting network policy objects to understand
    their effects on the directional network traffic between microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Network Policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listing network policies works the same as any other Kubernetes primitive.
    Use the `get` command in combination with the resource type `networkpolicy`, or
    its short-form, `netpol`. For the previous network policy, you see a table that
    renders the name and Pod selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It’s unfortunate that the output of the command doesn’t give a lot of information
    about the ingress and egress rules. To retrieve more information, you have to
    dig into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Network Policy Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can inspect the details of a network policy using the `describe` command.
    The output renders all the important information: Pod selector, and ingress and
    egress rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The network policy details don’t draw a clear picture of the Pods that have
    been selected based on its rules. You can create Pods that match the rules and
    do not match the rules to verify the network policy’s desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing network policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining the rules of network policies correctly can be challenging. The page
    [networkpolicy.io](https://networkpolicy.io) provides a visual editor for network
    policies that renders a graphical representation in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, every Pod can talk to other Pods running on any node of
    the cluster, which exposes a potential security risk. An attacker able to gain
    access to a Pod theoretically can try to compromise another Pod by communicating
    with it by its virtual IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Default Network Policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principle of least privilege is a fundamental security concept, and it’s
    highly recommended when it comes to restricting Pod-to-Pod network traffic in
    Kubernetes. The idea is to initially disallow all traffic and then selectively
    open up only the necessary connections based on the application’s architecture
    and communication requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can lock down Pod-to-Pod communication with the help of a [default network
    policy](https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-policies).
    Default network policies are custom policies set up by administrators to enforce
    restrictive communication patterns by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the functionality of such a default network policy, we’ll set
    up two Pods in the namespace `internal-tools`. Within the namespace, all Pods
    will be able to communicate with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s create a default network policy that denies all ingress and egress network
    traffic in the namespace. We’ll store the network policy in the file *networkpolicy-deny-all.yaml*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-2\. Disallowing all traffic with the default policy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_network_policies_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The curly braces for `spec.podSelector` mean “apply to all Pods in the namespace.”
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_network_policies_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the types of traffic the rule should apply to, in this case ingress
    and egress traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the network policy from the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The network policy prevents any network communication between the Pods in the
    `internal-tools` namespace will, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With those default deny constraints in place, you can define more detailed rules
    and loosen restrictions gradually. Network policies are additive. It’s common
    practice to now set up additional network policies that will open up directional
    traffic, but only the ones that are really required.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting Access to Specific Ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Controlling access at the port level is a critical aspect of network security
    in Kubernetes. If not explicitly defined by a network policy, all ports are accessible,
    which can pose security risks. For instance, if you have an application running
    in a Pod that exposes port 80 to the outside world, leaving all other ports open
    widens the attack vector unnecessarily. Port rules can be specified for ingress
    and egress as part of a network policy. The definition of a network policy in
    [Example 23-3](#network_policy_ports) allows access on port 80.
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-3\. Definition of a network policy allowing ingress access on port
    8080
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_network_policies_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Only allows incoming traffic on port 80.
  prefs: []
  type: TYPE_NORMAL
- en: When defining network policies, only allow those ports that are required for
    implementing your architectural needs. All other ports should be locked down.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intra-Pod communication or communication between two containers of the same
    Pod is completely unrestricted in Kubernetes. Network policies instate rules to
    control the network traffic either from or to a Pod. You can think of network
    policies as firewall rules for Pods. It’s best practice to start with a “deny
    all traffic” rule to minimize the attack vector.
  prefs: []
  type: TYPE_NORMAL
- en: From there, you can open access as needed. Learning about the intricacies of
    network policies requires a bit of hands-on practice, as it is not directly apparent
    if the rules work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand the purpose and effects of network policies
  prefs: []
  type: TYPE_NORMAL
- en: By default, Pod-to-Pod communication is unrestricted. Instantiate a default
    deny rule to restrict Pod-to-Pod network traffic with the principle of least privilege.
    The attribute `spec.podSelector` of a network policy selects the target Pod the
    rules apply to based on label selection. The ingress and egress rules define Pods,
    namespaces, IP addresses, and ports for allowing incoming and outgoing traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to implement the principle of least privilege
  prefs: []
  type: TYPE_NORMAL
- en: Network policies can be aggregated. A default deny rule can disallow ingress
    and/or egress traffic. An additional network policy can open up those rules with
    a more fine-grained definition.
  prefs: []
  type: TYPE_NORMAL
- en: Explore common network policy scenarios
  prefs: []
  type: TYPE_NORMAL
- en: To explore common scenarios, look at the GitHub repository named [“Kubernetes
    Network Policy Recipes”](https://github.com/ahmetb/kubernetes-network-policy-recipes).
    The repository comes with a visual representation for each scenario and walks
    you through the steps to set up the network policy and the involved Pods. This
    is a great practice resource.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_019.xhtml#appendix_a_network_policies).
  prefs: []
  type: TYPE_NORMAL
- en: You have been tasked with setting up a network policy for an existing application
    stack that consists of a `frontend` Pod in the namespace `end-user` and a `backend`
    Pod in the namespace `internal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch23/app-stack* of the checked-out GitHub repository
    [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide). Create
    the objects from the YAML manifest *setup.yaml*. Inspect the objects in both namespaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a network policy named `app-stack` in the `end-user` namespace. Allow
    egress traffic only from the `frontend` Pod to the `backend` Pod. The `backend`
    Pod should be reachable only on port 80.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch23/troubleshooting* of the checked-out GitHub
    repository [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide).
    Create the objects from the YAML manifest *setup.yaml*. Inspect the objects in
    the namespace `k1` and `k2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the virtual IP address of Pod `nginx` in namespace `k2.` Try to make
    a wget call on port 80 from the Pod `busybox` in namespace `k1` to the Pod `nginx`
    in namespace `k2`. The call will fail with the current setup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a network policy that allows performing ingress calls for all Pods in
    namespace `k1` to the Pod `nginx` in namespace `k2`. Pods in all other namespaces
    should be denied to make ingress calls to Pods in namespace `k2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify that a network connection can be established.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
