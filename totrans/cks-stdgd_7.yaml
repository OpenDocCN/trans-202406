- en: Chapter 7\. Monitoring, Logging, and Runtime Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last domain of the curriculum primarily deals with detecting suspicious
    activity on the host and container level in a Kubernetes cluster. We’ll first
    define the term *behavior analytics* and how it applies to the realm of Kubernetes.
    With the theory out of the way, we’ll bring in the tool called Falco that can
    detect intrusion scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Once a container has been started, its runtime environment can still be modified.
    For example, as an operator you could decide to shell into the container in order
    to manually install additional tools or write files to the container’s temporary
    filesystem. Modifying a container after it has been started can open doors to
    security risks. You will want to aim for creating *immutable containers*, containers
    that cannot be modified after they have been started. We’ll learn how to configure
    a Pod with the right settings to make its containers immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Last, we’ll talk about capturing logs for events that occur in a Kubernetes
    cluster. Those logs can be used for troubleshooting purposes on the cluster level,
    to reconstruct when and how the cluster configuration was changed such that it
    led to an undesired or broken runtime behavior. Log entries can also be used to
    trace an attack that may be happening right now as a means to enacting countermeasures.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing behavior analytics to detect malicious activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing deep analytical investigation and identification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring immutability of containers at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using audit logs to monitor access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing Behavior Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from managing and upgrading a Kubernetes cluster, the administrator is
    in charge of keeping an eye on potentially malicious activity. While you can perform
    this task manually by logging into cluster nodes and observing host- and container-level
    processes, it is a horribly inefficient undertaking.
  prefs: []
  type: TYPE_NORMAL
- en: '*Behavior analytics* is the process of observing the cluster nodes for any
    activity that seems out of the ordinary. An automated process helps with filtering,
    recording, and alerting events of specific interest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: A Kubernetes Administrator Can Observe Actions Taken by an Attacker'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attacker gained access to a container by opening a shell running on a worker
    node to launch additional attacks throughout the Kubernetes cluster. An administrator
    can’t easily detect this event by manually checking each and every container.
    [Figure 7-1](#behavioral-analytics-attacker) illustrates the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0701](assets/ckss_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Malicious events recorded by behavior analytics tool
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The administrator decided to take matters in their own hands by installing a
    behavior analytics tool. The tool will continuously monitor certain events and
    record them almost instantaneously. The administrator now has an efficient mechanism
    for detecting intrusions and can act upon them.
  prefs: []
  type: TYPE_NORMAL
- en: Among the behavior analytics tools relevant to the exam are [Falco](https://falco.org),
    [Tracee](https://oreil.ly/ibXcO), and [Tetragon](https://oreil.ly/q15oU). In this
    book, we’ll only focus on Falco, as it is listed among the links of documentation
    pages available during the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Falco
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Falco helps with detecting threats by observing host- and container-level activity.
    Here are a few examples of events Falco could watch for:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading or writing files at specific locations in the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a shell binary for a container, such as `/bin/bash` to open a bash shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An attempt to make a network call to undesired URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Falco deploys a set of sensors that listen for the configured events and conditions.
    Each sensor consists of a set of rules that map an event to a data source. An
    alert is produced when a rule matches a specific event. Alerts will be sent to
    an output channel to record the event, such as standard output, a file, or an
    HTTPS endpoint. Falco allows for enabling more than one output channel simultaneously.
    [Figure 7-2](#falco-high-level-architecture) shows Falco’s high-level architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0702](assets/ckss_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Falco’s high-level architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Falco is a tool with a lot of features and configuration options. We won’t be
    able to discuss all features in this book, but I would suggest you spend some
    time on understanding Falco’s high-level concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Another great learning resource on Falco can be found on the Sysdig training
    portal webpage. [“Falco 101”](https://oreil.ly/PwGWx) is a free video course that
    explains all the bells and whistles of the product. All you need to do to get
    started is sign up for an account. Moreover, I’d suggest giving the book [*Practical
    Cloud Native Security with Falco*](https://oreil.ly/0WHIR) by Loris Degioanni
    and Leonardo Grasso (O’Reilly) a read. The content takes a beginner-friendly approach
    to learning Falco.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Falco
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Falco can be installed as a binary on the host system or as a DaemonSet object
    in Kubernetes. You can safely assume that Falco has been preinstalled for you
    in the exam environment. For more information on the installation process, have
    a look at the [relevant portion](https://oreil.ly/MB6wU) of the Falco documentation.
    The following steps briefly explain the installation of the binary on an Ubuntu
    machine. Falco needs to be installed on all worker nodes of a Kubernetes cluster.
    Be aware that those instructions may change with a future version of Falco.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to trust the Falco GPG key, configure the Falco-specific apt
    repository, and update the package list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You then install the kernel header with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, you need to install the Falco apt package with version 0.33.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Falco has been installed successfully and is running as a systemd service in
    the background. Run the following command to check on the status of the Falco
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Falco service should be in the “active” status. It is already monitoring
    events in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Falco
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Falco service provides an operational environment for monitoring the system
    with a set of default rules. Those rules live in YAML files in the `/etc/falco`
    directory. The list of files and subdirectories in `/etc/falco` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Of those files, I want to describe the high-level purpose of the most important
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Falco configuration file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file named `falco.yaml` is the configuration file for the Falco process.
    It controls the channel that will be notified in case of an alert. A channel could
    be standard output or a file. Furthermore, the file defines the minimum log level
    of alerts to include in logs, and how to configure the embedded web server used
    to implement a health check for the Falco process. Refer to [“Falco Configuration
    Options”](https://oreil.ly/sfHW9) for a full reference on all available options.
  prefs: []
  type: TYPE_NORMAL
- en: Default rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file named `falco_rules.yaml` defines a set of preinstalled rules. Falco
    considers those rules to be applied by default. Among them are checks for creating
    an alert when a shell to a container is opened or when a write operation is performed
    to a system directory. You can find other examples and their corresponding rule
    definitions on the [“Rules Examples” page](https://oreil.ly/fxHQm).
  prefs: []
  type: TYPE_NORMAL
- en: Custom rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file named `falco_rules.local.yaml` lets you define custom rules and override
    default rules. With a fresh installation of Falco, the file only contains commented-out
    rules to provide you with a starting point for adding your own rules. You can
    find [guidance on writing custom rules](https://oreil.ly/mJnPo) in the Falco documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes-specific rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file `k8s_audit_rules.yaml` defines [Kubernetes-specific rules](https://oreil.ly/d5FGD)
    in addition to logging system call events. Typical examples are “log an event
    when a namespace is deleted” or “log an event when a Role or ClusterRole object
    is created.”
  prefs: []
  type: TYPE_NORMAL
- en: Applying configuration changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modifying the contents of configuration files will not automatically propagate
    them to the Falco process. You need to restart the Falco service, as demonstrated
    by the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we’ll trigger some of the events covered by Falco’s default rules.
    Each of those events will create an alert written to the configured channel. The
    initial setup of Falco routes messages to standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Events and Inspecting Falco Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see Falco alerts in action. One of the default rules added by Falco creates
    an alert whenever a user tries to open a shell to a container. We’ll need to perform
    this activity to see a log entry for it. To achieve that, create a new Pod named
    `nginx`, open a bash shell to the container, and then exit out of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Identify the cluster node the Pod runs on by inspecting its runtime details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This Pod is running on the cluster node named `kube-worker-1`. You will need
    to inspect the Falco logs on that machine to find the relevant log entry. You
    can inspect logged events by using the `journalctl` command directly on the `kube-worker-1`
    cluster node. The following command searches for entries that contain the keyword
    `falco`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find that additional rules will kick in if you try to modify the container
    state. Say you’d installed the Git package using `apt` in the `nginx` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Falco added log entries for those system-level operations. The following output
    renders the alerts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll inspect the Falco rules that trigger the creation
    of alerts, and their syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Falco Rule File Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Falco rules file usually consists of three elements defined in YAML: rules,
    macros, and lists. You’ll need to understand those elements on a high level and
    know how to modify them to achieve a certain goal.'
  prefs: []
  type: TYPE_NORMAL
- en: Crafting your own Falco rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the exam, you will likely not have to craft your own Falco rules. You’ll
    be provided with an existing set of rules. If you want to dive deeper into Falco
    rules, have a look at the relevant [documentation page](https://oreil.ly/PD1ro).
  prefs: []
  type: TYPE_NORMAL
- en: Rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *rule* is the condition under which an alert should be generated. It also
    defines the output message of the alert. An output message can consist of a hard-coded
    message and incorporate built-in variables. The alert is recorded on the `WARNING`
    log level. [Example 7-1](#falco-rule-camera) shows the YAML for a rule listening
    to events that try to access the machine’s camera from processes other than your
    traditional video-conferencing software, such as Skype or Webex.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. A Falco rule that monitors camera access
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Macro
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *macro* is a reusable rule condition that helps with avoiding copy-pasting
    similar logic across multiple rules. Macros are useful if the rule file becomes
    lengthy and you want to improve on maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Say you are in the process of simplifying a rules file. You notice that multiple
    rules use the same condition that listens for camera access. [Example 7-2](#falco-macro-camera)
    shows how to break out the logic into a macro.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. A Falco macro defining a reusable condition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The macro can now be referenced by name in a rule definition, as shown in [Example 7-3](#falco-rule-with-macro).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. A Falco rule incorporating a macro
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *list* is a collection of items that you can include in rules, macros, and
    other lists. Think of lists as an array in traditional programming languages.
    [Example 7-4](#falco-list-video-software) creates a list of process names associated
    with video-conferencing software.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4\. A Falco list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 7-5](#falco-macro-with-list) shows the usage of the list by name in
    a macro.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-5\. A Falco macro that uses a list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Dissecting an existing rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason why Falco ships with default rules is to shorten the timespan to
    hit the ground running for a production cluster. Instead of having to come up
    with your own rules and the correct syntax, you can simply install Falco and benefit
    from best practices from the get-go.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s come back to one of the events we triggered in [“Generating Events and
    Inspecting Falco Logs”](#generating-events-inspect-falco-logs). At the time of
    writing, I am using the Falco version 0.33.1\. The rules file `/etc/falco/falco_rules.yaml`
    shipped with it contains a rule named “Terminal shell in container.” It observes
    the event of opening a shell to a container. You can easily find the rule by searching
    for a portion of the log message, e.g., “A shell was spawned in a container.”
    [Example 7-6](#default-open-shell-falco-rule-file) shows the syntax of the rule
    definition, as well as the annotated portions of the YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-6\. A Falco rule that monitors shell activity to a container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_monitoring__logging__and_runtime_security_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines a macro, a condition reusable across multiple rules referenced by name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_monitoring__logging__and_runtime_security_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the name of the rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_monitoring__logging__and_runtime_security_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The aggregated condition composed of multiple macros.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_monitoring__logging__and_runtime_security_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The alerting message should the event happen. The message may use built-in fields
    to reference runtime value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_monitoring__logging__and_runtime_security_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates how serious a violation of the rule it is.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_monitoring__logging__and_runtime_security_CO1-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Categorizes the rule set into groups of related rules for ease of management.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you may want to change an existing rule. The next section will explain
    how to best approach overriding default rules.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding Existing Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of modifying the rule definition directly in `/etc/falco/falco_rules.yaml`,
    I’d suggest you redefine the rule in `/etc/falco/falco_rules.local.yaml`. That’ll
    help with falling back to the original rule definition in case you want to get
    rid of the modifications or if you make any mistakes in the process. The rule
    definition needs to be changed on all worker nodes of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The rule definition shown in [Example 7-7](#modified-open-shell-falco-rule-file)
    overrides the rule named “Terminal shell in container” by changing the priority
    to `ALERT` and the output to a new format by incorporating [built-in fields](https://oreil.ly/z5oAk).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-7\. The modified rule that monitors shell activity to a container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_monitoring__logging__and_runtime_security_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifies the log output rendered for a violation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_monitoring__logging__and_runtime_security_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Treats a violation of the rule with `ALERT` priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the rule to `falco_rules.local.yaml`, we need to let Falco pick
    up the changes. Restart the Falco service with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, any attempt that shells into a container will be logged with a
    different output format and priority, as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In addition to overriding existing Falco rules, you can also define your own
    custom rules in `/etc/falco/falco_rules.local.yaml`. Writing custom rules is out
    of scope for this book, but you should find plenty of information on the topic
    in the Falco documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring Container Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are mutable by default. After the container has been started, you
    can open a shell to it, install a patch for existing software, modify files, or
    make changes to its configuration. Mutable containers allow attackers to gain
    access to the container by downloading or installing malicious software.
  prefs: []
  type: TYPE_NORMAL
- en: To counteract the situation, make sure that the container is operated in an
    immutable state. That means preventing write operations to the container’s filesystem
    or even disallowing shell access to the container. If you need to make any substantial
    changes to the container, such as updating a dependency or incorporating a new
    application feature, you should release a new tag of the container image instead
    of manually modifying the container itself. You’d then assign the new tag of the
    container image to the Pod without having to modify the internals directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Installs Malicious Software'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 7-3](#installs-malicious-software-attacker) illustrates a scenario
    where an attacker gains access to a container using stolen credentials. The attacker
    downloads and installs malicious software given that the container allows write
    operations to the root filesystem. The malicious software keeps monitoring activities
    in the container; for example, it could parse the application logs for sensitive
    information. It may then send the information to a server outside of the Kubernetes
    cluster. Consequently, the data is used as a means to log into other parts of
    the system.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0703](assets/ckss_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. An attacker shells into a container and installs malicious software
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the next section, you’ll learn how to prevent the situation from happening
    by using a distroless container image, injecting configuration data with the help
    of a ConfigMap or Secret, and by configuring a read-only container filesystem.
    Those settings as a whole will make the container truly immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Distroless Container Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Distroless container images have become increasing popular in the world of containers.
    They only bundle your application and its runtime dependencies, while at the same
    time removing as much of the operating system as possible, e.g., shells, package
    managers, and libraries. Distroless container images are not just smaller in size;
    they are also more secure. An attacker cannot shell into the container, and therefore
    the filesystem cannot be misused to install malicious software. Using distroless
    container images is the first line of defense in creating an immutable container.
    We already covered distroless container images in [“Picking a Base Image Small
    in Size”](ch06.xhtml#small-sized-base-image). Refer to that section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Container with a ConfigMap or Secret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is best practice to use the same container image for different deployment
    environments, even though their runtime configurations may be different. Any environment-specific
    configuration, such as credentials, and connection URLs to other parts of the
    system, should be externalized. In Kubernetes, you can inject configuration data
    into a container with the help of a ConfigMap or Secret as environment variables
    or files mounted via Volumes. [Figure 7-4](#configmap-runtime-configuration) shows
    the reuse of the same container image to configure a Pod in a development and
    production cluster. Configuration data specific to the environment is provided
    by a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0704](assets/ckss_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Using the same container image across multiple environments
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Avoiding the creation of environment-specific container images simplifies the
    creation process, reduces the risk of introducing accidental security risks, and
    makes testing of the functionality easier. Injecting runtime values does not require
    changing the container after it has been started and therefore is key to making
    it immutable.
  prefs: []
  type: TYPE_NORMAL
- en: When using Secrets as environment variables in a container, make sure to avoid
    accidentally logging the values to standard output, e.g., as a plain-text value
    when writing a log message. Anyone with access to the container logs would be
    able to parse them for Secrets values. As a spot check, identify the places in
    your application code where you use a Secret and assess their risk for exposure.
  prefs: []
  type: TYPE_NORMAL
- en: To brush up on creating, configuring, and consuming ConfigMaps and Secrets,
    revisit the [Kubernetes documentation](https://oreil.ly/RjxjE).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Read-Only Container Root Filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another aspect of container immutability is to prevent write access to the container’s
    filesystem. You can configure this runtime behavior by assigning the value `true`
    to the attribute `spec.containers[].securityContext.readOnlyRootFilesystem`.
  prefs: []
  type: TYPE_NORMAL
- en: There are some applications that still require write access to fulfill their
    functional requirements. For example, [nginx](https://www.nginx.com) needs to
    write to the directories `/var/run`, `/var/cache/nginx`, and `/usr/local/nginx`.
    In combination with setting `readOnlyRootFilesystem` to `true`, you can declare
    Volumes that make those directories writable. [Example 7-8](#nginx-immutable-container)
    shows the YAML manifest of an immutable container running nginx.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-8\. A container disallowing write access to the root filesystem
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Identify the filesystem read/write requirements of your application before creating
    a Pod. Configure write mountpaths with the help of Volumes. Any other filesystem
    path should become read-only.
  prefs: []
  type: TYPE_NORMAL
- en: Using Audit Logs to Monitor Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s imperative for a Kubernetes administrator to have a record of events that
    have occurred in the cluster. Those records can help detect an intrusion in real-time,
    or they can be used to track down configuration changes for troubleshooting purposes.
    *Audit logs* provide a chronological view of events received by the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Administrator Can Monitor Malicious Events in Real Time'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 7-5](#observing-audit-log-attacker) shows the benefits of monitoring
    Kubernetes API events. In this scenario, the attacker tries to make calls to the
    API server. Events of interest have been captured by the audit log mechanism.
    The administrator can view those events at any time, identify intrusion attempts,
    and take countermeasure.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0705](assets/ckss_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. An attacker monitored by observing audit logs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We only reviewed one of the use cases here, the one that applies to security
    concerns. The ability to trace company-internal API requests should not be underestimated.
    By reviewing audit logs, the administrator can provide guidance to application
    developers trying to create Kubernetes objects, or reconstruct configuration changes
    that may have led to faulty cluster behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Audit Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes can store records for events triggered by end users for any requests
    made to the API server or for events emitted by the control plane itself. Entries
    in the audit log exist in [JSON Lines](https://jsonlines.org) format and can consist
    of, but aren’t limited to, the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: What event occurred?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who triggered the event?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When was it triggered?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which Kubernetes component handled the request?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of event and the corresponding request data to be recorded are defined
    by an *audit policy*. The audit policy is a YAML manifest specifying those rules
    and has to be provided to the API server process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *audit backend* is responsible for storing the recorded audit events, as
    defined by the audit policy. You have two configurable options for a backend:'
  prefs: []
  type: TYPE_NORMAL
- en: A log backend, which write the events to a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A webhook backend, which sends the events to an external service via HTTP(S)—for
    example, for the purpose of integrating a centralized logging and monitoring system.
    Such a backend can help with debugging runtime issues like a crashed application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 7-6](#audit-log-architecture) puts together all the pieces necessary
    to configure audit logging. The following sections will explain the details of
    configuring them.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0706](assets/ckss_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. The high-level audit log architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s have a deeper look at the audit policy file and its configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Audit Policy File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The audit policy file is effectively a YAML manifest for a `Policy` resource.
    Any event received by the API server is matched against the rules defined in the
    policy file in the order of definition. The event is logged with the declared
    audit level if a matching rule can be found. [Table 7-1](#audit-levels) lists
    all available audit levels.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Audit levels
  prefs: []
  type: TYPE_NORMAL
- en: '| Level | Effect |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `None` | Do not log events matching this rule. |'
  prefs: []
  type: TYPE_TB
- en: '| `Metadata` | Only log request metadata for the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `Request` | Log metadata and the request body for the event. |'
  prefs: []
  type: TYPE_TB
- en: '| `RequestResponse` | Log metadata, request, and response body for the event.
    |'
  prefs: []
  type: TYPE_TB
- en: '[Example 7-9](#audit-policy) shows an exemplary audit policy. The rules are
    specified as an array of items with the attribute named `rules`. Each rule declares
    a level, the resource type and API group it applies to, and an optional namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-9\. Contents of an audit policy file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_monitoring__logging__and_runtime_security_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Prevents generating logs for all requests in the `RequestReceived` stage
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_monitoring__logging__and_runtime_security_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Logs Pod changes at `RequestResponse` level
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_monitoring__logging__and_runtime_security_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Logs specialized Pod events, e.g., log and status requests, at the `Metadata`
    level
  prefs: []
  type: TYPE_NORMAL
- en: The previous audit policy isn’t very extensive but should give you an impression
    of its format. Refer to the [Kubernetes documentation](https://oreil.ly/Zozkf)
    for additional examples and more details.
  prefs: []
  type: TYPE_NORMAL
- en: Once the audit policy file has been created, it can be consumed by the API server
    process. Add the flag `--audit-policy-file` to the API server process in the file
    `/etc/kubernetes/manifests/kube-apiserver.yaml`. The value assigned to the parameter
    is the fully qualified path to the audit policy file.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we’ll walk through the settings needed to configure audit logging for
    the API server for a file-based log backend and a webhook backend.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Log Backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up a file-based log backend, you will need to add three pieces of configuration
    to the file `/etc/kubernetes/manifests/kube-apiserver.yaml`. The following list
    summarizes the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide two flags to the API server process: the flag `--audit-policy-file`
    points to the audit policy file; the flag `--audit-log-path` points to the log
    output file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Volume mountpath for the audit log policy file and the log output directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Volume definition to the host path for the audit log policy file and the
    log output directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Example 7-10](#log-backend-api-server) shows the modified content of the API
    server configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-10\. Configuring the audit policy file and audit log file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_monitoring__logging__and_runtime_security_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Provides the location of the policy file and log file to the API server process.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_monitoring__logging__and_runtime_security_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Mounts the policy file and the audit log directory to the given paths.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_monitoring__logging__and_runtime_security_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the Volumes for the policy file and the audit log directory.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime behavior of the log backend can be further customized by passing
    additional flags to the API server process. For example, you can specify the maximum
    number of days to retain old audit log files by providing the flag `--audit-log-maxage`.
    Refer to the [Kubernetes documentation](https://oreil.ly/L-63d) to have a look
    at the complete list of flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to produce some log entries. The following `kubectl` command sends
    a request to the API server for creating a Pod named `nginx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous step, we configured the audit log file at `/var/log/kubernetes/audit/audit.log`.
    Depending on the rules in the audit policy, the number of entries may be overwhelming,
    which makes finding a specific event hard. A simple way to filter configured events
    is by searching for the value `audit.k8s.io/v1` assigned to the `apiVersion` attribute.
    The following command finds relevant log entries, one for the `RequestResponse`
    level, and another for the `Metadata` level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a Webhook Backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuring a webhook backend looks different from configuring a log backend.
    We need to tell the API server to send an HTTP(S) request to an external service
    instead of the file. The configuration to the external service, the webhook, and
    the credentials needed to authenticate are defined in a [kubeconfig file](https://oreil.ly/bUnmO),
    similarly to what we’ve done in [“Configuring the ImagePolicyWebhook Admission
    Controller Plugin”](ch06.xhtml#configuring-imagepolicywebhook-admission-controller-plugin).
  prefs: []
  type: TYPE_NORMAL
- en: Add the flag `--audit-webhook-config-file` to the API server process in the
    file `/etc/kubernetes/manifests/kube-apiserver.yaml`, and point it to the location
    of the kubeconfig file. The flag `--audit-webhook-initial-backoff` defines the
    time to wait after the initial request to the external service before retrying.
    You will still have to assign the flag `--audit-policy-file` to point to the audit
    policy file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring and logging events in a Kubernetes cluster is an important duty of
    every administrator. We used Falco to identify and filter security-related events.
    You learned about the purpose and syntax of the different configuration files
    and how to find relevant alerts in the logs.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to employing behavior analytics tools, you will want to set up audit
    logging for requests reaching the API server. Audit logging records configured
    events to a backend, either to a file on the control plane node or to an external
    service via an HTTP(S) call. We worked through the process of enabling audit logging
    for the API server process.
  prefs: []
  type: TYPE_NORMAL
- en: A sensible step toward more secure containers is to make them immutable. An
    immutable container only supports a read-only filesystem, so that a potential
    attacker cannot install malicious software. Mount a Volume if the application
    running inside of the container needs to write data. Use a distroless container
    image to lock out attackers from being able to shell into the container.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practice how to configure and operate Falco.
  prefs: []
  type: TYPE_NORMAL
- en: Falco is definitely going to come up as a topic during the exam. You will need
    to understand how to read and modify a rule in a configuration file. I would suggest
    you browse through the syntax and options in more detail in case you need to write
    one yourself. The main entry point for running Falco is the command line tool.
    It’s fair to assume that it will have been preinstalled in the exam environment.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to identify immutable containers.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable containers are a central topic to this exam domain. Understand how
    to set the `spec.containers[].securityContext.readOnlyRootFilesystem` attribute
    for a Pod and how to mount a Volume to a specific path in case a write operation
    is required by the container process.
  prefs: []
  type: TYPE_NORMAL
- en: Deeply understand audit log configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up audit logging consists of two steps. For one, you need to understand
    the syntax and structure of an audit policy file. The other aspect is how to configure
    the API server to consume the audit policy file, provide a reference to a backend,
    and mount the relevant filesystem Volumes. Make sure to practice all of those
    aspects hands-on.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch07/falco* of the checked-out GitHub repository
    [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Start up the VMs running
    the cluster using the command `vagrant up`. The cluster consists of a single control
    plane node named `kube-control-plane` and one worker node named `kube-worker-1`.
    Once done, shut down the cluster using `vagrant destroy -f`. Falco is already
    running as a systemd service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspect the process running in the existing Pod named `malicious`. Have a look
    at the Falco logs and see if a rule created a log for the process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reconfigure the existing rule that creates a log for the event by changing the
    output to `<timestamp>,<username>,<container-id>`. Find the changed log entry
    in the Falco logs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reconfigure Falco to write logs to the file at `/var/logs/falco.log`. Disable
    the standard output channel. Ensure that Falco appends new messages to the log
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Prerequisite:* This exercise requires the installation of the tools [Vagrant](https://oreil.ly/FiyeH)
    and [VirtualBox](https://oreil.ly/WW8IK).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch07/immutable-container* of the checked-out
    GitHub repository [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Execute
    the command `kubectl apply -f setup.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspect the Pod created by the YAML manifest in the `default` namespace. Make
    relevant changes to the Pod so that its container can be considered immutable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch07/audit-log* of the checked-out GitHub repository
    [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Start up the VMs running
    the cluster using the command `vagrant up`. The cluster consists of a single control
    plane node named `kube-control-plane` and one worker node named `kube-worker-1`.
    Once done, shut down the cluster using `vagrant destroy -f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the existing audit policy file at `/etc/kubernetes/audit/rules/audit-policy.yaml`.
    Add a rule that logs events for ConfigMaps and Secrets at the `Metadata` level.
    Add another rule that logs events for Services at the `Request` level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configure the API server to consume the audit policy file. Logs should be written
    to the file `/var/log/kubernetes/audit/logs/apiserver.log`. Define a maximum number
    of five days to retain audit log files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that the log file has been created and contains at least one entry that
    matches the events configured.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Prerequisite:* This exercise requires the installation of the tools [Vagrant](https://oreil.ly/FiyeH)
    and [VirtualBox](https://oreil.ly/WW8IK).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
