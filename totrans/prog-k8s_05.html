<html><head></head><body><section data-pdf-bookmark="Chapter 5. Automating Code Generation" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_autocodegen">&#13;
<h1><span class="label">Chapter 5. </span>Automating Code Generation</h1>&#13;
&#13;
&#13;
<p>In<a data-primary="custom resource definitions (CRDs)" data-secondary="writing with code generators" data-type="indexterm" id="CRgenerat05"/><a data-primary="code generation" data-secondary="benefits of" data-type="indexterm" id="idm46336860244136"/> this chapter you’ll learn how to use the Kubernetes code generators in Go projects to write custom resources in a natural way. Code generators are used a lot in the implementation of native Kubernetes resources, and we’ll use the very same generators here.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why Code Generation" data-type="sect1"><div class="sect1" id="idm46336860242664">&#13;
<h1>Why Code Generation</h1>&#13;
&#13;
<p>Go is a simple language by design. It lacks higher-level or even metaprogramming-like mechanisms to express algorithms on different data types in a generic (i.e., type-independent) way. The “Go way” is to use external code generation instead.</p>&#13;
&#13;
<p>Very early in the Kubernetes development process, more and more code had to be rewritten as more resources were added to the system. Code generation made the maintenance of this code much easier. Very early on, the <a href="http://bit.ly/2L9kwNJ">Gengo library</a> was created, and eventually, based on Gengo, <a href="http://bit.ly/2Kw8I8U"><em>k8s.io/code-generator</em></a> was developed as an externally usable collection of generators. We will use these generators in the following sections for CRs.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Calling the Generators" data-type="sect1"><div class="sect1" id="idm46336860238536">&#13;
<h1>Calling the Generators</h1>&#13;
&#13;
<p>Usually, the code generators<a data-primary="code generation" data-secondary="calling code generators" data-type="indexterm" id="idm46336860237128"/> are called in mostly the same way in every controller project. Only packages, group names, and API versions differ. Calling the script <em>k8s.io/code-generator/generate-groups.sh</em> or a bash script like <em>hack/update-codegen.sh</em> is the easiest way to add code generation to CR Go types from the build system (see <a href="http://bit.ly/2J0s2YL">the book’s GitHub repository</a>).</p>&#13;
&#13;
<p>Note that some projects call the generator binaries directly due to very special requirements and often historic reasons. For the use case of building a controller for CRs, it is much easier to just call the <em>generate-groups.sh</em> script from the <em>k8s.io/code-generator</em> repository:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>vendor/k8s.io/code-generator/generate-groups.sh all <code class="se">\</code>&#13;
    github.com/programming-kubernetes/cnat/cnat-client-go/pkg/generated&#13;
    github.com/programming-kubernetes/cnat/cnat-client-go/pkg/apis <code class="se">\</code>&#13;
    cnat:v1alpha1 <code class="se">\</code>&#13;
    --output-base <code class="s2">"</code><code class="si">${</code><code class="nv">GOPATH</code><code class="si">}</code><code class="s2">/src"</code> <code class="se">\</code>&#13;
    --go-header-file <code class="s2">"hack/boilerplate.go.txt"</code></pre>&#13;
&#13;
<p>Here, <code>all</code> means to call<a data-primary="generator" data-secondary="deepcopy-gen" data-type="indexterm" id="idm46336860214776"/><a data-primary="deep-copy" data-secondary="deepcopy-gen" data-type="indexterm" id="idm46336860213864"/> all four standard code generators for CRs:</p>&#13;
<dl>&#13;
<dt><code>deepcopy-gen</code></dt>&#13;
<dd>&#13;
<p>Generates <code>func</code> <code>(t *T)</code> <code>DeepCopy()</code> <code>*T</code> and <code>func</code> <code>(t *T)</code> <code>DeepCopyInto(*T)</code> methods.</p>&#13;
</dd>&#13;
<dt><code>client-gen</code></dt>&#13;
<dd>&#13;
<p>Creates typed client sets.</p>&#13;
</dd>&#13;
<dt><code>informer-gen</code></dt>&#13;
<dd>&#13;
<p>Creates informers for CRs that offer an event-based interface to react to changes of CRs on the server.</p>&#13;
</dd>&#13;
<dt><code>lister-gen</code></dt>&#13;
<dd>&#13;
<p>Creates listers for CRs that offer a read-only caching layer for <code>GET</code> and <code>LIST</code> requests.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The last two are the basis for building controllers (see <a data-type="xref" href="ch01.html#ch_controllers-operators">“Controllers and Operators”</a>). These four code generators make up a powerful basis for building full-featured, production-ready controllers using the same mechanisms and packages that the Kubernetes upstream controllers are using.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There are some more generators in <em>k8s.io/code-generator</em>, mostly for other contexts. For example, if you build your own aggregated API server (see <a data-type="xref" href="ch08.html#ch_custom-api-servers">Chapter 8</a>), you will work with internal types in addition to versioned types, and you have to define defaulting functions. Then these two generators, which you can access by calling the <a href="http://bit.ly/2L9kSE3"><em>generate-internal-groups.sh</em></a> script from <em>k8s.io/code-generator</em>, will become relevant:</p>&#13;
<dl>&#13;
<dt><code>conversion-gen</code></dt>&#13;
<dd>&#13;
<p>Creates functions for converting between<a data-primary="generator" data-secondary="defaulter-gen" data-type="indexterm" id="idm46336860195832"/><a data-primary="defaulting" data-secondary="defaulter-gen" data-type="indexterm" id="idm46336860194856"/> internal and external types.</p>&#13;
</dd>&#13;
<dt><code>defaulter-gen</code></dt>&#13;
<dd>&#13;
<p>Takes care of defaulting certain fields.</p>&#13;
</dd>&#13;
</dl>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Now let’s look in detail at the parameters to <code>generate-groups.sh</code>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The second parameter is the target package name for the generated clients, listers, and informers.</p>&#13;
</li>&#13;
<li>&#13;
<p>The third parameter is the base package for the API group.</p>&#13;
</li>&#13;
<li>&#13;
<p>The fourth parameter is a space-separated list of API groups with their versions.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>--output-base</code> is passed as a flag to all generators to define the base directory where the given packages are found.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>--go-header-file</code> enables us to put copyright headers into generated code.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Some generators, like <code>deepcopy-gen</code>, create files directly inside the API group packages. Those files follow a standard naming scheme with a <em>zz_generated.</em> prefix such that it is easy to exclude them from version control systems (e.g., via <em>.gitignore</em> file), though most projects decide to check generated files in because the Go tooling around code generators is not well developed.<sup><a data-type="noteref" href="ch05.html#idm46336860111320" id="idm46336860111320-marker">1</a></sup></p>&#13;
&#13;
<p>If the project follows the pattern of <a href="http://bit.ly/2UppsTN"><em>k8s.io/sample-controller</em></a>—the <code>sample-controller</code> is a blueprint project replicating the patterns established by the many controllers built in Kubernetes itself—then the code generation starts with:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>hack/update-codegen.sh</pre>&#13;
&#13;
<p>The <code>cnat</code> example in the <code>sample-controller+client-go</code> variant in <a data-type="xref" href="ch06.html#cnat-client-go">“Following sample-controller”</a> goes this route.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Usually, in addition to the <a href="http://bit.ly/2J0s2YL"><code>hack/update-codegen.sh</code></a> script, there is a second script called <a href="http://bit.ly/2IXUWsy"><code>hack/verify-codegen.sh</code></a>.</p>&#13;
&#13;
<p>This script calls the <code>hack/update-codegen.sh</code> script and checks whether anything changed, and then it terminates with a nonzero return code if any of the generated files is not up-to-date.</p>&#13;
&#13;
<p>This is very helpful in a continuous integration (CI) script: if a developer modified the files by accident or if the files are just outdated, CI will notice and complain.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Controlling the Generators with Tags" data-type="sect1"><div class="sect1" id="idm46336860237944">&#13;
<h1>Controlling the Generators with Tags</h1>&#13;
&#13;
<p>While<a data-primary="code generation" data-secondary="controlling with tags" data-type="indexterm" id="idm46336860100584"/> some of the code-generator behavior is controlled via command-line flags as described earlier (especially the packages to process), a lot more properties are <span class="keep-together">controlled</span> via <em>tags</em> in your Go files. A tag is a specially formatted Go comment in the following form:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +some-tag</code>&#13;
<code class="c1">// +some-other-tag=value</code></pre>&#13;
&#13;
<p>There are two kind of tags:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Global tags above the <code>package</code> line in a file called <em>doc.go</em></p>&#13;
</li>&#13;
<li>&#13;
<p>Local tags above a type declaration (e.g., above a struct definition)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Depending on the tags in question, the position of the comment might be important.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336860095576">&#13;
<h5>Follow Examples (including Comment Blocks) Precisely</h5>&#13;
<p>There are a number of tags that must be in a comment directly above a type (or the package line for a global tag), while others must be separated from the type (or the package line) with at least one empty line in between them. For example:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +second-comment-block-tag</code>&#13;
&#13;
<code class="c1">// +first-comment-block-tag</code>&#13;
<code class="kd">type</code> <code class="nx">Foo</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The reason for this distinction is historic: the API documentation generators in Kubernetes used not to know about code generation tags and instead exported only the first comment block. Therefore, tags in that block would have showed up in API HTML documents.</p>&#13;
&#13;
<p>The code generator tag parsing logic is not always very consistent, and often the error handling is far from perfect. While this is improved with each version, be prepared to follow existing examples very precisely—for example, an empty line might matter.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Global Tags" data-type="sect2"><div class="sect2" id="global-tags">&#13;
<h2>Global Tags</h2>&#13;
&#13;
<p>Global tags<a data-primary="code generation" data-secondary="global tags for" data-type="indexterm" id="idm46336860063688"/><a data-primary="global tags" data-type="indexterm" id="idm46336860062680"/> are written into a package’s <em>doc.go</em>. A typical <em>pkg/apis/<code>group</code>/<code>version</code>/doc.go</em> file looks like this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +k8s:deepcopy-gen=package</code>&#13;
&#13;
<code class="c1">// Package v1 is the v1alpha1 version of the API.</code>&#13;
<code class="c1">// +groupName=cnat.programming-kubernetes.info</code>&#13;
<code class="kn">package</code> <code class="nx">v1alpha1</code></pre>&#13;
&#13;
<p>The first line of this file tells <code>deepcopy-gen</code> to create deep-copy methods by default for every type in that package. If you have types where deep copy is not necessary, not desired, or even not possible, you can opt out for them with the local tag <span class="keep-together"><code>// +k8s:deepcopy-gen=false</code></span>. If you do not enable package-wide deep copy, you have to opt in to deep copy for each desired type via <code>// +k8s:deepcopy-gen=true</code>.</p>&#13;
&#13;
<p>The second tag, <code>// +groupName=example.com</code>, defines the fully qualified API group name. This tag is necessary if the Go parent package name does not match the group name.</p>&#13;
&#13;
<p>The file shown here actually comes from the <a href="http://bit.ly/2L6M9ad"><code>cnat client-go</code> example <em>pkg/apis/cnat/v1alpha1/doc.go</em> file</a> (see <a data-type="xref" href="ch06.html#cnat-client-go">“Following sample-controller”</a>). There, <code>cnat</code> is the parent package, but <code>cnat.programming-kubernetes.info</code> is the group name.</p>&#13;
&#13;
<p>With the <code>// +groupName</code> tag, the client generator (see <a data-type="xref" href="ch04.html#clientgen-client">“Typed client created via client-gen”</a>) will generate a client using the correct HTTP path <em>/apis/foo.project.example.com</em>. Besides <code>+groupName</code> there is also <code>+groupGoName</code>, which defines a custom Go identifier (for variable and type names) to be used instead of the parent package name. For example, the generators will use the uppercase parent package name for identifies by default, which in our example is <code>Cnat</code>. A better identifier would be <code>CNAt</code> for “Cloud Native At.” With <code>// +groupGoName=CNAt</code> we could use that instead of <code>Cnat</code> (though we don’t do that in this example—we’ve stayed with <code>Cnat</code>), and<a data-primary="generator" data-secondary="client-gen" data-type="indexterm" id="idm46336859993352"/> the <code>client-gen</code> result would look like the following:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">Interface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Discovery</code><code class="p">()</code> <code class="nx">discovery</code><code class="p">.</code><code class="nx">DiscoveryInterface</code>&#13;
    <code class="nx">CNatV1</code><code class="p">()</code> <code class="nx">atv1alpha1</code><code class="p">.</code><code class="nx">CNatV1alpha1Interface</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Local Tags" data-type="sect2"><div class="sect2" id="local-tags">&#13;
<h2>Local Tags</h2>&#13;
&#13;
<p>Local tags<a data-primary="code generation" data-secondary="local tags for" data-type="indexterm" id="idm46336859962104"/><a data-primary="local tags" data-type="indexterm" id="idm46336859960904"/> are written either directly above an API type or in the second comment block above it. Here are the main types in the <em>types.go</em> file of the <a href="http://bit.ly/31QosJw"><code>cnat</code> example</a>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// AtSpec defines the desired state of At</code>&#13;
<code class="kd">type</code> <code class="nx">AtSpec</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// Schedule is the desired time the command is supposed to be executed.</code>&#13;
    <code class="c1">// Note: the format used here is UTC time https://www.utctime.net</code>&#13;
    <code class="nx">Schedule</code> <code class="kt">string</code> <code class="s">`json:"schedule,omitempty"`</code>&#13;
    <code class="c1">// Command is the desired command (executed in a Bash shell) to be executed.</code>&#13;
    <code class="nx">Command</code> <code class="kt">string</code> <code class="s">`json:"command,omitempty"`</code>&#13;
    <code class="c1">// Important: Run "make" to regenerate code after modifying this file</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// AtStatus defines the observed state of At</code>&#13;
<code class="kd">type</code> <code class="nx">AtStatus</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// Phase represents the state of the schedule: until the command is executed</code>&#13;
    <code class="c1">// it is PENDING, afterwards it is DONE.</code>&#13;
    <code class="nx">Phase</code> <code class="kt">string</code> <code class="s">`json:"phase,omitempty"`</code>&#13;
    <code class="c1">// Important: Run "make" to regenerate code after modifying this file</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// +genclient</code>&#13;
<code class="c1">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code>&#13;
&#13;
<code class="c1">// At runs a command at a given schedule.</code>&#13;
<code class="kd">type</code> <code class="nx">At</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">TypeMeta</code>   <code class="s">`json:",inline"`</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">ObjectMeta</code> <code class="s">`json:"metadata,omitempty"`</code>&#13;
&#13;
    <code class="nx">Spec</code>   <code class="nx">AtSpec</code>   <code class="s">`json:"spec,omitempty"`</code>&#13;
    <code class="nx">Status</code> <code class="nx">AtStatus</code> <code class="s">`json:"status,omitempty"`</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code>&#13;
&#13;
<code class="c1">// AtList contains a list of At</code>&#13;
<code class="kd">type</code> <code class="nx">AtList</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">TypeMeta</code> <code class="s">`json:",inline"`</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">ListMeta</code> <code class="s">`json:"metadata,omitempty"`</code>&#13;
    <code class="nx">Items</code>           <code class="p">[]</code><code class="nx">At</code> <code class="s">`json:"items"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the following sections we’ll walk through the tags of this example.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>In this example, the API documentation is in the first comment block, while we put the tags into the second comment block. This helps to keep the tags out of the API documentation, if you use some tool to extract the Go doc comments for that purpose.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="deepcopy-gen Tags" data-type="sect2"><div class="sect2" id="deepcopy-tags">&#13;
<h2>deepcopy-gen Tags</h2>&#13;
&#13;
<p>Deep-copy method generation<a data-primary="deep copies" data-type="indexterm" id="deep05"/><a data-primary="code generation" data-secondary="deepcopy-gen tags" data-type="indexterm" id="idm46336859825416"/> is usually enabled for all types by default via the global <code>// +k8s:deepcopy-gen=package</code> tag (see <a data-type="xref" href="#global-tags">“Global Tags”</a>)—that is, with possible opt-out. However, in the preceding example file (and actually the whole package), all API types need deep-copy methods. Hence, we don’t have to opt out locally.</p>&#13;
&#13;
<p>If we had a helper struct in the API types package (this is usually discouraged to keep API packages clean), we would have to disable deep-copy generation. For example:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +k8s:deepcopy-gen=false</code>&#13;
<code class="c1">//</code>&#13;
<code class="c1">// Helper is a helper struct, not an API type.</code>&#13;
<code class="kd">type</code> <code class="nx">Helper</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="runtime.Object and DeepCopyObject" data-type="sect2"><div class="sect2" id="deepcopy-runtime-object">&#13;
<h2>runtime.Object and DeepCopyObject</h2>&#13;
&#13;
<p>There<a data-primary="code generation" data-secondary="runtime.Object and DeepCopyObject" data-type="indexterm" id="idm46336859815384"/><a data-primary="runtime.Object" data-type="indexterm" id="idm46336859814408"/><a data-primary="DeepCopyObject tag" data-type="indexterm" id="idm46336859813736"/> is a special deep-copy tag that needs more explanation:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code></pre>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.html#kube-objects">“Kubernetes Objects in Go”</a> we saw that <code>runtime.Object</code>s have to implement the <code>DeepCopyObject() runtime.Object</code> method. The reason is that generic code within Kubernetes has to be able to create deep copies of objects. This method allows that.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336859791784">&#13;
<h5>Historical Background</h5>&#13;
<p>Prior to 1.8, the scheme (see <a data-type="xref" href="ch03.html#scheme">“Scheme”</a>) was also keeping references to type-specific deep-copy functions, and it had a reflection-based deep-copy implementation. Both mechanisms were the reason for a number of nontrivial and hard-to-discover bugs. Therefore, Kubernetes switched to static deep copy with the <code>DeepCopyObject</code> method in the <code>runtime.Object</code> interface.</p>&#13;
</div></aside>&#13;
&#13;
<p>The <code>DeepCopyObject()</code> method does nothing other than calling the generated <code>DeepCopy</code> method. The signature of the latter varies from type to type (<code>DeepCopy()</code> <code>*T</code> depends on <code>T</code>). The signature of the former is always <code>DeepCopyObject()</code> <code>runtime.Object</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">in</code> <code class="o">*</code><code class="nx">T</code><code class="p">)</code> <code class="nx">DeepCopyObject</code><code class="p">()</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">Object</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="nx">c</code> <code class="o">:=</code> <code class="nx">in</code><code class="p">.</code><code class="nx">DeepCopy</code><code class="p">();</code> <code class="nx">c</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nx">c</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Put the local tag <code>//</code> <code>+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery<span class="keep-together">/pkg/runtime.Object</span></code> above your top-level API types to generate this method with <code>deepcopy-gen</code>. This tells <code>deepcopy-gen</code> to create such a method for <code>runtime.Object</code>, called <code>DeepCopyObject()</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>In the previous example, both <code>At</code> and <code>AtList</code> are top-level types because they are used as <code>runtime.Object</code>s.</p>&#13;
&#13;
<p>As a rule of thumb, top-level types are those that have <code>metav1.TypeMeta</code> embedded.</p>&#13;
</div>&#13;
&#13;
<p>It happens that other interfaces need a way to be deep-copied. This is usually the case if, for example, API types have a field of interface type <code>Foo</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">SomeAPIType</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
  <code class="nx">Foo</code> <code class="nx">Foo</code> <code class="s">`json:"foo"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As we have seen, API types must be deep-copyable, and hence the field <code>Foo</code> must be deep-copied too. How could you do that in a generic way (without type-casts) without adding <code>DeepCopyFoo() Foo</code> to the <code>Foo</code> interface?</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">Foo</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="o">...</code>&#13;
    <code class="nx">DeepCopyFoo</code><code class="p">()</code> <code class="nx">Foo</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In that case the same tag can be used:</p>&#13;
<pre data-code-language="go" data-type="programlisting">&#13;
<code class="c1">// +k8s:deepcopy-gen:interfaces=&lt;package&gt;.Foo</code>&#13;
<code class="kd">type</code> <code class="nx">FooImplementation</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>There<a data-primary="" data-startref="deep05" data-type="indexterm" id="idm46336859682504"/> are a few examples beyond <code>runtime.Object</code> in the Kubernetes source where this tag is actually used:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +k8s:deepcopy-gen:interfaces=.../pkg/registry/rbac/reconciliation.RuleOwner</code>&#13;
<code class="c1">// +k8s:deepcopy-gen:interfaces=.../pkg/registry/rbac/reconciliation.RoleBinding</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="client-gen Tags" data-type="sect2"><div class="sect2" id="clientgen-tags">&#13;
<h2>client-gen Tags</h2>&#13;
&#13;
<p>Finally, there<a data-primary="code generation" data-secondary="client-gen tags" data-type="indexterm" id="idm46336859618616"/><a data-primary="client-gen tags" data-type="indexterm" id="idm46336859617608"/> are a number of tags to control <code>client-gen</code>, one of which we saw in the earlier example for <code>At</code> and <code>AtList</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +genclient</code></pre>&#13;
&#13;
<p>It tells <code>client-gen</code> to create a client for this type (this is always opt-in). Note that you don’t have to and indeed <em>must not</em> put it above the <code>List</code> type of the API objects.</p>&#13;
&#13;
<p>In our <code>cnat</code> example, we use the <em>/status</em> subresource and update the status of the CRs with the <code>UpdateStatus</code> method of the client (see <a data-type="xref" href="ch04.html#status-subresource">“Status subresource”</a>). There are instances of CRs without a status or without a spec-status split. In those cases, the following tag avoids the generation of that <code>UpdateStatus()</code> method:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +genclient:noStatus</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Without this tag, <code>client-gen</code> will blindly generate the <code>UpdateStatus()</code> method. It is important to understand, however, that the spec-status split works only if the <em>/status</em> subresource is actually enabled in the CustomResourceDefinition manifest (see <a data-type="xref" href="ch04.html#crd-subresources">“Subresources”</a>).</p>&#13;
&#13;
<p>The existence of the method alone in the client has no effect. Requests to it without the change in the manifest will even fail.</p>&#13;
</div>&#13;
&#13;
<p>The client generator has to choose the right HTTP path, either with or without a namespace. For cluster-wide resources, you have to use the tag:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +genclient:nonNamespaced</code></pre>&#13;
&#13;
<p>The default is to generate a namespaced client. Again, this has to match the scope setting in the CRD manifest. For special-purpose clients, you might also want to control in detail which HTTP methods are offered. You can do this by using a couple of tags, for example:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +genclient:noVerbs</code>&#13;
<code class="c1">// +genclient:onlyVerbs=create,delete</code>&#13;
<code class="c1">// +genclient:skipVerbs=get,list,create,update,patch,delete,watch</code>&#13;
<code class="c1">// +genclient:method=Create,verb=create,</code>&#13;
<code class="c1">// result=k8s.io/apimachinery/pkg/apis/meta/v1.Status</code></pre>&#13;
&#13;
<p>The first three should be pretty self-explanatory, but the last one warrants some explanation.</p>&#13;
&#13;
<p>The type this tag is written above will be create-only and will not return the API type itself, but a <code>metav1.Status</code>. For CRs this does not make much sense, but for user-provided API servers written in Go (see <a data-type="xref" href="ch08.html#ch_custom-api-servers">Chapter 8</a>) those resources can exist, and they do in practice.</p>&#13;
&#13;
<p>One common case for the <code>// +genclient:method=</code> tag is the addition of a method to scale a resource. In <a data-type="xref" href="ch04.html#scale-subresource">“Scale subresource”</a> we describe how the <em>/scale</em> subresource can be enabled for CRs. The following tags create the corresponding client methods:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// +genclient:method=GetScale,verb=get,subresource=scale,\</code>&#13;
<code class="c1">//    result=k8s.io/api/autoscaling/v1.Scale</code>&#13;
<code class="c1">// +genclient:method=UpdateScale,verb=update,subresource=scale,\</code>&#13;
<code class="c1">//    input=k8s.io/api/autoscaling/v1.Scale,result=k8s.io/api/autoscaling/v1.Scale</code></pre>&#13;
&#13;
<p>The first tag creates the getter <code>GetScale</code>. The second creates the setter <code>UpdateScale</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>All CR <em>/scale</em> subresources receive and output the <code>Scale</code> type from the <em>autoscaling/v1</em> group. In the Kubernetes API there are resources that use other types for historic reasons.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="informer-gen and lister-gen" data-type="sect2"><div class="sect2" id="idm46336859619752">&#13;
<h2>informer-gen and lister-gen</h2>&#13;
&#13;
<p>Both<a data-primary="generator" data-secondary="informer-gen" data-type="indexterm" id="idm46336859478056"/><a data-primary="code generation" data-secondary="informer-gen and lister-gen" data-type="indexterm" id="idm46336859477048"/><a data-primary="informer-gen" data-type="indexterm" id="idm46336859476136"/><a data-primary="generator" data-secondary="lister-gen" data-type="indexterm" id="idm46336859475464"/><a data-primary="lister-gen" data-type="indexterm" id="idm46336859456600"/> <code>informer-gen</code> and <code>lister-gen</code> process the <code>// +genclient</code> tag of <code>client-gen</code>. There is nothing else to configure. Each type that opted in to client generation gets informers and listers automatically that match the client (if the whole suite of generators is called via the <em>k8s.io/code-generator/generate-group.sh</em> script).</p>&#13;
&#13;
<p>The documentation of the Kubernetes generators has a lot of room for improvement and will certainly be refined slowly over time. For more information about the different generators, it is often helpful to look at examples inside Kubernetes itself—for example, <a href="http://bit.ly/2ZA6dWH">k8s.io/api</a> and <a href="http://bit.ly/2KxpKnc">OpenShift API types</a>. Both repositories have many advanced use cases.</p>&#13;
&#13;
<p>Moreover, don’t hesitate to look into the generators themselves. <code>deepcopy-gen</code> has some documentation available inside its <a href="http://bit.ly/2x9HmN4"><em>main.go</em></a> file. <code>client-gen</code> has some documentation available in the <a href="http://bit.ly/2WYNlns">Kubernetes contributor documentation</a>. <code>informer-gen</code> and <code>lister-gen</code> currently don’t have further documentation, but <em>generate-groups.sh</em> shows <a href="http://bit.ly/31MeSHp">how each is invoked</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46336860101656">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we showed you how to use the Kubernetes code generators for CRs. With that out of the way, we now move on to higher-level abstraction tooling—that is, solutions for writing custom controllers and operators that enable you to focus on the business logic.<a data-primary="" data-startref="CRgenerat05" data-type="indexterm" id="idm46336859423832"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46336860111320"><sup><a href="ch05.html#idm46336860111320-marker">1</a></sup> The Go tools do not run the generation automatically when needed and lack a way to define dependencies between source and generated files.</p></div></div></section></body></html>