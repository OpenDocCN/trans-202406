- en: 'Chapter 9\. Material Views: *A Material World*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0355-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Most apps need a slick UI that responds to the user.**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve so far learned how to use views such as **text views, buttons and spinners**,
    and applied **Material themes** to make sweeping changes to your app’s look and
    feel. But there’s so much more you can do. Here, you’ll learn how to make your
    UI more responsive with the **coordinator layout**. You’ll create **toolbars**
    that can **collapse or scroll** on a whim. You’ll discover **exciting new views**
    such as **checkboxes**, **radio buttons**, **chips**, and **floating action buttons**.
    Finally, you’ll find out how to display friendly pop-up messages using **toasts**
    and **snackbars**. Read on to find out more.
  prefs: []
  type: TYPE_NORMAL
- en: Material is used throughout Androidville
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter you learned how to use toolbars, bottom navigation bars,
    and navigation drawers to help users navigate your app, and styled them using
    a theme from the Material library. As you may recall, Material is a design system
    that helps you build apps with a consistent look and feel across all screens.
  prefs: []
  type: TYPE_NORMAL
- en: Material isn’t just limited to toolbars, navigation drawers, and bottom navigation
    bars; it styles every view in your app, from buttons to text views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more examples of components and features that use Material:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/star.png) **Scrolling and collapsing toolbars**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can make the toolbar scroll off the screen, or collapse, if the user scrolls
    content.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0356-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/star.png) **Radio buttons, checkboxes, and chips**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These let the user choose options.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0356-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/star.png) **Floating action buttons (FABs)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FABs are special buttons that float above the main screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0356-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/star.png) **Snackbars**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are pop-up messages you can interact with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0356-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We’re going to show you how to use these views and features by building a new
    app.
  prefs: []
  type: TYPE_NORMAL
- en: The Bits and Pizzas app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re going to build a new app named Bits and Pizzas. We’re going to focus on
    its Create Order screen, which lets the user place an order for a pizza.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screen looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0357-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The app is comprised of an activity—`MainActivity`—that displays a fragment
    named `OrderFragment`. The fragment defines the Create Order screen’s appearance
    and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the steps we need to take to build the app.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what we’ll do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll build the app by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add a toolbar that can scroll.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll create `OrderFragment`, and add a toolbar to its layout that will scroll
    off the screen when the user scrolls the screen up, and reappear when they scroll
    down.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0358-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Implement a collapsing toolbar.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we’ve made the toolbar scroll, we’ll add an image to it, and get it to
    collapse and expand when the user scrolls the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0358-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add views.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user needs to be able to place a pizza order. We’ll enable this by adding
    radio buttons, chips, and a floating action button to `OrderFragment`’s layout.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0358-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Make the FAB respond to clicks.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user clicks the FAB, we’ll display a pop-up message that gives details
    of her order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0358-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Create the Bits and Pizzas project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0359-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re going to create a new project for the Bits and Pizzas app, so you need
    to create one using the same steps from previous chapters. Choose the Empty Activity
    option, enter a name of “Bits and Pizzas” and a package name of “com.hfad.bitsandpizzas”,
    and accept the default save location. Make sure the language is set to Kotlin
    and the minimum SDK is API 21 so it will run on most Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: Add a Material library dependency to the app build.gradle file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’re going to use themes, views, and features from the Material
    library, so we need to make sure that the app’s *build.gradle* file includes it
    as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file *BitsandPizzas/app/build.gradle*, and make sure that its `dependencies`
    section includes the following line (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0359-02.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s likely that Android Studio has already added this dependency to the file
    for you. If not, you’ll need to add it yourself, and click on the Sync Now option
    that appears at the top of the code editor to sync the change with the rest of
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve made sure that the app includes the Material library, let’s
    go and create `OrderFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Create OrderFragment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`OrderFragment` is the Bits and Pizzas app’s main screen, and it’s what the
    user will use to place a pizza order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the fragment, highlight the *com.hfad.bitsandpizzas* package in the
    *app/src/main/java* folder, then go to File→New→Fragment→Fragment (Blank). Name
    the fragment “OrderFragment” and its layout “fragment_order”, and make sure the
    language is set to Kotlin. Then update the code for *OrderFragment.kt* to match
    the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0360-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then update the code in its layout file *fragment_order.xml* so that it includes
    a frame layout like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0360-03.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ll update `OrderFragment` through the rest of this chapter. First, let’s
    display it in `MainActivity`’s layout.
  prefs: []
  type: TYPE_NORMAL
- en: Display OrderFragment in MainActivity’s layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll add `OrderFragment` to `MainActivity`’s layout using a `FragmentContainerView`,
    specifying the name of the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code to do this; open *activity_main.xml* and update its code to
    include the changes below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0361-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, open *MainActivity.kt* and make sure that its code matches the code
    shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0361-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve got `MainActivity` to display `OrderFragment`, let’s find out
    how to make the app bar respond to scrolls.
  prefs: []
  type: TYPE_NORMAL
- en: Replace the default app bar with a toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re going to make the Bits and Pizzas app bar respond when the user scrolls.
    For now, we’ll make it scroll off the screen when the user scrolls the screen
    up, and make it reappear when she scrolls down again.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0362-01.png)'
  prefs: []
  type: TYPE_IMG
- en: To do this, we first need to replace the default app bar with a toolbar. This
    is because the default app bar is fixed to the top of the screen, and can’t be
    made to scroll. A toolbar, however, is much more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first need to change the app’s theme to one that has no app
    bar. Open the file *themes.xml* in the *app/src/main/res/values* folder, and update
    its code to include the style below in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0362-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If your project includes a *themes.xml* file in the *values-night* folder, you’ll
    need to apply the above change to this file as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve made this change, add a toolbar to `FragmentOrder` by updating
    the *fragment_order.xml* code so it matches the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0362-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Fragments don’t have a setSupportActionBar() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve added the toolbar, we need to make it behave like a proper app
    bar that displays the app’s name. As you learned in the previous chapter, this
    is done by calling the activity’s `setSupportActionBar()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve added the toolbar to a fragment, and **fragments don’t include a**
    `**setSupportActionBar()**` **method**. To get around this, we’ll get a reference
    to the activity that’s displaying the fragment (using `**activity**`), cast it
    to an `AppCompatActivity` to reflect its type, and call its `setSupportActionBar()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0363-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the full code for *OrderFragment.kt*; update your code to include the
    changes (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0363-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve added the toolbar…now what?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve now added a toolbar to `OrderFragment`’s layout so that when the app
    runs, the toolbar is displayed at the top of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0364-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If we try and scroll the screen, however, the toolbar doesn’t move. To make
    it respond to scrolls, we need to make a few more changes.
  prefs: []
  type: TYPE_NORMAL
- en: We want the toolbar to respond to scrolls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make the toolbar move, we need to add more views to the fragment’s layout.
    The layout needs to follow the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0364-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The layout needs to include three things: a **coordinator layout**, an **app
    bar layout,** and a **nested scroll view**. Together, they let the toolbar respond
    when the user scrolls the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find out what each one does, starting with the coordinator layout.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinator layout coordinates animations between views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A coordinator layout is like a souped-up frame layout that’s used to coordinate
    animations between different views. It can, for example, coordinate the user scrolling
    the layout’s main content with the toolbar moving off the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You add a coordinator layout to your layout code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0365-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You need to include any views whose animations you want to coordinate in the
    coordinator layout. In the Bits and Pizzas app, for example, we want to coordinate
    two things: the user scrolling the layout’s main contents, and the toolbar scrolling
    off the screen. This means the toolbar and the screen’s main contents need to
    be included in the coordinator layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0365-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A CoordinatorLayout allows the behavior of one view to affect the behavior
    of another.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**The CoordinatorLayout is usually the root element of your layout.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we know what the coordinator layout does, let’s move on to the app
    bar layout.
  prefs: []
  type: TYPE_NORMAL
- en: The app bar layout enables toolbar animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An app bar layout is a type of vertical linear layout that’s designed to work
    with app bars. It works with the coordinator layout to enable toolbar animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You add an app bar layout to your code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0366-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the above app bar layout code includes an `android:theme` attribute
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This applies the specified style to the app bar layout and all of its views.
    In this example, it means that the toolbar—and anything else we add to the app
    bar layout—will be styled to use the Material theme’s app bar properties, including
    the color of its background and text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now your toolbar is animated and can respond to scroll events. But that’s
    not the end of the story: you also need to specify how it should respond. Let’s
    see how this is done.'
  prefs: []
  type: TYPE_NORMAL
- en: Tell the toolbar how to respond to scroll events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you’ve added an app bar layout, you tell the toolbar how to respond to
    scrolls by adding an app:layout_scrollFlags attribute to the toolbar and assigning
    a value to it. The value specifies how the toolbar should respond to scroll events.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Bits and Pizzas app, we want the toolbar to scroll upward off the screen
    when the user scrolls up, and quickly return to its original position when the
    user scrolls down. We can achieve this by setting the toolbar’s `app:layout_scrollFlags`
    attribute to `"scroll|enterAlways"` using code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The toolbar MUST be inside an app bar layout in order for it to scroll. The
    app bar layout and coordinator layout work together to enable scrolling.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](Images/f0367-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'specifies two behaviors: `scroll` and `enterAlways`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `scroll` value means that the view can scroll off the top of the screen
    when the user scrolls up. Without this value, the toolbar would stay pinned to
    the top of the screen and wouldn’t be able to scroll.
  prefs: []
  type: TYPE_NORMAL
- en: The `enterAlways` value means that the toolbar quickly scrolls down to its original
    position when the user scrolls down. The toolbar would still scroll down without
    this value, but it would be much slower.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re almost there! There’s just one more step you need to do before we can
    get the `OrderFragment` toolbar to scroll: the **nested scroll view**.'
  prefs: []
  type: TYPE_NORMAL
- en: A nested scroll view makes layout content scrollable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now need to add a **nested scroll view** so the layout’s main content can
    scroll. This kind of view works just like a normal scroll view, except that it
    enables *nested* scrolling. This is important, because the coordinator layout
    *only listens for nested scroll events*. If you use a normal scroll view in your
    layout, the toolbar won’t be able to respond when the user scrolls the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another view that enables nested scrolling is the recycler view. You’ll learn
    about this view in [Chapter 14](ch14.xhtml#room_databasescolon_room_with_a_view).
  prefs: []
  type: TYPE_NORMAL
- en: 'You add a nested scroll view to your layout using code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0368-02.png)'
  prefs: []
  type: TYPE_IMG
- en: In the above example, the nested scroll view includes an extra attribute named
    `app:layout_behavior`, which is set to the built-in `String` value `"@string/appbar_scrolling_view_behavior"`.
    This makes sure that the contents of the nested scroll view are arranged below
    the app bar layout, and move when it scrolls.
  prefs: []
  type: TYPE_NORMAL
- en: Note that **a nested scroll view can only have one direct child**, which, in
    the example above, is a text view. If you want to add more than one view to a
    nested scroll view, you must first add them to a view group—such as a linear layout—and
    then add the view group to the nested scroll view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You’ll see an example of this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: That’s everything that we need to know in order to get the Bits and Pizzas toolbar
    to scroll, so let’s go ahead and update `OrderFragment`’s layout.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for fragment_order.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the full code for *fragment_order.xml*; update the code to include the
    changes below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0369-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0370-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the app, `OrderFragment` is displayed in `MainActivity`’s layout.
    A toolbar is displayed at the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: When we scroll the screen up, the toolbar scrolls upward off the top of the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0370-02.png)'
  prefs: []
  type: TYPE_IMG
- en: When we scroll the main content down, the toolbar reappears.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0370-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You’ve now learned how to create a toolbar that responds to
    scrolls.
  prefs: []
  type: TYPE_NORMAL
- en: After the following exercise, we’re going to learn how to turn the scrolling
    toolbar into one that collapses and expands as the user scrolls the screen.
  prefs: []
  type: TYPE_NORMAL
- en: BE the Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common04.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Below is the layout file for a fragment named MyFragment. Your job is to
    play like you’re the layout, and change the code so that when the user scrolls
    the screen up, the toolbar scrolls off the screen, and when they scroll down,
    it quickly reappears.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0371-01.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the Layout Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common04.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Below is the layout file for a fragment named MyFragment. Your job is to
    play like you’re the layout, and change the code so that when the user scrolls
    the screen up, the toolbar scrolls off the screen, and when they scroll down,
    it quickly reappears.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0372-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s create a collapsing toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0373-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you know how to make a toolbar scroll off the screen, let’s replace
    it with a slightly different type of toolbar: a **collapsing toolbar**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A collapsing toolbar is a toolbar that starts off large, shrinks when the user
    scrolls the screen up, and expands again when the user scrolls the screen back
    down. You can even add an image to it, which disappears when the toolbar reaches
    its minimum height, and becomes visible again as the toolbar expands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0373-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Over the next few pages, we’re going to find out how to turn a simple toolbar
    into a collapsing toolbar by adding one to `OrderFragment`’s layout. We’ll start
    with a plain collapsing toolbar first, and then create one that includes an image.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to create a plain collapsing toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s relatively straightforward to turn a scrolling toolbar into a collapsing
    toolbar. You simply wrap the toolbar in a **collapsing toolbar layout**, and tweak
    the toolbar attributes. The basic code structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0374-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the collapsing toolbar layout is defined using the `<...CollapsingToolbarLayout>`
    element, part of the *com.google.android.material* library. You specify its maximum
    height using its `layout_height` attribute, and the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0374-03.png)'
  prefs: []
  type: TYPE_IMG
- en: tells it to collapse when the user scrolls up until it has nothing left to collapse,
    and expand when the user scrolls down until it reaches its full height.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to make sure that when the toolbar collapses, anything that’s
    displayed on the toolbar—like the Up button and any menu items—stay on the screen.
    This is achieved by adding the following attribute to the `Toolbar` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0374-04.png)'
  prefs: []
  type: TYPE_IMG
- en: How to add an image to a collapsing toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you’ve created a plain collapsing toolbar, you can add an image to it
    by adding an <`ImageView>` to the collapsing toolbar layout, specifying the image
    you want to use. The code follows this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0375-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'which has been added to the `<...CollapsingToolbarLayout>` gives the toolbar
    a plain background color when it’s collapsed. We’ve also added a parallax animation
    to the image using this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This attribute is optional: it makes the image scroll at a different rate to
    the rest of the toolbar.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned about collapsing toolbars, let’s add one to `OrderFragment`’s
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Add a restaurant image drawable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want `OrderFragment`’s collapsing toolbar to include a restaurant image,
    so let’s start by adding it to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that your project includes a folder named *app/src/main/res/drawable*,
    then download the file *restaurant.webp* from *tinyurl.com/hfad3*, and add it
    to the *drawable* folder. This includes the image in your project as a drawable
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add the collapsing toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0376-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The full code for fragment_order.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code below adds a collapsing toolbar to `OrderFragment`’s layout. Update
    your code for *fragment_order.xml* to include the changes (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0376-03.png)![image](Images/f0377-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Those are all the changes that we need to create the collapsing toolbar. Let’s
    take the app for a test drive, and see what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0378-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the app, `OrderFragment` is displayed. It includes a collapsing
    toolbar with an image.
  prefs: []
  type: TYPE_NORMAL
- en: When we scroll up, the toolbar collapses, the image fades, and the toolbar’s
    background changes to the app’s primary color. When we scroll down, the toolbar
    expands, and the image reappears.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0378-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Layout Magnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  prefs: []
  type: TYPE_IMG
- en: Someone arranged some magnets on the fridge door to show how to structure a
    layout file that implements a collapsing toolbar with an image. Unfortunately,
    the magnets fell off when a large pterodactyl flew by in search of food.
  prefs: []
  type: TYPE_NORMAL
- en: See if you can put the magnets back in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0379-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Answers in [“Layout Magnets Solution”](#layout_magnets_solution-id00147).**'
  prefs: []
  type: TYPE_NORMAL
- en: We need to build OrderFragment’s main content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we’ve added a collapsing toolbar to `OrderFragment`’s layout, we need
    to add some more views. These will let the user choose which type of pizza she
    wants to order, add any extra options such as parmesan or chili oil, and display
    a message when she clicks a button. The screen needs to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0380-01.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, `OrderFragment`’s layout includes some extra views that we haven’t
    yet learned how to use. Before we build the layout, let’s find out more about
    these views.
  prefs: []
  type: TYPE_NORMAL
- en: Choose a pizza type using a radio button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0381-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The first view we’ll use is a group of **radio buttons** so that the user can
    choose which type of pizza she wants. Radio buttons let you display multiple options
    from which you make a single choice, so they’re a good choice for this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You add radio buttons to a layout using two elements: `<RadioButton>` and `<RadioGroup>`.
    You use the `<RadioButton>` element to define each radio button, and you group
    them by putting them inside a `<RadioGroup>` element. Placing the radio buttons
    in a radio group in this way means that only a single radio button can be selected
    at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0381-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Bits and Pizzas app, we want to display radio buttons for the Diavolo
    and Funghi buttons. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0381-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you’ve defined the radio group and radio buttons, you can write Kotlin
    code to find out which radio button has been selected using the radio group’s
    `checkedRadioButtonId` property. Its value is the ID of the selected radio button,
    or -1 if no radio button has been selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0381-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '**RadioGroup is a subclass of LinearLayout, so you can use the same attributes
    with a radio group as you can with a linear layout.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Radio buttons are a type of compound button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behind the scenes, radio buttons inherit from a class named `CompoundButton`:
    a subclass of `Button`. A compound button is a button that has two states: checked
    and unchecked, or on and off.'
  prefs: []
  type: TYPE_NORMAL
- en: Android includes other types of compound button (in addition to radio buttons),
    such as **checkboxes**, **switches,** and **toggle buttons**. These views are
    useful if you want to offer the user yes/no choices, such as “Do you want chili
    oil?” or “Would you like extra parmesan?”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0382-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You add checkboxes, switches, and toggle buttons to your layout using code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0382-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can then use each view’s `isChecked` property in your Kotlin code to find
    out if it has been selected, as in the example code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0382-03.png)'
  prefs: []
  type: TYPE_IMG
- en: A chip is a type of flexible compound button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you’ve seen how to use different types of compound buttons such as
    radio buttons, checkboxes and switches. A more flexible type of compound button
    is a **chip**. This is a material view that’s available so long as you’re using
    a theme from the Material library, for example `Theme.MaterialComponents.DayNight.NoActionBar`.
    It’s used for making yes/no choices like other types of compound button, but it
    has other uses too: it can also be used for user input, filtering data and performing
    actions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0383-02.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Bits and Pizzas app, we’re going to use chips to let the user say whether
    she wants extra parmesan or chili oil on her pizza.
  prefs: []
  type: TYPE_NORMAL
- en: 'You add a chip to your layout using code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0383-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The key part of the chip code is the `style` attribute, because this controls
    the chip’s appearance. The code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: in the above example styles the chip as a Choice so that its color changes when
    its selected. Other options are Entry (which lets you use chips for data input),
    Filter (which is used for chips that filter content), and Action (which acts like
    a button).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the Entry, Filter, and Action chips look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0383-04.png)'
  prefs: []
  type: TYPE_IMG
- en: As well as adding single chips to your layout, you can group several chips together.
    Let’s find out how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Add multiple chips to a chip group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0384-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want your layout to include multiple chips that are grouped together,
    you can add them to a **chip group**. A chip group is a type of view group that’s
    designed to neatly arrange multiple chips.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Bits and Pizzas app, we want to use two chips: one for parmesan and
    another for chili oil. We’ll therefore group them in a chip group using code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0384-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Use isChecked to find out if a chip is checked
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you’ve added chips to your layout, you can find out if a chip has been
    selected using each chip’s `isChecked` property, just as you can with other types
    of compound button such as switches, toggle buttons, and checkboxes. The following
    code, for example, checks whether the *parmesan* chip has been selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A FAB is a floating action button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s one final view we need to learn about before we can complete `OrderFragment`’s
    layout: a **FAB**.'
  prefs: []
  type: TYPE_NORMAL
- en: A FAB—or **floating action button**—is a circular button that floats above the
    user interface. It’s used to draw attention to common or important actions, and
    just like a normal button, you can make a FAB respond to clicks by assigning an
    `OnClickListener` to it in your Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0385-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You add a FAB to your layout using code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0385-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The above code uses the `layout_gravity` attribute to anchor a FAB to the bottom-end
    corner of the device screen with a margin of 16dp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: adds an icon to the FAB. In the above example, it displays one of Android’s
    built-in icons named *ic_menu_send*, but you can use any kind of drawable so long
    as it fits on the FAB.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When you add a src attribute to a FAB, the code editor lets you browse Android’s
    built-in icons. If you don’t like any of them, you can find lots more here: [https://material.io/resources/icons](https://material.io/resources/icons)'
  prefs: []
  type: TYPE_NORMAL
- en: You usually use a FAB inside a coordinator layout so that you can coordinate
    movement between the different views in your layout. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: You can anchor a FAB to a collapsing toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FABs are often positioned at the bottom-end corner of the screen, but you can
    also anchor one to another view such as a collapsing toolbar. When you do this,
    the FAB moves with the collapsing toolbar as it collapses and expands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0386-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The layout code for this is shown below. As you can see, it uses the FAB’s
    `app:layout_anchor` and `app:layout_anchorGravity` attributes to anchor the FAB
    to the bottom end of the collapsing toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0386-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve learned about radio buttons, chips, FABs, and other views, let’s
    build the main content for `OrderFragment`’s layout.
  prefs: []
  type: TYPE_NORMAL
- en: We need to build OrderFragment’s layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add views to `OrderFragment`’s layout so that the user can order
    a pizza type, and request any extras. The layout needs to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0387-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You’re already familiar with all the code that’s needed to create this layout,
    so let’s go and update *fragment_order.xml*. We’ll show you the full code over
    the next few pages.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for fragment_order.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the complete code for `OrderFragment`’s layout. Update the code for
    file *fragment_order.xml* so that it includes the changes below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0388-02.png)![image](Images/f0389-02.png)![image](Images/f0390-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s all the layout code we need, so let’s take the app for a test drive and
    see what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0391-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the app, `OrderFragment` is displayed in `MainActivity`. It includes
    a collapsing toolbar as before, but this time the main content features text views,
    radio buttons, chips, and a FAB.
  prefs: []
  type: TYPE_NORMAL
- en: When we scroll the device screen, the main content scrolls upward and the toolbar
    collapses. The FAB remains fixed in the bottom-end corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0391-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s make the FAB respond to clicks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0392-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve now built `OrderFragment`’s layout, but when the user clicks on the FAB,
    nothing happens. Let’s update the fragment’s Kotlin code so that the FAB responds
    to clicks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll make the FAB do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Display a message if no pizza has been chosen.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need the user to select which type of pizza she wants. If she clicks the
    FAB *without* choosing one, we’ll display a pop-up message (called a **toast**)
    telling them to choose a pizza.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0392-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Display their order in a separate message.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user has selected a type of pizza, we’ll display a message telling them
    what she has ordered. We’ll use a different type of pop-up message for this called
    a **snackbar**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: In the real world, you’d want the app to place the pizza order when the user
    clicks on the FAB. Here, we just want to make the FAB do something (and it’s a
    good excuse for teaching you about pop-up messages).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0392-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s begin by making the FAB respond to clicks.
  prefs: []
  type: TYPE_NORMAL
- en: Add an OnClickListener to the FAB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0393-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we said earlier, you make a FAB respond to clicks in the same way that you
    make any other type of button respond to clicks: by attaching an `OnClickListener`
    to the FAB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code to add an `OnClickListener` to the FAB in `OrderFragment`;
    as you can see, it looks the same as the code you’ve used with plain old normal
    buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0393-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let’s get the `OnClickListener` to display a message if the user hasn’t
    selected a type of pizza.
  prefs: []
  type: TYPE_NORMAL
- en: Find out if a pizza type has been selected
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can find out whether the user has selected a pizza type using the `checkedRadioButtonId`
    property of the `pizzas_group` radio group. The property’s value is the ID of
    the selected radio button if one has been selected, and -1 if the user hasn’t
    made a choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code to check whether the user has clicked the FAB without choosing
    which type of pizza she wants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0393-03.png)'
  prefs: []
  type: TYPE_IMG
- en: If the user hasn’t selected a type of pizza, we want to display a message in
    a pop-up message called a **toast**. Let’s find out how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: A toast is a simple pop-up message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the user clicks on the FAB without first choosing a pizza type, we’re going
    to display a toast on the device screen. A toast is a simple pop-up message that
    gives the user information, and automatically disappears when it times out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0394-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You create a toast by calling `Toast.makeText()`. The `makeText` method takes
    three parameters: a `Context` (usually `this` or `activity`, depending on whether
    you’re calling the toast from an activity or a fragment), a `CharSequence!` that’s
    the message you want to display, and a duration. You then call the toast’s `show()`
    method to display it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some example code that displays a message in a toast that appears on
    screen for a short duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0394-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Add a toast to the FAB OnClickListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to display a toast when the user clicks on the FAB without choosing
    a pizza type. The code to do this is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0394-04.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s everything we need to do if the user hasn’t selected a pizza type. Next,
    let’s write the code to display their order.
  prefs: []
  type: TYPE_NORMAL
- en: Display the pizza order in a snackbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the user has chosen a pizza type, we’re going to display their order in a
    pop-up message called a **snackbar** when she clicks on the FAB. A snackbar is
    like a toast, except that it’s more interactive. You can swipe a snackbar away,
    for example, or make it do something if it’s clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'You create a snackbar by calling `Snackbar.make()`. The `make` method takes
    three parameters: the `View` that triggered the snackbar (in this case a FAB),
    a `CharSequence!` that’s the text you want to display, and a duration. You then
    display the snackbar by calling its `show()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0395-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s some example snackbar code that displays a message on the screen for
    a short time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0395-03.png)'
  prefs: []
  type: TYPE_IMG
- en: In the above code, we’ve used `LENGTH_SHORT` to show the snackbar for a short
    period of time. Other options are `LENGTH_LONG` (which shows it for a long duration)
    and `LENGTH_INDEFINITE` (which shows it indefinitely).
  prefs: []
  type: TYPE_NORMAL
- en: Snackbars can have actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want, you can add an action to the snackbar so that the user can, say,
    undo an action she’s just performed. You do this by calling the snackbar’s `setAction()`
    method before calling `show()`. `setAction` takes two parameters: the text that
    should appear for the action, and a lambda that runs when the user clicks on the
    action.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of some snackbar code that includes an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0395-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Snackbars are usually displayed at the bottom of the screen, but you can override
    this using the snackbar’s `setAnchorView()` method. This anchors the snackbar
    to a particular view so that the snackbar appears above it. This is useful if,
    for example, you want the snackbar to appear above a bottom navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0395-05.png)'
  prefs: []
  type: TYPE_IMG
- en: The snackbar code for the pizza order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to create a snackbar, let’s write the code to display
    the user’s pizza order. We’ll show a snackbar that displays the pizza type the
    user has selected, along with any extras such as parmesan or chili oil.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0396-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the code to display the snackbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0396-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s all the Kotlin code we need for the Bits and Pizzas app. Let’s look at
    the full code for *OrderFragment.kt* and take the app for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for OrderFragment.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the full code for *OrderFragment.kt*; update the code to include the
    changes below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0397-02.png)![image](Images/f0398-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we click on the FAB without selecting a pizza type, a toast is displayed
    asking us to choose a pizza.
  prefs: []
  type: TYPE_NORMAL
- en: When we select a pizza type and click on the FAB again, a snackbar appears at
    the bottom of the screen giving details of our order.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0398-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You’ve now learned how to make the FAB respond to clicks by
    displaying a pop-up message.
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **goal** is to complete the fragment code below so that when a FAB with
    an ID of `fab` is clicked, it displays a snackbar. The snackbar should include
    an action, “Undo”, which shows a toast when clicked. Take code snippets from the
    pool and place them into the blank lines in the code. You may **not** use the
    same snippet more than once, and you won’t need to use all the snippets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0399-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Note: each thing from the pool can only be used once!**'
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **goal** is to complete the fragment code below so that when a FAB with
    an ID of `fab` is clicked, it displays a snackbar. The snackbar should include
    an action, “Undo”, which shows a toast when clicked. Take code snippets from the
    pool and place them into the blank lines in the code. You may **not** use the
    same snippet more than once, and you won’t need to use all the snippets.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0400-01.png)![image](Images/f0400-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Layout Magnets Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  prefs: []
  type: TYPE_IMG
- en: Someone arranged some magnets on the fridge door to show how to structure a
    layout file that implements a collapsing toolbar with an image. Unfortunately,
    the magnets fell off when a large pterodactyl flew by in search of food.
  prefs: []
  type: TYPE_NORMAL
- en: See if you can put the magnets back in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0401-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your Android Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/tools.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You’ve got [Chapter 9](#material_viewscolon_a_material_world) under your
    belt and now you’ve added more views and components to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0402-01.png)'
  prefs: []
  type: TYPE_IMG
