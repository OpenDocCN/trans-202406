- en: Chapter 7\. Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we go into detail about Linux networking. In modern environments,
    the network stack that Linux provides is an essential component. Without it, few
    things are possible. Whether you want to access an instance in your cloud provider,
    browse the web, or install a new app, you need connectivity, and you need a way
    to interact with it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first have a look at common network terms, from the hardware level all
    the way up to user-facing components such as HTTP and SSH. We’ll also discuss
    the network stack, protocols, and interfaces. Specifically, we’ll spend time on
    the naming center piece of the web and the wider internet, the so-called Domain
    Name System (DNS). Interestingly, this system is found not only in wide-area deployments
    but is also a central component used for service discovery in container environments
    such as Kubernetes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at application layer network protocols and tooling. This includes
    file sharing, the web, networked filesystems, and other methods to share data
    over the network.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of the chapter, we’ll review some advanced network topics,
    from geomapping to managing time over the network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the expectations for the content in this chapter: you can spend a lot
    of time with the topic of Linux networking; in fact, entire books are dedicated
    to the topic. We’ll take a pragmatic stance here, jumping into hands-on topics
    from an end-user point of view. Admin topics around networking, such as configuration
    and setup of network devices, are by and large out of scope here.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s turn our attention to the networking basics.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s first discuss why networking is relevant for a number of use cases and
    define some common network terminology.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In modern environments, networking plays a central role. This ranges from tasks
    such as installing apps, browsing the web, and viewing mail or social media to
    working with remote machines (from the embedded system you’re connecting to over
    a local network to servers that run in data centers of your cloud providers).
    Given a network’s many moving parts and layers, it can be difficult to figure
    out if a problem is hardware-related or originates in the software stack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Another challenge Linux networking addresses comes from abstractions: many
    of the things we’ll cover in this chapter provide a high-level user interface,
    making it appear that files or applications that in reality run on a remote machine
    are accessible or can be manipulated on your local machine. While providing an
    abstraction that makes remote resources seem to be local is a useful feature,
    we should not forget that at the end of the day, all of this boils down to bits
    traveling over the wire and through the air. Keep this in mind when troubleshooting
    or testing.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](#fig-net-overview) shows how, on a high level, networking works
    in Linux. There is some kind of networking hardware, such as Ethernet or wireless
    cards; then a number of kernel-level components, such as the TCP/IP stack; and
    finally, in the user space, a range of tools to configure, query, and use networking.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0701](Images/lmlx_0701.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. An overview of Linux networking
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s now dive into the TCP/IP stack, the core of networking in Linux.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike in other areas of Linux, where you need to either consult the source
    code or hope for properly documented design assumptions behind interfaces and
    protocols, in the networking space, almost every protocol and interface is based
    on publicly available specifications. The Internet Engineering Task Force (IETF)
    makes all of those requests for comments (RFCs) freely available via [*data​tracker.ietf.org*](https://datatracker.ietf.org).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Make a habit out of simply reading these RFCs before you get into the details
    of implementations. Those RFCs are written by practitioners for practitioners
    and document good practices and how to implement stuff. Don’t be afraid of working
    through them; you’ll gain a much better understanding about the motivation, use
    cases, and reasons why things are the way they are.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP Stack
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TCP/IP stack, shown in [Figure 7-2](#fig-tcpip-stack), is a layered network
    model made of a number of protocols and tools, mostly defined by IETF specs. Each
    layer must be aware of and able to communicate with only the layers right above
    and below itself. The data is encapsulated in packets, and each layer typically
    wraps the data in a header that contains information relevant for its function.
    So, if an app wants to send data, it would interact directly with the highest
    layer that would add a header and so on down the stack (the send path). Conversely,
    if an app wants to receive data, it would arrive at the lowest layer, and each
    layer in turn would process it based on the header information it finds and pass
    the payload on to the layer above (the receive path).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0702](Images/lmlx_0702.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. The TCP/IP layers working together to enable communication
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Starting at the bottom of the stack, the four layers of the TCP/IP stack are
    the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The link layer
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Lowest in the stack, this layer covers the hardware (Ethernet, WiFi) and kernel
    drivers and focuses on how packets are sent between physical devices. See [“The
    Link Layer”](#tcp-link) for details.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The internet layer
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: With the Internet Protocol (IP), this layer focuses on routing; that is, it
    supports sending packets between machines across networks. We’ll discuss it in
    [“The Internet Layer”](#tcp-internet).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: This layer controls end-to-end communications between (virtual or physical)
    hosts, with the Transmission Control Protocol (TCP) for session-based, reliable
    communication and User Datagram Protocol (UDP) for connection-less communication.
    It mainly deals with how packets are transmitted, including addressing individual
    services on a machine via ports as well as data integrity. Further, Linux supports
    sockets as communication endpoints. See [“The Transport Layer”](#tcp-transport).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The application layer
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: This layer deals with user-facing tooling and apps, such as the web, SSH, and
    mail. We’ll discuss it in [“DNS”](#dns) and [“Application Layer Networking”](#app-layer-net).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The layering means that the header and the payload of a layer make up the payload
    for the next layer. For example, looking at [Figure 7-2](#fig-tcpip-stack), the
    payload in the internet layer is the transport layer header H[T] and its payload.
    In other words, the internet layer takes the packet it gets from the transport
    layer, treats it as an opaque chunk of bytes, and can focus on its function, the
    routing of the packet to the target machine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now work our way up the TCP/IP stack, starting with the lowest layer,
    the link layer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The Link Layer
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the link layer of the TCP/IP stack, it’s all about hardware or near-hardware
    stuff, such as bytes, wires, electromagnetic waves, device drivers, and network
    interfaces. You’ll come across the following terms in this context:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Ethernet
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: A family of networking technologies using wires to connect machines; often used
    in local area networks (LANs).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Wireless
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Also known as WiFi, a class of communication protocols and methods that, rather
    than using wires, uses some electromagnetic waves to transport data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: MAC addresses
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Short for *media access control*, MAC is a unique 48-bit identifier for hardware,
    used to identify your machine (to be precise, the network interface; see the following
    term). The MAC address encodes the manufacturer (of the interface) via the organizationally
    unique identifier (OUI), usually occupying the first 24 bits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: A network connection. It can be a physical interface (see [“Network interface
    controller”](#nic) for details) or a virtual (software) interface, like the loopback
    interface `lo`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with these basics, let’s have a closer look at the link layer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Network interface controller
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One essential piece of hardware equipment is the [*network interface controller*
    (NIC)](https://oreil.ly/fZeVJ), sometimes also called the *network interface card*.
    The NIC provides the physical connectivity to a network through either a wired
    standard—for example, the [IEEE 802.3-2018 standard for Ethernet](https://oreil.ly/9g4Mu)—or
    one of the many wireless standards from the [IEEE 802.11 family](https://oreil.ly/V5NiL).
    Once part of a network, the NIC turns the digital representation of the bytes
    you want to send into electrical or electromagnetic signals. The reverse is true
    for the receive path, where the NIC turns whatever physical signals it receives
    into bits and bytes that the software can deal with.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at NICs in action. Traditionally, one would use the (now
    widely considered deprecated) [`ifconfig` command](https://oreil.ly/QwgOc) to
    query information on the NICs available on the system (we show it here first for
    educational purposes; in practice, it’s better to use `ip`, as shown in the next
    example):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_networking_CO1-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The first interface here is `lo`, the loopback interface with the IP address
    `127.0.0.1` (see [“IPv4”](#ipv4)). The maximum transmission unit (MTU) is the
    packet size, here 65,536 bytes (with larger sizes meaning higher throughput);
    for historical reasons, the default for Ethernet was 1,500 bytes, but you can
    use [jumbo frames](https://oreil.ly/NjpnF) that are 9,000 bytes in size.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO1-2)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The second interface reported is `wlp1s0`, with an IPv4 address of `192.168.178.40`
    assigned. This interface is an NIC and has a MAC address (`ether` is `38:de:ad:37:32:0f`).
    When looking at the flags (`<UP,BROADCAST,RUNNING,MULTICAST>`), it seems to be
    operational.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more modern approach of doing the same thing (querying interfaces and
    checking on their status), use the [`ip` command](https://oreil.ly/pruUF). We’ll
    use this approach most often in this chapter (output edited to fit):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#custom_co_networking_CO2-1)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The loopback interface.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#custom_co_networking_CO2-2)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'My NIC, with a MAC address of `38:de:ad:37:32:0f`. Note that the name (`wlp1s0`)
    here tells you something about the interface: it’s a wireless interface (`wl`)
    in PCI bus 1 (`p1`) and slot 0 (`s0`). This naming makes the interface names more
    predictable. In other words, if you had two old-style interfaces (say, `eth0`
    and `eth1`), there was no guarantee that a reboot or adding a new card wouldn’t
    cause Linux to rename those interfaces.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: For both `ifconfig` and `ip link`, you might be interested in the meaning of
    flags such as `LOWER_IP` or `MULTICAST`; these are documented in the [netdevice
    man pages](https://oreil.ly/OTB7R).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Address Resolution Protocol
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Address Resolution Protocol (ARP) maps MAC addresses to IP addresses. In
    a sense, it bridges the link layer with the layer above it, the internet layer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_networking_CO2-1)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Use the `arp` command to show the cache of mapping MAC addresses to hostnames
    or IP addresses. Note that you can use `arp -n` to prevent hostname resolution
    and show IP addresses instead of DNS names.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, using a more modern approach with `ip`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_networking_CO3-1)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ip` command to show the cache of mapping MAC addresses to IP addresses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'To display, configure, and troubleshoot wireless devices, you want to use the
    [`iw` command](https://oreil.ly/fyR0y). For example, I know that my wireless NIC
    is called `wlp1s0`, so I can query it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_networking_CO4-1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Show base information about wireless interface `wlp1s0`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO4-2)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The router the interface is connected to (see also the next example).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO4-3)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The WiFi frequency band the interface is using.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, I can gather router- and traffic-related information like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_networking_CO5-1)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Show connection information about wireless interface `wlp1s0`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO5-2)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: This and the next line send (`TX` stands for “transmit”) and receive (`RX`)
    statistics—that is, bytes and packets sent and received via this interface.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good handle on what’s going on in the lowest layer of the
    TCP/IP stack, the (data) link layer, let’s move up the stack.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The Internet Layer
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second-lowest layer of the TCP/IP stack, the internet layer, is concerned
    with routing packets from one machine on the network to another. The design of
    the internet layer assumes that the available network infrastructure is unreliable
    and that the participants (such as nodes in the network or the connections between
    them) change frequently.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The internet layer provides best-effort delivery (that is, no guarantees concerning
    performance) and treats every packet as independent. As a consequence, higher
    layers, typically the transport layer, take care of addressing reliability issues,
    including packet order, retries, or delivery guarantees.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: In this layer, the dominating protocol for logically identifying machines uniquely,
    worldwide, is the Internet Protocol (IP), which comes in two flavors, IP version
    4 (IPv4) and IP version 6 (IPv6).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: IPv4
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IPv4 defines unique 32-bit numbers identifying a host or process acting as an
    endpoint in a TCP/IP communication.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to write IPv4 addresses is to split up the 32-bit into four 8-bit segments
    separated by a period, each segment in the 0 to 255 range, called an *octet* (hinting
    at that the segment covers 8 bits). Let’s have a look at a concrete example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_networking_CO6-4)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'First octet in binary form: `00111111`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO6-3)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Second octet in binary form: `00100000`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO6-2)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Third octet in binary form: `01101010`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO6-1)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Fourth octet in binary form: `10010101`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The IP header ([Figure 7-3](#fig-ip-header)), as defined in [RFC 791](https://oreil.ly/7u93r)
    and related IETF specs, has a number of fields, but the following are the most
    important ones that you should be aware of:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Source address (32 bits)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The IP address of the sender
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Destination address (32 bits)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The IP address of the receiver
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Protocol (8 bits)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The payload type (next-higher layer type), as per [RFC 790](https://oreil.ly/Y8PPz)—for
    example, TCP, UDP, or ICMP
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Time to live, aka TTL (8 bits)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The maximal time the packet is allowed to exist
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Type of service (8 bits)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Can be used for quality of service (QoS) purposes
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0703](Images/lmlx_0703.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. The IP header format as per RFC 791
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Given that the internet is a network of networks, it seems natural to distinguish
    between networks and single machines (hosts) in the networks. IP address ranges
    are assigned to networks and within those networks to individual hosts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, the [Classless Inter-Domain Routing (CIDR)](https://oreil.ly/VDVuy)
    is the only relevant method for assigning IP addresses. The CIDR format consists
    of two parts:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The first part represents the network address. This looks like a normal IP address—for
    example, `10.0.0.0`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part defines how many bits (and with that, IP addresses) fall within
    the address range—for example, `/24`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, a complete CIDR range example looks like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the first 24 bits (or three octets) represent the
    network, and the last 8 bits (32 bits overall minus the 24 bits for the network)
    are the IP addresses available for the 256 hosts (2⁸). The first IP address in
    this CIDR range is `10.0.0.0`, and the last IP address is `10.0.0.255`. Strictly
    speaking, only the addresses `10.0.0.1` to `10.0.0.254` can be assigned to hosts
    since the `.0` and `.255` addresses are reserved for special purposes. In addition,
    we can say that the netmask is `255.255.255.0` since that’s the first 24 bits
    representing the network.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, you don’t need to remember all the math here. If you’re dealing
    with CIDR ranges on a daily basis, then you just know, and if you’re a casual
    user, you may want to use some tooling. If you want to do CIDR range calculations,
    such as determining how many IPs are in a range, the following are available:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Online tools such as those at [*https://cidr.xyz*](https://cidr.xyz) and [*https://ipaddressguide.com/cidr*](https://ipaddressguide.com/cidr)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line tools like [mapcidr](https://oreil.ly/2uTwU) and [cidrchk (by yours
    truly)](https://oreil.ly/g88Yk)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also some notable [reserved IPv4 addresses](https://oreil.ly/97Tp7)
    you should know:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '`127.0.0.0`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: This subnet is reserved for local addresses, with the most prominent one being
    the loopback address `127.0.0.1`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '`169.254.0.0/16` (`169.254.0.0` to `169.254.255.255`)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: These are link local addresses, meaning packets sent there should not be forwarded
    to other parts of the network. Some cloud providers such as Amazon Web Services
    use this for special services (metadata).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`224.0.0.0/24` (`224.0.0.0` to `239.255.255.255`)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: This range is reserved for multicast.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[RFC 1918](https://oreil.ly/2Ijxk) defines private IP ranges. A private IP
    range means that the IP addresses in it are not routable on the public internet;
    hence, it is safe to assign them internally (for example, in the context of your
    company):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '`10.0.0.0` to `10.255.255.255` (the `10/8` prefix)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`172.16.0.0` to `172.31.255.255` (`172.16/12` prefix)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.0.0` to `192.168.255.255` (`192.168/16` prefix)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another interesting IPv4 address is `0.0.0.0`. It is a nonroutable address that
    has different use cases and different meanings depending on the context, but the
    most important one, from a server perspective, is that `0.0.0.0` refers to all
    IPv4 addresses present in the machine. That’s a great way to say “listen on all
    available IP addresses” as a source until it turns into a known IP.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'That was a lot of dry theory; let’s see it in action. We’ll start by querying
    the machine for IP-related things (output edited):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_networking_CO7-1)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: List addresses of all interfaces.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO7-2)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The IP address of the loopback interface (`127.0.0.1`, as expected).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO7-3)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The (private) IP address of the wireless NIC. Note that this is the LAN-local
    IP address of the machine, which isn’t publicly routable since it falls in the
    `192.168/16` range.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The IPv4 address space is already exhausted, and given that there are many more
    endpoints today than the internet designers thought there would be (for example,
    due to mobile devices and IoT), a sustainable solution is needed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, with IPv6 there is a solution for the address-exhaustion issue. Unfortunately,
    at this time of writing, the ecosystem at large has still not made the move to
    IPv6, partly for infrastructure reasons but also due to a lack of tooling that
    supports IPv6\. This means that for the time being you’ll still have to deal with
    IPv4 and its limitations and [workarounds](https://oreil.ly/XSiTu).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the (hopefully not-to-distant) future: IPv6.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: IPv6
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Internet Protocol version 6 (IPv6)](https://oreil.ly/T0ISm) is a 128-bit number
    identifying an endpoint in a TCP/IP communication. This means that with IPv6 we
    can assign on the order of 10^(38) individual machines (devices). In contrast
    to IPv4, IPv6 uses a hexadecimal representation, eight groups of 16 bits each,
    separating the groups by a colon (`:`).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: There are a few rules for shortening IPv6 addresses, such as removing leading
    zeros or compressing consecutive sections of zeros by replacing them with two
    colons (`::`). For example, the IPv6 [loopback address](https://oreil.ly/mGfiU)
    can be written abbreviated as `::1` (the IPv4 variant would be `127.0.0.1`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Just like IPv4, IPv6 has a number of special and reserved addresses; see APNIC’s
    listing of [IPv6 address types](https://oreil.ly/isoL1) for examples.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that IPv4 and IPv6 are not compatible. This means that
    IPv6 support needs to be built into each and every network participant, from edge
    devices (like your phone) to routers to server software. This IPv6 support has,
    at least in the context of Linux, already shown to be pretty wide. For example,
    the `ip addr` command we saw in the section [“IPv4”](#ipv4) would already by default
    show us the IPv6 addresses.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Internet Control Message Protocol
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [RFC 792](https://oreil.ly/6Nphe) defines the Internet Control Message Protocol
    (ICMP), which is used for lower-level components to send error messages and operational
    information like availability.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see ICMP in action by testing the reachability of a website with `ping`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Alternatively, you can use [`gping`](https://oreil.ly/1Y5qv), which can ping
    multiple targets at the same time and plot a graph on the command line (see [Figure 7-4](#fig-gping)).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0704](Images/lmlx_0704.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Pinging two websites with `gping`
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that an equivalent tool is available for IPv6: the aptly named [`ping6`](https://oreil.ly/F6q6B).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Part of the network stack in Linux is concerned with routing—that is, deciding
    on a per-packet basis where to send a packet. The destination could be a process
    on the same machine, or it could be an IP address on a different machine.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'While the exact implementation details of routing are beyond the scope of this
    chapter, we’ll provide a high-level overview: [iptables](https://oreil.ly/roRsv),
    a widely used tool that allows you to manipulate the routing tables—for example,
    to reroute packets on certain conditions or implement a firewall—uses [netfilter](https://www.netfilter.org)
    to intercept and manipulate packets.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'What you should know is how to query and display routing information, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_networking_CO8-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Use the `route` command with `-n`, forcing numerical IP addresses.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The detailed meaning of the tabular output in the previous `route` command
    is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`Destination`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The IP address of the destination; `0.0.0.0` means it’s unspecified or unknown,
    potentially sending it to the gateway.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '`Gateway`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: For packets not on the same network, the gateway address.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '`Genmask`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The subnet mask used.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '`Flags`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '`UG` means the network is up and is a gateway.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`Iface`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The network interface the packet is going to use.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'A modern way is using `ip` like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Is it down? We can check connectivity as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we will discuss a number of TCP/IP-related troubleshooting and performance
    tools in [“Monitoring”](ch08.xhtml#monitoring).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: To round things off, I’ll also briefly mention the [Border Gateway Protocol
    (BGP)](https://oreil.ly/QMc1v) as defined in [RFC 4271](https://oreil.ly/iwRNE)
    and other IETF specs. While it’s unlikely that you’ll interact directly with BGP
    (unless you work at a network provider or admin a network), it’s crucial to be
    aware of its existence and understand at a high level what it does.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We said earlier on that the internet really is a network of networks. In BGP
    terminology, a network is called an *autonomous system* (AS). For IP routing to
    work, these ASs need to share their routing and reachability data, announcing
    routes to deliver packets across the internet.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the fundamental workings of the internet layer—how addresses
    and routing work—let’s move up the stack.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The Transport Layer
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this layer, it’s all about the nature of the communication between endpoints.
    There are connection-oriented protocols and connection-less ones. Reliability,
    QoS, and in-order delivery may be a concern.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are attempts in modern protocol design—[HTTP/3](https://oreil.ly/ecuPK)
    is an example—to combine functionality, such as moving parts of TCP into higher-level
    protocols.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Ports
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One core concept in this layer is that of ports. No matter which protocol is
    used in this layer, each requires ports. A *port* is a unique 16-bit number identifying
    a service available at an IP address. Think of it this way: a single (virtual)
    machine may have a number of services (see [“Application Layer Networking”](#app-layer-net))
    running, and you need to be able to identify each in the context of the machine’s
    IP.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'We differentiate between the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Well-known ports (from 0 to 1023)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: These are for daemons such as an SSH server or a web server. Using (binding
    to) one of them requires elevated privileges (`root` or `CAP_NET_BIND_SERVICE`
    capability, as discussed in [“Capabilities”](ch04.xhtml#capabilities)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Registered ports (from 1024 to 49151)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: These are managed by Internet Assigned Numbers Authority (IANA) through a publicly
    documented process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Ephemeral ports (from 49152 to 65535)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: These cannot be registered. They can be used for automatically allocating a
    temporary port (for example, if your app connects to a web server, it needs a
    port itself, as the other endpoint of the communication) as well as for private
    (say, company-internal) services.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: You can see the ports and mapping in */etc/services*, and further, there is
    a comprehensive list of [TCP and UDP port numbers](https://oreil.ly/VBp7N) you
    might want to consult if you’re unsure.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see what’s in use on your local machine (*do not* do this on
    someone else’s machine/against a nonlocal IP):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_networking_CO9-1)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Scan ports on local machine.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO9-2)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Found one open port, 631, which is the Internet Printing Protocol (IPP).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: With the general idea of ports explained, let’s now have a look how these ports
    are used in different transport layer protocols.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Transmission Control Protocol
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Transmission Control Protocol* (TCP) is a connection-oriented transport
    layer protocol that is used by a number of higher-level protocols, including HTTP
    and SSH (see [“Application Layer Networking”](#app-layer-net)). It is a session-based
    protocol that guarantees delivery of the packets in order and supports retransmission
    in case of errors.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The TCP header ([Figure 7-5](#fig-tcp-header)), as defined in [RFC 793](https://oreil.ly/4BY3T)
    and related IETF specs, has these most important fields:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Source port (16 bits)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The port used by the sender.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Destination port (16 bits)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The port used by the receiver.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Sequence number (32 bits)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Used to manage in-order delivery.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgment number (32 bits)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: This number and the `SYN` and `ACK` flags are the core of the so-called [*TCP/IP
    three-way handshake*](https://oreil.ly/Icea3).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Flags (9 bits)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Most important, the `SYN` (synchronize) and the `ACK` (acknowledgement) bits.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Window (16 bits)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The receive window size.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Checksum (16 bits)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: A checksum of the TCP-header, used for error checking.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Data
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The payload to transport.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0705](Images/lmlx_0705.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. The TCP header format as per RFC 793
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TCP tracks the state of the connection from establishment to termination, with
    both the sender and the receiver having to negotiate certain things, from how
    much data to send (TCP window size) to QoS.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, TCP is without any defense mechanisms. In other
    words, the payload is sent in plain text, and anyone between the sender and the
    receiver (and there are by design many hops) can inspect the packet; see [“Wireshark
    and tshark”](#network-traffic-inspection) for details on using Wireshark and `tshark`
    to inspect the payload. To enable encryption of the message, you need to use the
    Transport Layer Security (TLS) protocol, ideally in version 1.3 as per [RFC 8446](https://oreil.ly/6dTwf).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, let’s move on to the most important stateless transport layer protocol:
    UDP.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: User Datagram Protocol
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*User Datagram Protocol* (UDP) is a connection-less transport layer protocol
    allowing you to send messages, called *datagrams* in UDP, without communication
    setups (such as TCP does with the handshake). It does, however, support datagram
    checksums to ensure integrity. There are a number of application-level protocols,
    such as NTP and DHCP (see [“Application Layer Networking”](#app-layer-net)) as
    well as DNS (see [“DNS”](#dns)), that use UDP.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The [RFC 768](https://oreil.ly/dysc4) defines the UDP header format as shown
    in [Figure 7-6](#fig-udp-header). Its most important fields are the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Source port (16 bits)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The port used by the sender; optional, and if not, use 0
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Destination port (16 bits)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The port used by the receiver
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Length (16 bits)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The total length of the UDP header and data
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Checksum (16 bits)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Can optionally be used for error checking
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Data
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The payload of the datagram
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0706](Images/lmlx_0706.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. The UDP header format as per RFC 768
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: UDP is a very simple protocol and requires the higher-level protocol that works
    on top of it to take care of many of the things that TCP would handle itself.
    On the other hand, UDP has very little overhead and can achieve high throughput.
    It’s very simple to use; see also the [UDP manual page](https://oreil.ly/NJiAQ).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A high-level communication interface that Linux provides are [*sockets*](https://oreil.ly/C7gQA).
    Think of them as endpoints in a communication, with their distinct identity: a
    tuple made up of the TCP or UDP port and the IP address.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: It’s likely that you’ll only use sockets if you want to develop network-related
    tooling or apps, but you should at least be aware of how to query them. For example,
    in the context of the [Docker daemon](https://oreil.ly/OUD5V), you at least need
    to know about the required permissions for the socket.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at how to use the [`ss` command](https://oreil.ly/qtCkK) to
    display socket-related information.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we want to get an overview of the TCP sockets in use on the system:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](Images/1.png)](#co_networking_CO10-1)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ss` command to query ports (with `-s`, we ask for a summary).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO10-2)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The summary for TCP; overall, 10 sockets in use.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO10-3)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: A more detailed overview, breaking down by type and IP version.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what about UDP? Can we get this information, maybe with some more details,
    such as endpoint IP addresses? Turns out this is also possible with `ss` (output
    edited):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_networking_CO11-1)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `ss`: the `-u` parameter restricts to UDP sockets, `-l` is for selecting
    listening sockets, and `-p` also shows the process information (none in our case).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tool you might find handy in this context (sockets and processes) is
    [`lsof`](https://oreil.ly/YBhMB). For example, let’s see what UDP sockets Chrome
    uses on my machine (output edited):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](Images/1.png)](#co_networking_CO12-1)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Use `lsof` with `-c` to specifically select a process by name as well as limit
    to UDP with `-i`. Note that the overall output would be many dozens of lines;
    that’s why I cut it down to five with the `head -5` command in the pipe.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'With that we’ve covered the three lower layers of the TCP/IP stack. Since the
    application layer has so much going on, I’ve dedicated two sections to it: first,
    we’re looking into the global-scale naming system, and then we’ll look into a
    number of application layer (or layer 7) protocols and applications, such as the
    web.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: DNS
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned that the internet layer of the TCP/IP stack defines so-called IP
    addresses whose main function it is to identify machines, virtual or physical
    alike. In the context of [“Containers”](ch06.xhtml#containers), we go so far as
    to assign IP addresses to individual containers. There are two challenges with
    numerical IP addresses, no matter if IPv4 or IPv6:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: As humans, we generally remember names better than we do (long) numbers. For
    example, if you want to share a website with a friend, you can just say it’s [*ietf.org*](https://ietf.org)
    they should check out rather than `4.31.198.44`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the way the internet and its applications are built, IP addresses often
    change. You might get a new server with a new IP address in a more traditional
    setup. Or, in the context of containers, you may be rescheduled onto a different
    host, in which case the container automatically gets a new IP address assigned.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in a nutshell, IP addresses are hard to remember and can change, while a
    name (for a server or a service) remains the same. This challenge has existed
    since the beginning of the internet and since UNIX supported the TCP/IP stack.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The way to address this was to locally (in the context of a single machine)
    maintain a mapping between names and IP addresses via */etc/hosts*. The Network
    Information Center (NIC) would share a single file called *HOSTS.TXT* via FTP
    with all participating hosts.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Very soon it became clear that this centralized approach could not keep up with
    the growing internet, and in the early 1980s, a distributed system was designed.
    Paul Mockapetris was the lead architect.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The DNS is a worldwide, hierarchical naming system for hosts and services on
    the internet. While there are many related RFCs, the original one, [RFC 1034](https://oreil.ly/rbQNY),
    and its implementation guidance via [RFC 1035](https://oreil.ly/c1eYB) are still
    valid, and I strongly recommend you read them if you want to learn more about
    the motivation and design.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The DNS uses a number of terms, but the following are the main concepts:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Domain name space
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: A tree structure with `.` as the root and each tree node and leaf containing
    information about a certain space. The labels (63 bytes maximum length) along
    the path from a leaf to the root is what we call a *fully qualified domain name*
    (FQDN). For example, *demo.mhausenblas.info.* is an FQDN with the so-called top-level
    domain *.info*. Note that the right-most dot, the root, is often left off.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Resource records
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The payload in the nodes or leaves of the domain name space (see [“DNS Records”](#dns-records)).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Name servers
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Server programs that hold information about the domain tree’s structure. If
    a name server has the complete information about a space, it’s called an *authoritative
    name server*. Authoritative information is organized into zones.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Resolvers
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Programs that extract information from name servers in response to client requests.
    They are machine local, and no explicit protocol is defined for the interaction
    between a resolver and a client. Often there are library calls supported for resolving
    the DNS.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-7](#fig-dns-example) shows a complete setup of a DNS system, including
    user program, resolver, and name server(s), as described in RFC 1035\. In the
    query process, the resolver would iteratively query authoritative name servers
    (NS) starting from the root or, if supported, using a recursive query where an
    NS queries others on behalf of a resolver.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0707](Images/lmlx_0707.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. A complete DNS example setup
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-287
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although they’re still around, we usually don’t use the DNS [resolver configuration](https://oreil.ly/2plq1)
    in */etc/resolv.conf* in modern systems, especially when DHCP (see [“Dynamic Host
    Configuration Protocol”](#dhcp)) is deployed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'The DNS is a hierarchical naming system, and at its root sit 13 [root servers](https://oreil.ly/hNppq)
    that manage the records for the top-level domains. Directly beneath the root are
    the [top-level domains (TLD)](https://oreil.ly/secgy):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure top-level domain
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Managed by IANA on behalf of the IETF and including, for example, *example*
    and *localhost*
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Generic top-level domains (gTLD)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Generic domains having three or more characters, such as *.org* or *.com*
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Country-code top-level domains (ccTLD)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: For countries or territories assigned [two-letter ISO country codes](https://oreil.ly/lBWjD)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Sponsored top-level domains (sTLD)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: For private agencies or organizations that establish and enforce rules restricting
    the eligibility to use the TLD—for example, *.aero* and *.gov*
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a closer look at some moving parts of the DNS and how to use it in
    practice.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: DNS Records
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A name server manages records that capture the type, the payload, and other
    fields, including things like the time to live (TTL), the time period after which
    the record is supposed to be discarded. You can think of the FQDN as the address
    of the node and the resource record (RR) as the payload, the data in the node.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'DNS has a number of [record types](https://oreil.ly/5QTJ9), including the following
    most important ones (in alphabetical order):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '`A` records (RFC 1035) and `AAAA` records (RFC 3596)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 and IPv6 address records, respectively; usually used to map hostnames to
    an IP address of the host.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '`CNAME` records (RFC 1035)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Canonical name records providing an alias of one name to another.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '`NS` records (RFC 1035)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Name server records delegating a DNS zone to use the authoritative name servers.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '`PTR` records (RFC 1035)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Pointer records used for performing reverse DNS lookups; the opposite of `A`
    records.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '`SRV` records (RFC 2782)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Service locator records. They are a generalized discovery mechanism, rather
    than hardcoded (as traditionally was the case with the `MX` record type for mail
    exchange).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '`TXT` records (RFC 1035)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Text records. These were originally meant for arbitrary human-readable text
    but over time found a new use case. Today, these records often have machine-readable
    data in the context of security-related DNS extensions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: There are also [wildcard records](https://oreil.ly/yL039) starting with the
    asterisk label (`*`)—for example, **.mhausenblas.info*—as a catch-all to match
    requests for nonexistent names.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how these records look in practice. The DNS records are represented
    in a textual form in a [zone file](https://oreil.ly/4Ngai) that a name server—such
    as [bind](https://oreil.ly/095v2)—reads in and makes part of its database:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_networking_CO13-1)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The start of this zone file in the namespace.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO13-2)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Default expiration time in seconds of all RRs that don’t define their own TTL.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO13-3)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The nameserver for this domain.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO13-4)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The mailserver for this domain.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_networking_CO13-5)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The IPv4 address for this domain.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_networking_CO13-6)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The IPv4 address for the nameserver.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_networking_CO13-7)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Make *www.example.com* an alias for this domain—that is, *example.com*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_networking_CO13-8)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: The IPv4 address for the mail server.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting all the concepts discussed together, we can now understand the example
    shown in [Figure 7-8](#fig-dns-space-example). This shows a part of the global
    domain name space and a concrete example FQDN, *demo.mhausenblas.info*:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '*.info*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: A generic TLD managed by a company called [Afilias](https://www.afilias.info).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '*mhausenblas.info*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: A domain I bought. Within this zone I can assign subdomains as I please.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '*demo.mhausenblas.info*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The subdomain I assigned for demo purposes.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0708](Images/lmlx_0708.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. The domain name space and an example path (FQDN)
  id: totrans-341
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Consider how in the previous example each entity (Afilias or me) only looks
    after its part, and no coordination is required. For example, to create the *demo*
    subdomain, I only had to change my DNS settings for the zone, without asking anyone
    at Afilias for support or permissions. This seemingly simple fact is the core
    of the decentralized nature of DNS and is what makes it so scalable.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how the domain name space is structured and the information
    in the nodes is represented, let’s see how you can query them.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: DNS Lookups
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all the infrastructure in place, mainly nameservers and resolvers, we now
    look at performing DNS queries. There is a lot of logic in the evaluation and
    construction of the resolution (mostly covered in RFC 1034 and 1035), but this
    is beyond the scope of the book. Let’s have a look at how you can do the query
    without having to understand the internals.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `host` command to query local (and global) names to resolve
    them to IP addresses and the other way around:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_networking_CO14-1)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Look up local IP addresses.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO14-2)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Look up FQDN.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO14-3)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Reverse lookup of IP address to find an FQDN; looks like the GitHub CDN.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'A more powerful way to look up the DNS records is using the `dig` command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](Images/1.png)](#co_networking_CO15-1)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Using `dig`, look up the DNS records of the FQDN *mhausenblas.info*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO15-2)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The DNS A records.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO15-3)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The authoritative nameserver.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: There are alternatives to the `dig` command available, notably `dog` and `nslookup`;
    see [Appendix B](app02.xhtml#appendix-modern).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-363
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One saying you will come across often is: “It’s always DNS.” But what does
    this mean? It’s about troubleshooting and understanding that DNS is a distributed
    database with many moving parts. When debugging DNS-related issues, consider the
    TTL of records and that there are many caches, from local ones in your app to
    resolver, to anything between you and the nameservers.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: In [“DNS Records”](#dns-records), we mentioned the `SRV` record type and that
    it serves as a generic discovery mechanism. So, rather than defining a new record
    type for a new service in an RFC, the community came up with a generic way to
    address any upcoming service type. This mechanism, described in [RFC 2782](https://oreil.ly/DIKbI),
    explains how `SRV` records can be used to communicate the IP address and port
    of a service via DNS.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see that in practice. Say we want to know what chat services—more specifically,
    [Extensible Messaging and Presence Protocol (XMPP)](https://oreil.ly/rDmcx) services—if
    any, are available:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#custom_co_networking_CO16-1)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Use the `dig` command with the `+short` option to display only the relevant
    answer section. The *_xmpp-client._tcp* part is the format RFC 2782 prescribes,
    and the `SRV` at the end of this command specifies what record type we’re interested
    in.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#custom_co_networking_CO16-2)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Overall there are five answers. An example service instance is available at
    *xmpp.l.google.com:5222* with a TTL of 5 seconds. If you have an XMPP such as
    Jabber, you could use this address for configuration input.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: With this, we’ve reached the end of the DNS section. Now we’ll have a look at
    other application layer protocols and tooling.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Application Layer Networking
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we focus on user space or application layer network protocols,
    tooling, and apps. As an end user, you’ll likely spend most of your time here,
    using things such as web browsers or mail clients for your daily tasks.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The Web
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The web, originally developed by Sir Tim Berners-Lee in the early 1990s, has
    three core components:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Uniform Resource Locators (URL)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: As per [RFC 1738](https://oreil.ly/EfgPm) originally and a number of updates
    and related RFCs. A URL defines both the identity and the location of a resource
    on the web. A resource could be a static page or a process that generates content
    dynamically.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Hypertext Transfer Protocol (HTTP)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP defines an application layer protocol and how to interact with content
    available via URLs. As per [RFC 2616](https://oreil.ly/hGr3E) for v1.1, but there
    are also more modern versions, such as HTTP/2, defined in [RFC 7540](https://oreil.ly/1Z6pn),
    and the [HTTP/3 draft](https://oreil.ly/XRkMf) (which at the time of this writing
    was still in the works). Core HTTP concepts are:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[HTTP methods](https://oreil.ly/FFWuP)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Including `GET` for read operations and, among others, `POST` for write operations,
    these define a CRUD-like interface.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[Resource naming](https://oreil.ly/ttnOq)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: This dictates how to form URLs.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[HTTP status codes](https://oreil.ly/LppmX)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: With the `2xx` range for success, `3xx` for redirects, `4xx` for client errors,
    and `5xx` for server errors.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Hyper Text Markup Language (HTML)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Initially a W3C specification, HTML is now a living standard available via [WHATWG](https://oreil.ly/lUcHo).
    A hypertext markup allows you to define page elements such as headers or inputs.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a closer look at how URIs (the generic version of URLs) are constructed
    (as per RFC 3986) and how that maps to HTTP URLs:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The components are as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '`user` and `password` (both optional)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Initially used for basic authentication, these components should not be used
    anymore. Instead, for HTTP, you should be using a proper [authentication mechanism](https://oreil.ly/EHNfN)
    together with [HTTPS](https://oreil.ly/Dvuh4) for encryption on the wire.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '`scheme`'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Refers to the [URL scheme](https://oreil.ly/R9QeW), an IETF specification defining
    its meaning. For HTTP, that scheme is called `http`, which really is a family
    of HTTP specifications, such as RFC 2616.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '`authority`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'The hierarchical naming part. For HTTP, this is:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Hostname
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Either as a DNS FQDN or an IP address.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Port
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: With a default of 80 (so *example.com:80* and *example.com* are the same).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '`path`'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: A scheme-specific part for further resource details.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '`query` and `fragment` (both optional)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: The former appears after the `?` for nonhierarchical data (for example, to express
    tags or form data), and the latter appears after the `#` for secondary resources
    (in the context of HTML, that could be a section).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Today, the web has advanced far beyond its humble 1990s roots, with a number
    of technologies such as [JavaScript/ECMAScript](https://oreil.ly/b8kFe) and [Cascading
    Style Sheets (CSS)](https://oreil.ly/rSlYl) considered core. Those additions,
    JavaScript for dynamic client-side content and CSS for styling, have eventually
    led to [single-page web apps](https://oreil.ly/E1SJu). While this topic is beyond
    the scope of the book, it’s important to remember that knowing the basics (URL,
    HTTP, and HTML) well goes a long way in terms of understanding how things work
    and troubleshooting issues you may have.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see web specifications in action by simulating the flow end to end,
    starting at the HTTP server end.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'You can rather easily run a simple HTTP server that only serves the content
    of a directory in two ways: by using [Python](https://oreil.ly/clti0) or by using
    [netcat (`nc`)](https://oreil.ly/AaCJG).'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'With Python, to serve the content of a directory, you would do the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](Images/1.png)](#co_networking_CO16-1)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Use the built-in Python module `http.server` to serve the content of the current
    directory (that is, the directory from which you launched this command).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO16-2)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: It confirms that it’s ready to serve via port 8000\. This means that you could
    enter *[*http://localhost:8000*](http://localhost:8000)* into your browser and
    you would see the content of your directory there.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO16-3)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: This shows that an HTTP request against the root (*/*) has been issued and served
    successfully (the 200 HTTP response code).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-417
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want to do more advanced stuff, beyond serving a static directory, consider
    using a proper web server such as [NGINX](https://docs.nginx.com). You could,
    for example, run NGINX using Docker (see [“Docker”](ch06.xhtml#docker)) with the
    following command:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](Images/1.png)](#co_networking_CO17-1)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Call the running container `mywebserver`; you should see that when you issue
    a `docker ps` command to list running containers.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO17-2)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: The `--rm` removes the container on exit, and the `-d` turns it into a daemon
    (detach from terminal, run in background).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO17-3)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Mounts the current directory (`$PWD`) into the container as the NGINX source
    content directory. Note that `$PWD` is a bash way to address the current directory.
    In Fish you would use `(pwd)` instead.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO17-4)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Makes the container-internal port 80 available on the host via 8042. That means
    you would be able to access the web server via *[*http://localhost:8042*](http://localhost:8042)*
    on your machine.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_networking_CO17-5)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The container image to use (`nginx:1.21`), and implicitly using Docker Hub since
    we didn’t specify the registry part.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how we can use [`curl`](https://curl.se), a powerful and popular
    tool to interact with any kind of URLs, to get the content of the web server we
    launched in the previous example (make sure it’s still running, or launch it again
    in a separate session if you terminated it already):'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In [Table 7-1](#tab-curl-usage) you see some common options for `curl` that
    you may find useful. The selection is based on my usage history for a range of
    tasks, from developing to system administration.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Useful options for `curl`
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Long-form option | Description and use case |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
- en: '| `-v` | `--verbose` | For verbose output, use for debugging. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| `-s` | `--silent` | Silence `curl`: do not show the progress meter or error
    messages. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: '| `-L` | `--location` | Follow page redirects (`3XX` HTTP response codes).
    |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '| `-o` | `--output` | By default, the content goes to `stdout`; if you want
    to directly store it in a file, specify it via this option. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '| `-m` | `--max-time` | Maximum time (in seconds) you are willing to wait for
    the operation to take. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
- en: '| `-I` | `--head` | Fetch the headers only (careful: not every HTTP server
    supports the `HEAD` method for a path). |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
- en: '| `-k` | `--insecure` | By default, HTTPS calls are verified. Use this option
    to ignore the errors for cases where that’s not possible. |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
- en: If `curl` is not available, you can fall back to [`wget`](https://oreil.ly/0jYJj),
    which is more limited but sufficient for simple HTTP-related interactions.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Secure Shell
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Secure Shell (SSH)](https://oreil.ly/dNVgt) is a cryptographic network protocol
    for securely offering network services on an unsecured network. For example, as
    a replacement for `telnet`, you can use `ssh` to log into a remote machine and
    also move data securely between (virtual) machines.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see SSH in action. I’ve provisioned a virtual machine in the cloud with
    an IP address of `63.32.106.149`, and the user name provided by default is `ec2-user`.
    To log into the machine, I can do the following (note that the output is edited
    and assumes that you or someone else created credentials in *~/.ssh/lml.pem* beforehand):'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](Images/1.png)](#co_networking_CO18-1)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ssh` command to log into a remote machine.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO18-2)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Use the identity file *~/.ssh/lml.pem* rather than a password. Explicitly providing
    that file is a good practice but in our case would strictly speaking not be necessary
    as it resides in the default location *~/.ssh*.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO18-3)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: The SSH target machine in the format `username@host`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO18-4)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Once the login process is completed, I can tell from the prompt that I’m on
    the target machine and can use it just as if it were local.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'Some general SSH usage tips:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: If you run an SSH server, that is, allow others to `ssh` into your machine,
    then you absolutely should [disable password authentication](https://oreil.ly/Jz5tA).
    This forces users to create a key pair and share the public key with you that
    you then add to *~/.ssh/authorized_keys* and allow to log in via this mechanism.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `ssh -tt` to force pseudo-tty allocation.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do `export TERM=xterm` when you `ssh` into a machine, in case you are having
    display issues.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure timeouts for `ssh` sessions in your client. On a per-user basis, this
    is usually via *~/.ssh/config*, where you can set `ServerAliveInterval` and `Server​Ali⁠veCountMax`
    options to keep your connections alive.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re having issues, and you’ve excluded local permission issues with the
    key(s), then you can try launching `ssh` with the `-v` option, giving you details
    about what’s going on under the hood (also, try multiple instances of `v`, like
    `-vvv` for finer-grained debug info).
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH is not only used directly by humans, but it is also used as a building block
    under the hood—for example, in file-transfer tooling.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: File Transfer
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One very common task involving the network is transferring files. You can do
    this from your local machine to a server in the cloud or from another machine
    in the local network.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: To copy to and from remote systems, you can use one basic tool. [`scp` (short
    for “secure copy”)](https://oreil.ly/RKbEu) works on top of SSH. Given that `scp`
    defaults to `ssh`, we need to make sure that we have the password (or even better,
    key-based authentication) in place for it to work.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a remote machine with the IPv4 address `63.32.106.149`,
    and we want to copy a file there from our local machine:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](Images/1.png)](#co_networking_CO19-1)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Source is the file *copyme* in the current directory.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO19-2)'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Destination is the */home/ec2-user/* directory on machine `63.32.106.149`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing files with [`rsync`](https://oreil.ly/eC6Kz) is much more convenient
    and faster than `scp`. Under the hood, `rsync` uses SSH by default.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now see how we can use `rsync` to transfer files from the *~/data/* from
    the local machine to the host at `63.32.106.149`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](Images/1.png)](#co_networking_CO20-1)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Options meaning `-a` for archive (incremental, preserve), `-v` for verbose so
    that we see something, and `-z` for using compression.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO20-2)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Source directories (since `-a` includes `-r` which is recursive).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO20-3)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Destination in `user@host` format.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO20-4)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Verify if the data has arrived by executing an `ls` on the remote machine. The
    next line shows that it indeed worked—the data arrived in good order.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: If you’re unsure what `rsync` will do, use the `--dry-run` option in addition
    to the other ones. It will essentially tell you what it will do without actually
    carrying out the operation, so it’s safe.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '`rsync` is also a great tool to perform directory backups because it can be
    set to copy only files that have been added or changed.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-485
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t forget the `:` after the host! Without it, `rsync` will happily go ahead
    and interpret the source or destination as a local directory. That is, the command
    will work fine, but rather than copying the files to the remote machine, it will
    end up on your local machine. For example, *user@example.com* as the destination
    would be a subdirectory of the current directory called *user@example.com/*.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, one use case you often come across is when someone provides
    files in an Amazon S3 bucket. To download those files, you can use the [AWS CLI](https://oreil.ly/mqQcr)
    with the `s3` subcommand as follows. We’re using a dataset from the [Open Data
    registry](https://oreil.ly/cbYMH) in a public S3 bucket (output edited to fit):'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](Images/1.png)](#co_networking_CO21-1)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Use the AWS S3 command to synchronize files from a public bucket.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO21-2)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the source bucket, *s3://commoncrawl*, and the exact path of the source
    we want to sync. Warning: there are more than 8 GB of data in that directory,
    so try this only if you don’t mind the bandwidth.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO21-3)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: The destination is the current directory, signaled by a single period (`.`).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO21-4)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Ignore/skip authentication since this is a publicly available bucket (and thus
    the data in it).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: The File Transfer Protocol (FTP) as per [RFC 959](https://oreil.ly/Okegf) is
    still in use, but we don’t recommend using it anymore. Not only are these insecure,
    but there are also many better alternatives, such as the ones we discussed in
    this section. So, there’s no actual need for FTP anymore.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Network File System
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A widely supported and used way to share files from a central location over
    the network is via network file system (NFS), originally developed by Sun Microsystems
    in the early 1980s. It saw multiple iterations as per [RFC 7530](https://oreil.ly/Uy4CZ)
    and other related IETF specs and is very stable.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'You would usually have an NFS server maintained by a cloud provider or central
    IT in a professional setup. All you would need to do is install the client (usually
    through a package called `nfs-common`). Then, you can mount a source directory
    from the NFS server as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Many cloud providers, such as AWS and Azure, now offer NFS as a service. It’s
    a nice way to provide your storage-hungry application with a lot of space in a
    way that looks and feels almost like local attached storage. For media applications,
    however, a [network-attached storage (NAS) setup](https://oreil.ly/JrQ8m) is likely
    the better choice.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Sharing with Windows
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have Windows machines in your local network and want to share it, you
    can use the [Server Message Block (SMB)](https://oreil.ly/mTAMe), a protocol initially
    developed at IBM in the 1980s, or its Microsoft-owned successor, [Common Internet
    File System (CIFS)](https://oreil.ly/qMEjj).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: You would typically use [Samba](https://www.samba.org), the standard Windows
    interoperability suite of programs for Linux, to achieve the file sharing.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Network Topics
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we discuss some advanced network protocols and tooling across
    the TCP/IP stack. Their usage is normally beyond the scope of a casual user. However,
    if you’re a developer or sys admin, you probably will want to be at least aware
    of them.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: whois
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`whois`](https://oreil.ly/3m97l) is a client for the whois directory service
    that you can use to look up registration and user information. For example, if
    I want to find out who is behind the *ietf.org* domain (note that you can pay
    your domain registrar to keep that information private), I would do the following:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](Images/1.png)](#co_networking_CO22-1)'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Use `whois` to look up registration information about domain.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Host Configuration Protocol
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Dynamic Host Configuration Protocol (DHCP)](https://oreil.ly/C8vOE) is
    a network protocol that enables automatic assignment of an IP address to a host.
    It’s a cli⁠ent​/server setup that removes the need for manually configuring network
    devices.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up and managing a DHCP server is outside our scope, but you can use
    [`dhcpdump`](https://oreil.ly/uPvGn) to scan for DHCP packets. For this, a device
    in your local network needs to join, trying to acquire an IP address, so you may
    need to be a bit patient to see something here (output shortened):'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](Images/1.png)](#co_networking_CO23-1)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Using `dhcpdump`, sniff DHCP packets on interface `wlp1s0`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Network Time Protocol
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [Network Time Protocol (NTP)](http://www.ntp.org) is for synchronizing
    clocks of computers over a network. For example, using the [`ntpq` command](https://oreil.ly/0JxbJ),
    a standard NTP query program, you could make an explicit time server query like
    so:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](Images/1.png)](#co_networking_CO24-1)'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: With the `-p` option, show a list of peers known to the machine, including their
    state.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Usually, NTP works in the background, managed by `systemd` and other daemons,
    so you are unlikely to need to manually query it.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark and tshark
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to do low-level network traffic analysis—that is, you want to see
    exactly the packets across the stack—you can use either the command-line tool
    [`tshark`](https://oreil.ly/n7Urm) or its GUI-based version, [`wireshark`](https://oreil.ly/YQrSa).
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, after finding out via `ip link` that I have a network interface
    called `wlp1s0`, I capture traffic there (output edited to fit):'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](Images/1.png)](#co_networking_CO25-1)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Use `tshark` to capture network traffic on network interface `wlp1s0` and only
    look at TCP traffic.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO25-2)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: In another session, I issued a `curl` command to trigger an HTTP session, in
    which application layer interaction starts. You could also use the less powerful
    but on the other hand more widely available [`tcpdump`](http://www.tcpdump.org)
    for this task.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Other Advanced Tooling
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of advanced network-related tools out there you may find
    useful, including but not limited to the following:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[`socat`](https://oreil.ly/R4Upv)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Establishes two bidirectional byte streams and enables the transferring of data
    between the endpoint.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[`geoiplookup`](https://oreil.ly/huZpl)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to map an IP to a geographic region.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Tunnels
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: An easy-to-use alternative to VPNs and other site-to-site networking solutions.
    Enabled by such tools as [inlets](https://docs.inlets.dev).
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: BitTorrent
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: A peer-to-peer system that groups files into a package called a *torrent*. Check
    out [some clients](https://oreil.ly/Z4rak) to decide if this is something for
    your toolbox.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we defined common network terms, from the hardware level, such
    as NICs, to the TCP/IP stack, to application-layer, user-facing components, such
    as HTTP.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Linux provides a powerful, standards-based implementation of the TCP/IP stack
    that you can use programmatically (for example, sockets) and in the context of
    setting up and querying (usually with the `ip` command).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: We further discussed application-layer protocols and interfaces that make up
    most of the daily (network-related) flows. Your command-line friends here include
    `curl` for transfer and `dig` for DNS lookups.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to dive deeper into networking topics, check out the following
    resources:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP stack
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[*Understanding Linux Network Internals*](https://oreil.ly/pXRxW) by Christian
    Benvenuti (O’Reilly)'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“A Protocol for Packet Network Intercommunication”](https://oreil.ly/wRxdI)'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DHCP server setup webpage](https://oreil.ly/S6ZFJ)'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Hello IPv6: A Minimal Tutorial for IPv4 Users”](https://oreil.ly/DPgZc)'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Understanding IPv6—7 Part Series”](https://oreil.ly/91jkO)'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Collection of IPv6 articles by Johannes Weber](https://oreil.ly/MUcxG)'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iljitsch van Beijnum’s [BGP Expert website](https://oreil.ly/K47dS)
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Everything You Ever Wanted to Know About UDP Sockets but Were Afraid to Ask”](https://oreil.ly/CCrfA)'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[“An Introduction to DNS Terminology, Components, and Concepts”](https://oreil.ly/K31GM)'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Install and Configure DNS Server in Linux”](https://oreil.ly/eKdtK)'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Anatomy of a Linux DNS Lookup”](https://oreil.ly/KkVSf)'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“TLDs—Putting the *.fun* in the Top of the DNS”](https://oreil.ly/qwRTx)'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application layer and advanced networking
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[“SSH Tunneling Explained”](https://oreil.ly/3yhlV)'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Everything curl*](https://oreil.ly/OzB6P)'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“What Is DHCP and How to Configure DHCP Server in Linux”](https://oreil.ly/hrLpo)'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Install and Configure Linux NTP Server and Client”](https://oreil.ly/kHZhw)'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NFS wiki](https://oreil.ly/IOS4b)'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Use Wireshark at the Linux Command Line with TShark”](https://oreil.ly/1ttt0)'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Getting Started with socat”](https://oreil.ly/LWXCj)'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“socat 入门指南”](https://oreil.ly/LWXCj)'
- en: '[“Geomapping Network Traffic”](https://oreil.ly/TAd0b)'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“地图绘制网络流量”](https://oreil.ly/TAd0b)'
- en: 'With that, we’re ready to move on to the next topic in the book: using observability
    to avoid flying blind.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们准备好进入书中的下一个主题：利用可观测性避免盲目行动。
