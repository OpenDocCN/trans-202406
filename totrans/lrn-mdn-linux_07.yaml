- en: Chapter 7\. Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we go into detail about Linux networking. In modern environments,
    the network stack that Linux provides is an essential component. Without it, few
    things are possible. Whether you want to access an instance in your cloud provider,
    browse the web, or install a new app, you need connectivity, and you need a way
    to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first have a look at common network terms, from the hardware level all
    the way up to user-facing components such as HTTP and SSH. We’ll also discuss
    the network stack, protocols, and interfaces. Specifically, we’ll spend time on
    the naming center piece of the web and the wider internet, the so-called Domain
    Name System (DNS). Interestingly, this system is found not only in wide-area deployments
    but is also a central component used for service discovery in container environments
    such as Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at application layer network protocols and tooling. This includes
    file sharing, the web, networked filesystems, and other methods to share data
    over the network.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of the chapter, we’ll review some advanced network topics,
    from geomapping to managing time over the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the expectations for the content in this chapter: you can spend a lot
    of time with the topic of Linux networking; in fact, entire books are dedicated
    to the topic. We’ll take a pragmatic stance here, jumping into hands-on topics
    from an end-user point of view. Admin topics around networking, such as configuration
    and setup of network devices, are by and large out of scope here.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s turn our attention to the networking basics.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s first discuss why networking is relevant for a number of use cases and
    define some common network terminology.
  prefs: []
  type: TYPE_NORMAL
- en: In modern environments, networking plays a central role. This ranges from tasks
    such as installing apps, browsing the web, and viewing mail or social media to
    working with remote machines (from the embedded system you’re connecting to over
    a local network to servers that run in data centers of your cloud providers).
    Given a network’s many moving parts and layers, it can be difficult to figure
    out if a problem is hardware-related or originates in the software stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another challenge Linux networking addresses comes from abstractions: many
    of the things we’ll cover in this chapter provide a high-level user interface,
    making it appear that files or applications that in reality run on a remote machine
    are accessible or can be manipulated on your local machine. While providing an
    abstraction that makes remote resources seem to be local is a useful feature,
    we should not forget that at the end of the day, all of this boils down to bits
    traveling over the wire and through the air. Keep this in mind when troubleshooting
    or testing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](#fig-net-overview) shows how, on a high level, networking works
    in Linux. There is some kind of networking hardware, such as Ethernet or wireless
    cards; then a number of kernel-level components, such as the TCP/IP stack; and
    finally, in the user space, a range of tools to configure, query, and use networking.'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0701](Images/lmlx_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. An overview of Linux networking
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s now dive into the TCP/IP stack, the core of networking in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike in other areas of Linux, where you need to either consult the source
    code or hope for properly documented design assumptions behind interfaces and
    protocols, in the networking space, almost every protocol and interface is based
    on publicly available specifications. The Internet Engineering Task Force (IETF)
    makes all of those requests for comments (RFCs) freely available via [*data​tracker.ietf.org*](https://datatracker.ietf.org).
  prefs: []
  type: TYPE_NORMAL
- en: Make a habit out of simply reading these RFCs before you get into the details
    of implementations. Those RFCs are written by practitioners for practitioners
    and document good practices and how to implement stuff. Don’t be afraid of working
    through them; you’ll gain a much better understanding about the motivation, use
    cases, and reasons why things are the way they are.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TCP/IP stack, shown in [Figure 7-2](#fig-tcpip-stack), is a layered network
    model made of a number of protocols and tools, mostly defined by IETF specs. Each
    layer must be aware of and able to communicate with only the layers right above
    and below itself. The data is encapsulated in packets, and each layer typically
    wraps the data in a header that contains information relevant for its function.
    So, if an app wants to send data, it would interact directly with the highest
    layer that would add a header and so on down the stack (the send path). Conversely,
    if an app wants to receive data, it would arrive at the lowest layer, and each
    layer in turn would process it based on the header information it finds and pass
    the payload on to the layer above (the receive path).
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0702](Images/lmlx_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. The TCP/IP layers working together to enable communication
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Starting at the bottom of the stack, the four layers of the TCP/IP stack are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The link layer
  prefs: []
  type: TYPE_NORMAL
- en: Lowest in the stack, this layer covers the hardware (Ethernet, WiFi) and kernel
    drivers and focuses on how packets are sent between physical devices. See [“The
    Link Layer”](#tcp-link) for details.
  prefs: []
  type: TYPE_NORMAL
- en: The internet layer
  prefs: []
  type: TYPE_NORMAL
- en: With the Internet Protocol (IP), this layer focuses on routing; that is, it
    supports sending packets between machines across networks. We’ll discuss it in
    [“The Internet Layer”](#tcp-internet).
  prefs: []
  type: TYPE_NORMAL
- en: The transport layer
  prefs: []
  type: TYPE_NORMAL
- en: This layer controls end-to-end communications between (virtual or physical)
    hosts, with the Transmission Control Protocol (TCP) for session-based, reliable
    communication and User Datagram Protocol (UDP) for connection-less communication.
    It mainly deals with how packets are transmitted, including addressing individual
    services on a machine via ports as well as data integrity. Further, Linux supports
    sockets as communication endpoints. See [“The Transport Layer”](#tcp-transport).
  prefs: []
  type: TYPE_NORMAL
- en: The application layer
  prefs: []
  type: TYPE_NORMAL
- en: This layer deals with user-facing tooling and apps, such as the web, SSH, and
    mail. We’ll discuss it in [“DNS”](#dns) and [“Application Layer Networking”](#app-layer-net).
  prefs: []
  type: TYPE_NORMAL
- en: The layering means that the header and the payload of a layer make up the payload
    for the next layer. For example, looking at [Figure 7-2](#fig-tcpip-stack), the
    payload in the internet layer is the transport layer header H[T] and its payload.
    In other words, the internet layer takes the packet it gets from the transport
    layer, treats it as an opaque chunk of bytes, and can focus on its function, the
    routing of the packet to the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now work our way up the TCP/IP stack, starting with the lowest layer,
    the link layer.
  prefs: []
  type: TYPE_NORMAL
- en: The Link Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the link layer of the TCP/IP stack, it’s all about hardware or near-hardware
    stuff, such as bytes, wires, electromagnetic waves, device drivers, and network
    interfaces. You’ll come across the following terms in this context:'
  prefs: []
  type: TYPE_NORMAL
- en: Ethernet
  prefs: []
  type: TYPE_NORMAL
- en: A family of networking technologies using wires to connect machines; often used
    in local area networks (LANs).
  prefs: []
  type: TYPE_NORMAL
- en: Wireless
  prefs: []
  type: TYPE_NORMAL
- en: Also known as WiFi, a class of communication protocols and methods that, rather
    than using wires, uses some electromagnetic waves to transport data.
  prefs: []
  type: TYPE_NORMAL
- en: MAC addresses
  prefs: []
  type: TYPE_NORMAL
- en: Short for *media access control*, MAC is a unique 48-bit identifier for hardware,
    used to identify your machine (to be precise, the network interface; see the following
    term). The MAC address encodes the manufacturer (of the interface) via the organizationally
    unique identifier (OUI), usually occupying the first 24 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  prefs: []
  type: TYPE_NORMAL
- en: A network connection. It can be a physical interface (see [“Network interface
    controller”](#nic) for details) or a virtual (software) interface, like the loopback
    interface `lo`.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with these basics, let’s have a closer look at the link layer.
  prefs: []
  type: TYPE_NORMAL
- en: Network interface controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One essential piece of hardware equipment is the [*network interface controller*
    (NIC)](https://oreil.ly/fZeVJ), sometimes also called the *network interface card*.
    The NIC provides the physical connectivity to a network through either a wired
    standard—for example, the [IEEE 802.3-2018 standard for Ethernet](https://oreil.ly/9g4Mu)—or
    one of the many wireless standards from the [IEEE 802.11 family](https://oreil.ly/V5NiL).
    Once part of a network, the NIC turns the digital representation of the bytes
    you want to send into electrical or electromagnetic signals. The reverse is true
    for the receive path, where the NIC turns whatever physical signals it receives
    into bits and bytes that the software can deal with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at NICs in action. Traditionally, one would use the (now
    widely considered deprecated) [`ifconfig` command](https://oreil.ly/QwgOc) to
    query information on the NICs available on the system (we show it here first for
    educational purposes; in practice, it’s better to use `ip`, as shown in the next
    example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first interface here is `lo`, the loopback interface with the IP address
    `127.0.0.1` (see [“IPv4”](#ipv4)). The maximum transmission unit (MTU) is the
    packet size, here 65,536 bytes (with larger sizes meaning higher throughput);
    for historical reasons, the default for Ethernet was 1,500 bytes, but you can
    use [jumbo frames](https://oreil.ly/NjpnF) that are 9,000 bytes in size.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The second interface reported is `wlp1s0`, with an IPv4 address of `192.168.178.40`
    assigned. This interface is an NIC and has a MAC address (`ether` is `38:de:ad:37:32:0f`).
    When looking at the flags (`<UP,BROADCAST,RUNNING,MULTICAST>`), it seems to be
    operational.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more modern approach of doing the same thing (querying interfaces and
    checking on their status), use the [`ip` command](https://oreil.ly/pruUF). We’ll
    use this approach most often in this chapter (output edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#custom_co_networking_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The loopback interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#custom_co_networking_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'My NIC, with a MAC address of `38:de:ad:37:32:0f`. Note that the name (`wlp1s0`)
    here tells you something about the interface: it’s a wireless interface (`wl`)
    in PCI bus 1 (`p1`) and slot 0 (`s0`). This naming makes the interface names more
    predictable. In other words, if you had two old-style interfaces (say, `eth0`
    and `eth1`), there was no guarantee that a reboot or adding a new card wouldn’t
    cause Linux to rename those interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: For both `ifconfig` and `ip link`, you might be interested in the meaning of
    flags such as `LOWER_IP` or `MULTICAST`; these are documented in the [netdevice
    man pages](https://oreil.ly/OTB7R).
  prefs: []
  type: TYPE_NORMAL
- en: Address Resolution Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Address Resolution Protocol (ARP) maps MAC addresses to IP addresses. In
    a sense, it bridges the link layer with the layer above it, the internet layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `arp` command to show the cache of mapping MAC addresses to hostnames
    or IP addresses. Note that you can use `arp -n` to prevent hostname resolution
    and show IP addresses instead of DNS names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, using a more modern approach with `ip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ip` command to show the cache of mapping MAC addresses to IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display, configure, and troubleshoot wireless devices, you want to use the
    [`iw` command](https://oreil.ly/fyR0y). For example, I know that my wireless NIC
    is called `wlp1s0`, so I can query it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Show base information about wireless interface `wlp1s0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The router the interface is connected to (see also the next example).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The WiFi frequency band the interface is using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, I can gather router- and traffic-related information like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Show connection information about wireless interface `wlp1s0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This and the next line send (`TX` stands for “transmit”) and receive (`RX`)
    statistics—that is, bytes and packets sent and received via this interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good handle on what’s going on in the lowest layer of the
    TCP/IP stack, the (data) link layer, let’s move up the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second-lowest layer of the TCP/IP stack, the internet layer, is concerned
    with routing packets from one machine on the network to another. The design of
    the internet layer assumes that the available network infrastructure is unreliable
    and that the participants (such as nodes in the network or the connections between
    them) change frequently.
  prefs: []
  type: TYPE_NORMAL
- en: The internet layer provides best-effort delivery (that is, no guarantees concerning
    performance) and treats every packet as independent. As a consequence, higher
    layers, typically the transport layer, take care of addressing reliability issues,
    including packet order, retries, or delivery guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: In this layer, the dominating protocol for logically identifying machines uniquely,
    worldwide, is the Internet Protocol (IP), which comes in two flavors, IP version
    4 (IPv4) and IP version 6 (IPv6).
  prefs: []
  type: TYPE_NORMAL
- en: IPv4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IPv4 defines unique 32-bit numbers identifying a host or process acting as an
    endpoint in a TCP/IP communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to write IPv4 addresses is to split up the 32-bit into four 8-bit segments
    separated by a period, each segment in the 0 to 255 range, called an *octet* (hinting
    at that the segment covers 8 bits). Let’s have a look at a concrete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'First octet in binary form: `00111111`'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second octet in binary form: `00100000`'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Third octet in binary form: `01101010`'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fourth octet in binary form: `10010101`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The IP header ([Figure 7-3](#fig-ip-header)), as defined in [RFC 791](https://oreil.ly/7u93r)
    and related IETF specs, has a number of fields, but the following are the most
    important ones that you should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Source address (32 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The IP address of the sender
  prefs: []
  type: TYPE_NORMAL
- en: Destination address (32 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The IP address of the receiver
  prefs: []
  type: TYPE_NORMAL
- en: Protocol (8 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The payload type (next-higher layer type), as per [RFC 790](https://oreil.ly/Y8PPz)—for
    example, TCP, UDP, or ICMP
  prefs: []
  type: TYPE_NORMAL
- en: Time to live, aka TTL (8 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The maximal time the packet is allowed to exist
  prefs: []
  type: TYPE_NORMAL
- en: Type of service (8 bits)
  prefs: []
  type: TYPE_NORMAL
- en: Can be used for quality of service (QoS) purposes
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0703](Images/lmlx_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. The IP header format as per RFC 791
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Given that the internet is a network of networks, it seems natural to distinguish
    between networks and single machines (hosts) in the networks. IP address ranges
    are assigned to networks and within those networks to individual hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, the [Classless Inter-Domain Routing (CIDR)](https://oreil.ly/VDVuy)
    is the only relevant method for assigning IP addresses. The CIDR format consists
    of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part represents the network address. This looks like a normal IP address—for
    example, `10.0.0.0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part defines how many bits (and with that, IP addresses) fall within
    the address range—for example, `/24`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, a complete CIDR range example looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the first 24 bits (or three octets) represent the
    network, and the last 8 bits (32 bits overall minus the 24 bits for the network)
    are the IP addresses available for the 256 hosts (2⁸). The first IP address in
    this CIDR range is `10.0.0.0`, and the last IP address is `10.0.0.255`. Strictly
    speaking, only the addresses `10.0.0.1` to `10.0.0.254` can be assigned to hosts
    since the `.0` and `.255` addresses are reserved for special purposes. In addition,
    we can say that the netmask is `255.255.255.0` since that’s the first 24 bits
    representing the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, you don’t need to remember all the math here. If you’re dealing
    with CIDR ranges on a daily basis, then you just know, and if you’re a casual
    user, you may want to use some tooling. If you want to do CIDR range calculations,
    such as determining how many IPs are in a range, the following are available:'
  prefs: []
  type: TYPE_NORMAL
- en: Online tools such as those at [*https://cidr.xyz*](https://cidr.xyz) and [*https://ipaddressguide.com/cidr*](https://ipaddressguide.com/cidr)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line tools like [mapcidr](https://oreil.ly/2uTwU) and [cidrchk (by yours
    truly)](https://oreil.ly/g88Yk)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also some notable [reserved IPv4 addresses](https://oreil.ly/97Tp7)
    you should know:'
  prefs: []
  type: TYPE_NORMAL
- en: '`127.0.0.0`'
  prefs: []
  type: TYPE_NORMAL
- en: This subnet is reserved for local addresses, with the most prominent one being
    the loopback address `127.0.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`169.254.0.0/16` (`169.254.0.0` to `169.254.255.255`)'
  prefs: []
  type: TYPE_NORMAL
- en: These are link local addresses, meaning packets sent there should not be forwarded
    to other parts of the network. Some cloud providers such as Amazon Web Services
    use this for special services (metadata).
  prefs: []
  type: TYPE_NORMAL
- en: '`224.0.0.0/24` (`224.0.0.0` to `239.255.255.255`)'
  prefs: []
  type: TYPE_NORMAL
- en: This range is reserved for multicast.
  prefs: []
  type: TYPE_NORMAL
- en: '[RFC 1918](https://oreil.ly/2Ijxk) defines private IP ranges. A private IP
    range means that the IP addresses in it are not routable on the public internet;
    hence, it is safe to assign them internally (for example, in the context of your
    company):'
  prefs: []
  type: TYPE_NORMAL
- en: '`10.0.0.0` to `10.255.255.255` (the `10/8` prefix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`172.16.0.0` to `172.31.255.255` (`172.16/12` prefix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.0.0` to `192.168.255.255` (`192.168/16` prefix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another interesting IPv4 address is `0.0.0.0`. It is a nonroutable address that
    has different use cases and different meanings depending on the context, but the
    most important one, from a server perspective, is that `0.0.0.0` refers to all
    IPv4 addresses present in the machine. That’s a great way to say “listen on all
    available IP addresses” as a source until it turns into a known IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was a lot of dry theory; let’s see it in action. We’ll start by querying
    the machine for IP-related things (output edited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List addresses of all interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The IP address of the loopback interface (`127.0.0.1`, as expected).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The (private) IP address of the wireless NIC. Note that this is the LAN-local
    IP address of the machine, which isn’t publicly routable since it falls in the
    `192.168/16` range.
  prefs: []
  type: TYPE_NORMAL
- en: The IPv4 address space is already exhausted, and given that there are many more
    endpoints today than the internet designers thought there would be (for example,
    due to mobile devices and IoT), a sustainable solution is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, with IPv6 there is a solution for the address-exhaustion issue. Unfortunately,
    at this time of writing, the ecosystem at large has still not made the move to
    IPv6, partly for infrastructure reasons but also due to a lack of tooling that
    supports IPv6\. This means that for the time being you’ll still have to deal with
    IPv4 and its limitations and [workarounds](https://oreil.ly/XSiTu).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the (hopefully not-to-distant) future: IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: IPv6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Internet Protocol version 6 (IPv6)](https://oreil.ly/T0ISm) is a 128-bit number
    identifying an endpoint in a TCP/IP communication. This means that with IPv6 we
    can assign on the order of 10^(38) individual machines (devices). In contrast
    to IPv4, IPv6 uses a hexadecimal representation, eight groups of 16 bits each,
    separating the groups by a colon (`:`).'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few rules for shortening IPv6 addresses, such as removing leading
    zeros or compressing consecutive sections of zeros by replacing them with two
    colons (`::`). For example, the IPv6 [loopback address](https://oreil.ly/mGfiU)
    can be written abbreviated as `::1` (the IPv4 variant would be `127.0.0.1`).
  prefs: []
  type: TYPE_NORMAL
- en: Just like IPv4, IPv6 has a number of special and reserved addresses; see APNIC’s
    listing of [IPv6 address types](https://oreil.ly/isoL1) for examples.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that IPv4 and IPv6 are not compatible. This means that
    IPv6 support needs to be built into each and every network participant, from edge
    devices (like your phone) to routers to server software. This IPv6 support has,
    at least in the context of Linux, already shown to be pretty wide. For example,
    the `ip addr` command we saw in the section [“IPv4”](#ipv4) would already by default
    show us the IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Control Message Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [RFC 792](https://oreil.ly/6Nphe) defines the Internet Control Message Protocol
    (ICMP), which is used for lower-level components to send error messages and operational
    information like availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see ICMP in action by testing the reachability of a website with `ping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use [`gping`](https://oreil.ly/1Y5qv), which can ping
    multiple targets at the same time and plot a graph on the command line (see [Figure 7-4](#fig-gping)).
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0704](Images/lmlx_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Pinging two websites with `gping`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that an equivalent tool is available for IPv6: the aptly named [`ping6`](https://oreil.ly/F6q6B).'
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Part of the network stack in Linux is concerned with routing—that is, deciding
    on a per-packet basis where to send a packet. The destination could be a process
    on the same machine, or it could be an IP address on a different machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the exact implementation details of routing are beyond the scope of this
    chapter, we’ll provide a high-level overview: [iptables](https://oreil.ly/roRsv),
    a widely used tool that allows you to manipulate the routing tables—for example,
    to reroute packets on certain conditions or implement a firewall—uses [netfilter](https://www.netfilter.org)
    to intercept and manipulate packets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What you should know is how to query and display routing information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `route` command with `-n`, forcing numerical IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The detailed meaning of the tabular output in the previous `route` command
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Destination`'
  prefs: []
  type: TYPE_NORMAL
- en: The IP address of the destination; `0.0.0.0` means it’s unspecified or unknown,
    potentially sending it to the gateway.
  prefs: []
  type: TYPE_NORMAL
- en: '`Gateway`'
  prefs: []
  type: TYPE_NORMAL
- en: For packets not on the same network, the gateway address.
  prefs: []
  type: TYPE_NORMAL
- en: '`Genmask`'
  prefs: []
  type: TYPE_NORMAL
- en: The subnet mask used.
  prefs: []
  type: TYPE_NORMAL
- en: '`Flags`'
  prefs: []
  type: TYPE_NORMAL
- en: '`UG` means the network is up and is a gateway.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Iface`'
  prefs: []
  type: TYPE_NORMAL
- en: The network interface the packet is going to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'A modern way is using `ip` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Is it down? We can check connectivity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that we will discuss a number of TCP/IP-related troubleshooting and performance
    tools in [“Monitoring”](ch08.xhtml#monitoring).
  prefs: []
  type: TYPE_NORMAL
- en: To round things off, I’ll also briefly mention the [Border Gateway Protocol
    (BGP)](https://oreil.ly/QMc1v) as defined in [RFC 4271](https://oreil.ly/iwRNE)
    and other IETF specs. While it’s unlikely that you’ll interact directly with BGP
    (unless you work at a network provider or admin a network), it’s crucial to be
    aware of its existence and understand at a high level what it does.
  prefs: []
  type: TYPE_NORMAL
- en: We said earlier on that the internet really is a network of networks. In BGP
    terminology, a network is called an *autonomous system* (AS). For IP routing to
    work, these ASs need to share their routing and reachability data, announcing
    routes to deliver packets across the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the fundamental workings of the internet layer—how addresses
    and routing work—let’s move up the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The Transport Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this layer, it’s all about the nature of the communication between endpoints.
    There are connection-oriented protocols and connection-less ones. Reliability,
    QoS, and in-order delivery may be a concern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are attempts in modern protocol design—[HTTP/3](https://oreil.ly/ecuPK)
    is an example—to combine functionality, such as moving parts of TCP into higher-level
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One core concept in this layer is that of ports. No matter which protocol is
    used in this layer, each requires ports. A *port* is a unique 16-bit number identifying
    a service available at an IP address. Think of it this way: a single (virtual)
    machine may have a number of services (see [“Application Layer Networking”](#app-layer-net))
    running, and you need to be able to identify each in the context of the machine’s
    IP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We differentiate between the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Well-known ports (from 0 to 1023)
  prefs: []
  type: TYPE_NORMAL
- en: These are for daemons such as an SSH server or a web server. Using (binding
    to) one of them requires elevated privileges (`root` or `CAP_NET_BIND_SERVICE`
    capability, as discussed in [“Capabilities”](ch04.xhtml#capabilities)).
  prefs: []
  type: TYPE_NORMAL
- en: Registered ports (from 1024 to 49151)
  prefs: []
  type: TYPE_NORMAL
- en: These are managed by Internet Assigned Numbers Authority (IANA) through a publicly
    documented process.
  prefs: []
  type: TYPE_NORMAL
- en: Ephemeral ports (from 49152 to 65535)
  prefs: []
  type: TYPE_NORMAL
- en: These cannot be registered. They can be used for automatically allocating a
    temporary port (for example, if your app connects to a web server, it needs a
    port itself, as the other endpoint of the communication) as well as for private
    (say, company-internal) services.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the ports and mapping in */etc/services*, and further, there is
    a comprehensive list of [TCP and UDP port numbers](https://oreil.ly/VBp7N) you
    might want to consult if you’re unsure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see what’s in use on your local machine (*do not* do this on
    someone else’s machine/against a nonlocal IP):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Scan ports on local machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Found one open port, 631, which is the Internet Printing Protocol (IPP).
  prefs: []
  type: TYPE_NORMAL
- en: With the general idea of ports explained, let’s now have a look how these ports
    are used in different transport layer protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Transmission Control Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Transmission Control Protocol* (TCP) is a connection-oriented transport
    layer protocol that is used by a number of higher-level protocols, including HTTP
    and SSH (see [“Application Layer Networking”](#app-layer-net)). It is a session-based
    protocol that guarantees delivery of the packets in order and supports retransmission
    in case of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TCP header ([Figure 7-5](#fig-tcp-header)), as defined in [RFC 793](https://oreil.ly/4BY3T)
    and related IETF specs, has these most important fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Source port (16 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The port used by the sender.
  prefs: []
  type: TYPE_NORMAL
- en: Destination port (16 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The port used by the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence number (32 bits)
  prefs: []
  type: TYPE_NORMAL
- en: Used to manage in-order delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgment number (32 bits)
  prefs: []
  type: TYPE_NORMAL
- en: This number and the `SYN` and `ACK` flags are the core of the so-called [*TCP/IP
    three-way handshake*](https://oreil.ly/Icea3).
  prefs: []
  type: TYPE_NORMAL
- en: Flags (9 bits)
  prefs: []
  type: TYPE_NORMAL
- en: Most important, the `SYN` (synchronize) and the `ACK` (acknowledgement) bits.
  prefs: []
  type: TYPE_NORMAL
- en: Window (16 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The receive window size.
  prefs: []
  type: TYPE_NORMAL
- en: Checksum (16 bits)
  prefs: []
  type: TYPE_NORMAL
- en: A checksum of the TCP-header, used for error checking.
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs: []
  type: TYPE_NORMAL
- en: The payload to transport.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0705](Images/lmlx_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. The TCP header format as per RFC 793
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TCP tracks the state of the connection from establishment to termination, with
    both the sender and the receiver having to negotiate certain things, from how
    much data to send (TCP window size) to QoS.
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, TCP is without any defense mechanisms. In other
    words, the payload is sent in plain text, and anyone between the sender and the
    receiver (and there are by design many hops) can inspect the packet; see [“Wireshark
    and tshark”](#network-traffic-inspection) for details on using Wireshark and `tshark`
    to inspect the payload. To enable encryption of the message, you need to use the
    Transport Layer Security (TLS) protocol, ideally in version 1.3 as per [RFC 8446](https://oreil.ly/6dTwf).
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, let’s move on to the most important stateless transport layer protocol:
    UDP.'
  prefs: []
  type: TYPE_NORMAL
- en: User Datagram Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*User Datagram Protocol* (UDP) is a connection-less transport layer protocol
    allowing you to send messages, called *datagrams* in UDP, without communication
    setups (such as TCP does with the handshake). It does, however, support datagram
    checksums to ensure integrity. There are a number of application-level protocols,
    such as NTP and DHCP (see [“Application Layer Networking”](#app-layer-net)) as
    well as DNS (see [“DNS”](#dns)), that use UDP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [RFC 768](https://oreil.ly/dysc4) defines the UDP header format as shown
    in [Figure 7-6](#fig-udp-header). Its most important fields are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Source port (16 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The port used by the sender; optional, and if not, use 0
  prefs: []
  type: TYPE_NORMAL
- en: Destination port (16 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The port used by the receiver
  prefs: []
  type: TYPE_NORMAL
- en: Length (16 bits)
  prefs: []
  type: TYPE_NORMAL
- en: The total length of the UDP header and data
  prefs: []
  type: TYPE_NORMAL
- en: Checksum (16 bits)
  prefs: []
  type: TYPE_NORMAL
- en: Can optionally be used for error checking
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs: []
  type: TYPE_NORMAL
- en: The payload of the datagram
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0706](Images/lmlx_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. The UDP header format as per RFC 768
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: UDP is a very simple protocol and requires the higher-level protocol that works
    on top of it to take care of many of the things that TCP would handle itself.
    On the other hand, UDP has very little overhead and can achieve high throughput.
    It’s very simple to use; see also the [UDP manual page](https://oreil.ly/NJiAQ).
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A high-level communication interface that Linux provides are [*sockets*](https://oreil.ly/C7gQA).
    Think of them as endpoints in a communication, with their distinct identity: a
    tuple made up of the TCP or UDP port and the IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s likely that you’ll only use sockets if you want to develop network-related
    tooling or apps, but you should at least be aware of how to query them. For example,
    in the context of the [Docker daemon](https://oreil.ly/OUD5V), you at least need
    to know about the required permissions for the socket.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at how to use the [`ss` command](https://oreil.ly/qtCkK) to
    display socket-related information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we want to get an overview of the TCP sockets in use on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ss` command to query ports (with `-s`, we ask for a summary).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The summary for TCP; overall, 10 sockets in use.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A more detailed overview, breaking down by type and IP version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what about UDP? Can we get this information, maybe with some more details,
    such as endpoint IP addresses? Turns out this is also possible with `ss` (output
    edited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `ss`: the `-u` parameter restricts to UDP sockets, `-l` is for selecting
    listening sockets, and `-p` also shows the process information (none in our case).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tool you might find handy in this context (sockets and processes) is
    [`lsof`](https://oreil.ly/YBhMB). For example, let’s see what UDP sockets Chrome
    uses on my machine (output edited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `lsof` with `-c` to specifically select a process by name as well as limit
    to UDP with `-i`. Note that the overall output would be many dozens of lines;
    that’s why I cut it down to five with the `head -5` command in the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that we’ve covered the three lower layers of the TCP/IP stack. Since the
    application layer has so much going on, I’ve dedicated two sections to it: first,
    we’re looking into the global-scale naming system, and then we’ll look into a
    number of application layer (or layer 7) protocols and applications, such as the
    web.'
  prefs: []
  type: TYPE_NORMAL
- en: DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned that the internet layer of the TCP/IP stack defines so-called IP
    addresses whose main function it is to identify machines, virtual or physical
    alike. In the context of [“Containers”](ch06.xhtml#containers), we go so far as
    to assign IP addresses to individual containers. There are two challenges with
    numerical IP addresses, no matter if IPv4 or IPv6:'
  prefs: []
  type: TYPE_NORMAL
- en: As humans, we generally remember names better than we do (long) numbers. For
    example, if you want to share a website with a friend, you can just say it’s [*ietf.org*](https://ietf.org)
    they should check out rather than `4.31.198.44`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the way the internet and its applications are built, IP addresses often
    change. You might get a new server with a new IP address in a more traditional
    setup. Or, in the context of containers, you may be rescheduled onto a different
    host, in which case the container automatically gets a new IP address assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in a nutshell, IP addresses are hard to remember and can change, while a
    name (for a server or a service) remains the same. This challenge has existed
    since the beginning of the internet and since UNIX supported the TCP/IP stack.
  prefs: []
  type: TYPE_NORMAL
- en: The way to address this was to locally (in the context of a single machine)
    maintain a mapping between names and IP addresses via */etc/hosts*. The Network
    Information Center (NIC) would share a single file called *HOSTS.TXT* via FTP
    with all participating hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Very soon it became clear that this centralized approach could not keep up with
    the growing internet, and in the early 1980s, a distributed system was designed.
    Paul Mockapetris was the lead architect.
  prefs: []
  type: TYPE_NORMAL
- en: The DNS is a worldwide, hierarchical naming system for hosts and services on
    the internet. While there are many related RFCs, the original one, [RFC 1034](https://oreil.ly/rbQNY),
    and its implementation guidance via [RFC 1035](https://oreil.ly/c1eYB) are still
    valid, and I strongly recommend you read them if you want to learn more about
    the motivation and design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DNS uses a number of terms, but the following are the main concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain name space
  prefs: []
  type: TYPE_NORMAL
- en: A tree structure with `.` as the root and each tree node and leaf containing
    information about a certain space. The labels (63 bytes maximum length) along
    the path from a leaf to the root is what we call a *fully qualified domain name*
    (FQDN). For example, *demo.mhausenblas.info.* is an FQDN with the so-called top-level
    domain *.info*. Note that the right-most dot, the root, is often left off.
  prefs: []
  type: TYPE_NORMAL
- en: Resource records
  prefs: []
  type: TYPE_NORMAL
- en: The payload in the nodes or leaves of the domain name space (see [“DNS Records”](#dns-records)).
  prefs: []
  type: TYPE_NORMAL
- en: Name servers
  prefs: []
  type: TYPE_NORMAL
- en: Server programs that hold information about the domain tree’s structure. If
    a name server has the complete information about a space, it’s called an *authoritative
    name server*. Authoritative information is organized into zones.
  prefs: []
  type: TYPE_NORMAL
- en: Resolvers
  prefs: []
  type: TYPE_NORMAL
- en: Programs that extract information from name servers in response to client requests.
    They are machine local, and no explicit protocol is defined for the interaction
    between a resolver and a client. Often there are library calls supported for resolving
    the DNS.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-7](#fig-dns-example) shows a complete setup of a DNS system, including
    user program, resolver, and name server(s), as described in RFC 1035\. In the
    query process, the resolver would iteratively query authoritative name servers
    (NS) starting from the root or, if supported, using a recursive query where an
    NS queries others on behalf of a resolver.'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0707](Images/lmlx_0707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. A complete DNS example setup
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although they’re still around, we usually don’t use the DNS [resolver configuration](https://oreil.ly/2plq1)
    in */etc/resolv.conf* in modern systems, especially when DHCP (see [“Dynamic Host
    Configuration Protocol”](#dhcp)) is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DNS is a hierarchical naming system, and at its root sit 13 [root servers](https://oreil.ly/hNppq)
    that manage the records for the top-level domains. Directly beneath the root are
    the [top-level domains (TLD)](https://oreil.ly/secgy):'
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure top-level domain
  prefs: []
  type: TYPE_NORMAL
- en: Managed by IANA on behalf of the IETF and including, for example, *example*
    and *localhost*
  prefs: []
  type: TYPE_NORMAL
- en: Generic top-level domains (gTLD)
  prefs: []
  type: TYPE_NORMAL
- en: Generic domains having three or more characters, such as *.org* or *.com*
  prefs: []
  type: TYPE_NORMAL
- en: Country-code top-level domains (ccTLD)
  prefs: []
  type: TYPE_NORMAL
- en: For countries or territories assigned [two-letter ISO country codes](https://oreil.ly/lBWjD)
  prefs: []
  type: TYPE_NORMAL
- en: Sponsored top-level domains (sTLD)
  prefs: []
  type: TYPE_NORMAL
- en: For private agencies or organizations that establish and enforce rules restricting
    the eligibility to use the TLD—for example, *.aero* and *.gov*
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a closer look at some moving parts of the DNS and how to use it in
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A name server manages records that capture the type, the payload, and other
    fields, including things like the time to live (TTL), the time period after which
    the record is supposed to be discarded. You can think of the FQDN as the address
    of the node and the resource record (RR) as the payload, the data in the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'DNS has a number of [record types](https://oreil.ly/5QTJ9), including the following
    most important ones (in alphabetical order):'
  prefs: []
  type: TYPE_NORMAL
- en: '`A` records (RFC 1035) and `AAAA` records (RFC 3596)'
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 and IPv6 address records, respectively; usually used to map hostnames to
    an IP address of the host.
  prefs: []
  type: TYPE_NORMAL
- en: '`CNAME` records (RFC 1035)'
  prefs: []
  type: TYPE_NORMAL
- en: Canonical name records providing an alias of one name to another.
  prefs: []
  type: TYPE_NORMAL
- en: '`NS` records (RFC 1035)'
  prefs: []
  type: TYPE_NORMAL
- en: Name server records delegating a DNS zone to use the authoritative name servers.
  prefs: []
  type: TYPE_NORMAL
- en: '`PTR` records (RFC 1035)'
  prefs: []
  type: TYPE_NORMAL
- en: Pointer records used for performing reverse DNS lookups; the opposite of `A`
    records.
  prefs: []
  type: TYPE_NORMAL
- en: '`SRV` records (RFC 2782)'
  prefs: []
  type: TYPE_NORMAL
- en: Service locator records. They are a generalized discovery mechanism, rather
    than hardcoded (as traditionally was the case with the `MX` record type for mail
    exchange).
  prefs: []
  type: TYPE_NORMAL
- en: '`TXT` records (RFC 1035)'
  prefs: []
  type: TYPE_NORMAL
- en: Text records. These were originally meant for arbitrary human-readable text
    but over time found a new use case. Today, these records often have machine-readable
    data in the context of security-related DNS extensions.
  prefs: []
  type: TYPE_NORMAL
- en: There are also [wildcard records](https://oreil.ly/yL039) starting with the
    asterisk label (`*`)—for example, **.mhausenblas.info*—as a catch-all to match
    requests for nonexistent names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how these records look in practice. The DNS records are represented
    in a textual form in a [zone file](https://oreil.ly/4Ngai) that a name server—such
    as [bind](https://oreil.ly/095v2)—reads in and makes part of its database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The start of this zone file in the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Default expiration time in seconds of all RRs that don’t define their own TTL.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The nameserver for this domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The mailserver for this domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_networking_CO13-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The IPv4 address for this domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_networking_CO13-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The IPv4 address for the nameserver.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_networking_CO13-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Make *www.example.com* an alias for this domain—that is, *example.com*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_networking_CO13-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The IPv4 address for the mail server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting all the concepts discussed together, we can now understand the example
    shown in [Figure 7-8](#fig-dns-space-example). This shows a part of the global
    domain name space and a concrete example FQDN, *demo.mhausenblas.info*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*.info*'
  prefs: []
  type: TYPE_NORMAL
- en: A generic TLD managed by a company called [Afilias](https://www.afilias.info).
  prefs: []
  type: TYPE_NORMAL
- en: '*mhausenblas.info*'
  prefs: []
  type: TYPE_NORMAL
- en: A domain I bought. Within this zone I can assign subdomains as I please.
  prefs: []
  type: TYPE_NORMAL
- en: '*demo.mhausenblas.info*'
  prefs: []
  type: TYPE_NORMAL
- en: The subdomain I assigned for demo purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0708](Images/lmlx_0708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. The domain name space and an example path (FQDN)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Consider how in the previous example each entity (Afilias or me) only looks
    after its part, and no coordination is required. For example, to create the *demo*
    subdomain, I only had to change my DNS settings for the zone, without asking anyone
    at Afilias for support or permissions. This seemingly simple fact is the core
    of the decentralized nature of DNS and is what makes it so scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how the domain name space is structured and the information
    in the nodes is represented, let’s see how you can query them.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Lookups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all the infrastructure in place, mainly nameservers and resolvers, we now
    look at performing DNS queries. There is a lot of logic in the evaluation and
    construction of the resolution (mostly covered in RFC 1034 and 1035), but this
    is beyond the scope of the book. Let’s have a look at how you can do the query
    without having to understand the internals.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `host` command to query local (and global) names to resolve
    them to IP addresses and the other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Look up local IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Look up FQDN.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse lookup of IP address to find an FQDN; looks like the GitHub CDN.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more powerful way to look up the DNS records is using the `dig` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `dig`, look up the DNS records of the FQDN *mhausenblas.info*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The DNS A records.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The authoritative nameserver.
  prefs: []
  type: TYPE_NORMAL
- en: There are alternatives to the `dig` command available, notably `dog` and `nslookup`;
    see [Appendix B](app02.xhtml#appendix-modern).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One saying you will come across often is: “It’s always DNS.” But what does
    this mean? It’s about troubleshooting and understanding that DNS is a distributed
    database with many moving parts. When debugging DNS-related issues, consider the
    TTL of records and that there are many caches, from local ones in your app to
    resolver, to anything between you and the nameservers.'
  prefs: []
  type: TYPE_NORMAL
- en: In [“DNS Records”](#dns-records), we mentioned the `SRV` record type and that
    it serves as a generic discovery mechanism. So, rather than defining a new record
    type for a new service in an RFC, the community came up with a generic way to
    address any upcoming service type. This mechanism, described in [RFC 2782](https://oreil.ly/DIKbI),
    explains how `SRV` records can be used to communicate the IP address and port
    of a service via DNS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see that in practice. Say we want to know what chat services—more specifically,
    [Extensible Messaging and Presence Protocol (XMPP)](https://oreil.ly/rDmcx) services—if
    any, are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#custom_co_networking_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `dig` command with the `+short` option to display only the relevant
    answer section. The *_xmpp-client._tcp* part is the format RFC 2782 prescribes,
    and the `SRV` at the end of this command specifies what record type we’re interested
    in.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#custom_co_networking_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Overall there are five answers. An example service instance is available at
    *xmpp.l.google.com:5222* with a TTL of 5 seconds. If you have an XMPP such as
    Jabber, you could use this address for configuration input.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we’ve reached the end of the DNS section. Now we’ll have a look at
    other application layer protocols and tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Application Layer Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we focus on user space or application layer network protocols,
    tooling, and apps. As an end user, you’ll likely spend most of your time here,
    using things such as web browsers or mail clients for your daily tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The Web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The web, originally developed by Sir Tim Berners-Lee in the early 1990s, has
    three core components:'
  prefs: []
  type: TYPE_NORMAL
- en: Uniform Resource Locators (URL)
  prefs: []
  type: TYPE_NORMAL
- en: As per [RFC 1738](https://oreil.ly/EfgPm) originally and a number of updates
    and related RFCs. A URL defines both the identity and the location of a resource
    on the web. A resource could be a static page or a process that generates content
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Hypertext Transfer Protocol (HTTP)
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP defines an application layer protocol and how to interact with content
    available via URLs. As per [RFC 2616](https://oreil.ly/hGr3E) for v1.1, but there
    are also more modern versions, such as HTTP/2, defined in [RFC 7540](https://oreil.ly/1Z6pn),
    and the [HTTP/3 draft](https://oreil.ly/XRkMf) (which at the time of this writing
    was still in the works). Core HTTP concepts are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[HTTP methods](https://oreil.ly/FFWuP)'
  prefs: []
  type: TYPE_NORMAL
- en: Including `GET` for read operations and, among others, `POST` for write operations,
    these define a CRUD-like interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[Resource naming](https://oreil.ly/ttnOq)'
  prefs: []
  type: TYPE_NORMAL
- en: This dictates how to form URLs.
  prefs: []
  type: TYPE_NORMAL
- en: '[HTTP status codes](https://oreil.ly/LppmX)'
  prefs: []
  type: TYPE_NORMAL
- en: With the `2xx` range for success, `3xx` for redirects, `4xx` for client errors,
    and `5xx` for server errors.
  prefs: []
  type: TYPE_NORMAL
- en: Hyper Text Markup Language (HTML)
  prefs: []
  type: TYPE_NORMAL
- en: Initially a W3C specification, HTML is now a living standard available via [WHATWG](https://oreil.ly/lUcHo).
    A hypertext markup allows you to define page elements such as headers or inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a closer look at how URIs (the generic version of URLs) are constructed
    (as per RFC 3986) and how that maps to HTTP URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user` and `password` (both optional)'
  prefs: []
  type: TYPE_NORMAL
- en: Initially used for basic authentication, these components should not be used
    anymore. Instead, for HTTP, you should be using a proper [authentication mechanism](https://oreil.ly/EHNfN)
    together with [HTTPS](https://oreil.ly/Dvuh4) for encryption on the wire.
  prefs: []
  type: TYPE_NORMAL
- en: '`scheme`'
  prefs: []
  type: TYPE_NORMAL
- en: Refers to the [URL scheme](https://oreil.ly/R9QeW), an IETF specification defining
    its meaning. For HTTP, that scheme is called `http`, which really is a family
    of HTTP specifications, such as RFC 2616.
  prefs: []
  type: TYPE_NORMAL
- en: '`authority`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hierarchical naming part. For HTTP, this is:'
  prefs: []
  type: TYPE_NORMAL
- en: Hostname
  prefs: []
  type: TYPE_NORMAL
- en: Either as a DNS FQDN or an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Port
  prefs: []
  type: TYPE_NORMAL
- en: With a default of 80 (so *example.com:80* and *example.com* are the same).
  prefs: []
  type: TYPE_NORMAL
- en: '`path`'
  prefs: []
  type: TYPE_NORMAL
- en: A scheme-specific part for further resource details.
  prefs: []
  type: TYPE_NORMAL
- en: '`query` and `fragment` (both optional)'
  prefs: []
  type: TYPE_NORMAL
- en: The former appears after the `?` for nonhierarchical data (for example, to express
    tags or form data), and the latter appears after the `#` for secondary resources
    (in the context of HTML, that could be a section).
  prefs: []
  type: TYPE_NORMAL
- en: Today, the web has advanced far beyond its humble 1990s roots, with a number
    of technologies such as [JavaScript/ECMAScript](https://oreil.ly/b8kFe) and [Cascading
    Style Sheets (CSS)](https://oreil.ly/rSlYl) considered core. Those additions,
    JavaScript for dynamic client-side content and CSS for styling, have eventually
    led to [single-page web apps](https://oreil.ly/E1SJu). While this topic is beyond
    the scope of the book, it’s important to remember that knowing the basics (URL,
    HTTP, and HTML) well goes a long way in terms of understanding how things work
    and troubleshooting issues you may have.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see web specifications in action by simulating the flow end to end,
    starting at the HTTP server end.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can rather easily run a simple HTTP server that only serves the content
    of a directory in two ways: by using [Python](https://oreil.ly/clti0) or by using
    [netcat (`nc`)](https://oreil.ly/AaCJG).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Python, to serve the content of a directory, you would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the built-in Python module `http.server` to serve the content of the current
    directory (that is, the directory from which you launched this command).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: It confirms that it’s ready to serve via port 8000\. This means that you could
    enter *[*http://localhost:8000*](http://localhost:8000)* into your browser and
    you would see the content of your directory there.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This shows that an HTTP request against the root (*/*) has been issued and served
    successfully (the 200 HTTP response code).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want to do more advanced stuff, beyond serving a static directory, consider
    using a proper web server such as [NGINX](https://docs.nginx.com). You could,
    for example, run NGINX using Docker (see [“Docker”](ch06.xhtml#docker)) with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Call the running container `mywebserver`; you should see that when you issue
    a `docker ps` command to list running containers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `--rm` removes the container on exit, and the `-d` turns it into a daemon
    (detach from terminal, run in background).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO17-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Mounts the current directory (`$PWD`) into the container as the NGINX source
    content directory. Note that `$PWD` is a bash way to address the current directory.
    In Fish you would use `(pwd)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO17-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Makes the container-internal port 80 available on the host via 8042. That means
    you would be able to access the web server via *[*http://localhost:8042*](http://localhost:8042)*
    on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_networking_CO17-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The container image to use (`nginx:1.21`), and implicitly using Docker Hub since
    we didn’t specify the registry part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how we can use [`curl`](https://curl.se), a powerful and popular
    tool to interact with any kind of URLs, to get the content of the web server we
    launched in the previous example (make sure it’s still running, or launch it again
    in a separate session if you terminated it already):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In [Table 7-1](#tab-curl-usage) you see some common options for `curl` that
    you may find useful. The selection is based on my usage history for a range of
    tasks, from developing to system administration.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Useful options for `curl`
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Long-form option | Description and use case |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | `--verbose` | For verbose output, use for debugging. |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | `--silent` | Silence `curl`: do not show the progress meter or error
    messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `-L` | `--location` | Follow page redirects (`3XX` HTTP response codes).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-o` | `--output` | By default, the content goes to `stdout`; if you want
    to directly store it in a file, specify it via this option. |'
  prefs: []
  type: TYPE_TB
- en: '| `-m` | `--max-time` | Maximum time (in seconds) you are willing to wait for
    the operation to take. |'
  prefs: []
  type: TYPE_TB
- en: '| `-I` | `--head` | Fetch the headers only (careful: not every HTTP server
    supports the `HEAD` method for a path). |'
  prefs: []
  type: TYPE_TB
- en: '| `-k` | `--insecure` | By default, HTTPS calls are verified. Use this option
    to ignore the errors for cases where that’s not possible. |'
  prefs: []
  type: TYPE_TB
- en: If `curl` is not available, you can fall back to [`wget`](https://oreil.ly/0jYJj),
    which is more limited but sufficient for simple HTTP-related interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Secure Shell (SSH)](https://oreil.ly/dNVgt) is a cryptographic network protocol
    for securely offering network services on an unsecured network. For example, as
    a replacement for `telnet`, you can use `ssh` to log into a remote machine and
    also move data securely between (virtual) machines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see SSH in action. I’ve provisioned a virtual machine in the cloud with
    an IP address of `63.32.106.149`, and the user name provided by default is `ec2-user`.
    To log into the machine, I can do the following (note that the output is edited
    and assumes that you or someone else created credentials in *~/.ssh/lml.pem* beforehand):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ssh` command to log into a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the identity file *~/.ssh/lml.pem* rather than a password. Explicitly providing
    that file is a good practice but in our case would strictly speaking not be necessary
    as it resides in the default location *~/.ssh*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO18-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The SSH target machine in the format `username@host`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO18-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Once the login process is completed, I can tell from the prompt that I’m on
    the target machine and can use it just as if it were local.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some general SSH usage tips:'
  prefs: []
  type: TYPE_NORMAL
- en: If you run an SSH server, that is, allow others to `ssh` into your machine,
    then you absolutely should [disable password authentication](https://oreil.ly/Jz5tA).
    This forces users to create a key pair and share the public key with you that
    you then add to *~/.ssh/authorized_keys* and allow to log in via this mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `ssh -tt` to force pseudo-tty allocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do `export TERM=xterm` when you `ssh` into a machine, in case you are having
    display issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure timeouts for `ssh` sessions in your client. On a per-user basis, this
    is usually via *~/.ssh/config*, where you can set `ServerAliveInterval` and `Server​Ali⁠veCountMax`
    options to keep your connections alive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re having issues, and you’ve excluded local permission issues with the
    key(s), then you can try launching `ssh` with the `-v` option, giving you details
    about what’s going on under the hood (also, try multiple instances of `v`, like
    `-vvv` for finer-grained debug info).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH is not only used directly by humans, but it is also used as a building block
    under the hood—for example, in file-transfer tooling.
  prefs: []
  type: TYPE_NORMAL
- en: File Transfer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One very common task involving the network is transferring files. You can do
    this from your local machine to a server in the cloud or from another machine
    in the local network.
  prefs: []
  type: TYPE_NORMAL
- en: To copy to and from remote systems, you can use one basic tool. [`scp` (short
    for “secure copy”)](https://oreil.ly/RKbEu) works on top of SSH. Given that `scp`
    defaults to `ssh`, we need to make sure that we have the password (or even better,
    key-based authentication) in place for it to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a remote machine with the IPv4 address `63.32.106.149`,
    and we want to copy a file there from our local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Source is the file *copyme* in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Destination is the */home/ec2-user/* directory on machine `63.32.106.149`.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing files with [`rsync`](https://oreil.ly/eC6Kz) is much more convenient
    and faster than `scp`. Under the hood, `rsync` uses SSH by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now see how we can use `rsync` to transfer files from the *~/data/* from
    the local machine to the host at `63.32.106.149`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Options meaning `-a` for archive (incremental, preserve), `-v` for verbose so
    that we see something, and `-z` for using compression.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO20-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Source directories (since `-a` includes `-r` which is recursive).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO20-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Destination in `user@host` format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO20-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Verify if the data has arrived by executing an `ls` on the remote machine. The
    next line shows that it indeed worked—the data arrived in good order.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re unsure what `rsync` will do, use the `--dry-run` option in addition
    to the other ones. It will essentially tell you what it will do without actually
    carrying out the operation, so it’s safe.
  prefs: []
  type: TYPE_NORMAL
- en: '`rsync` is also a great tool to perform directory backups because it can be
    set to copy only files that have been added or changed.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t forget the `:` after the host! Without it, `rsync` will happily go ahead
    and interpret the source or destination as a local directory. That is, the command
    will work fine, but rather than copying the files to the remote machine, it will
    end up on your local machine. For example, *user@example.com* as the destination
    would be a subdirectory of the current directory called *user@example.com/*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, one use case you often come across is when someone provides
    files in an Amazon S3 bucket. To download those files, you can use the [AWS CLI](https://oreil.ly/mqQcr)
    with the `s3` subcommand as follows. We’re using a dataset from the [Open Data
    registry](https://oreil.ly/cbYMH) in a public S3 bucket (output edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the AWS S3 command to synchronize files from a public bucket.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO21-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the source bucket, *s3://commoncrawl*, and the exact path of the source
    we want to sync. Warning: there are more than 8 GB of data in that directory,
    so try this only if you don’t mind the bandwidth.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO21-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The destination is the current directory, signaled by a single period (`.`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_networking_CO21-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore/skip authentication since this is a publicly available bucket (and thus
    the data in it).
  prefs: []
  type: TYPE_NORMAL
- en: The File Transfer Protocol (FTP) as per [RFC 959](https://oreil.ly/Okegf) is
    still in use, but we don’t recommend using it anymore. Not only are these insecure,
    but there are also many better alternatives, such as the ones we discussed in
    this section. So, there’s no actual need for FTP anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Network File System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A widely supported and used way to share files from a central location over
    the network is via network file system (NFS), originally developed by Sun Microsystems
    in the early 1980s. It saw multiple iterations as per [RFC 7530](https://oreil.ly/Uy4CZ)
    and other related IETF specs and is very stable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You would usually have an NFS server maintained by a cloud provider or central
    IT in a professional setup. All you would need to do is install the client (usually
    through a package called `nfs-common`). Then, you can mount a source directory
    from the NFS server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Many cloud providers, such as AWS and Azure, now offer NFS as a service. It’s
    a nice way to provide your storage-hungry application with a lot of space in a
    way that looks and feels almost like local attached storage. For media applications,
    however, a [network-attached storage (NAS) setup](https://oreil.ly/JrQ8m) is likely
    the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing with Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have Windows machines in your local network and want to share it, you
    can use the [Server Message Block (SMB)](https://oreil.ly/mTAMe), a protocol initially
    developed at IBM in the 1980s, or its Microsoft-owned successor, [Common Internet
    File System (CIFS)](https://oreil.ly/qMEjj).
  prefs: []
  type: TYPE_NORMAL
- en: You would typically use [Samba](https://www.samba.org), the standard Windows
    interoperability suite of programs for Linux, to achieve the file sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Network Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we discuss some advanced network protocols and tooling across
    the TCP/IP stack. Their usage is normally beyond the scope of a casual user. However,
    if you’re a developer or sys admin, you probably will want to be at least aware
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: whois
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`whois`](https://oreil.ly/3m97l) is a client for the whois directory service
    that you can use to look up registration and user information. For example, if
    I want to find out who is behind the *ietf.org* domain (note that you can pay
    your domain registrar to keep that information private), I would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `whois` to look up registration information about domain.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Host Configuration Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Dynamic Host Configuration Protocol (DHCP)](https://oreil.ly/C8vOE) is
    a network protocol that enables automatic assignment of an IP address to a host.
    It’s a cli⁠ent​/server setup that removes the need for manually configuring network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up and managing a DHCP server is outside our scope, but you can use
    [`dhcpdump`](https://oreil.ly/uPvGn) to scan for DHCP packets. For this, a device
    in your local network needs to join, trying to acquire an IP address, so you may
    need to be a bit patient to see something here (output shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO23-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `dhcpdump`, sniff DHCP packets on interface `wlp1s0`.
  prefs: []
  type: TYPE_NORMAL
- en: Network Time Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [Network Time Protocol (NTP)](http://www.ntp.org) is for synchronizing
    clocks of computers over a network. For example, using the [`ntpq` command](https://oreil.ly/0JxbJ),
    a standard NTP query program, you could make an explicit time server query like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO24-1)'
  prefs: []
  type: TYPE_NORMAL
- en: With the `-p` option, show a list of peers known to the machine, including their
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, NTP works in the background, managed by `systemd` and other daemons,
    so you are unlikely to need to manually query it.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark and tshark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to do low-level network traffic analysis—that is, you want to see
    exactly the packets across the stack—you can use either the command-line tool
    [`tshark`](https://oreil.ly/n7Urm) or its GUI-based version, [`wireshark`](https://oreil.ly/YQrSa).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, after finding out via `ip link` that I have a network interface
    called `wlp1s0`, I capture traffic there (output edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO25-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `tshark` to capture network traffic on network interface `wlp1s0` and only
    look at TCP traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO25-2)'
  prefs: []
  type: TYPE_NORMAL
- en: In another session, I issued a `curl` command to trigger an HTTP session, in
    which application layer interaction starts. You could also use the less powerful
    but on the other hand more widely available [`tcpdump`](http://www.tcpdump.org)
    for this task.
  prefs: []
  type: TYPE_NORMAL
- en: Other Advanced Tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of advanced network-related tools out there you may find
    useful, including but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`socat`](https://oreil.ly/R4Upv)'
  prefs: []
  type: TYPE_NORMAL
- en: Establishes two bidirectional byte streams and enables the transferring of data
    between the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[`geoiplookup`](https://oreil.ly/huZpl)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to map an IP to a geographic region.
  prefs: []
  type: TYPE_NORMAL
- en: Tunnels
  prefs: []
  type: TYPE_NORMAL
- en: An easy-to-use alternative to VPNs and other site-to-site networking solutions.
    Enabled by such tools as [inlets](https://docs.inlets.dev).
  prefs: []
  type: TYPE_NORMAL
- en: BitTorrent
  prefs: []
  type: TYPE_NORMAL
- en: A peer-to-peer system that groups files into a package called a *torrent*. Check
    out [some clients](https://oreil.ly/Z4rak) to decide if this is something for
    your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we defined common network terms, from the hardware level, such
    as NICs, to the TCP/IP stack, to application-layer, user-facing components, such
    as HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Linux provides a powerful, standards-based implementation of the TCP/IP stack
    that you can use programmatically (for example, sockets) and in the context of
    setting up and querying (usually with the `ip` command).
  prefs: []
  type: TYPE_NORMAL
- en: We further discussed application-layer protocols and interfaces that make up
    most of the daily (network-related) flows. Your command-line friends here include
    `curl` for transfer and `dig` for DNS lookups.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to dive deeper into networking topics, check out the following
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP stack
  prefs: []
  type: TYPE_NORMAL
- en: '[*Understanding Linux Network Internals*](https://oreil.ly/pXRxW) by Christian
    Benvenuti (O’Reilly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“A Protocol for Packet Network Intercommunication”](https://oreil.ly/wRxdI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DHCP server setup webpage](https://oreil.ly/S6ZFJ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Hello IPv6: A Minimal Tutorial for IPv4 Users”](https://oreil.ly/DPgZc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Understanding IPv6—7 Part Series”](https://oreil.ly/91jkO)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Collection of IPv6 articles by Johannes Weber](https://oreil.ly/MUcxG)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iljitsch van Beijnum’s [BGP Expert website](https://oreil.ly/K47dS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Everything You Ever Wanted to Know About UDP Sockets but Were Afraid to Ask”](https://oreil.ly/CCrfA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS
  prefs: []
  type: TYPE_NORMAL
- en: '[“An Introduction to DNS Terminology, Components, and Concepts”](https://oreil.ly/K31GM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Install and Configure DNS Server in Linux”](https://oreil.ly/eKdtK)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Anatomy of a Linux DNS Lookup”](https://oreil.ly/KkVSf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“TLDs—Putting the *.fun* in the Top of the DNS”](https://oreil.ly/qwRTx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application layer and advanced networking
  prefs: []
  type: TYPE_NORMAL
- en: '[“SSH Tunneling Explained”](https://oreil.ly/3yhlV)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Everything curl*](https://oreil.ly/OzB6P)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“What Is DHCP and How to Configure DHCP Server in Linux”](https://oreil.ly/hrLpo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Install and Configure Linux NTP Server and Client”](https://oreil.ly/kHZhw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NFS wiki](https://oreil.ly/IOS4b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Use Wireshark at the Linux Command Line with TShark”](https://oreil.ly/1ttt0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Getting Started with socat”](https://oreil.ly/LWXCj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Geomapping Network Traffic”](https://oreil.ly/TAd0b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that, we’re ready to move on to the next topic in the book: using observability
    to avoid flying blind.'
  prefs: []
  type: TYPE_NORMAL
