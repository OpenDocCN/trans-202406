- en: Chapter 9\. The Standard Library and External Type Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript’s lead architect, Anders Hejlsberg, once said that he envisions “TypeScript
    to be the Switzerland of JavaScript,” meaning that it doesn’t prefer or work toward
    compatibility with a single framework but rather tries to cater to all JavaScript
    frameworks and flavors. In the past, TypeScript worked on a decorator implementation
    to convince Google not to pursue the JavaScript dialect [AtScript](https://oreil.ly/ZrcKR)
    for Angular, which was TypeScript plus decorators. The TypeScript decorator implementation
    also serves as a template for a respective [ECMAScript proposal on decorators](https://oreil.ly/76JuE).
    TypeScript also understands the JSX syntax extension, allowing frameworks like
    React or Preact to use TypeScript without limitations.
  prefs: []
  type: TYPE_NORMAL
- en: But even if TypeScript tries to cater to all JavaScript developers and makes
    a huge effort to integrate new and useful features for a plethora of frameworks,
    there are still things it can’t or won’t do. Maybe because a certain feature is
    too niche, or maybe because a decision would have huge implications for too many
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: This is why TypeScript has been designed to be extensible by default. A lot
    of TypeScript’s features like namespaces, modules, and interfaces allow for declaration
    merging, which gives you the possibility to add type definitions to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we look at how TypeScript deals with standard JavaScript functionality
    like modules, arrays, and objects. We will see some of their limitations, analyze
    the reasoning behind their limitations, and provide reasonable workarounds. You
    will see that TypeScript has been designed to be very flexible for various flavors
    of JavaScript, starting with sensible defaults, and giving you the opportunity
    to extend when you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Iterating over Objects with Object.keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you try to access object properties via iterating over its keys, TypeScript
    throws red squiggly lines at you, telling you that "`‘string’` can’t be used to
    index type.”
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `for-in` loop instead of `Object.keys` and lock your type using generic
    type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A prominent head-scratcher in TypeScript is trying to access an object property
    via iterating through its keys. This pattern is so common in JavaScript, yet TypeScript
    seems to keep you from using it at all costs. We use this simple line to iterate
    over an object’s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It leads to TypeScript throwing red squigglies at you and developers flipping
    tables: “Element implicitly has an `''any''` type because expression of type `''string''`
    can’t be used to index type `''Person''`.” In this situation, experienced JavaScript
    developers feel like TypeScript is working against them. But as with all decisions
    in TypeScript, there is a good reason why TypeScript behaves like this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find out why. Take a look at this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All we want is to print a `Person`’s fields by accessing them through its keys.
    TypeScript won’t allow this. `Object.keys(p)` returns a `string[]`, which is too
    wide to allow accessing a very defined object shape `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But why is that? Isn’t it obvious that we only access keys that are available?
    That’s the whole point of using `Object.keys`! It is, but we are also able to
    pass objects that are subtypes of `Person`, which can have more properties than
    defined in `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`printPerson` still should work correctly. It prints more properties, but it
    doesn’t break. It’s still the keys of `p`, so every property should be accessible.
    But what if you don’t access only `p`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume `Object.keys` gives you `(keyof Person)[]`. You can easily write
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If `Object.keys(p)` returns an array of type `keyof Person[]`, you will be able
    to access other objects of `Person`, too. This might not add up. In our example,
    we just print undefined. But what if you try to do something with those values?
    This will break at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript prevents you from scenarios like this. While we might think `Object.keys`
    is `keyof Person`, in reality, it can be so much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to mitigate this problem is to use type guards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But this adds an extra step that frankly shouldn’t be there.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another way to iterate over objects, using `for-in` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript will throw the same error for the same reason because you still
    can do things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And it will break at runtime. However, writing it like this gives you a little
    edge over the `Object.keys` version. TypeScript can be much more exact in this
    scenario if you add a generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Instead of requiring `p` to be `Person` (and thus be compatible with all subtypes
    of `Person`), we add a new generic type parameter `T` that is a subtype of `Person`.
    This means all types that have been compatible with this function signature are
    still compatible, but the moment we use `p`, we are dealing with an explicit subtype,
    not the broader supertype `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: We substitute `T` for something that is compatible with `Person` but where TypeScript
    knows that it’s concrete enough to prevent errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code works. `k` is of type `keyof T`. That’s why we can access
    `p`, which is of type `T`. And this technique still prevents us from accessing
    types that lack specific properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t access a `Person` with `keyof T`. They might be different. But since
    `T` is a subtype of `Person`, we still can assign properties, if we know the exact
    property names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And that’s exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript being very conservative about its types here is something that might
    seem odd at first, but it helps you in scenarios you wouldn’t think of. I guess
    this is the part where JavaScript developers usually scream at the compiler and
    think they’re “fighting” it, but maybe TypeScript saved you without you knowing
    it. For situations where this gets annoying, TypeScript at least gives you ways
    to work around it.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 Explicitly Highlighting Unsafe Operations with Type Assertions and unknown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parsing arbitrary data via JSON operations can go wrong if the data is not correct.
    TypeScript’s defaults don’t provide any safeguards for these unsafe operations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Explicitly highlight unsafe operations by using type assertions instead of type
    annotations, and make sure they are enforced by patching the original types with
    `unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Recipe 3.9](ch03.html#ch03_item_assertions) we spoke about how to effectively
    use type assertions. Type assertions are an explicit call to the type system to
    say that some type should be a different one, and based on some set of guardrails—for
    example, not saying `number` is actually `string`—TypeScript will treat this particular
    value as the new type.
  prefs: []
  type: TYPE_NORMAL
- en: 'With TypeScript’s rich and extensive type system, sometimes type assertions
    are inevitable. Sometimes you even want them, as shown in [Recipe 3.9](ch03.html#ch03_item_assertions)
    where we use the `fetch` API to get JSON data from a backend. One way is to call
    `fetch` and assign the results to an annotated type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`res.json()` results in `any`,^([1](ch09.html#id816)) and everything that is
    `any` can be changed to any other type through a type annotation. There is no
    guarantee that the result is actually `Person[]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way is to use a type assertion instead of a type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For the type system, this is the same thing, but we can easily scan situations
    where there might be problems. If we don’t validate our incoming values against
    types (with, for example, Zod; see [Recipe 12.5](ch12.html#ch12_zod)), then having
    a type assertion here is an effective way of highlighting unsafe operations.
  prefs: []
  type: TYPE_NORMAL
- en: '*Unsafe* operations in a type system are situations where we tell the type
    system that we expect values to be of a certain type, but we don’t have any guarantee
    from the type system itself that this will actually be true. This happens mostly
    at the borders of our application, where we load data from someplace, deal with
    user input, or parse data with built-in methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe operations can be highlighted by using certain keywords that indicate
    an explicit change in the type system. Type assertions (`as`), type predicates
    (`is`), or assertion signatures (`asserts`) help us find those situations. In
    some cases, TypeScript even forces us either to comply with its view of types
    or to explicitly change the rules based on our situations. But not always.
  prefs: []
  type: TYPE_NORMAL
- en: When we fetch data from some backend, it is just as easy to annotate as it is
    to write a type assertion. Things like that can be overlooked if we don’t force
    ourselves to use the correct technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can help TypeScript help us do the right thing. The problem is the call
    to `res.json()`, which comes from the `Body` interface in *lib.dom.d.ts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `json()` call returns a `Promise<any>`, and `any` is the loosey-goosey
    type where TypeScript just ignores any type-check at all. We would need `any`’s
    cautious brother, `unknown`. Thanks to declaration merging, we can override the
    `Body` type definition and define `json()` to be a bit more restrictive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The moment we do a type annotation, TypeScript yells at us that we can’t assign
    `unknown` to `Person[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But TypeScript is still happy if we do a type assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we can force TypeScript to highlight unsafe operations.^([2](ch09.html#id822))
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Working with defineProperty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You define properties on the fly using `Object.defineProperty`, but TypeScript
    doesn’t pick up changes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a wrapper function and use assertion signatures to change the object’s
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, you can define object properties on the fly with `Ob⁠je⁠ct.de⁠fi⁠ne​Pr⁠op⁠er⁠ty`.
    This is useful if you want your properties to be read-only. Think of a storage
    object that has a maximum value that shouldn’t be overwritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`defineProperty` and property descriptors are very complex. They allow you
    to do everything with properties that usually is reserved for built-in objects.
    So they’re common in larger codebases. TypeScript has a problem with `defineProperty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t explicitly assert to a new type, we don’t get `maxValue` attached
    to the type of `storage`. However, for simple use cases, we can help ourselves
    using assertion signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While TypeScript might not feature object changes when using `Object.defineProperty`,
    there is a chance that the team will add typings or special behavior for cases
    like this in the future. For example, checking if an object has a certain property
    using the `in` keyword didn’t affect types for years. This changed in 2022 with
    [TypeScript 4.9](https://oreil.ly/YpyGG).
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of an `assertIsNumber` function where you can make sure some value is
    of type `number`. Otherwise, it throws an error. This is similar to the `assert`
    function in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To comply with behavior like this, we can add an assertion signature that tells
    TypeScript that we know more about the type after this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This works a lot like type predicates (see [Recipe 3.5](ch03.html#ch03_item_type_predicates))
    but without the control flow of a condition-based structure like `if` or `switch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you look at it closely, you can see those assertion signatures can *change
    the type of a parameter or variable on the fly*. This is what `Object.defineProperty`
    does as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following helper does not aim to be 100% accurate or complete. It might
    have errors, and it might not tackle every edge case of the `defineProperty` specification.
    But it will give us the basic functionality. First, we define a new function called
    `de⁠fin⁠e​Pr⁠ope⁠rty` that we use as a wrapper function for `Object.defineProperty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We work with three generics:'
  prefs: []
  type: TYPE_NORMAL
- en: The object we want to modify, of type `Obj`, which is a subtype of `object`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type `Key`, which is a subtype of `PropertyKey` (built-in): `string | number
    | ​sy⁠mb⁠ol`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDesc`, a subtype of `PropertyDescriptor` (built-in). This allows us to define
    the property with all its features (writability, enumerability, reconfigurability).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use generics because TypeScript can narrow them to a very specific unit type.
    `PropertyKey`, for example, is all numbers, strings, and symbols. But if we use
    `Key extends PropertyKey`, we can pinpoint `prop` to be, for example, type `"maxValue"`.
    This is helpful if we want to change the original type by adding more properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `Object.defineProperty` function either changes the object or throws an
    error should something go wrong. That’s exactly what an assertion function does.
    Our custom helper `defineProperty` thus does the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add an assertion signature. Once `defineProperty` successfully executes,
    our object has another property. We are creating some helper types for that. The
    signature first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`obj` then is of type `Obj` (narrowed through a generic) and our newly defined
    property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `DefineProperty` helper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we deal with the `writable` property of a `PropertyDescriptor`. It’s
    a set of conditions to define some edge cases and conditions of how the original
    property descriptors work:'
  prefs: []
  type: TYPE_NORMAL
- en: If we set `writable` and any property accessor (`get`, `set`), we fail. `never`
    tells us that an error was thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we set `writable` to `false`, the property is read-only. We defer to the
    `InferValue` helper type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we set `writable` to `true`, the property is not read-only. We defer as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last default case is the same as `writable: false`, so `Readonly<InferValue<Prop,
    Desc>>`. (`Readonly<T>` is built-in.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the `InferValue` helper type, dealing with the set `value` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Again a set of conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we have a getter and a value set? `Object.defineProperty` throws an error,
    so `never`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have set a value, let’s infer the type of this value and create an object
    with our defined property key and the value type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or we infer the type from the return type of a getter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else we forget. TypeScript won’t let us work with the object as it’s
    becoming `never`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lots of helper types, but roughly 20 lines of code to get it right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what TypeScript does with our changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: While this might not cover everything, there is already a lot done for simple
    property definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Expanding Types for Array.prototype.includes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript won’t be able to look for an element of a broad type like `string`
    or `number` within a very narrow tuple or array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create generic helper functions with type predicates, where you change the relationship
    between type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create an array called `actions`, which contains a set of actions in string
    format that we want to execute. The resulting type of this `actions` array is
    `string[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `execute` function takes any string as an argument. We check if this is
    a valid action, and if so, do something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It gets a little trickier if we want to narrow the `string[]` to something more
    concrete, a subset of all possible strings. By adding *const context* via `as
    const`, we can narrow `actions` to be of type `readonly ["CREATE", "READ", "UPDATE",
    "DELETE"]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is handy if we want to do exhaustiveness checking to make sure we have
    cases for all available actions. However, `actions.includes` does not agree with
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is that? Let’s look at the typings of `Array<T>` and `ReadonlyArray<T>`
    (we work with the latter due to *const context*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The element we want to search for (`searchElement`) needs to be of the same
    type as the array itself! So if we have `Array<string>` (or `string[]` or `Re⁠ad⁠on⁠ly​Ar⁠ra⁠y<s⁠tr⁠in⁠g>`),
    we can search only for strings. In our case, this would mean that `action` needs
    to be of type `"CREATE" | "READ" | "UPDATE" | "DELETE"`.
  prefs: []
  type: TYPE_NORMAL
- en: Suddenly, our program doesn’t make a lot of sense anymore. Why do we search
    for something if the type already tells us that it can be just one of four strings?
    If we change the type for `action` to `"CREATE" | "READ" | "UPDATE" | "DELETE"`,
    `actions.includes` becomes obsolete. If we don’t change it, TypeScript throws
    an error at us, and rightfully so!
  prefs: []
  type: TYPE_NORMAL
- en: One of the problems is that TypeScript lacks the possibility to check for contravariant
    types with, for example, upper-bound generics. We can tell if a type should be
    a *subset* of type `T` with constructs like `extends`; we can’t check if a type
    is a *superset* of `T`. At least not yet!
  prefs: []
  type: TYPE_NORMAL
- en: So what can we do?
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: Redeclare ReadonlyArray'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One option that comes to mind is changing how `includes` in `ReadonlyArray`
    should behave. Thanks to declaration merging, we can add our own definitions for
    `Re⁠ad⁠on⁠ly​Ar⁠ray` that are a bit looser in the arguments and more specific
    in the result, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This allows for a broader set of `searchElement` values to be passed (literally
    any!), and if the condition is true, we tell TypeScript through a *type predicate*
    that `se⁠ar⁠ch​Ele⁠men⁠t is⁠ T` (the subset we are looking for).
  prefs: []
  type: TYPE_NORMAL
- en: 'Turns out, this works pretty well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a problem, though. The solution works but takes the assumption of what’s
    correct and what needs to be checked. If you change `action` to `number`, TypeScript
    usually throws an error that you can’t search for that kind of type. `actions`
    only consists of `string`, so why even look at `number`? This is an error you
    want to catch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With our change to `ReadonlyArray`, we lose this check as `searchElement` is
    `any`. While the functionality of `action.includes` still works as intended, we
    might not see the right *problem* once we change function signatures along the
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Also, and more important, we change the behavior of built-in types. This might
    change your type-checks somewhere else and might cause problems in the long run!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you do a *type patch* by changing behavior from the standard library, be
    sure to do this module scoped, and not globally.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2: A helper with type assertions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As originally stated, one of the problems is that TypeScript lacks the possibility
    to check if a value belongs to a *superset* of a generic parameter. With a helper
    function, we can turn this relationship around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `includes` function takes the `ReadonlyArray<T>` as an argument and searches
    for an element that is of type `U`. We check through our generic bounds that `T
    extends U`, which means that `U` is a *superset* of `T` (or `T` is a *subset*
    of `U`). If the method returns `true`, we can say for sure that `el` is of the
    *narrower* type `U`.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that we need to make the implementation work is to do a little
    type assertion the moment we pass `el` to `Array.prototype.includes`. The original
    problem is still there! The type assertion `el as T` is OK, though, as we check
    possible problems already in the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means the moment we change, for example, `action` to `number`, we get
    the right errors throughout our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And this is the behavior we want. A nice touch is that TypeScript wants us to
    change the array, not the element we are looking for. This is due to the relationship
    between the generic type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The same solutions also work if you run into similar troubles with `Array.prototype.indexOf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript aims to get all standard JavaScript functionality correct, but sometimes
    you have to make trade-offs. This case calls for trade-offs: do you allow for
    an argument list that’s looser than you would expect, or do you throw errors for
    types where you already should know more?'
  prefs: []
  type: TYPE_NORMAL
- en: Type assertions, declaration merging, and other tools help us get around that
    in situations where the type system can’t help us. Not until it becomes better
    than before, by allowing us to move even further in the type space.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Filtering Nullish Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use the Boolean constructor to filter nullish values from an array,
    but TypeScript still yields the same types, including `null` and `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overload the `filter` method from `Array` using declaration merging.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you have collections that could include *nullish* values (`undefined`
    or `null`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To continue working, you want to remove those nullish values from your collection.
    This is typically done using the `filter` method of `Array`, maybe by checking
    the *truthiness* of a value. `null` and `undefined` are *falsy*, so they get filtered
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A convenient way of checking the truthiness of a value is by passing it to
    the Boolean constructor. This is short, on point, and very elegant to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: But sadly, it doesn’t change our type. We still have `null` and `undefined`
    as possible types for the filtered array.
  prefs: []
  type: TYPE_NORMAL
- en: 'By opening up the `Array` interface and adding another declaration for `filter`,
    we can add this special case as an overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, we get rid of nullish types and have more clarity on the type
    of our array’s contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Neat! What’s the caveat? Literal tuples and arrays. `BooleanConstructor` filters
    not only nullish values but also falsy values. To get the right elements, we not
    only have to return `NonNullable<T>` but also introduce a type that checks for
    truthy values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The example includes `0n` which is 0 in the `BigInt` type. This type is available
    only from ECMAScript 2020 on.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us the right idea of which types to expect, but since `ReadonlyArray<T>`
    takes the tuple’s elements types and not the tuple type itself, we lose information
    on the order of types within the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: As with all extensions to existing TypeScript types, be aware that this might
    cause side effects. Scope them locally and use them carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Extending Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You work with libraries that provide their own view of HTML elements, like Preact
    or React. But sometimes their type definitions don’t include the latest features.
    You want to patch them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use declaration merging on the module and interface level.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*JSX* is a syntax extension to JavaScript, introducing an XML-like way of describing
    and nesting components. Basically, everything that can be described as a tree
    of elements can be expressed in JSX. JSX was introduced by the creators of the
    popular React framework to make it possible to write and nest components in an
    HTML-like way within JavaScript, where it is actually transpiled to a series of
    function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: JSX has since been adopted by many frameworks, even if there is little or no
    connection to React. There’s a lot more on JSX in [Chapter 10](ch10.html#ch10).
  prefs: []
  type: TYPE_NORMAL
- en: React typings for TypeScript come with lots of interfaces for all possible HTML
    elements. But sometimes your browsers, your frameworks, or your code are a little
    bit ahead of what’s possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to use the latest image features in Chrome and load your
    images lazily. This is a progressive enhancement, so only browsers that understand
    what’s going on know how to interpret this. Other browsers are robust enough not
    to care:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'But your TypeScript JSX code? Errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To prevent this, we can extend the available interfaces with our own properties.
    This TypeScript feature is called *declaration merging*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an *@types* folder and put a *jsx.d.ts* file in it. Change your TypeScript
    config so your compiler options allow for extra types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We re-create the exact module and interface structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The module is called `'react'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface is `ImgHTMLAttributes<T> extends HTMLAttributes<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We know that from the original typings. Here, we add the properties we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And while we are at it, let’s make sure we don’t forget alt texts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That’s much better! TypeScript will take the original definition and merge your
    declarations. Your autocomplete can give you all available options *and* will
    error when you forget an alt text.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with [Preact](https://preactjs.com), things are a bit more complicated.
    The original HTML typings are very generous and not as specific as React’s typings.
    That’s why we have to be a bit more explicit when defining images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes sure that both `alt` and `src` are available and adds a new attribute
    called `loading`. The technique is the same, though: declaration merging, which
    works on the level of namespaces, interfaces, and modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.7 Augmenting Globals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use a browser feature like `ResizeObserver` and see that it isn’t available
    in your current TypeScript configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Augment the global namespace with custom type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript stores types to all DOM APIs in *lib.dom.d.ts*. This file is autogenerated
    from Web IDL files. *Web IDL* stands for *Web Interface Definition Language* and
    is a format the W3C and WHATWG use to define interfaces to web APIs. It came out
    around 2012 and has been a standard since 2016.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you read standards at [W3C](https://www.w3.org)—like on [Resize Observer](https://oreil.ly/XeSUG)—you
    can see parts of a definition or the full definition somewhere within the specification.
    Like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Browsers use this as a guideline to implement respective APIs. TypeScript uses
    these IDL files to generate *lib.dom.d.ts*. The [TypeScript and JavaScript lib
    generator](https://oreil.ly/WLcLB) project scrapes web standards and extracts
    IDL information. Then an *IDL to TypeScript* generator parses the IDL file and
    generates the correct typings.
  prefs: []
  type: TYPE_NORMAL
- en: Pages to scrape are maintained manually. The moment a specification is far enough
    and supported by all major browsers, people add a new resource and see their change
    released with an upcoming TypeScript version. So it’s just a matter of time until
    we get `ResizeObserver` in *lib.dom.d.ts*.
  prefs: []
  type: TYPE_NORMAL
- en: If we can’t wait, we can add the typings ourselves but only for the project
    we currently are working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we generated the types for `ResizeObserver`. We would store the
    output in a file called *resize-observer.d.ts*. Here are the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a ton of interfaces and some variables that implement our interfaces,
    like `declare var ResizeObserver`, which is the object that defines the prototype
    and constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This already helps a lot. We can use the (arguably) long type declarations and
    put them directly in the file where we need them. `ResizeObserver` is found! We
    want to have it available everywhere, though.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to TypeScript’s declaration-merging feature, we can extend *namespaces*
    and *interfaces* as needed. This time, we’re extending the *global namespace*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The global namespace contains all objects and interfaces that are, well, globally
    available. Like the `window` object (and `Window` interface), as well as everything
    else that should be part of our JavaScript execution context. We augment the global
    namespace and add the `ResizeObserver` object to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s put *resize-observer.d.ts* in a folder called *@types*. Don’t forget
    to add the folder to the sources that TypeScript will parse as well as the list
    of type declaration folders in *tsconfig.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there’s a significant possibility that `ResizeObserver` is not yet available
    in your target browser, make sure that you make the `ResizeObserver` object `undefined`.
    This urges you to check if the object is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This makes working with `ResizeObserver` as safe as possible!
  prefs: []
  type: TYPE_NORMAL
- en: 'It might be that TypeScript doesn’t pick up your ambient declaration files
    and the global augmentation. If this happens, make sure that:'
  prefs: []
  type: TYPE_NORMAL
- en: You parse the *@types* folder via the `include` property in *tsconfig.json*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your ambient type declaration files are recognized as such by adding them to
    `types` or `typeRoots` in the *tsconfig.json* compiler options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You add `export {}` at the end of your ambient declaration file so TypeScript
    recognizes this file as a module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.8 Adding Non-JS Modules to the Module Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use a bundler like Webpack to load files like *.css* or images from JavaScript,
    but TypeScript does not recognize those files.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Globally declare modules based on filename extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a movement in web development to make JavaScript the default entry
    point of everything and let it handle all relevant assets via `import` statements.
    What you need for this is a build tool, a bundler, that analyzes your code and
    creates the right artifacts. A popular tool for this is [Webpack](https://webpack.js.org),
    a JavaScript bundler that allows you to bundle *everything*—CSS, Markdown, SVGs,
    JPEGs, you name it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Webpack uses a concept called *loaders*, which looks at file endings and activates
    certain bundling concepts. Importing *.css* files in JavaScript is not native.
    It’s part of Webpack (or whatever bundler you are using). However, we can teach
    TypeScript to understand files like this.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a proposal in the ECMAScript standards committee to allow imports of
    files other than JavaScript and assert certain built-in formats for this. This
    will have an effect on TypeScript eventually. You can read all about it [here](https://oreil.ly/stAm5).
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript supports *ambient module declarations*, even for a module that is
    not “physically” there but in the environment or reachable via tooling. One example
    is Node’s main built-in modules, like `url`, `http` or `path`, as described in
    TypeScript’s documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is great for modules where we know the exact name. We can also use the
    same technique for wildcard patterns. Let’s declare a generic ambient module for
    all our *.css* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern is ready. This listens to all *.css* files we want to import. What
    we expect is a list of class names that we can add to our components. Since we
    don’t know which classes are defined in the *.css* files, let’s go with an object
    that accepts every string key and returns a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: That’s all we need to make our files compile again. The only downside is that
    we can’t use the exact class names to get autocompletion and similar benefits.
    A way to solve this is to generate type files automatically. There are packages
    on [NPM](https://oreil.ly/sDBv0) that deal with that problem. Feel free to choose
    one of your liking.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a bit easier if we want to import something like MDX into our modules.
    MDX lets us write Markdown, which parses to regular React (or JSX) components
    (more on React in [Chapter 10](ch10.html#ch10)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We expect a functional component (that we can pass props to) that returns a
    JSX element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And voilà! We can load *.mdx* files in JavaScript and use them as components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t know what to expect, make your life easy. All you need to do is
    declare the module. Don’t provide any types. TypeScript will allow loading but
    won’t give you any type safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To make ambient modules available to your app, it is recommended to create
    an *@types* folder somewhere in your project (probably root level). There you
    can put any amount of *.d.ts* files with your module definitions. Add a referral
    to your *tsconfig.json*, and TypeScript knows what to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: One of TypeScript’s main features is to be adaptable to all JavaScript flavors.
    Some things are built-in, and others need some extra patching from you.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch09.html#id816-marker)) Back when the API defintiion was created, `unknown`
    didn’t exist. Also, TypeScript has a strong focus on developer productivity, and
    with `res.json()` being a widely used method, this would’ve broken countless applications.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch09.html#id822-marker)) Credit to Dan Vanderkam’s [*Effective TypeScript*
    blog](https://effectivetypescript.com) for inspiration on this subject.
  prefs: []
  type: TYPE_NORMAL
