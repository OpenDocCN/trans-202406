<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 6. Supply Chain Security" data-type="chapter" epub:type="chapter"><div class="chapter" id="supply_chain_security">
<h1><span class="label">Chapter 6. </span>Supply Chain Security</h1>
<p><a data-primary="supply chain security" data-secondary="about" data-type="indexterm" id="idm46394751707376"/><a data-primary="supply chain security" data-type="indexterm" id="scs_ch"/>Earlier chapters primarily focused on securing the Kubernetes cluster and its components, the OS infrastructure used to run cluster nodes, and the operational aspects for running workload on a cluster node with existing container images. This chapter takes a step back and drills into the process, best practices, and tooling for designing, building, and optimizing container images.</p>
<p>Sometimes, you do not want to create your own container image but instead consume an existing one produced by a different team or company. Scanning container images for known vulnerabilities in a manual or automated fashion should be part of your vetting process before using them to run your workload. We’ll talk through some options relevant to the CKS exam used to identify, analyze, and mitigate security risks for pre-built container images.</p>
<p>At a high level, this chapter covers the following concepts:</p>
<ul>
<li>
<p>Minimizing base image footprint</p>
</li>
<li>
<p>Securing the supply chain</p>
</li>
<li>
<p>Using static analysis of user workload</p>
</li>
<li>
<p>Scanning images for known vulnerabilities</p>
</li>
</ul>
<section class="less_space" data-pdf-bookmark="Minimizing the Base Image Footprint" data-type="sect1"><div class="sect1" id="idm46394751700304">
<h1>Minimizing the Base Image Footprint</h1>
<p><a data-primary="base images" data-secondary="minimizing footprint for" data-type="indexterm" id="bi_min"/><a data-primary="supply chain security" data-secondary="minimizing base image footprint" data-type="indexterm" id="scs_min"/>The process for building a container image looks straightforward on the surface level; however, the devil is often in the details. It may not be obvious to someone new to the topic to refrain from building a container image that is unnecessarily too large in size, riddled with vulnerabilities, and not optimized for container layer caching. We’ll address all of those aspects in the course of this chapter with the help of the container engine Docker.</p>
<section data-pdf-bookmark="Scenario: An Attacker Exploits Container Vulnerabilities" data-type="sect2"><div class="sect2" id="idm46394751695840">
<h2>Scenario: An Attacker Exploits Container Vulnerabilities</h2>
<p><a data-primary="Dockerfiles" data-type="indexterm" id="idm46394751694448"/><a data-primary="scenarios" data-secondary="attacker exploits container vulnerabilities" data-type="indexterm" id="idm46394751693744"/>One of the first decisions you have to make when defining a Dockerfile is the selection of a base image. The base image provides the operating system and additional dependencies, and it may expose shell access.</p>
<p><a data-primary="Docker Hub" data-type="indexterm" id="idm46394751692320"/>Some of the base images you can choose from on a public registry like Docker Hub are large in size and will likely contain functionality you don’t necessarily need to run your application inside of it. The operating system itself, as well as any dependencies available with the base image, can expose vulnerabilities.</p>
<p>In <a data-type="xref" href="#container-image-vulnerabilities-attacker">Figure 6-1</a>, the attacker was able to figure out details about the container by gaining access to it. Those vulnerabilities can now be used as a launching pad for more advanced attacks.</p>
<figure><div class="figure" id="container-image-vulnerabilities-attacker">
<img alt="ckss 0601" height="608" src="assets/ckss_0601.png" width="954"/>
<h6><span class="label">Figure 6-1. </span>An attacker exploits container image vulnerabilities</h6>
</div></figure>
<p><a data-primary="documentation" data-secondary="Docker" data-type="indexterm" id="idm46394751687952"/>It is recommended to use a base image with a minimal set of functionality and dependencies. The next couple of sections will explain the methods for creating a more optimized base image that’s faster to build, quicker to download from a container registry, and that will ultimately lead to a smaller attack surface simply by reducing the bloat. The next sections will touch on the most important techniques. You can find a more detailed list of best practices for writing Dockerfiles in the <a href="https://oreil.ly/43Diy">Docker documentation</a>.</p>
</div></section>
<section data-pdf-bookmark="Picking a Base Image Small in Size" data-type="sect2"><div class="sect2" id="small-sized-base-image">
<h2>Picking a Base Image Small in Size</h2>
<p><a data-primary="size, of base images" data-type="indexterm" id="idm46394751683952"/><a data-primary="base images" data-secondary="selecting" data-type="indexterm" id="idm46394751683248"/><a data-primary="images" data-secondary="base" data-type="indexterm" id="idm46394751682304"/>Some container images can have a size of a gigabyte or even more. Do you really need all the functionality bundled with such a container image? Unlikely. Thankfully, many container producers upload a wide range of variations of their container images for the same release. One of those variations is an <code>alpine</code> image, a small, lightweight, and less vulnerable Linux distribution. As you can see in the following output, the downloaded <code>alpine</code> container image with the tag <code>3.17.0</code> only has a size of 7.05MB:</p>
<pre data-type="programlisting"><strong>$ docker pull alpine:3.17.0</strong>
...
<strong>$ docker image ls alpine</strong>
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
alpine       3.17.0    49176f190c7e   3 weeks ago   7.05MB</pre>
<p>The <code>alpine</code> container image comes with an <code>sh</code> shell you can use to troubleshoot the process running inside of the container. You can use the following command to open an interactive shell in a new container:</p>
<pre data-type="programlisting"><strong>$ docker run -it alpine:3.17.0 /bin/sh</strong>
/ # exit</pre>
<p>While runtime troubleshooting functionality can be useful, offering a shell as part of a container image increases the size of it and potentially opens the door for attackers. Additionally, the more software there is inside of a container image, the more vulnerabilities it will have.</p>
<p><a data-primary="images" data-secondary="distroless" data-type="indexterm" id="idm46394751674976"/><a data-primary="distroless image" data-type="indexterm" id="idm46394751674000"/><a data-primary="Google distroless image" data-type="indexterm" id="idm46394751673328"/>You can further reduce the container image size and the attack surface by using a <a href="https://oreil.ly/J6Vra">distroless image</a> offered by Google. The following command downloads the latest tag of the container image <code>gcr.io/distroless/static-debian11</code> and renders its details. The size of the container image is only 2.34MB:</p>
<pre data-type="programlisting"><strong>$ docker pull gcr.io/distroless/static-debian11</strong>
...
<strong>$ docker image ls gcr.io/distroless/static-debian11:latest</strong>
REPOSITORY                          TAG       IMAGE ID       CREATED      \
  SIZE
gcr.io/distroless/static-debian11   latest    901590160d4d   53 years ago \
  2.34MB</pre>
<p>A distroless container image does not ship with any shell, which you can observe by running the following command:</p>
<pre data-type="programlisting"><strong>$ docker run -it gcr.io/distroless/static-debian11:latest /bin/sh</strong>
docker: Error response from daemon: failed to create shim task: OCI runtime \
create failed: runc create failed: unable to start container process: exec: \
"/bin/sh": stat /bin/sh: no such file or directory: unknown.</pre>
<p><a data-primary="documentation" data-secondary="Kubernetes" data-type="indexterm" id="idm46394751667968"/>Kubernetes offers the concept of ephemeral containers for troubleshooting distroless containers. Those containers are meant to be disposable and can be deployed for troubleshooting minimal containers that would usually not allow opening a shell. Discussing ephemeral containers is out of scope of this book, but you can find more information about them in the <a href="https://oreil.ly/IRjP3">Kubernetes documentation</a>.</p>
</div></section>
<section data-pdf-bookmark="Using a Multi-Stage Approach for Building Container Images" data-type="sect2"><div class="sect2" id="idm46394751685440">
<h2>Using a Multi-Stage Approach for Building Container Images</h2>
<p><a data-primary="multi-stage approach, using for building container images" data-type="indexterm" id="idm46394751664576"/><a data-primary="Dockerfiles" data-type="indexterm" id="idm46394751663824"/><a data-primary="images" data-secondary="container" data-type="indexterm" id="idm46394751663152"/><a data-primary="container images" data-secondary="using a multi-stage approach for building" data-type="indexterm" id="idm46394751662208"/><a data-primary="Docker, multi-stage build in" data-type="indexterm" id="idm46394751661168"/>As a developer, you can decide to build the application code as part of the instructions in a Dockerfile. This process may include compiling the code and building a binary that should become the entry point of the container image. Having all the necessarily tools and dependencies available to implement the process will automatically blow up the size of the container image, plus you won’t need those dependencies at runtime anymore.</p>
<p>The idea of a <a href="https://oreil.ly/znQc3">multi-stage build in Docker</a> is that you separate the build stage from the runtime stage. As a result, all dependencies needed in the build stage will be discarded after the process has been performed and therefore do not end up in the final container image. This approach leads to a much smaller container image size by removing all the unnecessary cruft.</p>
<p><a data-primary="Go runtime" data-type="indexterm" id="idm46394751659040"/>While we won’t go into the details of crafting and fully understanding multi-stage Dockerfile, I want to show you the differences on a high level. We’ll start by showing you a Dockerfile that builds and tests a simple program using the programming language Go, as shown in <a data-type="xref" href="#dockerfile-single-stage">Example 6-1</a>. In essence, we are using a <a href="https://oreil.ly/nwLtT">base image</a> that includes Go 1.19.4. The Go runtime provides the <code>go</code> executes, which we’ll invoke to execute the tests and build the binary of the application.</p>
<div data-type="example" id="dockerfile-single-stage">
<h5><span class="label">Example 6-1. </span>Building and testing a Go program using a Go base image</h5>
<pre data-code-language="dockerfile" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">golang:1.19.4-alpine</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO1-1" id="co_supply_chain_security_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="k">WORKDIR</code><code class="w"> </code><code class="s">/app</code><code class="w">
</code><code class="w">
</code><code class="k">COPY</code><code class="w"> </code><code>go.mod</code><code class="w"> </code><code>.</code><code class="w">
</code><code class="k">COPY</code><code class="w"> </code><code>go.sum</code><code class="w"> </code><code>.</code><code class="w">
</code><code class="k">RUN</code><code class="w"> </code><code>go</code><code class="w"> </code><code>mod</code><code class="w"> </code><code>download</code><code class="w">
</code><code class="w">
</code><code class="k">COPY</code><code class="w"> </code><code>.</code><code class="w"> </code><code>.</code><code class="w">
</code><code class="k">RUN</code><code class="w"> </code><code class="nv">CGO_ENABLED</code><code class="o">=</code><code class="m">0</code><code class="w"> </code><code>go</code><code class="w"> </code><code class="nb">test</code><code class="w"> </code><code>-v</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO1-2" id="co_supply_chain_security_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="k">RUN</code><code class="w"> </code><code>go</code><code class="w"> </code><code>build</code><code class="w"> </code><code>-o</code><code class="w"> </code><code>/go-sample-app</code><code class="w"> </code><code>.</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO1-3" id="co_supply_chain_security_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="k">CMD</code><code class="w"> </code><code class="p">[</code><code class="s2">"/go-sample-app"</code><code class="p">]</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_supply_chain_security_CO1-1" id="callout_supply_chain_security_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Uses a Go base image</p></dd>
<dt><a class="co" href="#co_supply_chain_security_CO1-2" id="callout_supply_chain_security_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Executes the tests against the application code</p></dd>
<dt><a class="co" href="#co_supply_chain_security_CO1-3" id="callout_supply_chain_security_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Builds the binary of the Go application</p></dd>
</dl>
<p><a data-primary="commands" data-secondary="docker build" data-type="indexterm" id="idm46394751563552"/><a data-primary="docker build command" data-type="indexterm" id="idm46394751562576"/>You can produce the image using the <code>docker build</code> command, as shown in the following:</p>
<pre data-type="programlisting"><strong>$ docker build . -t go-sample-app:0.0.1</strong>
...</pre>
<p><a data-primary="commands" data-secondary="go build" data-type="indexterm" id="idm46394751521936"/><a data-primary="go build command" data-type="indexterm" id="idm46394751520960"/>The size of the result container image is pretty big, 348MB, and there’s a good reason for it. It includes the Go runtime, even though we don’t actually need it anymore when starting the container. The <code>go build</code> command produced the binary that we can run as the container’s entry point:</p>
<pre data-type="programlisting"><strong>$ docker images</strong>
REPOSITORY      TAG     IMAGE ID       CREATED          SIZE
go-sample-app   0.0.1   88175f3ab0d3   44 seconds ago   358MB</pre>
<p>Next up, we’ll have a look at the multi-stage approach. In a multi-stage Dockerfile, you define at least two stages. In <a data-type="xref" href="#dockerfile-multi-stage">Example 6-2</a>, we specify a stage aliased with <code>build</code> to run the tests and build the binary, similarly to what we’ve done earlier. A second stage copies the binary produced by the stage <code>build</code> into a dedicated directory; however, it uses the <code>alpine</code> base image to run it. When running the <code>docker build</code> command, the stage <code>build</code> will not be included in the final container image anymore.</p>
<div data-type="example" id="dockerfile-multi-stage">
<h5><span class="label">Example 6-2. </span>Building and testing a Go program as part of a multi-stage Dockerfile</h5>
<pre data-code-language="dockerfile" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">golang:1.19.4-alpine</code><code class="w"> </code><code class="k">AS</code><code class="w"> </code><code class="s">build</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO2-1" id="co_supply_chain_security_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="k">RUN</code><code class="w"> </code><code>apk</code><code class="w"> </code><code>add</code><code class="w"> </code><code>--no-cache</code><code class="w"> </code><code>git</code><code class="w">
</code><code class="k">WORKDIR</code><code class="w"> </code><code class="s">/tmp/go-sample-app</code><code class="w">
</code><code class="k">COPY</code><code class="w"> </code><code>go.mod</code><code class="w"> </code><code>.</code><code class="w">
</code><code class="k">COPY</code><code class="w"> </code><code>go.sum</code><code class="w"> </code><code>.</code><code class="w">
</code><code class="k">RUN</code><code class="w"> </code><code>go</code><code class="w"> </code><code>mod</code><code class="w"> </code><code>download</code><code class="w">
</code><code class="k">COPY</code><code class="w"> </code><code>.</code><code class="w"> </code><code>.</code><code class="w">
</code><code class="w">
</code><code class="k">RUN</code><code class="w"> </code><code class="nv">CGO_ENABLED</code><code class="o">=</code><code class="m">0</code><code class="w"> </code><code>go</code><code class="w"> </code><code class="nb">test</code><code class="w"> </code><code>-v</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO2-2" id="co_supply_chain_security_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="k">RUN</code><code class="w"> </code><code>go</code><code class="w"> </code><code>build</code><code class="w"> </code><code>-o</code><code class="w"> </code><code>./out/go-sample-app</code><code class="w"> </code><code>.</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO2-3" id="co_supply_chain_security_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">
</code><code class="k">FROM</code><code class="w"> </code><code class="s">alpine:3.17.0</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO2-4" id="co_supply_chain_security_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="k">RUN</code><code class="w"> </code><code>apk</code><code class="w"> </code><code>add</code><code class="w"> </code><code>ca-certificates</code><code class="w">
</code><code class="k">COPY</code><code class="w"> </code><code>--from</code><code class="o">=</code><code>build</code><code class="w"> </code><code>/tmp/go-sample-app/out/go-sample-app</code><code class="w"> </code><code>/app/go-sample-app</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO2-5" id="co_supply_chain_security_CO2-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code class="w">
</code><code class="k">CMD</code><code class="w"> </code><code class="p">[</code><code class="s2">"/app/go-sample-app"</code><code class="p">]</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_supply_chain_security_CO2-1" id="callout_supply_chain_security_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Uses a Go base image for building and testing the program in the stage named <code>build</code>.</p></dd>
<dt><a class="co" href="#co_supply_chain_security_CO2-2" id="callout_supply_chain_security_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Executes the tests against the application code.</p></dd>
<dt><a class="co" href="#co_supply_chain_security_CO2-3" id="callout_supply_chain_security_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Builds the binary of the Go application.</p></dd>
<dt><a class="co" href="#co_supply_chain_security_CO2-4" id="callout_supply_chain_security_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Uses a much smaller base image for running the application in a container.</p></dd>
<dt><a class="co" href="#co_supply_chain_security_CO2-5" id="callout_supply_chain_security_CO2-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>Copies the application binary produced in the <code>build</code> stage and uses it as the command to run when the container is started.</p></dd>
</dl>
<p>The resulting container image size is significantly smaller when using the <code>alpine</code> base image, only 12MB. You can verify the outcome by running the <code>docker build</code> command again and inspecting the size of the container image by listing it:</p>
<pre data-type="programlisting"><strong>$ docker build . -t go-sample-app:0.0.1</strong>
...
<strong>$ docker images</strong>
REPOSITORY      TAG     IMAGE ID       CREATED          SIZE
go-sample-app   0.0.1   88175f3ab0d3   44 seconds ago   12MB</pre>
<p><a data-primary="attack surface, reducing" data-type="indexterm" id="idm46394751359344"/>Not only did we reduce the size, we also reduced the attack surface by including fewer dependencies. You can further reduce the size of the container image by incorporating a distroless base image instead of the <code>alpine</code> base image.</p>
</div></section>
<section data-pdf-bookmark="Reducing the Number of Layers" data-type="sect2"><div class="sect2" id="idm46394751665568">
<h2>Reducing the Number of Layers</h2>
<p><a data-primary="layers, reducing number of" data-type="indexterm" id="idm46394751356768"/><a data-primary="reducing attack surface/number of payers" data-type="indexterm" id="idm46394751355872"/><a data-primary="CMD command" data-type="indexterm" id="idm46394751355104"/><a data-primary="commands" data-secondary="CMD" data-type="indexterm" id="idm46394751354432"/><a data-primary="commands" data-secondary="FROM" data-type="indexterm" id="idm46394751353488"/><a data-primary="FROM command" data-type="indexterm" id="idm46394751352544"/><a data-primary="commands" data-secondary="COPY" data-type="indexterm" id="idm46394751351872"/><a data-primary="COPY command" data-type="indexterm" id="idm46394751350928"/><a data-primary="commands" data-secondary="RUN" data-type="indexterm" id="idm46394751350256"/><a data-primary="RUN command" data-type="indexterm" id="idm46394751349312"/>Every Dockerfile consists of an ordered list of instructions. Only some instructions create a read-only layer in the resulting container image. Those instructions are <code>FROM</code>, <code>COPY</code>, <code>RUN</code>, and <code>CMD</code>. All other instructions will not create a layer as they create temporary intermediate images. The more layers you add to the container image, the slower will be the build execution time and/or the bigger will be the size of the container image. Therefore, you need to be cautious about the instructions used in your Dockerfile to minimize the footprint of the container image.</p>
<p>It’s common practice to execute multiple commands in a row. You may define those commands using a list of <code>RUN</code> instructions on individual lines, as shown in 
<span class="keep-together"><a data-type="xref" href="#dockerfile-multiple-run-instructions">Example 6-3</a>.</span></p>
<div data-type="example" id="dockerfile-multiple-run-instructions">
<h5><span class="label">Example 6-3. </span>A Dockerfile specifying multiple <code>RUN</code> instructions</h5>
<pre data-code-language="dockerfile" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">ubuntu:22.10</code><code class="w"/>
<code class="k">RUN</code><code class="w"> </code>apt-get<code class="w"> </code>update<code class="w"> </code>-y<code class="w"/>
<code class="k">RUN</code><code class="w"> </code>apt-get<code class="w"> </code>upgrade<code class="w"> </code>-y<code class="w"/>
<code class="k">RUN</code><code class="w"> </code>apt-get<code class="w"> </code>install<code class="w"> </code>-y<code class="w"> </code>curl<code class="w"/></pre></div>
<p>Each <code>RUN</code> instruction will create a layer, potentially adding to the size of the container image. It’s more efficient to string them together with <code>&amp;&amp;</code> to ensure that only a single layer will be produced. <a data-type="xref" href="#dockerfile-combined-run-instructions">Example 6-4</a> shows an example of this optimization technique.</p>
<div data-type="example" id="dockerfile-combined-run-instructions">
<h5><span class="label">Example 6-4. </span>A Dockerfile specifying multiple <code>RUN</code> instructions</h5>
<pre data-code-language="dockerfile" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">ubuntu:22.10</code><code class="w"/>
<code class="k">RUN</code><code class="w"> </code>apt-get<code class="w"> </code>update<code class="w"> </code>-y<code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code>apt-get<code class="w"> </code>upgrade<code class="w"> </code>-y<code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code>apt-get<code class="w"> </code>install<code class="w"> </code>-y<code class="w"> </code>curl<code class="w"/></pre></div>
</div></section>
<section data-pdf-bookmark="Using Container Image Optimization Tools" data-type="sect2"><div class="sect2" id="idm46394751235760">
<h2>Using Container Image Optimization Tools</h2>
<p><a data-primary="tools" data-secondary="optimization" data-type="indexterm" id="idm46394751263856"/><a data-primary="container images" data-secondary="optimization tools for" data-type="indexterm" id="idm46394751262784"/><a data-primary="images" data-secondary="container" data-type="indexterm" id="idm46394751261840"/><a data-primary="optimization tools, for container images" data-type="indexterm" id="idm46394751260896"/>It’s easy to forget about the optimization practices mentioned previously. The open source community developed a couple of tools that can help with inspecting a produced container image. Their functionalities provide useful tips for pairing down on unnecessary layers, files, and folders:</p>
<dl>
<dt><a data-primary="DockerSlim" data-type="indexterm" id="idm46394751259248"/>DockerSlim</dt>
<dd>
<p>DockerSlim will optimize and secure your container image by analyzing your application and its dependencies. You can find more information in the tool’s <a href="https://oreil.ly/ZbeZl">GitHub repository</a>.</p>
</dd>
<dt><a data-primary="GitHub" data-type="indexterm" id="idm46394751256544"/><a data-primary="Dive" data-type="indexterm" id="idm46394751255840"/>Dive</dt>
<dd>
<p>Dive is a tool for exploring the layers baked into a container image. It makes it easy to identify unnecessary layers, which you can further optimize on. The code and documentation for Dive are available in a <a href="https://oreil.ly/UBqqj">GitHub repository</a>.</p>
</dd>
</dl>
<p><a data-primary="" data-startref="bi_min" data-type="indexterm" id="idm46394751253040"/><a data-primary="" data-startref="scs_min" data-type="indexterm" id="idm46394751252064"/>This is only the short list of container image optimization tools. In <a data-type="xref" href="#static-analysis-workload">“Static Analysis of Workload”</a>, we’ll have a look at other tools that focus on the static analysis of Dockerfiles and Kubernetes manifests.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Securing the Supply Chain" data-type="sect1"><div class="sect1" id="idm46394751249712">
<h1>Securing the Supply Chain</h1>
<p><a data-primary="supply chain security" data-secondary="securing supply chain" data-type="indexterm" id="scs_sec"/><a data-primary="Container Security (Rice)" data-type="indexterm" id="idm46394751246928"/><a data-primary="Rice, Liz, Container Security" data-type="indexterm" id="idm46394751246288"/>A supply chain automates the process of producing a container image and operating it in a runtime environment, in this case Kubernetes. We already touched on a couple of tools that can be integrated into the supply chain to support the aspect of container image optimization. In this section, we’ll expand on practices that target security aspects. Refer to the book <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/container-security/9781492056690/"><em>Container Security</em></a> by Liz Rice (O’Reilly) to learn more.</p>
<section data-pdf-bookmark="Signing Container Images" data-type="sect2"><div class="sect2" id="idm46394751222480">
<h2>Signing Container Images</h2>
<p><a data-primary="signing container images" data-type="indexterm" id="idm46394751221472"/><a data-primary="commands" data-secondary="docker trust sign" data-type="indexterm" id="idm46394751220864"/><a data-primary="docker trust sign command" data-type="indexterm" id="idm46394751220016"/><a data-primary="container images" data-secondary="signing" data-type="indexterm" id="idm46394751219408"/>You can sign a container image before pushing it to a container registry. Signing can be achieved with the <code>docker trust sign</code> command, which adds a signature to the container image, the so-called image digest. An image digest is derived from the contents of the container image and commonly represented in the form of SHA256. When consuming the container image, Kubernetes can compare the image digest with the contents of the image to ensure that it hasn’t been tampered with.</p>
</div></section>
<section data-pdf-bookmark="Scenario: An Attacker Injects Malicious Code into a Container Image" data-type="sect2"><div class="sect2" id="idm46394751217568">
<h2>Scenario: An Attacker Injects Malicious Code into a Container Image</h2>
<p><a data-primary="scenarios" data-secondary="attacker injects malicious code into container images" data-type="indexterm" id="idm46394751216224"/><a data-primary="image pull policy" data-type="indexterm" id="idm46394751215280"/>The Kubernetes component that verifies the image digest is the kubelet. If you configured the <a href="https://oreil.ly/0wSjy">image pull policy</a> to <code>Always</code>, the kubelet will query for the image digest from the container registry even though it may have downloaded and verified the container image before.</p>
<p>An attacker can try to modify the contents of an existing container image, inject malicious code, and upload it to the container registry with the same tag, as shown in <a data-type="xref" href="#no-image-digest-validation-attacker">Figure 6-2</a>. The malicious code running in the container could then send sensitive information to a third-party server accessible by the attacker.</p>
<figure><div class="figure" id="no-image-digest-validation-attacker">
<img alt="ckss 0602" height="1001" src="assets/ckss_0602.png" width="990"/>
<h6><span class="label">Figure 6-2. </span>An attacker injects malicious code into a container image</h6>
</div></figure>
<div data-type="note" epub:type="note"><h1>Image checksum validation is not automatic</h1>
<p>Image digest validation is an opt-in functionality in Kubernetes. When defining Pods, make sure you spell out the image digest explicitly for all container images.</p>
</div>
</div></section>
<section data-pdf-bookmark="Validating Container Images" data-type="sect2"><div class="sect2" id="idm46394751208400">
<h2>Validating Container Images</h2>
<p><a data-primary="container images" data-secondary="validating" data-type="indexterm" id="idm46394751206896"/><a data-primary="validating" data-secondary="container images" data-type="indexterm" id="idm46394751205696"/><a data-primary="images" data-secondary="container" data-type="indexterm" id="idm46394751204752"/><a data-primary="image digest validation" data-type="indexterm" id="idm46394751203808"/><a data-primary="SHA256" data-type="indexterm" id="idm46394751203136"/>In Kubernetes, you’re able to append the SHA256 image digest to the specification of a container. For example, this can be achieved with the attribute <code>spec.containers[].image</code>. The image digest is generally available in the container registry. For example, <a data-type="xref" href="#dockerhub-alpine-image-digest">Figure 6-3</a> shows the image digest for the container image <a href="https://oreil.ly/ZAV_H"><code>alpine:3.17.0</code> on Docker Hub</a>. In this example, the image digest is <code>sha256:c0d488a800e4127c334ad20d61d7bc21b4097540327217dfab52262adc02380c</code>.</p>
<figure><div class="figure" id="dockerhub-alpine-image-digest">
<img alt="ckss 0603" height="282" src="assets/ckss_0603.png" width="1642"/>
<h6><span class="label">Figure 6-3. </span>The image digest of the <code>alpine:3.17.0</code> container image on Docker Hub</h6>
</div></figure>
<p>Let’s see the image digest in action. Instead of using the tag, <a data-type="xref" href="#container-valid-image-digest">Example 6-5</a> specifies the container image by appending the image digest.</p>
<div data-type="example" id="container-valid-image-digest">
<h5><span class="label">Example 6-5. </span>A Pod using a valid container image digest</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine-valid</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine@sha256:c0d488a800e4127c334ad20d61d7bc21b40 \</code><code class="w"/>
<code class="w">           </code><code class="l-Scalar-Plain">97540327217dfab52262adc02380c</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"/bin/sh"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">echo</code><code class="nv"> </code><code class="s">hello;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">10;</code><code class="nv"> </code><code class="s">done"</code><code class="p-Indicator">]</code><code class="w"/></pre></div>
<p>Creating the Pod will work as expected. The image digest will be verified and the container transitions into the “Running” status:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f pod-valid-image-digest.yaml</strong>
pod/alpine-valid created
<strong>$ kubectl get pod alpine-valid</strong>
NAME           READY   STATUS    RESTARTS   AGE
alpine-valid   1/1     Running   0          6s</pre>
<p><a data-type="xref" href="#container-invalid-image-digest">Example 6-6</a> shows the same Pod definition; however, the image digest has been changed so that it does not match with the contents of the container image.</p>
<div data-type="example" id="container-invalid-image-digest">
<h5><span class="label">Example 6-6. </span>A Pod using an invalid container image digest</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine-invalid</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine@sha256:d006a643bccb6e9adbabaae668533c7f2e5 \</code><code class="w"/>
<code class="w">           </code><code class="l-Scalar-Plain">111572fffb5c61cb7fcba7ef4150b</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"/bin/sh"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">echo</code><code class="nv"> </code><code class="s">hello;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">10;</code><code class="nv"> </code><code class="s">done"</code><code class="p-Indicator">]</code><code class="w"/></pre></div>
<p>You will see that Kubernetes can still create the Pod object but it can’t properly validate the hash of the container image. This results in the status “ErrImagePull.” As you can see from the event log, the container image couldn’t even be pulled from the container registry:</p>
<pre data-type="programlisting"><strong>$ kubectl get pods</strong>
NAME             READY   STATUS         RESTARTS   AGE
alpine-invalid   0/1     ErrImagePull   0          29s
<strong>$ kubectl describe pod alpine-invalid</strong>
...
Events:
  Type     Reason     Age   From               Message
  ----     ------     ----  ----               -------
  Normal   Scheduled  13s   default-scheduler  Successfully assigned default \
  /alpine-invalid to minikube
  Normal   Pulling    13s   kubelet            Pulling image "alpine@sha256: \
  d006a643bccb6e9adbabaae668533c7f2e5111572fffb5c61cb7fcba7ef4150b"
  Warning  Failed     11s   kubelet            Failed to pull image \
  "alpine@sha256:d006a643bccb6e9adbabaae668533c7f2e5111572fffb5c61cb7fcba7ef4 \
  150b": rpc error: code = Unknown desc = Error response from daemon: manifest \
  for alpine@sha256:d006a643bccb6e9adbabaae668533c7f2e5111572fffb5c61cb7fcba7e \
  f4150b not found: manifest unknown: manifest unknown
  Warning  Failed     11s   kubelet            Error: ErrImagePull
  Normal   BackOff    11s   kubelet            Back-off pulling image \
  "alpine@sha256:d006a643bccb6e9adbabaae668533c7f2e5111572fffb5c61cb7fcba7ef415 \
  0b"
  Warning  Failed     11s   kubelet            Error: ImagePullBackOff</pre>
</div></section>
<section data-pdf-bookmark="Using Public Image Registries" data-type="sect2"><div class="sect2" id="idm46394751207776">
<h2>Using Public Image Registries</h2>
<p><a data-primary="public image registries" data-type="indexterm" id="idm46394751029968"/><a data-primary="registries, public image" data-type="indexterm" id="idm46394751029264"/><a data-primary="image pull policy" data-type="indexterm" id="idm46394751028624"/>Whenever a Pod is created, the container runtime engine will download the declared container image from a container registry if it isn’t available locally yet. This runtime behavior can be further tweaked using the <a href="https://oreil.ly/ZBMnH">image pull policy</a>.</p>
<p><a data-primary="Google Cloud container registry" data-type="indexterm" id="idm46394751026848"/><a data-primary="Docker Hub" data-type="indexterm" id="idm46394751026016"/>The prefix in the image name declares the domain name of the registry; e.g., <code>gcr.io/google-containers/debian-base:v1.0.1</code> refers to the container image <code>google-containers/debian-base:v1.0.1</code> in the <a href="https://oreil.ly/QFxfY">Google Cloud container registry</a>, denoted by <code>gcr.io</code>. The container runtime will try to resolve it from <code>docker.io</code>, the <a href="https://hub.docker.com">Docker Hub container registry</a> if you leave off the domain name in the container image declaration.</p>
</div></section>
<section data-pdf-bookmark="Scenario: An Attacker Uploads a Malicious Container Image" data-type="sect2"><div class="sect2" id="idm46394751022032">
<h2>Scenario: An Attacker Uploads a Malicious Container Image</h2>
<p><a data-primary="scenarios" data-secondary="attacker uploads malicious container images" data-type="indexterm" id="idm46394751020656"/>While it is convenient to resolve container images from public container registries, it doesn’t come without risks. Anyone with a login to those container registries can upload new images. Consuming container images usually doesn’t even require an account.</p>
<p>As shown in <a data-type="xref" href="#public-registries-attacker">Figure 6-4</a>, an attacker can upload a container image containing malicious code to a public registry using stolen credentials. Any container referencing the container image from that registry will automatically run the malicious code.</p>
<figure><div class="figure" id="public-registries-attacker">
<img alt="ckss 0604" height="761" src="assets/ckss_0604.png" width="949"/>
<h6><span class="label">Figure 6-4. </span>An attacker uploads a malicious container image</h6>
</div></figure>
<p>On an enterprise level, you need to control which container registries you trust. It’s recommended to set up your own container registry within your company’s network, which you can fully control and govern. Alternatively, you can set up a private container registry in a cloud provider environment, not accessible by anyone else.</p>
<p><a data-primary="JFrog Artifactory" data-type="indexterm" id="idm46394750949312"/>One of the prominent binary repository managers you can choose from is <a href="https://oreil.ly/jdF_6">JFrog Artifactory</a>. The product fully supports storing, scanning, and serving container images. Any consumer of container images should only be allowed to pull images from your whitelisted container registry. All other container registries should be denied.</p>
</div></section>
<section data-pdf-bookmark="Whitelisting Allowed Image Registries with OPA GateKeeper" data-type="sect2"><div class="sect2" id="idm46394750947824">
<h2>Whitelisting Allowed Image Registries with OPA GateKeeper</h2>
<p><a data-primary="image registries" data-secondary="whitelisting with OPA Gatekeeper" data-type="indexterm" id="ir_wh"/><a data-primary="OPA (Open Policy Agent) Gatekeeper" data-secondary="whitelisting allowed image registries with" data-type="indexterm" id="opa_wh"/><a data-primary="whitelisting" data-secondary="allowed image registries with OPA Gatekeeper" data-type="indexterm" id="wh_opa"/>One way to govern container registry usage is with OPA Gatekeeper. We discussed the installation process and functionality of OPA Gatekeeper in <a data-type="xref" href="ch05.xhtml#opa-gatekeeper">“Understanding Open Policy Agent (OPA) and Gatekeeper”</a>. Here, we’ll’ touch on the constraint template and constraint for allowing trusted container registries.</p>
<p><a data-primary="constraint template" data-type="indexterm" id="idm46394750941488"/><a data-primary="Rego" data-type="indexterm" id="idm46394750940560"/><a data-type="xref" href="#opa-whitelisted-repositories-constraint-template">Example 6-7</a> shows the <a href="https://oreil.ly/hvgnr">constraint template</a> I got directly from the OPA Gatekeeper library. As input properties, the constraint template defines an array of strings 
<span class="keep-together">representing</span> the prefixes of container registries. The Rego rules verify not only the assigned container images for the attribute <code>spec.containers[]</code> but also <code>spec.initContainers[]</code> and <code>spec.ephemeralContainers[]</code>.</p>
<div data-type="example" id="opa-whitelisted-repositories-constraint-template">
<h5><span class="label">Example 6-7. </span>An OPA Gatekeeper constraint template for enforcing container registries</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">templates.gatekeeper.sh/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConstraintTemplate</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8sallowedrepos</code><code class="w"/>
<code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">metadata.gatekeeper.sh/title</code><code class="p">:</code><code class="w"> </code><code class="s">"Allowed</code><code class="nv"> </code><code class="s">Repositories"</code><code class="w"/>
<code class="w">    </code><code class="nt">metadata.gatekeeper.sh/version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1.0.0</code><code class="w"/>
<code class="w">    </code><code class="nt">description</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;-</code><code class="w"/>
<code class="w">      </code><code class="no">Requires container images to begin with a string from the specified list.</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">crd</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">names</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">K8sAllowedRepos</code><code class="w"/>
<code class="w">      </code><code class="nt">validation</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">openAPIV3Schema</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">object</code><code class="w"/>
<code class="w">          </code><code class="nt">properties</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">repos</code><code class="p">:</code><code class="w"/>
<code class="w">              </code><code class="nt">description</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">The list of prefixes a container image is allowed to have.</code><code class="w"/>
<code class="w">              </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">array</code><code class="w"/>
<code class="w">              </code><code class="nt">items</code><code class="p">:</code><code class="w"/>
<code class="w">                </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">string</code><code class="w"/>
<code class="w">  </code><code class="nt">targets</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">target</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">admission.k8s.gatekeeper.sh</code><code class="w"/>
<code class="w">      </code><code class="nt">rego</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w"/>
<code class="w">        </code><code class="no">package k8sallowedrepos</code><code class="w"/>

<code class="w">        </code><code class="no">violation[{"msg": msg}] {</code><code class="w"/>
<code class="w">          </code><code class="no">container := input.review.object.spec.containers[_]</code><code class="w"/>
<code class="w">          </code><code class="no">satisfied := [good | repo = input.parameters.repos[_] ; \</code><code class="w"/>
<code class="w">          </code><code class="no">good = startswith(container.image, repo)]</code><code class="w"/>
<code class="w">          </code><code class="no">not any(satisfied)</code><code class="w"/>
<code class="w">          </code><code class="no">msg := sprintf("container &lt;%v&gt; has an invalid image repo &lt;%v&gt;, allowed \</code><code class="w"/>
<code class="w">          </code><code class="no">repos are %v", [container.name, container.image, input.parameters.repos])</code><code class="w"/>
<code class="w">        </code><code class="no">}</code><code class="w"/>

<code class="w">        </code><code class="no">violation[{"msg": msg}] {</code><code class="w"/>
<code class="w">          </code><code class="no">container := input.review.object.spec.initContainers[_]</code><code class="w"/>
<code class="w">          </code><code class="no">satisfied := [good | repo = input.parameters.repos[_] ; \</code><code class="w"/>
<code class="w">          </code><code class="no">good = startswith(container.image, repo)]</code><code class="w"/>
<code class="w">          </code><code class="no">not any(satisfied)</code><code class="w"/>
<code class="w">          </code><code class="no">msg := sprintf("initContainer &lt;%v&gt; has an invalid image repo &lt;%v&gt;, \</code><code class="w"/>
<code class="w">          </code><code class="no">allowed repos are %v", [container.name, container.image, \</code><code class="w"/>
<code class="w">          </code><code class="no">input.parameters.repos])</code><code class="w"/>
<code class="w">        </code><code class="no">}</code><code class="w"/>

<code class="w">        </code><code class="no">violation[{"msg": msg}] {</code><code class="w"/>
<code class="w">          </code><code class="no">container := input.review.object.spec.ephemeralContainers[_]</code><code class="w"/>
<code class="w">          </code><code class="no">satisfied := [good | repo = input.parameters.repos[_] ; \</code><code class="w"/>
<code class="w">          </code><code class="no">good = startswith(container.image, repo)]</code><code class="w"/>
<code class="w">          </code><code class="no">not any(satisfied)</code><code class="w"/>
<code class="w">          </code><code class="no">msg := sprintf("ephemeralContainer &lt;%v&gt; has an invalid image repo &lt;%v&gt;, \</code><code class="w"/>
<code class="w">          </code><code class="no">allowed repos are %v", [container.name, container.image, \</code><code class="w"/>
<code class="w">          </code><code class="no">input.parameters.repos])</code><code class="w"/>
<code class="w">        </code><code class="no">}</code><code class="w"/></pre></div>
<p>The constraint shown in <a data-type="xref" href="#opa-whitelisted-repositories-constraint">Example 6-8</a> is in charge of defining which container registries we want to allow. You’d usually go with a domain name of a server hosted in your company’s network. Here, we are going to use <code>gcr.io/</code> for demonstration purposes.</p>
<div data-type="example" id="opa-whitelisted-repositories-constraint">
<h5><span class="label">Example 6-8. </span>An OPA Gatekeeper constraint assigning Google Cloud registry as trusted repository</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">constraints.gatekeeper.sh/v1beta1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">K8sAllowedRepos</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">repo-is-gcr</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">match</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">kinds</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">        </code><code class="nt">kinds</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"Pod"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code><code class="nt">parameters</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">repos</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"gcr.io/"</code><code class="w"/></pre></div>
<p><a data-primary="commands" data-secondary="apply" data-type="indexterm" id="idm46394750828816"/><a data-primary="apply command" data-type="indexterm" id="idm46394750582576"/>Let’s create both objects using the <code>apply</code> command:</p>
<pre data-type="programlisting"><strong>$ kubectl apply -f allowed-repos-constraint-template.yaml</strong>
constrainttemplate.templates.gatekeeper.sh/k8sallowedrepos created
<strong>$ kubectl apply -f gcr-allowed-repos-constraint.yaml</strong>
k8sallowedrepos.constraints.gatekeeper.sh/repo-is-gcr created</pre>
<p>In the constraint, we didn’t specify a namespace that the rules should apply to. Therefore, they’ll apply across all namespaces in the cluster. The following commands verify that the whitelisting rules work as expected. The following command tries to create a Pod using the <code>nginx</code> container image from Docker Hub. The creation of the Pod is denied with an appropriate error message:</p>
<pre data-type="programlisting"><strong>$ kubectl run nginx --image=nginx:1.23.3</strong>
Error from server (Forbidden): admission webhook "validation.gatekeeper.sh" \
denied the request: [repo-is-gcr] container &lt;nginx&gt; has an invalid image \
repo &lt;nginx:1.23.3&gt;, allowed repos are ["gcr.io/"]</pre>
<p><a data-primary="" data-startref="ir_wh" data-type="indexterm" id="idm46394750608880"/><a data-primary="" data-startref="opa_wh" data-type="indexterm" id="idm46394750607904"/><a data-primary="" data-startref="wh_opa" data-type="indexterm" id="idm46394750606960"/>The next command creates a Pod with a container image from the Google Cloud container registry. The operation is permitted and the Pod object is created:</p>
<pre data-type="programlisting"><strong>$ kubectl run busybox --image=gcr.io/google-containers/busybox:1.27.2</strong>
pod/busybox created
<strong>$ kubectl get pods</strong>
NAME      READY   STATUS      RESTARTS     AGE
busybox   0/1     Completed   1 (2s ago)   3s</pre>
</div></section>
<section data-pdf-bookmark="Whitelisting Allowed Image Registries with the ImagePolicyWebhook Admission Controller Plugin" data-type="sect2"><div class="sect2" id="idm46394750947232">
<h2>Whitelisting Allowed Image Registries with the ImagePolicyWebhook Admission Controller Plugin</h2>
<p><a data-primary="image registries" data-secondary="whitelisting with ImagePolicyWebhook Admission Controller plugin" data-type="indexterm" id="idm46394750555536"/><a data-primary="ImagePolicyWebhook Admission Controller plugin" data-secondary="whitelisting allowed image registries with" data-type="indexterm" id="idm46394750554592"/><a data-primary="whitelisting" data-secondary="allowed image registries with ImagePolicyWebhook Admission Controller plugin" data-type="indexterm" id="idm46394750553712"/>Another way to validate the use of allowed image registries is to intercept a call to the API server when a Pod is about to be created. This mechanism can be achieved by enabling an admission controller plugin. Once configured, the logic of an admission controller plugin is automatically invoked when the API server receives the request, but after it could authenticate and authorize the caller. We already touched on the phases an API call has to go through in <a data-type="xref" href="ch03.xhtml#processing-api-request">“Processing a Request”</a>.</p>
<p>The admission controller provides a way to approve, deny, or mutate a request before the request takes effect. For example, we can inspect the data sent with the API request to create a Pod, iterate over the assigned container images, and execute custom logic to validate the container image notation. If the container image doesn’t stick to the expected conventions, we can deny the creation of the Pod. <a data-type="xref" href="#imagepolicywebhook-admission-controller-plugin">Figure 6-5</a> illustrates the high-level workflow.</p>
<figure><div class="figure" id="imagepolicywebhook-admission-controller-plugin">
<img alt="ckss 0605" height="440" src="assets/ckss_0605.png" width="1436"/>
<h6><span class="label">Figure 6-5. </span>Intercepting a Pod-specific API call and handling it with a webhook</h6>
</div></figure>
<p>The <a href="https://oreil.ly/JxmUu">ImagePolicyWebhook</a> admission controller plugin is one of the plugins we can configure for intercepting Kubernetes API calls. You can probably derive the plugin’s functionality from its name. It defines a policy for all defined container images in a Pod. To compare container images with the defined policy, the plugin calls off to a service external to Kubernetes via HTTPS, a webhook. The external service then makes the decision on how to validate the data. In the context of the admission controller plugin, the external service is also referred to as <em>backend</em>.</p>
</div></section>
<section data-pdf-bookmark="Implementing the Backend Application" data-type="sect2"><div class="sect2" id="idm46394750547008">
<h2>Implementing the Backend Application</h2>
<p>The backend application can be implemented with a programming language of your choice. There are only three requirements it must fulfill:</p>
<ol>
<li>
<p>It’s a web application that can handle HTTPS requests.</p>
</li>
<li>
<p>It can accept and parse JSON request payloads.</p>
</li>
<li>
<p>It can send a JSON response payload.</p>
</li>
</ol>
<p><a data-primary="GitHub" data-type="indexterm" id="idm46394750542208"/>Implementing the backend application is not part of the CKS exam, but you can find a sample Go-based implementation in the <a href="https://oreil.ly/OF4fF">GitHub repository</a> of this book. Be aware that the code is not considered to be production-ready.</p>
<p><a data-primary="documentation" data-secondary="Kubernetes" data-type="indexterm" id="idm46394750540432"/>The following commands demonstrate the runtime behavior of the application accessible at <code>https://localhost:8080/validate</code>. You can find an example request and response JSON body in the <a href="https://oreil.ly/8GaQe">Kubernetes documentation</a>.</p>
<p><a data-primary="curl command" data-type="indexterm" id="idm46394750537888"/><a data-primary="commands" data-secondary="curl" data-type="indexterm" id="idm46394750537184"/>The following <code>curl</code> command calls the validation logic for the container image <code>nginx:1.19.0</code>. As you can see from the JSON response, the image is denied:</p>
<pre data-type="programlisting">
<strong>$ curl -X POST -H "Content-Type: application/json" -k -d \'{"apiVersion":</strong> \
<strong>"imagepolicy.k8s.io/v1alpha1", "kind": "ImageReview", "spec":</strong> \
<strong>{"containers": [{"image": "nginx:1.19.0"}]}}' https://localhost:8080/validate</strong>
{"apiVersion": "imagepolicy.k8s.io/v1alpha1", "kind": "ImageReview", \
"status": {"allowed": false, "reason": "Denied request: [container 1 \
has an invalid image repo nginx:1.19.0, allowed repos are [gcr.io/]]"}}
</pre>
<p>The following <code>curl</code> command calls the validation logic for the container image <code>gcr.io/nginx:1.19.0</code>. As you can see from the JSON response, the image is allowed:</p>
<pre data-type="programlisting">
<strong>$ curl -X POST -H "Content-Type: application/json"  -k -d '{"apiVersion":</strong> \
<strong>"imagepolicy.k8s.io/v1alpha1", "kind": "ImageReview", "spec": {"containers":</strong> \
<strong>[{"image": "gcr.io/nginx:1.19.0"}]}}' https://localhost:8080/validate</strong>
{"apiVersion": "imagepolicy.k8s.io/v1alpha1", "kind": "ImageReview", \
"status": {"allowed": true, "reason": ""}}
</pre>
</div></section>
<section data-pdf-bookmark="Configuring the ImagePolicyWebhook Admission Controller Plugin" data-type="sect2"><div class="sect2" id="configuring-imagepolicywebhook-admission-controller-plugin">
<h2>Configuring the ImagePolicyWebhook Admission Controller Plugin</h2>
<p><a data-primary="configuring" data-secondary="ImagePolicyWebhook Admission Controller plugin" data-type="indexterm" id="con_pl"/><a data-primary="ImagePolicyWebhook Admission Controller plugin" data-secondary="configuring" data-type="indexterm" id="pl_con"/>For the exam, you are expected to understand how to “wire” the ImagePolicyWebhook admission controller plugin. This section will walk you through the process. First, you’ll need to create a configuration file for the admission controller so it knows what plugins to use and how it should behave at runtime. Create the file <code>/etc/kubernetes/admission-control/image-policy-webhook-admission-config.yaml</code> and populate it with the content shown in <a data-type="xref" href="#admission-controller-configuration-file">Example 6-9</a>.</p>
<div data-type="example" id="admission-controller-configuration-file">
<h5><span class="label">Example 6-9. </span>The admission controller configuration file</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apiserver.config.k8s.io/v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">AdmissionConfiguration</code><code class="w">
</code><code class="nt">plugins</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ImagePolicyWebhook</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO3-1" id="co_supply_chain_security_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">    </code><code class="nt">configuration</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">imagePolicy</code><code class="p">:</code><code class="w">
</code><code class="w">        </code><code class="nt">kubeConfigFile</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/kubernetes/admission-control/</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">\</code><code class="w">
</code><code class="w">                        </code><code class="l-Scalar-Plain">imagepolicywebhook.kubeconfig</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO3-2" id="co_supply_chain_security_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">        </code><code class="nt">allowTTL</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">50</code><code class="w">
</code><code class="w">        </code><code class="nt">denyTTL</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">50</code><code class="w">
</code><code class="w">        </code><code class="nt">retryBackoff</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">500</code><code class="w">
</code><code class="w">        </code><code class="nt">defaultAllow</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO3-3" id="co_supply_chain_security_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_supply_chain_security_CO3-1" id="callout_supply_chain_security_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Provides the configuration for the ImagePolicyWebhook plugin.</p></dd>
<dt><a class="co" href="#co_supply_chain_security_CO3-2" id="callout_supply_chain_security_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Points to the configuration file used to configure the backend.</p></dd>
<dt><a class="co" href="#co_supply_chain_security_CO3-3" id="callout_supply_chain_security_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Denies an API request if the backend cannot be reached. The default is true but setting it to false is far more sensible.</p></dd>
</dl>
<p>Next, create the file referenced by the <code>plugins[].configuration.imagePolicy.kubeConfigFile</code> attribute. The contents of the file point to the HTTPS URL of the external service. It also defines the client certificate and key file, as well as the CA file on disk. <a data-type="xref" href="#image-policy-configuration-file">Example 6-10</a> shows the contents of the configuration file.</p>
<div data-type="example" id="image-policy-configuration-file">
<h5><span class="label">Example 6-10. </span>The image policy configuration file</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Config</code><code class="w">
</code><code class="nt">preferences</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="w">
</code><code class="nt">clusters</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">image-validation-webhook</code><code class="w">
</code><code class="w">    </code><code class="nt">cluster</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">certificate-authority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/kubernetes/admission-control/ca.crt</code><code class="w">
</code><code class="w">      </code><code class="nt">server</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://image-validation-webhook:8080/validate</code><code class="w"> </code><a class="co" href="#callout_supply_chain_security_CO4-1" id="co_supply_chain_security_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="nt">contexts</code><code class="p">:</code><code class="w">
</code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">context</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">cluster</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">image-validation-webhook</code><code class="w">
</code><code class="w">    </code><code class="nt">user</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-server-client</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">image-validation-webhook</code><code class="w">
</code><code class="nt">current-context</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">image-validation-webhook</code><code class="w">
</code><code class="nt">users</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-server-client</code><code class="w">
</code><code class="w">    </code><code class="nt">user</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">client-certificate</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/kubernetes/admission-control/api-server-client.crt</code><code class="w">
</code><code class="w">      </code><code class="nt">client-key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/kubernetes/admission-control/api-server-client.key</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_supply_chain_security_CO4-1" id="callout_supply_chain_security_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The URL to the backend service. Must use the HTTPS protocol.</p></dd>
</dl>
<p>Enable the ImagePolicyWebhook admission controller plugin for the API server and point the admission controller to the configuration file. To achieve this, edit the configuration file of the API server, usually found at <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code>.</p>
<p>Find the command line option <code>--enable-admission-plugins</code> and append the value <code>ImagePolicyWebhook</code> to the existing list of plugins, separated by a comma. Provide the command line option <code>--admission-control-config-file</code> if it doesn’t exist yet, and set the value to <code>/etc/kubernetes/admission-control/image-policy-webhook-admission-configuration.yaml</code>. Given that the configuration file lives in a new directory, you will have to define it as a Volume and mount it to the container. <a data-type="xref" href="#api-server-configuration-file">Example 6-11</a> shows the relevant options for the API server container.</p>
<div data-type="example" id="api-server-configuration-file">
<h5><span class="label">Example 6-11. </span>The API server configuration file</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">command</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">kube-apiserver</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">--enable-admission-plugins=NodeRestriction,ImagePolicyWebhook</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">--admission-control-config-file=/etc/kubernetes/admission-control/ \</code><code class="w"/>
<code class="w">      </code><code class="l-Scalar-Plain">image-policy-webhook-admission-configuration.yaml</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">admission-control</code><code class="w"/>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/kubernetes/admission-control</code><code class="w"/>
<code class="w">      </code><code class="nt">readonly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p">...</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">admission-control</code><code class="w"/>
<code class="w">    </code><code class="nt">hostPath</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/kubernetes/admission-control</code><code class="w"/>
<code class="w">      </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DirectoryOrCreate</code><code class="w"/>
<code class="p">...</code><code class="w"/></pre></div>
<p><a data-primary="commands" data-secondary="sudo systemctl restart kubelet" data-type="indexterm" id="idm46394750263168"/><a data-primary="sudo systemctl restart kubelet command" data-type="indexterm" id="idm46394750262320"/>The Pod running the API server should automatically restart. This process may take a couple of minutes. Restart the kubelet service with the command <code>sudo systemctl restart kubelet</code> should the API server not come up by itself. Once fully restarted, you should be able to query for it:</p>
<pre data-type="programlisting"><strong>$ kubectl get pods -n kube-system</strong>
NAME                           READY   STATUS    RESTARTS   AGE
...
kube-apiserver-control-plane   1/1     Running   0          69s</pre>
<p><a data-primary="" data-startref="scs_sec" data-type="indexterm" id="idm46394750152160"/><a data-primary="" data-startref="con_pl" data-type="indexterm" id="idm46394750151184"/><a data-primary="" data-startref="pl_con" data-type="indexterm" id="idm46394750150240"/>Any API call that requests the creation of a Pod will now be routed to the backend. Based on the validation result, the creation of the object will be allowed or denied.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Static Analysis of Workload" data-type="sect1"><div class="sect1" id="static-analysis-workload">
<h1>Static Analysis of Workload</h1>
<p><a data-primary="static analysis, of workload" data-type="indexterm" id="sa_wo"/><a data-primary="supply chain security" data-secondary="static analysis of workload" data-type="indexterm" id="scs_sa"/><a data-primary="workload, static analysis of" data-type="indexterm" id="wo_sa"/><a data-primary="Kubesec" data-type="indexterm" id="idm46394750144448"/>Throughout this book, we talk about best practices for Dockerfiles and Kubernetes manifests. You can inspect those files manually, find undesired configurations, and fix them by hand. This approach requires a lot of intricate knowledge and is very tedious and error-prone. It is much more convenient and efficient to analyze workload files in an automated fashion with proper tooling. The list of commercial and open source tooling for static analysis is long. In this section, we are going to present the functionality of two options, Haskell Dockerfile Linter and Kubesec.</p>
<p>On an enterprise level, where you have to process hundreds or even thousands of workload files, you’d do so with the help of a continuous delivery pipeline, as shown in <a data-type="xref" href="#continuous-delivery-kubernetes-static-analysis">Figure 6-6</a>.</p>
<figure><div class="figure" id="continuous-delivery-kubernetes-static-analysis">
<img alt="ckss 0606" height="210" src="assets/ckss_0606.png" width="1438"/>
<h6><span class="label">Figure 6-6. </span>An exemplary continuous delivery pipeline for Kubernetes</h6>
</div></figure>
<p><a data-primary="Continuous Delivery (Humble and Farley)" data-type="indexterm" id="idm46394750140240"/><a data-primary="Farley, David, Continuous Delivery" data-type="indexterm" id="idm46394750117008"/><a data-primary="Humble, Jez, Continuous Delivery" data-type="indexterm" id="idm46394750116400"/>Relevant static analysis tools can be invoked as a quality gate at an early stage of the pipeline even before a container image is built, pushed to a registry, or deployed to a Kubernetes cluster. For a deep dive on the principles and practices of continuous delivery, see the excellent book <a class="orm:hideurl" href="https://oreil.ly/8CR5M"><em>Continuous Delivery</em></a> by Jez Humble and David Farley (Addison-Wesley Professional).</p>
<section data-pdf-bookmark="Using Hadolint for Analyzing Dockerfiles" data-type="sect2"><div class="sect2" id="idm46394750114544">
<h2>Using Hadolint for Analyzing Dockerfiles</h2>
<p><a data-primary="Dockerfiles" data-type="indexterm" id="idm46394750113104"/><a data-primary="Haskell Dockerfile Linter" data-type="indexterm" id="idm46394750112496"/><a href="https://oreil.ly/C9bvu">Haskell Dockerfile Linter</a>, also called hadolint in short, is a linter for Dockerfiles. The tool inspects a Dockerfile based on <a href="https://oreil.ly/Fwksr">best practices</a> listed on the Docker documentation page. <a data-type="xref" href="#unoptimized-dockerfile">Example 6-12</a> shows an unoptimized Dockerfile for building a container image running a Go-based 
<span class="keep-together">application.</span></p>
<div data-type="example" id="unoptimized-dockerfile">
<h5><span class="label">Example 6-12. </span>An unoptimized Dockerfile</h5>
<pre data-code-language="dockerfile" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">golang</code><code class="w"/>
<code class="k">COPY</code><code class="w"> </code>main.go<code class="w"> </code>.<code class="w"/>
<code class="k">RUN</code><code class="w"> </code>go<code class="w"> </code>build<code class="w"> </code>main.go<code class="w"/>
<code class="k">CMD</code><code class="w"> </code><code class="p">[</code><code class="s2">"./main"</code><code class="p">]</code><code class="w"/></pre></div>
<p>The Haskell Dockerfile Linter supports a mode of operation that lets you point the <code>hadolint</code> executable to a Dockerfile on disk. You can see the command execution that follows, including the discovered warning messages produced by the analysis:</p>
<pre data-type="programlisting"><strong>$ hadolint Dockerfile</strong>
Dockerfile:1 DL3006 warning: Always tag the version of an image explicitly
Dockerfile:2 DL3045 warning: `COPY` to a relative destination without \
`WORKDIR` set.</pre>
<p>The output of the command suggests that you should assign a tag to the base image. The existing Dockerfile will pull the <code>latest</code> tag, which will resolve to the newest Go container image. This practice can result in an incompatibility between the Go runtime version and the application code. Defining a working directory for copying resources helps with keeping operating system-specific directories and files separate from application-specific directories and files. <a data-type="xref" href="#optimized-dockerfile">Example 6-13</a> fixes the warning messages found by the Haskell Dockerfile Linter.</p>
<div data-type="example" id="optimized-dockerfile">
<h5><span class="label">Example 6-13. </span>An optimized Dockerfile</h5>
<pre data-code-language="dockerfile" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">golang:1.19.4-alpine</code><code class="w"/>
<code class="k">WORKDIR</code><code class="w"> </code><code class="s">/app</code><code class="w"/>
<code class="k">COPY</code><code class="w"> </code>main.go<code class="w"> </code>.<code class="w"/>
<code class="k">RUN</code><code class="w"> </code>go<code class="w"> </code>build<code class="w"> </code>main.go<code class="w"/>
<code class="k">CMD</code><code class="w"> </code><code class="p">[</code><code class="s2">"./main"</code><code class="p">]</code><code class="w"/></pre></div>
<p>Another execution against the modified Dockerfile leads to a successful exit code, and no additional warning messages will be rendered:</p>
<pre data-type="programlisting"><strong>$ hadolint Dockerfile</strong></pre>
<p>The Dockerfile now follows best practices, as perceived by hadolint.</p>
</div></section>
<section data-pdf-bookmark="Using Kubesec for Analyzing Kubernetes Manifests" data-type="sect2"><div class="sect2" id="idm46394750113952">
<h2>Using Kubesec for Analyzing Kubernetes Manifests</h2>
<p><a data-primary="kubectl tool" data-type="indexterm" id="idm46394750028336"/><a data-primary="Kubernetes Manifests, analyzing using Kubesec" data-type="indexterm" id="km_an"/><a data-primary="Kubesec" data-type="indexterm" id="ku_ab"/><a href="https://kubesec.io">Kubesec</a> is a tool for analyzing Kubernetes manifests. It can be executed as a binary, Docker container, admission controller plugin, and even as a plugin for <code>kubectl</code>. To demonstrate its use, we’ll set up a YAML manifest file <code>pod-initial-kubesec-test.yaml</code>, shown in <a data-type="xref" href="#pod-yaml-manifest-initial-security-settings">Example 6-14</a> as a starting point.</p>
<div data-type="example" id="pod-yaml-manifest-initial-security-settings">
<h5><span class="label">Example 6-14. </span>A Pod YAML manifest using initial security settings</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubesec-demo</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubesec-demo</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/google-samples/node-hello:1.0</code><code class="w"/>
<code class="w">    </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">readOnlyRootFilesystem</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/></pre></div>
<p>Upon inspecting the Pod configuration, you may already have some suggestions on what could be improved based on the content of the previous chapters. Let’s see what Kubesec is going to recommend.</p>
<p>The simplest way to invoke Kubesec is to run the logic in a container with the help of Docker. The following command feeds the contents of the YAML manifest to the standard input stream. The result, formatted in JSON, renders a score, provides a human-readable message of the outcome, and advises on changes to be made:</p>
<pre data-type="programlisting"><strong>$ docker run -i kubesec/kubesec:512c5e0 scan /dev/stdin</strong> \
  <strong>&lt; pod-initial-kubesec-test.yaml</strong>
[
  {
    "object": "Pod/kubesec-demo.default",
    "valid": true,
    "message": "Passed with a score of 1 points",
    "score": 1,
    "scoring": {
      "advise": [
        {
          "selector": ".spec .serviceAccountName",
          "reason": "Service accounts restrict Kubernetes API access and \
                     should be configured with least privilege"
        },
        {
          "selector": ".metadata .annotations .\"container.apparmor.security. \
                       beta.kubernetes.io/nginx\"",
          "reason": "Well defined AppArmor policies may provide greater \
                     protection from unknown threats. WARNING: NOT PRODUCTION \
                     READY"
        },
        {
          "selector": "containers[] .resources .requests .cpu",
          "reason": "Enforcing CPU requests aids a fair balancing of \
                     resources across the cluster"
        },
        {
          "selector": ".metadata .annotations .\"container.seccomp.security. \
                       alpha.kubernetes.io/pod\"",
          "reason": "Seccomp profiles set minimum privilege and secure against \
                     unknown threats"
        },
        {
          "selector": "containers[] .resources .limits .memory",
          "reason": "Enforcing memory limits prevents DOS via resource \
                     exhaustion"
        },
        {
          "selector": "containers[] .resources .limits .cpu",
          "reason": "Enforcing CPU limits prevents DOS via resource exhaustion"
        },
        {
          "selector": "containers[] .securityContext .runAsNonRoot == true",
          "reason": "Force the running image to run as a non-root user to \
                     ensure least privilege"
        },
        {
          "selector": "containers[] .resources .requests .memory",
          "reason": "Enforcing memory requests aids a fair balancing of \
                     resources across the cluster"
        },
        {
          "selector": "containers[] .securityContext .capabilities .drop",
          "reason": "Reducing kernel capabilities available to a container \
                     limits its attack surface"
        },
        {
          "selector": "containers[] .securityContext .runAsUser -gt 10000",
          "reason": "Run as a high-UID user to avoid conflicts with the \
                     host's user table"
        },
        {
          "selector": "containers[] .securityContext .capabilities .drop | \
                       index(\"ALL\")",
          "reason": "Drop all capabilities and add only those required to \
                     reduce syscall attack surface"
        }
      ]
    }
  }
]</pre>
<p>A touched-up version of the original YAML manifest can be found in <a data-type="xref" href="#pod-yaml-manifest-improved-security-settings">Example 6-15</a>. Here, we incorporated some of the recommended changes proposed by Kubesec.</p>
<div data-type="example" id="pod-yaml-manifest-improved-security-settings">
<h5><span class="label">Example 6-15. </span>A Pod YAML manifest using improved security settings</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubesec-demo</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubesec-demo</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/google-samples/node-hello:1.0</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"64Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"250m"</code><code class="w"/>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"128Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"500m"</code><code class="w"/>
<code class="w">    </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">readOnlyRootFilesystem</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">      </code><code class="nt">runAsNonRoot</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">      </code><code class="nt">runAsUser</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">20000</code><code class="w"/>
<code class="w">      </code><code class="nt">capabilities</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">drop</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"ALL"</code><code class="p-Indicator">]</code><code class="w"/></pre></div>
<p><a data-primary="" data-startref="sa_wo" data-type="indexterm" id="idm46394749761968"/><a data-primary="" data-startref="scs_sa" data-type="indexterm" id="idm46394749761120"/><a data-primary="" data-startref="wo_sa" data-type="indexterm" id="idm46394749787232"/><a data-primary="" data-startref="km_an" data-type="indexterm" id="idm46394749786288"/><a data-primary="" data-startref="ku_ab" data-type="indexterm" id="idm46394749785344"/>Executing the same Docker command against the changed Pod YAML manifest will render an improved score and reduce the number of advised messages:</p>
<pre data-type="programlisting"><strong>$ docker run -i kubesec/kubesec:512c5e0 scan /dev/stdin</strong> \
  <strong>&lt; pod-improved-kubesec-test.yaml</strong>
[
  {
    "object": "Pod/kubesec-demo.default",
    "valid": true,
    "message": "Passed with a score of 9 points",
    "score": 9,
    "scoring": {
      "advise": [
        {
          "selector": ".metadata .annotations .\"container.seccomp.security. \
                       alpha.kubernetes.io/pod\"",
          "reason": "Seccomp profiles set minimum privilege and secure against \
                     unknown threats"
        },
        {
          "selector": ".spec .serviceAccountName",
          "reason": "Service accounts restrict Kubernetes API access and should \
                     be configured with least privilege"
        },
        {
          "selector": ".metadata .annotations .\"container.apparmor.security. \
                       beta.kubernetes.io/nginx\"",
          "reason": "Well defined AppArmor policies may provide greater \
                     protection from unknown threats. WARNING: NOT PRODUCTION \
                     READY"
        }
      ]
    }
  }
]</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Scanning Images for Known Vulnerabilities" data-type="sect1"><div class="sect1" id="idm46394749782656">
<h1>Scanning Images for Known Vulnerabilities</h1>
<p><a data-primary="CVE Details" data-type="indexterm" id="idm46394749781280"/>One of the top sources for logging and discovering security vulnerabilities is <a href="https://oreil.ly/DDlVa">CVE Details</a>. The page lists and ranks known vulnerabilities (CVEs) by score. Automated tooling can identify the software components embedded in a container image, compare those with the central vulnerabilities database, and flag issues by their severity.</p>
<p><a data-primary="documentation" data-secondary="Trivy" data-type="indexterm" id="idm46394749779504"/><a data-primary="Trivy" data-type="indexterm" id="idm46394749778304"/><a data-primary="images" data-secondary="scanning for known vulnerabilities" data-type="indexterm" id="idm46394749777632"/><a data-primary="known vulnerabilities, scanning images for" data-type="indexterm" id="idm46394749776720"/><a data-primary="scanning images, for known vulnerabilities" data-type="indexterm" id="idm46394749776080"/><a data-primary="supply chain security" data-secondary="scanning images for known vulnerabilities" data-type="indexterm" id="idm46394749775376"/><a data-primary="vulnerabilities, scanning images for known" data-type="indexterm" id="idm46394749750496"/>One of the open source tools with this capability explicitly mentioned in the CKS curriculum is <a href="https://oreil.ly/hqPHH">Trivy</a>. Trivy can run in different modes of operation: as a command line tool, in a container, as a GitHub Action configurable in a continuous integration workflow, as a plugin for the IDE VSCode, and as a Kubernetes operator. For an overview of the available installation options and procedures, see the <a href="https://oreil.ly/qB_c8">Trivy documentation</a>. During the exam, you are not expected to install the tool. It will already be preconfigured for you. All you need to understand is how to run it and how to interpret and fix the found vulnerabilities.</p>
<p>Say you installed the command line implementation of Trivy. You can check the version of Trivy with the following command:</p>
<pre data-type="programlisting"><strong>$ trivy -v</strong>
Version: 0.36.1
Vulnerability DB:
  Version: 2
  UpdatedAt: 2022-12-13 12:07:14.884952254 +0000 UTC
  NextUpdate: 2022-12-13 18:07:14.884951854 +0000 UTC
  DownloadedAt: 2022-12-13 17:09:28.866739 +0000 UTC</pre>
<p>As you can see in <a data-type="xref" href="#trivy-execution">Figure 6-7</a>, Trivy indicates the timestamp when a copy of known vulnerabilities has been downloaded from the central database. Trivy can scan container images in various forms. The subcommand <code>image</code> simply expects you to spell out the image name and tag, in this case <code>python:3.4-alpine</code>.</p>
<figure><div class="figure" id="trivy-execution">
<img alt="ckss 0607" height="1731" src="assets/ckss_0607.png" width="3001"/>
<h6><span class="label">Figure 6-7. </span>Reporting generated by scanning a container image with Trivy</h6>
</div></figure>
<p>The most important information in the output consists of the library that contains a specific vulnerability, its severity, and the minimum version to use that fixes the issue. Any found vulnerabilities with high or critical severity should be considered for a fix. If you do not have any control over the container image yourself, you can try to upgrade to a newer version.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46394749742832">
<h1>Summary</h1>
<p>Kubernetes primary objective is to run applications in containers in a scalable and secure fashion. In this chapter, we looked at the process, best practices, and tooling that help to ensure that a container image is produced that is small in size and that ships with as few known security vulnerabilities as possible.</p>
<p>We reviewed some of the most efficient techniques to reduce the footprint of a container image to a minimum. Start by picking a small base image to start with. You can even go to the extreme and not provide a shell at all for additional gains in size reduction. If you are using Docker, you can leverage the multi-stage approach that lets you build the application inside of the container without bundling the compiler, runtime, and build tools necessary to achieve the goal.</p>
<p>When consuming the container image in a Pod, make sure to only pull the container image from a trusted registry. It’s advisable to set up an in-house container registry to serve up container images, so that reaching out to public, internet-accessible registries becomes obsolete, to eliminate potential security risks. You can enforce the usage of a list of trusted container registries with the help of OPA Gatekeeper. Another measure of security can be enforced by using the SHA256 hash of a container image to validate its expected contents.</p>
<p>The process of building and scanning a container image can be incorporated into a CI/CD pipeline. Third-party tools can parse and analyze the resource files of your deployable artifacts even before you build them. We looked at Haskell Dockerfile Linter for Dockerfiles and Kubesec for Kubernetes manifests. The other use case that needs to be covered on security aspects is consuming an existing container image built by an entity external to you as a developer, or your company. Before running a container image in a Kubernetes Pod, make sure to scan the contents for vulnerabilities. Trivy is one of those tools that can identify and report vulnerabilities in a container image to give you an idea of the security risks you are exposing yourself to in case you are planning to operate it in a container.</p>
</div></section>
<section data-pdf-bookmark="Exam Essentials" data-type="sect1"><div class="sect1" id="idm46394749739952">
<h1>Exam Essentials</h1>
<dl>
<dt>Become familiar with techniques that help with reducing the container image footprint.</dt>
<dd>
<p>In this section, we described some techniques for reducing the size of a container image when building it. I would suggest you read the best practices mentioned on the Docker web page and try to apply them to sample container images. Compare the size of the produced container image before and after applying a technique. You can try to challenge yourself by reducing a container image to the smallest size possible while at the same time avoiding the loss of crucial functionality.</p>
</dd>
<dt>Walk through the process of governing where a container image can be resolved from.</dt>
<dd>
<p>OPA Gatekeeper offers a way to define the registries users are allowed to resolve container images from. Set up the objects for the constraint template and constraint, and see if the rules apply properly for a Pod that defines a main application container, an init container, and an ephemeral container. To broaden your exposure, also look at other products in the Kubernetes spaces that provide similar functionality. One of those products is <a href="https://kyverno.io">Kyverno</a>.</p>
</dd>
<dt>Sign a container image and verify it using the hash.</dt>
<dd>
<p>After building a container image, make sure to also create a digest for it. Publish the container image, as well as the digest, to a registry. Practice how to use the digest in a Pod definition and verify the behavior of Kubernetes upon pulling the container image.</p>
</dd>
<dt>Understand how to configure the ImagePolicyWebhook admission controller plugin.</dt>
<dd>
<p>You are not expected to write a backend for an ImagePolicyWebhook. That’s out of scope for the exam and requires knowledge of a programming language. You do need to understand how to enable the plugin in the API server configuration, though. I would suggest you practice the workflow even if you don’t have a running backend application available.</p>
</dd>
<dt>Know how to fix warnings produced by static analysis tools.</dt>
<dd>
<p>The CKS curriculum doesn’t prescribe a specific tool for analyzing Dockerfiles and Kubernetes manifests. During the exam, you may be asked to run a specific command that will produce a list of error and/or warning messages. Understand how to interpret the messages, and how to fix them in the relevant resource files.</p>
</dd>
<dt>Practice the use of Trivy to identify and fix security vulnerabilities.</dt>
<dd>
<p>The FAQ of the CKS lists the documentation page for Trivy. Therefore, it’s fair to assume that Trivy may come up in one of the questions. You will need to understand the different ways to invoke Trivy to scan a container image. The produced report will give a you clear indication on what needs to be fixed and the severity of the found vulnerability. Given that you can’t modify the container image easily, you will likely be asked to flag Pods that run container images with known vulnerabilities.</p>
</dd>
</dl>
</div></section>
<section class="less_space pagebreak-before" data-pdf-bookmark="Sample Exercises" data-type="sect1"><div class="sect1" id="idm46394749729264">
<h1>Sample Exercises</h1>
<p><a data-primary="sample exercises" data-secondary="supply chain security" data-type="indexterm" id="idm46394749727648"/><a data-primary="supply chain security" data-secondary="sample exercises" data-type="indexterm" id="idm46394749726672"/><a data-primary="" data-startref="scs_ch" data-type="indexterm" id="idm46394749725728"/>Solutions to these exercises are available in the <a data-type="xref" href="app01.xhtml#appendix-a">Appendix</a>.</p>
<ol>
<li>
<p>Have a look at the following Dockerfile. Can you identify possibilities for reducing the footprint of the produced container image?</p>
<pre data-code-language="dockerfile" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">node:latest</code><code class="w"/>
<code class="k">ENV</code><code class="w"> </code>NODE_ENV<code class="w"> </code>development<code class="w"/>
<code class="k">WORKDIR</code><code class="w"> </code><code class="s">/app</code><code class="w"/>
<code class="k">COPY</code><code class="w"> </code>package.json<code class="w"> </code>.<code class="w"/>
<code class="k">RUN</code><code class="w"> </code>npm<code class="w"> </code>install<code class="w"/>
<code class="k">COPY</code><code class="w"> </code>.<code class="w"> </code>.<code class="w"/>
<code class="k">EXPOSE</code><code class="w"> </code><code class="s">3001</code><code class="w"/>
<code class="k">CMD</code><code class="w"> </code><code class="p">[</code><code class="s2">"node"</code><code class="p">,</code><code class="w"> </code><code class="s2">"app.js"</code><code class="p">]</code><code class="w"/></pre>
<p>Apply Dockerfile best practices to optimize the container image footprint. Run the <code>docker build</code> command before and after making optimizations. The resulting size of the container image should be smaller but the application should still be functioning.</p>
</li>
<li>
<p>Install Kyverno in your Kubernetes cluster. You can find installation instructions in the <a href="https://oreil.ly/yxlLe">documentation</a>.</p>
<p>Apply the “Restrict Image Registries” policy described on the <a href="https://oreil.ly/Kdj1k">documentation page</a>. The only allowed registry should be <code>gcr.io</code>. Usage of any other registry should be denied.</p>
<p>Create a Pod that defines the container image <code>gcr.io/google-containers/busybox:1.27.2</code>. Creation of the Pod should fail. Create another Pod using the container image <code>busybox:1.27.2</code>. Kyverno should allow the Pod to be created.</p>
</li>
<li>
<p>Define a Pod using the container image <code>nginx:1.23.3-alpine</code> in the YAML manifest <code>pod-validate-image.yaml</code>. Retrieve the digest of the container image from Docker Hub. Validate the container image contents using the SHA256 hash. Create the Pod. Kubernetes should be able to successfully pull the container image.</p>
</li>
<li>
<p>Use Kubesec to analyze the following contents of the YAML manifest file <code>pod.yaml</code>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hello-world</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">runAsUser</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">0</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">linux</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hello-world:linux</code><code class="w"/></pre>
<p>Inspect the suggestions generated by Kubesec. Ignore the suggestions on seccomp and AppArmor. Fix the root cause of all messages so that another execution of the tool will not report any additional suggestions.</p>
</li>
<li>
<p>Navigate to the directory <em>app-a/ch06/trivy</em> of the checked-out GitHub repository <a href="https://oreil.ly/sImXZ"><em>bmuschko/cks-study-guide</em></a>. Execute the command <code>kubectl apply -f setup.yaml</code>.</p>
<p>The command creates three different Pods in the namespace <code>r61</code>. From the command line, execute Trivy against the container images used by the Pods. Delete all Pods that have “CRITICAL” vulnerabilities. Which of the Pods are still running?</p>
</li>
</ol>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46394749620320">
<h1>Interactive Exam Practice</h1>
<p>Get more hands-on training and test your CKS exam readiness by working through our interactive CKS labs. Each step of the lab must be completed correctly before you can move to the next step. If you get stuck, you can view the solution and learn how to complete the step.</p>
<p>The following labs cover material from this chapter:</p>
<ul>
<li>
<p><a href="https://learning.oreilly.com/scenarios/reducing-the-footprint/9781098149932/">Reducing the Footprint of a Container Image</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/governing-allowed-container/9781098149949/">Governing Allowed Container Registries</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/validating-the-container/9781098149956/">Validating the Container Image Contents Using Its SHA256 Digest</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/configuring-the-imagepolicywebhook/9781098149963/">Configuring the ImagePolicyWebhook Admission Controller Plug-in</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/applying-security-best/9781098149970/">Applying Security Best Practices to a Dockerfile</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/applying-security-best/9781098149987/">Applying Security Best Practices to a Kubernetes Resource File</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/scanning-container-images/9781098149994/">Scanning Container Images with Trivy</a></p>
</li>
</ul>
</div></aside>
</div></section>
</div></section></div></body></html>