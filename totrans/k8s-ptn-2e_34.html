<html><head></head><body><section data-pdf-bookmark="Chapter 27. Controller" data-type="chapter" epub:type="chapter"><div class="chapter" id="Controller">&#13;
<h1><span class="label">Chapter 27. </span>Controller</h1>&#13;
&#13;
&#13;
<p>A<a data-primary="Controller" data-type="indexterm" id="cntrllr27"/> controller actively monitors and maintains a set of Kubernetes resources in a desired state. The heart of Kubernetes itself consists of a fleet of controllers that regularly watch and reconcile the current state of applications with the declared target state. In this chapter, we see how to leverage this <em>Controller</em> pattern to extend the platform for our needs.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902084270032">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>You’ve<a data-primary="problems" data-secondary="controllers, creating customized" data-type="indexterm" id="idm45902084268528"/> already seen that Kubernetes is a sophisticated and comprehensive platform that provides many features out of the box. However, it is a general-purpose orchestration platform that does not cover all application use cases.&#13;
Luckily, it provides natural extension points where specific use cases can be implemented elegantly on top of proven Kubernetes building blocks.</p>&#13;
&#13;
<p>The main questions that arise here are how to extend Kubernetes without changing and breaking it and how to use its capabilities for custom use cases.</p>&#13;
&#13;
<p>By design, Kubernetes is based on a<a data-primary="Kubernetes" data-secondary="declarative resource-centric API base" data-type="indexterm" id="idm45902084266416"/><a data-primary="declarative resource-centric APIs" data-type="indexterm" id="idm45902084265376"/> declarative resource-centric API. What exactly do we mean by <em>declarative</em>? As opposed to an <em>imperative</em> approach, a declarative approach does not tell Kubernetes how it should act but instead describes how the target state should look. For example, when we scale up a Deployment, we do not actively create new Pods by telling Kubernetes to “create a new Pod.” Instead, we change the Deployment resource’s <code>replicas</code> property via the Kubernetes API to the desired number.</p>&#13;
&#13;
<p>So, how<a data-primary="Pods" data-secondary="creating new" data-type="indexterm" id="idm45902084262832"/> are the new Pods created? This is done internally by the controllers. For every change in the resource status (like changing the <code>replicas</code> property value of a Deployment), Kubernetes creates an event and broadcasts it to all interested listeners. These listeners can then react by modifying, deleting, or creating new resources, which in turn creates other events, like Pod-created events. These events are then potentially picked up again by other controllers, which perform their specific actions.</p>&#13;
&#13;
<p>The whole process is also known as<a data-primary="state reconciliation" data-type="indexterm" id="idm45902084260752"/> <em>state reconciliation</em>, where a target state (the number of desired replicas) differs from the current state (the actual running instances), and it is the task of a controller to reconcile and reach the desired target state again. When looked at from this angle, Kubernetes essentially represents a distributed state manager. You give it the desired state for a component instance, and it attempts to maintain that state should anything change.</p>&#13;
&#13;
<p>How can we now hook into this reconciliation process without modifying Kubernetes code and create a controller customized for our specific needs?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902084258800">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>Kubernetes comes with a collection of built-in controllers that manage standard Kubernetes resources like ReplicaSets, <a data-primary="DaemonSets" data-secondary="built-in controllers" data-type="indexterm" id="idm45902084255952"/>DaemonSets, StatefulSets, Deployments, or Services. These controllers run as part of the controller manager, which is deployed (as a standalone process or a Pod) on the control plane node. These controllers are not aware of one another. They run in an endless reconciliation loop, to monitor their resources for the actual and desired state and to act accordingly to get the actual state closer to the desired state.</p>&#13;
&#13;
<p>However, in addition to these out-of-the-box controllers, the<a data-primary="Kubernetes" data-secondary="event-driven architecture" data-type="indexterm" id="idm45902084254560"/><a data-primary="event-driven" data-secondary="architecture" data-type="indexterm" id="idm45902084253488"/> Kubernetes event-driven architecture allows us to natively plug in other custom controllers. Custom controllers can add extra functionality to the behavior by reacting to state-changing events, the same way that internal controllers do. A common characteristic of controllers is that they are reactive and react to events in the system to perform their specific actions. At a high level, this reconciliation process consists of the following main steps:</p>&#13;
<dl>&#13;
<dt>Observe</dt>&#13;
<dd>&#13;
<p>Discover the actual state by watching for events issued by Kubernetes when an observed resource changes.</p>&#13;
</dd>&#13;
<dt>Analyze</dt>&#13;
<dd>&#13;
<p>Determine the differences from the desired state.</p>&#13;
</dd>&#13;
<dt>Act</dt>&#13;
<dd>&#13;
<p>Perform operations to drive the actual state to the desired state.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>For example, the<a data-primary="ReplicaSet" data-secondary="Controller" data-type="indexterm" id="idm45902084247280"/> ReplicaSet controller watches for ReplicaSet resource changes, analyzes how many Pods need to be running, and acts by submitting Pod definitions to the API Server. The Kubernetes backend is then responsible for starting up the requested Pod on a node.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-controller-controller">Figure 27-1</a> shows how a controller registers itself as an event listener for detecting changes on the managed resources. It observes the current state and changes it by calling out to the API Server to get closer to the target state (if necessary).</p>&#13;
&#13;
<figure><div class="figure" id="img-controller-controller">&#13;
<img alt="Observe-Analyse-Act cycle" src="assets/kup2_2701.png"/>&#13;
<h6><span class="label">Figure 27-1. </span>Observe-Analyze-Act cycle</h6>&#13;
</div></figure>&#13;
&#13;
<p>Controllers are part of the Kubernetes control plane, and it became clear early on that they would also allow you to extend the platform with custom behavior. Moreover, they have become the standard mechanism for extending the platform and enable complex application lifecycle management. And as a result, a new generation of more sophisticated controllers was born, called<a data-primary="Operator" data-secondary="Controller" data-type="indexterm" id="idm45902084242752"/><a data-primary="Operator" data-type="indexterm" id="idm45902084241776"/> <em>Operators</em>. From an evolutionary and complexity point of view, we can classify the active reconciliation components into two groups:</p>&#13;
<dl>&#13;
<dt><em>Controllers</em></dt>&#13;
<dd>&#13;
<p>A simple reconciliation process that monitors and acts on standard Kubernetes resources. More often, these controllers enhance platform behavior and add new platform features.</p>&#13;
</dd>&#13;
<dt><em>Operators</em></dt>&#13;
<dd>&#13;
<p>A sophisticated reconciliation process that interacts with CustomResourceDefinitions (CRDs), which are at the heart of the <em>Operator</em> pattern. Typically, these operators encapsulate complex application domain logic and manage the full application lifecycle.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>As stated previously, these classifications help introduce new concepts gradually. Here, we focus on the simpler controllers, and in <a data-type="xref" href="ch28.html#Operator">Chapter 28</a>, we introduce CRDs and build up to the <em>Operator</em> pattern.</p>&#13;
&#13;
<p>To<a data-primary="Singleton Service" data-secondary="Controller" data-type="indexterm" id="idm45902084234096"/><a data-primary="Singleton Service" data-type="indexterm" id="idm45902084233088"/> avoid having multiple controllers acting on the same resources simultaneously, controllers use the <em>Singleton Service</em> pattern explained in <a data-type="xref" href="ch10.html#SingletonService">Chapter 10</a>. Most controllers are deployed just as Deployments but with one replica, as Kubernetes uses optimistic locking at the resource level to prevent concurrency issues when changing resource objects. In the end, a controller is nothing more than an application that runs permanently in the background.</p>&#13;
&#13;
<p>Because Kubernetes itself is written in Go, and a complete client library for accessing Kubernetes is also written in Go, many controllers are written in Go too. However, you can write controllers in any programming language by sending requests to the Kubernetes API Server. We see a controller written in a pure shell script later in <a data-type="xref" href="#ex-controller-config-map">Example 27-1</a>.</p>&#13;
&#13;
<p>The most straightforward kind of controllers extend the way Kubernetes manages its resources. They operate on the same standard resources and perform similar tasks as the Kubernetes internal controllers operating on the standard Kubernetes resources, but they are invisible to the user of the cluster. Controllers evaluate resource definitions and conditionally perform some actions. Although they can monitor and act upon any field in the resource definition, metadata and ConfigMaps are most suitable for this purpose. The following are a few considerations to keep in mind when choosing where to store controller data:</p>&#13;
<dl>&#13;
<dt>Labels</dt>&#13;
<dd>&#13;
<p>Labels<a data-primary="labels" data-type="indexterm" id="idm45902084227504"/> as part of a resource’s metadata can be watched by any controller. They are indexed in the backend database and can be efficiently searched for in queries. We should use labels when a selector-like functionality is required (e.g., to match Pods of a Service or a Deployment). A limitation of labels is that only alphanumeric names and values with restrictions can be used. See the Kubernetes documentation for which syntax and character sets are allowed for labels.</p>&#13;
</dd>&#13;
<dt>Annotations</dt>&#13;
<dd>&#13;
<p>Annotations<a data-primary="annotations" data-type="indexterm" id="idm45902084224880"/> are an excellent alternative to labels. They have to be used instead of labels if the values do not conform to the syntax restrictions of label values. Annotations are not indexed, so we use annotations for nonidentifying information not used as keys in controller queries. Preferring annotations over labels for arbitrary metadata also has the advantage that it does not negatively impact the internal Kubernetes performance.</p>&#13;
</dd>&#13;
<dt>ConfigMaps</dt>&#13;
<dd>&#13;
<p>Sometimes<a data-primary="ConfigMaps" data-secondary="holding target state definitions in" data-type="indexterm" id="idm45902084222736"/> controllers need additional information that does not fit well into labels or annotations. In this case, ConfigMaps can be used to hold the target state definition. These ConfigMaps are then watched and read by the controllers. However, CRDs are much better suited for designing the custom target state specification and are recommended over plain ConfigMaps. For registering CRDs, however, you need elevated cluster-level permissions. If you don’t have these, ConfigMaps are still the best alternative to CRDs. We will explain CRDs in detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch28.html#Operator">Chapter 28, “Operator”</a>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Here are a few reasonably simple example controllers you can study as a sample implementation of this pattern:</p>&#13;
<dl>&#13;
<dt>jenkins-x/exposecontroller</dt>&#13;
<dd>&#13;
<p><a href="https://oreil.ly/URMaE">This controller</a> watches<a data-primary="jenkins-x/exposecontroller" data-type="indexterm" id="idm45902084217472"/><a data-primary="Services" data-secondary="controller for exposing" data-type="indexterm" id="idm45902084216768"/> Service definitions, and if it detects an annotation named <code>expose</code> in the metadata, the controller automatically exposes an Ingress object for external access of the Service. It also removes the Ingress object when someone removes the Service. This project is now archived but still serves as a good example of implementing a simple controller.</p>&#13;
</dd>&#13;
<dt>stakater/Reloader</dt>&#13;
<dd>&#13;
<p>This<a data-primary="stakater/Reloader" data-type="indexterm" id="idm45902084213920"/> is <a href="https://oreil.ly/YUGPG">a controller</a> that watches ConfigMap and Secret objects for changes and performs rolling upgrades of their associated workloads, which can be Deployment, <a data-primary="DaemonSets" data-secondary="stakater/Reloader controller" data-type="indexterm" id="idm45902084212208"/>DaemonSet, StatefulSet and other workload resources. We can use this controller with applications that are not capable of watching the ConfigMap and updating themselves with new configurations dynamically. That is particularly true when a Pod consumes this ConfigMap as environment variables or when your application cannot quickly and reliably update itself on the fly without a restart. As a proof of concept, we implement a similar controller with a plain shell script in <a data-type="xref" href="#ex-controller-script">Example 27-2</a>.</p>&#13;
</dd>&#13;
<dt>Flatcar Linux Update Operator</dt>&#13;
<dd>&#13;
<p>This<a data-primary="Flatcar Linux update operator" data-type="indexterm" id="idm45902084208512"/> is a <a href="https://oreil.ly/f8_FY">controller</a> that reboots a Kubernetes node running on Flatcar Container Linux when it detects a particular annotation on the Node resource object.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Now<a data-primary="ConfigMaps" data-secondary="custom controllers for" data-type="indexterm" id="idm45902084206208"/> let’s take a look at a concrete example: a controller that consists of a single shell script and that watches the Kubernetes API for changes on ConfigMap resources.&#13;
If we annotate such a ConfigMap with <code>k8spatterns.io/podDeleteSelector</code>, all Pods selected with the given label selector are deleted when the ConfigMap changes.&#13;
Assuming we back these Pods with a high-order resource like Deployment or ReplicaSet, these Pods are restarted and pick up the changed configuration.</p>&#13;
&#13;
<p>For example, the following ConfigMap would be monitored by our controller for changes and would restart all Pods that have a label <code>app</code> with value <code>webapp</code>. The ConfigMap in <a data-type="xref" href="#ex-controller-config-map">Example 27-1</a> is used in our web application to provide a welcome <span class="keep-together">message</span>.</p>&#13;
<div data-type="example" id="ex-controller-config-map">&#13;
<h5><span class="label">Example 27-1. </span>ConfigMap use by web application</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webapp-config</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">k8spatterns.io/podDeleteSelector</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">app=webapp</code><code class="s">"</code><code class="w">  </code><a class="co" href="#callout_controller_CO1-1" id="co_controller_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">data</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">message</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">Welcome</code><code class="nv"> </code><code class="s">to</code><code class="nv"> </code><code class="s">Kubernetes</code><code class="nv"> </code><code class="s">Patterns</code><code class="nv"> </code><code class="s">!</code><code class="s">"</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_controller_CO1-1" id="callout_controller_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Annotation used as selector for the controller in <a data-type="xref" href="#ex-controller-script">Example 27-2</a> to find the application Pods to restart.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Our controller shell script now evaluates this ConfigMap. You can find the source in its full glory in our Git repository. In short, the controller starts a<a data-primary="hanging GET technique" data-type="indexterm" id="idm45902084150064"/> <em>hanging GET</em> HTTP request for opening an endless HTTP response stream to observe the lifecycle events pushed by the API Server to us. These events are in the form of plain JSON objects, which are then analyzed to detect whether a changed ConfigMap carries our annotation. As events arrive, the controller acts by deleting all Pods matching the selector provided as the value of the annotation. Let’s have a closer look at how the controller works.</p>&#13;
&#13;
<p>The main part of this controller is the reconciliation loop, which listens on ConfigMap lifecycle events, as shown in <a data-type="xref" href="#ex-controller-script">Example 27-2</a>.</p>&#13;
<div data-type="example" id="ex-controller-script">&#13;
<h5><span class="label">Example 27-2. </span>Controller script</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">namespace</code><code class="o">=</code><code class="si">${</code><code class="nv">WATCH_NAMESPACE</code><code class="k">:-</code><code class="nv">default</code><code class="si">}</code><code class="w">  </code><a class="co" href="#callout_controller_CO2-1" id="co_controller_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
&#13;
</code><code class="nv">base</code><code class="o">=</code><code>http://localhost:8001</code><code class="w">             </code><a class="co" href="#callout_controller_CO2-2" id="co_controller_CO2-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="nv">ns</code><code class="o">=</code><code>namespaces/</code><code class="nv">$namespace</code><code class="w">&#13;
&#13;
</code><code>curl</code><code class="w"> </code><code>-N</code><code class="w"> </code><code>-s</code><code class="w"> </code><code class="nv">$base</code><code>/api/v1/</code><code class="si">${</code><code class="nv">ns</code><code class="si">}</code><code>/configmaps?watch</code><code class="o">=</code><code class="nb">true</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code class="se">\&#13;
</code><code class="k">while</code><code class="w"> </code><code class="nb">read</code><code class="w"> </code><code>-r</code><code class="w"> </code><code>event</code><code class="w">                    </code><a class="co" href="#callout_controller_CO2-3" id="co_controller_CO2-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="k">do</code><code class="w">&#13;
   </code><code class="c1"># ...&#13;
</code><code class="k">done</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_controller_CO2-1" id="callout_controller_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Namespace to watch (or <em>default</em> if not given).</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO2-2" id="callout_controller_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Access to the Kubernetes API via a proxy running in the same Pod.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO2-3" id="callout_controller_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Loop with watches for events on ConfigMaps.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The environment variable <code>WATCH_NAMESPACE</code> specifies the namespace in which the controller should watch for ConfigMap updates. We can set this variable in the Deployment descriptor of the controller itself. In our example, we’re using the Downward API described in<a data-primary="Self Awareness" data-secondary="Controller" data-type="indexterm" id="idm45902084055840"/><a data-primary="Self Awareness" data-type="indexterm" id="idm45902084019952"/> <a data-type="xref" data-xrefstyle="chap-num-title" href="ch14.html#SelfAwareness">Chapter 14, “Self Awareness”</a>, to monitor the namespace in which we have deployed the controller as configured in <a data-type="xref" href="#ex-controller-downward-api">Example 27-3</a> as part of the controller Deployment.</p>&#13;
<div class="less_space pagebreak-before" data-type="example" id="ex-controller-downward-api">&#13;
<h5><span class="label">Example 27-3. </span><code>WATCH_NAMESPACE</code> extracted from the current namespace</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w"> </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">WATCH_NAMESPACE</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">fieldRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">fieldPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">metadata.namespace</code><code class="w"/></pre></div>&#13;
&#13;
<p>With this namespace, the controller script constructs the URL to the Kubernetes API endpoint to watch the ConfigMaps.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Note the <code>watch=true</code> query parameter in <a data-type="xref" href="#ex-controller-script">Example 27-2</a>. This parameter indicates to the API Server not to close the HTTP connection but to send events along the response channel as soon as they happen<a data-primary="Comet technique" data-type="indexterm" id="idm45902083992112"/> (<em>hanging GET</em> or <em>Comet</em> are other names for this kind of technique). The loop reads every individual event as it arrives as a single item to process.</p>&#13;
</div>&#13;
&#13;
<p>As you can see, our controller contacts the Kubernetes API Server via localhost. We won’t deploy this script directly on the Kubernetes API control plane node, but then how can we use localhost in the script? As you may have probably guessed, another pattern kicks in here. We<a data-primary="Ambassador" data-type="indexterm" id="idm45902083987088"/><a data-primary="Ambassador" data-secondary="Controller" data-type="indexterm" id="idm45902083986384"/> deploy this script in a Pod together with an ambassador container that exposes port 8001 on localhost and proxies it to the real Kubernetes Service. See <a data-type="xref" href="ch18.html#Ambassador">Chapter 18</a> for more details on the <em>Ambassador</em> pattern. We see the actual Pod definition with this ambassador in detail later in this chapter.</p>&#13;
&#13;
<p>Watching events this way is not very robust, of course. The connection can stop anytime, so there should be a way to restart the loop. Also, one could miss events, so production-grade controllers should not only watch on events but from time to time should also query the API Server for the entire current state and use that as the new base.&#13;
For the sake of demonstrating the pattern, this is good enough.</p>&#13;
&#13;
<p>Within the loop, the logic shown in <a data-type="xref" href="#ex-controller-loop">Example 27-4</a> is performed.</p>&#13;
<div data-type="example" id="ex-controller-loop">&#13;
<h5><span class="label">Example 27-4. </span>Controller reconciliation loop</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code>curl</code><code class="w"> </code><code>-N</code><code class="w"> </code><code>-s</code><code class="w"> </code><code class="nv">$base</code><code>/api/v1/</code><code class="si">${</code><code class="nv">ns</code><code class="si">}</code><code>/configmaps?watch</code><code class="o">=</code><code class="nb">true</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code class="se">\&#13;
</code><code class="k">while</code><code class="w"> </code><code class="nb">read</code><code class="w"> </code><code>-r</code><code class="w"> </code><code>event</code><code class="w">&#13;
</code><code class="k">do</code><code class="w">&#13;
  </code><code class="nv">type</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code><code class="w"> </code><code class="s2">"</code><code class="nv">$event</code><code class="s2">"</code><code class="w">        </code><code class="p">|</code><code class="w"> </code><code>jq</code><code class="w"> </code><code>-r</code><code class="w"> </code><code class="s1">'.type'</code><code class="k">)</code><code class="w">                 </code><a class="co" href="#callout_controller_CO3-1" id="co_controller_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
  </code><code class="nv">config_map</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code><code class="w"> </code><code class="s2">"</code><code class="nv">$event</code><code class="s2">"</code><code class="w">  </code><code class="p">|</code><code class="w"> </code><code>jq</code><code class="w"> </code><code>-r</code><code class="w"> </code><code class="s1">'.object.metadata.name'</code><code class="k">)</code><code class="w">&#13;
  </code><code class="nv">annotations</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code><code class="w"> </code><code class="s2">"</code><code class="nv">$event</code><code class="s2">"</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code>jq</code><code class="w"> </code><code>-r</code><code class="w"> </code><code class="s1">'.object.metadata.annotations'</code><code class="k">)</code><code class="w">&#13;
&#13;
  </code><code class="k">if</code><code class="w"> </code><code class="o">[</code><code class="w"> </code><code class="s2">"</code><code class="nv">$annotations</code><code class="s2">"</code><code class="w"> </code><code>!</code><code class="o">=</code><code class="w"> </code><code class="s2">"null"</code><code class="w"> </code><code class="o">]</code><code class="p">;</code><code class="w"> </code><code class="k">then</code><code class="w">&#13;
    </code><code class="nv">selector</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code><code class="w"> </code><code class="nv">$annotations</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code class="se">\ </code><code class="w">                          </code><a class="co" href="#callout_controller_CO3-2" id="co_controller_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
     </code><code>jq</code><code class="w"> </code><code>-r</code><code class="w"> </code><code class="s2">"\&#13;
        to_entries                                           |\&#13;
        .[]                                                  |\&#13;
        select(.key == \"k8spatterns.io/podDeleteSelector\") |\&#13;
        .value                                               |\&#13;
         @uri                                                 \&#13;
     "</code><code class="k">)</code><code class="w">&#13;
  </code><code class="k">fi</code><code class="w">&#13;
&#13;
  </code><code class="k">if</code><code class="w"> </code><code class="o">[</code><code class="w"> </code><code class="nv">$type</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"MODIFIED"</code><code class="w"> </code><code class="o">]</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="o">[</code><code class="w"> </code><code>-n</code><code class="w"> </code><code class="s2">"</code><code class="nv">$selector</code><code class="s2">"</code><code class="w"> </code><code class="o">]</code><code class="p">;</code><code class="w"> </code><code class="k">then</code><code class="w">        </code><a class="co" href="#callout_controller_CO3-3" id="co_controller_CO3-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
    </code><code class="nv">pods</code><code class="o">=</code><code class="k">$(</code><code>curl</code><code class="w"> </code><code>-s</code><code class="w"> </code><code class="nv">$base</code><code>/api/v1/</code><code class="si">${</code><code class="nv">ns</code><code class="si">}</code><code>/pods?labelSelector</code><code class="o">=</code><code class="nv">$selector</code><code class="w"> </code><code class="p">|</code><code class="se">\&#13;
</code><code class="w">           </code><code>jq</code><code class="w"> </code><code>-r</code><code class="w"> </code><code>.items</code><code class="o">[</code><code class="o">]</code><code>.metadata.name</code><code class="k">)</code><code class="w">&#13;
&#13;
    </code><code class="k">for</code><code class="w"> </code><code>pod</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code class="nv">$pods</code><code class="p">;</code><code class="w"> </code><code class="k">do</code><code class="w">                                       </code><a class="co" href="#callout_controller_CO3-4" id="co_controller_CO3-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
      </code><code>curl</code><code class="w"> </code><code>-s</code><code class="w"> </code><code>-X</code><code class="w"> </code><code>DELETE</code><code class="w"> </code><code class="nv">$base</code><code>/api/v1/</code><code class="si">${</code><code class="nv">ns</code><code class="si">}</code><code>/pods/</code><code class="nv">$pod</code><code class="w">&#13;
    </code><code class="k">done</code><code class="w">&#13;
  </code><code class="k">fi</code><code class="w">&#13;
</code><code class="k">done</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_controller_CO3-1" id="callout_controller_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Extract the type and name of the ConfigMap from the event.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO3-2" id="callout_controller_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Extract all annotations on the ConfigMap with the key <code>k8spatterns.io/podDeleteSelector</code>. See the following sidebar for an explanation of this <code>jq</code> expression.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO3-3" id="callout_controller_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>If the event indicates an update of the ConfigMap and our annotation is attached, then find all Pods matching this label selector.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO3-4" id="callout_controller_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Delete all Pods that match the selector.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>First, the script extracts the event type that specifies what action happened to the ConfigMap. Then, we derive the annotations with <code>jq</code>.&#13;
<a href="https://oreil.ly/e57Xi"><code>jq</code></a> is an excellent tool for parsing JSON documents from the command line, and the script assumes it is available in the container the script is running in.</p>&#13;
&#13;
<p>If the ConfigMap has annotations, we check for the annotation <code>k8spatterns.io/podDeleteSelector</code> by using a more complex <code>jq</code> query. The purpose of this query is to convert the annotation value to a Pod selector that can be used in an API query option in the next step: an annotation <code>k8spatterns.io/podDeleteSelector: "app=webapp"</code> is transformed to <code>app%3Dwebapp</code> that is used as a Pod selector. This conversion is performed with <code>jq</code> and is explained next if you are interested in how this extraction works.</p>&#13;
&#13;
<p>If the script can extract a <code>selector</code>, we can now use it directly to select the Pods to delete. First, we look up all Pods that match the selector, and then we delete them one by one with direct API calls.</p>&#13;
&#13;
<p>This<a data-primary="shell script-based controller" data-type="indexterm" id="idm45902083692912"/> shell script-based controller is, of course, not production-grade (e.g., the event loop can stop any time), but it nicely reveals the base concepts without too much boilerplate code for us.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar-controller-jq">&#13;
<h1>Some jq Fu</h1>&#13;
<p>Extracting<a data-primary="jq command line tool" data-type="indexterm" id="idm45902083690432"/> the ConfigMap’s <code>k8spatterns.io/podDeleteSelector</code>  annotation value and converting it to a Pod selector is performed with <code>jq</code>. This is an excellent JSON command-line tool, but some concepts can be a bit confusing. Let’s have a close look at how the expressions work in detail:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">selector</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code><code class="w"> </code><code class="nv">$annotations</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code class="se">\</code>&#13;
<code class="w">   </code>jq<code class="w"> </code>-r<code class="w"> </code><code class="s2">"\</code>&#13;
<code class="s2">    to_entries                                           |\</code>&#13;
<code class="s2">    .[]                                                  |\</code>&#13;
<code class="s2">    select(.key == \"k8spatterns.io/podDeleteSelector\") |\</code>&#13;
<code class="s2">    .value                                               |\</code>&#13;
<code class="s2">     @uri                                                 \</code>&#13;
<code class="s2"> "</code><code class="k">)</code><code class="w"/></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>$annotations</code> holds all annotations as a JSON object, with annotation names as properties.</p>&#13;
</li>&#13;
<li>&#13;
<p>With <code>to_entries</code>, we convert a JSON object like <code>{ "a": "b"}</code> into an array with entries like <code>{ "key": "a", "value": "b" }</code>. See the <a href="https://oreil.ly/c3c6b"><code>jq</code> documentation</a> for more details.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>.[]</code> selects the array entries individually.</p>&#13;
</li>&#13;
<li>&#13;
<p>From these entries, we pick only the ones with the matching key. There can be only zero or one matches that survive this filter.</p>&#13;
</li>&#13;
<li>&#13;
<p>Finally, we extract the value (<code>.value</code>) and convert it with <code>@uri</code> so that it can be used as part of a URI.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This expression converts a JSON structure such as</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"k8spatterns.io/pattern"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Controller"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"k8spatterns.io/podDeleteSelector"</code><code class="p">:</code><code class="w"> </code><code class="s2">"app=webapp"</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>to a selector, <code>app%3Dwebapp</code>.</p>&#13;
</div></aside>&#13;
&#13;
<p>The remaining work is about creating resource objects and container images. The controller script itself is stored in a ConfigMap <code>config-watcher-controller</code>, and can be easily edited later if required.</p>&#13;
&#13;
<p>We use a Deployment to create a Pod for our controller with two containers:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>One Kubernetes API<a data-primary="Ambassador" data-type="indexterm" id="idm45902083601568"/><a data-primary="Ambassador" data-secondary="Controller" data-type="indexterm" id="idm45902083600832"/> ambassador container that exposes the Kubernetes API on localhost on port 8001. The image <code>k8spatterns/kubeapi-proxy</code> is an Alpine Linux with a local <code>kubectl</code> installed and<a data-primary="kubectl" data-secondary="creating Pods with two containers" data-type="indexterm" id="idm45902083598880"/> <code>kubectl proxy</code> started with the proper CA and token mounted. The original version, kubectl-proxy, was written by Marko Lukša, who introduced this proxy in <em>Kubernetes in Action</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The main container that executes the script contained in the just-created ConfigMap. Here, we use an Alpine base image with <code>curl</code> and <code>jq</code> installed.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>You can find the Dockerfiles for the <code>k8spatterns/kubeapi-proxy</code> and <code>k8spatterns/curl-jq</code> images in the example <a href="https://oreil.ly/a0zZR">Git repository</a>.</p>&#13;
&#13;
<p>Now that we have the images for our Pod, the final step is to deploy the controller by using a Deployment. We can see the main parts of the Deployment in <a data-type="xref" href="#ex-controller-deployment">Example 27-5</a> (the full version is available in our example repository).</p>&#13;
<div data-type="example" id="ex-controller-deployment">&#13;
<h5><span class="label">Example 27-5. </span>Controller Deployment</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w">&#13;
</code><code class="c1"># ....</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="c1"># ...</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-watcher-controller</code><code class="w"> </code><a class="co" href="#callout_controller_CO4-1" id="co_controller_CO4-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubeapi-proxy</code><code class="w">                         </code><a class="co" href="#callout_controller_CO4-2" id="co_controller_CO4-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/kubeapi-proxy</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-watcher</code><code class="w">                        </code><a class="co" href="#callout_controller_CO4-3" id="co_controller_CO4-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/curl-jq</code><code class="w">&#13;
</code><code class="w">        </code><code class="c1"># ...</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w">                                    </code><a class="co" href="#callout_controller_CO4-4" id="co_controller_CO4-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">sh</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">/watcher/config-watcher-controller.sh</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">                               </code><a class="co" href="#callout_controller_CO4-5" id="co_controller_CO4-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">/watcher</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-watcher-controller</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-watcher-controller</code><code class="w">             </code><a class="co" href="#callout_controller_CO4-6" id="co_controller_CO4-6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">configMap</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-watcher-controller</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_controller_CO4-1" id="callout_controller_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>ServiceAccount with proper permissions for watching events and restarting Pods.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO4-2" id="callout_controller_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Ambassador container for proxying localhost to the Kubeserver API.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO4-3" id="callout_controller_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Main container holding all tools and mounting the controller script.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO4-4" id="callout_controller_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Startup command calling the controller script.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO4-5" id="callout_controller_CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Volume mapped to the ConfigMap holding our script.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO4-6" id="callout_controller_CO4-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Mount of the ConfigMap-backed volume into the main Pod.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>As you can see, we mount the <code>config-watcher-controller-script</code> from the ConfigMap we created previously and directly use it as the startup command for the primary container. For simplicity, we omitted any liveness and readiness checks as well as resource limit declarations. Also, we need a ServiceAccount <code>config-watcher-controller</code> that is allowed to monitor ConfigMaps. Refer to the example repository for the full security setup.</p>&#13;
&#13;
<p>Let’s see the controller in action. For this, we are using a straightforward web server, which serves the value of an environment variable as the only content.&#13;
The base image uses plain <code>nc</code> (netcat) for serving the content. You can find the Dockerfile for this image in the example repository. We deploy the HTTP server with a ConfigMap and Deployment, as is sketched in <a data-type="xref" href="#ex-controller-webapp">Example 27-6</a>.</p>&#13;
<div data-type="example" id="ex-controller-webapp">&#13;
<h5><span class="label">Example 27-6. </span>Sample web app with Deployment and ConfigMap</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w">                                    </code><a class="co" href="#callout_controller_CO5-1" id="co_controller_CO5-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webapp-config</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">k8spatterns.io/podDeleteSelector</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">app=webapp</code><code class="s">"</code><code class="w"> </code><a class="co" href="#callout_controller_CO5-2" id="co_controller_CO5-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="nt">data</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">message</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">Welcome</code><code class="nv"> </code><code class="s">to</code><code class="nv"> </code><code class="s">Kubernetes</code><code class="nv"> </code><code class="s">Patterns</code><code class="nv"> </code><code class="s">!</code><code class="s">"</code><code class="w">      </code><a class="co" href="#callout_controller_CO5-3" id="co_controller_CO5-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="nn">---</code><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w">                                   </code><a class="co" href="#callout_controller_CO5-4" id="co_controller_CO5-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="c1"># ...</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="c1"># ...</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/mini-http-server</code><code class="w">        </code><a class="co" href="#callout_controller_CO5-5" id="co_controller_CO5-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">env</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MESSAGE</code><code class="w">                            </code><a class="co" href="#callout_controller_CO5-6" id="co_controller_CO5-6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webapp-config</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">message</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_controller_CO5-1" id="callout_controller_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>ConfigMap for holding the data to serve.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO5-2" id="callout_controller_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Annotation that triggers a restart of the web app’s Pod.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO5-3" id="callout_controller_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Message used in web app in HTTP responses.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO5-4" id="callout_controller_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Deployment for the web app.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO5-5" id="callout_controller_CO5-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Simplistic image for HTTP serving with netcat.</p></dd>&#13;
<dt><a class="co" href="#co_controller_CO5-6" id="callout_controller_CO5-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Environment variable used as an HTTP response body and fetched from the watched ConfigMap.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This concludes our example of our ConfigMap controller implemented in a plain shell script. Although this is probably the most complex example in this book, it also shows that it does not take much to write a basic controller.</p>&#13;
&#13;
<p>Obviously, for real-world scenarios, you would write this sort of controller in a real programming language that provides better error-handling capabilities and other advanced features.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902084257248">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>To sum up, a controller is an active reconciliation process that monitors objects of interest for the world’s desired state and the world’s actual state. Then, it sends instructions to try to change the world’s current state to be more like the desired state. Kubernetes uses this mechanism with its internal controllers, and you can also reuse the same mechanism with custom controllers. We demonstrated what is involved in writing a custom controller and how it functions and extends the Kubernetes platform.</p>&#13;
&#13;
<p>Controllers are possible because of the highly modular and event-driven nature of the Kubernetes architecture. This architecture naturally leads to a decoupled and asynchronous approach for controllers as extension points. The significant benefit here is that we have a precise technical boundary between Kubernetes itself and any extensions. However, one issue with the asynchronous nature of controllers is that they are often hard to debug because the flow of events is not always straightforward. As a consequence, you can’t easily set breakpoints in your controller to stop everything to examine a specific situation.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch28.html#Operator">Chapter 28</a>, you’ll learn about the related <em>Operator</em> pattern, which builds on this <em>Controller</em> pattern and provides an even more flexible way to configure operations.<a data-primary="" data-startref="cntrllr27" data-type="indexterm" id="idm45902083163776"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="controller-more-information">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/qQcZM">Controller Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/3yuBU">Writing Controllers</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/mY5Dc">Writing a Kubernetes Controller</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Qa2X4">A Deep Dive into Kubernetes Controllers</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Mq3GN">Expose Controller</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/bcTYK">Reloader: ConfigMap Controller</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/yZdL3">Writing a Custom Controller: Extending the Functionality of Your Cluster</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/0zM5X">Writing Kubernetes Custom Controllers</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/19xfy">Contour Ingress Controller</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/FTxze">Syntax and Character Set</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/_g75A">Kubectl-Proxy</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>