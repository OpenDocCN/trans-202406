<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Advanced Querying"><div class="chapter" id="CH5_ADV1">
<h1><span class="label">Chapter 5. </span>Advanced Querying</h1>


<p>Over the previous two chapters, you’ve completed an introduction to the basic features of querying and modifying databases with SQL. You should now be able to create, modify, and remove database structures, as well as work with data as you read, insert, delete, and update entries. Over this and the next two chapters, we’ll look at more advanced concepts and then will proceed to more administrative and operations-oriented content. You can skim these chapters and return to read them thoroughly when you’re comfortable using MySQL.</p>

<p>This chapter teaches you more about querying, giving you skills to answer complex information needs. You’ll learn how to do the following:</p>

<ul>
<li>
<p>Use nicknames, or <em>aliases</em>, in queries to save typing and allow a table to be used more than once in a query.</p>
</li>
<li>
<p>Aggregate data into groups so you can discover sums, averages, and counts.</p>
</li>
<li>
<p>Join tables in different ways.</p>
</li>
<li>
<p>Use nested queries.</p>
</li>
<li>
<p>Save query results in variables so they can be reused in other queries.</p>
</li>
</ul>






<section data-type="sect1" data-pdf-bookmark="Aliases"><div class="sect1" id="ADV1-SEC-ALIASES">
<h1>Aliases</h1>

<p>Aliases are nicknames. They give you a shorthand way of expressing a column, table, or function name, allowing you to:<a data-type="indexterm" data-primary="aliases" data-secondary="about" id="idm46177475438888"/></p>

<ul>
<li>
<p>Write shorter queries.</p>
</li>
<li>
<p>Express your queries more clearly.</p>
</li>
<li>
<p>Use one table in two or more ways in a single query.</p>
</li>
<li>
<p>Access data more easily from programs.</p>
</li>
<li>
<p>Use special types of nested queries, discussed in <a data-type="xref" href="#ADV1-SEC-NESTED">“Nested Queries”</a>.</p>
</li>
</ul>








<section data-type="sect2" data-pdf-bookmark="Column Aliases"><div class="sect2" id="ADV1-SEC-COLUMNALIASES">
<h2>Column Aliases</h2>

<p>Column aliases are useful for improving the expression of your<a data-type="indexterm" data-primary="aliases" data-secondary="column aliases" id="idm46177475430168"/><a data-type="indexterm" data-primary="columns" data-secondary="aliases" id="idm46177475429192"/><a data-type="indexterm" data-primary="queries" data-secondary="aliases" data-tertiary="column aliases" id="idm46177475428248"/> queries, reducing the number of characters you need to type, and making it easier to work with programming languages such as Python or PHP. Consider a simple, not-very-useful example:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">AS</code><code> </code><code class="s1">'First Name'</code><code class="p">,</code><code> </code><code class="n">last_name</code><code> </code><code class="k">AS</code><code> </code><code class="s1">'Last Name'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+--------------+
| First Name | Last Name    |
+------------+--------------+
| PENELOPE   | GUINESS      |
| NICK       | WAHLBERG     |
| ED         | CHASE        |
| JENNIFER   | DAVIS        |
| JOHNNY     | LOLLOBRIGIDA |
+------------+--------------+
5 rows in set (0.00 sec)</pre>

<p>The column <code>first_name</code> is aliased as <code>First Name</code>, and column <code>last_name</code> as <code>Last Name</code>. You can see that in the output, the usual column headings, <code>first_name</code> and <code>last_name</code>, are replaced by the aliases <code>First Name</code> and <code>Last Name</code>. The advantage is that the aliases might be more meaningful to users. In this case, at the very least, they are more human-readable. Other than that, it’s not very useful, but it does illustrate the idea that for a column, you add the keyword <code>AS</code> and then a string that represents what you’d like the column to be known as. Specifying the <code>AS</code> keyword is not required but makes things much clearer.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We’ll be using the <code>LIMIT</code> clause extensively throughout this chapter, as otherwise almost every output would be unwieldy and long. Sometimes we’ll mention that explicitly, sometimes not. You can experiment on your own by removing <code>LIMIT</code> from the queries we give. More information about the <code>LIMIT</code> clause can be found in <a data-type="xref" href="ch03.xhtml#BAS-SEC-LIMIT">“The LIMIT Clause”</a>.</p>
</div>

<p>Now let’s see column aliases doing something useful. Here’s an example that uses a MySQL function and an <code>ORDER BY</code> clause:<a data-type="indexterm" data-primary="ORDER BY" data-secondary="column aliases" id="idm46177475371400"/><a data-type="indexterm" data-primary="columns" data-secondary="aliases" data-tertiary="ORDER BY" id="idm46177475370552"/><a data-type="indexterm" data-primary="aliases" data-secondary="column aliases" data-tertiary="ORDER BY" id="idm46177475369464"/><a data-type="indexterm" data-primary="CONCAT()" id="idm46177475368376"/><a data-type="indexterm" data-primary="strings" data-secondary="CONCAT() in example query" id="idm46177475367768"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">CONCAT</code><code class="p">(</code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="s1">' '</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="s1">' played in '</code><code class="p">,</code><code> </code><code class="n">title</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">movie</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">movie</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting" class="less_space pagebreak-before">+--------------------------------------------+
| movie                                      |
+--------------------------------------------+
| ADAM GRANT played in ANNIE IDENTITY        |
| ADAM GRANT played in BALLROOM MOCKINGBIRD  |
| ...                                        |
| ADAM GRANT played in TWISTED PIRATES       |
| ADAM GRANT played in WANDA CHAMBER         |
| ADAM HOPPER played in BLINDNESS GUN        |
| ADAM HOPPER played in BLOOD ARGONAUTS      |
+--------------------------------------------+
20 rows in set (0.03 sec)</pre>

<p>The MySQL function <code>CONCAT()</code> <em>concatenates</em> the strings that are parameters—in this case, the <code>first_name</code>, a constant string with a space, the <code>last_name</code>, the constant string <code>played in</code>, and the <code>title</code>—to give output such as <code>ZERO CAGE played in CANYON STOCK</code>. We’ve added an alias to the function, <code>AS movie</code>, so that we can refer to it easily as <code>movie</code> throughout the query. You can see that we do this in the <code>ORDER BY</code> clause, where we ask MySQL to sort the output by ascending <code>movie</code> value. This is much better than the unaliased alternative, which requires you to write out the <code>CONCAT()</code> function again:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">CONCAT</code><code class="p">(</code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="s1">' '</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="s1">' played in '</code><code class="p">,</code><code> </code><code class="n">title</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">movie</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="nf">CONCAT</code><code class="p">(</code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="s1">' '</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="s1">' played in '</code><code class="p">,</code><code> </code><code class="n">title</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------------------------------------+
| movie                                      |
+--------------------------------------------+
| ADAM GRANT played in ANNIE IDENTITY        |
| ADAM GRANT played in BALLROOM MOCKINGBIRD  |
| ...                                        |
| ADAM GRANT played in TWISTED PIRATES       |
| ADAM GRANT played in WANDA CHAMBER         |
| ADAM HOPPER played in BLINDNESS GUN        |
| ADAM HOPPER played in BLOOD ARGONAUTS      |
+--------------------------------------------+
20 rows in set (0.03 sec)</pre>

<p>The alternative is unwieldy, and worse, you risk mistyping some part of the <code>ORDER BY</code> clause and getting a result different from what you expect. (Note that we’ve used <code>AS movie</code> on the first line so that the displayed column has the label <code>movie</code>.)</p>

<p>There are restrictions on where you can use column aliases.<a data-type="indexterm" data-primary="aliases" data-secondary="column aliases" data-tertiary="when can’t use" id="idm46177475211496"/><a data-type="indexterm" data-primary="columns" data-secondary="aliases" data-tertiary="when can’t use" id="idm46177475210248"/> You can’t use them in a <code>WHERE</code> clause, or in the <code>USING</code> and <code>ON</code> clauses that we discuss later in this chapter. This means you can’t write a query like this:</p>

<pre data-type="programlisting" data-code-language="mysql" class="less_space pagebreak-before"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">AS</code><code> </code><code class="n">name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'ZERO CAGE'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">ERROR 1054 (42S22): Unknown column 'name' in 'where clause'</pre>

<p>You can’t do that because MySQL doesn’t always know the column values before it executes the <code>WHERE</code> clause. However, you can use column aliases in the <code>ORDER BY</code> clause, and in the <code>GROUP BY</code> and <code>HAVING</code> clauses discussed later in this chapter.</p>

<p>The <code>AS</code> keyword is optional, as we’ve mentioned. Because of this, the following two queries are equivalent:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">actor_id</code><code> </code><code class="k">AS</code><code> </code><code class="n">id</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">first_name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'ZERO'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+
| id |
+----+
| 11 |
+----+
1 row in set (0.00 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">actor_id</code><code> </code><code class="n">id</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">first_name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'ZERO'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+
| id |
+----+
| 11 |
+----+
1 row in set (0.00 sec)</pre>

<p>We recommend using the <code>AS</code> keyword, since it helps to clearly distinguish an aliased column, especially where you’re selecting multiple columns from a list of columns separated by commas.</p>

<p>Alias names have a few restrictions. They <a data-type="indexterm" data-primary="names" data-secondary="aliases" id="idm46177475064936"/><a data-type="indexterm" data-primary="aliases" data-secondary="about" data-tertiary="names" id="idm46177475063960"/>can be at most 255 characters in length and can contain any character. Aliases don’t always need to be quoted, and they follow the same rules as table and column names do, which we described in <a data-type="xref" href="ch04.xhtml#CH4_MODIFY">Chapter 4</a>. If an alias is a single word and doesn’t include special symbols—like a dash, a plus sign, or a space, for example—and is not a keyword, like <code>USE</code>, then you don’t need to put quotes around it. Otherwise, you need to quote the alias, which you can do using double quotes, single quotes, or backticks. We recommend using lowercase alphanumeric strings for alias names and using a consistent character choice—such as an underscore—to separate words. <a data-type="indexterm" data-primary="case sensitivity" data-secondary="aliases" id="idm46177475060744"/>Aliases are case-insensitive on all platforms.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Table Aliases"><div class="sect2" id="ADV1-SEC-TABLEALIASES">
<h2>Table Aliases</h2>

<p>Table aliases are useful for the same reasons as column<a data-type="indexterm" data-primary="aliases" data-secondary="table aliases" id="idm46177475045320"/><a data-type="indexterm" data-primary="tables" data-secondary="aliases" id="idm46177475044472"/><a data-type="indexterm" data-primary="queries" data-secondary="aliases" data-tertiary="table aliases" id="idm46177475043624"/><a data-type="indexterm" data-primary="tables" data-secondary="names" data-tertiary="aliases" id="idm46177475042536"/> aliases, but they are also sometimes the only way to express a query. This section shows you how to use table aliases, and <a data-type="xref" href="#ADV1-SEC-NESTED">“Nested Queries”</a> shows you some other sample queries where table aliases are essential.</p>

<p class="pagebreak-before">Here’s a basic table alias example that shows you how to save some typing:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">ac</code><code class="p">.</code><code class="n">actor_id</code><code class="p">,</code><code> </code><code class="n">ac</code><code class="p">.</code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">ac</code><code class="p">.</code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">fl</code><code class="p">.</code><code class="n">title</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor</code><code> </code><code class="k">AS</code><code> </code><code class="n">ac</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">AS</code><code> </code><code class="n">fla</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">AS</code><code> </code><code class="n">fl</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">fl</code><code class="p">.</code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'AFFAIR PREJUDICE'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------+------------+-----------+------------------+
| actor_id | first_name | last_name | title            |
+----------+------------+-----------+------------------+
|       41 | JODIE      | DEGENERES | AFFAIR PREJUDICE |
|       81 | SCARLETT   | DAMON     | AFFAIR PREJUDICE |
|       88 | KENNETH    | PESCI     | AFFAIR PREJUDICE |
|      147 | FAY        | WINSLET   | AFFAIR PREJUDICE |
|      162 | OPRAH      | KILMER    | AFFAIR PREJUDICE |
+----------+------------+-----------+------------------+
5 rows in set (0.00 sec)</pre>

<p>You can see that the <code>film</code> and <code>actor</code> tables are aliased as <code>fl</code> and <code>ac</code>, respectively, using the <code>AS</code> keyword. This allows you to express column names more compactly, such as <code>fl.title</code>. <a data-type="indexterm" data-primary="tables" data-secondary="aliases" data-tertiary="no use restrictions" id="idm46177474976024"/><a data-type="indexterm" data-primary="names" data-secondary="tables" data-tertiary="aliases" id="idm46177474974744"/>Notice also that you can use table aliases in the <code>WHERE</code> clause; unlike column aliases, there are no restrictions on where table aliases can be used in queries. From our example, you can see that we’re referring to the table aliases in <code>SELECT</code> before they have been defined in <code>FROM</code>. <a data-type="indexterm" data-primary="names" data-secondary="aliases" data-tertiary="tables" id="idm46177474971992"/><a data-type="indexterm" data-primary="tables" data-secondary="aliases" data-tertiary="if used, must use" id="idm46177474970712"/>There is, however, a catch with table aliases: if an alias has been used for a table, it’s impossible to refer to that table without using its new alias. For example, the following statement will error out, as it would if we’d mentioned <code>film</code> in the <code>SELECT</code> clause:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">ac</code><code class="p">.</code><code class="n">actor_id</code><code class="p">,</code><code> </code><code class="n">ac</code><code class="p">.</code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">ac</code><code class="p">.</code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">fl</code><code class="p">.</code><code class="n">title</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor</code><code> </code><code class="k">AS</code><code> </code><code class="n">ac</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">AS</code><code> </code><code class="n">fla</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">AS</code><code> </code><code class="n">fl</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film</code><code class="p">.</code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'AFFAIR PREJUDICE'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">ERROR 1054 (42S22): Unknown column 'film.title' in 'where clause'</pre>

<p>As with column aliases, the <code>AS</code> keyword is optional. This means that:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">actor</code> <code class="k">AS</code> <code class="n">ac</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">film_actor</code> <code class="k">AS</code> <code class="n">fla</code></pre>

<p>is the same as</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">actor</code> <code class="n">ac</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">film_actor</code> <code class="n">fla</code></pre>

<p>Again, we prefer the <code>AS</code> style because it’s clearer to anyone looking at your queries than the alternative. The length and content restrictions on table aliases names are the same as for column aliases, and our recommendations on choosing them are the same, too.</p>

<p>As discussed in the introduction to this section, table aliases allow you to write queries that you can’t otherwise easily express. Consider an example: suppose you want to know whether two or more films in our collection have the same title, and if so, what those films are. Let’s think about the basic requirement: you want to know if two movies have the same name. To do get that, you might try a query like this:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="n">title</code><code class="p">;</code></strong></pre>

<p>But that doesn’t make sense—every film has the same title as itself, so the query just produces all films as output:</p>

<pre data-type="programlisting">+---------+------------------...
| film_id | title            ...
+---------+------------------...
|       1 | ACADEMY DINOSAUR ...
|       2 | ACE GOLDFINGER   ...
|       3 | ADAPTATION HOLES ...
|     ...                    ...
|    1000 | ZORRO ARK        ...
+---------+------------------...
1000 rows in set (0.01 sec)</pre>

<p>What you really want is to know whether two different films from the <code>film</code> table have the same name. But how can you do that in a single query? The answer is to give the table two different aliases; you then check to see whether one row in the first aliased table matches a row in the second:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">m1</code><code class="p">.</code><code class="n">film_id</code><code class="p">,</code><code> </code><code class="n">m2</code><code class="p">.</code><code class="n">title</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">AS</code><code> </code><code class="n">m1</code><code class="p">,</code><code> </code><code class="n">film</code><code> </code><code class="k">AS</code><code> </code><code class="n">m2</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">m1</code><code class="p">.</code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="n">m2</code><code class="p">.</code><code class="n">title</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---------+-------------------+
| film_id | title             |
+---------+-------------------+
|       1 | ACADEMY DINOSAUR  |
|       2 | ACE GOLDFINGER    |
|       3 | ADAPTATION HOLES  |
|     ...                     |
|    1000 | ZORRO ARK         |
+---------+-------------------+
1000 rows in set (0.02 sec)</pre>

<p>But it still doesn’t work! We get all 1,000 movies as answers. The reason is that again, each film matches itself because it occurs in both aliased tables.</p>

<p>To get the query to work, we need to make sure a movie from one aliased table doesn’t match itself in the other aliased table. The way to do that is to specify that the movies in each table shouldn’t have the same ID:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">m1</code><code class="p">.</code><code class="n">film_id</code><code class="p">,</code><code> </code><code class="n">m2</code><code class="p">.</code><code class="n">title</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">AS</code><code> </code><code class="n">m1</code><code class="p">,</code><code> </code><code class="n">film</code><code> </code><code class="k">AS</code><code> </code><code class="n">m2</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">m1</code><code class="p">.</code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="n">m2</code><code class="p">.</code><code class="n">title</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">m1</code><code class="p">.</code><code class="n">film_id</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="n">m2</code><code class="p">.</code><code class="n">film_id</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Empty set (0.00 sec)</pre>

<p>You can now see that there aren’t two films in the database with the same name. The additional <code>AND m1.film_id != m2.film_id</code> stops answers from being reported where the movie ID is the same in both tables.</p>

<p>Table aliases are also useful in nested queries that use the <code>EXISTS</code> and <code>ON</code> clauses. We’ll show you examples later in this chapter when we introduce nested queries.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Aggregating Data"><div class="sect1" id="ADV1-SEC-AGGREGATE">
<h1>Aggregating Data</h1>

<p>Aggregate functions allow you to discover the properties of a<a data-type="indexterm" data-primary="aggregating data" data-secondary="about" id="idm46177474631576"/><a data-type="indexterm" data-primary="rows" data-secondary="aggregating data" id="idm46177474630600"/> group of rows. You use them for purposes such as finding out how many rows there are in a table, how many rows in a table share a property (such as having the same name or date of birth), finding averages (such as the average temperature in November), or finding the maximum or minimum values of rows that meet some condition (such as finding the coldest day in August).</p>

<p>This section explains the <code>GROUP BY</code> and <code>HAVING</code> clauses, the two most commonly used SQL statements for aggregation. But first it explains the <code>DISTINCT</code> clause, which is used to report unique results for the output of a query. When neither the <code>DISTINCT</code> nor the <code>GROUP BY</code> clause is specified, the returned raw data can still be processed using the aggregate functions that we describe in this section.</p>








<section data-type="sect2" data-pdf-bookmark="The DISTINCT Clause"><div class="sect2" id="ADV1-SEC-DISTINCT">
<h2>The DISTINCT Clause</h2>

<p>To begin our discussion of aggregate functions, we’ll focus on<a data-type="indexterm" data-primary="aggregating data" data-secondary="DISTINCT clause" id="idm46177474592376"/><a data-type="indexterm" data-primary="DISTINCT clause" id="idm46177474591528"/><a data-type="indexterm" data-primary="queries" data-secondary="aggregating data" data-see="aggregating data" id="idm46177474590920"/> the <code>DISTINCT</code> clause. This isn’t really an aggregate function, but more of a post-processing filter that allows you to remove duplicates. We’ve added it into this section because, like aggregate functions, it’s concerned with picking examples from the output of a query, rather than processing individual rows.</p>

<p>An example is the best way to understand <code>DISTINCT</code>. Consider this query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="k">DISTINCT</code><code> </code><code class="n">first_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-------------+
| first_name  |
+-------------+
| PENELOPE    |
| NICK        |
| ...         |
| GREGORY     |
| JOHN        |
| BELA        |
| THORA       |
+-------------+
128 rows in set (0.00 sec)</pre>

<p>The query finds all first names of all the actors listed in our database that have participated in a film and reports one example of each name. If you remove the <code>DISTINCT</code> clause, you get one row of output for each role in every film we have in our database, or 5,462 rows. That’s a lot of output, so we’re limiting it to five rows, but you can spot the difference immediately with names being repeated:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+
| first_name |
+------------+
| PENELOPE   |
| PENELOPE   |
| PENELOPE   |
| PENELOPE   |
| PENELOPE   |
+------------+
5 rows in set (0.00 sec)</pre>

<p>So, the <code>DISTINCT</code> clause helps you get a summary.</p>

<p>The <code>DISTINCT</code> clause applies to the query output and removes rows that have identical values in the columns selected for output in the query. If you rephrase the previous query to output both <code>first_name</code> and <code>last_name</code> (but otherwise don’t change the <code>JOIN</code> clause and still use <code>DISTINCT</code>), you’ll get 199 rows in the output (that’s why we use last names):</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="k">DISTINCT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-------------+--------------+
| first_name  | last_name    |
+-------------+--------------+
| PENELOPE    | GUINESS      |
| NICK        | WAHLBERG     |
| ...                        |
| JULIA       | FAWCETT      |
| THORA       | TEMPLE       |
+-------------+--------------+
199 rows in set (0.00 sec)</pre>

<p>Unfortunately, people’s names even when last names are added still make for a bad unique key. There are 200 rows in the <code>actor</code> table in the <code>sakila</code> database, and we’re missing one of them. You should remember this issue, as using <code>DISTINCT</code> indiscriminately may result in incorrect query results.</p>

<p>To remove duplicates, MySQL needs to sort the output. <a data-type="indexterm" data-primary="performance" data-secondary="DISTINCT clause on large datasets" id="idm46177474461144"/>If indexes are available that are in the same order as required for the sort, or the data itself is in an order that’s useful, this process has very little overhead. However, for large tables and without an easy way of accessing the data in the right order, sorting can be very slow. You should use <code>DISTINCT</code> (and other aggregate functions) with caution on large datasets. If you do use it, you can check its behavior using the <code>EXPLAIN</code> statement discussed in 
<span class="keep-together"><a data-type="xref" href="ch07.xhtml#CH7_DOING_MORE">Chapter 7</a>.</span></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The GROUP BY Clause"><div class="sect2" id="ADV1-SEC-GROUPBY">
<h2>The GROUP BY Clause</h2>

<p>The <code>GROUP BY</code> clause groups output data for the purpose of<a data-type="indexterm" data-primary="aggregating data" data-secondary="GROUP BY clause" id="ch05-gb"/><a data-type="indexterm" data-primary="GROUP BY clause" id="ch05-gb2"/> aggregation. Particularly, that allows us to use aggregate functions (covered in <a data-type="xref" href="#ADV1-AGGREGATE-FUNCTIONS">“Aggregate functions”</a>) on our data when our projection (that is, the contents of the <code>SELECT</code> clause) contains columns other than those within an aggregate function. <code>GROUP BY</code> is similar to <code>ORDER BY</code> in that it takes a list of columns as an argument. However, these clauses are evaluated at different times and are only similar in how they look, not how they 
<span class="keep-together">operate.</span></p>

<p>Let’s take a look at a few <code>GROUP BY</code> examples that will demonstrate what it can be used for. In its most basic form, when we list every column we <code>SELECT</code> in <code>GROUP BY</code>, we end up with a <code>DISTINCT</code> equivalent. We’ve already established that a first name is not a unique identifier for an actor:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">first_name</code><code> </code><code class="k">IN</code><code> </code><code class="p">(</code><code class="s1">'GENE'</code><code class="p">,</code><code> </code><code class="s1">'MERYL'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+
| first_name |
+------------+
| GENE       |
| GENE       |
| MERYL      |
| GENE       |
| MERYL      |
+------------+
5 rows in set (0.00 sec)</pre>

<p>We can tell MySQL to group the output by a given column to get rid of duplicates. In this case, we’ve selected only one column, so let’s use that:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">first_name</code><code> </code><code class="k">IN</code><code> </code><code class="p">(</code><code class="s1">'GENE'</code><code class="p">,</code><code> </code><code class="s1">'MERYL'</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">first_name</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+
| first_name |
+------------+
| GENE       |
| MERYL      |
+------------+
2 rows in set (0.00 sec)</pre>

<p>You can see that the original five rows were folded—or, more accurately, grouped—into just two resulting rows. That’s not very helpful, as <code>DISTINCT</code> could do the same. It’s worth mentioning, however, that this is not always going to be the case. <code>DISTINCT</code> and <code>GROUP BY</code> are evaluated and executed at different stages of query execution, so you should not confuse them, even if sometimes the effects are similar.</p>

<p>According to the SQL standard, every column projected in the<a data-type="indexterm" data-primary="SELECT" data-secondary="columns chosen" data-tertiary="GROUP BY clause" id="idm46177474352136"/> <code>SELECT</code> clause that is not part of an aggregate function should be listed in the <code>GROUP BY</code> clause. The only time this rule may be violated is when the resulting groups have only one row each. If you think about it, that’s logical: if you select <code>first_name</code> and <code>last_name</code> from the <code>actor</code> table and group only by <code>first_name</code>, how should the database behave? It cannot output more than one row with the same first name, as that goes against the grouping rules, but there may be more than one last name for a given first name.</p>

<p>For a long time, MySQL extended the standard by allowing you to <code>GROUP BY</code> based on fewer columns than defined in <code>SELECT</code>. What did it do with the extra columns? Well, it output some value in a nondeterministic way. For example, when you grouped by first name but not by the last name, you could get either of the two rows <code>GENE, WILLIS</code> and <code>GENE, HOPKINS</code>. That’s a nonstandard and dangerous behavior. Imagine that for a year you got <code>Hopkins</code>, as if the results were ordered alphabetically, and came to rely on that—but then the table was reorganized, and the order changed. We firmly believe that the SQL standard is correct to limit such behaviors, to avoid 
<span class="keep-together">unpredictability.</span></p>

<p>Note also that while every column in the <code>SELECT</code> must be used either in <code>GROUP BY</code> or in an aggregate function, you can <code>GROUP BY</code> columns that are not part of the <code>SELECT</code>. You’ll see some examples of that later.</p>

<p>Now let’s construct a more useful example. An actor usually takes part in many films throughout their career. We may want to find out just how many films a particular actor has played in, or do a calculation for each actor we know of and get a rating by productivity. To start, we can use the techniques we’ve learned so far and perform an <code>INNER JOIN</code> between the <code>actor</code> and <code>film_actor</code> tables. We don’t need the <code>film</code> table as we’re not looking for any details on the films themselves. We can then order the output by actor’s name, making it easier to count what we want:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">film_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+---------+
| first_name | last_name | film_id |
+------------+-----------+---------+
| ADAM       | GRANT     |      26 |
| ADAM       | GRANT     |      52 |
| ADAM       | GRANT     |     233 |
| ADAM       | GRANT     |     317 |
| ADAM       | GRANT     |     359 |
| ADAM       | GRANT     |     362 |
| ADAM       | GRANT     |     385 |
| ADAM       | GRANT     |     399 |
| ADAM       | GRANT     |     450 |
| ADAM       | GRANT     |     532 |
| ADAM       | GRANT     |     560 |
| ADAM       | GRANT     |     574 |
| ADAM       | GRANT     |     638 |
| ADAM       | GRANT     |     773 |
| ADAM       | GRANT     |     833 |
| ADAM       | GRANT     |     874 |
| ADAM       | GRANT     |     918 |
| ADAM       | GRANT     |     956 |
| ADAM       | HOPPER    |      81 |
| ADAM       | HOPPER    |      82 |
+------------+-----------+---------+
20 rows in set (0.01 sec)</pre>

<p>By running down the list, it’s easy to count off how many films we’ve got for each actor, or at least for Adam Grant. Without a <code>LIMIT</code>, however, the query would return 5,462 distinct rows, and calculating our counts manually would take a lot of time. The <code>GROUP BY</code> clause can help automate this process by grouping the movies by actor; we can then use the <code>COUNT()</code> function to count off the number of films in each group. Finally, we can use <code>ORDER BY</code> and <code>LIMIT</code> to get the top 10 actors by the number of films they’ve appeared in. Here’s the query that does what we want:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">num_films</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">num_films</code><code> </code><code class="k">DESC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-------------+-----------+
| first_name | last_name   | num_films |
+------------+-------------+-----------+
| SUSAN      | DAVIS       |        54 |
| GINA       | DEGENERES   |        42 |
| WALTER     | TORN        |        41 |
| MARY       | KEITEL      |        40 |
| MATTHEW    | CARREY      |        39 |
| SANDRA     | KILMER      |        37 |
| SCARLETT   | DAMON       |        36 |
| VAL        | BOLGER      |        35 |
| ANGELA     | WITHERSPOON |        35 |
| UMA        | WOOD        |        35 |
+------------+-------------+-----------+
10 rows in set (0.01 sec)</pre>

<p>You can see that the output we’ve asked for is <code>first_name, last_name, COUNT(film_id) as num_films</code>, and this tells us exactly what we wanted to know. We group our data by the <code>first_name</code> and <code>last_name</code> columns, running the <code>COUNT()</code> aggregate function in the process. For each “bucket” of rows we got in the previous query, we now get only a single row, albeit giving the information we want. Notice how we’ve combined <code>GROUP BY</code> and <code>ORDER BY</code> to get the ordering we wanted: by the number of films, from more to fewer. <code>GROUP BY</code> doesn’t guarantee ordering, only grouping. Finally, we <code>LIMIT</code> the output to 10 rows representing our most productive actors, as otherwise we’d get 199 rows of output.</p>

<p>Let’s consider the query further. We’ll start with the <code>GROUP BY</code> clause. This tells us how to put rows together into groups: in this example, we’re telling MySQL that the way to group rows is by <code>first_name, last_name</code>. The result is that rows for actors with the same name form a cluster, or bucket—that is, each distinct name becomes one group. Once the rows are grouped, they’re treated in the rest of the query as if they’re one row. So, for example, when we write <code>SELECT first_name, last_name</code>, we get just one row for each group. This is exactly the same as <code>DISTINCT</code>, as we’ve already discussed. <a data-type="indexterm" data-primary="aggregating data" data-secondary="aggregate functions" data-tertiary="COUNT()" id="idm46177474202008"/><a data-type="indexterm" data-primary="COUNT()" data-secondary="GROUP BY clause" id="idm46177474200872"/><a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="aggregate functions" data-tertiary="COUNT()" id="idm46177474168920"/>The <code>COUNT()</code> function tells us about the properties of the group. More specifically, it tells us the number of rows that form each group; you can count any column in a group and you’ll get the same answer, so <code>COUNT(film_id)</code> is almost always the same as <code>COUNT(*)</code> or <code>COUNT(first_name)</code>. (See <a data-type="xref" href="#ADV1-AGGREGATE-FUNCTIONS">“Aggregate functions”</a> for more details on why we say <em>almost</em>.) We could also just do <code>COUNT(1)</code>, or in fact specify any literal. Think of this as doing <code>SELECT 1</code> from a table and then counting the results. A value of 1 will be output for each row in the table, and <code>COUNT()</code> does the counting. <a data-type="indexterm" data-primary="COUNT()" data-secondary="COUNT(NULL)" id="idm46177474163560"/><a data-type="indexterm" data-primary="NULL" data-secondary="COUNT()" data-tertiary="COUNT(NULL)" id="idm46177474162712"/><a data-type="indexterm" data-primary="zero (0)" data-secondary="COUNT(NULL)" id="idm46177474161624"/>One exception is <code>NULL</code>: while it’s perfectly acceptable and legal to specify <code>COUNT(NULL)</code>, the result will always be zero, as <code>COUNT()</code> discards <code>NULL</code> values. Of course, you can use a column alias for the <code>COUNT()</code> column.</p>

<p>Let’s try another example. Suppose you want to know how many different actors played in each movie, along with the film name and its category, and get the five films with the largest crews. Here’s the query:<a data-type="indexterm" data-primary="INNER JOIN" data-secondary="GROUP BY with" id="idm46177474203848"/><a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="INNER JOIN with" id="idm46177474157784"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">name</code><code> </code><code class="k">AS</code><code> </code><code class="n">category_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">film_id</code><code class="p">,</code><code> </code><code class="n">category_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">cnt</code><code> </code><code class="k">DESC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------------+---------------+-----+
| title            | category_name | cnt |
+------------------+---------------+-----+
| LAMBS CINCINATTI | Games         |  15 |
| CRAZY HOME       | Comedy        |  13 |
| CHITTY LOCK      | Drama         |  13 |
| RANDOM GO        | Sci-Fi        |  13 |
| DRACULA CRYSTAL  | Classics      |  13 |
+------------------+---------------+-----+
5 rows in set (0.03 sec)</pre>

<p>Before we discuss what’s new, think about the general function of the query. We join four tables together with <code>INNER JOIN</code> using their identifier columns: <code>film</code>, <code>film_actor</code>, <code>film_category</code>, and <code>category</code>. Forgetting the aggregation for a moment, the output of this query is one row per combination of movie and actor.</p>

<p>The <code>GROUP BY</code> clause puts the rows together into clusters. In this query, we want the films grouped together with their categories. The <code>GROUP BY</code> clause uses <code>film_id</code> and <code>category_id</code> to do that. You can use the <code>film_id</code> column from any of the three tables; <code>film.film_id</code>, <code>film_actor.film_id</code>, and <code>film_category.film_id</code> are the same for this purpose. It doesn’t matter which one you use; the <code>INNER JOIN</code> makes sure they match anyway. The same applies to <code>category_id</code>.</p>

<p>As mentioned earlier, even though it’s required to list every non-aggregated column in <code>GROUP BY</code>, you can <code>GROUP BY</code> on columns outside of the <code>SELECT</code>. In the previous example query, we’re using the <code>COUNT()</code> function to tell us how many rows are in each group. For example, you can see that <code>COUNT(*)</code> tells us that there are 13 actors in the comedy <em>CRAZY HOME</em>. Again, it doesn’t matter what column or columns you count in the query: for example, <code>COUNT(*)</code> has the same effect as <code>COUNT(film.film_id)</code> or <code>COUNT(category.name)</code>.</p>

<p>We’re then ordering the output by the <code>COUNT(*)</code> column aliased <code>cnt</code> in descending order and picking the first five rows. Note how there are multiple rows with <code>cnt</code> equal to 13. In fact, there are even more of those—six in all—in the database, making this ordering a bit unfair, as movies having the same number of actors will be sorted randomly. You can add another column to the <code>ORDER BY</code> clause, like <code>title</code>, to make sorting more predictable.</p>

<p>Let’s try another example. The <code>sakila</code> database isn’t only about movies and actors: it’s based on movie rentals, after all. We have, among other things, customer information, including data on what films they rented. Say we want to know which customers tend to rent movies from the same category. For example, we might want to adjust our ads based on whether a person likes different film categories or sticks to a single one most of the time. We need to carefully think about our grouping: we don’t want to group by movie, as that would just give us the number of times a customer rented it. The resulting query is quite complex, although it’s still based around <code>INNER JOIN</code> and <code>GROUP BY</code>:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">email</code><code class="p">,</code><code> </code><code class="n">name</code><code> </code><code class="k">AS</code><code> </code><code class="n">category_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">customer</code><code> </code><code class="n">cs</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">category</code><code> </code><code class="n">cat</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="mi">1</code><code class="p">,</code><code> </code><code class="mi">2</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="mi">3</code><code> </code><code class="k">DESC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------------------------------+---------------+-----+
| email                            | category_name | cnt |
+----------------------------------+---------------+-----+
| WESLEY.BULL@sakilacustomer.org   | Games         |   9 |
| ALMA.AUSTIN@sakilacustomer.org   | Animation     |   8 |
| KARL.SEAL@sakilacustomer.org     | Animation     |   8 |
| LYDIA.BURKE@sakilacustomer.org   | Documentary   |   8 |
| NATHAN.RUNYON@sakilacustomer.org | Animation     |   7 |
+----------------------------------+---------------+-----+
5 rows in set (0.08 sec)</pre>

<p>These customers repeatedly rent films from the same category. What we don’t know is if any of them have rented the same movie multiple times, or if those were all different movies within a category. The <code>GROUP BY</code> clause hides the details. Again, we use <code>COUNT(*)</code> to do the counting of rows in the groups, and you can see the <code>INNER JOIN</code> spread over lines 2 to 5 in the query.</p>

<p>The interesting thing about this query is that we didn’t explicitly specify column names for the <code>GROUP BY</code> or <code>ORDER BY</code> clauses. Instead, we used the columns’ position numbers (counted from 1) as they appear in the <code>SELECT</code> clause. This technique saves on typing but can be problematic if you later decide to add another column in the <code>SELECT</code>, which would break the ordering.</p>

<p>As with <code>DISTINCT</code>, there’s a danger with <code>GROUP BY</code> that we should mention. Consider the following query:<a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="caution on duplicates" id="idm46177473939000"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------+
| COUNT(*) |
+----------+
|        1 |
|        1 |
|      ... |
|        1 |
|        1 |
+----------+
199 rows in set (0.00 sec)</pre>

<p>It looks simple enough, and it produces the number of times a combination of a given first name and last name was found in the <code>actor</code> table. You might assume that it just outputs 199 rows of the digit <code>1</code>. However, if we do a <code>COUNT(*)</code> on the <code>actor</code> table, we get 200 rows. What’s the catch? Apparently, two actors have the same first name and last name. These things happen, and you have to be mindful of them. When you group based on columns that do not form a unique identifier, you may accidentally group together unrelated rows, resulting in misleading data. To find the duplicates, we can modify a query that we constructed in <a data-type="xref" href="#ADV1-SEC-TABLEALIASES">“Table Aliases”</a> to look for films with the same name:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">a1</code><code class="p">.</code><code class="n">actor_id</code><code class="p">,</code><code> </code><code class="n">a1</code><code class="p">.</code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">a1</code><code class="p">.</code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">AS</code><code> </code><code class="n">a1</code><code class="p">,</code><code> </code><code class="n">actor</code><code> </code><code class="k">AS</code><code> </code><code class="n">a2</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">a1</code><code class="p">.</code><code class="n">first_name</code><code> </code><code class="o">=</code><code> </code><code class="n">a2</code><code class="p">.</code><code class="n">first_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">a1</code><code class="p">.</code><code class="n">last_name</code><code> </code><code class="o">=</code><code> </code><code class="n">a2</code><code class="p">.</code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">a1</code><code class="p">.</code><code class="n">actor_id</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="n">a2</code><code class="p">.</code><code class="n">actor_id</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------+------------+-----------+
| actor_id | first_name | last_name |
+----------+------------+-----------+
|      101 | SUSAN      | DAVIS     |
|      110 | SUSAN      | DAVIS     |
+----------+------------+-----------+
2 rows in set (0.00 sec)</pre>

<p>Before we end this section, let’s again touch on how MySQL<a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="MySQL evolution" id="idm46177473780248"/><a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="ONLY_FULL_GROUP_BY" id="idm46177473793928"/><a data-type="indexterm" data-primary="ONLY_FULL_GROUP_BY" id="idm46177473793080"/><a data-type="indexterm" data-primary="portability" data-secondary="GROUP_BY evolution" id="idm46177473792472"/> extends the SQL standard around the <code>GROUP BY</code> clause. Before MySQL 5.7, it was possible by default to specify an incomplete column list in the <code>GROUP BY</code> clause, and, as we’ve explained, that resulted in a random rows being output within groups for non-grouped dependent columns. For reasons of supporting legacy software, both MySQL 5.7 and My SQL 8.0 continue providing this behavior, though it has to be explicitly enabled. The behavior is controlled by the <code>ONLY_FULL_GROUP_BY</code> SQL mode, which is set by default. If you find yourself in a situation where you need to port a program that relies on the legacy <code>GROUP BY</code> behavior, we recommend that you do not resort to changing the SQL mode. There are generally two ways to handle this problem. The first is to understand whether the query logic requires incomplete grouping at all—that is rarely the case. The second is to support the random data behavior for non-grouped columns by using either an aggregate function like <code>MIN()</code> or <code>MAX()</code> or the special <code>ANY_VALUE()</code> aggregate function, which, unsurprisingly, just produces a random value from within a group. We’ll look more closely at aggregate functions next.</p>










<section data-type="sect3" data-pdf-bookmark="Aggregate functions"><div class="sect3" id="ADV1-AGGREGATE-FUNCTIONS">
<h3>Aggregate functions</h3>

<p>We’ve seen examples of how the <code>COUNT()</code> function can be<a data-type="indexterm" data-primary="COUNT()" id="idm46177473748072"/> used to tell how many rows are in a group. Here we will cover some other functions commonly used to explore the properties of aggregated rows. We’ll also expand a bit on <code>COUNT()</code> as it’s used 
<span class="keep-together">frequently:</span></p>
<dl>
<dt><code>COUNT()</code></dt>
<dd>
<p>Returns the number of rows <em>or</em> the number of values in a<a data-type="indexterm" data-primary="COUNT()" data-secondary="NULL value in row" id="idm46177473743416"/><a data-type="indexterm" data-primary="NULL" data-secondary="COUNT()" data-tertiary="NULL value in row" id="idm46177473742568"/> column. Remember we mentioned that <code>COUNT(*)</code> is <em>almost</em> always the equivalent of <code>COUNT</code><code><em>(&lt;column&gt;)</em></code>. The problem is <code>NULL</code>. <code>COUNT(*)</code> will do a count of rows returned, regardless of whether the column in those rows is <code>NULL</code> or not. However, when you do a <code>COUNT</code><code><em>(&lt;column&gt;)</em></code>, only non-<code>NULL</code> values will be counted. For example, in the <code>sakila</code> database, a customer’s email address may be <code>NULL</code>, and we can observe the impact:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">customer</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------+
| count(*) |
+----------+
|      599 |
+----------+
1 row in set (0.00 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">email</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">customer</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------+
| count(email) |
+--------------+
|          598 |
+--------------+
1 row in set (0.00 sec)</pre>

<p>We should also add that <code>COUNT()</code> can be run with an internal<a data-type="indexterm" data-primary="DISTINCT clause" data-secondary="COUNT()" id="idm46177473692152"/><a data-type="indexterm" data-primary="COUNT()" data-secondary="DISTINCT clause" id="idm46177473691176"/> <code>DISTINCT</code> clause, as in <code>COUNT(DISTINCT</code> <code><em>&lt;column&gt;</em>)</code>, and will return the number of distinct values instead of all values in this case.</p>
</dd>
<dt><code>AVG()</code></dt>
<dd>
<p>Returns the average (mean) of the values in the specified<a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="aggregate functions" data-tertiary="AVG()" id="idm46177473687288"/><a data-type="indexterm" data-primary="aggregating data" data-secondary="aggregate functions" data-tertiary="AVG()" id="idm46177473686040"/><a data-type="indexterm" data-primary="AVG()" id="idm46177473664936"/><a data-type="indexterm" data-primary="mean via AVG()" id="idm46177473664328"/> column for all rows in a group. For example, you could use it to find the average cost of a house in a city, when the houses are grouped by city:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="k">SELECT</code> <code class="nf">AVG</code><code class="p">(</code><code class="n">cost</code><code class="p">)</code> <code class="k">FROM</code> <code class="n">house_prices</code> <code class="k">GROUP</code> <code class="k">BY</code> <code class="n">city</code><code class="p">;</code></pre>
</dd>
<dt><code>MAX()</code></dt>
<dd>
<p>Returns the maximum value from rows in a group. For example,<a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="aggregate functions" data-tertiary="MAX()" id="idm46177473655320"/><a data-type="indexterm" data-primary="aggregating data" data-secondary="aggregate functions" data-tertiary="MAX()" id="idm46177473654072"/><a data-type="indexterm" data-primary="MAX()" id="idm46177473652856"/> you could use it to find the warmest day in a month, when the rows are grouped by month.</p>
</dd>
<dt><code>MIN()</code></dt>
<dd>
<p>Returns the minimum value from rows in a group. For example,<a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="aggregate functions" data-tertiary="MIN()" id="idm46177473645288"/><a data-type="indexterm" data-primary="aggregating data" data-secondary="aggregate functions" data-tertiary="MIN()" id="idm46177473644040"/><a data-type="indexterm" data-primary="MIN()" id="idm46177473642824"/> you could use it to find the youngest student in a class, when the rows are grouped by class.</p>
</dd>
<dt><code>STD()</code>, <code>STDDEV()</code>, and <code>STDDEV_POP()</code></dt>
<dd>
<p>Return the standard deviation of values from rows in a group.<a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="aggregate functions" data-tertiary="STD(), STDDEV()" id="idm46177473639384"/><a data-type="indexterm" data-primary="aggregating data" data-secondary="aggregate functions" data-tertiary="STD(), STDDEV()" id="idm46177473638136"/><a data-type="indexterm" data-primary="STD()" id="idm46177473636920"/><a data-type="indexterm" data-primary="STDDEV()" id="idm46177473636248"/><a data-type="indexterm" data-primary="STDDEV_POP()" id="idm46177473635576"/> For example, you could use these to understand the spread of test scores, when rows are grouped by university course. All three of these are synonyms. <code>STD()</code> is a MySQL extension, <code>STDDEV()</code> is added for compatibility with Oracle, and <code>STDDEV_POP()</code> is a SQL standard function.</p>
</dd>
<dt><code>SUM()</code></dt>
<dd>
<p>Returns the sum of values from rows in a group. For example,<a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="aggregate functions" data-tertiary="SUM()" id="idm46177473632040"/><a data-type="indexterm" data-primary="aggregating data" data-secondary="aggregate functions" data-tertiary="SUM()" id="idm46177473630792"/><a data-type="indexterm" data-primary="SUM()" id="idm46177473629576"/> you could use it to compute the dollar amount of sales in a given month, when rows are grouped by month.</p>
</dd>
</dl>

<p>There are other functions available for use with <code>GROUP BY</code>, but they’re less frequently used than the ones we’ve introduced here. <a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="aggregate functions" data-tertiary="reference online" id="idm46177473608104"/><a data-type="indexterm" data-primary="web links in book" data-secondary="aggregate functions documentation" id="idm46177473607016"/><a data-type="indexterm" data-primary="aggregating data" data-secondary="aggregate functions" data-tertiary="reference online" id="idm46177473606168"/>You can find more details on them in the section on <a href="https://oreil.ly/QSZst">aggregate function descriptions</a> in the MySQL Reference Manual.<a data-type="indexterm" data-startref="ch05-gb" id="idm46177473604328"/><a data-type="indexterm" data-startref="ch05-gb2" id="idm46177473603720"/></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="The HAVING Clause"><div class="sect2" id="ADV1-SEC-HAVING">
<h2>The HAVING Clause</h2>

<p>You’re now familiar with the <code>GROUP BY</code> clause, which allows<a data-type="indexterm" data-primary="HAVING clause" id="ch05-hav"/><a data-type="indexterm" data-primary="aggregating data" data-secondary="GROUP BY clause" data-tertiary="HAVING clause" id="ch05-hav2"/><a data-type="indexterm" data-primary="GROUP BY clause" data-secondary="HAVING clause" id="ch05-hav3"/> you to sort and cluster data. You should be able to use it to find counts, averages, minimums, and maximums. This section shows how you can use the <code>HAVING</code> clause to gain additional control over the aggregation of rows in a <code>GROUP BY</code> operation.</p>

<p>Suppose you want to know how many popular actors there are in our database. You’ve decided to define an actor as popular if they’ve taken part in at least 40 movies. In the previous section, we tried an almost identical query but without the popularity limitation. We also found that when we grouped the actors by first and last name, we lost one record, so we’ll add grouping on the <code>actor_id</code> column, which we know to be unique. Here’s the new query, with an additional <code>HAVING</code> clause that adds the 
<span class="keep-together">constraint:</span></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">actor_id</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">HAVING</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code><code> </code><code class="o">&gt;</code><code> </code><code class="mi">40</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+----------------+
| first_name | last_name | COUNT(film_id) |
+------------+-----------+----------------+
| GINA       | DEGENERES |             42 |
| WALTER     | TORN      |             41 |
+------------+-----------+----------------+
2 rows in set (0.01 sec)</pre>

<p>You can see there are only two actors that meet the new criteria.</p>

<p>The <code>HAVING</code> clause must contain an expression or column that’s listed in the <code>SELECT</code> clause. In this example, we’ve used <code>HAVING COUNT(film_id) &gt;= 40</code>, and you can see that <code>COUNT(film_id)</code> is part of the <code>SELECT</code> clause. Typically, the expression in the 
<span class="keep-together"><code>HAVING</code></span> clause uses an aggregate function such as <code>COUNT()</code>, <code>SUM()</code>, <code>MIN()</code>, or <code>MAX()</code>. <a data-type="indexterm" data-primary="HAVING clause" data-secondary="WHERE clause instead" id="idm46177473531352"/><a data-type="indexterm" data-primary="WHERE clause" data-secondary="HAVING clause versus" id="idm46177473530344"/>If you find yourself wanting to write a <code>HAVING</code> clause that uses a column or expression that isn’t in the <code>SELECT</code> clause, chances are you should be using a <code>WHERE</code> clause instead. The <code>HAVING</code> clause is only for deciding how to form each group or cluster, not for choosing rows in the output. We’ll show you an example later that illustrates when not to use <code>HAVING</code>.</p>

<p>Let’s try another example. Suppose you want a list of the top 5 movies that were rented more than 30 times, together with the number of times they were rented, ordered by popularity in reverse. Here’s the query you’d use:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">rental_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">num_rented</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">film</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">title</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">HAVING</code><code> </code><code class="n">num_rented</code><code> </code><code class="o">&gt;</code><code> </code><code class="mi">30</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">num_rented</code><code> </code><code class="k">DESC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------------+------------+
| title              | num_rented |
+--------------------+------------+
| BUCKET BROTHERHOOD |         34 |
| ROCKETEER MOTHER   |         33 |
| FORWARD TEMPLE     |         32 |
| GRIT CLOCKWORK     |         32 |
| JUGGLER HARDLY     |         32 |
+--------------------+------------+
5 rows in set (0.04 sec)</pre>

<p>You can again see that the expression <code>COUNT()</code> is used in both the <code>SELECT</code> and <code>HAVING</code> clauses. This time, though, we aliased the <code>COUNT(rental_id)</code> function to <code>num_rented</code> and used the alias in both the <code>HAVING</code> and <code>ORDER BY</code> clauses.</p>

<p>Now let’s consider an example where you shouldn’t use <code>HAVING</code>. You want to know how many films a particular actor played in. Here’s the query you shouldn’t use:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">film_cnt</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">actor_id</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">HAVING</code><code> </code><code class="n">first_name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'EMILY'</code><code> </code><code class="k">AND</code><code> </code><code class="n">last_name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'DEE'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+----------+
| first_name | last_name | film_cnt |
+------------+-----------+----------+
| EMILY      | DEE       |       14 |
+------------+-----------+----------+
1 row in set (0.02 sec)</pre>

<p>It gets the right answer, but in the wrong—and, for large amounts of data, a much slower—way. It’s not the correct way to write the query because the <code>HAVING</code> clause isn’t being used to decide what rows should form each group but is instead being incorrectly used to filter the answers to display. For this query, we should really use a <code>WHERE</code> clause, as follows:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">film_cnt</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">first_name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'EMILY'</code><code> </code><code class="k">AND</code><code> </code><code class="n">last_name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'DEE'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">actor_id</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting" class="less_space pagebreak-before">+------------+-----------+----------+
| first_name | last_name | film_cnt |
+------------+-----------+----------+
| EMILY      | DEE       |       14 |
+------------+-----------+----------+
1 row in set (0.00 sec)</pre>

<p>This correct query forms the groups and then picks which groups to display based on the <code>WHERE</code> clause.<a data-type="indexterm" data-startref="ch05-hav" id="idm46177473243352"/><a data-type="indexterm" data-startref="ch05-hav2" id="idm46177473256024"/><a data-type="indexterm" data-startref="ch05-hav3" id="idm46177473255416"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Advanced Joins"><div class="sect1" id="ADV1-SEC-JOINS">
<h1>Advanced Joins</h1>

<p>So far in the book, we’ve used the <code>INNER JOIN</code> clause to bring together rows from two or more tables. We’ll explain the inner join in more detail in this section, contrasting it with the other join types we discuss: the union, left and right joins, and natural joins. At the conclusion of this section, you’ll be able to answer difficult information needs and be familiar with the correct choice of join for the task at hand.</p>








<section data-type="sect2" data-pdf-bookmark="The Inner Join"><div class="sect2" id="ADV1-SEC-INNERJOIN">
<h2>The Inner Join</h2>

<p>The <code>INNER JOIN</code> clause matches rows between two tables<a data-type="indexterm" data-primary="INNER JOIN" id="ch05-inj"/><a data-type="indexterm" data-primary="SELECT" data-secondary="INNER JOIN" id="idm46177473248280"/><a data-type="indexterm" data-primary="USING clause of joins" id="idm46177473213720"/> based on the criteria you provide in the <code>USING</code> clause. For example, you’re very familiar now with an inner join of the <code>actor</code> and <code>film_actor</code> tables:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">film_id</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+---------+
| first_name | last_name | film_id |
+------------+-----------+---------+
| PENELOPE   | GUINESS   |       1 |
| PENELOPE   | GUINESS   |      23 |
| ...                              |
| PENELOPE   | GUINESS   |     980 |
| NICK       | WAHLBERG  |       3 |
+------------+-----------+---------+
20 rows in set (0.00 sec)</pre>

<p>Let’s review the key features of an <code>INNER JOIN</code>:</p>

<ul>
<li>
<p>Two tables (or results of a previous join) are listed on either side of the <code>INNER JOIN</code> keyphrase.</p>
</li>
<li>
<p>The <code>USING</code> clause defines one or more columns that are in both tables or results and are used to join or match rows.</p>
</li>
<li>
<p>Rows that don’t match aren’t returned. For example, if you have a row in the <code>actor</code> table that doesn’t have any matching films in the <code>film_actor</code> table, it won’t be included in the output.</p>
</li>
</ul>

<p>You can actually write inner-join queries with the <code>WHERE</code> clause<a data-type="indexterm" data-primary="WHERE clause" data-secondary="inner joins via" id="idm46177473178408"/><a data-type="indexterm" data-primary="INNER JOIN" data-secondary="WHERE clause instead" id="idm46177473177400"/> without using the <code>INNER JOIN</code> keyphrase. Here’s a rewritten version of the previous query that produces the same result:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">film_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code class="p">,</code><code> </code><code class="n">film_actor</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">actor</code><code class="p">.</code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="n">film_actor</code><code class="p">.</code><code class="n">actor_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+---------+
| first_name | last_name | film_id |
+------------+-----------+---------+
| PENELOPE   | GUINESS   |       1 |
| PENELOPE   | GUINESS   |      23 |
| ...                              |
| PENELOPE   | GUINESS   |     980 |
| NICK       | WAHLBERG  |       3 |
+------------+-----------+---------+
20 rows in set (0.00 sec)</pre>

<p>You can see that we didn’t spell out the inner join: we’re selecting from the <code>actor</code> and <code>film_actor</code> tables the rows where the identifiers match between the tables.</p>

<p>You can modify the <code>INNER JOIN</code> syntax to express the join criteria in a way that’s similar to using a <code>WHERE</code> clause. This is useful if the names of the identifiers don’t match between the tables, although that’s not the case in this example. Here’s the previous query, rewritten in this style:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">film_id</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ON</code><code> </code><code class="n">actor</code><code class="p">.</code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="n">film_actor</code><code class="p">.</code><code class="n">actor_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+---------+
| first_name | last_name | film_id |
+------------+-----------+---------+
| PENELOPE   | GUINESS   |       1 |
| PENELOPE   | GUINESS   |      23 |
| ...                              |
| PENELOPE   | GUINESS   |     980 |
| NICK       | WAHLBERG  |       3 |
+------------+-----------+---------+
20 rows in set (0.00 sec)</pre>

<p>You can see that the <code>ON</code> clause replaces the <code>USING</code> clause and that the columns that follow are fully specified to include the table and column names. If the columns were named differently and uniquely between the two tables, you could omit the table names. There’s no real advantage or disadvantage to using <code>ON</code> or a <code>WHERE</code> clause; it’s just a matter of taste. Typically, these days, you’ll find most SQL professionals use the <code>INNER JOIN</code> with an <code>ON</code> clause in preference to <code>WHERE</code>, but it’s not universal.</p>

<p>Before we move on, let’s consider what purpose the <code>WHERE</code>, <code>ON</code>, and <code>USING</code> clauses serve. If you omit the <code>WHERE</code> clause from the query we just showed you, you get a very different result. Here’s the query and the first few lines of output:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">film_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code class="p">,</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-------------+---------+
| first_name | last_name   | film_id |
+------------+-------------+---------+
| THORA      | TEMPLE      |       1 |
| JULIA      | FAWCETT     |       1 |
| ...                                |
| DEBBIE     | AKROYD      |       1 |
| MATTHEW    | CARREY      |       1 |
+------------+-------------+---------+
20 rows in set (0.00 sec)</pre>

<p>The output is nonsensical: what’s happened is that each row from the <code>actor</code> table has been output alongside each row from the <code>film_actor</code> table, for all possible combinations. Since there are 200 actors and 5,462 records in the <code>film_actor</code> table, there are 200 × 5,462 = 1,092,400 rows of output, and we know that only 5,462 of those combinations actually make sense (there are only 5,462 records for actors who played in films). We can see the number of rows we’d get without a <code>LIMIT</code> with the following query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code class="p">,</code><code> </code><code class="n">film_actor</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------+
| COUNT(*) |
+----------+
|  1092400 |
+----------+
1 row in set (0.00 sec)</pre>

<p>This type of query, without a clause that matches rows, is<a data-type="indexterm" data-primary="queries" data-secondary="Cartesian products" id="idm46177472948984"/><a data-type="indexterm" data-primary="Cartesian products" id="idm46177472948040"/><a data-type="indexterm" data-primary="INNER JOIN" data-secondary="Cartesian products" id="idm46177472947368"/><a data-type="indexterm" data-primary="joins" data-secondary="Cartesian products" id="idm46177472946424"/> known as a <em>Cartesian product</em>. Incidentally, you also get the Cartesian product if you perform an inner join without specifying a column with a <code>USING</code> or <code>ON</code> clause, as in this query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="k">SELECT</code> <code class="n">first_name</code><code class="p">,</code> <code class="n">last_name</code><code class="p">,</code> <code class="n">film_id</code>
<code class="k">FROM</code> <code class="n">actor</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">film_actor</code><code class="p">;</code></pre>

<p>In <a data-type="xref" href="#ADV1-SEC-NATURAL">“The Natural Join”</a> we’ll introduce the natural join,<a data-type="indexterm" data-primary="natural joins" data-secondary="as inner join" id="idm46177472923080"/> which is an inner join on identically named columns. While the natural join doesn’t use explicitly specified columns, it still produces an inner join, rather than a Cartesian product.</p>

<p>The keyphrase <code>INNER JOIN</code> can be replaced with <code>JOIN</code> or <code>STRAIGHT JOIN</code>; they all do the same thing. However, <code>STRAIGHT JOIN</code> forces MySQL to always read the table on the left before it reads the table on the right. We’ll have a look at how MySQL processes queries behind the scenes in <a data-type="xref" href="ch07.xhtml#CH7_DOING_MORE">Chapter 7</a>. <a data-type="indexterm" data-primary="JOIN" data-see="INNER JOIN" id="idm46177472908632"/>The keyphrase <code>JOIN</code> is the one you’ll see most commonly used: it’s a standard shorthand for <code>INNER JOIN</code> used by many other database systems besides MySQL, and we will use it in  most of our inner-join examples.<a data-type="indexterm" data-startref="ch05-inj" id="idm46177472906568"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The Union"><div class="sect2" id="ADV1-SEC-UNION">
<h2>The Union</h2>

<p>The <code>UNION</code> statement isn’t really a join operator. Rather, it<a data-type="indexterm" data-primary="joins" data-secondary="union" id="idm46177472903912"/><a data-type="indexterm" data-primary="UNION" id="idm46177472902936"/><a data-type="indexterm" data-primary="SELECT" data-secondary="UNION" id="idm46177472902264"/> allows you to combine the output of more than one <code>SELECT</code> statement to give a consolidated result set. It’s useful in cases where you want to produce a single list from more than one source, or you want to create lists from a single source that are difficult to express in a single query.</p>

<p>Let’s look at an example. If you wanted to output all actor <em>and</em> movie <em>and</em> customer names in the <code>sakila</code> database, you could do this with a <code>UNION</code> statement. It’s a contrived example, but you might want to do this just to list all of the text fragments, rather than to meaningfully present the relationships in the data. There’s text in the <code>actor.first_name</code>, <code>film.title</code>, and <code>customer.first_name</code> columns. Here’s how to display it:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">UNION</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">customer</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">UNION</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-----------------------------+
| first_name                  |
+-----------------------------+
| PENELOPE                    |
| NICK                        |
| ED                          |
| ...                         |
| ZHIVAGO CORE                |
| ZOOLANDER FICTION           |
| ZORRO ARK                   |
+-----------------------------+
1647 rows in set (0.00 sec)</pre>

<p>We’ve shown only a few of the 1,647 rows. The <code>UNION</code> statement outputs the results from all the queries together, under a heading appropriate to the first query.</p>

<p>A slightly less contrived example is to create a list of the five most- and least-rented movies in our database. You can do this easily with the <code>UNION</code> operator:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">rental_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">num_rented</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">title</code><code> </code><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">num_rented</code><code> </code><code class="k">DESC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">UNION</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">rental_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">num_rented</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">title</code><code> </code><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">num_rented</code><code> </code><code class="k">ASC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------------+------------+
| title              | num_rented |
+--------------------+------------+
| BUCKET BROTHERHOOD |         34 |
| ROCKETEER MOTHER   |         33 |
| FORWARD TEMPLE     |         32 |
| GRIT CLOCKWORK     |         32 |
| JUGGLER HARDLY     |         32 |
| TRAIN BUNCH        |          4 |
| HARDLY ROBBERS     |          4 |
| MIXED DOORS        |          4 |
| BUNCH MINDS        |          5 |
| BRAVEHEART HUMAN   |          5 |
+--------------------+------------+
10 rows in set (0.04 sec)</pre>

<p>The first query uses <code>ORDER BY</code> with the <code>DESC</code> (descending) modifier and a <code>LIMIT 5</code> clause to find the top five most-rented movies. The second query uses <code>ORDER BY</code> with the <code>ASC</code> (ascending) modifier and a <code>LIMIT 5</code> clause to find the five least-rented movies. The <code>UNION</code> combines the result sets. Note that there are multiple titles with the same <code>num_rented</code> value, and the ordering of titles with the same value is not guaranteed to be determined. You may see different titles listed for <code>num_rented</code> values of 32 and 5 on your end.</p>

<p>The <code>UNION</code> operator has several limitations:</p>

<ul>
<li>
<p>The output is labeled with the names of the columns or expressions from the first query. Use column aliases to change this behavior.</p>
</li>
<li>
<p>The queries must output the same number of columns. If you try using different numbers of columns, MySQL will report an error.</p>
</li>
<li>
<p>All matching columns must have the same type. So, for example, if the first column output from the first query is a date, the first column output from any other query must also be a date.</p>
</li>
<li>
<p>The results returned are unique, as if you’d applied a <code>DISTINCT</code> to the overall result set. To see this in action, let’s try a simple example. Remember we had issues with actors’ names—the first name is a bad unique identifier. If we select two actors with the same first name and <code>UNION</code> the two queries, we will end up with just one row. The implicit <code>DISTINCT</code> operation hides the duplicate (for <code>UNION</code>) rows:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">88</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">UNION</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">169</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+
| first_name |
+------------+
| KENNETH    |
+------------+
1 row in set (0.01 sec)</pre>

<p>If you want to show any duplicates, replace <code>UNION</code> with <code>UNION ALL</code>:<a data-type="indexterm" data-primary="UNION" data-secondary="UNION ALL for duplicates" id="idm46177472626296"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">88</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">UNION</code><code> </code><code class="k">ALL</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">169</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+
| first_name |
+------------+
| KENNETH    |
| KENNETH    |
+------------+
2 rows in set (0.00 sec)</pre>

<p>Here, the first name <code>KENNETH</code> appears twice.</p>

<p>The implicit <code>DISTINCT</code> that <code>UNION</code> performs has a nonzero<a data-type="indexterm" data-primary="performance" data-secondary="UNION ALL over UNION" id="idm46177472565848"/> cost on the performance side of things. Whenever you use <code>UNION</code>, see whether <code>UNION ALL</code> fits logically, and if it can improve query performance.</p>
</li>
<li>
<p>If you want to apply <code>LIMIT</code> or <code>ORDER BY</code> to an individual query that is part of a <code>UNION</code> statement, enclose that query in parentheses (as shown in the previous example). It’s useful to use parentheses anyway to keep the query easy to 
<span class="keep-together">understand.</span></p>

<p>The <code>UNION</code> operation simply concatenates the results of the component queries with no attention to order,<a data-type="indexterm" data-primary="UNION" data-secondary="ORDER BY needs LIMIT" id="ch05-obl"/> so there’s not much point in using <code>ORDER BY</code> within one of the subqueries. The only time that it makes sense to order a subquery in a <code>UNION</code> operation is when you want to select a subset of the results. In our example, we’ve ordered the movies by the number of times they were rented and then selected only the top five (in the first subquery) and the bottom five (in the second subquery).</p>

<p>For efficiency, MySQL will actually ignore an <code>ORDER BY</code> clause within a subquery if it’s used without <code>LIMIT</code>. Let’s look at some examples to see exactly how this works.</p>

<p>First, let’s run a simple query to list the rental information for a particular movie, along with the time at which the rental happened. We’ve enclosed the query in parentheses for consistency with our other examples—the parentheses don’t actually have any effect here—and haven’t used an <code>ORDER BY</code> or <code>LIMIT</code> clause:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code><code class="p">,</code><code> </code><code class="n">return_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">998</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------+---------------------+---------------------+
| title        | rental_date         | return_date         |
+--------------+---------------------+---------------------+
| ZHIVAGO CORE | 2005-06-17 03:19:20 | 2005-06-21 00:19:20 |
| ZHIVAGO CORE | 2005-07-07 12:18:57 | 2005-07-12 09:47:57 |
| ZHIVAGO CORE | 2005-07-27 14:53:55 | 2005-07-31 19:48:55 |
| ZHIVAGO CORE | 2005-08-20 17:18:48 | 2005-08-26 15:31:48 |
| ZHIVAGO CORE | 2005-05-30 05:15:20 | 2005-06-07 00:49:20 |
| ZHIVAGO CORE | 2005-06-18 06:46:54 | 2005-06-26 09:48:54 |
| ZHIVAGO CORE | 2005-07-12 05:24:02 | 2005-07-16 03:43:02 |
| ZHIVAGO CORE | 2005-08-02 02:05:04 | 2005-08-10 21:58:04 |
| ZHIVAGO CORE | 2006-02-14 15:16:03 | NULL                |
+--------------+---------------------+---------------------+
9 rows in set (0.00 sec)</pre>

<p>The query returns all the times the movie was rented, in no particular order (see the fourth and fifth entries).</p>

<p>Now, let’s add an <code>ORDER BY</code> clause to this query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code><code class="p">,</code><code> </code><code class="n">return_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">998</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">rental_date</code><code> </code><code class="k">ASC</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------+---------------------+---------------------+
| title        | rental_date         | return_date         |
+--------------+---------------------+---------------------+
| ZHIVAGO CORE | 2005-05-30 05:15:20 | 2005-06-07 00:49:20 |
| ZHIVAGO CORE | 2005-06-17 03:19:20 | 2005-06-21 00:19:20 |
| ZHIVAGO CORE | 2005-06-18 06:46:54 | 2005-06-26 09:48:54 |
| ZHIVAGO CORE | 2005-07-07 12:18:57 | 2005-07-12 09:47:57 |
| ZHIVAGO CORE | 2005-07-12 05:24:02 | 2005-07-16 03:43:02 |
| ZHIVAGO CORE | 2005-07-27 14:53:55 | 2005-07-31 19:48:55 |
| ZHIVAGO CORE | 2005-08-02 02:05:04 | 2005-08-10 21:58:04 |
| ZHIVAGO CORE | 2005-08-20 17:18:48 | 2005-08-26 15:31:48 |
| ZHIVAGO CORE | 2006-02-14 15:16:03 | NULL                |
+--------------+---------------------+---------------------+
9 rows in set (0.00 sec)</pre>

<p>As expected, we get all the times the movie was rented, in the order of the rental date.</p>

<p>Adding a <code>LIMIT</code> clause to the previous query selects the first five rentals, in chronological order—no surprises here:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code><code class="p">,</code><code> </code><code class="n">return_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">998</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">rental_date</code><code> </code><code class="k">ASC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------+---------------------+---------------------+
| title        | rental_date         | return_date         |
+--------------+---------------------+---------------------+
| ZHIVAGO CORE | 2005-05-30 05:15:20 | 2005-06-07 00:49:20 |
| ZHIVAGO CORE | 2005-06-17 03:19:20 | 2005-06-21 00:19:20 |
| ZHIVAGO CORE | 2005-06-18 06:46:54 | 2005-06-26 09:48:54 |
| ZHIVAGO CORE | 2005-07-07 12:18:57 | 2005-07-12 09:47:57 |
| ZHIVAGO CORE | 2005-07-12 05:24:02 | 2005-07-16 03:43:02 |
+--------------+---------------------+---------------------+
5 rows in set (0.01 sec)</pre>

<p>Now, let’s see what happens when we perform a <code>UNION</code> operation. In this example, we’re using two subqueries, each with an <code>ORDER BY</code> clause. We’ve used a <code>LIMIT</code> clause for the second subquery, but not for the first:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code><code class="p">,</code><code> </code><code class="n">return_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">998</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">rental_date</code><code> </code><code class="k">ASC</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">UNION</code><code> </code><code class="k">ALL</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code><code class="p">,</code><code> </code><code class="n">return_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">998</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">rental_date</code><code> </code><code class="k">ASC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------+---------------------+---------------------+
| title        | rental_date         | return_date         |
+--------------+---------------------+---------------------+
| ZHIVAGO CORE | 2005-06-17 03:19:20 | 2005-06-21 00:19:20 |
| ZHIVAGO CORE | 2005-07-07 12:18:57 | 2005-07-12 09:47:57 |
| ZHIVAGO CORE | 2005-07-27 14:53:55 | 2005-07-31 19:48:55 |
| ZHIVAGO CORE | 2005-08-20 17:18:48 | 2005-08-26 15:31:48 |
| ZHIVAGO CORE | 2005-05-30 05:15:20 | 2005-06-07 00:49:20 |
| ZHIVAGO CORE | 2005-06-18 06:46:54 | 2005-06-26 09:48:54 |
| ZHIVAGO CORE | 2005-07-12 05:24:02 | 2005-07-16 03:43:02 |
| ZHIVAGO CORE | 2005-08-02 02:05:04 | 2005-08-10 21:58:04 |
| ZHIVAGO CORE | 2006-02-14 15:16:03 | NULL                |
| ZHIVAGO CORE | 2005-05-30 05:15:20 | 2005-06-07 00:49:20 |
| ZHIVAGO CORE | 2005-06-17 03:19:20 | 2005-06-21 00:19:20 |
| ZHIVAGO CORE | 2005-06-18 06:46:54 | 2005-06-26 09:48:54 |
| ZHIVAGO CORE | 2005-07-07 12:18:57 | 2005-07-12 09:47:57 |
| ZHIVAGO CORE | 2005-07-12 05:24:02 | 2005-07-16 03:43:02 |
+--------------+---------------------+---------------------+
14 rows in set (0.01 sec)</pre>

<p>As expected, the first subquery returns all the times the movie was rented (the first nine rows of this output), and the second subquery returns the first five rentals (the last five rows of this output). Notice how the first nine rows are not in order (see the fourth and fifth rows), even though the first subquery does have an <code>ORDER BY</code> clause. Since we’re performing a <code>UNION</code> operation, the MySQL server has decided that there’s no point sorting the results of the subquery. The second subquery includes a <code>LIMIT</code> operation, so the results of that subquery are sorted.</p>

<p>The output of a <code>UNION</code> operation isn’t guaranteed to be ordered even if the subqueries are ordered, so if you want the final output to be ordered, you should add an <code>ORDER BY</code> clause at the end of the whole query. Note that it can be in another order from the subqueries. See the following:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code><code class="p">,</code><code> </code><code class="n">return_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">998</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">rental_date</code><code> </code><code class="k">ASC</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">UNION</code><code> </code><code class="k">ALL</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code><code class="p">,</code><code> </code><code class="n">return_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">998</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">rental_date</code><code> </code><code class="k">ASC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">rental_date</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------+---------------------+---------------------+
| title        | rental_date         | return_date         |
+--------------+---------------------+---------------------+
| ZHIVAGO CORE | 2006-02-14 15:16:03 | NULL                |
| ZHIVAGO CORE | 2005-08-20 17:18:48 | 2005-08-26 15:31:48 |
| ZHIVAGO CORE | 2005-08-02 02:05:04 | 2005-08-10 21:58:04 |
| ZHIVAGO CORE | 2005-07-27 14:53:55 | 2005-07-31 19:48:55 |
| ZHIVAGO CORE | 2005-07-12 05:24:02 | 2005-07-16 03:43:02 |
| ZHIVAGO CORE | 2005-07-12 05:24:02 | 2005-07-16 03:43:02 |
| ZHIVAGO CORE | 2005-07-07 12:18:57 | 2005-07-12 09:47:57 |
| ZHIVAGO CORE | 2005-07-07 12:18:57 | 2005-07-12 09:47:57 |
| ZHIVAGO CORE | 2005-06-18 06:46:54 | 2005-06-26 09:48:54 |
| ZHIVAGO CORE | 2005-06-18 06:46:54 | 2005-06-26 09:48:54 |
| ZHIVAGO CORE | 2005-06-17 03:19:20 | 2005-06-21 00:19:20 |
| ZHIVAGO CORE | 2005-06-17 03:19:20 | 2005-06-21 00:19:20 |
| ZHIVAGO CORE | 2005-05-30 05:15:20 | 2005-06-07 00:49:20 |
| ZHIVAGO CORE | 2005-05-30 05:15:20 | 2005-06-07 00:49:20 |
+--------------+---------------------+---------------------+
14 rows in set (0.00 sec)</pre>

<p>Here’s another example of sorting the final results, including a limit on the number of returned results:<a data-type="indexterm" data-startref="ch05-obl" id="idm46177472005672"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">actor_id</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">5</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">UNION</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">actor_id</code><code> </code><code class="o">&gt;</code><code> </code><code class="mi">190</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">first_name</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">4</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+
| first_name | last_name |
+------------+-----------+
| BELA       | WALKEN    |
| BURT       | TEMPLE    |
| ED         | CHASE     |
| GREGORY    | GOODING   |
+------------+-----------+
4 rows in set (0.00 sec)</pre>

<p>The <code>UNION</code> operation is somewhat unwieldy, and there are generally alternative ways of getting the same result. <a data-type="indexterm" data-primary="OR operator" data-secondary="UNION alternative" id="idm46177471918552"/><a data-type="indexterm" data-primary="UNION" data-secondary="OR instead" id="idm46177471929960"/>For example, the previous query could have been written more simply like this:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">actor_id</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">5</code><code> </code><code class="k">OR</code><code> </code><code class="n">actor_id</code><code> </code><code class="o">&gt;</code><code> </code><code class="mi">190</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">first_name</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">4</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+
| first_name | last_name |
+------------+-----------+
| BELA       | WALKEN    |
| BURT       | TEMPLE    |
| ED         | CHASE     |
| GREGORY    | GOODING   |
+------------+-----------+
4 rows in set (0.00 sec)</pre>
</li>
</ul>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The Left and Right Joins"><div class="sect2" id="ADV1-SEC-LEFTRIGHT">
<h2>The Left and Right Joins</h2>

<p>The joins we’ve discussed so far output only rows that match<a data-type="indexterm" data-primary="joins" data-secondary="left joins" data-see="left joins" id="idm46177471863976"/><a data-type="indexterm" data-primary="left joins" id="ch05-lj"/><a data-type="indexterm" data-primary="queries" data-secondary="joins" data-see="joins" id="idm46177471861784"/> between tables. For example, when you join the <code>film</code> and <code>rental</code> tables through the <code>inventory</code> table, you see only the films that were rented. Rows for films that haven’t been rented are ignored. This makes sense in many cases, but it isn’t the only way to join data. This section explains other options you have.</p>

<p>Suppose you do want a comprehensive list of all films and the number of times they’ve been rented. Unlike in the example earlier in this chapter, included in the list you want to see a zero next to movies that haven’t been rented. You can do this with a <em>left join</em>, a different type of join that’s driven by one of the two tables participating in the join. In a left join, each row in the left table—the one that’s doing the driving—is processed and output, with the matching data from the second table if it exists and <code>NULL</code> values if there is no matching data in the second table. We’ll show you how to write this type of query later in this section, but we’ll start with a simpler example.</p>

<p>Here’s a simple <code>LEFT JOIN</code> example. You want to list all movies, and next to each movie you want to show when it was rented. If a movie has never been rented, you want to see that. If it’s been rented many times, you want to see that too. Here’s the query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-----------------------------+---------------------+
| title                       | rental_date         |
+-----------------------------+---------------------+
| ACADEMY DINOSAUR            | 2005-07-08 19:03:15 |
| ACADEMY DINOSAUR            | 2005-08-02 20:13:10 |
| ACADEMY DINOSAUR            | 2005-08-21 21:27:43 |
| ...                                               |
| WAKE JAWS                   | NULL                |
| WALLS ARTIST                | NULL                |
| ...                                               |
| ZORRO ARK                   | 2005-07-31 07:32:21 |
| ZORRO ARK                   | 2005-08-19 03:49:28 |
+-----------------------------+---------------------+
16087 rows in set (0.06 sec)</pre>

<p>You can see what happens: movies that have been rented have dates and times, and those that haven’t don’t (the <code>rental_date</code> value is <code>NULL</code>). Note also that we <code>LEFT JOIN</code> twice in this example. First we join <code>film</code> and <code>inventory</code>, and we want to make sure that even if a movie is not in our inventory (and thus cannot be rented by definition), we still output it. Then we join the <code>rental</code> table with the dataset resulting from the previous join. We use a <code>LEFT JOIN</code> again, as we may have films that are not in our inventory, and those won’t have any rows in the <code>rental</code> table. However, we may also have films listed in our inventory that just haven’t been rented. That’s why we need to <code>LEFT JOIN</code> both tables here.</p>

<p>The order of the tables in the <code>LEFT JOIN</code> is important. If you reverse the order in the previous query, you get very different output:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">rental</code><code> </code><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">rental_date</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-----------------------------+---------------------+
| title                       | rental_date         |
+-----------------------------+---------------------+
| ...                                               |
| LOVE SUICIDES               | 2005-05-24 23:04:41 |
| GRADUATE LORD               | 2005-05-24 23:03:39 |
| FREAKY POCUS                | 2005-05-24 22:54:33 |
| BLANKET BEVERLY             | 2005-05-24 22:53:30 |
+-----------------------------+---------------------+
16044 rows in set (0.06 sec)</pre>

<p>In this version, the query is driven by the <code>rental</code> table, so all rows from it are matched against the <code>inventory</code> table and then against <code>film</code>. Since all the rows in the <code>rental</code> table by definition are based on the <code>inventory</code> table, which is linked to the <code>film</code> table, we have no <code>NULL</code> values in the output. There can be no rental for a film that doesn’t exist. We adjusted the query with <code>ORDER BY rental_date DESC</code> to show that we really didn’t get any <code>NULL</code> values (these would have been last).</p>

<p>By now you can see that left joins are useful when we’re sure that our <em>left</em> table has some important data, but we’re not sure whether the <em>right</em> table does. We want to get the rows from the left one with or without the corresponding rows from the right one. Let’s try to apply this to a query we wrote in <a data-type="xref" href="#ADV1-SEC-GROUPBY">“The GROUP BY Clause”</a>, which showed customers renting a lot from the same category. Here’s the query, as a reminder:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">email</code><code class="p">,</code><code> </code><code class="n">name</code><code> </code><code class="k">AS</code><code> </code><code class="n">category_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">cat</code><code class="p">.</code><code class="n">category_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">customer</code><code> </code><code class="n">cs</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">category</code><code> </code><code class="n">cat</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">email</code><code class="p">,</code><code> </code><code class="n">category_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">cnt</code><code> </code><code class="k">DESC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------------------------------+---------------+-----+
| email                            | category_name | cnt |
+----------------------------------+---------------+-----+
| WESLEY.BULL@sakilacustomer.org   | Games         |   9 |
| ALMA.AUSTIN@sakilacustomer.org   | Animation     |   8 |
| KARL.SEAL@sakilacustomer.org     | Animation     |   8 |
| LYDIA.BURKE@sakilacustomer.org   | Documentary   |   8 |
| NATHAN.RUNYON@sakilacustomer.org | Animation     |   7 |
+----------------------------------+---------------+-----+
5 rows in set (0.06 sec)</pre>

<p>What if we now want to see whether a customer we found this way rents films from anything but their favorite category? It turns out that’s actually pretty difficult!</p>

<p>Let’s consider this task. We need to start with the <code>category</code> table, as that will have all the categories we have for our films. We then need to start constructing a whole chain of left joins. First we left join <code>category</code> to <code>film_category</code>, as we may have categories with no films. Then we left join the result to the <code>inventory</code> table, as some movies we know about may not be in our catalog. We then left join that result to the <code>rental</code> table, as customers may not have rented some of the films in a category. Finally, we need to left join that result to our <code>customer</code> table. Even though there can be no 
<span class="keep-together">associated</span> customer record without a rental, omitting the left join here will cause MySQL to discard rows for categories that end up with no customer records.</p>

<p>Now, after this whole long explanation, can we finally go ahead and filter by email address and get our data? No! Unfortunately, by adding a <code>WHERE</code> condition on the table that is not <em>left</em> in our left-join relationship, we break the idea of this join. See what happens:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">category</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------+
| COUNT(*) |
+----------+
|       16 |
+----------+
1 row in set (0.00 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">email</code><code class="p">,</code><code> </code><code class="n">name</code><code> </code><code class="k">AS</code><code> </code><code class="n">category_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">category</code><code> </code><code class="n">cat</code><code> </code><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="n">cs</code><code> </code><code class="k">ON</code><code> </code><code class="n">rental</code><code class="p">.</code><code class="n">customer_id</code><code> </code><code class="o">=</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">customer_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">email</code><code class="p">,</code><code> </code><code class="n">category_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">cnt</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------------------------+---------------+-----+
| email                          | category_name | cnt |
+--------------------------------+---------------+-----+
| WESLEY.BULL@sakilacustomer.org | Games         |   9 |
| WESLEY.BULL@sakilacustomer.org | Foreign       |   6 |
| ...                                                  |
| WESLEY.BULL@sakilacustomer.org | Comedy        |   1 |
| WESLEY.BULL@sakilacustomer.org | Sports        |   1 |
+--------------------------------+---------------+-----+
14 rows in set (0.00 sec)</pre>

<p>We got 14 categories for our customer, while there are 16 in total. In fact, MySQL will optimize away all the left joins in this query, as it understands they are meaningless when put like this. There’s no easy way to answer the question we have with just 
<span class="keep-together">joins—we’ll</span> get back to this example in <a data-type="xref" href="#ADV1-SEC-NESTEDJOIN">“Nested Queries in JOINs”</a>.</p>

<p>The query that we’ve written is still useful, though. While by default <code>sakila</code> does not have a film category in which no films have been rented, if we expand our database slightly, we can see the effectiveness of left joins:</p>
<pre data-type="programlisting" data-code-language="mysql">
<code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="nf">category</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code> </code><code class="k">VALUES</code><code> </code><code class="p">(</code><code class="s1">'Thriller'</code><code class="p">)</code><code class="p">;</code></strong><code>
</code></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.01 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">cat</code><code class="p">.</code><code class="n">name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">rental_id</code><code class="p">)</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">category</code><code> </code><code class="n">cat</code><code> </code><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="n">cs</code><code> </code><code class="k">ON</code><code> </code><code class="n">rental</code><code class="p">.</code><code class="n">customer_id</code><code> </code><code class="o">=</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">customer_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="mi">1</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="mi">2</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---------------+------+
| category_name | cnt  |
+---------------+------+
| Sports        | 1179 |
| Animation     | 1166 |
| ...                  |
| Music         |  830 |
| Thriller      |    0 |
+---------------+------+
17 rows in set (0.07 sec)</pre>

<p>If we were to use a regular <code>INNER JOIN</code> (or just <code>JOIN</code>, its synonym) here, we wouldn’t get information for the Thriller category, and we might get different counts for other categories. As <code>category</code> is our leftmost table, it drives the process of the query, and every row from that table is present in the output.</p>

<p>We’ve shown you that it matters what comes before and after the <code>LEFT JOIN</code> keyphrase. Whatever is on the left drives the process, hence the name “left join.” <a data-type="indexterm" data-primary="right joins" id="idm46177471268504"/><a data-type="indexterm" data-primary="joins" data-secondary="right joins" id="idm46177471267896"/>If you really don’t want to reorganize your query so it matches that template, you can use <code>RIGHT JOIN</code>. It’s exactly the same, except whatever is on the right drives the process.</p>

<p>Earlier we showed the importance of the order of the tables in a left join using two queries for film rental information. Let’s rewrite the second of them (which showed incorrect data) using a right join:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="n">rental_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">rental</code><code> </code><code class="k">RIGHT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">RIGHT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">rental_date</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">...
| SUICIDES SILENCE            | NULL                |
| TADPOLE PARK                | NULL                |
| TREASURE COMMAND            | NULL                |
| VILLAIN DESPERATE           | NULL                |
| VOLUME HOUSE                | NULL                |
| WAKE JAWS                   | NULL                |
| WALLS ARTIST                | NULL                |
+-----------------------------+---------------------+
16087 rows in set (0.06 sec)</pre>

<p>We got the same number of rows, and we can see that the <code>NULL</code> values are the same as those the “correct” query gave us. The right join is useful sometimes because it allows you to write a query more naturally, expressing it in a way that’s more intuitive. However, you won’t often see it used, and we’d recommend avoiding it where possible.</p>

<p>Both left and right joins can use the <code>USING</code> and <code>ON</code> clauses discussed in <a data-type="xref" href="#ADV1-SEC-INNERJOIN">“The Inner Join”</a>. You should use one or the other: without them you’ll get the Cartesian product, as discussed in that section.</p>

<p>There’s also an extra <code>OUTER</code> keyword that you can optionally<a data-type="indexterm" data-primary="joins" data-secondary="outer joins no different" id="idm46177471181896"/> use in left and right joins to make them read as <code>LEFT OUTER JOIN</code> and <code>RIGHT OUTER JOIN</code>. It’s just an alternative syntax that doesn’t do anything different, and you won’t often see it used. We stick to the basic versions in this book.<a data-type="indexterm" data-startref="ch05-lj" id="idm46177471179816"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The Natural Join"><div class="sect2" id="ADV1-SEC-NATURAL">
<h2>The Natural Join</h2>

<p>We’re not big fans of the natural join that we describe in this section.<a data-type="indexterm" data-primary="joins" data-secondary="natural joins" id="idm46177471177480"/><a data-type="indexterm" data-primary="natural joins" id="idm46177471146632"/> It’s included here only for completeness, and because you’ll see it used sometimes in SQL statements you’ll encounter. Our advice is to avoid using it where possible.</p>

<p>A natural join is, well, supposed to be magically natural. <a data-type="indexterm" data-primary="natural joins" data-secondary="as inner join" id="idm46177471145320"/>This means that you tell MySQL what tables you want to join, and it figures out how to do it and gives you an <code>INNER JOIN</code> result set. Here’s an example for the <code>actor_info</code> and <code>film_actor</code> tables:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">film_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor_info</code><code> </code><code class="k">NATURAL</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+---------+
| first_name | last_name | film_id |
+------------+-----------+---------+
| PENELOPE   | GUINESS   |       1 |
| PENELOPE   | GUINESS   |      23 |
| ...                              |
| PENELOPE   | GUINESS   |     980 |
| NICK       | WAHLBERG  |       3 |
+------------+-----------+---------+
20 rows in set (0.28 sec)</pre>

<p>In reality, it’s not quite magical: all MySQL does is look for columns with the same names and, behind the scenes, add these silently into an inner join with join conditions written into the <code>WHERE</code> clause. So, the previous query is actually translated into something like this:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">film_id</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor_info</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="p">(</code><code class="n">actor_info</code><code class="p">.</code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="n">film_actor</code><code class="p">.</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<p>If the identifier columns don’t share the same name, natural joins won’t work. Also, more dangerously, if columns that do share the same names aren’t identifiers, they’ll get thrown into the behind-the-scenes <code>USING</code> clause anyway. You can very easily see this in the <code>sakila</code> database. In fact, that’s why we resorted to showing the preceding example with <code>actor_info</code>, which isn’t even a table: it’s a view. Let’s see what would have happened if we used the regular <code>actor</code> and <code>film_actor</code> tables:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">film_id</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">NATURAL</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Empty set (0.01 sec)</pre>

<p>But how? The problem is: <code>NATURAL JOIN</code> really does take <em>all</em> of the columns into consideration. With the <code>sakila</code> database, that’s a huge roadblock, as every table has a <code>last_update</code> column. If you were to run an <code>EXPLAIN</code> statement on the previous query and then execute <code>SHOW WARNINGS</code>, you’d see that the resulting query is meaningless:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SHOW</code><code> </code><code class="n">WARNINGS</code><code class="err">\</code><code class="n">G</code></strong></pre>

<pre data-type="programlisting">*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `sakila`.`customer`.`email` AS `email`,
`sakila`.`rental`.`rental_date` AS `rental_date`
from `sakila`.`customer` join `sakila`.`rental`
where ((`sakila`.`rental`.`last_update` = `sakila`.`customer`.`last_update`)
and (`sakila`.`rental`.`customer_id` = `sakila`.`customer`.`customer_id`))
1 row in set (0.00 sec)</pre>

<p>You’ll sometimes see the natural join mixed with left and right joins. The following are valid join syntaxes: <code>NATURAL LEFT JOIN</code>, <code>NATURAL LEFT OUTER JOIN</code>, <code>NATURAL RIGHT JOIN</code>, and <code>NATURAL RIGHT OUTER JOIN</code>. The former two are left joins without <code>ON</code> or <code>USING</code> clauses, and the latter two are right joins. Again, avoid writing them when you can, but you should understand what they mean if you see them used.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Constant Expressions in Joins"><div class="sect2" id="idm46177471178856">
<h2>Constant Expressions in Joins</h2>

<p>In all of the examples of joins we’ve given you so far, we’ve<a data-type="indexterm" data-primary="joins" data-secondary="constant expressions in" id="ch05-cej"/><a data-type="indexterm" data-primary="constant expressions in joins" id="ch05-cej2"/><a data-type="indexterm" data-primary="left joins" data-secondary="constant expressions in" id="ch05-cej3"/> used column identifiers to define the join condition. When you’re using the <code>USING</code> clause, that’s the only possible way to go. When you’re defining the join conditions in a <code>WHERE</code> clause, that’s also the only thing that will work. However, when you’re using the <code>ON</code> clause, you can actually add constant expressions.</p>

<p>Let’s consider an example, listing all films for a particular actor:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">title</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">11</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+--------------------+
| first_name | last_name | title              |
+------------+-----------+--------------------+
| ZERO       | CAGE      | CANYON STOCK       |
| ZERO       | CAGE      | DANCES NONE        |
| ...                                         |
| ZERO       | CAGE      | WEST LION          |
| ZERO       | CAGE      | WORKER TARZAN      |
+------------+-----------+--------------------+
25 rows in set (0.00 sec)</pre>

<p>We can move the <code>actor_id</code> clause into the join like this:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">title</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code>   </code><strong><code class="k">ON</code><code> </code><code class="n">actor</code><code class="p">.</code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="n">film_actor</code><code class="p">.</code><code class="n">actor_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code>   </code><strong><code class="k">AND</code><code> </code><code class="n">actor</code><code class="p">.</code><code class="n">actor_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">11</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+--------------------+
| first_name | last_name | title              |
+------------+-----------+--------------------+
| ZERO       | CAGE      | CANYON STOCK       |
| ZERO       | CAGE      | DANCES NONE        |
| ...                                         |
| ZERO       | CAGE      | WEST LION          |
| ZERO       | CAGE      | WORKER TARZAN      |
+------------+-----------+--------------------+
25 rows in set (0.00 sec)</pre>

<p>Well, that’s neat, of course, but why? Is this any more expressive than having the proper <code>WHERE</code> clause? The answer to both questions is that constant conditions in joins are evaluated and resolved differently than the conditions in the <code>WHERE</code> clause are. It’s easier to show this with an example, but the preceding query is a poor one. The impact of constant conditions in joins is best shown with a left join.</p>

<p>Remember this query from the section on left joins:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">email</code><code class="p">,</code><code> </code><code class="n">name</code><code> </code><code class="k">AS</code><code> </code><code class="n">category_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">rental_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">category</code><code> </code><code class="n">cat</code><code> </code><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="n">cs</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">email</code><code class="p">,</code><code> </code><code class="n">category_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">cnt</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------------------------+---------------+-----+
| email                          | category_name | cnt |
+--------------------------------+---------------+-----+
| WESLEY.BULL@sakilacustomer.org | Games         |   9 |
| WESLEY.BULL@sakilacustomer.org | Foreign       |   6 |
| ...                                                  |
| WESLEY.BULL@sakilacustomer.org | Comedy        |   1 |
| WESLEY.BULL@sakilacustomer.org | Sports        |   1 |
+--------------------------------+---------------+-----+
14 rows in set (0.01 sec)</pre>

<p>If we go ahead and move the <code>cs.email</code> clause to the <code>LEFT JOIN customer cs</code> part, we’ll see completely different results:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">email</code><code class="p">,</code><code> </code><code class="n">name</code><code> </code><code class="k">AS</code><code> </code><code class="n">category_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">rental_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">category</code><code> </code><code class="n">cat</code><code> </code><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="n">cs</code><code> </code><code class="k">ON</code><code> </code><code class="n">rental</code><code class="p">.</code><code class="n">customer_id</code><code> </code><code class="o">=</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">customer_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">email</code><code class="p">,</code><code> </code><code class="n">category_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">cnt</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------------------------------+-------------+------+
| email                          | name        | cnt  |
+--------------------------------+-------------+------+
| NULL                           | Sports      | 1178 |
| NULL                           | Animation   | 1164 |
| ...                                                 |
| NULL                           | Travel      |  834 |
| NULL                           | Music       |  829 |
| WESLEY.BULL@sakilacustomer.org | Games       |    9 |
| WESLEY.BULL@sakilacustomer.org | Foreign     |    6 |
| ...                                                 |
| WESLEY.BULL@sakilacustomer.org | Comedy      |    1 |
| NULL                           | Thriller    |    0 |
+--------------------------------+-------------+------+
31 rows in set (0.07 sec)</pre>

<p>That’s interesting! Instead of getting only Wesley’s rental counts per category, we also get rental counts for everyone else broken down by category. That even includes our new and so far empty Thriller category. Let’s try to understand what happens here.</p>

<p>The <code>WHERE</code> clause’s contents are applied logically after the joins are resolved and executed. We tell MySQL we only need rows from whatever we join where the <code>cs.email</code> column equals <code>'WESLEY.BULL@sakilacustomer.org'</code>. In reality, MySQL is smart enough to optimize this situation and will actually start the plan execution as if regular inner joins were used. When we have the <code>cs.email</code> condition within the <code>LEFT JOIN customer</code> clause, we tell MySQL that we want to add columns from the <code>customer</code> table to our result set so far (which includes the <code>category</code>, <code>inventory</code>, and <code>rental</code> tables), but only when the certain value is present in the <code>email</code> column. Since this is a <code>LEFT JOIN</code>, we get <code>NULL</code> in every column of <code>customer</code> in rows that didn’t match.</p>

<p>It’s important to be aware of this behavior.<a data-type="indexterm" data-startref="ch05-cej" id="idm46177470566312"/><a data-type="indexterm" data-startref="ch05-cej2" id="idm46177470565608"/><a data-type="indexterm" data-startref="ch05-cej3" id="idm46177470564936"/></p>
</div></section>





</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Nested Queries"><div class="sect1" id="ADV1-SEC-NESTED">
<h1>Nested Queries</h1>

<p>Nested queries, supported by MySQL since version 4.1, are the<a data-type="indexterm" data-primary="nested queries" data-secondary="about" id="idm46177470513848"/><a data-type="indexterm" data-primary="queries" data-secondary="nested queries" data-see="nested queries" id="idm46177470513000"/> most difficult to learn. However, they provide a powerful, useful, and concise way of expressing difficult information needs in short SQL statements. This section explains them, beginning with simple examples and leading to the more complex features of the <code>EXISTS</code> and <code>IN</code> statements. At the conclusion of this section, you’ll have completed everything this book contains about querying data, and you should understand almost any SQL query you encounter.</p>








<section data-type="sect2" data-pdf-bookmark="Nested Query Basics"><div class="sect2" id="ADV1-SEC-NESTEDBASICS">
<h2>Nested Query Basics</h2>

<p>You know how to find the names of all the actors who played in a particular movie using an <code>INNER JOIN</code>:<a data-type="indexterm" data-primary="nested queries" data-secondary="basics" id="ch05-nqb2"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'ZHIVAGO CORE'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+
| first_name | last_name |
+------------+-----------+
| UMA        | WOOD      |
| NICK       | STALLONE  |
| GARY       | PENN      |
| SALMA      | NOLTE     |
| KENNETH    | HOFFMAN   |
| WILLIAM    | HACKMAN   |
+------------+-----------+
6 rows in set (0.00 sec)</pre>

<p>But there’s another way, using a <em>nested query</em>:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">film_id</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'ZHIVAGO CORE'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+
| first_name | last_name |
+------------+-----------+
| UMA        | WOOD      |
| NICK       | STALLONE  |
| GARY       | PENN      |
| SALMA      | NOLTE     |
| KENNETH    | HOFFMAN   |
| WILLIAM    | HACKMAN   |
+------------+-----------+
6 rows in set (0.00 sec)</pre>

<p>It’s called a nested query because one query is inside another.<a data-type="indexterm" data-primary="nested queries" data-secondary="inner query (subquery)" id="idm46177470390552"/><a data-type="indexterm" data-primary="inner query in nested queries" id="idm46177470400696"/><a data-type="indexterm" data-primary="subquery in nested queries" id="idm46177470400056"/> The <em>inner query</em>, or <em>subquery</em>—the one that is nested—is written in parentheses, and you can see that it determines the <code>film_id</code> for the film with the title <code>ZHIVAGO CORE</code>. The parentheses are required for inner queries. <a data-type="indexterm" data-primary="nested queries" data-secondary="outer query" id="idm46177470397480"/><a data-type="indexterm" data-primary="outer query in nested queries" id="idm46177470396504"/>The <em>outer query</em> is the one that’s listed first and isn’t parenthesized here: you can see that it finds the <code>first_name</code> and <code>last_name</code> of the actors from a <code>JOIN</code> with <code>film_actor</code> with a <code>film_id</code> that matches the result of the subquery. So, overall, the inner query finds the <code>film_id</code>, and the outer query uses it to find actors’ names. Whenever nested queries are used, it’s possible to rewrite them as a few separate queries. Let’s do that with the previous example, as it may help you understand what is going on:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">film_id</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'ZHIVAGO CORE'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---------+
| film_id |
+---------+
|     998 |
+---------+
1 row in set (0.03 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_actor</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">actor_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">998</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+
| first_name | last_name |
+------------+-----------+
| UMA        | WOOD      |
| NICK       | STALLONE  |
| GARY       | PENN      |
| SALMA      | NOLTE     |
| KENNETH    | HOFFMAN   |
| WILLIAM    | HACKMAN   |
+------------+-----------+
6 rows in set (0.00 sec)</pre>

<p>So, which approach is preferable: nested or not nested? The<a data-type="indexterm" data-primary="performance" data-secondary="nested queries" id="idm46177470299656"/> answer isn’t easy. In terms of performance, the answer is usually <em>not</em>: nested queries are hard to optimize, so they’re almost always slower to run than the unnested alternative.</p>

<p>Does this mean you should avoid nesting? The answer is no: sometimes it’s your only choice if you want to write a single query, and sometimes nested queries can answer information needs that can’t be easily solved otherwise. What’s more, nested queries are expressive. Once you’re comfortable with the idea, they’re a very readable way to show how a query is evaluated. In fact, many SQL designers advocate teaching nested queries before the join-based alternatives we’ve shown you in the past few sections. We’ll show you examples where nesting is readable and powerful throughout this 
<span class="keep-together">section.</span></p>

<p>Before we begin to cover the keywords that can be used in nested queries, let’s take a look at an example that can’t be done easily in a single query—at least, not without MySQL’s nonstandard, although ubiquitous, <code>LIMIT</code> clause! <a data-type="indexterm" data-primary="date and time columns" data-secondary="most recent" id="idm46177470295432"/><a data-type="indexterm" data-primary="time and date columns" data-secondary="most recent" id="idm46177470294424"/><a data-type="indexterm" data-primary="nested queries" data-secondary="most recent item identified" id="idm46177470293480"/>Suppose you want to know what movie a customer rented most recently. To do this, following the methods we’ve learned previously, you could find the date and time of the most recently stored row in the <code>rental</code> table for that customer:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">MAX</code><code class="p">(</code><code class="n">rental_date</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">rental</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---------------------+
| MAX(rental_date)    |
+---------------------+
| 2005-08-23 15:46:33 |
+---------------------+
1 row in set (0.01 sec)</pre>

<p>You can then use the output as input to another query to find the film title:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">rental_date</code><code> </code><code class="o">=</code><code> </code><code class="s1">'2005-08-23 15:46:33'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-------------+
| title       |
+-------------+
| KARATE MOON |
+-------------+
1 row in set (0.00 sec)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In <a data-type="xref" href="#ADV1-SEC-VARIABLES">“User Variables”</a> we’ll show you how you can use variables to avoid having to type in the value in the second query.</p>
</div>

<p>With a nested query, you can do both steps in one shot:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">rental_date</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="nf">MAX</code><code class="p">(</code><code class="n">rental_date</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">rental</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting" class="less_space pagebreak-before">+-------------+
| title       |
+-------------+
| KARATE MOON |
+-------------+
1 row in set (0.01 sec)</pre>

<p>You can see the nested query combines the two previous queries. Rather than using the constant date and time value discovered from a previous query, it executes the query directly as a subquery. <a data-type="indexterm" data-primary="inner query in nested queries" data-secondary="scalar values" id="idm46177470058280"/><a data-type="indexterm" data-primary="subquery in nested queries" data-secondary="scalar values" id="idm46177470071528"/><a data-type="indexterm" data-primary="queries" data-secondary="scalar values" id="idm46177470070616"/><a data-type="indexterm" data-primary="nested queries" data-secondary="scalar values" id="idm46177470069672"/><a data-type="indexterm" data-primary="scalar values" id="idm46177470068728"/>This is the simplest type of nested query, one that returns a <em>scalar operand</em>--that is, a single value.<a data-type="indexterm" data-startref="ch05-nqb2" id="idm46177470067544"/></p>
<div data-type="tip"><h6>Tip</h6>
<p>The previous example used the equality operator (<code>=</code>). You can use all types of comparison operators: <code>&lt;</code> (less than), <code>&lt;=</code> (less than or equal to), <code>&gt;</code> (greater than), <code>&gt;=</code> (greater than or equal to), and <code>!=</code> (not equals) or <code>&lt;&gt;</code> (not equals).</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The ANY, SOME, ALL, IN, and NOT IN Clauses"><div class="sect2" id="ADV1-SEC-ANYANDFRIENDS">
<h2>The ANY, SOME, ALL, IN, and NOT IN Clauses</h2>

<p>Before we start to show some more advanced features of nested queries, we need to switch to a new database in our examples. Unfortunately, the <code>sakila</code> database is a little too well normalized to effectively demonstrate the full power of nested querying. So, let’s add a new database to give us something to play with.</p>

<p>The database we’ll install is the <code>employees</code> sample database.<a data-type="indexterm" data-primary="employees example database" data-secondary="installing and using" id="idm46177470023800"/> You can find instructions for installation in the <a href="https://oreil.ly/vODJG">MySQL documentation</a>  or in the database’s GitHub repo. Either clone the repository using <code>git</code> or download the latest release (<a href="https://oreil.ly/zW0E1">1.0.7</a> at the time of writing). Once you have the necessary files ready, you need to run two commands.</p>

<p>The first command creates the necessary structures and loads the data:</p>

<pre data-type="programlisting">$ <strong>mysql -uroot -p &lt; employees.sql</strong>
INFO
CREATING DATABASE STRUCTURE
INFO
storage engine: InnoDB
INFO
LOADING departments
INFO
LOADING employees
INFO
LOADING dept_emp
INFO
LOADING dept_manager
INFO
LOADING titles
INFO
LOADING salaries
data_load_time_diff
00:00:28</pre>

<p>The second command verifies the installation:</p>

<pre data-type="programlisting">$ <strong>mysql -uroot -p &lt; test_employees_md5.sql</strong>
INFO
TESTING INSTALLATION
table_name      expected_records        expected_crc
departments     9       d1af5e170d2d1591d776d5638d71fc5f
dept_emp        331603  ccf6fe516f990bdaa49713fc478701b7
dept_manager    24      8720e2f0853ac9096b689c14664f847e
employees       300024  4ec56ab5ba37218d187cf6ab09ce1aa1
salaries        2844047 fd220654e95aea1b169624ffe3fca934
titles  443308  bfa016c472df68e70a03facafa1bc0a8
table_name      found_records           found_crc
departments     9       d1af5e170d2d1591d776d5638d71fc5f
dept_emp        331603  ccf6fe516f990bdaa49713fc478701b7
dept_manager    24      8720e2f0853ac9096b689c14664f847e
employees       300024  4ec56ab5ba37218d187cf6ab09ce1aa1
salaries        2844047 fd220654e95aea1b169624ffe3fca934
titles  443308  bfa016c472df68e70a03facafa1bc0a8
table_name      records_match   crc_match
departments     OK      ok
dept_emp        OK      ok
dept_manager    OK      ok
employees       OK      ok
salaries        OK      ok
titles  OK      ok
computation_time
00:00:25
summary result
CRC     OK
count   OK</pre>

<p>Once this is done, you can proceed to work through the examples we’ll be providing next.</p>

<p>To connect to the new database, either run <code>mysql</code> from the command line like this (or specify <code>employees</code> as a target for your MySQL client of choice):</p>

<pre data-type="programlisting">$ <strong>mysql employees</strong></pre>

<p>Or execute the following at a <code>mysql</code> prompt to change the default database:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">USE</code><code> </code><code class="n">employees</code></strong></pre>

<p>Now you’re ready to move forward.</p>










<section data-type="sect3" data-pdf-bookmark="Using ANY and IN"><div class="sect3" id="idm46177470008936">
<h3>Using ANY and IN</h3>

<p>Now that you’ve created the sample tables, you can try an example using <code>ANY</code>. <a data-type="indexterm" data-primary="nested queries" data-secondary="ANY" id="idm46177470006824"/><a data-type="indexterm" data-primary="ANY in nested queries" id="idm46177470005816"/>Suppose you’re looking to find assistant engineers who’ve been working longer than the least experienced manager. You can express this information need as follows:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">hire_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Assistant Engineer'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">hire_date</code><code> </code><code class="o">&lt;</code><code> </code><code class="nf">ANY</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">hire_date</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+----------------+------------------+------------+
| emp_no | first_name     | last_name        | hire_date  |
+--------+----------------+------------------+------------+
|  10009 | Sumant         | Peac             | 1985-02-18 |
|  10066 | Kwee           | Schusler         | 1986-02-26 |
| ...                                                     |
| ...                                                     |
| 499958 | Srinidhi       | Theuretzbacher   | 1989-12-17 |
| 499974 | Shuichi        | Piazza           | 1989-09-16 |
+--------+----------------+------------------+------------+
10747 rows in set (0.20 sec)</pre>

<p>Turns out there are a lot of people who meet these criteria! The subquery finds the dates on which managers were hired:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">hire_date</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+
| hire_date  |
+------------+
| 1985-01-01 |
| 1986-04-12 |
| ...        |
| 1991-08-17 |
| 1989-07-10 |
+------------+
24 rows in set (0.10 sec)</pre>

<p>The outer query goes through each employee with the title <code>Associate Engineer</code>, returning the engineer if their hire date is lower (older) than any of the values in the set returned by the subquery. So, for example, <code>Sumant Peac</code> is output because <code>1985-02-18</code> is older than at least one value in the set (as you can see, the second hire date returned for managers is <code>1986-04-12</code>). The <code>ANY</code> keyword means just that: it’s true if the column or expression preceding it is true for <em>any</em> of the values in the set returned by the subquery. <a data-type="indexterm" data-primary="aliases" data-secondary="SOME as alias for ANY" id="idm46177469849800"/><a data-type="indexterm" data-primary="SOME as alias for ANY" id="idm46177469848824"/>Used in this way, <code>ANY</code> has the alias <code>SOME</code>, which was included so that some queries can be read more clearly as English expressions; it doesn’t do anything different, and you’ll rarely see it used.</p>

<p>The <code>ANY</code> keyword gives you more power in expressing nested queries. Indeed, the previous query is the first nested query in this section with<a data-type="indexterm" data-primary="inner query in nested queries" data-secondary="column subqueries" id="idm46177469846104"/><a data-type="indexterm" data-primary="subquery in nested queries" data-secondary="column subqueries" id="idm46177469845160"/><a data-type="indexterm" data-primary="nested queries" data-secondary="column subqueries" id="idm46177469828184"/><a data-type="indexterm" data-primary="columns" data-secondary="column subqueries" id="idm46177469827336"/> a <em>column subquery</em>—that is, the results returned by the subquery are one or more values from a column, instead of a single scalar value as in the previous section. With this, you can now compare a column value from an outer query to a set of values returned from a subquery.</p>

<p>Consider another example using <code>ANY</code>. Suppose you want to know the managers who also have some other title. You can do this with the following nested query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">emp_no</code><code> </code><code class="o">=</code><code> </code><code class="nf">ANY</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">FROM</code><code> </code><code class="n">employees</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code><code> </code><code class="k">WHERE</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">title</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+-------------+--------------+
| emp_no | first_name  | last_name    |
+--------+-------------+--------------+
| 110022 | Margareta   | Markovitch   |
| 110039 | Vishwani    | Minakawa     |
| ...                                 |
| 111877 | Xiaobin     | Spinelli     |
| 111939 | Yuchang     | Weedman      |
+--------+-------------+--------------+
24 rows in set (0.11 sec)</pre>

<p>The <code>= ANY</code> causes the outer query to return a manager when the <code>emp_no</code> is equal to any of the engineer employee numbers returned by the subquery. <a data-type="indexterm" data-primary="nested queries" data-secondary="ANY" data-tertiary="IN as alias" id="idm46177472989384"/><a data-type="indexterm" data-primary="IN as alias for ANY" id="idm46177469762600"/><a data-type="indexterm" data-primary="ANY in nested queries" data-secondary="IN as alias" id="idm46177469761928"/>The <code>= ANY</code> keyphrase has the alias <code>IN</code>, which you’ll see commonly used in nested queries. Using <code>IN</code>, the previous example can be rewritten as:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">IN</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">FROM</code><code> </code><code class="n">employees</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code><code> </code><code class="k">WHERE</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">title</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+-------------+--------------+
| emp_no | first_name  | last_name    |
+--------+-------------+--------------+
| 110022 | Margareta   | Markovitch   |
| 110039 | Vishwani    | Minakawa     |
| ...                                 |
| 111877 | Xiaobin     | Spinelli     |
| 111939 | Yuchang     | Weedman      |
+--------+-------------+--------------+
24 rows in set (0.11 sec)</pre>

<p>Of course, for this particular example, you could also have used a join query. Note that we have to use <code>DISTINCT</code> here, because otherwise we get 30 rows returned. Some people hold more than one non-engineer title:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="k">DISTINCT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="n">mgr</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="n">nonmgr</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">mgr</code><code class="p">.</code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">nonmgr</code><code class="p">.</code><code class="n">title</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="s1">'Manager'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+-------------+--------------+
| emp_no | first_name  | last_name    |
+--------+-------------+--------------+
| 110022 | Margareta   | Markovitch   |
| 110039 | Vishwani    | Minakawa     |
| ...                                 |
| 111877 | Xiaobin     | Spinelli     |
| 111939 | Yuchang     | Weedman      |
+--------+-------------+--------------+
24 rows in set (0.11 sec)</pre>

<p>Again, nested queries are expressive but typically slow in MySQL, so use a join where you can.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Using ALL"><div class="sect3" id="idm46177470008344">
<h3>Using ALL</h3>

<p>Suppose you want to find assistant engineers who are more<a data-type="indexterm" data-primary="nested queries" data-secondary="ALL" id="idm46177469570488"/><a data-type="indexterm" data-primary="ALL for nested queries" id="idm46177469569608"/> experienced than all of the managers—that is, more experienced than the most experienced manager. You can do this with the <code>ALL</code> keyword in place of <code>ANY</code>:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">hire_date</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Assistant Engineer'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">hire_date</code><code> </code><code class="o">&lt;</code><code> </code><code class="k">ALL</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">hire_date</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Empty set (0.18 sec)</pre>

<p>You can see that there are no answers. We can inspect the data further to check what is the oldest hire date of a manager and of an assistant engineer:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="s1">'Assistant Engineer'</code><code> </code><code class="k">AS</code><code> </code><code class="n">title</code><code class="p">,</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="nf">MIN</code><code class="p">(</code><code class="n">hire_date</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">mhd</code><code> </code><code class="k">FROM</code><code> </code><code class="n">employees</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Assistant Engineer'</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">UNION</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="s1">'Manager'</code><code> </code><code class="n">title</code><code class="p">,</code><code> </code><code class="nf">MIN</code><code class="p">(</code><code class="n">hire_date</code><code class="p">)</code><code> </code><code class="n">mhd</code><code> </code><code class="k">FROM</code><code> </code><code class="n">employees</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting" class="less_space pagebreak-before">+--------------------+------------+
| title              | mhd        |
+--------------------+------------+
| Assistant Engineer | 1985-02-01 |
| Manager            | 1985-01-01 |
+--------------------+------------+
2 rows in set (0.26 sec)</pre>

<p>Looking at the data, we see that the first manager was hired on January 1, 1985, and the first assistant engineer only on February 1 of the same year. While the <code>ANY</code> keyword returns values that satisfy at least one condition (Boolean OR), the <code>ALL</code> keyword returns values only where all the conditions are satisfied (Boolean AND).</p>

<p>We can use the alias <code>NOT IN</code> in place of <code>&lt;&gt; ANY</code> or <code>!= ANY</code>. Let’s find all the managers who aren’t senior staff:<a data-type="indexterm" data-primary="nested queries" data-secondary="NOT IN" id="idm46177469357736"/><a data-type="indexterm" data-primary="NOT operator" data-secondary="nested queries" data-tertiary="NOT IN" id="idm46177469356760"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code><code> </code><code class="k">AND</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">NOT</code><code> </code><code class="k">IN</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">FROM</code><code> </code><code class="n">titles</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Senior Staff'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+-------------+--------------+
| emp_no | first_name  | last_name    |
+--------+-------------+--------------+
| 110183 | Shirish     | Ossenbruggen |
| 110303 | Krassimir   | Wegerle      |
| ...                                 |
| 111400 | Arie        | Staelin      |
| 111692 | Tonny       | Butterworth  |
+--------+-------------+--------------+
15 rows in set (0.09 sec)</pre>

<p>As an exercise, try writing this query using the <code>ANY</code> syntax and as a join query.</p>

<p>The <code>ALL</code> keyword has a few tricks and traps:<a data-type="indexterm" data-primary="nested queries" data-secondary="ALL" data-tertiary="tricks and traps" id="idm46177469261704"/></p>

<ul>
<li>
<p>If it’s false for any value, it’s false. Suppose that table <code>a</code> contains a row with the value 14, and table <code>b</code> contains the values 16, 1, and <code>NULL</code>. If you check whether the value in <code>a</code> is greater than <code>ALL</code> values in <code>b</code>, you’ll get <code>false</code>, since 14 isn’t greater than 16. It doesn’t matter that the other values are 1 and <code>NULL</code>.</p>
</li>
<li>
<p>If it isn’t false for any value, it isn’t true unless it’s true for all values. Suppose that table <code>a</code> again contains 14, and <code>b</code> contains 1 and <code>NULL</code>. If you check whether the value in <code>a</code> is greater than <code>ALL</code> values in <code>b</code>, you’ll get <code>UNKNOWN</code> (neither true nor false) because it can’t be determined whether <code>NULL</code> is greater than or less than 14.</p>
</li>
<li>
<p>If the table in the subquery is empty, the result is always true. Hence, if <code>a</code> contains 14 and <code>b</code> is empty, you’ll get <code>true</code> when you check if the value in <code>a</code> is greater than <code>ALL</code> values in <code>b</code>.</p>
</li>
</ul>

<p>When using the <code>ALL</code> keyword, be very careful with tables that can have <code>NULL</code> values in columns; consider disallowing <code>NULL</code> values in such cases. Also, be careful with empty tables.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Writing row subqueries"><div class="sect3" id="idm46177469571208">
<h3>Writing row subqueries</h3>

<p>In the previous examples, the subquery returned a single scalar<a data-type="indexterm" data-primary="inner query in nested queries" data-secondary="row subqueries" id="idm46177469211400"/><a data-type="indexterm" data-primary="subquery in nested queries" data-secondary="row subqueries" id="idm46177469210552"/><a data-type="indexterm" data-primary="nested queries" data-secondary="row subqueries" id="idm46177469209704"/><a data-type="indexterm" data-primary="rows" data-secondary="row subqueries" id="idm46177469208856"/> value (such as an <code>actor_id</code>) or a set of values from one column (such as all of the <code>emp_no</code> values). This section describes another type of subquery, the <em>row subquery</em>, that works with multiple columns from multiple rows.</p>

<p>Suppose you’re interested in whether a manager had another position within the same calendar year. To answer this need, you must match both the employee number and the title assignment date, or, more precisely, year. You can write this as a join:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">mgr</code><code class="p">.</code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="kt">YEAR</code><code class="p">(</code><code class="n">mgr</code><code class="p">.</code><code class="n">from_date</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">fd</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">titles</code><code> </code><code class="k">AS</code><code> </code><code class="n">mgr</code><code class="p">,</code><code> </code><code class="n">titles</code><code> </code><code class="k">AS</code><code> </code><code class="n">other</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">mgr</code><code class="p">.</code><code class="n">emp_no</code><code> </code><code class="o">=</code><code> </code><code class="n">other</code><code class="p">.</code><code class="n">emp_no</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">mgr</code><code class="p">.</code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">mgr</code><code class="p">.</code><code class="n">title</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="n">other</code><code class="p">.</code><code class="n">title</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="kt">YEAR</code><code class="p">(</code><code class="n">mgr</code><code class="p">.</code><code class="n">from_date</code><code class="p">)</code><code> </code><code class="o">=</code><code> </code><code class="kt">YEAR</code><code class="p">(</code><code class="n">other</code><code class="p">.</code><code class="n">from_date</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+------+
| emp_no | fd   |
+--------+------+
| 110765 | 1989 |
| 111784 | 1988 |
+--------+------+
2 rows in set (0.11 sec)</pre>

<p>But you can also write it as a nested query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="kt">YEAR</code><code class="p">(</code><code class="n">from_date</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">fd</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">titles</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code><code> </code><code class="k">AND</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="kt">YEAR</code><code class="p">(</code><code class="n">from_date</code><code class="p">)</code><code class="p">)</code><code> </code><code class="k">IN</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="kt">YEAR</code><code class="p">(</code><code class="n">from_date</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">titles</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+------+
| emp_no | fd   |
+--------+------+
| 110765 | 1989 |
| 111784 | 1988 |
+--------+------+
2 rows in set (0.12 sec)</pre>

<p>You can see there’s a different syntax being used in this nested query: a list of two column names in parentheses follows the <code>WHERE</code> statement, and the inner query returns two columns. We’ll explain this syntax next.</p>

<p>The row subquery syntax allows you to compare multiple values per row. The expression <code>(emp_no, YEAR(from_date))</code> means two values per row are compared to the output of the subquery. You can see following the <code>IN</code> keyword that the subquery returns two values, <code>emp_no</code> and <code>YEAR(from_date)</code>. So, the fragment:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="p">(</code><code class="n">emp_no</code><code class="p">,</code> <code class="kt">YEAR</code><code class="p">(</code><code class="n">from_date</code><code class="p">))</code> <code class="k">IN</code> <code class="p">(</code><code class="k">SELECT</code> <code class="n">emp_no</code><code class="p">,</code> <code class="kt">YEAR</code><code class="p">(</code><code class="n">from_date</code><code class="p">)</code>
<code class="k">FROM</code> <code class="n">titles</code> <code class="k">WHERE</code> <code class="n">title</code> <code class="o">&lt;&gt;</code> <code class="s1">'Manager'</code><code class="p">)</code></pre>

<p>matches manager numbers and starting years to nonmanager numbers and starting years, and returns a true value when a match is found. The result is that if a matching pair is found, the overall query outputs a result. This is a typical row subquery: it finds rows that exist in two tables.</p>

<p>To explain the syntax further, let’s consider another example. Suppose you want to see if a particular employee is a senior staff member. You can do this with the following query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code class="p">,</code><code> </code><code class="n">titles</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="p">(</code><code class="n">employees</code><code class="p">.</code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code><code> </code><code class="n">title</code><code class="p">)</code><code> </code><code class="o">=</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="n">titles</code><code class="p">.</code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="s1">'Marjo'</code><code class="p">,</code><code> </code><code class="s1">'Giarratana'</code><code class="p">,</code><code> </code><code class="s1">'Senior Staff'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+------------+
| first_name | last_name  |
+------------+------------+
| Marjo      | Giarratana |
+------------+------------+
1 row in set (0.09 sec)</pre>

<p>It’s not a nested query, but it shows you how the new row subquery syntax works. You can see that the query matches the list of columns before the equals sign, <code>(employees.emp_no, first_name, last_name, title)</code>, to the list of columns and values after the equals sign, <code>(titles.emp_no, 'Marjo', 'Giarratana', 'Senior Staff')</code>. So, when the <code>emp_no</code> values match, the employee’s full name is <code>Marjo</code> 
<span class="keep-together"><code>Giarratana</code>,</span> and the title is <code>Senior Staff</code>, we get output from the query. We don’t recommend writing queries like this—use a regular <code>WHERE</code> clause with multiple <code>AND</code> conditions instead—but it does illustrate exactly what’s going on. For an exercise, try writing this query using a join.</p>

<p>Row subqueries require that the number, order, and type of values in the columns match. So, for example, our previous example matches an <code>INT</code> to an <code>INT</code>, and two character strings to two character strings.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="The EXISTS and NOT EXISTS Clauses"><div class="sect2" id="ADV1-SEC-EXISTS">
<h2>The EXISTS and NOT EXISTS Clauses</h2>

<p>You’ve now seen three types of subquery: scalar subqueries,<a data-type="indexterm" data-primary="nested queries" data-secondary="EXISTS and NOT EXISTS" id="ch05-ene"/><a data-type="indexterm" data-primary="nested queries" data-secondary="correlated subqueries" id="idm46177468864152"/><a data-type="indexterm" data-primary="correlated subqueries" id="idm46177468863416"/><a data-type="indexterm" data-primary="EXISTS and NOT EXISTS" id="ch05-ene2"/><a data-type="indexterm" data-primary="NOT operator" data-secondary="nested queries" data-tertiary="NOT EXISTS" id="ch05-ene3"/> column subqueries, and row subqueries. In this section, you’ll learn about a fourth type, the <em>correlated subquery</em>, where a table used in the outer query is referenced in the subquery. Correlated subqueries are often used with the <code>IN</code> statement we’ve already discussed and almost always used with the <code>EXISTS</code> and <code>NOT EXISTS</code> clauses that are the focus of this section.</p>










<section data-type="sect3" data-pdf-bookmark="EXISTS and NOT EXISTS basics"><div class="sect3" id="idm46177468858728">
<h3>EXISTS and NOT EXISTS basics</h3>

<p>Before we start on our discussion of correlated subqueries, let’s investigate what the <code>EXISTS</code> clause does. We’ll need a simple but strange example to introduce the clause, since we’re not discussing correlated subqueries just yet. So, here goes: suppose you want to find a count of all films in the database, but only if the database is active, which you’ve defined to mean only if at least one movie from any branch has been rented. Here’s the query that does it (don’t forget to connect to the <code>sakila</code> database again before running this query—hint: use the <code>use &lt;db&gt;</code> command):</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="k">EXISTS</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">rental</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------+
| COUNT(*) |
+----------+
|     1000 |
+----------+
1 row in set (0.01 sec)</pre>

<p>The subquery returns all rows from the <code>rental</code> table. However, what’s important is that it returns at least one row; it doesn’t matter what’s in the row, how many rows there are, or whether the row contains only <code>NULL</code> values. So, you can think of the subquery as being true or false, and in this case it’s true because it produces some output. When the subquery is true, the outer query that uses the <code>EXISTS</code> clause returns a row. The overall result is that all rows in the <code>film</code> table are counted because, for each one, the subquery is true.</p>

<p>Let’s try a query where the subquery isn’t true. Again, let’s contrive a query: this time, we’ll output the names of all films in the database, but only if a particular film exists. Here’s the query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="k">EXISTS</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'IS THIS A MOVIE?'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Empty set (0.00 sec)</pre>

<p>Since the subquery isn’t true—no rows are returned because <code>IS THIS A MOVIE?</code> isn’t in our database—no results are returned by the outer query.</p>

<p>The <code>NOT EXISTS</code> clause does the opposite. Imagine you want a list of all actors if you <em>don’t</em> have a particular movie in the database. Here it is:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">actor</code><code> </code><code class="k">WHERE</code><code> </code><code class="k">NOT</code><code> </code><code class="k">EXISTS</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'ZHIVAGO CORE'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Empty set (0.00 sec)</pre>

<p>This time, the inner query is true, but the <code>NOT EXISTS</code> clause negates it to give false. Since it’s false, the outer query doesn’t produce results.</p>

<p>You’ll notice that the subquery begins with <code>SELECT * FROM film</code>. It doesn’t actually matter what you select in an inner query when you’re using the <code>EXISTS</code> clause, since it’s not used by the outer query anyway. You can select one column, everything, or even a constant (as in <code>SELECT 'cat' from film</code>), and it’ll have the same effect. Traditionally, though, you’ll see most SQL authors write <code>SELECT</code> <code>*</code> by convention.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Correlated subqueries"><div class="sect3" id="idm46177468858200">
<h3>Correlated subqueries</h3>

<p>So far, it’s probably difficult to imagine what you’d do with the<a data-type="indexterm" data-primary="nested queries" data-secondary="correlated subqueries" id="idm46177468709080"/><a data-type="indexterm" data-primary="correlated subqueries" id="idm46177468706808"/> <code>EXISTS</code> and <code>NOT EXISTS</code> clauses. This section shows you how they’re really used, illustrating the most advanced type of nested query that you’ll typically see in action.</p>

<p>Let’s think about the realistic kinds of information you might want from the <code>sakila</code> database. Suppose you want a list of all employees who’ve rented something from our company, or are just customers. You can do this easily with a join query, which we recommend you try to think about before you continue. You can also do it with the following nested query that uses a correlated subquery:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">staff</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="k">EXISTS</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">customer</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">customer</code><code class="p">.</code><code class="n">first_name</code><code> </code><code class="o">=</code><code> </code><code class="n">staff</code><code class="p">.</code><code class="n">first_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">customer</code><code class="p">.</code><code class="n">last_name</code><code> </code><code class="o">=</code><code> </code><code class="n">staff</code><code class="p">.</code><code class="n">last_name</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Empty set (0.01 sec)</pre>

<p>There’s no output because nobody from the staff is also a customer (or that’s forbidden, but we’ll bend the rules). Let’s add a customer with the same details as one of the staff members:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="nf">customer</code><code class="p">(</code><code class="n">store_id</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code class="p">,</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">email</code><code class="p">,</code><code> </code><code class="n">address_id</code><code class="p">,</code><code> </code><code class="n">create_date</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">VALUES</code><code> </code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code> </code><code class="s1">'Mike'</code><code class="p">,</code><code> </code><code class="s1">'Hillyer'</code><code class="p">,</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="s1">'Mike.Hillyer@sakilastaff.com'</code><code class="p">,</code><code> </code><code class="mi">3</code><code class="p">,</code><code> </code><code class="nf">NOW</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.02 sec)</pre>

<p>And try the query again:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">staff</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="k">EXISTS</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">customer</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">customer</code><code class="p">.</code><code class="n">first_name</code><code> </code><code class="o">=</code><code> </code><code class="n">staff</code><code class="p">.</code><code class="n">first_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">customer</code><code class="p">.</code><code class="n">last_name</code><code> </code><code class="o">=</code><code> </code><code class="n">staff</code><code class="p">.</code><code class="n">last_name</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+-----------+
| first_name | last_name |
+------------+-----------+
| Mike       | Hillyer   |
+------------+-----------+
1 row in set (0.00 sec)</pre>

<p>So, the query works; now, we just need to understand how!</p>

<p>Let’s examine the subquery in our previous example. You can see that it lists only the <code>customer</code> table in the <code>FROM</code> clause, but it uses a column from the <code>staff</code> table in the <code>WHERE</code> clause. If you run it in isolation, you’ll see this isn’t allowed:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">customer</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">customer</code><code class="p">.</code><code class="n">first_name</code><code> </code><code class="o">=</code><code> </code><code class="n">staff</code><code class="p">.</code><code class="n">first_name</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">ERROR 1054 (42S22): Unknown column 'staff.first_name' in 'where clause'</pre>

<p>However, it’s legal when executed as a subquery because tables listed in the outer query are allowed to be accessed in the subquery. So, in this example, the current value of <code>staff.first_name</code> and <code>staff.last_name</code> in the outer query is supplied to the subquery as a constant, scalar value and compared to the customer’s first and last names. If the customer’s name matches the staff member’s name, the subquery is true, and so the outer query outputs a row. Consider two cases that illustrate this more clearly:</p>

<ul>
<li>
<p>When the <code>first_name</code> and <code>last_name</code> being processed by the outer query are <code>Jon</code> and <code>Stephens</code>, the subquery is false because <code>SELECT * FROM customer WHERE first_name = 'Jon' and last_name = 'Stephens';</code> doesn’t return any rows, and so the staff row for Jon Stephens isn’t output as an answer.</p>
</li>
<li>
<p>When the <code>first_name</code> and <code>last_name</code> being processed by the outer query are <code>Mike</code> and <code>Hillyer</code>, the subquery is true because <code>SELECT * FROM customer WHERE first_name = 'Mike' and last_name = 'Hillyer';</code> returns at least one row. Overall, the staff row for Mike Hillyer is returned.</p>
</li>
</ul>

<p>Can you see the power of correlated subqueries? You can use values from the outer query in the inner query to evaluate complex information needs.</p>

<p>We’ll now explore another example using <code>EXISTS</code>. Let’s try to find a count of all films of which we own at least two copies. To do this with <code>EXISTS</code>, we need to think through what the inner and outer queries should do. The inner query should produce a result only when the condition we’re checking is true; in this case, it should produce output when there are at least two rows in the inventory for the same film. The outer query should increment the counter whenever the inner query is true. Here’s the query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">WHERE</code><code> </code><code class="k">EXISTS</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">film_id</code><code> </code><code class="k">FROM</code><code> </code><code class="n">inventory</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">inventory</code><code class="p">.</code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="n">film</code><code class="p">.</code><code class="n">film_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">film_id</code><code> </code><code class="k">HAVING</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code><code> </code><code class="o">&gt;</code><code class="o">=</code><code> </code><code class="mi">2</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----------+
| COUNT(*) |
+----------+
|      958 |
+----------+
1 row in set (0.00 sec)</pre>

<p>This is yet another query where nesting isn’t necessary and a join would suffice, but let’s stick with this version for the purpose of explanation. Have a look at the inner query: you can see that the <code>WHERE</code> clause ensures that films match by the unique <code>film_id</code>, and only matching rows for the current film are considered by the subquery. The <code>GROUP BY</code> clause clusters the rows for that film, but only if there are at least two entries in the inventory. Therefore, the inner query produces output only when there are at least two rows for the current film in our inventory. The outer query is straightforward: it can be thought of as incrementing a counter when the subquery produces output.</p>

<p>Here’s one more example before we move on and discuss other issues. This example will be in the <code>employees</code> database, so switch your client. We’ve already shown you a query that uses <code>IN</code> and finds managers who also had some other position:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">IN</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">FROM</code><code> </code><code class="n">employees</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code><code> </code><code class="k">WHERE</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">title</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+-------------+--------------+
| emp_no | first_name  | last_name    |
+--------+-------------+--------------+
| 110022 | Margareta   | Markovitch   |
| 110039 | Vishwani    | Minakawa     |
| ...                                 |
| 111877 | Xiaobin     | Spinelli     |
| 111939 | Yuchang     | Weedman      |
+--------+-------------+--------------+
24 rows in set (0.11 sec)</pre>

<p>Let’s rewrite the query to use <code>EXISTS</code>. First, think about the subquery: it should produce output when there’s a <code>title</code> record for an employee with the same name as a manager.</p>

<p>Second, think about the outer query: it should return the employee’s name when the inner query produces output. Here’s the rewritten query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="k">EXISTS</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">FROM</code><code> </code><code class="n">titles</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">titles</code><code class="p">.</code><code class="n">emp_no</code><code> </code><code class="o">=</code><code> </code><code class="n">employees</code><code class="p">.</code><code class="n">emp_no</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">title</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+-------------+--------------+
| emp_no | first_name  | last_name    |
+--------+-------------+--------------+
| 110022 | Margareta   | Markovitch   |
| 110039 | Vishwani    | Minakawa     |
| ...                                 |
| 111877 | Xiaobin     | Spinelli     |
| 111939 | Yuchang     | Weedman      |
+--------+-------------+--------------+
24 rows in set (0.09 sec)</pre>

<p>Again, you can see that the subquery references the <code>emp_no</code> column, which comes from the outer query.</p>

<p>Correlated subqueries can be used with any nested query type. Here’s the previous <code>IN</code> query rewritten with an outer reference:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">IN</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">FROM</code><code> </code><code class="n">titles</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">titles</code><code class="p">.</code><code class="n">emp_no</code><code> </code><code class="o">=</code><code> </code><code class="n">employees</code><code class="p">.</code><code class="n">emp_no</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">title</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+-------------+--------------+
| emp_no | first_name  | last_name    |
+--------+-------------+--------------+
| 110022 | Margareta   | Markovitch   |
| 110039 | Vishwani    | Minakawa     |
| ...                                 |
| 111877 | Xiaobin     | Spinelli     |
| 111939 | Yuchang     | Weedman      |
+--------+-------------+--------------+
24 rows in set (0.09 sec)</pre>

<p>The query is more convoluted than it needs to be, but it illustrates the idea. You can see that the <code>emp_no</code> in the subquery references the <code>employees</code> table from the outer query.</p>

<p>If the query would return a single row, it can also be rewritten to use an equals instead of <code>IN</code>:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">emp_no</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">FROM</code><code> </code><code class="n">titles</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">titles</code><code class="p">.</code><code class="n">emp_no</code><code> </code><code class="o">=</code><code> </code><code class="n">employees</code><code class="p">.</code><code class="n">emp_no</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">title</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="s1">'Manager'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">ERROR 1242 (21000): Subquery returns more than 1 row</pre>

<p>This doesn’t work in this case because the subquery returns more than one scalar value. Let’s narrow it down:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">first_name</code><code class="p">,</code><code> </code><code class="n">last_name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">employees</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">titles</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">emp_no</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Manager'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">emp_no</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code> </code><code class="k">FROM</code><code> </code><code class="n">titles</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">titles</code><code class="p">.</code><code class="n">emp_no</code><code> </code><code class="o">=</code><code> </code><code class="n">employees</code><code class="p">.</code><code class="n">emp_no</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">title</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Senior Engineer'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+------------+-----------+
| emp_no | first_name | last_name |
+--------+------------+-----------+
| 110344 | Rosine     | Cools     |
| 110420 | Oscar      | Ghazalie  |
| 110800 | Sanjoy     | Quadeer   |
+--------+------------+-----------+
3 rows in set (0.10 sec)</pre>

<p>It works now—there’s only one manager and senior engineer title with each name—so the column subquery operator <code>IN</code> isn’t necessary. Of course, if titles are duplicated (for example, if a person switches back and forth between positions), you’d need to use <code>IN</code>, <code>ANY</code>, or <code>ALL</code> instead.<a data-type="indexterm" data-startref="ch05-ene" id="idm46177467875944"/><a data-type="indexterm" data-startref="ch05-ene2" id="idm46177467875208"/><a data-type="indexterm" data-startref="ch05-ene3" id="idm46177467874536"/></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Nested Queries in the FROM Clause"><div class="sect2" id="ADV1-SEC-NESTEDFROM">
<h2>Nested Queries in the FROM Clause</h2>

<p>The techniques we’ve shown all use nested queries in the<a data-type="indexterm" data-primary="nested queries" data-secondary="FROM clause" id="idm46177467873000"/><a data-type="indexterm" data-primary="FROM clause nested queries" id="idm46177467872024"/> <code>WHERE</code> clause. This section shows you how they can alternatively be used in the <code>FROM</code> clause. This is useful when you want to manipulate the source of the data you’re using in a query.</p>

<p>In the <code>employees</code> database, the <code>salaries</code> table stores the annual wage alongside the employee ID. If you want to find the monthly rate, for example, you can do some math in the query. One option in this case is to do it with a subquery:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">monthly_salary</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">salary</code><code class="o">/</code><code class="mi">12</code><code> </code><code class="k">AS</code><code> </code><code class="n">monthly_salary</code><code> </code><code class="k">FROM</code><code> </code><code class="n">salaries</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">ms</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+----------------+
| emp_no | monthly_salary |
+--------+----------------+
|  10001 |      5009.7500 |
|  10001 |      5175.1667 |
|  10001 |      5506.1667 |
|  10001 |      5549.6667 |
|  10001 |      5580.0833 |
+--------+----------------+
5 rows in set (0.00 sec)</pre>

<p id="DERIVED-TABLE">Focus on what follows the <code>FROM</code> clause. The subquery uses the <code>salaries</code> table and returns two columns: the first column is the <code>emp_no</code>; the second column is aliased as <code>monthly_salary</code> and is the <code>salary</code> value divided by 12. The outer query is straightforward: it just returns the <code>emp_no</code> and the <code>monthly_salary</code> value created through the subquery. Note that we’ve added the table alias <code>ms</code> for the subquery. When we use a subquery as a table—that is, we use a <code>SELECT FROM</code> operation on it—this “derived table” must have an alias, even if we don’t use the alias in our query. MySQL complains if we omit the alias:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">monthly_salary</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">emp_no</code><code class="p">,</code><code> </code><code class="n">salary</code><code class="o">/</code><code class="mi">12</code><code> </code><code class="k">AS</code><code> </code><code class="n">monthly_salary</code><code> </code><code class="k">FROM</code><code> </code><code class="n">salaries</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LIMIT</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">ERROR 1248 (42000): Every derived table must have its own alias</pre>

<p>Here’s another example, now in the <code>sakila</code> database. Suppose we want to find out the average sum a film brings us through rentals, or the average gross, as we’ll call it. Let’s begin by thinking through the subquery. It should return the sum of payments that we have for each film. Then, the outer query should average the values to give the answer. Here’s the query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">AVG</code><code class="p">(</code><code class="n">gross</code><code class="p">)</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="nf">SUM</code><code class="p">(</code><code class="n">amount</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">gross</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">payment</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">rental_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">film_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">gross_amount</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------+
| AVG(gross) |
+------------+
|  70.361754 |
+------------+
1 row in set (0.05 sec)</pre>

<p>You can see that the inner query joins together <code>payment</code>, <code>rental</code>, <code>inventory</code>, and <code>film</code>, and groups the sales together by film so you can get a sum for each film. If you run it in isolation, here’s what happens:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">SUM</code><code class="p">(</code><code class="n">amount</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">gross</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">payment</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">rental_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">film_id</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+--------+
| gross  |
+--------+
|  36.77 |
|  52.93 |
|  37.88 |
|    ... |
|  14.91 |
|  73.83 |
| 214.69 |
+--------+
958 rows in set (0.08 sec)</pre>

<p>Now, the outer query takes these sums—which are aliased as <code>gross</code>--and averages them to give the final result. This query is the typical way that you apply two aggregate functions to one set of data. You can’t apply aggregate functions in a cascade, as in <code>AVG(SUM(amount))</code>:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">AVG</code><code class="p">(</code><code class="nf">SUM</code><code class="p">(</code><code class="n">amount</code><code class="p">)</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">avg_gross</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">payment</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">rental_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">film</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code><code> </code><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">film_id</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">ERROR 1111 (HY000): Invalid use of group function</pre>

<p>With subqueries in <code>FROM</code> clauses, you can return a scalar value, a set of column values, more than one row, or even a whole table. However, you can’t use correlated subqueries, meaning that you can’t reference tables or columns from tables that aren’t explicitly listed in the subquery. Note also that you must alias the whole subquery using the <code>AS</code> keyword and give it a name, even if you don’t use that name anywhere in the query.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Nested Queries in JOINs"><div class="sect2" id="ADV1-SEC-NESTEDJOIN">
<h2>Nested Queries in JOINs</h2>

<p>The last use of nested queries we’ll show, but not the least<a data-type="indexterm" data-primary="nested queries" data-secondary="joins using" id="idm46177467485896"/><a data-type="indexterm" data-primary="joins" data-secondary="nested queries" id="idm46177467484920"/><a data-type="indexterm" data-primary="left joins" data-secondary="nested queries" id="idm46177467483976"/> useful, is using them in joins. In this use case, the results of the subquery basically form a new table and can be used in any of the join types we have discussed.</p>

<p>For an example of this, let’s go back to the query that listed the number of films from each of the categories a particular customer has rented. Remember, we had an issue writing that query using just joins: we didn’t get a zero count for categories from which our customer didn’t rent. This was the query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">cat</code><code class="p">.</code><code class="n">name</code><code> </code><code class="k">AS</code><code> </code><code class="n">category_name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">cat</code><code class="p">.</code><code class="n">category_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">category</code><code> </code><code class="k">AS</code><code> </code><code class="n">cat</code><code> </code><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="k">AS</code><code> </code><code class="n">cs</code><code> </code><code class="k">ON</code><code> </code><code class="n">rental</code><code class="p">.</code><code class="n">customer_id</code><code> </code><code class="o">=</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">customer_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">category_name</code><code> </code><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">cnt</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-------------+-----+
| name        | cnt |
+-------------+-----+
| Games       |   9 |
| Foreign     |   6 |
| ...               |
| ...               |
| Comedy      |   1 |
| Sports      |   1 |
+-------------+-----+
14 rows in set (0.00 sec)</pre>

<p>Now that we know about subqueries and joins and that subqueries can be used in joins, we can easily finish the task. This is our new query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">cat</code><code class="p">.</code><code class="n">name</code><code> </code><code class="k">AS</code><code> </code><code class="n">category_name</code><code class="p">,</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">category</code><code> </code><code class="k">AS</code><code> </code><code class="n">cat</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">cat</code><code class="p">.</code><code class="n">name</code><code class="p">,</code><code> </code><code class="nf">COUNT</code><code class="p">(</code><code class="n">cat</code><code class="p">.</code><code class="n">category_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">cnt</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code>    </code><strong><code class="k">FROM</code><code> </code><code class="n">category</code><code> </code><code class="k">AS</code><code> </code><code class="n">cat</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code>    </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">film_category</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">category_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code>    </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code>    </code><strong><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code>    </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="n">cs</code><code> </code><code class="k">ON</code><code> </code><code class="n">rental</code><code class="p">.</code><code class="n">customer_id</code><code> </code><code class="o">=</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">customer_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code>    </code><strong><code class="k">WHERE</code><code> </code><code class="n">cs</code><code class="p">.</code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code>    </code><strong><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">cat</code><code class="p">.</code><code class="n">name</code><code class="p">)</code><code> </code><code class="n">customer_cat</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">name</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">cnt</code><code> </code><code class="k">DESC</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-------------+------+
| name        | cnt  |
+-------------+------+
| Games       |    9 |
| Foreign     |    6 |
| ...                |
| Children    |    1 |
| Sports      |    1 |
| Sci-Fi      | NULL |
| Action      | NULL |
| Thriller    | NULL |
+-------------+------+
17 rows in set (0.01 sec)</pre>

<p>Finally, we get all the categories displayed, and we get <code>NULL</code> values for those where no rentals were made. Let’s review what’s going on in our new query. The subquery, which we aliased as <code>customer_cat</code>, is our previous query without the <code>ORDER BY</code> clause. Thus, we know what it will return: 14 rows for categories in which Wesley rented something, and the number of rentals in each. Next, use <code>LEFT JOIN</code> to concatenate that information to the full list of categories from the <code>category</code> table. The <code>category</code> table is driving the join, so it’ll have every row selected. We join the subquery using the <code>name</code> column that matches between the subquery’s output and the <code>category</code> table’s column.</p>

<p>The technique we showed here is a very powerful one; however, as always with subqueries, it comes at a cost. MySQL cannot optimize the whole query as efficiently when a subquery is present in the join clause.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="User Variables"><div class="sect1" id="ADV1-SEC-VARIABLES">
<h1>User Variables</h1>

<p>Often you’ll want to save values that are returned from queries.<a data-type="indexterm" data-primary="queries" data-secondary="user variables" id="ch05-uv2"/><a data-type="indexterm" data-primary="user variables in queries" id="ch05-uv"/><a data-type="indexterm" data-primary="variables" data-secondary="user variables in queries" id="ch05-uv3"/> You might want to do this so that you can easily use a value in a later query. You might also simply want to save a result for later display. In both cases, user variables solve the problem: they allow you to store a result and use it later.</p>

<p>Let’s illustrate user variables with a simple example. The following query finds the title of a film and saves the result in a user variable:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">@</code><code class="n">film</code><code class="p">:</code><code class="o">=</code><code class="n">title</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------------+
| @film:=title     |
+------------------+
| ACADEMY DINOSAUR |
+------------------+
1 row in set, 1 warning (0.00 sec)</pre>

<p>The user variable is named <code>film</code>, and it’s denoted as a user variable by the <code>@</code> character that precedes it. The value is assigned using the <code>:=</code> operator. You can print out the contents of the user variable with the following very short query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">@</code><code class="n">film</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------------+
| @film            |
+------------------+
| ACADEMY DINOSAUR |
+------------------+
1 row in set (0.00 sec)</pre>

<p>You may have noticed the warning—what was that about?</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">@</code><code class="n">film</code><code class="p">:</code><code class="o">=</code><code class="n">title</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong><code>
</code><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SHOW</code><code> </code><code class="n">WARNINGS</code><code class="err">\</code><code class="n">G</code></strong></pre>

<pre data-type="programlisting">*************************** 1. row ***************************
  Level: Warning
   Code: 1287
Message: Setting user variables within expressions is deprecated
and will be removed in a future release. Consider alternatives:
'SET variable=expression, ...', or
'SELECT expression(s) INTO variables(s)'.
1 row in set (0.00 sec)</pre>

<p>Let’s cover the two alternatives proposed. First, we can still execute a nested query within a <code>SET</code> statement:<a data-type="indexterm" data-primary="SET command" data-secondary="user variables in queries" id="ch05-set"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="kt">SET</code><code> </code><code class="o">@</code><code class="n">film</code><code> </code><code class="p">:</code><code class="o">=</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">title</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 0 rows affected (0.00 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">@</code><code class="n">film</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------------+
| @film            |
+------------------+
| ACADEMY DINOSAUR |
+------------------+
1 row in set (0.00 sec)</pre>

<p>Second, we can use the <code>SELECT INTO</code> statement:<a data-type="indexterm" data-primary="SELECT" data-secondary="INTO variable" id="ch05-into"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code> </code><code class="k">INTO</code><code> </code><code class="o">@</code><code class="n">film</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">@</code><code class="n">film</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------------------+
| @film            |
+------------------+
| ACADEMY DINOSAUR |
+------------------+
1 row in set (0.00 sec)</pre>

<p>You can explicitly set a variable using the <code>SET</code> statement without a <code>SELECT</code>. Suppose you want to initialize a counter to zero:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="kt">SET</code><code> </code><code class="o">@</code><code class="n">counter</code><code> </code><code class="p">:</code><code class="o">=</code><code> </code><code class="mi">0</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 0 rows affected (0.00 sec)</pre>

<p>The <code>:=</code> is optional, and you can write <code>=</code> instead and mix them up. You should separate several assignments with a comma or put each in a statement of its own:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="kt">SET</code><code> </code><code class="o">@</code><code class="n">counter</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code class="p">,</code><code> </code><code class="o">@</code><code class="n">age</code><code> </code><code class="p">:</code><code class="o">=</code><code> </code><code class="mi">23</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 0 rows affected (0.00 sec)</pre>

<p>The alternative syntax for <code>SET</code> is <code>SELECT INTO</code>. You can initialize a single variable:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="mi">0</code><code> </code><code class="k">INTO</code><code> </code><code class="o">@</code><code class="n">counter</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)</pre>

<p>Or multiple variables at once:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="mi">0</code><code class="p">,</code><code> </code><code class="mi">23</code><code> </code><code class="k">INTO</code><code> </code><code class="o">@</code><code class="n">counter</code><code class="p">,</code><code> </code><code class="o">@</code><code class="n">age</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)</pre>

<p>The most common use of user variables is to save a result and use it later. You’ll recall the following example from earlier in the chapter, which we used to motivate nested queries (which are certainly a better solution for this problem). Here, we want to find the name of the film that a particular customer rented most recently:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">MAX</code><code class="p">(</code><code class="n">rental_date</code><code class="p">)</code><code> </code><code class="k">FROM</code><code> </code><code class="n">rental</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---------------------+
| MAX(rental_date)    |
+---------------------+
| 2005-08-23 15:46:33 |
+---------------------+
1 row in set (0.01 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">rental_date</code><code> </code><code class="o">=</code><code> </code><code class="s1">'2005-08-23 15:46:33'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-------------+
| title       |
+-------------+
| KARATE MOON |
+-------------+
1 row in set (0.00 sec)</pre>

<p>You can use a user variable to save the result for input into the following query. Here’s the same query pair rewritten using this approach:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="nf">MAX</code><code class="p">(</code><code class="n">rental_date</code><code class="p">)</code><code> </code><code class="k">INTO</code><code> </code><code class="o">@</code><code class="n">recent</code><code> </code><code class="k">FROM</code><code> </code><code class="n">rental</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">1 row in set (0.01 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">inventory</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">film_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">rental</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">inventory_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">customer</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">customer_id</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">email</code><code> </code><code class="o">=</code><code> </code><code class="s1">'WESLEY.BULL@sakilacustomer.org'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AND</code><code> </code><code class="n">rental_date</code><code> </code><code class="o">=</code><code> </code><code class="o">@</code><code class="n">recent</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-------------+
| title       |
+-------------+
| KARATE MOON |
+-------------+
1 row in set (0.00 sec)</pre>

<p>This can save you cutting and pasting, and it certainly helps you avoid typing errors.</p>

<p>Here are some guidelines on using user variables:<a data-type="indexterm" data-primary="names" data-secondary="user variables" id="idm46177466440904"/></p>

<ul>
<li>
<p>User variables are unique to a connection: variables that you create can’t be seen by anyone else, and two different connections can have two different variables with the same name.</p>
</li>
<li>
<p>The variable names can be alphanumeric strings and can also include the period (<code>.</code>), underscore (<code>_</code>), and dollar sign (<code>$</code>) characters.</p>
</li>
<li>
<p>Variable names are case-sensitive in MySQL versions earlier than version 5, and case-insensitive from version 5 onward.<a data-type="indexterm" data-primary="case sensitivity" data-secondary="user variable names" id="idm46177466449368"/></p>
</li>
<li>
<p>Any variable that isn’t initialized has the value <code>NULL</code>; you can also manually set a variable to be <code>NULL</code>.<a data-type="indexterm" data-primary="NULL" data-secondary="user variables uninitialized" id="idm46177466446792"/></p>
</li>
<li>
<p>Variables are destroyed when a connection closes.</p>
</li>
<li>
<p>You should avoid trying to both assign a value to a variable and use the variable as part of a <code>SELECT</code> query. Two reasons for this are that the new value may not be available for use immediately in the same statement, and a variable’s type is set when it’s first assigned in a query; trying to use it later as a different type in the same SQL statement can lead to unexpected results.</p>

<p>Let’s look at the first issue in more detail using the new variable <code>@fid</code>. Since we haven’t used this variable before, it’s empty. Now, let’s show the <code>film_id</code> for movies that have an entry in the <code>inventory</code> table. Instead of showing it directly, we’ll assign the <code>film_id</code> to the <code>@fid</code> variable. Our query will show the variable three times—once before the assignment operation, once as part of the assignment operation, and once afterward:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">@</code><code class="n">fid</code><code class="p">,</code><code> </code><code class="o">@</code><code class="n">fid</code><code class="p">:</code><code class="o">=</code><code class="n">film</code><code class="p">.</code><code class="n">film_id</code><code class="p">,</code><code> </code><code class="o">@</code><code class="n">fid</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code class="p">,</code><code> </code><code class="n">inventory</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">inventory</code><code class="p">.</code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="o">@</code><code class="n">fid</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Empty set, 1 warning (0.16 sec)</pre>

<p>This returns nothing apart from a deprecation warning; since there’s nothing in the variable to start with, the <code>WHERE</code> clause tries to look for empty 
<span class="keep-together"><code>inventory.film_id</code></span> values. If we modify the query to use <code>film.film_id</code> as part of the <code>WHERE</code> clause, things work as expected:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">@</code><code class="n">fid</code><code class="p">,</code><code> </code><code class="o">@</code><code class="n">fid</code><code class="p">:</code><code class="o">=</code><code class="n">film</code><code class="p">.</code><code class="n">film_id</code><code class="p">,</code><code> </code><code class="o">@</code><code class="n">fid</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code class="p">,</code><code> </code><code class="n">inventory</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">inventory</code><code class="p">.</code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="n">film</code><code class="p">.</code><code class="n">film_id</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------+--------------------+------+
| @fid | @fid:=film.film_id | @fid |
+------+--------------------+------+
| NULL |                  1 | 1    |
| 1    |                  1 | 1    |
| 1    |                  1 | 1    |
| ...                              |
| 4    |                  4 | 4    |
| 4    |                  4 | 4    |
+------+--------------------+------+
20 rows in set, 1 warning (0.00 sec)</pre>

<p>Now that if <code>@fid</code> isn’t empty, the initial query will produce some results:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">@</code><code class="n">fid</code><code class="p">,</code><code> </code><code class="o">@</code><code class="n">fid</code><code class="p">:</code><code class="o">=</code><code class="n">film</code><code class="p">.</code><code class="n">film_id</code><code class="p">,</code><code> </code><code class="o">@</code><code class="n">fid</code><code> </code><code class="k">FROM</code><code> </code><code class="n">film</code><code class="p">,</code><code> </code><code class="n">inventory</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">inventory</code><code class="p">.</code><code class="n">film_id</code><code> </code><code class="o">=</code><code> </code><code class="n">film</code><code class="p">.</code><code class="n">film_id</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">20</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------+--------------------+------+
| @fid | @fid:=film.film_id | @fid |
+------+--------------------+------+
|    4 |                  1 |    1 |
|    1 |                  1 |    1 |
|  ...                             |
|    4 |                  4 |    4 |
|    4 |                  4 |    4 |
+------+--------------------+------+
20 rows in set, 1 warning (0.00 sec)</pre>

<p>It’s best to avoid such circumstances where the behavior is not guaranteed and is hence unpredictable.<a data-type="indexterm" data-startref="ch05-uv" id="idm46177466236328"/><a data-type="indexterm" data-startref="ch05-uv2" id="idm46177466245928"/><a data-type="indexterm" data-startref="ch05-uv3" id="idm46177466245256"/><a data-type="indexterm" data-startref="ch05-into" id="idm46177466244584"/><a data-type="indexterm" data-startref="ch05-set" id="idm46177466243912"/></p>
</li>
</ul>
</div></section>







</div></section></div></body></html>