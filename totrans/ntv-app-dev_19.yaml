- en: Chapter 17\. Listing Data in the App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we went through the basics of starting a new project in
    Android Studio and Xcode. We were also charged by a mysterious librarian to build
    an app for a library that, presumably, has magic powers. This is just a typical
    day in the life of a mobile app developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this chapter, we’re going to add a bit more structure and scaffolding
    to our app. More specifically, we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to customize and tweak views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to trigger actions from button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to show lists of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to transition between two screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a long chapter, so let’s get started. Our future library patrons are
    waiting.
  prefs: []
  type: TYPE_NORMAL
- en: Sprucing Up Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you take a look at both the Android and iOS apps in their current state,
    they are fairly skeletal and uninviting. We can do a better job than a basic label
    that says “Welcome” displayed against a blank background. In fact, both platforms
    have a pretty robust set of built-in tools for styling that we can use to make
    our app more presentable and inviting. We’re not going to get in depth into those
    tools—the tooling is quite deep and the possibilities are near limitless with
    what you can create—but for now let’s at least spruce up the apps a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Referring back to [Chapter 15](ch15.html#app_setup), you’ll see that we started
    with a simple `Activity` when we chose the project type and were able to update
    the text. Let use this same `Activity` and XML layout to update our welcome screen.
    For this simple version, we won’t use any kind of login or authentication, so
    our welcome screen is probably as simple as a logo, a small amount of copy introducing
    the library, and maybe an Accept Terms label and checkbox. Let’s also include
    a button at the bottom of the screen to browse the library’s corpus, which will
    be disabled until the Accept Terms checkbox is ticked. Once enabled, tapping this
    button will launch into one of our primary UI controllers, tentatively named `BrowseLibraryActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Also remember that we have no idea how large the screen will be when some user
    runs our app on a device left over from 2010, nor on a device from 2024\. Nor
    can we be sure of the orientation (landscape or portrait), and if we’re observing
    accessibility recommendations, even our font size can vary wildly depending on
    user or device settings. The bottom line is that we’ll need all that content to
    scroll, so we can ensure the user can read all the information we’re presenting,
    opt in (or not) to the terms we establish, and be able to tap the browse button
    to start wandering our virtual stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s establish some facts. In Android, resources like strings and drawables
    are generally held in XML structures identified by a system-generated integer,
    as described earlier when creating and referencing our logo image. Read on for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Adding string and drawable resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So we’ll need a few pieces of copy: an introduction to the app and the library,
    something about copyrighted material that the user digitally agrees to, and button
    labels. You’ll recall that we created our logo file and registered with the system
    simply by placing it in the appropriate resource directory. For string values,
    we’ll want a different resource type: `values`. The traditional format is */res/values/strings.xml*,
    and each string is a `string` node with a `name` attribute identifying it during
    compilation; the string value is the text content of the node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To *strings.xml*, let’s add some nodes to represent our copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There. Now we not only have our logo bitmap as a compiled resource, but all
    of our welcome screen copy as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new layout file for this `Activity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So what’s going on here?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The root node of our layout is a `ScrollView`, which scrolls content vertically,
    by default, as needed. On most screens, this small amount of content may not need
    to scroll at all, but on small or low-density screens, on devices with a significant
    text magnification setting, or even on a standard device in landscape mode, this
    may come into play. It’s critically important that all interactive UI elements,
    even those that simply provide critical information to the user, be reachable
    somehow, and the traditional user experience to achieve this is by scrolling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We know that all the rest of our components will be stacked vertically, each
    successive element positioned just below the last. This is traditional flow in
    almost every modern UI engine, from a traditional HTML web page, to a PDF document,
    to documents created by editors like Pages or MS Word, markdown, AsciiDoc(tor),
    troff, (La)TeX, etc. The framework-provided `LinearLayout` does just that. Note
    that the default orientation of `LinearLayout` is horizontal, so that each element
    is positioned to the right of the preceding elements; we must set the attribute
    `orientation` to the value of `vertical` to get the stacked interface that we
    want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next comes our logo. We want this image to fill the width of the page but maintain
    aspect ratio vertically; thus, we use the following layout attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A simple block of text, describing the app and the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another text block, this one providing some minimal legalese to protect our
    authors’ copyrights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `CheckBox` instance with a label. While this `CheckBox` is not checked, we’ll
    provide logic so that the button following it will remain disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple `Button` instance that, when enabled and tapped, will take the user
    to a screen that let’s them start to explore the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it! Since our `MainActivity` already calls `setContentView` and passes
    in the compiled identifier for this layout file, the initial welcome screen will
    now show the UI elements described, rather than the simple “Hello World!” it did
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the preceding example layout is explicitly bare bones, to just demonstrate
    what you absolutely *need* to display the UI, let’s add just a few lines of instructions
    around whitespace and element gravity to dress it up a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Other than the addition of margins, font specs, and gravity, you may also notice
    we added the attribute `adjustViewBounds` to the `ImageView` representing the
    logo. While you can see we’re not doing extensive `View` manipulation at this
    point, I do feel like this one is worth a quick detour, since it comes up very
    often and can throw even seasoned developers for a loop, since the behavior is
    fairly nonstandard when compared to our layout or drawing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the [developer documentation](https://oreil.ly/qKi6P), we find this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Set this to true if you want the ImageView to adjust its bounds to preserve
    the aspect ratio of its drawable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In simpler terms, if we do not set this attribute to `true`, the `ImageView`
    may use and consider whitespace part of its drawing area, which may appear as
    margins or padding that were not specified. When in doubt, set this attribute
    to true for any `ImageView` for which you don’t have specifically distinct behavior
    reserved. It may not seem like much, but if you need your images to line up with
    your screen or other elements in a pixel-perfect fashion, this is an attribute
    you’ll want to know about. On we go!
  prefs: []
  type: TYPE_NORMAL
- en: Run your app, and you should see something like [Figure 17-1](#app_welcome_screen).
  prefs: []
  type: TYPE_NORMAL
- en: With our visible UI already in a spiffy state, we’ll want to wire up some of
    the behavior for the `CheckBox` and `Button` instances we have.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll want the submit button at the bottom of the screen to launch a UI that’ll
    allow the user to browse our books; the button should be disabled unless the user
    has indicated he or she accepts our terms (basically, just reminding our users
    that the copyrights on our books are still enforceable when presented digitally).
    Let’s see how to do that in code.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of our new welcome screen](assets/nmdv_1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. Welcome screen
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'First, let’s open our *MainActivity.java* file, which is responsible for controlling
    the welcome screen. You’ll notice the line `setContentView(R.layout.main)`, which
    will inflate the XML view nodes from the previous chapter and draw them on the
    screen. At the moment, it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Pretty straightforward, right? Well, we need to do a little more to get the
    special behavior we just described.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we know we’ll need to perform operations on both the checkbox and the
    button, so let’s grab references to those with the `findViewById` method, available
    to both `Activity` and `View` instances. We’ll also declare member variables to
    hold those references. Your activity code should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll notice a neat thing in the Kotlin version of the preceding code—it’s
    all done for you! You’ll have a `TextView` instance available as `terms_checkbox`
    and a `Button` instance available as `browse_button`, without writing any additional
    code. `Activity` instances in Kotlin, as well as any class that implements `LayoutContainer`,
    will automatically read any `View` with an ID in the layout as a member variable
    with a name equal to the ID. See for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! We’ve got a visible UI, and we have in-memory references to some UI
    elements that we’ll want to perform some logic on. Let’s think about the specification
    we described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: The browse button should start a new `Activity` to allow the user to explore
    the library’s corpus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browse button should be disabled as long as the user has not checked the
    “Accept Terms” `CheckBox` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first requirement, we need to attach a `View.OnClickListener` instance
    to the `Button`. While there are several ways to do this, described in [Chapter 4](ch04.html#topics_user_input)
    on user input, we’ll use method references to keep things short yet readable.
    Our `View.OnClickListener` implementation just needs to be a method that returns
    `void` and accepts a single `View` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There we go—we attach the method `browseContent` to the button as its click
    listener. You might notice that lint will probably complain that `BrowseContentActivity`
    doesn’t exist—let’s stub that out for now. Create a minimal `Activity` file, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: And don’t forget to register it with your manifest!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to make sure the button is disabled unless the Accept Terms `CheckBox`
    is checked. Let’s start off with `enabled="false"` in the XML layout, and then
    we’ll update that as the check state of the `CheckBox` changes. To do that, we’ll
    need an `OnCheckChangedListener`, which we’ll again use a method reference for.
    The contract of the `OnCheckChangedListener` requires a method that returns `void`
    and accepts two parameters: the compound `Button` instance that can be a `CheckBox`,
    `Switch`, or similar UI widget, as well as the boolean state of the toggle. The
    `onCheckChanged` method defined in the following meets those criteria; let’s attach
    that to the `CheckBox` reference we obtained earlier, and we’re in business:'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the app again, you’ll notice the button colors are dimmed, and it
    won’t accept a tap action. However, if you tap the checkbox (or the attached label)
    to toggle its state, you’ll find the `Button` also changes state between enabled
    and disabled. While it’s enabled, a tap on the `Button` launches the new `BrowseContentActivity`—even
    though it’s currently blank, you can see how user interaction and `Activity` instances
    make up a large part of app navigation in the Android framework.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how it’s done on Android, let’s do something similar on
    iOS.
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to make this application a bit easier to work with, the first thing
    we need to do is tweak its structure and style. Let’s start with the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we want to do on iOS to make this app more usable is to provide
    some structure. Open up Xcode and navigate to the *Main.storyboard* file. Within
    the storyboard editor, click on the Library button on the top right group of buttons
    within the project window (the same button we dragged our label from in [Chapter 16](ch16.html#app_project));
    this will present the modal where we can select from a list of available UIKit
    objects to drag onto our storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide the structure we desire and to adhere to a system-wide look
    and feel, we’re going to wrap our welcome view in a navigation controller. Search
    for “Navigation Controller” in the Library and drag it near our current welcome
    view controller like in [Figure 17-2](#figures_nav-controller).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a navigation controller to our storyboard](assets/nmdv_1702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-2\. Adding a navigation controller to our storyboard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Navigation controllers are a built-in object within UIKit, the framework that
    does all the UI heavy lifting in iOS. They are used to make navigating an app
    easier and handle the state of transitioning between views, which will be important
    later. More important at the moment, however, they provide a persistent navigation
    bar at the top of the screen to help the user with spatial reasoning within the
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, our navigation controller will never be seen. Let’s fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the “Root View Controller” added automatically by Xcode. This view
    controller is the first view controller shown by the navigation controller we’ve
    added. Delete it by hitting the Delete button. Every navigation controller is,
    in fact, a `UINavigationController`. This class has a stack of child view controllers
    that are currently being presented by the application. The root view controller
    can be any `UIViewController` object—it’s essentially just the bottom of the stack.
    Fortunately, we’ve got a perfect candidate for a new root view controller: our
    welcome screen!'
  prefs: []
  type: TYPE_NORMAL
- en: In order to connect the two views together, we need to wire them up similar
    to how we wired up the header label in [Chapter 2](ch02.html#topics_views). Control-click
    on the navigation controller and drag the connection over to the welcome view
    controller. In the modal dialog that pops up, select “root view controller” under
    “Relationship Segue.”
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, if you run the application in the Simulator, you’ll notice that
    not much has changed. The reason for this is because our welcome view controller
    is still set as the initial view controller of this storyboard. This means iOS
    will just create an instance of `WelcomeViewController` and tell it to present
    its view as the root view of the window.
  prefs: []
  type: TYPE_NORMAL
- en: We can fix this by clicking on the Navigation Controller scene in the storyboard
    editor, highlighting the Attributes inspector, and checking the box labeled “Is
    Initial View Controller” in the inspector pane. You’ll notice the large floating
    arrow moves from welcome view controller over to the left side of navigation controller
    indicating the switch. Build and run and the app and you’ll see the Welcome View
    Controller scene displayed within the Navigation Controller scene we created.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got our structure down; let’s see if we can get some more style added.
  prefs: []
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of ways we can improve our welcome screen. The easiest, and
    arguably the best, option is to get rid of the header label we created before
    and have the navigation controller display the name of the screen we’re viewing
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: First, click on the header label within the Welcome scene and delete it by hitting
    the Delete key. You’ll notice it disappears from the screen as well as disappearing
    from the Document Outline on the left side of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s set the title of the screen for the navigation controller to view.
    We can do this programmatically, but since we’re already in the storyboard editor,
    let’s do it here. Within the Document Outline on the left side, click on the Navigation
    Item object inside the Welcome View Controller scene. Open the Attributes inspector
    on the right side of the screen and put “Welcome” in the Title field.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you’d like, go ahead and set Large Title from `Automatic` to
    `Always`. This will make our navigation controller title larger and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We could also set the navigation item properties programmatically. Within the
    `UIViewController` class, there are `navigationItem.title` and `navigationItem.largeTitleDisplayMode`
    properties for the respective Title and Large Title attributes we set in the storyboard
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and run the application on the iOS Simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Uh-oh. We broke it. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: Errors, errors, and more errors!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all, welcome to the wonderful world of runtime errors! As you’ll notice,
    our application compiled and ran, but then crashed when it was running. This is
    due to the dynamic nature of UIKit, which has roots in Objective-C history. If
    you open up our `WelcomeViewController` class, you’ll see we have a property called
    `headerLabel` that’s still present in the class.
  prefs: []
  type: TYPE_NORMAL
- en: You might be saying, “But I thought we deleted the header label just a few paragraphs
    ago?” You’re right. We did. However, we *didn’t* remove it from the class. Now,
    there are a few ways to prevent something like this in the future. One option
    is to change our type from `UILabel!`, which is an implicitly unwrapped Optional
    (i.e., a non-`nil` type), to an Optional property—a type that could be `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You see, iOS was expecting there to be a value for that object whenever we
    interacted with it in the `viewDidLoad()` method. Because we deleted the label
    from the scene in the storyboard editor, the connection we wired up with this
    class in [Chapter 2](ch02.html#topics_views) never had a chance to complete. The
    compiler didn’t know this happened and let the project compile because all the
    wiring up happens at runtime instead of compile time. So consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the app called this, the system didn’t know what to do because there
    *should* have been a header label set, but there wasn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can actually tell this happened if you read the error generated in the
    console, the lower-right window that popped up, in Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `headerLabel` property is the `nil` value in something that shouldn’t be.
  prefs: []
  type: TYPE_NORMAL
- en: If we set `headerLabel` to a type of `UILabel?`, the app will compile and run
    properly. However, I think this is usually the wrong solution because the code
    will still continue to exist in the class. We will still attempt to set the `headerLabel`
    to red, but because `headerLabel` is `nil` and an Optional type, this will short-circuit
    and fail quietly. Later, when we go to the edit the class, we might not quickly
    remember that we deleted the header label from our view and spend time trying
    to figure out what this line is doing. In my opinion, it’s best to leave `@IBOutlet`s
    as implicitly unwrapped Optionals and let the application fail when we run it
    to remind ourselves to remove this code whenever we remove connected views.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s remove this property from the `WelcomeViewController` class.
    We’ll also add a quick snippet of code to enable the large title we set in the
    storyboard editor to display in this view controller’s navigation bar (it’s not
    enabled by default). Our class should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Hit the stop button beside the “Build and Run” button near the top left of the
    project window to stop our currently running application. Then, hit the play button
    to build and run the project. We should now see something like [Figure 17-3](#figures_welcome).
  prefs: []
  type: TYPE_NORMAL
- en: Both apps are looking good! We can go a bit further with background colors and
    other properties for the welcome screen, but we’ll leave that as an exercise for
    the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve spent a lot of time within our app’s welcome screen, and we’ve set the
    groundwork for some more interactivity. Ultimately, our goal at the end of this
    chapter is to have an app that lists some data, so let’s get there in the simplest
    way possible first: by simply pressing a button.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our first styling applied to the app''s Welcome screen](assets/nmdv_1703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-3\. Our first styling applied to the app’s Welcome screen
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Adding a Button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, we don’t mean that you, the developer of this amazing app, can
    just press a button and make it all happen magically; what we mean to say is let’s
    add a button to our app so that *users* can press to list out some books. This
    particular button will be labeled “Catalog” and display the entire catalog of
    the library in a list view that transitions into the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We can read back a bit and see how it was handled in Android; let’s take a look
    at how we’d do the same thing in iOS.
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add a button to our view, open up *Main.storyboard* in the storyboard editor
    and click on the Library button to bring up our library of UI objects. Next, search
    for “button” and drag the Button object onto the welcome screen within the editor.
    You should see a placeholder button labeled “Button” in the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Right now it’s wherever you dropped the button onto the canvas, but ideally
    we want this button to be displayed in the center of the screen for now. This
    is easy enough to target one device, but if you’ll recall, there are a number
    of screen sizes and form factors of devices that run iOS. Fortunately, iOS has
    a robust framework for laying out views automatically aptly named Auto Layout.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Layout uses predefined constraints to position views within a scene. There
    is a great description of Auto Layout in [Chapter 2](ch02.html#topics_views).
    It describes how to set constraints programmatically using the storyboard editor
    within Xcode. For now, we’re going to use the editor because it’s usually easier.
  prefs: []
  type: TYPE_NORMAL
- en: With the button selected, click the Align button—third from the right at the
    bottom of the storyboard editor canvas—and check the boxes for “Horizontally in
    Container” and “Vertically in Container.” Click “Add 2 Constraints” to add the
    constraints to the button.
  prefs: []
  type: TYPE_NORMAL
- en: You should see the button move automatically to the center of the view. In this
    case, we’re telling iOS that this object is centered horizontally and vertically
    within its container. That part might be obvious, but what is the container? Well,
    the container is the root view in which the object resides. In this case, it happens
    to be the root view that the entire scene is embedded in—which also happens to
    the `view` property of the `WelcomeViewController`. If, for instance, this button
    was nested within another view, then it would center itself within that view instead
    of the root view of the view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Now that it’s positioned properly, let’s finish styling our button. Click on
    the button and change the title of the button to read “Catalog” within the Attributes
    inspector. Build and run the application and you should see a button in the center
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, this button will display our library catalog. But, before we show
    that, we have to build it!
  prefs: []
  type: TYPE_NORMAL
- en: Lists, Lists, and More Lists!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common tasks in mobile development is displaying lists of data.
    There are entire categories of apps specifically for listing data. What is a book
    catalog but a giant list of books? Luckily, both Android and iOS have some great,
    core libraries for dealing with lists of items. On Android it’s `RecyclerView`,
    which is a part of the support library but at the time of this writing is moving
    to the `androidx` package; it’s up to you which to use. The support library version
    is well-tested at this point, and while we might be able to expect some performance
    improvements or technical upgrades, I suspect the usability and public API will
    remain largely unchanged in `androidx`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Android has gone through some public evolution around this type of
    component. Originally, we had `ListView`, which managed scrolling and item rendering
    nicely, but users were expected to do manual recycling of views (which benefits
    memory management). There was a component called `GridView` that, as you probably
    guessed, allowed `Views` to be expressed as horizontal rows and vertical columns,
    rather than just the vertical stack enabled by `ListView`. Both should be considered
    deprecated at this point, and `RecyclerView` instances use a layout manager to
    provide list or grid layouts (or really, any other layout you can conceive of).
    On iOS, this feature requirement can be satisfied by either `UITableView` or `UICollectionView`.
  prefs: []
  type: TYPE_NORMAL
- en: Add a New Catalog View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start by adding a new UI controller and adding an empty list to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Android, we’ll create a new layout file for the `BrowseContentActivity`
    that contains just a `RecyclerView`, to start. Let’s call it *res/layout/activity_browse.xml*.
    We may end up including a toolbar for navigation and contextual menus, or a coordinator
    layout to manage `Snackbar` animations or `FloatingActionButton` position, but
    let’s keep it simple for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You’d want to set this as the content view in your `BrowseContentActivity`
    class, in the `onCreate` method right after `super` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need to do a few things in code later to provide a data source and specify
    layout behavior and effects, but this is really all the layout we need for now.
  prefs: []
  type: TYPE_NORMAL
- en: For iOS, we can accomplish this mostly in the storyboard editor. For this catalog,
    we’ll use a `UITableView` as it’s a bit simpler to work with initially. First,
    open up the *Main.storyboard* file in Xcode and click on the Library button in
    the project window to bring up our object library. Next, drag a new view controller
    to the canvas. Then, use the Library again to drag a table view into the new view
    controller screen that was just created. Finally, with the table view selected,
    click the Add New Constraints button at the bottom right of the storyboard editor’s
    canvas. Set all the margins to `0` and then click the Add 4 Constraints button;
    this will make the table view have a margin of `0` around all its dimensions,
    effectively expanding it to the width and height of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: As a final touch, click on the View Controller scene we created. In the Attributes
    inspector, put the text “Catalog” under the Title field to name our view controller.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got a list view created in both apps, but they’re currently inaccessible.
    Let’s fix that!
  prefs: []
  type: TYPE_NORMAL
- en: Wiring Up the Button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is a button without an action really a button at all?
  prefs: []
  type: TYPE_NORMAL
- en: Putting this momentary existential crisis aside for the moment, let’s focus
    on the catalog button currently devoid of purpose on our welcome screen. The goal
    of this button is to display the catalog of books in the library. But right now
    it’s doing nothing.
  prefs: []
  type: TYPE_NORMAL
- en: For iOS let’s wire up this button with a segue. Segues are explained in detail
    in [Chapter 1](ch01.html#topics_ui_controllers) of the book. They are, in their
    simplest form, transitions between two views. Segues are defined in a storyboard
    and can be triggered via storyboard connections or programmatically. For this
    example, because of its simplicity, we can wire everything up in the storyboard
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: First, Control-click on the catalog button we created in the welcome screen.
    Drag a connection over to our new catalog scene. Now, in the modal dialog that
    is presented select Show under the Action Segues section.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all it takes. This will create a segue trigger whenever someone clicks
    the catalog button, which displays the catalog view. Build and run and the app,
    and you should see a list view like [Figure 17-4](#figures_catalog) whenever the
    catalog button is tapped.
  prefs: []
  type: TYPE_NORMAL
- en: '![Rows and rows of no data—is this a metaphor for life? No, just an empty table
    view](assets/nmdv_1704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-4\. Rows and rows of no data—is this a metaphor for life? No, just
    an empty table view
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All right. We’ve got our buttons wired up. We’ve got our list views. But right
    now, they’re empty. It’s finally time to talk about our data.
  prefs: []
  type: TYPE_NORMAL
- en: Books
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look around the library for the app we’re creating, you’ll notice something:
    there are A LOT of books. There are nonfiction books. There are non-fiction books.
    There are books with pictures. There are books with no pictures. There are small
    books, big books, old books, books to read on a beach, books to read in the bathtub
    while sipping a glass of red wine—all kinds of books!'
  prefs: []
  type: TYPE_NORMAL
- en: So how do we know what to display?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, fortunately, there is a certain amount of information that is shared
    among all books. A few common properties of books are:'
  prefs: []
  type: TYPE_NORMAL
- en: Title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ISBN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fiction or nonfiction?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To work with our list views, we’ll need to keep this information organized.
    We could pass it directly as properties to our list view rows and configure each
    row, but a more common practice is to define a shared model to keep the data contained
    and more easily maintainable; it’s much easier to add a new field to a single
    type than to have to add it to every method within the application that deals
    with book metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s define a book object so we can start using it populate our list views.
    So, what does this object look like in Java and Swift? Well, remarkably, this
    is where the classes look very much alike.
  prefs: []
  type: TYPE_NORMAL
- en: In Android, we’ll use a standard Java class definition to represent our books.
    These are sometimes called “models” or “data classes,” and the latter does have
    special designation in Kotlin (which we’ll touch on, shortly), but in reality
    there’s no functional difference between a model and any other class. Some developers
    prefer to use “POJOs” (“Plain Old Java Objects”), which are simply classes that
    don’t extend another class and don’t implement an interface, but this is simply
    a matter of taste. It is also fairly common to have model classes exclude logical
    operations (methods) other than getters and setters, and while this may make sense
    or even be enforced on your team, it’s technically optional insofar as restrictions
    of the language and framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering that Android does suggest we do not use public members, we’ll assign
    some fields and the appropriate getters and setters, so our `Book` class might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While that may seem a bit verbose, you’ll find Android Studio is happy to generate
    getter and setter methods from your properties and can even be configured to work
    properly with Hungarian notation (so that `mName` becomes `getName` and `setName`,
    rather than `getMname`).
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, you can see that Kotlin really shines in this specific example,
    and the data class for a `Book` instance has a much smaller definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can include a constructor that allows us to pass a no-arg instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This not only includes a default constructor that accepts all fields but combines
    that constructor with the definition itself. Further, while all the fields are
    `val` and therefore immutable (in Java, this would be considered `final`), you’ll
    see that we don’t have to set a default value to be updated on instantiation—by
    having these values defined within the constructor, we can ensure that instantiation
    provides the single, immutable value for the member.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in Xcode, add a new Swift file called *Book.swift* (File > New > File)
    to the project. We could use a `class` here, but instead we’ll use a `struct`.
    Classes in Swift are reference objects; in other words, you pass around addresses
    to the object in memory. Meanwhile, structs are value objects, similar to primitive
    data types like strings. This makes copying operations much safer and easier in
    multi-threaded situations. You won’t have to worry about another object changing
    data in the object because the object itself will be copied instead of just the
    address to the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what our `Book` object type looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We’ve got our data models defined, we’ve got our catalog view created, and we’ve
    got our catalog button wired up. Almost all the puzzle pieces are lined up to
    start displaying some data! Let’s head back over to our new list views.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the List View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re not currently grabbing any data from a network service or reading in data
    from the filesystem. (Spoiler! We’ll talk about both of those in later chapters!)
    For now, let’s use static data within the class to demonstrate how to populate
    list views in Android and iOS. Let’s start with Android.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So we have our `RecyclerView` instantiated and ready to kick some butt, but
    without data there’s not much to see. Let’s remedy that. For now, we’ll hardcode
    some data in our `Book` model as a `static` class variable, but *for the love
    of all that’s good, please don’t ever do this in production*. And don’t worry,
    we’ll remedy this later.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *for now*, here’s some sample books—we’ll use a very similar structure
    in iOS soon:'
  prefs: []
  type: TYPE_NORMAL
- en: So that’s our data. Consider that the source of data for a list view might change
    during the lifetime of an app—we might initially fetch the data from a remote
    server but subsequently show a cached version from a local database. We might
    have a search service that has a variety of sort or filter options. For this reason
    and others, in Android the data source is not directly attached to the `RecyclerView`
    but is rather managed by a bridge between the UI and the data, known both semantically
    and canonically as an `Adapter`. The `Adapter` pattern is common within Android
    and is used for things like `ViewPagers`, `Spinners`, `Galleries`, and many others;
    the specific `Adapter` class used by `ReyclderView` is simply `RecyclerView.Adapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Adapter` has several contracts to fulfill. We’ll provide a working example
    with the `Book.SAMPLE_DATA` array as the data source and then dig into each of
    the required methods:'
  prefs: []
  type: TYPE_NORMAL
- en: If this looks confusing or opaque to you, you’re right—it is! In fact, the concept
    of the `RecyclerView` was originally merely a *convention*. We (Android developers)
    used the now deprecated `ListView` widget, and over time we as a community came
    to accept that using certain patterns allowed us to save memory and improve performance.
    Without the recycling pattern, a simple search that returned a few thousand items
    could easily use up more resources than the app had available, especially on the
    devices available at the time.
  prefs: []
  type: TYPE_NORMAL
- en: When `RecyclerView` was first released in the original support library (prior
    to the much fancier-sounding `androidx` package we use now), that convention became
    codified, but without understanding that history or without being a part of it
    some of these patterns and contracts seemed arbitrary and unintuitive—mostly because
    they are!
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, at this point in Android development, we have a feature-full,
    well-vetted, and highly performant widget at our disposal, so let’s take the time
    we need to learn it. Let’s actually start at the bottom: the static `ViewHolder`
    class. The super class `RecyclerView.ViewHolder` is abstract, so even if we didn’t
    need any extended behavior, you’d still have to subclass it. In reality, if the
    super class was not abstract, we could just cast the `itemView` member to a `TextView`
    instance in the `onBindViewHolder` method, and we wouldn’t even need the custom
    subclass. What a mouthful! Let’s slow down and take a step back.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, a `ViewHolder` is just a bag of `View` references, representing
    child `View`s on each row. For example, if each row of your list has an `ImageView`
    to represent a thumbnail image, a `TextView` to indicate the title, and another
    to display the concatenated list of authors, your `ViewHolder` would likely have
    those three `View`s as references, maybe something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might rightly wonder where those `View` instances come from—we’ll step
    away from the `ViewHolder` for a moment to touch on the `onCreateViewHolder` method.
    In our preceding simple example, we simply pass a `TextView`, but in the more
    complex UI we’re using to explain `ViewHolder`, let’s imagine you want a view
    tree and probably want to represent that like you do all your layouts—via XML.
    Each row might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note the linear layout trick using the `weight` attribute mentioned in [Chapter 2](ch02.html#topics_views).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s call this file *complex_book_row.xml* and save it in *res/layout*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with this more complex row, using our more robust `ViewHolder` class, our
    `onCreateViewHolder` method might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Now you might start to see how this comes together—if not, try to imagine how
    the `RecyclerView` does its recycling…
  prefs: []
  type: TYPE_NORMAL
- en: 'When first laid out, the `RecyclerView` creates enough rows to fill its visible
    area, using the `onCreateViewHolder` method as well as some internal opaque functionality.
    When a user scrolls down far enough for the first row to be outside of the visible
    viewport, that entire row’s view tree is *recycled*—it’s detached from the window
    and added to a pool to be used later, when a row that has not yet rendered becomes
    visible due to the scrolling or resizing of the `RecyclerView`. When that happens,
    the `onBindViewHolder` method of the `RecyclerView.Adpater` is invoked, passing
    in the position (which is often used as an indexed position against a list-style
    data source) and populating the recently retired but now newly employed view tree.
    In our most sophisticated example, the `onBindViewHolder` method might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see how our simple example works, by comparing it to a more thorough
    version of the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: All that’s left is to wire this all together. Additionally, we need to let the
    `ReyclerView` know how to position its children. As mentioned previously, there
    are multiple layout managers provided for you for vertical lists, horizontal lists,
    and grid views, and you can use the same templates to create your own `LayoutManager`
    subclass with custom behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'After selecting and instantiating a `LayoutManager`, assign it to the `RecyclerView`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, attach the `Adapter` to the `RecyclerView` with `setAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first draft of your working browse `Activity` might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: If you run your app now and tap into the `BrowseBooksActivity`, you should see
    the title of each of your books listed in a vertical stack. If your font size
    is large enough or your screen small enough (feel free to play around with the
    padding or margins on your `TextView` to see this in action), you’ll see that
    this list scrolls and manages to appears as if the entire dataset is available
    at all times—the magic of `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got a working list of books on Android. Let’s get iOS working now!
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ll recall from before, on iOS, we’re using a `UITableView` to show the
    data in our catalog. The first thing we need to do if we’re going to do any special
    logic is switch our vanilla `UIViewController` into a custom view controller within
    the storyboard editor. Create a new Cocoa Touch Class named `CatalogViewController`
    that inherits from `UIViewController` in Xcode (File > New > File) and add it
    to the project. Leave this file as is, for now, and click on *Main.storyboard*
    to open it in the storyboard editor.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the storyboard editor, click on the Catalog scene. In the Identity inspector
    set the Class value to `CatalogViewController`, which is the name of the class
    we just created.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the table view within the scene, you might notice it’s empty
    right now. If we tried to use the table view, we wouldn’t be able to because there
    are currently no prototype cells. Prototype cells are templates defined in the
    storyboard that are created on-demand by the table view in order to display a
    row of content. Each row could be a different cell type, but more commonly, a
    handful (or even just one!) of cell prototypes are defined and used for each cell.
  prefs: []
  type: TYPE_NORMAL
- en: In order to add a prototype cell, select the table view in the scene, open the
    Attributes inspector and increment the value under Prototype Cells. This will
    add a new row to the example table view shown in the storyboard editor. To be
    able to use this cell type, however, we have to be able to target it in the code.
    This is done by selecting the table view cell in the editor and setting its Identifier
    (also known as a Reuse Identifier) to a unique value. For now, let’s set the value
    to `CatalogTableViewCell`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned earlier that our data for this chapter would be static data. Let’s
    use the same titles we used in the Android section for populating a list view.
    We can modify our `Book` structure to include an extension with a convenience
    method for our list of books like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, it might seem contrary, but we will not pass all this data to our table
    view at once. One of the amazing things about `UITableView` and `UICollectionView`
    is their ability to maintain performance with vast amounts of data. They do this
    by only interacting with a subset of the data at a time, very similar to Android’s
    `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to populate the table view, we need to create a data source for the
    table view. This is done by assigning an object that conforms to the `UITableViewDataSource`
    protocol of the table view object itself. In this example, we’ll have `CatalogViewController`
    itself conform to this protocol for simplicity instead of creating a separate
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s fairly common practice to have `UIViewController`s themselves conform to
    the data source (and delegate) protocols for table views. This is OK for simple
    apps, but it does violate the separation offered by following a stricter MVC architecture.
    It also leads to view controller bloat, which is a common problem. Developer beware!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an extension to `CatalogViewController` to conform to `UITableViewDataSource`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there are a number of optional methods you can conform to with the data
    source protocol, but there are two required methods you’ll have to implement to
    populate the table view: `tableView(_:numberOfRowsInSection:)` and `tableView(_:cellForRowAt:)`.
    Let’s take a look at the first one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `tableView(_:numberOfRowsInSection:)`, we’re telling the table view how
    many rows are in each section of data. Our table view will have only one section,
    so we can just return the number of items in our static data that we defined previously
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The default amount of sections for a table view if `1`. In order to define multiple
    sections inside a table view (with section headers), implement the method `numberOfSections(in:)`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve told the table view how many rows there will be. Let’s implement our next
    method, `tableView(_:cellForRowAt:)`, to provide logic for how to populate the
    cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main body of this method needs to do two things: it needs to instantiate
    a table view cell and it needs to populate that table view cell with the correct
    book. We can do this by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we’re grabbing a reusable instance of a table view cell by using the
    identifier (`CatalogTableViewCell`) we assigned when we created our prototype
    table cell. Next, we’re grabbing the book for the current row based on the `indexPath.row`
    property. This method is called for every cell that’s displayed, so if we’re grabbing
    the third row, the value of this property would be `2` so we can grab the third
    item from the array (i.e., it’s a zero-based row count for convenience). Then,
    we take that cell and set its text label to the book’s title. Finally, we return
    the cell so that the table view can display it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve got one more step to get this all hooked up together: we have to tell
    the table view that it can use this view controller as its data source.'
  prefs: []
  type: TYPE_NORMAL
- en: Hop back over to *Main.storyboard* in the storyboard editor. Control-click and
    drag from the table view in the Catalog scene over to the `Catalog` object itself
    inside the Document Outline on the left side of the canvas. In the dialog that
    appears select `dataSource` under Outlets to wire up the table view to the view
    controller as its data source.
  prefs: []
  type: TYPE_NORMAL
- en: Click build and run and you should be able to click our catalog button to see
    a list of the sample data we’ve used to populate the list.
  prefs: []
  type: TYPE_NORMAL
- en: What We’ve Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s review what we’ve learned this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, we learned how to add some structure and style to our screens. Next,
    we learned how to wire up transitions between views triggered by buttons. We discussed
    data models and showed how similar they can be between platforms. We also created
    a basic model object for a book that we’ll use and improve in later chapters.
    Finally, we took that data and displayed it in a list view as part of the library’s
    book catalog.
  prefs: []
  type: TYPE_NORMAL
- en: We did it! We’ve gotten our app to display some book titles, albeit with static
    sample data. All this time in the view and controller layers has been fun, but
    next chapter, we’ll spend more of our time dealing with our models. Let’s check
    it out!
  prefs: []
  type: TYPE_NORMAL
