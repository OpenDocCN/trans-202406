<html><head></head><body><section data-pdf-bookmark="Chapter 6. Basic Visual Formatting" data-type="chapter" epub:type="chapter"><div class="chapter" id="basic-visual-formatting">&#13;
<h1><span class="label">Chapter 6. </span>Basic Visual Formatting</h1>&#13;
&#13;
&#13;
<p>You’ve <a data-primary="visual formatting" data-type="indexterm" id="ix_vis_format_ch6"/>likely experienced the frustration of having your intended layout not render as expected. After adding 27 style rules to get it perfect, you still might not know which rule solved your problem. With a model as open and powerful as that contained within CSS, no book could&#13;
hope to cover every possible way of combining properties and effects.&#13;
You will undoubtedly go on to discover new ways of using CSS. With a thorough grasp of how the visual rendering model&#13;
works, however, you’ll be better able to determine whether a behavior is a&#13;
correct (if unexpected) consequence of the rendering engine CSS defines.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Basic Boxes" data-type="sect1"><div class="sect1" id="basic-boxes">&#13;
<h1>Basic Boxes</h1>&#13;
&#13;
<p>At its core, <a data-primary="boxes" data-secondary="basic" data-type="indexterm" id="ix_box_basic"/><a data-primary="element boxes" data-type="indexterm" id="ix_elem_box_ch6"/><a data-primary="boxes" data-secondary="element boxes" data-type="indexterm" id="ix_box_elem_ch6"/><a data-primary="boxes" data-seealso="blocks; flexible box layout; grid layout" data-type="indexterm" id="idm45176109527936"/>CSS assumes that every element generates one or more&#13;
rectangular boxes, called <em>element boxes</em>. (Future versions of the&#13;
specification may allow for nonrectangular shapes, and indeed changes have been proposed, but for now all boxes are still &#13;
<span class="keep-together">rectangular.)</span></p>&#13;
&#13;
<p>Each <a data-primary="visual formatting" data-secondary="content area" data-type="indexterm" id="ix_vis_format_content_area"/><a data-primary="content area" data-type="indexterm" id="ix_content_area"/>element box has a <em>content area</em> at its center. This content area is&#13;
surrounded by optional amounts of padding, borders, outlines, and&#13;
margins. These areas are considered optional because they could all be&#13;
set to a size of 0, effectively removing them from the element box.&#13;
<a data-type="xref" href="#bvf_fig01">Figure 6-1</a> shows an example content area, along with the surrounding&#13;
regions of padding, borders, and margins.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig01">&#13;
<img alt="css5 0601" src="assets/css5_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>The content area and its surroundings</h6>&#13;
</div></figure>&#13;
&#13;
<p>Before looking at the properties that can alter the space taken up by elements, let’s cover the vocabulary needed to fully understand how elements are laid out and take up space.<a data-primary="" data-startref="ix_content_area" data-type="indexterm" id="idm45176109519504"/><a data-primary="" data-startref="ix_vis_format_content_area" data-type="indexterm" id="idm45176109518528"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Quick Primer" data-type="sect2"><div class="sect2" id="a-quick-primer">&#13;
<h2>A Quick Primer</h2>&#13;
&#13;
<p>First, we’ll quickly review the kinds of boxes we’ll be discussing, as well as&#13;
some important terms that are needed to understand the explanations to come:</p>&#13;
<dl>&#13;
<dt>Block flow direction</dt>&#13;
<dd>&#13;
<p>Also <a data-primary="visual formatting" data-secondary="block flow direction" data-type="indexterm" id="idm45176109514032"/><a data-primary="block direction (axis)" data-type="indexterm" id="idm45176109513024"/>known as the <em>block axis</em>,  this is the direction along which block-level element boxes are stacked.  <a data-primary="vertical writing direction" data-type="indexterm" id="idm45176109511808"/>In many languages, including all European and European-derived languages, this direction is from top to bottom.  In Chinese/Japanese/Korean (CJK) languages, this can be either right to left or top to bottom.  The actual block flow direction is set by the writing mode, which is discussed in <a data-type="xref" href="ch15.html#text_properties">Chapter 15</a>.</p>&#13;
</dd>&#13;
<dt>Inline base direction</dt>&#13;
<dd>&#13;
<p>Also <a data-primary="visual formatting" data-secondary="inline base direction" data-type="indexterm" id="idm45176109508896"/><a data-primary="inline base direction (axis)" data-type="indexterm" id="idm45176109507888"/>known as the <em>inline axis</em>, this is the direction along which lines of text are written.  In Romanic languages, among others, this is left to right.  In languages such as Arabic or Hebrew, the inline base direction is right to left.  In CJK languages, this can be either top to bottom or left to right.  As with block flow, the inline base direction is set by the writing mode.</p>&#13;
</dd>&#13;
<dt>Normal flow</dt>&#13;
<dd>&#13;
<p>The <a data-primary="visual formatting" data-secondary="normal flow" data-type="indexterm" id="idm45176109505392"/><a data-primary="normal flow" data-type="indexterm" id="idm45176109504384"/>default system by which elements are placed inside the browser’s viewport, based on the parent’s writing mode. Most elements are in the normal flow, and the only way for an element to leave the normal flow is to be floated, positioned, or made into a flexible box, grid layout, or table element. The discussions in this chapter cover elements in the normal flow, unless otherwise stated.</p>&#13;
</dd>&#13;
<dt>Block box</dt>&#13;
<dd>&#13;
<p>This is a <a data-primary="blocks" data-type="indexterm" id="idm45176109502304"/><a data-primary="blocks" data-secondary="element boxes" data-type="indexterm" id="idm45176109501568"/><a data-primary="element boxes" data-secondary="blocks" data-type="indexterm" id="idm45176109500624"/>box generated by an element such as a paragraph, heading, or <code>&lt;div&gt;</code>. These boxes generate blank spaces both before and after their boxes when in the normal flow so that block boxes in the normal flow stack along the block flow axis, one after another. Pretty much any element can be made to generate a block box by declaring <code>display: block</code>, though there are other ways to make elements generate block boxes (e.g., float them or make them flex items).</p>&#13;
</dd>&#13;
<dt>Inline box</dt>&#13;
<dd>&#13;
<p>This is a <a data-primary="inline boxes" data-type="indexterm" id="idm45176109496960"/><a data-primary="element boxes" data-secondary="inline boxes" data-type="indexterm" id="idm45176109496224"/><a data-primary="boxes" data-secondary="element boxes" data-tertiary="inline boxes" data-type="indexterm" id="idm45176109495280"/>box generated by an element such as <code>&lt;strong&gt;</code> or <code>&lt;span&gt;</code>. These boxes are laid out along the inline base direction, and do not generate line breaks before or after themselves. An inline box longer than the inline size of its element will (by default, if it’s nonreplaced) wrap to multiple lines. Any element can be made to generate an inline box by declaring <code>display: inline</code>.</p>&#13;
</dd>&#13;
<dt>Nonreplaced element</dt>&#13;
<dd>&#13;
<p>This is an <a data-primary="nonreplaced elements" data-type="indexterm" id="idm45176109491472"/><a data-primary="positioning" data-secondary="nonreplaced elements" data-type="indexterm" id="idm45176109490736"/><a data-primary="absolute positioning" data-secondary="nonreplaced elements" data-type="indexterm" id="idm45176109489792"/>element whose content is contained within the document. For example, a paragraph (<code>&lt;p&gt;</code>) is a nonreplaced element because its textual content is found within the element itself.</p>&#13;
</dd>&#13;
<dt>Replaced element</dt>&#13;
<dd>&#13;
<p>This is an <a data-primary="positioning" data-secondary="replaced elements" data-type="indexterm" id="idm45176109486688"/><a data-primary="replaced elements" data-type="indexterm" id="idm45176109485712"/><a data-primary="replaced elements" data-secondary="positioning" data-type="indexterm" id="idm45176109485008"/><a data-primary="absolute positioning" data-secondary="replaced elements" data-type="indexterm" id="idm45176109484064"/>element that serves as a placeholder for something else. The classic example of a replaced element is <code>&lt;img&gt;</code>, which simply points to an image file that is inserted into the document’s flow at the point where the <code>&lt;img&gt;</code> element itself is found. <a data-primary="form elements" data-secondary="as replaced elements" data-secondary-sortas="replaced elements" data-type="indexterm" id="idm45176109481952"/>Most form elements are also replaced (e.g., <code>&lt;input type="radio"&gt;</code>).</p>&#13;
</dd>&#13;
<dt>Root element</dt>&#13;
<dd>&#13;
<p>This is the <a data-primary="root elements" data-type="indexterm" id="idm45176109478752"/><a data-primary="elements" data-secondary="root" data-type="indexterm" id="idm45176109478048"/>element at the top of the document tree. In HTML documents, this is the element <code>&lt;html&gt;</code>. In XML documents, it can be whatever the language permits: for example, the root element of RSS files is <code>&lt;rss&gt;</code>, whereas in an SVG document, the root element is <code>&lt;svg&gt;</code>.<a data-primary="" data-startref="ix_box_elem_ch6" data-type="indexterm" id="idm45176109475600"/><a data-primary="" data-startref="ix_elem_box_ch6" data-type="indexterm" id="idm45176109474592"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Containing Block" data-type="sect2"><div class="sect2" id="bvf_the-containing-block">&#13;
<h2>The Containing Block</h2>&#13;
&#13;
<p>We need to <a data-primary="absolute positioning" data-secondary="containing blocks and" data-type="indexterm" id="idm45176109471680"/><a data-primary="containing blocks" data-type="indexterm" id="idm45176109470672"/><a data-primary="containing blocks" data-secondary="positioning and" data-type="indexterm" id="idm45176109470000"/><a data-primary="positioning" data-secondary="containing blocks and" data-type="indexterm" id="idm45176109469056"/>examine one more kind of box in detail, and in&#13;
this case enough detail that it merits its own section: the <em>containing&#13;
block</em>.</p>&#13;
&#13;
<p>Every element’s box is laid out with respect to its containing block. In&#13;
a very real way, the containing block is the <em>layout context</em> for a box.&#13;
CSS defines a series of rules for determining a box’s containing block.</p>&#13;
&#13;
<p>For a given element, the containing&#13;
block <a data-primary="content edge" data-type="indexterm" id="idm45176109466256"/>forms from the <em>content edge</em> of the nearest ancestor element that&#13;
generates a list item or block box, which includes all table-related&#13;
boxes (e.g., those generated by table cells). Consider the following:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;body&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">&lt;p&gt;</code>This<code class="w"> </code>is<code class="w"> </code>a<code class="w"> </code>paragraph.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/body&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In this simple markup, the containing block for the <code>&lt;p&gt;</code> element’s&#13;
block box is the <code>&lt;div&gt;</code> element’s block box, as that is the closest&#13;
ancestor element box that has a block or a list item box (in this case, it’s a&#13;
block box). Similarly, the <code>&lt;div&gt;</code>’s containing block is the <code>&lt;body&gt;</code>’s box.&#13;
Thus, the layout of the <code>&lt;p&gt;</code> is dependent on the layout of the <code>&lt;div&gt;</code>,&#13;
which is in turn dependent on the layout of the <code>&lt;body&gt;</code> element.</p>&#13;
&#13;
<p>And <a data-primary="initial containing block" data-type="indexterm" id="idm45176109437152"/>above that in the document tree, the layout of the <code>&lt;body&gt;</code> element is dependent on the&#13;
layout of the <code>&lt;html&gt;</code> element, whose box creates what is called the&#13;
<em>initial containing block</em>. It’s unique in that the viewport—the browser window in screen&#13;
media, or the printable area of the page in print media—determines the dimensions of the initial containing block, not the&#13;
size of the content of the root element.  This matters because the content can be shorter, and usually longer, than the size of the viewport.  Most of the time it doesn’t make a difference, but when it comes to things such as fixed positioning or viewport units, the difference is real.</p>&#13;
&#13;
<p>Now that you <a data-primary="visual formatting" data-secondary="outlines" data-type="indexterm" id="idm45176109434368"/><a data-primary="visual formatting" data-secondary="borders" data-type="indexterm" id="idm45176109433360"/><a data-primary="border-style property" data-type="indexterm" id="idm45176109432416"/>understand some of the terminology, we can address the properties that make up <a data-type="xref" href="#bvf_fig01">Figure 6-1</a>. The various margin, border, and padding features, such as <code>border-style</code>, can be set using various side-specific longhand properties, such as <code>margin-inline-start</code> or <code>border-bottom-width</code>. (The outline properties do not have side-specific properties; a change to an outline property affects all four sides.)</p>&#13;
&#13;
<p>The content’s <a data-primary="backgrounds" data-secondary="containing block" data-type="indexterm" id="idm45176109429280"/>background—a color or tiled image, for example—is applied within the padding and border areas by default, but this can be changed. The margins are always transparent, allowing the background(s) of any parent element(s) to be visible. Padding and borders cannot be of a negative length, but margins can. We’ll explore the effects of negative margins in <a data-type="xref" href="#negative-margins-and-collapsing">“Negative Margins and Collapsing”</a>.</p>&#13;
&#13;
<p>Borders are <a data-primary="borders" data-secondary="containing block" data-type="indexterm" id="idm45176109426736"/>most often generated using defined styles, with a <code>border-style</code> such as <code>solid</code>, <code>dotted</code>, or <code>inset</code>,&#13;
and their colors are set using the <code>border-color</code> property. If no color&#13;
is set, the value defaults to <code>currentcolor</code>. Borders can also be generated from images. If a border style has gaps&#13;
of some type, as with <code>border-style: dashed</code> or with a border generated from a partially transparent image, then the element’s background is visible through those&#13;
gaps by default, though it is possible to clip the background to stay inside the border (or the padding).<a data-primary="" data-startref="ix_box_basic" data-type="indexterm" id="idm45176109422384"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Altering Element Display" data-type="sect1"><div class="sect1" id="altering-element-display">&#13;
<h1>Altering Element Display</h1>&#13;
&#13;
<p>You can <a data-primary="display roles" data-secondary="changing" data-type="indexterm" id="ix_display_roles_change"/><a data-primary="visual formatting" data-secondary="element display, altering" data-type="indexterm" id="ix_vis_format_elem_disp"/><a data-primary="inline display" data-type="indexterm" id="ix_inline_display"/><a data-primary="elements" data-secondary="display roles" data-type="indexterm" id="ix_elem_display_role"/><a data-primary="display property" data-secondary="altering element display" data-type="indexterm" id="idm45176109397984"/>affect the way a user agent displays by setting a value for the&#13;
<code>display</code> property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176109396384">&#13;
<h1>display</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>display-outside</code></em>&gt; ‖ &lt;<em><code>display-inside</code></em>&gt; ] | &lt;<em><code>display-listitem</code></em>&gt; | &lt;<em><code>display-internal</code></em>&gt; | &lt;<em><code>display-box</code></em>&gt; | &lt;<em><code>display-legacy</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Definitions</strong></p></td>&#13;
<td><p>See below</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>inline</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<dl>&#13;
<dt>&lt;<em><code>display-outside</code></em>&gt;</dt>&#13;
<dd>&#13;
<p><code>block</code> | <code>inline</code> | <code>run-in</code></p>&#13;
</dd>&#13;
<dt>&lt;<em><code>display-inside</code></em>&gt;</dt>&#13;
<dd>&#13;
<p><code>flow</code> | <code>flow-root</code> | <code>table</code> | <code>flex</code> | <code>grid</code> | <code>ruby</code></p>&#13;
</dd>&#13;
<dt>&lt;<em><code>display-listitem</code></em>&gt;</dt>&#13;
<dd>&#13;
<p><code>list-item</code> &amp;&amp; &lt;<em><code>display-outside</code></em>&gt;? &amp;&amp; [ <code>flow</code> | <code>flow-root</code> ]?</p>&#13;
</dd>&#13;
<dt>&lt;<em><code>display-internal</code></em>&gt;</dt>&#13;
<dd>&#13;
<p><code>table-row-group</code> | <code>table-header-group</code> | <code>table-footer-group</code> | <code>table-row</code> | <code>table-cell</code> | <code>table-column-group</code> | <code>table-column</code> | <code>table-caption</code> | &#13;
<span class="keep-together"><code>ruby-base</code> |</span> <code>ruby-text</code> | <code>ruby-base-container</code> | <code>ruby-text-container</code></p>&#13;
</dd>&#13;
<dt>&lt;<em><code>display-box</code></em>&gt;</dt>&#13;
<dd>&#13;
<p><code>contents</code> | <code>none</code></p>&#13;
</dd>&#13;
<dt>&lt;<em><code>display-legacy</code></em>&gt;</dt>&#13;
<dd>&#13;
<p><code>inline-block</code> | <code>inline-list-item</code> | <code>inline-table</code> | <code>inline-flex</code> | <code>inline-grid</code></p>&#13;
</dd>&#13;
</dl>&#13;
</div></aside>&#13;
&#13;
<p>We’re going to ignore the <code>ruby</code>- and <code>table</code>-related values, since they’re far too complex for this chapter.  We’ll also temporarily ignore the value <code>list-item</code>, since it’s very similar to block boxes and is explored in detail in <a data-type="xref" href="ch16.html#lists-and-generated-content">Chapter 16</a>.  For now, we’ll spend a moment talking about how altering an element’s display role can alter layout.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Changing Roles" data-type="sect2"><div class="sect2" id="changing-roles">&#13;
<h2>Changing Roles</h2>&#13;
&#13;
<p>When it comes to styling a document, it’s sometimes handy to be able to&#13;
change the type of box an element generates. For example, suppose we&#13;
have a series of links in a <code>&lt;nav&gt;</code> that we’d like to lay out as a&#13;
vertical sidebar:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;nav&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"index.html"</code><code class="nt">&gt;</code>WidgetCo<code class="w"> </code>Home<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"products.html"</code><code class="nt">&gt;</code>Products<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"services.html"</code><code class="nt">&gt;</code>Services<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"fun.html"</code><code class="nt">&gt;</code>Widgety<code class="w"> </code>Fun!<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"support.html"</code><code class="nt">&gt;</code>Support<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"about.html"</code><code class="w"> </code><code class="na">id=</code><code class="s">"current"</code><code class="nt">&gt;</code>About<code class="w"> </code>Us<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"contact.html"</code><code class="nt">&gt;</code>Contact<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/nav&gt;</code><code class="w"/></pre>&#13;
&#13;
<p class="less_space pagebreak-before">By default, the links will generate inline boxes, and thus get sort of mushed together into what looks like a short paragraph of nothing but links.  We could put all the links into their own paragraphs or list items, or we could just make them all block-level elements, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="nt">a</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">block</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will make every <code>&lt;a&gt;</code> element within the navigation element <code>&lt;nav&gt;</code> generate a block box, instead of its usual inline box. If we add on a few more styles, we could have a result like&#13;
that shown in <a data-type="xref" href="#bvf_fig02">Figure 6-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig02">&#13;
<img alt="css5 0602" src="assets/css5_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>Changing the display role from inline to block</h6>&#13;
</div></figure>&#13;
&#13;
<p>Changing display roles can be useful when you want the navigation links to be inline elements if the CSS isn’t available (perhaps by failing to load), but to lay out&#13;
the same links as block-level elements in CSS-aware contexts. You could also present the links as inline on desktop displays and block on mobile devices, or vice versa. With the links laid out as blocks, you&#13;
can style them as you would <code>&lt;div&gt;</code> or <code>&lt;p&gt;</code> elements, with the advantage&#13;
that the entire element box becomes part of the link.</p>&#13;
&#13;
<p>You may also want to take elements and make them inline. Suppose we have&#13;
an &#13;
<span class="keep-together">unordered</span> list of names:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;ul</code><code class="w"> </code><code class="na">id=</code><code class="s">"rollcall"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Bob<code class="w"> </code>C.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Marcio<code class="w"> </code>G.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Eric<code class="w"> </code>M.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Kat<code class="w"> </code>M.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Tristan<code class="w"> </code>N.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Arun<code class="w"> </code>R.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Doron<code class="w"> </code>R.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Susie<code class="w"> </code>W.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/ul&gt;</code><code class="w"/></pre>&#13;
&#13;
<p class="less_space pagebreak-before">Given <a data-primary="list-item display" data-type="indexterm" id="idm45176109205936"/>this markup, say we want our display to show a series of inline&#13;
names with vertical bars between them (and on each end of the list). The&#13;
only way to do so is to change their display role. The following rules&#13;
will have the effect shown in <a data-type="xref" href="#bvf_fig03">Figure 6-3</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#rollcall</code> <code class="nt">li</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">inline</code><code class="p">;</code> <code class="k">border-right</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0</code> <code class="m">0.33em</code><code class="p">;}</code>&#13;
<code class="nf">#rollcall</code> <code class="nt">li</code><code class="nd">:first-child</code> <code class="p">{</code><code class="k">border-left</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="bvf_fig03">&#13;
<img alt="css5 0603" src="assets/css5_0603.png"/>&#13;
<h6><span class="label">Figure 6-3. </span>Changing the display role from <code>list-item</code> to <code>inline</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>Understand that you are, for the most part, changing the display role of elements—not changing their inherent nature. In other words, causing a paragraph to generate an inline box does <em>not</em> turn that paragraph into an inline element. In HTML, for example, some elements are block while others are inline. While a <code>&lt;span&gt;</code> can easily be placed&#13;
inside a paragraph, a <code>&lt;span&gt;</code> should not be wrapped around a paragraph.</p>&#13;
&#13;
<p>We say “for the most part” because while <a data-primary="accessibility issues" data-secondary="element display role changes" data-type="indexterm" id="idm45176109100080"/>CSS mostly impacts presentation and not content, CSS properties can impact accessibility in more ways than just color contrast. For example, changing the <code>display</code> value can impact the way an element is perceived by assistive technologies. Setting an element’s <code>display</code> property to <code>none</code> removes the element from the accessibility tree. Setting the <code>display</code> property on a <code>&lt;table&gt;</code> to <code>grid</code> may cause the table to be interpreted as something other than a data table, removing normal table keyboard navigation, and making the table inaccessible as a data table to screen-reader users.  (This shouldn’t happen, but it does in some browsers.)</p>&#13;
&#13;
<p>This can be <a data-primary="Accessible Rich Internet Applications (ARIA)" data-type="indexterm" id="idm45176109095920"/><a data-primary="ARIA (Accessible Rich Internet Applications)" data-type="indexterm" id="idm45176109095216"/>mitigated by setting the Accessible Rich Internet Applications (ARIA) <code>role</code> attribute for the table and all its descendants. However, in general, anytime a change you make in CSS forces you to make changes in ARIA roles, you should take a moment to consider whether there isn’t a better way to accomplish your goal.<a data-primary="" data-startref="ix_inline_display" data-type="indexterm" id="idm45176109094064"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Handling Block Boxes" data-type="sect2"><div class="sect2" id="block-boxes">&#13;
<h2>Handling Block Boxes</h2>&#13;
&#13;
<p>Block <a data-primary="vertical formatting" data-secondary="block boxes" data-type="indexterm" id="ix_vert_format_blocks"/><a data-primary="blocks" data-secondary="vertical formatting" data-type="indexterm" id="ix_blocks_vert_format"/><a data-primary="horizontal formatting" data-secondary="block boxes" data-type="indexterm" id="ix_horiz_format_blocks"/><a data-primary="blocks" data-secondary="horizontal formatting" data-type="indexterm" id="ix_blocks_horiz_format"/><a data-primary="writing modes (flow direction)" data-secondary="block box handling" data-type="indexterm" id="ix_write_mode_blocks"/><a data-primary="element boxes" data-secondary="blocks" data-type="indexterm" id="ix_elem_box_blocks"/><a data-primary="blocks" data-secondary="writing modes" data-type="indexterm" id="ix_blocks_writing_modes"/><a data-primary="blocks" data-type="indexterm" id="ix_blocks_ch6"/>boxes behave in predictable, yet sometimes surprising,&#13;
ways. The handling of box placement along the block and inline&#13;
axes can differ, for example. To fully understand how block&#13;
boxes are handled, you must clearly understand several aspects of these boxes. They are shown in detail in <a data-type="xref" href="#css5_07box">Figure 6-4</a>, which illustrates placement in two different &#13;
<span class="keep-together">writing modes.</span></p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="css5_07box">&#13;
<img alt="css5 0604" src="assets/css5_0604.png"/>&#13;
<h6><span class="label">Figure 6-4. </span>The complete box model in two different writing modes</h6>&#13;
</div></figure>&#13;
&#13;
<p>As <a data-primary="visual formatting" data-secondary="horizontal formatting" data-type="indexterm" id="ix_vis_format_horiz"/>shown in <a data-type="xref" href="#css5_07box">Figure 6-4</a>, <a data-primary="blocks" data-secondary="element boxes" data-type="indexterm" id="idm45176109047008"/><a data-primary="writing modes (flow direction)" data-type="indexterm" id="ix_write_mode_flow"/>CSS deals with the block directions and inline directions, as well as block sizes and inline sizes.  Block and inline sizes are descriptions of the size of the content area (by default) along the block and inline axes.</p>&#13;
&#13;
<p class="less_space pagebreak-before">By contrast, the <em>width</em> (sometimes referred to as the <em>physical width</em>) of a block box is defined as the distance between the inner edges of the content area (again, by default) along the horizontal axis (left to right), regardless of the writing direction, and the <em>height</em> (<em>physical height</em>) is&#13;
the distance along the vertical axis (top to bottom).  Properties are available to set all these sizes, which we’ll talk about shortly.</p>&#13;
&#13;
<p>Something important to note in <a data-type="xref" href="#css5_07box">Figure 6-4</a> is the use of <em>start</em> and <em>end</em> to describe various parts of the element box.  <a data-primary="logical properties" data-secondary="margins" data-type="indexterm" id="idm45176109040240"/>For example, you’ll see a block-start margin and a block-end margin.  The <em>start edge</em> is the edge that you come to first as you move along an axis.</p>&#13;
&#13;
<p>This <a data-primary="boxes" data-secondary="element boxes" data-tertiary="edges" data-type="indexterm" id="idm45176109038272"/>may be clearer if you look at <a data-type="xref" href="#css5_07block-inline-axes">Figure 6-5</a> and trace your finger along each axis from arrow tail to tip.  As you move along a block axis, the first edge you come to for each element is that element’s block-start edge.  As you pass out of the element, you move through the block-end edges.  Similarly, as you move along an inline axis, you go through the inline-start edges, across the inline dimension of the content, and then out the inline-end edges.  Try it for each of the three examples.<a data-primary="" data-startref="ix_elem_display_role" data-type="indexterm" id="idm45176109036128"/><a data-primary="" data-startref="ix_vis_format_elem_disp" data-type="indexterm" id="idm45176109035280"/><a data-primary="" data-startref="ix_display_roles_change" data-type="indexterm" id="idm45176109034432"/><a data-primary="" data-startref="ix_blocks_writing_modes" data-type="indexterm" id="idm45176109033584"/><a data-primary="" data-startref="ix_elem_box_blocks" data-type="indexterm" id="idm45176109032704"/><a data-primary="" data-startref="ix_write_mode_blocks" data-type="indexterm" id="idm45176109031760"/></p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="css5_07block-inline-axes">&#13;
<img alt="css5 0605" src="assets/css5_0605.png"/>&#13;
<h6><span class="label">Figure 6-5. </span>The block- and inline-axis directions for three common writing modes</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logical Element Sizing" data-type="sect1"><div class="sect1" id="logical-element-sizing">&#13;
<h1>Logical Element Sizing</h1>&#13;
&#13;
<p>Because CSS <a data-primary="visual formatting" data-secondary="sizing of logical element" data-type="indexterm" id="ix_vis_format_logical_size"/><a data-primary="writing modes (flow direction)" data-secondary="logical element sizing" data-type="indexterm" id="ix_write_mode_log_elem"/><a data-primary="properties" data-secondary="logical" data-type="indexterm" id="ix_prop_logic"/><a data-primary="vertical formatting" data-secondary="logical element sizing" data-type="indexterm" id="ix_vert_format_logical"/><a data-primary="horizontal formatting" data-secondary="logical element sizing" data-type="indexterm" id="ix_horiz_format_logic"/><a data-primary="logical properties" data-secondary="element sizing" data-type="indexterm" id="ix_logic_prop_size"/>recognizes block and inline axes for elements, it provides properties that let you set an explicit element size along each axis.<a data-primary="block-size property" data-type="indexterm" id="ix_block_size"/><a data-primary="inline-size property" data-type="indexterm" id="idm45176109018320"/></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176109017520">&#13;
<h1>block-size, inline-size</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | <code>min-content</code> | <code>max-content</code> | <code>fit-content</code> | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements except nonreplaced inline elements, table rows, and row groups</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Calculated with respect to the length of the element’s containing block along the block-flow axis (for <code>block-size</code>) or inline-flow axis (for <code>inline-size</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For <code>auto</code> and percentage values, as specified; otherwise, an absolute length, unless the property does not apply to the element (then <code>auto</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>These properties allow you to set the size of an element along its block axis, or to constrain the lengths of lines of text along the inline axis, regardless of the direction of text flow.  If you write <code>block-size: 500px</code>, the element’s block size will be 500 pixels wide, even if that leads to content spilling out of the element box.  (We’ll discuss that in more detail later in the chapter.)</p>&#13;
&#13;
<p>Consider the following, which has the results shown in <a data-type="xref" href="#sizing-elements-inline-axis">Figure 6-6</a> when applied in various writing modes:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">25ch</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="sizing-elements-inline-axis">&#13;
<img alt="css5 0606" src="assets/css5_0606.png"/>&#13;
<h6><span class="label">Figure 6-6. </span>Sizing elements along their inline axis</h6>&#13;
</div></figure>&#13;
&#13;
<p>As seen in <a data-type="xref" href="#sizing-elements-inline-axis">Figure 6-6</a>, the elements are sized consistently along their inline axis, regardless of the writing direction.  If you tilt your head to the side, you can see that the lines wrap in exactly the same places.  This yields a consistent line length across all writing modes.</p>&#13;
&#13;
<p>Similarly, you can set a block size for elements.  This is used a bit more often for replaced elements like images, but it can be used in any circumstance that makes sense.  Take this as an example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="nt">img</code> <code class="p">{</code><code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">1.5em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Having done that, any <code>&lt;img&gt;</code> element found inside a <code>&lt;p&gt;</code> element will have its block size set to one and a half times the size of the surrounding text.  (This works on images because they’re inline replaced elements; it wouldn’t work on inline nonreplaced elements.)  You could also use <code>block-size</code> to constrain the block length of grid layout items to be a minimum or maximum size, such as this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#maingrid</code> <code class="o">&gt;</code> <code class="nt">nav</code> <code class="p">{</code><code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="n">clamp</code><code class="p">(</code><code class="m">2rem</code><code class="o">,</code> <code class="m">4em</code><code class="o">,</code> <code class="m">25vh</code><code class="p">);}</code></pre>&#13;
&#13;
<p>It should be said that usually block size is determined automatically, because elements in the normal flow often don’t have an explicitly set block size.  For example, if an&#13;
element’s block flow is top to bottom and it’s 8 lines long, and each line is 1/8th of an inch tall,&#13;
then its block size will be 1 inch. If it’s 10 lines tall,&#13;
the block size is instead 1.25 inches. In either case, as long as <code>block-size</code> is <code>auto</code>, the block size is determined by the content of the element, not by the author.  This is usually what you want, particularly for elements containing text.  When <code>block-size</code> is explicitly set and there isn’t enough content to fill the box, empty space will appear inside the box; if there is more content than can fit, the content may overflow the box or scrollbars may appear.<a data-primary="" data-startref="ix_blocks_ch6" data-type="indexterm" id="idm45176108903872"/><a data-primary="" data-startref="ix_blocks_horiz_format" data-type="indexterm" id="idm45176108902928"/><a data-primary="" data-startref="ix_blocks_vert_format" data-type="indexterm" id="idm45176108900896"/><a data-primary="" data-startref="ix_horiz_format_blocks" data-type="indexterm" id="idm45176108899952"/><a data-primary="" data-startref="ix_vert_format_blocks" data-type="indexterm" id="idm45176108899008"/><a data-primary="" data-startref="ix_block_size" data-type="indexterm" id="idm45176108898064"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Content-Based Sizing Values" data-type="sect2"><div class="sect2" id="idm45176108896992">&#13;
<h2>Content-Based Sizing Values</h2>&#13;
&#13;
<p>Beyond the <a data-primary="horizontal formatting" data-secondary="content-based sizing" data-type="indexterm" id="ix_horiz_format_content"/><a data-primary="vertical formatting" data-secondary="content-based sizing" data-type="indexterm" id="ix_vert_format_content"/>lengths and percentages you saw previously for setting block and inline sizes, a few keywords provide content-based sizing:</p>&#13;
<dl>&#13;
<dt><code>max-content</code></dt>&#13;
<dd>&#13;
<p>Take<a data-primary="max-content keyword" data-type="indexterm" id="idm45176108890880"/> up the most space possible to fit in the content, even suppressing line wrapping in the case of text content.</p>&#13;
</dd>&#13;
<dt><code>min-content</code></dt>&#13;
<dd>&#13;
<p>Take<a data-primary="min-content keyword" data-type="indexterm" id="idm45176108888480"/> up the least space possible to fit in the content.</p>&#13;
</dd>&#13;
<dt><code>fit-content</code></dt>&#13;
<dd>&#13;
<p>Take<a data-primary="fit-content keyword" data-type="indexterm" id="idm45176108885984"/><a data-primary="flex-basis property" data-secondary="fit-content keyword" data-type="indexterm" id="idm45176108885248"/> up the amount of space determined by calculating the values of <code>max-content</code>, <code>min-content</code>, and regular content sizing, taking the maximum of <code>min-content</code> and regular sizing, and then taking the minimum of <code>max-content</code> and whichever value was the greater of <code>min-content</code> and regular sizing.  Yes, that all sounds a bit confusing, but we’ll explain it in a moment.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>If you’ve worked at all with CSS Grid (covered in <a data-type="xref" href="ch12.html#grid-layout">Chapter 12</a>), you may recognize these keywords, as they were originally defined as ways to size grid items.  Now they’re making their way into other areas of CSS.  Let’s consider the first two keywords, which are &#13;
<span class="keep-together">demonstrated</span> in <a data-type="xref" href="#content-sizing">Figure 6-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="content-sizing">&#13;
<img alt="css5 0607" src="assets/css5_0607.png"/>&#13;
<h6><span class="label">Figure 6-7. </span>Content sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p>The paragraph on the left is set to <code>max-content</code>, and that’s what happens:  the paragraph is made as wide as needed to fit all of the content.  It’s as narrow as it is only because there isn’t much content.  Had we added another three sentences, the single line of text would have just kept going and going with no line wrapping, even if it ran right off the page (or out of the browser window).</p>&#13;
&#13;
<p>In the paragraph on the right, the content is as narrow as possible without forcing breaks or hyphens inside words.  In this particular case, the element is <em>just</em> wide enough to fit the word “paragraph,” which is the longest word in the content.  For every other line of text in the example, the browser places as many words as will fit into the space needed for “paragraph,” and goes to the next line when it runs out of room.  If we added “antidisestablishmentarianism” to the text, the element would become just wide enough to fit <em>that</em> word, and every other line of text would very likely contain multiple words.</p>&#13;
&#13;
<p>Notice that, at the end of the <code>min-content</code> example in <a data-type="xref" href="#content-sizing">Figure 6-7</a>, the browser took advantage of the presence of the hyphen in <code>min-content</code> to trigger a line wrap there.  Had it not made that choice, <code>min-content</code> would almost certainly have been the longest piece of content in the paragraph, and the element’s width would have been set to that length.  This means that if your content contains symbols that browsers understand to be natural line-wrapping points (e.g., spaces and hyphens), they’ll likely be considered in the <code>min-content</code> calculations.  If you want to squeeze the element width even further, you can enable auto-hyphenating of words with the <code>hyphens</code> property (see <a data-type="xref" href="ch15.html#text_properties">Chapter 15</a>).</p>&#13;
&#13;
<p>For some more examples of <code>min-content</code> sizing, see <a data-type="xref" href="#minimum-content-sizing">Figure 6-8</a>.</p>&#13;
&#13;
<figure><div class="figure" id="minimum-content-sizing">&#13;
<img alt="css5 0608" src="assets/css5_0608.png"/>&#13;
<h6><span class="label">Figure 6-8. </span>Minimum content sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <a data-primary="fit-content keyword" data-type="indexterm" id="idm45176108851168"/><a data-primary="flex-basis property" data-secondary="fit-content keyword" data-type="indexterm" id="idm45176108850432"/>third keyword, <code>fit-content</code>, is interesting in that it does its best to fit the element to the content.  What that means in practice is that if you have only a little content, the element’s inline size (usually its width)  will be just big enough to enclose it, as if <code>max-content</code> were used.  If there’s enough content to wrap to multiple lines or otherwise threaten to overflow the element’s container, the inline size stops there.  This is illustrated in <a data-type="xref" href="#fit-content-sizing">Figure 6-9</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fit-content-sizing">&#13;
<img alt="css5 0609" src="assets/css5_0609.png"/>&#13;
<h6><span class="label">Figure 6-9. </span>Fit-content sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p>In each case, the element is fit to the content without overspilling the element’s container.  At least, that’s what happens with elements in the normal flow.  The behavior can be quite different in flexbox and grid contexts, and is further explored in later chapters.<a data-primary="" data-startref="ix_vert_format_content" data-type="indexterm" id="idm45176108845280"/><a data-primary="" data-startref="ix_horiz_format_content" data-type="indexterm" id="idm45176108844304"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Minimum and Maximum Logical Sizing" data-type="sect2"><div class="sect2" id="idm45176108843104">&#13;
<h2>Minimum and Maximum Logical Sizing</h2>&#13;
&#13;
<p>If you’d <a data-primary="max-block-size property" data-type="indexterm" id="idm45176108841664"/><a data-primary="max-inline-size property" data-type="indexterm" id="idm45176108840928"/><a data-primary="min-block-size property" data-type="indexterm" id="idm45176108840288"/><a data-primary="min-inline-size property" data-type="indexterm" id="idm45176108839616"/>like to set minimum and maximum bounds on block or inline sizes, CSS has some properties to help you out.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176108838592">&#13;
<h1>min-block-size, max-block-size, min-inline-size, max-inline-size</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>Same as for <code>block-size</code> and <code>inline-size</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Same as for <code>block-size</code> and <code>inline-size</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Same as for <code>block-size</code> and <code>inline-size</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Same as for <code>block-size</code> and <code>inline-size</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>These properties can be very useful when you know you want upper and lower bounds on the sizing of an element’s box, and are willing to allow the browser to do whatever it wants as long as it obeys those restrictions.  As an example, you might set part of a layout like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">main</code> <code class="p">{</code><code class="n">min</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="n">min</code><code class="o">-</code><code class="n">content</code><code class="p">;</code> <code class="n">max</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">75ch</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That keeps the <code>&lt;main&gt;</code> element from getting any narrower than the widest bit of inline content, whether that’s a long word or an illustration or something else.  It also keeps the <code>&lt;main&gt;</code> element from getting any wider than around 75 characters, thus keeping line lengths to a readable amount.</p>&#13;
&#13;
<p>It’s also possible to set bounds on block sizing.  A good example is limiting any image embedded in the normal flow to be its intrinsic size up to a certain point.  The following CSS would have the effects shown in <a data-type="xref" href="#maximum-block-sizing">Figure 6-10</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#cb1</code> <code class="nt">img</code> <code class="p">{</code><code class="n">max</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">2em</code><code class="p">;}</code>&#13;
<code class="nf">#cb2</code> <code class="nt">img</code> <code class="p">{</code><code class="n">max</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="maximum-block-sizing">&#13;
<img alt="css5 0610" src="assets/css5_0610.png"/>&#13;
<h6><span class="label">Figure 6-10. </span>Maximum block sizing</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Height and Width" data-type="sect2"><div class="sect2" id="height-and-width">&#13;
<h2>Height and Width</h2>&#13;
&#13;
<p>If you’ve <a data-primary="height property" data-secondary="logical element sizing" data-type="indexterm" id="ix_height_prop"/><a data-primary="width property" data-secondary="logical element sizing" data-type="indexterm" id="ix_width_prop"/><a data-primary="logical properties" data-secondary="margins" data-type="indexterm" id="ix_log_prop_margin"/>used CSS for a while or are maintaining legacy code, you’re probably used to thinking of “top margin” and “bottom margin.”  That’s because, originally, all box model aspects were described in terms of their physical directions: top, right, bottom, and left.  You can still work with the physical directions! CSS has simply added new directions to the mix.</p>&#13;
&#13;
<p>If you were to change <code>inline-size</code> to <code>width</code> in the previous code example, you’d get a result more like that shown in <a data-type="xref" href="#sizing-elements-width">Figure 6-11</a> (in which the vertical writing modes are clipped off well short of their full height).</p>&#13;
&#13;
<figure><div class="figure" id="sizing-elements-width">&#13;
<img alt="css5 0611" src="assets/css5_0611.png"/>&#13;
<h6><span class="label">Figure 6-11. </span>Sizing elements’ width</h6>&#13;
</div></figure>&#13;
&#13;
<p>These elements are made <code>40ch</code> wide horizontally, regardless of their writing mode.  Each element’s height has been automatically determined by the content, the specifics of the writing mode, and so on.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you use block and inline properties like <code>block-size</code> instead of physical directions like <code>height</code>, and your design is applied to content translated to other languages, the layout will automatically adjust to your intentions.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176108734400">&#13;
<h1>height, width</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | <code>min-content</code> | <code>max-content</code> | <code>fit-content</code> | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements except nonreplaced inline elements, table rows, and row groups</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Calculated with respect to the vertical height (for <code>height</code>) or horizontal width (for <code>width</code>) of the containing block; for <code>height</code>, set to <code>auto</code> if the <code>height</code> of its containing block is <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For <code>auto</code> and percentage values, as specified; otherwise, an absolute length, unless the property does not apply to the element (then <code>auto</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>height</code> and <code>width</code> properties are <a data-primary="physical properties" data-type="indexterm" id="idm45176108688400"/>known as <em>physical properties</em>.  They refer to physical directions, as opposed to the writing-dependent directions of block size and inline size.  Thus, <code>height</code> really does refer to the distance from the top to the bottom of the element’s inner edge, regardless of the direction of the block axis.</p>&#13;
&#13;
<p>In writing with a horizontal inline axis, such as English or Arabic, if both <code>inline-size</code> and <code>width</code> are set on the same element, the one declared later will take precedence over the first one declared.  The same is true if <code>block-size</code> and <code>height</code> are both declared; if origin, layer, and specificity are the same, the one declared last takes precedence.  In vertical writing modes, <code>inline-size</code> corresponds to <code>height</code>, and <code>block-size</code> to <code>width</code>.</p>&#13;
&#13;
<p>Setting a block box’s height or width as a &lt;<em><code>length</code></em>&gt; means it will be that length tall or wide, regardless of the content within it.  If you set an element that generates a block box to <code>width: 200px</code>, it will be 200 pixels wide, even if it has a 500-pixel-wide image inside it.</p>&#13;
&#13;
<p>Setting the value of <code>width</code> to a &lt;<em><code>percentage</code></em>&gt; means the width of the element will be that percentage of its containing block’s width.  If you set a paragraph to <code>width: 50%</code> and its containing block is 1,024 pixels wide, then the paragraph’s <code>width</code> will be computed to 512 pixels.</p>&#13;
&#13;
<p>Setting <code>height</code> to a &lt;<em><code>percentage</code></em>&gt; works similarly, except this works only if the containing block has an explicitly set height.  If the containing block’s height is automatically set, a percentage value is treated as <code>auto</code> instead, as seen in the <code>#cb4</code> example in <a data-type="xref" href="#heights-and-widths">Figure 6-12</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The handling of <code>auto</code> top and bottom margins is different for&#13;
positioned elements, as well as flexible-box and grid elements. The differences are covered in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11.html#flexbox">11</a> and&#13;
<a data-type="xref" data-xrefstyle="select:labelnumber" href="ch12.html#grid-layout">12</a>.</p>&#13;
</div>&#13;
&#13;
<p>Here are some examples of these values and combinations, with the result shown in <a data-type="xref" href="#heights-and-widths">Figure 6-12</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">[</code><code class="nt">id</code><code class="o">^=</code><code class="s2">"cb"</code><code class="o">]</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;}</code>  <code class="c">/* "cb" for "containing block" */</code>&#13;
<code class="nf">#cb1</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code>    <code class="nf">#cb1</code> <code class="nt">p</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nf">#cb2</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">400px</code><code class="p">;}</code>   <code class="nf">#cb2</code> <code class="nt">p</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">300px</code><code class="p">;}</code>&#13;
<code class="nf">#cb3</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">400px</code><code class="p">;}</code>   <code class="nf">#cb3</code> <code class="nt">p</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">50%</code><code class="p">;}</code>&#13;
&#13;
<code class="nf">#cb4</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code>   <code class="nf">#cb4</code> <code class="nt">p</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">50%</code><code class="p">;}</code>&#13;
<code class="nf">#cb5</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">300px</code><code class="p">;}</code>  <code class="nf">#cb5</code> <code class="nt">p</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">200px</code><code class="p">;}</code>&#13;
<code class="nf">#cb6</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">300px</code><code class="p">;}</code>  <code class="nf">#cb6</code> <code class="nt">p</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">50%</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="heights-and-widths">&#13;
<img alt="css5 0612" src="assets/css5_0612.png"/>&#13;
<h6><span class="label">Figure 6-12. </span>Heights and widths</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can also use <code>max-content</code> and <code>min-content</code> with the <code>height</code> property, but in top-to-bottom block flows, both are the same as <code>height: auto</code>.  In writing modes using a horizontal block axis, setting these values for <code>height</code> will have similar effects as setting them for <code>width</code> in vertical block flows.</p>&#13;
&#13;
<p>In addition, these properties don’t apply to&#13;
inline nonreplaced elements. For example, if you try to declare a&#13;
<code>height</code> and <code>width</code> for a hyperlink that’s in the normal flow and&#13;
generates an inline box, CSS-conformant browsers <em>must</em> ignore those&#13;
declarations. Assume the following rules:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:any-link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">15px</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">60px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>You’ll end up with red unvisited links on silver backgrounds whose&#13;
height and width are determined by the content of the links. The links will&#13;
<em>not</em> have content areas that are 15 pixels tall by 60 pixels wide,&#13;
as these must be ignored when applied to inline nonreplaced elements. If,&#13;
on the other hand, you add a <code>display</code> value, such as <code>inline-block</code> or&#13;
<code>block</code>, then <code>height</code> and <code>width</code> <em>will</em> set the height and width of&#13;
the links’ content areas.<a data-primary="" data-startref="ix_write_mode_flow" data-type="indexterm" id="idm45176108502544"/><a data-primary="" data-startref="ix_vis_format_horiz" data-type="indexterm" id="idm45176108501568"/><a data-primary="" data-startref="ix_horiz_format_logic" data-type="indexterm" id="idm45176108500624"/><a data-primary="" data-startref="ix_logic_prop_size" data-type="indexterm" id="idm45176108499680"/><a data-primary="" data-startref="ix_prop_logic" data-type="indexterm" id="idm45176108498736"/><a data-primary="" data-startref="ix_vert_format_logical" data-type="indexterm" id="idm45176108472224"/><a data-primary="" data-startref="ix_vis_format_logical_size" data-type="indexterm" id="idm45176108471376"/><a data-primary="" data-startref="ix_write_mode_log_elem" data-type="indexterm" id="idm45176108470528"/><a data-primary="" data-startref="ix_width_prop" data-type="indexterm" id="idm45176108469680"/><a data-primary="" data-startref="ix_height_prop" data-type="indexterm" id="idm45176108468800"/><a data-primary="" data-startref="ix_log_prop_margin" data-type="indexterm" id="idm45176108467856"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Altering Box Sizing" data-type="sect1"><div class="sect1" id="altering-box-sizing">&#13;
<h1>Altering Box Sizing</h1>&#13;
&#13;
<p>If it <a data-primary="horizontal formatting" data-secondary="box sizing" data-type="indexterm" id="ix_horiz_format_box_size"/><a data-primary="vertical formatting" data-secondary="box sizing" data-type="indexterm" id="ix_vert_format_box_size"/><a data-primary="boxes" data-secondary="sizing alterations" data-type="indexterm" id="ix_box_sizing"/><a data-primary="box-sizing property" data-type="indexterm" id="ix_box_sizing_prop"/><a data-primary="blocks" data-secondary="sizing of" data-type="indexterm" id="ix_block_size2"/>seems a little weird to use <code>height</code> and <code>width</code> (and <code>block-size</code> and <code>inline-size</code>) to describe the sizing of the element’s content area instead of its visible area, you can make that sizing more intuitive by using the property <code>box-sizing</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176108457232">&#13;
<h1>box-sizing</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>content-box</code> | <code>border-box</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>content-box</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements that accept <code>width</code> or <code>height</code> values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This property changes what the values of the <code>height</code>, <code>width</code>, <code>block-size</code>, and <code>inline-size</code> properties do.</p>&#13;
&#13;
<p>If you declare <code>inline-size: 400px</code> and don’t declare a value for <code>box-sizing</code>, the element’s content area will be 400 pixels in the inline direction, and any padding, borders, and so on will be added to that. If, on the other hand, you declare <code>box-sizing: border-box</code>, the element box will be 400 pixels from the inline-start border edge to the inline-end border edge; any inline-start or -end border or padding will be placed within that distance, thus shrinking the inline size of the content area.  This is illustrated in <a data-type="xref" href="#bvf_fig05">Figure 6-13</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig05">&#13;
<img alt="css5 0613" src="assets/css5_0613.png"/>&#13;
<h6><span class="label">Figure 6-13. </span>The effects of <code>box-sizing</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>Put <a data-primary="visual formatting" data-secondary="borders" data-type="indexterm" id="ix_vis_format_border"/>another way, if you declare <code>width: 400px</code> and don’t declare a value for&#13;
<code>box-sizing</code>, the element’s content area will be 400 pixels wide, and&#13;
any padding, borders, and so on will be added to that. If, on the other&#13;
hand, you declare <code>box-sizing: border-box</code>, the element box will be 400 pixels&#13;
from the left outer border edge to the right outer border edge; any left or right&#13;
border or padding will be placed within that distance, thus shrinking&#13;
the width of the content area (again, as seen in <a data-type="xref" href="#bvf_fig05">Figure 6-13</a>).</p>&#13;
&#13;
<p>We’re talking about the <code>box-sizing</code> property here because, as stated,&#13;
it applies to “all elements that accept <code>width</code> or <code>height</code> values” (because it was defined before logical properties were commonplace). That’s most often elements generating block boxes, though it also&#13;
applies to replaced inline elements like images, as well as inline-block&#13;
boxes.</p>&#13;
&#13;
<p>Having established how to size elements in both logical and physical ways, let’s widen our scope and look at all the properties that affect block sizing.<a data-primary="" data-startref="ix_block_size2" data-type="indexterm" id="idm45176108429952"/><a data-primary="" data-startref="ix_box_sizing" data-type="indexterm" id="idm45176108428976"/><a data-primary="" data-startref="ix_box_sizing_prop" data-type="indexterm" id="idm45176108428032"/><a data-primary="" data-startref="ix_horiz_format_box_size" data-type="indexterm" id="idm45176108427088"/><a data-primary="" data-startref="ix_vert_format_box_size" data-type="indexterm" id="idm45176108426176"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Block-Axis Properties" data-type="sect1"><div class="sect1" id="block-axis-properties">&#13;
<h1>Block-Axis Properties</h1>&#13;
&#13;
<p>In <a data-primary="blocks" data-secondary="block-axis properties" data-type="indexterm" id="ix_blocks_blockaxis_props"/><a data-primary="boxes" data-secondary="block-axis properties" data-type="indexterm" id="ix_box_blockaxis_props"/><a data-primary="block-axis properties" data-type="indexterm" id="ix_block_axis_props"/><a data-primary="border-block-end property" data-type="indexterm" id="idm45176108419600"/><a data-primary="border-block-start property" data-type="indexterm" id="idm45176108418960"/><a data-primary="margin-block-end property" data-type="indexterm" id="idm45176108418320"/><a data-primary="margin-block-start property" data-type="indexterm" id="idm45176108417680"/><a data-primary="padding-block-end property" data-type="indexterm" id="idm45176108417040"/><a data-primary="padding-block-start property" data-type="indexterm" id="idm45176108416400"/><a data-primary="height property" data-secondary="block-axis properties" data-type="indexterm" id="idm45176108415760"/>total, block-axis formatting is affected by&#13;
seven related properties: <code>margin-block-start</code>, <code>border-block-start</code>, <code>padding-block-start</code>,&#13;
<code>height</code>, <code>padding-block-end</code>, <code>border-block-end</code>, and <code>margin-block-end</code>. These&#13;
properties are diagrammed in <a data-type="xref" href="#bvf_fig20">Figure 6-14</a>.  These properties are all covered in detail in <a data-type="xref" href="ch07.html#padding-borders-outlines-and-margins">Chapter 7</a>; here, we will talk about the general principles and behavior of these properties before looking at the details of their values.</p>&#13;
&#13;
<p>The block-start and -end&#13;
padding and borders must be set to specific values, or else they default&#13;
to a width of 0, assuming no border style is declared. If&#13;
<code>border-style</code> has been set, the thickness of the borders is set to&#13;
<code>medium</code>, which is 3 pixels wide in all known browsers.&#13;
<a data-type="xref" href="#bvf_fig20">Figure 6-14</a> depicts the block-axis formatting properties in two writing modes and indicates which parts of the box may have a value of <code>auto</code> and&#13;
which may not.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig20">&#13;
<img alt="css5 0614" src="assets/css5_0614.png"/>&#13;
<h6><span class="label">Figure 6-14. </span>The seven properties of block-axis formatting, and which can be set to <code>auto</code></h6>&#13;
</div></figure>&#13;
&#13;
<p class="less_space pagebreak-before">Interestingly, if either <code>margin-block-start</code> or <code>margin-block-end</code> is set to&#13;
<code>auto</code> for a block box in the normal flow, but not both, they both evaluate&#13;
to <code>0</code>. A value of <code>0</code>, unfortunately, prevents easy block-direction centering of&#13;
normal-flow boxes in their containing blocks (though such centering is fairly straightforward in flexbox or grid layout).</p>&#13;
&#13;
<p>The <code>block-size</code> property<a data-primary="block-size property" data-type="indexterm" id="idm45176108400992"/> must be set to <code>auto</code> or to a nonnegative value of some type;&#13;
it can never be less than 0.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Auto Block Sizing" data-type="sect2"><div class="sect2" id="auto-block-sizing">&#13;
<h2>Auto Block Sizing</h2>&#13;
&#13;
<p>In the <a data-primary="vertical formatting" data-secondary="auto block sizing" data-type="indexterm" id="ix_vert_format_auto_block"/><a data-primary="horizontal formatting" data-secondary="auto settings for" data-type="indexterm" id="idm45176108396320"/><a data-primary="blocks" data-secondary="auto sizing" data-type="indexterm" id="idm45176108395344"/><a data-primary="auto block sizing" data-type="indexterm" id="idm45176108394400"/><a data-primary="block-axis properties" data-secondary="auto block sizing" data-type="indexterm" id="idm45176108393728"/>simplest case, a normal-flow block box with <code>block-size: auto</code> is&#13;
rendered just tall enough to enclose the line boxes of its inline&#13;
content (including text). If an auto-block-size, normal-flow block box has&#13;
only block-level children and has no block-edge padding or borders, the distance from its first child’s border-start edge to its last child’s border-end edge will be the box’s block size. This is the case because the margins of the child elements can “stick out” of the element that contains them thanks to what’s known as <em>margin collapsing</em>, which we’ll talk about in <a data-type="xref" href="#collapsing-block-axis-margins">“Collapsing Block-Axis Margins”</a>.</p>&#13;
&#13;
<p>However, if a block-level element has either block-start or -end padding, or&#13;
block-start and -end borders, its block size will be the distance from the block-start margin edge of its first child to the block-end&#13;
margin edge of its last child:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"block-size: auto; background: silver;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"margin-block-start: 2em; margin-block-end: 2em;"</code><code class="nt">&gt;</code>A<code class="w"> </code>paragraph!<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"block-size: auto; border-block-start: 1px solid;</code>&#13;
<code class="s">     border-block-end: 1px solid; background: silver;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"margin-block-start: 2em; margin-block-end: 2em;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">         </code>Another<code class="w"> </code>paragraph!<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p><a data-type="xref" href="#bvf_fig23">Figure 6-15</a> demonstrates both of these behaviors.<a data-primary="" data-startref="ix_vis_format_border" data-type="indexterm" id="idm45176108315824"/></p>&#13;
&#13;
<p>If we changed the borders in the previous example to be padding instead, the effect on the block size of the <code>&lt;div&gt;</code> would be the same: it would still enclose the paragraph’s margins within it.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig23">&#13;
<img alt="css5 0615" src="assets/css5_0615.png"/>&#13;
<h6><span class="label">Figure 6-15. </span>Auto block sizes with block-level children</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Percentage Heights" data-type="sect2"><div class="sect2" id="percentage-heights">&#13;
<h2>Percentage Heights</h2>&#13;
&#13;
<p>You <a data-primary="block-axis properties" data-secondary="percentage heights" data-type="indexterm" id="idm45176108335792"/><a data-primary="blocks" data-secondary="percentage heights" data-type="indexterm" id="idm45176108334784"/><a data-primary="vertical formatting" data-secondary="percentage heights" data-type="indexterm" id="idm45176108333840"/>saw earlier how length-value block sizes are handled, so let’s spend a&#13;
moment on percentages. If the block size of a normal-flow block box is set&#13;
to a percentage value, that value is taken as a percentage of the&#13;
block size of the box’s containing block, assuming the container has an explicit, non-<code>auto</code> block size of its own. Given the following markup, the paragraph will be 3 em long along the block axis:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"block-size: 6em;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"block-size: 50%;"</code><code class="nt">&gt;</code>Half<code class="w"> </code>as<code class="w"> </code>tall<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>If the block size of the containing block is <em>not</em>&#13;
explicitly declared, percentage block sizes are reset to <code>auto</code>. If we&#13;
change the previous example so that the <code>block-size</code> of the <code>&lt;div&gt;</code> is&#13;
<code>auto</code>, the paragraph will now have its block size determined automatically:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"block-size: auto;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"block-size: 50%;"</code><code class="nt">&gt;</code>NOT<code class="w"> </code>half<code class="w"> </code>as<code class="w"> </code>tall;<code class="w"> </code>block<code class="w"> </code>size<code class="w"> </code>reset<code class="w"> </code>to<code class="w"> </code>auto<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p><a data-type="xref" href="#bvf_fig22">Figure 6-16</a> illustrates these two possibilities. (The spaces between&#13;
the paragraph borders and the <code>&lt;div&gt;</code> borders are the block-start and -end&#13;
margins on the paragraphs.)</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig22">&#13;
<img alt="css5 0616" src="assets/css5_0616.png"/>&#13;
<h6><span class="label">Figure 6-16. </span>Percentage block sizes in different circumstances</h6>&#13;
</div></figure>&#13;
&#13;
<p>Before we move on, take a closer look at the first example in <a data-type="xref" href="#bvf_fig22">Figure 6-16</a>,&#13;
the half-as-tall paragraph. It may be half as tall, but it isn’t centered along the block axis. That’s because the containing <code>&lt;div&gt;</code> is 6 em tall,&#13;
which means the half-as-tall paragraph is 3 em tall. It has block-start and&#13;
-end margins of 1 em thanks to the browser’s default styles, so its overall block size is 5 em. That means&#13;
there is actually 2 em of space between the block end of the paragraph’s&#13;
visible box and the <code>&lt;div&gt;</code>’s block-end border, not 1 em.<a data-primary="" data-startref="ix_vert_format_auto_block" data-type="indexterm" id="idm45176108227728"/> <a data-type="xref" href="#block-axis-sizing-placement-in-detail">Figure 6-17</a> illustrates this in detail.</p>&#13;
&#13;
<figure><div class="figure" id="block-axis-sizing-placement-in-detail">&#13;
<img alt="css5 0617" src="assets/css5_0617.png"/>&#13;
<h6><span class="label">Figure 6-17. </span>Block-axis sizing and placement in detail</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Handling Content Overflow" data-type="sect2"><div class="sect2" id="overflow">&#13;
<h2>Handling Content Overflow</h2>&#13;
&#13;
<p>Given <a data-primary="overflow property" data-type="indexterm" id="ix_overflow_prop"/><a data-primary="blocks" data-secondary="content overflow" data-type="indexterm" id="ix_blocks_cont_over"/><a data-primary="content area" data-secondary="overflow of" data-type="indexterm" id="ix_cont_overflow"/><a data-primary="block-axis properties" data-secondary="content overflow" data-type="indexterm" id="ix_block_axis_cont_over"/>that it’s possible to set elements to specific sizes, it becomes possible to make an element too small for its content to fit inside. This is more likely to arise if block sizes are explicitly defined, but it can also happen with inline sizes, as you’ll see in later sections.  If this sort of thing does happen, you can exert&#13;
some control over the situation with the <code>overflow</code> shorthand property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176108203456">&#13;
<h1>overflow</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>visible</code> | <code>hidden</code> | <code>clip</code> | <code>scroll</code> | <code>auto</code> ]{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>visible</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Block-level and replaced elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <a data-primary="vertical formatting" data-secondary="overflowing content, handling" data-type="indexterm" id="ix_vert_format_overflow"/>default value of <code>visible</code> means that the element’s content may be&#13;
visible outside the element’s box. Typically, this leads to the content&#13;
running outside its own element box, but not altering the shape of&#13;
that box. The following markup would result in <a data-type="xref" href="#overflow_methods">Figure 6-18</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nf">#sidebar</code> <code class="p">{</code><code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">7em</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="m">#BBB</code><code class="p">;</code> <code class="k">overflow</code><code class="o">:</code> <code class="nb">visible</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If <code>overflow</code> is set to <code>hidden</code>, the element’s content is clipped at&#13;
the edges of the element box. With the <code>hidden</code> value, there is no way to get at the parts of the content that are clipped off.<a data-primary="hidden keyword" data-type="indexterm" id="idm45176108164384"/></p>&#13;
&#13;
<p>If <code>overflow</code> is set to <code>clip</code>, the element’s content is also clipped—that&#13;
is, hidden—at the edges of the element box, with no way to get at the parts that are clipped off.<a data-primary="boxes" data-secondary="clipping based on" data-type="indexterm" id="idm45176108161408"/><a data-primary="clipping" data-secondary="based on boxes" data-type="indexterm" id="idm45176108160432"/></p>&#13;
&#13;
<p>If <code>overflow</code> is set to <code>scroll</code>, the overflowing content is clipped, but the content can be made available to the user via scrolling methods, including a scrollbar (or set of them). <a data-type="xref" href="#overflow_methods">Figure 6-18</a> depicts one possibility.</p>&#13;
&#13;
<p>If <code>scroll</code> is used, the panning mechanisms (e.g., scrollbars) should&#13;
always be rendered. To quote the specification, “this avoids any problem&#13;
with scrollbars appearing or disappearing in a dynamic environment.”&#13;
Thus, even if the element has sufficient space to display all its&#13;
content, the scrollbars may still appear and take up space (though they may not).<a data-primary="scrolling" data-secondary="block box overflow" data-type="indexterm" id="idm45176108156384"/></p>&#13;
&#13;
<p>In addition, when printing&#13;
a page or otherwise displaying the document in a print medium, the&#13;
content may be displayed as though the value of <code>overflow</code> were declared&#13;
to be <code>visible</code>.<a data-primary="visible keyword" data-type="indexterm" id="idm45176108154000"/></p>&#13;
&#13;
<p><a data-type="xref" href="#overflow_methods">Figure 6-18</a> illustrates these <code>overflow</code> values, with two of them combined in a &#13;
<span class="keep-together">single example.</span></p>&#13;
&#13;
<figure><div class="figure" id="overflow_methods">&#13;
<img alt="css5 0618" src="assets/css5_0618.png"/>&#13;
<h6><span class="label">Figure 6-18. </span>Methods for handling overflowing content</h6>&#13;
</div></figure>&#13;
&#13;
<p>Finally, <code>overflow: auto</code> allows user agents to determine&#13;
which of the previously described behaviors to use, although user agents are encouraged to provide a&#13;
scrolling mechanism whenever necessary. This is a potentially useful way to&#13;
use overflow, since user agents could interpret it to mean “provide&#13;
scrollbars only when needed.” (They may not, but generally do.)</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Single-axis overflow" data-type="sect3"><div class="sect3" id="single_axis_overflow">&#13;
<h3>Single-axis overflow</h3>&#13;
&#13;
<p>Two <a data-primary="single-axis overflow" data-type="indexterm" id="ix_single_axis_over"/><a data-primary="visual formatting" data-secondary="horizontal formatting" data-type="indexterm" id="idm45176108145008"/><a data-primary="overflow-x property" data-type="indexterm" id="idm45176108144064"/><a data-primary="overflow-y property" data-type="indexterm" id="idm45176108143392"/>properties make up the <code>overflow</code> shorthand.  You can define the overflow behavior along the <em>x</em> (horizontal) and <em>y</em> (vertical) directions separately, either by setting them both in <code>overflow</code>, or by using the <code>overflow-x</code> and <code>overflow-y</code> properties.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176108120608">&#13;
<h1>overflow-x, overflow-y</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>visible</code> | <code>hidden</code> | <code>clip</code> | <code>scroll</code> | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>visible</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Block-level and replaced elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>By <a data-primary="scrolling" data-secondary="block box overflow" data-type="indexterm" id="idm45176108105744"/>setting the overflow behavior separately along each axis, you’re essentially deciding where scrollbars will appear and where they won’t.  Consider the following, which is &#13;
<span class="keep-together">rendered</span> in <a data-type="xref" href="#overflow_x_y">Figure 6-19</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nc">.one</code>   <code class="p">{</code><code class="k">overflow-x</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;</code> <code class="k">overflow-y</code><code class="o">:</code> <code class="nb">hidden</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.two</code>   <code class="p">{</code><code class="k">overflow-x</code><code class="o">:</code> <code class="nb">hidden</code><code class="p">;</code> <code class="k">overflow-y</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.three</code> <code class="p">{</code><code class="k">overflow-x</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;</code> <code class="k">overflow-y</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="overflow_x_y">&#13;
<img alt="css5 0619" src="assets/css5_0619.png"/>&#13;
<h6><span class="label">Figure 6-19. </span>Setting overflow separately for x- and y-axes</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the <a data-primary="horizontal formatting" data-secondary="negative margins" data-type="indexterm" id="idm45176108068496"/>first case, an empty scrollbar is set up for the x-axis (horizontal), but none for the y-axis (vertical), even though the content overflowed along the y-axis.  This is the worst of both worlds: a scrollbar that’s empty because it isn’t needed, and no scrollbar where it is needed.</p>&#13;
&#13;
<p>The second case is the much more useful inverse: no scrollbar is set along the x-axis, but one is available for the y-axis, so the overflowed content can be accessed by means of scrolling.</p>&#13;
&#13;
<p>In the third case, <code>scroll</code> is set for both axes, so access to the overflowing content is available via scrolling, but we also have an unnecessary scrollbar (which is empty) for the x-axis.  This is equivalent to simply declaring <code>overflow: scroll</code>.</p>&#13;
&#13;
<p>This brings us to the true nature of <code>overflow</code>: it’s a shorthand property that brings <code>overflow-x</code> and <code>overflow-y</code> together under one roof.  The following is exactly equivalent to the previous example and will have the same result shown in <a data-type="xref" href="#overflow_x_y">Figure 6-19</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nc">.one</code>   <code class="p">{</code><code class="k">overflow</code><code class="o">:</code> <code class="nb">scroll</code> <code class="nb">hidden</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.two</code>   <code class="p">{</code><code class="k">overflow</code><code class="o">:</code> <code class="nb">hidden</code> <code class="nb">scroll</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.three</code> <code class="p">{</code><code class="k">overflow</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;}</code> <code class="c">/* 'scroll scroll' would also work */</code></pre>&#13;
&#13;
<p>As you see, you can give <code>overflow</code> two keywords, which are always in the order <em>x</em>, then <em>y</em>.  If only one value is given, it’s used for both the x- and y-axes.  This is why <code>scroll</code> and <code>scroll scroll</code> are the same thing as values of <code>overflow</code>.  Similarly, <code>hidden</code> would be the same as saying <code>hidden hidden</code>.<a data-primary="" data-startref="ix_block_axis_cont_over" data-type="indexterm" id="idm45176108003328"/><a data-primary="" data-startref="ix_blocks_cont_over" data-type="indexterm" id="idm45176108002432"/><a data-primary="" data-startref="ix_cont_overflow" data-type="indexterm" id="idm45176108001488"/><a data-primary="" data-startref="ix_overflow_prop" data-type="indexterm" id="idm45176108000544"/><a data-primary="" data-startref="ix_vert_format_overflow" data-type="indexterm" id="idm45176107999600"/><a data-primary="" data-startref="ix_single_axis_over" data-type="indexterm" id="idm45176107998656"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Negative Margins and Collapsing" data-type="sect2"><div class="sect2" id="negative-margins-and-collapsing">&#13;
<h2>Negative Margins and Collapsing</h2>&#13;
&#13;
<p>Believe it or not, <a data-primary="margins" data-secondary="collapsing" data-type="indexterm" id="ix_margin_collapse"/><a data-primary="collapsing margins" data-type="indexterm" id="ix_collapse_margin"/><a data-primary="vertical formatting" data-secondary="negative margins" data-type="indexterm" id="idm45176107994160"/><a data-primary="margins" data-secondary="negative" data-type="indexterm" id="idm45176107993216"/><a data-primary="negative margins" data-type="indexterm" id="idm45176107992272"/><a data-primary="block-axis properties" data-secondary="negative margins and collapsing" data-type="indexterm" id="idm45176107991600"/>negative margins are possible.  The base effect is to move the margin edge inward toward the center of the element’s box.  Consider this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.neg</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">-50px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"width: 420px; background-color: silver; padding: 10px;</code>&#13;
<code class="s">            margin-block-start: 50px; border: 1px solid;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"neg"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">        </code>A<code class="w"> </code>paragraph.<code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>A<code class="w"> </code>div.<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>As we see in <a data-type="xref" href="#bvf_fig28">Figure 6-20</a>, the paragraph has been pulled upward by&#13;
its negative block-start margin. Note that the content of the <code>&lt;div&gt;</code> that follows the paragraph in the markup has also been pulled up the block axis by 50 pixels.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig28">&#13;
<img alt="css5 0620" src="assets/css5_0620.png"/>&#13;
<h6><span class="label">Figure 6-20. </span>The effects of a negative block-start margin</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now compare the following markup to the situation shown in <a data-type="xref" href="#bvf_fig29">Figure 6-21</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.neg</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">-50px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"width: 420px; margin-block-start: 50px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"neg"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">        </code>A<code class="w"> </code>paragraph.<code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>The<code class="w"> </code>next<code class="w"> </code>paragraph.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="bvf_fig29">&#13;
<img alt="css5 0621" src="assets/css5_0621.png"/>&#13;
<h6><span class="label">Figure 6-21. </span>The effects of a negative block-end margin</h6>&#13;
</div></figure>&#13;
&#13;
<p>What’s happening?  The elements following the&#13;
<code>&lt;div&gt;</code> are placed according to the location of the block-end margin edge of the <code>&lt;div&gt;</code>, which is 50 pixels higher than it would be without the negative margin.&#13;
As <a data-type="xref" href="#bvf_fig29">Figure 6-21</a> shows, the block-end of the <code>&lt;div&gt;</code> is actually <em>above</em> the visual block-end&#13;
of its child paragraph. The next element after the <code>&lt;div&gt;</code> is the&#13;
appropriate distance from the block-end of the <code>&lt;div&gt;</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Collapsing Block-Axis Margins" data-type="sect2"><div class="sect2" id="collapsing-block-axis-margins">&#13;
<h2>Collapsing Block-Axis Margins</h2>&#13;
&#13;
<p>An <a data-primary="vertical formatting" data-secondary="collapsing margins" data-type="indexterm" id="ix_vert_format_margin"/><a data-primary="block-axis properties" data-secondary="collapsing block-axis margins" data-type="indexterm" id="ix_block_axis_margin"/>important aspect of block-axis formatting is the <em>collapsing</em> of adjacent margins, which is a way of comparing adjacent margins in the block direction, and then using only the largest of those margins to set the distance between the adjacent block elements.&#13;
Note that <a data-primary="padding" data-type="indexterm" id="idm45176107745088"/><a data-primary="visual formatting" data-secondary="borders" data-type="indexterm" id="idm45176107744480"/>collapsing behavior applies only to margins. Padding and borders never collapse.</p>&#13;
&#13;
<p>An unordered list, with list items that follow one another along the block axis, is a perfect&#13;
environment for studying margin collapsing. Assume that the following is declared for&#13;
a list that contains three items:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">li</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">15px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Each list item has a 10-pixel block-start margin and a 15-pixel block-end margin.&#13;
When the list is rendered, however, the visible distance between adjacent list&#13;
items is 15 pixels, not 25. This happens because, along the block&#13;
axis, adjacent margins are collapsed. In other words, the smaller of the&#13;
two margins is eliminated in favor of the larger. <a data-type="xref" href="#bvf_fig24">Figure 6-22</a> shows the&#13;
difference between collapsed and uncollapsed margins.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig24">&#13;
<img alt="css5 0622" src="assets/css5_0622.png"/>&#13;
<h6><span class="label">Figure 6-22. </span>Collapsed versus uncollapsed margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>User agents will collapse block-adjacent margins&#13;
as shown in the first list in <a data-type="xref" href="#bvf_fig24">Figure 6-22</a>, so that 15-pixel spaces&#13;
appear between each list item. The second list shows what happens if browsers&#13;
don’t collapse margins, resulting in 25-pixel spaces between&#13;
list items.</p>&#13;
&#13;
<p>Another word to use, if you don’t like “collapse,” is “overlap.”&#13;
Although the margins are not really overlapping, you can visualize&#13;
what’s happening by using the following analogy.</p>&#13;
&#13;
<p>Imagine that each element, such as a paragraph, is a small piece of&#13;
paper with the content of the element written on it. Around each piece&#13;
of paper is a certain amount of clear plastic, which represents the margins.&#13;
The first piece of paper (say an <code>&lt;h1&gt;</code> piece) is laid down on the canvas.&#13;
The second (a paragraph) is laid below it along the block axis and then slid upward along that axis until the&#13;
edge of one piece’s plastic touches the edge of the other’s&#13;
paper. If the first piece of paper has half an inch of plastic along its&#13;
block-end edge, and the second has a third of an inch along its block-start, then&#13;
when they slide together, the first piece’s block-end plastic will touch the block-start&#13;
edge of the second piece of paper. The two are now done being placed on&#13;
the canvas, and the plastic attached to the pieces is overlapping.</p>&#13;
&#13;
<p>Collapsing also occurs where multiple margins meet, such as at the end&#13;
of a list. Adding to the earlier example, let’s assume the following&#13;
rules apply:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ul</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">15px</code><code class="p">;}</code>&#13;
<code class="nt">li</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">28px</code><code class="p">;}</code></pre>&#13;
&#13;
<p class="less_space pagebreak-before">The last item in the list has a block-end margin of 20 pixels, the block-end&#13;
margin of the <code>&lt;ul&gt;</code> is 15 pixels, and the block-start margin of a succeeding <code>&lt;h1&gt;</code>&#13;
is 28 pixels. So once the margins have been collapsed, the distance&#13;
between the end of the last <code>&lt;li&gt;</code> in the list and the beginning of the <code>&lt;h1&gt;</code> is 28 pixels,&#13;
as shown in <a data-type="xref" href="#bvf_fig25">Figure 6-23</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig25">&#13;
<img alt="css5 0623" src="assets/css5_0623.png"/>&#13;
<h6><span class="label">Figure 6-23. </span>Collapsing in detail</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you add a <a data-primary="padding" data-type="indexterm" id="idm45176107621248"/>&#13;
<a data-primary="visual formatting" data-secondary="borders" data-type="indexterm" id="idm45176107620512"/><a data-primary="borders" data-secondary="containing block" data-type="indexterm" id="idm45176107619664"/><a data-primary="containing blocks" data-secondary="collapsing margins" data-type="indexterm" id="idm45176107618816"/>border or padding to a containing block, this causes&#13;
the margins of its child elements to be entirely contained within it. We can see&#13;
this behavior in operation by adding a border to the <code>&lt;ul&gt;</code> element in the&#13;
previous example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ul</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">15px</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;}</code>&#13;
<code class="nt">li</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">28px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>With this change, the block-end margin of the <code>&lt;li&gt;</code> element is now placed&#13;
inside its parent element (the <code>&lt;ul&gt;</code>). Therefore, the only margin&#13;
collapsing that takes place is between the <code>&lt;ul&gt;</code> and the <code>&lt;h1&gt;</code>, as&#13;
illustrated in <a data-type="xref" href="#bvf_fig26">Figure 6-24</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig26">&#13;
<img alt="css5 0624" src="assets/css5_0624.png"/>&#13;
<h6><span class="label">Figure 6-24. </span>Collapsing (or not) with borders added to the mix</h6>&#13;
</div></figure>&#13;
&#13;
<p>Negative <a data-primary="negative margins" data-type="indexterm" id="ix_neg_margin"/><a data-primary="margins" data-secondary="negative" data-type="indexterm" id="ix_margin_neg"/>margin collapsing is slightly different. When a negative margin participates in margin collapsing, the browser takes the&#13;
absolute value of the negative margin and subtracts it from any adjacent&#13;
positive margins. In other words, the negative length is added to the positive length(s),&#13;
and the resulting value is the distance between the elements, even if that distance is a negative length. <a data-type="xref" href="#bvf_fig27">Figure 6-25</a> provides some concrete examples.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig27">&#13;
<img alt="css5 0625" src="assets/css5_0625.png"/>&#13;
<h6><span class="label">Figure 6-25. </span>Examples of negative block-axis margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now let’s consider an example where the margins of a list item, an&#13;
unordered list, and a paragraph are all collapsed. In this case, the&#13;
unordered list and paragraph are assigned negative margins:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">li</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code>&#13;
<code class="nt">ul</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">-15px</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">-18px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The negative margin of the greatest magnitude (<code>-18px</code>) is added to the largest&#13;
positive margin (<code>20px</code>), yielding <code>20px</code> – <code>18px</code> = <code>2px</code>. Thus, we have only 2 pixels between the block-end of the list item’s content and&#13;
the block-start of the <code>&lt;h1&gt;</code>’s content, as we can see in <a data-type="xref" href="#bvf_fig30">Figure 6-26</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig30">&#13;
<img alt="css5 0626" src="assets/css5_0626.png"/>&#13;
<h6><span class="label">Figure 6-26. </span>Collapsing margins and negative margins, in detail</h6>&#13;
</div></figure>&#13;
&#13;
<p class="less_space pagebreak-before">When elements overlap each other because of negative margins, it’s hard to&#13;
tell which elements are on top of others. You may also have noticed that very few of&#13;
the examples in this section use background colors. If they did, the background color of a following&#13;
element might overwrite the content of a preceding element. This is expected behavior, since browsers usually render&#13;
elements in order from beginning to end, so a normal-flow element&#13;
that comes later in the document can generally be expected to overwrite an earlier&#13;
element, assuming the two end up overlapping.<a data-primary="" data-startref="ix_block_axis_props" data-type="indexterm" id="idm45176107473760"/><a data-primary="" data-startref="ix_blocks_blockaxis_props" data-type="indexterm" id="idm45176107469456"/><a data-primary="" data-startref="ix_box_blockaxis_props" data-type="indexterm" id="idm45176107468608"/><a data-primary="" data-startref="ix_collapse_margin" data-type="indexterm" id="idm45176107467760"/><a data-primary="" data-startref="ix_margin_collapse" data-type="indexterm" id="idm45176107466912"/><a data-primary="" data-startref="ix_block_axis_margin" data-type="indexterm" id="idm45176107466064"/><a data-primary="" data-startref="ix_vert_format_margin" data-type="indexterm" id="idm45176107465120"/><a data-primary="" data-startref="ix_margin_neg" data-type="indexterm" id="idm45176107464176"/><a data-primary="" data-startref="ix_neg_margin" data-type="indexterm" id="idm45176107463232"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inline-Axis Formatting" data-type="sect1"><div class="sect1" id="inline-axis-formatting">&#13;
<h1>Inline-Axis Formatting</h1>&#13;
&#13;
<p>Laying out <a data-primary="blocks" data-secondary="inline-axis" data-type="indexterm" id="ix_block_inlineaxis"/><a data-primary="horizontal formatting" data-secondary="inline-axis formatting" data-type="indexterm" id="ix_horiz_format_inlineaxis"/><a data-primary="inline-axis formatting" data-type="indexterm" id="ix_inline_axis_format"/><a data-primary="visual formatting" data-secondary="inline-axis formatting" data-type="indexterm" id="ix_vis_format_inline_axis"/>elements along the inline axis can be more complex than you’d think. Part of&#13;
the complexity has to do with the default behavior of <code>box-sizing</code>. With&#13;
the default value of <code>content-box</code>, the value given for <code>inline-size</code> affects&#13;
the inline width of the content area, <em>not</em> the entire visible element box.&#13;
Consider the following example, where the inline axis runs left to right:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"inline-size: 200px;"</code><code class="nt">&gt;</code>wideness?<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This <a data-primary="padding" data-secondary="additive versus subtractive" data-type="indexterm" id="ix_pad_addit_subtract"/><a data-primary="additive versus subtractive padding" data-type="indexterm" id="ix_addit_subtract_pad"/>makes the paragraph’s content area 200 pixels wide. If we give the&#13;
element a background, this will be quite obvious. However, any padding,&#13;
borders, or margins you specify are <em>added</em> to the width value. Suppose&#13;
we do this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"inline-size: 200px; padding: 10px; margin: 20px;"</code><code class="nt">&gt;</code>wideness?<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The visible element box is now 220 pixels in inline size, since we’ve added 10&#13;
pixels of padding to every side of the content. The margins will&#13;
now extend another 20 pixels to both inline sides for an overall element inline size of 260 pixels. This is illustrated in <a data-type="xref" href="#bvf_fig06">Figure 6-27</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig06">&#13;
<img alt="css5 0627" src="assets/css5_0627.png"/>&#13;
<h6><span class="label">Figure 6-27. </span>Additive padding and margin</h6>&#13;
</div></figure>&#13;
&#13;
<p>If we change the styles to use <code>box-sizing: border-box</code>,&#13;
the results will be different. In that case, the visible box will&#13;
be 200 pixels wide along the inline axis with a content inline size of 180 pixels, and a total of&#13;
40 pixels of margin on the inline sides, giving an overall box inline size of 240&#13;
pixels, as illustrated in <a data-type="xref" href="#bvf_fig07">Figure 6-28</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig07">&#13;
<img alt="css5 0628" src="assets/css5_0628.png"/>&#13;
<h6><span class="label">Figure 6-28. </span>Subtractive padding</h6>&#13;
</div></figure>&#13;
&#13;
<p>In either case, the CSS specification has a rule that says the sum of the&#13;
inline components of a block box in the normal flow always equals&#13;
the inline size of the containing block (which is why, as you’ll see in just a bit, <code>margin: auto</code> centers content in the inline direction).  Let’s consider two paragraphs within&#13;
a <code>&lt;div&gt;</code> whose margins have been set to <code>1em</code>, and whose <code>box-sizing</code>&#13;
value is the default <code>content-box</code>. The content size (the value of <code>inline-size</code>) of each&#13;
paragraph in this example, plus its inline-start and -end padding, borders, and margins, will always&#13;
add up to the inline size of the <code>&lt;div&gt;</code>’s content area.</p>&#13;
&#13;
<p>Let’s say the inline size of the <code>&lt;div&gt;</code> is <code>30em</code>. That makes the sum total of&#13;
the content size, padding, borders, and margins of each paragraph 30&#13;
em. In <a data-type="xref" href="#bvf_fig08">Figure 6-29</a>, the “blank” space around the paragraphs is actually&#13;
their margins.<a data-primary="" data-startref="ix_horiz_format_inlineaxis" data-type="indexterm" id="idm45176107383168"/><a data-primary="" data-startref="ix_addit_subtract_pad" data-type="indexterm" id="idm45176107382256"/><a data-primary="" data-startref="ix_pad_addit_subtract" data-type="indexterm" id="idm45176107381312"/> If the <code>&lt;div&gt;</code> had any padding, even more&#13;
blank space would be present, but that isn’t the case here.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig08">&#13;
<img alt="css5 0629" src="assets/css5_0629.png"/>&#13;
<h6><span class="label">Figure 6-29. </span>Element boxes are as wide as the inline width of their containing block</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inline-Axis Properties" data-type="sect2"><div class="sect2" id="inline-axis-properties">&#13;
<h2>Inline-Axis Properties</h2>&#13;
&#13;
<p>The <a data-primary="inline-axis formatting" data-secondary="properties" data-type="indexterm" id="idm45176107375664"/><a data-primary="vertical formatting" data-secondary="properties" data-type="indexterm" id="idm45176107374272"/><a data-primary="horizontal formatting" data-secondary="properties" data-type="indexterm" id="idm45176107373328"/><a data-primary="border-inline-end property" data-type="indexterm" id="idm45176107372384"/><a data-primary="border-inline-start property" data-type="indexterm" id="idm45176107371744"/><a data-primary="margin-inline-end property" data-type="indexterm" id="idm45176107371104"/><a data-primary="margin-inline-start property" data-type="indexterm" id="idm45176107370464"/><a data-primary="padding-inline-start property" data-type="indexterm" id="idm45176107369824"/><a data-primary="padding-inline-end property" data-type="indexterm" id="idm45176107369184"/><a data-primary="inline-size property" data-type="indexterm" id="ix_inline_size_prop"/>seven properties of inline formatting—<code>margin-inline-start</code>,&#13;
<code>border-inline-start</code>, <code>padding-inline-start</code>, <code>inline-size</code>, <code>padding-inline-end</code>, <code>padding-inline-end</code>,&#13;
and <code>padding-inline-end</code>—are diagrammed in <a data-type="xref" href="#bvf_fig09">Figure 6-30</a>.</p>&#13;
&#13;
<p>The values of these seven properties must add up to the inline size of the&#13;
element’s containing block, which is usually the value of <code>inline-size</code> for a&#13;
block element’s parent (since block-level elements nearly always have&#13;
block-level elements for parents).</p>&#13;
&#13;
<p>Of these seven properties, only three may be set to <code>auto</code>: the inline size of&#13;
the element’s content, and the inline-start and -end margins. The remaining&#13;
properties must either be set to specific values or default to a width&#13;
of 0. <a data-type="xref" href="#bvf_fig09">Figure 6-30</a> shows which parts of the box can take a value of <code>auto</code>&#13;
and which cannot. (That said, CSS is forgiving: if any part that can’t accept <code>auto</code> is erroneously set to <code>auto</code>, it will default to <code>0</code>.)</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig09">&#13;
<img alt="css5 0630" src="assets/css5_0630.png"/>&#13;
<h6><span class="label">Figure 6-30. </span>The seven properties of inline-axis formatting, and which can be set to <code>auto</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>inline-size</code> property must either be set to <code>auto</code> or a nonnegative value. When you do use <code>auto</code> in inline-axis formatting, different effects&#13;
can occur.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using auto" data-type="sect2"><div class="sect2" id="using-auto">&#13;
<h2>Using auto</h2>&#13;
&#13;
<p>In <a data-primary="inline-axis formatting" data-secondary="auto, using" data-type="indexterm" id="ix_inlineaxis_format_auto"/><a data-primary="horizontal formatting" data-secondary="auto settings for" data-type="indexterm" id="ix_horiz_format_auto"/>certain situations, it makes a lot of sense to explicitly set one or more of the inline margins and size to <code>auto</code>.  By default, the two inline margins are set to <code>0</code>, and the inline size is set to <code>auto</code>.  Let’s explore how moving the <code>auto</code> around can have different effects, and why.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Only one auto" data-type="sect3"><div class="sect3" id="only_one_auto">&#13;
<h3>Only one auto</h3>&#13;
&#13;
<p>If you set one of <code>inline-size</code>, <code>margin-inline-start</code>, or <code>margin-inline-end</code> to a value of&#13;
<code>auto</code>, and give the other two properties specific values, then the&#13;
property that is set to <code>auto</code> is set to the length required to make the&#13;
element box’s overall inline size equal to the parent element’s content inline size.</p>&#13;
&#13;
<p>Let’s say the sum of the seven inline-axis properties must equal 500 pixels, no&#13;
padding or borders are set, the inline-end margin and inline size are set to <code>100px</code>,&#13;
and the inline-start margin is set to <code>auto</code>. The inline-start margin will thus be 300&#13;
pixels wide:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">500px</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">100px</code><code class="p">;}</code> <code class="c">/* inline-start margin evaluates to 300px */</code></pre>&#13;
&#13;
<p>In a sense, <code>auto</code> can be used to make up the difference between&#13;
everything else and the required total. However, what if all three of&#13;
these properties (both inline margins and the inline size)&#13;
are set to <code>100px</code> and <em>none</em> of them are set to <code>auto</code>?</p>&#13;
&#13;
<p>If all <a data-primary="overconstraining" data-secondary="formatting properties" data-type="indexterm" id="idm45176107308064"/>three properties are set to something other than&#13;
<code>auto</code>—or, in CSS parlance, when these formatting properties have&#13;
been <em>overconstrained</em>—then the margin at the inline end is <em>always</em> forced to be&#13;
<code>auto</code>. This means that if both inline margins and the inline size are set to&#13;
<code>100px</code>, the user agent will reset the inline-end margin to&#13;
<code>auto</code>. The inline-end margin’s width will then be set according to the rule&#13;
that one <code>auto</code> value “fills in” the distance needed to make the&#13;
element’s overall inline size equal to that of its containing block’s content inline size. <a data-type="xref" href="#bvf_fig11">Figure 6-31</a>&#13;
shows the result of the following markup in left-to-right languages like English:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">500px</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">100px</code><code class="p">;}</code> <code class="c">/* inline-end margin forced to be 300px */</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig11">&#13;
<img alt="css5 0631" src="assets/css5_0631.png"/>&#13;
<h6><span class="label">Figure 6-31. </span>Overriding the inline-end margin’s value</h6>&#13;
</div></figure>&#13;
&#13;
<p>If both side margins are set explicitly, and <code>inline-size</code> is set to <code>auto</code>, then&#13;
<code>inline-size</code> will be whatever value is needed to reach&#13;
the required total (which is the content inline size of the parent element).&#13;
The <a data-primary="margin-inline-end property" data-type="indexterm" id="idm45176107236480"/><a data-primary="margin-inline-start property" data-type="indexterm" id="idm45176107235808"/>results of the following markup are shown in <a data-type="xref" href="#bvf_fig12">Figure 6-32</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
     <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This type of formatting is the most common, since it is&#13;
equivalent to setting the margins and not declaring anything for the&#13;
<code>inline-size</code>. The result of the following markup is exactly the same as that&#13;
shown in <a data-type="xref" href="#bvf_fig12">Figure 6-32</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">100px</code><code class="p">;}</code> <code class="c">/* same as before */</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig12">&#13;
<img alt="css5 0632" src="assets/css5_0632.png"/>&#13;
<h6><span class="label">Figure 6-32. </span>Automatic inline sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p>You <a data-primary="box-sizing property" data-type="indexterm" id="idm45176107126176"/>might be wondering what happens if <code>box-sizing</code> is set to&#13;
<code>padding-box</code>. In that case, all the same principles described here apply,&#13;
which is why this section discussed only <code>inline-size</code> and the inline-side margins&#13;
without introducing any padding or borders.</p>&#13;
&#13;
<p>In other words, the handling of&#13;
<code>inline-size: auto</code> in this section and the following sections is the same&#13;
regardless of the value of <code>box-sizing</code>. The details of what gets placed&#13;
where inside the <code>box-sizing</code>-defined box may vary, but the treatment of&#13;
<code>auto</code> values does not, because <code>box-sizing</code> determines what <code>inline-size</code>&#13;
refers to, not how it behaves in relation to the margins.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More than one auto" data-type="sect3"><div class="sect3" id="more-than-one-auto">&#13;
<h3>More than one auto</h3>&#13;
&#13;
<p>Now let’s see what happens when two of the three properties (<code>inline-size</code>,&#13;
<code>margin-inline-start</code>, and <code>margin-inline-end</code>) are set to <code>auto</code>. If both margins&#13;
are set to <code>auto</code> but the <code>inline-size</code> is set to a specific length, then both margins are set to&#13;
equal lengths, thus centering the element within its parent along the inline axis. The following code creates this layout,&#13;
illustrated in <a data-type="xref" href="#bvf_fig13">Figure 6-33</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">500px</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">300px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
  <code class="c">/* each margin is 100 pixels, because (500-300)/2 = 100 */</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig13">&#13;
<img alt="css5 0633" src="assets/css5_0633.png"/>&#13;
<h6><span class="label">Figure 6-33. </span>Setting an explicit inline size</h6>&#13;
</div></figure>&#13;
&#13;
<p>Another way of sizing elements along the inline axis is to set one of the inline margins and <code>inline-size</code> to <code>auto</code>. In this case, the margin set to <code>auto</code> is reduced to 0:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">500px</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code> <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
  <code class="c">/* inline-start margin evaluates to 0; inline-size becomes 400px  */</code></pre>&#13;
&#13;
<p>The <code>inline-size</code> property is then set to the value necessary to make the element fill&#13;
its containing block; in the preceding example, it would be 400 pixels, as&#13;
shown in <a data-type="xref" href="#bvf_fig14">Figure 6-34</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig14">&#13;
<img alt="css5 0634" src="assets/css5_0634.png"/>&#13;
<h6><span class="label">Figure 6-34. </span>What happens when both <code>inline-size</code> and the inline-start margin &#13;
<span class="keep-together">are <code>auto</code></span></h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Too many autos" data-type="sect3"><div class="sect3" id="too-many-autos">&#13;
<h3>Too many autos</h3>&#13;
&#13;
<p>Finally, what happens when all three properties are set to <code>auto</code>? The&#13;
answer: both margins are set to 0, and the <code>inline-size</code> is made&#13;
as wide as possible. This result is the same as the default situation,&#13;
when no values are explicitly declared for margins or the inline size. In such&#13;
a case, the margins default to 0 and <code>inline-size</code> defaults to <code>auto</code>.</p>&#13;
&#13;
<p>Note that since inline margins do not collapse (unlike block margins, as discussed earlier), the padding,&#13;
borders, and margins of a parent element can affect the inline layout of its children. The&#13;
effect is indirect in that the margins (and so on) of an element can&#13;
induce an offset for child elements.<a data-primary="" data-startref="ix_inline_size_prop" data-type="indexterm" id="idm45176106988848"/><a data-primary="" data-startref="ix_horiz_format_auto" data-type="indexterm" id="idm45176106987872"/><a data-primary="" data-startref="ix_inlineaxis_format_auto" data-type="indexterm" id="idm45176106986928"/> The results of the following markup&#13;
are shown in <a data-type="xref" href="#bvf_fig15">Figure 6-35</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">30px</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig15">&#13;
<img alt="css5 0635" src="assets/css5_0635.png"/>&#13;
<h6><span class="label">Figure 6-35. </span>Offset is implicit in the parent’s margins and padding</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Negative Margins" data-type="sect2"><div class="sect2" id="bvf_negative-margins">&#13;
<h2>Negative Margins</h2>&#13;
&#13;
<p>As you’ve <a data-primary="negative margins" data-type="indexterm" id="ix_neg_margin2"/><a data-primary="inline-axis formatting" data-secondary="negative margins" data-type="indexterm" id="ix_inlineaxis_format_neg_margin"/><a data-primary="margins" data-secondary="negative" data-type="indexterm" id="ix_margin_neg2"/><a data-primary="horizontal formatting" data-secondary="negative margins" data-type="indexterm" id="ix_horiz_format_neg_margin"/>seen with block-axis margins, it’s possible to set&#13;
negative values for inline-axis margins. Setting negative inline margins can result in some&#13;
interesting effects.</p>&#13;
&#13;
<p>Remember that the total of the seven inline-axis properties always equals&#13;
the inline size of the content area of the parent element. As long as all inline properties are 0 or&#13;
greater, an element’s inline size can never be greater than its parent’s content area inline size.&#13;
However, consider the following markup, depicted in <a data-type="xref" href="#bvf_fig16">Figure 6-36</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">500px</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.wide</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">-50px</code><code class="p">;</code>&#13;
    <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig16">&#13;
<img alt="css5 0636" src="assets/css5_0636.png"/>&#13;
<h6><span class="label">Figure 6-36. </span>Wider children through negative margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>Yes indeed, the child element is wider than its parent along the inline axis! This is&#13;
mathematically correct.  Let’s solve for inline size:</p>&#13;
<ul class="simplelist">&#13;
<li>10 px + 0 + 0 + 540 px + 0 + 0 – 50 px = 500 px</li>&#13;
</ul>&#13;
&#13;
<p>The <code>540px</code> is the evaluation of <code>inline-size: auto</code>, which is the number&#13;
needed to balance out the rest of the values in the equation. Even&#13;
though it leads to a child element sticking out of its parent, it all works because the values of the seven&#13;
properties add up to the required total.</p>&#13;
&#13;
<p class="pagebreak-before">Now, let’s add some borders to the mix:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">500px</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.wide</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">-50px</code><code class="p">;</code>&#13;
    <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The resulting change will be a reduction in the evaluated width of&#13;
<code>inline-size</code>:</p>&#13;
<ul class="simplelist">&#13;
<li>10 px + 3 px + 0 + 534 px + 0 + 3 px – 50 px = 500 px</li>&#13;
</ul>&#13;
&#13;
<p>Or, we can rearrange the equation to solve for the content size instead of for the width of the parent:</p>&#13;
<ul class="simplelist">&#13;
<li>500 px – 10 px – 3 px – 3 px + 50 px = 534 px</li>&#13;
</ul>&#13;
&#13;
<p>If we were to introduce padding, the value of <code>inline-size</code> would drop&#13;
even more (assuming <code>box-sizing: content-box</code>).</p>&#13;
&#13;
<p>Conversely, it’s possible to have <code>auto</code> inline-end margins evaluate to&#13;
negative amounts. If the values of other properties force the inline-end&#13;
margin to be negative in order to satisfy the requirement that elements&#13;
be no wider than their containing block, that’s what will happen.&#13;
Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">500px</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.wide</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
    <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">600px</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The equation works out like this:</p>&#13;
<ul class="simplelist">&#13;
<li>500 px – 10 px – 600 px – 3 px – 3 px = –116 px</li>&#13;
</ul>&#13;
&#13;
<p>In this case, the inline-end margin evaluates to <code>-116px</code>. No matter what explicit value it’s given in the CSS, this margin will still be forced to <code>-116px</code> because&#13;
of the rule stating that when an element’s dimensions are&#13;
overconstrained, the inline-end margin is reset to whatever is needed to make&#13;
the numbers work out correctly.</p>&#13;
&#13;
<p>Let’s consider another example, illustrated in <a data-type="xref" href="#bvf_fig17">Figure 6-37</a>, in which the inline-start&#13;
margin is set to be negative:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">500px</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.wide</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">-50px</code><code class="p">;</code> <code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code>&#13;
    <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig17">&#13;
<img alt="css5 0637" src="assets/css5_0637.png"/>&#13;
<h6><span class="label">Figure 6-37. </span>Setting a negative inline-start margin</h6>&#13;
</div></figure>&#13;
&#13;
<p>With a negative inline-start margin, the paragraph not only spills beyond&#13;
the borders of the <code>&lt;div&gt;</code>, but also spills beyond the edge of the&#13;
browser window itself!</p>&#13;
&#13;
<p>Remember: padding, borders, and content widths (and heights) can&#13;
never be negative. Only margins can be less than 0.<a data-primary="" data-startref="ix_horiz_format_neg_margin" data-type="indexterm" id="idm45176106627392"/><a data-primary="" data-startref="ix_inlineaxis_format_neg_margin" data-type="indexterm" id="idm45176106626448"/><a data-primary="" data-startref="ix_margin_neg2" data-type="indexterm" id="idm45176106625536"/><a data-primary="" data-startref="ix_neg_margin2" data-type="indexterm" id="idm45176106624592"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Percentages" data-type="sect2"><div class="sect2" id="bvf_percentages">&#13;
<h2>Percentages</h2>&#13;
&#13;
<p>When it <a data-primary="horizontal formatting" data-secondary="percentages" data-type="indexterm" id="idm45176106575728"/><a data-primary="inline-axis formatting" data-secondary="percentages" data-type="indexterm" id="idm45176106574880"/>comes to percentage values for the inline size, padding, and margins,&#13;
the same basic rules we discussed in previous sections apply. It doesn’t really matter whether the values&#13;
are declared with lengths or percentages.</p>&#13;
&#13;
<p>Percentages can be very useful. Suppose we want an element’s content to&#13;
be two-thirds the inline size of its containing block, the padding sides to&#13;
be 5% each, the inline-start margin to be 5%, and the inline-end margin to&#13;
take up the slack. That would be written something like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"inline-size: 67%;</code>&#13;
<code class="s">     padding-inline-end: 5%; padding-inline-start: 5%;</code>&#13;
<code class="s">     margin-inline-end: auto; margin-inline-start: 5%;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">     </code>playing<code class="w"> </code>percentages<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The inline-end <a data-primary="margin-inline-end property" data-type="indexterm" id="idm45176106567120"/>margin would evaluate to 18% (100% – 67% – 5% – 5% – 5%) of&#13;
the width of the containing block.</p>&#13;
&#13;
<p>Mixing percentages and length units can be tricky, however. Consider the&#13;
following example:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"inline-size: 67%; padding-inline-end: 2em; padding-inline-start: 2em;</code>&#13;
<code class="s">     margin-inline-end: auto; margin-inline-start: 5em;"</code><code class="nt">&gt;</code>mixed<code class="w"> </code>lengths<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In this case, the element’s box can be defined like this:</p>&#13;
<ul class="simplelist">&#13;
  <li>5 em + 0 + 2 em + 67% + 2 em + 0 + auto = containing block width</li>&#13;
</ul>&#13;
&#13;
<p>In order for the inline-end margin’s inline size to evaluate to 0, the element’s&#13;
containing block must be 27.272727 em wide (with the content area of the&#13;
element being 18.272727 em wide) along the inline axis. Any wider than that, and the inline-end&#13;
margin will evaluate to a positive value. Any narrower, and the inline-end&#13;
margin will be a negative value.</p>&#13;
&#13;
<p>The situation gets even more complicated if we start mixing length-value&#13;
unity types, like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"inline-size: 67%;</code>&#13;
<code class="s">     padding-inline-end: 15px; padding-inline-start: 10px;</code>&#13;
<code class="s">     margin-inline-end: auto; margin-inline-start: 5em;"</code><code class="nt">&gt;</code>more<code class="w"> </code>mixed<code class="w"> </code>lengths<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>And, just to make things more complex, <a data-primary="borders" data-secondary="lack of percentage values for" data-type="indexterm" id="idm45176106515456"/>borders cannot accept percentage&#13;
values, only length values. The bottom line is that it isn’t really&#13;
possible to create a fully flexible element based solely on percentages&#13;
unless you’re willing to avoid using borders or use approaches such as flexible box layout. That said, if you do need to mix percentages and length units, using the <code>calc()</code> and <code>minmax()</code> value functions can be a life changer, or at least a layout changer.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Replaced Elements" data-type="sect2"><div class="sect2" id="replaced-elements">&#13;
<h2>Replaced Elements</h2>&#13;
&#13;
<p>So far, we’ve <a data-primary="inline-axis formatting" data-secondary="replaced elements" data-type="indexterm" id="idm45176106479872"/><a data-primary="replaced elements" data-secondary="inline-axis formatting" data-type="indexterm" id="idm45176106478864"/><a data-primary="inline-size property" data-type="indexterm" id="idm45176106477920"/>been dealing with the inline-axis formatting of nonreplaced&#13;
block boxes in the normal flow of text. Replaced elements&#13;
are a bit simpler to manage. All of the rules given for nonreplaced&#13;
blocks hold true, with one exception: if <code>inline-size</code> is <code>auto</code>, the&#13;
<code>inline-size</code> of the element is the content’s intrinsic width. (<em>Intrinsic</em> means the original size—the size of the element by default when no external factors are applied to it.) The image in&#13;
the following example will be 20 pixels wide because that’s the width of&#13;
the original image:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"smile.svg"</code><code class="w"> </code><code class="na">style=</code><code class="s">"display: block; inline-size: auto; margin: 0;"</code><code class="w"/>&#13;
<code class="w">   </code><code class="na">alt=</code><code class="s">"smile"</code><code class="nt">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>If the actual image were 100 pixels wide instead, the element (and thus the image) would be laid&#13;
out as 100 pixels wide.</p>&#13;
&#13;
<p>We can override this rule by assigning a specific value to&#13;
<code>inline-size</code>. Suppose we modify the previous example to show the same image&#13;
three times, each with a different width value:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"smile.svg"</code><code class="w"> </code><code class="na">style=</code><code class="s">"display: block; inline-size: 25px; margin: 0;"</code><code class="w"/>&#13;
<code class="w">   </code><code class="na">alt=</code><code class="s">"small smile"</code><code class="w"> </code><code class="na">role=</code><code class="s">"img"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"smile.svg"</code><code class="w"> </code><code class="na">style=</code><code class="s">"display: block; inline-size: 50px; margin: 0;"</code><code class="w"/>&#13;
<code class="w">   </code><code class="na">alt=</code><code class="s">"medium smile"</code><code class="w"> </code><code class="na">role=</code><code class="s">"img"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"smile.svg"</code><code class="w"> </code><code class="na">style=</code><code class="s">"display: block; inline-size: 100px; margin: 0;"</code><code class="w"/>&#13;
<code class="w">   </code><code class="na">alt=</code><code class="s">"large smile"</code><code class="w"> </code><code class="na">role=</code><code class="s">"img"</code><code class="nt">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p><a data-type="xref" href="#bvf_fig18">Figure 6-38</a> illustrates the result.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig18">&#13;
<img alt="css5 0638" src="assets/css5_0638.png"/>&#13;
<h6><span class="label">Figure 6-38. </span>Changing replaced element inline sizes</h6>&#13;
</div></figure>&#13;
&#13;
<p>Note that the <a data-primary="block-size property" data-type="indexterm" id="idm45176106384064"/>block size of the elements also increases. When a replaced&#13;
element’s <code>inline-size</code> is changed from its intrinsic width, the value of&#13;
<code>block-size</code> is scaled to match, maintaining the object’s initial aspect ratio, unless <code>block-size</code> has been set to an explicit&#13;
value of its own. The reverse is also true: if <code>block-size</code> is set, but&#13;
<code>inline-size</code> is left as <code>auto</code>, then the inline size is scaled proportionately to&#13;
the change in block size.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="List Items" data-type="sect2"><div class="sect2" id="list-items">&#13;
<h2>List Items</h2>&#13;
&#13;
<p>List <a data-primary="visual formatting" data-secondary="list items" data-type="indexterm" id="idm45176106378752"/><a data-primary="lists" data-secondary="formatting items" data-type="indexterm" id="idm45176106377744"/><a data-primary="inline-axis formatting" data-secondary="list items" data-type="indexterm" id="idm45176106376800"/>items have a few special rules of their own. They are typically&#13;
preceded by a marker, such as a round bullet mark or a number.</p>&#13;
&#13;
<p>The <a data-primary="list-style-position property" data-type="indexterm" id="idm45176106375344"/>marker attached to a list item element can be either outside the&#13;
content of the list item or treated as an inline marker at the beginning&#13;
of the content, depending on the value of the property&#13;
<code>list-style-position</code>, as illustrated in <a data-type="xref" href="#bvf_fig32">Figure 6-39</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig32">&#13;
<img alt="css5 0639" src="assets/css5_0639.png"/>&#13;
<h6><span class="label">Figure 6-39. </span>Markers outside and inside the list</h6>&#13;
</div></figure>&#13;
&#13;
<p>If the marker stays outside the content, it is placed a specified distance&#13;
from the inline-start content edge of the content.&#13;
No matter how the list’s styles are altered, the marker stays the same&#13;
distance from the content edge.</p>&#13;
&#13;
<p>Remember that list-item boxes define containing blocks for their&#13;
descendant boxes, just like regular block boxes.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>List markers are discussed in more detail, including how to create and style them using the <code>::marker</code> pseudo-element, in <a data-type="xref" href="ch16.html#lists-and-generated-content">Chapter 16</a>.<a data-primary="" data-startref="ix_vis_format_inline_axis" data-type="indexterm" id="idm45176106334112"/><a data-primary="" data-startref="ix_inline_axis_format" data-type="indexterm" id="idm45176106333168"/><a data-primary="" data-startref="ix_block_inlineaxis" data-type="indexterm" id="idm45176106332224"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Box Sizing with Aspect Ratios" data-type="sect1"><div class="sect1" id="aspect-ratio-sizing">&#13;
<h1>Box Sizing with Aspect Ratios</h1>&#13;
&#13;
<p>Sometimes you’ll want to <a data-primary="boxes" data-secondary="sizing with aspect ratios" data-type="indexterm" id="ix_box_aspect_ratio"/><a data-primary="aspect-ratio property" data-type="indexterm" id="ix_aspect_ratio_prop"/>size an element by its <em>aspect ratio</em>, which means its block and inline sizes exist in a specific ratio.  Old TVs used to have a 4:3 width-to-height ratio, for example; HD video resolutions have a 16:9 aspect ratio.  You might want to force elements to be square while still letting their sizes flex.  In these cases, the <code>aspect-ratio</code> property can help.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176106326048">&#13;
<h1>aspect-ratio</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>auto</code> ‖ &lt;<em><code>ratio</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements except inline boxes and internal table and Ruby boxes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>If &lt;<em><code>ratio</code></em>&gt;, a pair of numbers; otherwise, <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Let’s say we know we’ll have a bunch of elements, and we don’t know how wide or tall each will be, but we want them all to be squares.  First, pick an axis you want to size on.  We’ll use <code>height</code> here.  Make sure the other axis is autosized, and set an aspect ratio:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="nt">div</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="n">aspect</code><code class="o">-</code><code class="n">ratio</code><code class="o">:</code> <code class="m">1</code><code class="o">/</code><code class="m">1</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#aspect-ratio">Figure 6-40</a> shows the same set of HTML, both with and without the previous CSS applied.</p>&#13;
&#13;
<figure><div class="figure" id="aspect-ratio">&#13;
<img alt="css5 0640" src="assets/css5_0640.png"/>&#13;
<h6><span class="label">Figure 6-40. </span>A gallery with and without aspect ratios defined</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <a data-primary="box-sizing property" data-type="indexterm" id="idm45176106284560"/>ratio is maintained over the distances defined by <code>box-sizing</code> (see <a data-type="xref" href="#altering-box-sizing">“Altering Box Sizing”</a>), so given the following CSS, the result will be an element whose outer border distances are in an exact 2:1 ratio:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.cards</code> <code class="nt">div</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">box-sizing</code><code class="o">:</code> <code class="nb">border-box</code><code class="p">;</code> <code class="n">aspect</code><code class="o">-</code><code class="n">ratio</code><code class="o">:</code> <code class="m">2</code><code class="o">/</code><code class="m">1</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The default value, <code>auto</code>, means that boxes that have an intrinsic aspect ratio—boxes generated by images, for example—will use that aspect ratio.  For elements that don’t have an intrinsic aspect ratio, such as most HTML elements like <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, and so on, the axis sizes of the box will be determined by the content.<a data-primary="" data-startref="ix_aspect_ratio_prop" data-type="indexterm" id="idm45176106242352"/><a data-primary="" data-startref="ix_box_aspect_ratio" data-type="indexterm" id="idm45176106241376"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inline Formatting" data-type="sect1"><div class="sect1" id="inline-formatting">&#13;
<h1>Inline Formatting</h1>&#13;
&#13;
<p><em>Inline formatting</em> isn’t as simple as <a data-primary="visual formatting" data-secondary="inline formatting" data-type="indexterm" id="ix_vis_format_inline"/><a data-primary="inline formatting" data-type="indexterm" id="ix_inline_format_ch6"/>formatting block-level elements, which just&#13;
generates block boxes and usually doesn’t allow anything to coexist with&#13;
them. By contrast, look <em>inside</em> a block-level element, such as a&#13;
paragraph. You may well ask, how was the size and wrapping of each line determined?&#13;
What controls the lines’ arrangement? How can I affect it?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Line Layout" data-type="sect2"><div class="sect2" id="line-layout">&#13;
<h2>Line Layout</h2>&#13;
&#13;
<p>To understand how <a data-primary="line layout" data-type="indexterm" id="ix_line_layout"/><a data-primary="inline formatting" data-secondary="line layout" data-type="indexterm" id="ix_inline_format_line"/>lines are generated, first consider an element containing one very long line of text, as shown in <a data-type="xref" href="#bvf_fig33">Figure 6-41</a>. Note that we’ve put a border around the line by wrapping the entire&#13;
line in a <code>&lt;span&gt;</code> element and then assigning it a border style:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">span</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">dashed</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="bvf_fig33">&#13;
<img alt="css5 0641" src="assets/css5_0641.png"/>&#13;
<h6><span class="label">Figure 6-41. </span>A single-line inline element</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#bvf_fig33">Figure 6-41</a> shows the simplest case of an inline element contained by a&#13;
block-level &#13;
<span class="keep-together">element.</span></p>&#13;
&#13;
<p>To get from this simplified state to something more familiar,&#13;
all we have to do is determine how wide (along the inline axis) the element should be, and then&#13;
break up the line so that the resulting pieces will fit into the content&#13;
inline size of the element. Therefore, we arrive at the state shown in <a data-type="xref" href="#bvf_fig34">Figure 6-42</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig34">&#13;
<img alt="css5 0642" src="assets/css5_0642.png"/>&#13;
<h6><span class="label">Figure 6-42. </span>A multiple-line inline element</h6>&#13;
</div></figure>&#13;
&#13;
<p>Nothing has really changed. All we did was take the single line and&#13;
break it into pieces, and then stack those pieces one after the other along the direction of the block flow.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#bvf_fig34">Figure 6-42</a>, the borders for each line of text also happen to coincide&#13;
with the top and bottom of each line. This is true only because no&#13;
padding has been set for the inline text. Notice that the borders overlap each other slightly; for example, the bottom border of&#13;
the first line is just below the top border of the second line. This is&#13;
because the border is drawn on the next pixel&#13;
to the <em>outside</em> of each line. Since the lines are&#13;
touching each other, their borders overlap as shown in <a data-type="xref" href="#bvf_fig34">Figure 6-42</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For simplicity, we use terms such as <em>top</em> and <em>bottom</em> when talking about the edges of line boxes.  In this context, the top of a line box is the one closest to the block-start, and the bottom of a line box is the one closest to the block-end.  Similarly, <em>tall</em> and <em>short</em> refer to the size of line boxes along the block axis.</p>&#13;
</div>&#13;
&#13;
<p class="less_space pagebreak-before">If we alter the span styles to have a <a data-primary="inline formatting" data-secondary="background" data-type="indexterm" id="idm45176106166064"/>background color, the actual&#13;
placement of the lines becomes clearer. Consider <a data-type="xref" href="#bvf_fig35">Figure 6-43</a>, which&#13;
shows four paragraphs in each of two writing modes, and the effects of different values of <code>text-align</code> (see <a data-type="xref" href="ch15.html#text_properties">Chapter 15</a>),&#13;
by each paragraph having the backgrounds of its lines <span class="keep-together">filled in.</span></p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig35">&#13;
<img alt="css5 0643" src="assets/css5_0643.png"/>&#13;
<h6><span class="label">Figure 6-43. </span>Showing lines in different alignments and writing modes</h6>&#13;
</div></figure>&#13;
&#13;
<p>As <a data-type="xref" href="#bvf_fig35">Figure 6-43</a> shows, not every line reaches to the edge of its parent&#13;
paragraph’s content area, which has been denoted with a dashed gray&#13;
border. For the left-aligned paragraph, the lines are all pushed flush&#13;
against the left content edge of the paragraph, and the end of each line happens wherever the line is broken. The reverse is true for the&#13;
right-aligned paragraph. For the centered paragraph, the centers of the&#13;
lines are aligned with the center of the paragraph.</p>&#13;
&#13;
<p>In the last <a data-primary="spacing" data-seealso="whitespace" data-type="indexterm" id="idm45176106158704"/>case, where the value of <code>text-align</code> is <code>justify</code>, each&#13;
line (except the last) is forced to be as wide as the paragraph’s content area so that the line’s edges touch the content edges of the paragraph. The difference between the natural length of the line and the width of the paragraph’s content area is made up by altering the spacing between letters and words in each line. Therefore, the value of <code>word-spacing</code> can be overridden when the text is justified. (The value of <code>letter-spacing</code> cannot be overridden if it is a length value.)</p>&#13;
&#13;
<p>That pretty well covers how lines are generated in the simplest cases.&#13;
As you’re about to see, however, the inline formatting model is far from&#13;
simple.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Basic Terms and Concepts" data-type="sect2"><div class="sect2" id="basic-terms-and-concepts">&#13;
<h2>Basic Terms and Concepts</h2>&#13;
&#13;
<p>Before we go any further, let’s <a data-primary="inline formatting" data-secondary="terms and concepts" data-type="indexterm" id="ix_inline_format_terms"/>review some terms of inline&#13;
layout, which will be crucial in navigating the following sections:</p>&#13;
<dl class="less_space pagebreak-before">&#13;
<dt>Anonymous text</dt>&#13;
<dd>&#13;
<p>Any <a data-primary="anonymous text" data-type="indexterm" id="idm45176106150064"/>string of characters that is not contained within an inline&#13;
element. Thus, in the markup <code>&lt;p&gt; I'm &lt;em&gt;so&lt;/em&gt; happy!&lt;/p&gt;</code>, the&#13;
sequences “ I’m ” and “ happy!” are anonymous text. Note that the spaces&#13;
are part of the text, since a space is a character like any other.</p>&#13;
</dd>&#13;
<dt>Em box</dt>&#13;
<dd>&#13;
<p>This is <a data-primary="boxes" data-secondary="em box (em square)" data-type="indexterm" id="idm45176106147424"/><a data-primary="character box (em box)" data-type="indexterm" id="idm45176106146416"/><a data-primary="em box (em square)" data-type="indexterm" id="idm45176106145744"/><a data-primary="fonts" data-secondary="glyphs not matching em boxes" data-type="indexterm" id="idm45176106145072"/>defined in the given font, otherwise known as the character box.&#13;
Actual glyphs can be taller or shorter than their em boxes. In CSS, the&#13;
value of <code>font-size</code> determines the height of each em box.</p>&#13;
</dd>&#13;
<dt>Content area</dt>&#13;
<dd>&#13;
<p>In <a data-primary="content area" data-secondary="inline-level elements" data-type="indexterm" id="idm45176106142336"/>nonreplaced elements, the content area can be one of two things, and&#13;
the CSS specification allows user agents to choose which one. The&#13;
content area can be the box described by the em boxes of every character&#13;
in the element, strung together; or it can be the box described by the&#13;
character glyphs in the element. In this book, we use the em box&#13;
definition for simplicity, and that’s what is used by most browsers.&#13;
In replaced elements, the content area&#13;
is the intrinsic height of the element plus any margins, borders, or&#13;
padding.</p>&#13;
</dd>&#13;
<dt>Leading</dt>&#13;
<dd>&#13;
<p>Leading <a data-primary="leading" data-type="indexterm" id="idm45176106139568"/><a data-primary="font-size property" data-secondary="inline element height from" data-type="indexterm" id="ix_font_size_prop"/>(pronounced “led-ing”) is the difference between the values of <code>font-size</code> and&#13;
<code>line-height</code>. This difference is divided in half, with one half&#13;
applied to the top and one half to the bottom of the content area. These&#13;
additions to the content area are called, perhaps unsurprisingly,&#13;
<em>half-leading</em>. <a data-primary="half-leading" data-type="indexterm" id="idm45176106136224"/>Leading is applied only to nonreplaced elements.</p>&#13;
</dd>&#13;
<dt>Inline box</dt>&#13;
<dd>&#13;
<p>This is the box<a data-primary="replaced elements" data-secondary="inline" data-type="indexterm" id="idm45176106134240"/><a data-primary="inline formatting" data-secondary="replaced elements" data-type="indexterm" id="idm45176106133232"/><a data-primary="inline boxes" data-type="indexterm" id="idm45176106132288"/><a data-primary="elements" data-secondary="inline-level" data-type="indexterm" id="idm45176106131616"/> described by the addition of the leading to the content&#13;
area. For nonreplaced elements, the height of the inline box of an&#13;
element will be exactly equal to the value of the <code>line-height</code> property. For&#13;
replaced elements, the height of the inline box of an element will be&#13;
exactly equal to the content area, since leading is not applied to&#13;
replaced elements.</p>&#13;
</dd>&#13;
<dt>Line box</dt>&#13;
<dd>&#13;
<p>This is the <a data-primary="line boxes" data-type="indexterm" id="idm45176106128816"/>shortest box that bounds the highest and lowest points of&#13;
the inline boxes that are found in the line. In other words, the top&#13;
edge of the line box is placed along the top of the highest inline-box&#13;
top, and the bottom of the line box is placed along the bottom of the&#13;
lowest inline-box bottom.  Remember that “top” and “bottom” are considered with respect to the block flow direction.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>CSS also contains a set of behaviors and useful concepts that fall outside&#13;
of the preceding list of terms and definitions:</p>&#13;
&#13;
<ul class="less_space pagebreak-before">&#13;
<li>&#13;
<p>The content area<a data-primary="content area" data-secondary="inline-level elements" data-type="indexterm" id="idm45176106126160"/> of an inline box is analogous to the content box of a block box.</p>&#13;
</li>&#13;
<li>&#13;
<p>The background<a data-primary="backgrounds" data-secondary="inline elements" data-type="indexterm" id="idm45176106124160"/> of an inline element is applied to the content area&#13;
plus any padding.</p>&#13;
</li>&#13;
<li>&#13;
<p>Any border<a data-primary="borders" data-secondary="inline elements" data-type="indexterm" id="idm45176106122192"/> on an inline element surrounds the content area plus any&#13;
padding.</p>&#13;
</li>&#13;
<li>&#13;
<p>Padding, borders, and margins on nonreplaced inline elements have no vertical&#13;
effect on the inline elements or the boxes they generate; they do&#13;
<em>not</em> affect the height of an element’s inline box (and thus the line&#13;
box that contains the element).</p>&#13;
</li>&#13;
<li>&#13;
<p>Margins and borders on replaced elements <em>do</em> affect the height of the&#13;
inline box for that element and, by implication, the height of the line&#13;
box for the line that contains the element.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>One more thing to note: inline boxes are vertically aligned within the&#13;
line according to their values for the property <code>vertical-align</code> (see <a data-type="xref" href="ch15.html#text_properties">Chapter 15</a>).</p>&#13;
&#13;
<p>Before moving on, let’s look at a <a data-primary="line boxes" data-type="indexterm" id="idm45176106116048"/>step-by-step process for constructing&#13;
a line box, which you can use to see how the various pieces of a line&#13;
fit together to determine its height. Determine the height of the inline box for each element in the line&#13;
by following these steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Find the <a data-primary="line-height property" data-type="indexterm" id="ix_line_height_prop"/>values of <code>font-size</code> and <code>line-height</code> for each inline&#13;
nonreplaced element and text that is not part of a descendant inline&#13;
element and combine them. This is done by subtracting the <code>font-size</code>&#13;
from the <code>line-height</code>, which yields the leading for the box. The&#13;
leading is split in half and applied to the top and bottom of each&#13;
em box.</p>&#13;
</li>&#13;
<li>&#13;
<p>Find the value of <code>height</code>, along with the values for the margins, padding, and borders along the block-start and block-end edges of each replaced element, and add them&#13;
together.</p>&#13;
</li>&#13;
<li>&#13;
<p>Figure out, for each content area, how much of it is above the&#13;
baseline for the overall line and how much of it is below the baseline.&#13;
This is not an easy task: you must know the position of the baseline for&#13;
each element and piece of anonymous text and the baseline of the line&#13;
itself, and then line them all up. In addition, the block-end edge of a&#13;
replaced element sits on the baseline for the overall line.</p>&#13;
</li>&#13;
<li>&#13;
<p>Determine the <a data-primary="vertical-align property" data-secondary="line heights" data-type="indexterm" id="idm45176106107840"/><a data-primary="vertical formatting" data-secondary="line heights, inline formatting" data-type="indexterm" id="idm45176106106832"/>vertical offset of any elements that have been given a&#13;
value for <code>vertical-align</code>. This will tell you how far up or down that&#13;
element’s inline box will be moved along the block axis, and that will change how much of the&#13;
element is above or below the baseline.</p>&#13;
</li>&#13;
<li>&#13;
<p>Now that you know where all of the inline boxes have come to rest,&#13;
calculate the final line box height. To do so, just add the distance&#13;
between the baseline and the highest inline-box top to the distance&#13;
between the baseline and the lowest inline-box bottom.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Let us consider the whole process in detail, which is the key to&#13;
intelligently styling &#13;
<span class="keep-together">inline content</span>.<a data-primary="" data-startref="ix_inline_format_line" data-type="indexterm" id="idm45176106103072"/><a data-primary="" data-startref="ix_line_layout" data-type="indexterm" id="idm45176106102064"/><a data-primary="" data-startref="ix_font_size_prop" data-type="indexterm" id="idm45176106101120"/><a data-primary="" data-startref="ix_inline_format_terms" data-type="indexterm" id="idm45176106100176"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Line Heights" data-type="sect2"><div class="sect2" id="line-heights">&#13;
<h2>Line Heights</h2>&#13;
&#13;
<p>First, <a data-primary="inline formatting" data-secondary="line heights" data-type="indexterm" id="ix_inline_format_height"/>know that all elements have a <code>line-height</code>, whether it’s&#13;
explicitly declared or not. This value greatly influences the way inline&#13;
elements are displayed, so let’s give it due attention.</p>&#13;
&#13;
<p>A line’s&#13;
height (or the height of a line box) is determined by the height of&#13;
its constituent elements and other content, such as text. It’s important&#13;
to understand that <code>line-height</code> affects inline elements and&#13;
other inline content, <em>not</em> block-level elements—at least, not directly.&#13;
We can <a data-primary="blocks" data-secondary="line height for" data-type="indexterm" id="idm45176106094032"/>set a <code>line-height</code> value for a block-level element, but the&#13;
value will have a visual impact only as it’s applied to inline content&#13;
within that block-level element. Consider the following empty paragraph,&#13;
for example:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"line-height: 0.25em;"</code><code class="nt">&gt;&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Without content, the paragraph won’t have anything to display, so we&#13;
won’t see anything. The fact that this paragraph has a <code>line-height</code> of&#13;
any value—be it <code>0.25em</code> or <code>25in</code>—makes no difference without some&#13;
content to create a line box.</p>&#13;
&#13;
<p>We can set a <code>line-height</code> value for a block-level element and&#13;
have that apply to all of the content within the block, whether it’s&#13;
contained in an inline element or anonymous text. In a certain sense,&#13;
then, each line of text contained within a block-level element is its&#13;
own inline element, whether or not it’s surrounded by tags. If you like,&#13;
picture a fictional tag sequence like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;line&gt;</code>This<code class="w"> </code>is<code class="w"> </code>a<code class="w"> </code>paragraph<code class="w"> </code>with<code class="w"> </code>a<code class="w"> </code>number<code class="w"> </code>of<code class="nt">&lt;/line&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;line&gt;</code>lines<code class="w"> </code>of<code class="w"> </code>text<code class="w"> </code>that<code class="w"> </code>make<code class="w"> </code>up<code class="w"> </code>the<code class="nt">&lt;/line&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;line&gt;</code>contents.<code class="nt">&lt;/line&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Even though the <code>line</code> tags don’t actually exist, the paragraph behaves&#13;
as if they did, and each line of text “inherits” styles from the paragraph.&#13;
You bother to create <code>line-height</code> rules for block-level&#13;
elements only so you don’t have to explicitly declare a <code>line-height</code> for all&#13;
of their inline elements, fictional or otherwise.</p>&#13;
&#13;
<p>The fictional <code>line</code> element clarifies the behavior that&#13;
results from setting <code>line-height</code> on a block-level element. According&#13;
to the CSS specification, declaring <code>line-height</code> on a block-level&#13;
element sets a <em>minimum</em> line-box height for the content of that&#13;
block-level element. Declaring <code>p.spacious {line-height: 24pt;}</code>&#13;
means that the <em>minimum</em> height for each line box is 24 points.&#13;
Technically, content can inherit this line height only if an inline&#13;
element does so. Most text isn’t contained by an inline element.&#13;
If you pretend that each line is contained by the fictional&#13;
<code>line</code> element, the model works out very nicely.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inline Nonreplaced Elements" data-type="sect2"><div class="sect2" id="inline-nonreplaced-elements">&#13;
<h2>Inline Nonreplaced Elements</h2>&#13;
&#13;
<p>Building on our <a data-primary="inline formatting" data-secondary="nonreplaced elements" data-type="indexterm" id="idm45176106024176"/>formatting knowledge, let’s move on to the construction&#13;
of lines that contain only nonreplaced elements (or anonymous text).&#13;
Then you’ll be in a good position to understand the differences between&#13;
nonreplaced and replaced elements in inline layout.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In this section, we use <em>top</em> and <em>bottom</em> to label where half-leading is placed and how line boxes are placed together. <a data-primary="half-leading" data-type="indexterm" id="idm45176106020976"/>Always remember that these terms are in relation to the direction of block flow: the <em>top edge</em> of an inline box is the one closest to the block-start edge, and the <em>bottom edge</em> of an inline box is closest to its block-end edge.  Similarly, <em>height</em> means the distance along the inline box’s block axis, and <em>width</em> is the distance along its inline axis.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building the Boxes" data-type="sect2"><div class="sect2" id="building-the-boxes">&#13;
<h2>Building the Boxes</h2>&#13;
&#13;
<p>First, for an <a data-primary="inline formatting" data-secondary="building boxes" data-type="indexterm" id="ix_inline_format_box"/><a data-primary="nonreplaced elements" data-type="indexterm" id="ix_nonrep_elem_inline_box"/><a data-primary="inline boxes" data-type="indexterm" id="ix_inline_box_ch6"/>inline nonreplaced element or piece of anonymous text, the&#13;
value of <code>font-size</code> determines the height of the content area. If an&#13;
inline element has a <code>font-size</code> of <code>15px</code>, the content area’s&#13;
height is 15 pixels because all of the em boxes in the element are 15&#13;
pixels tall, as illustrated in <a data-type="xref" href="#bvf_fig36">Figure 6-44</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig36">&#13;
<img alt="css5 0644" src="assets/css5_0644.png"/>&#13;
<h6><span class="label">Figure 6-44. </span>Em boxes determine content area height</h6>&#13;
</div></figure>&#13;
&#13;
<p>The next thing to consider is the value of <code>line-height</code> for the&#13;
element, and the difference between it and the value of <code>font-size</code>. If&#13;
an inline nonreplaced element has a <code>font-size</code> of <code>15px</code> and a&#13;
<code>line-height</code> of <code>21px</code>, the difference is 6 pixels. The user agent&#13;
splits the 6 pixels in half and applies half (3 pixels) to the top and half (3 pixels) to&#13;
the bottom of the content area, which yields the inline box. <a data-type="xref" href="#bvf_fig37">Figure 6-45</a> illustrates this process.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig37">&#13;
<img alt="css5 0645" src="assets/css5_0645.png"/>&#13;
<h6><span class="label">Figure 6-45. </span>Content area plus leading equals inline box</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, let’s break stuff so we can better understand how line height works.  Assume the &#13;
<span class="keep-together">following</span> is true:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"font-size: 12px; line-height: 12px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
This<code class="w"> </code>is<code class="w"> </code>text,<code class="w"> </code><code class="nt">&lt;em&gt;</code>some<code class="w"> </code>of<code class="w"> </code>which<code class="w"> </code>is<code class="w"> </code>emphasized<code class="nt">&lt;/em&gt;</code>,<code class="w"> </code>plus<code class="w"> </code>other<code class="w"> </code>text<code class="nt">&lt;br&gt;</code><code class="w"/>&#13;
that<code class="w"> </code>is<code class="w"> </code><code class="nt">&lt;strong</code><code class="w"> </code><code class="na">style=</code><code class="s">"font-size: 24px;"</code><code class="nt">&gt;</code>strongly<code class="w"> </code>emphasized<code class="nt">&lt;/strong&gt;</code><code class="w"/>&#13;
and<code class="w"> </code>that<code class="w"> </code>is<code class="nt">&lt;br&gt;</code><code class="w"/>&#13;
larger<code class="w"> </code>than<code class="w"> </code>the<code class="w"> </code>surrounding<code class="w"> </code>text.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, most of the text has a <code>font-size</code> of <code>12px</code>, while the&#13;
text in one inline nonreplaced element has a size of <code>24px</code>. However,&#13;
<em>all</em> of the text has a <code>line-height</code> of <code>12px</code> since <code>line-height</code> is&#13;
an inherited property. Therefore, the <code>&lt;strong&gt;</code> element’s <code>line-height</code>&#13;
is also <code>12px</code>.</p>&#13;
&#13;
<p>Thus, for each piece of text where both <code>font-size</code> and&#13;
<code>line-height</code> are <code>12px</code>, the content height does not change (since the&#13;
difference between <code>12px</code> and <code>12px</code> is 0), so the inline box is 12&#13;
pixels high. For the strong text, however, the difference between&#13;
<code>line-height</code> and <code>font-size</code> is <code>-12px</code>. This is divided in half to&#13;
determine the half-leading (<code>-6px</code>), and the half-leading is added to&#13;
both the top and bottom of the content height to arrive at an inline&#13;
box. Since we’re adding a negative number in both cases, the inline box&#13;
ends up being 12 pixels tall. The 12-pixel inline box is centered&#13;
vertically within the 24-pixel content height of the element, so the&#13;
inline box is smaller than the content area.</p>&#13;
&#13;
<p>So far, it sounds like we’ve done the same thing to each bit of text,&#13;
and that all the inline boxes are the same size, but that’s not quite true.&#13;
The inline boxes in the second line, although they’re the same size,&#13;
don’t line up because the text is all baseline aligned (see&#13;
<a data-type="xref" href="#bvf_fig38">Figure 6-46</a>), a concept we’ll discuss later in the chapter.</p>&#13;
&#13;
<p>Since inline boxes determine the height of the overall line box, their&#13;
placement with respect to one another is critical. The line box is&#13;
defined as the distance from the top of the highest inline box in the&#13;
line to the bottom of the lowest inline box, and the top of each line&#13;
box butts up against the bottom of the line box for the preceding line.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#bvf_fig38">Figure 6-46</a>, three boxes are being laid out for a single line of text: the two anonymous text boxes to either side of the <code>&lt;strong&gt;</code> element, and the <code>&lt;strong&gt;</code> element itself.  Because the enclosing paragraph has a <code>line-height</code> of <code>12px</code>, each of the three boxes will have a 12-pixel-tall inline box.  These inline boxes are centered within the content area of each box.  The boxes then have their baselines lined up, so the text all shares a common baseline.</p>&#13;
&#13;
<p>But because of where the inline boxes fall with respect to those baselines, the inline box of the <code>&lt;strong&gt;</code> element is a little bit higher than the inline boxes of the anonymous text boxes.  Thus, the distance from the top of the <code>&lt;strong&gt;</code>’s inline box to the bottoms of the anonymous inline boxes is more than 12 pixels, while the visible content of the line isn’t completely contained within the line box.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig38">&#13;
<img alt="css5 0646" src="assets/css5_0646.png"/>&#13;
<h6><span class="label">Figure 6-46. </span>Inline boxes within a line</h6>&#13;
</div></figure>&#13;
&#13;
<p>After all that, the middle line of text is placed between two other lines of text, as depicted in <a data-type="xref" href="#bvf_fig39">Figure 6-47</a>.  The bottom edge of the first line of text is placed against the top edge of the line of text we saw in <a data-type="xref" href="#bvf_fig38">Figure 6-46</a>.  Similarly, the top edge of the third line of text is placed against the bottom edge of the middle line of text.  Because the middle line of text has a slightly taller line box, the result is that the lines of text look irregular, because the distances between the three baselines are not consistent.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig39">&#13;
<img alt="css5 0647" src="assets/css5_0647.png"/>&#13;
<h6><span class="label">Figure 6-47. </span>Line boxes within a paragraph</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In just a bit, we’ll explore ways to cope with this irregular separation of baselines and&#13;
methods for achieving consistent baseline spacing.  (Spoiler: Unitless values for the win!)<a data-primary="" data-startref="ix_inline_box_ch6" data-type="indexterm" id="idm45176105878112"/><a data-primary="" data-startref="ix_nonrep_elem_inline_box" data-type="indexterm" id="idm45176105877136"/><a data-primary="" data-startref="ix_inline_format_box" data-type="indexterm" id="idm45176105876224"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Vertical Alignment" data-type="sect2"><div class="sect2" id="vertical-alignment">&#13;
<h2>Setting Vertical Alignment</h2>&#13;
&#13;
<p>If we change the <a data-primary="vertical formatting" data-secondary="alignment setting" data-type="indexterm" id="ix_vert_format_align"/><a data-primary="alignment" data-secondary="vertical" data-type="indexterm" id="ix_align_vert"/><a data-primary="vertical-align property" data-secondary="setting" data-type="indexterm" id="ix_vert_align_prop"/><a data-primary="inline formatting" data-secondary="vertical alignment" data-type="indexterm" id="ix_inline_format_vert_align"/>vertical alignment of the inline boxes, the same height&#13;
determination principles apply. Suppose that we give the <code>&lt;strong&gt;</code>&#13;
element a vertical alignment of <code>4px</code>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"font-size: 12px; line-height: 12px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
This<code class="w"> </code>is<code class="w"> </code>text,<code class="w"> </code><code class="nt">&lt;em&gt;</code>some<code class="w"> </code>of<code class="w"> </code>which<code class="w"> </code>is<code class="w"> </code>emphasized<code class="nt">&lt;/em&gt;</code>,<code class="w"> </code>plus<code class="w"> </code>other<code class="w"> </code>text<code class="nt">&lt;br&gt;</code><code class="w"/>&#13;
that<code class="w"> </code>is<code class="w"> </code><code class="nt">&lt;strong</code><code class="w"> </code><code class="na">style=</code><code class="s">"font-size: 24px; vertical-align: 4px;"</code><code class="nt">&gt;</code>strongly<code class="w"/>&#13;
emphasized<code class="nt">&lt;/strong&gt;</code><code class="w">  </code>and<code class="w"> </code>that<code class="w"> </code>is<code class="nt">&lt;br&gt;</code><code class="w"/>&#13;
larger<code class="w"> </code>than<code class="w"> </code>the<code class="w"> </code>surrounding<code class="w"> </code>text.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>That small change raises the <code>&lt;strong&gt;</code> element 4 pixels, which pushes&#13;
up both its content area and its inline box. Because the <code>&lt;strong&gt;</code>&#13;
element’s inline-box top was already the highest in the line, this&#13;
change in vertical alignment also pushes the top of the line box upward&#13;
by 4 pixels, as shown in <a data-type="xref" href="#bvf_fig40">Figure 6-48</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig40">&#13;
<img alt="css5 0648" src="assets/css5_0648.png"/>&#13;
<h6><span class="label">Figure 6-48. </span>Vertical alignment affects line-box height</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A formal definition for <code>vertical-align</code> can be found in &#13;
<span class="keep-together"><a data-type="xref" href="ch15.html#text_properties">Chapter 15</a>.</span></p>&#13;
</div>&#13;
&#13;
<p>Let’s consider another situation. Here, we have another inline element&#13;
in the same line as the strong text, and its alignment is other than the&#13;
baseline:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"font-size: 12px; line-height: 12px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
This<code class="w"> </code>is<code class="w"> </code>text,<code class="w"> </code><code class="nt">&lt;em&gt;</code>some<code class="w"> </code>of<code class="w"> </code>which<code class="w"> </code>is<code class="w"> </code>emphasized<code class="nt">&lt;/em&gt;</code>,<code class="nt">&lt;br&gt;</code><code class="w"/>&#13;
plus<code class="w"> </code>other<code class="w"> </code>text<code class="w"> </code>that<code class="w"> </code>is<code class="w"> </code><code class="nt">&lt;strong</code><code class="w"> </code><code class="na">style=</code><code class="s">"font-size: 24px; vertical-align: 4px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
strong<code class="nt">&lt;/strong&gt;</code><code class="w"> </code>and<code class="w"> </code><code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"vertical-align: top;"</code><code class="nt">&gt;</code>tall<code class="nt">&lt;/span&gt;</code><code class="w"> </code>and<code class="w"> </code>is<code class="nt">&lt;br&gt;</code><code class="w"/>&#13;
larger<code class="w"> </code>than<code class="w"> </code>the<code class="w"> </code>surrounding<code class="w"> </code>text.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Now we have the same result as in our earlier example, where the middle&#13;
line box is taller than the other line boxes. However, notice how the&#13;
“tall” text is aligned in <a data-type="xref" href="#bvf_fig41">Figure 6-49</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig41">&#13;
<img alt="css5 0649" src="assets/css5_0649.png"/>&#13;
<h6><span class="label">Figure 6-49. </span>Aligning an inline element to the line box</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this case, the top of the “tall” text’s inline box is aligned with&#13;
the top of the line box. Since the “tall” text has equal values for&#13;
<code>font-size</code> and <code>line-height</code>, the content height and inline box are the&#13;
same. However, consider this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"font-size: 12px; line-height: 12px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
This<code class="w"> </code>is<code class="w"> </code>text,<code class="w"> </code><code class="nt">&lt;em&gt;</code>some<code class="w"> </code>of<code class="w"> </code>which<code class="w"> </code>is<code class="w"> </code>emphasized<code class="nt">&lt;/em&gt;</code>,<code class="nt">&lt;br&gt;</code><code class="w"/>&#13;
plus<code class="w"> </code>other<code class="w"> </code>text<code class="w"> </code>that<code class="w"> </code>is<code class="w"> </code><code class="nt">&lt;strong</code><code class="w"> </code><code class="na">style=</code><code class="s">"font-size: 24px; vertical-align: 4px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
strong<code class="nt">&lt;/strong&gt;</code><code class="w"> </code>and<code class="w"> </code><code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"vertical-align: top; line-height: 2px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
tall<code class="nt">&lt;/span&gt;</code><code class="w"> </code>and<code class="w"> </code>is<code class="nt">&lt;br&gt;</code><code class="w"> </code>larger<code class="w"> </code>than<code class="w"> </code>the<code class="w"> </code>surrounding<code class="w"> </code>text.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Since the <code>line-height</code> for the “tall” text is less than its&#13;
<code>font-size</code>, the inline box for that element is smaller than its content&#13;
area. This tiny fact changes the placement of the text itself, because the&#13;
top of its inline box must be aligned with the top of the line box for&#13;
its line. Thus, we get the result shown in <a data-type="xref" href="#bvf_fig42">Figure 6-50</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig42">&#13;
<img alt="css5 0650" src="assets/css5_0650.png"/>&#13;
<h6><span class="label">Figure 6-50. </span>Text protruding from the line box (again)</h6>&#13;
</div></figure>&#13;
&#13;
<p>In relation to the terms we’ve been using in this chapter, the effects of the&#13;
assorted keyword values of <code>vertical-align</code> are as follows:</p>&#13;
<dl>&#13;
<dt><code>top</code></dt>&#13;
<dd>&#13;
<p>Aligns the <a data-primary="top keyword, vertical-align" data-type="indexterm" id="idm45176105651568"/>top (block-start edge) of the element’s inline box with the top of the&#13;
&#13;
<span class="keep-together">containing</span> line box.</p>&#13;
</dd>&#13;
<dt><code>bottom</code></dt>&#13;
<dd>&#13;
<p>Aligns the <a data-primary="bottom keyword, vertical-align" data-type="indexterm" id="idm45176105606496"/>bottom (block-end edge) of the element’s inline box with the bottom of the&#13;
containing line box.</p>&#13;
</dd>&#13;
<dt><code>text-top</code></dt>&#13;
<dd>&#13;
<p>Aligns the <a data-primary="text-top keyword, vertical-align" data-type="indexterm" id="idm45176105604480"/>top (block-start edge) of the element’s inline box with the top of the parent’s&#13;
content area.</p>&#13;
</dd>&#13;
<dt><code>text-bottom</code></dt>&#13;
<dd>&#13;
<p>Aligns the <a data-primary="text-bottom keyword, vertical-align" data-type="indexterm" id="idm45176105602352"/>bottom (block-end edge) of the element’s inline box with the bottom of the&#13;
parent’s content area.</p>&#13;
</dd>&#13;
<dt><code>middle</code></dt>&#13;
<dd>&#13;
<p>Aligns the <a data-primary="middle keyword, vertical-align" data-type="indexterm" id="idm45176105600000"/>vertical midpoint of the element’s inline box with <code>0.5ex</code> above the baseline of the parent.</p>&#13;
</dd>&#13;
<dt><code>super</code></dt>&#13;
<dd>&#13;
<p>Moves the <a data-primary="super keyword, vertical-align" data-type="indexterm" id="idm45176105597344"/>content area and inline box of the element upward along the block axis. The&#13;
distance is not specified and may vary by user agent.</p>&#13;
</dd>&#13;
<dt><code>sub</code></dt>&#13;
<dd>&#13;
<p>The same <a data-primary="sub keyword, vertical-align" data-type="indexterm" id="idm45176105595104"/>as <code>super</code>, except the element is moved downward along the block axis instead of&#13;
upward.</p>&#13;
</dd>&#13;
<dt>&lt;<em><code>percentage</code></em>&gt;</dt>&#13;
<dd>&#13;
<p>Shifts the element up or down the block axis by the distance defined by taking the&#13;
declared percentage of the element’s value for <code>line-height</code>.<a data-primary="" data-startref="ix_inline_format_vert_align" data-type="indexterm" id="idm45176105591552"/><a data-primary="" data-startref="ix_vert_align_prop" data-type="indexterm" id="idm45176105590576"/><a data-primary="" data-startref="ix_align_vert" data-type="indexterm" id="idm45176105589632"/><a data-primary="" data-startref="ix_vert_format_align" data-type="indexterm" id="idm45176105588688"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Managing the Line Height" data-type="sect2"><div class="sect2" id="managing-the-line-height">&#13;
<h2>Managing the Line Height</h2>&#13;
&#13;
<p>In previous sections, you saw that changing the <code>line-height</code> of an&#13;
inline element can cause text from one line to overlap another. In each&#13;
case, though, the changes were made to individual elements. So how can&#13;
you affect the <code>line-height</code> of elements in a more general way in order&#13;
to keep content from overlapping?</p>&#13;
&#13;
<p>One way to do this is to use the <code>em</code> unit in conjunction with an&#13;
element whose <code>font-size</code> has changed. For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">line-height</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code>&#13;
<code class="nt">strong</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">250%</code><code class="p">;</code> <code class="k">line-height</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
Not<code class="w"> </code>only<code class="w"> </code>does<code class="w"> </code>this<code class="w"> </code>paragraph<code class="w"> </code>have<code class="w"> </code>"normal"<code class="w"> </code>text,<code class="w"> </code>but<code class="w"> </code>it<code class="w"> </code>also<code class="nt">&lt;br&gt;</code><code class="w"/>&#13;
contains<code class="w"> </code>a<code class="w"> </code>line<code class="w"> </code>in<code class="w"> </code>which<code class="w"> </code><code class="nt">&lt;strong&gt;</code>some<code class="w"> </code>big<code class="w"> </code>text<code class="nt">&lt;/strong&gt;</code><code class="w"> </code>is<code class="w"> </code>found.<code class="nt">&lt;br&gt;</code><code class="w"/>&#13;
This<code class="w"> </code>large<code class="w"> </code>text<code class="w"> </code>helps<code class="w"> </code>illustrate<code class="w"> </code>our<code class="w"> </code>point.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>By setting a <code>line-height</code> for the <code>&lt;strong&gt;</code> element, we increase the&#13;
overall height of the line box, providing enough room to display the <code>&lt;strong&gt;</code>&#13;
element without overlapping any other text and without changing the&#13;
<code>line-height</code> of all lines in the paragraph. We use a value of <code>1em</code> so&#13;
that the <code>line-height</code> for the <code>&lt;strong&gt;</code> element will be set to the same&#13;
size as <code>&lt;strong&gt;</code>’s <code>font-size</code>. Remember, <code>line-height</code> is set in relation to&#13;
the <code>font-size</code> of the element itself, not the parent element. <a data-type="xref" href="#bvf_fig43">Figure 6-51</a> shows the results.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig43">&#13;
<img alt="css5 0651" src="assets/css5_0651.png"/>&#13;
<h6><span class="label">Figure 6-51. </span>Assigning the <code>line-height</code> property to inline elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>Make sure you really understand the previous sections, because readable formatting of the text gets trickier when we try to add borders. Let’s say we want to put&#13;
5-pixel borders around any hyperlink:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:any-link</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">blue</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If we don’t set a large-enough <code>line-height</code> to accommodate the border,&#13;
it will be in danger of overwriting other lines. We could increase the&#13;
size of the inline box for hyperlinks by using <code>line-height</code>, as we&#13;
did for the <code>&lt;strong&gt;</code> element in the earlier example; in this case, we’d&#13;
just need to make the value of <code>line-height</code> 10 pixels larger than the&#13;
value of <code>font-size</code> for those links. However, that will be difficult if we&#13;
don’t actually know the size of the font in pixels.</p>&#13;
&#13;
<p>Another solution is to increase the <code>line-height</code> of the paragraph. This&#13;
will affect every line in the entire element, not just the line in which&#13;
the bordered hyperlink appears:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">line-height</code><code class="o">:</code> <code class="m">1.8em</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">blue</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Because extra space is added above and below each line, the border&#13;
around the hyperlink doesn’t impinge on any other line, as shown in&#13;
<a data-type="xref" href="#bvf_fig44">Figure 6-52</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig44">&#13;
<img alt="css5 0652" src="assets/css5_0652.png"/>&#13;
<h6><span class="label">Figure 6-52. </span>Increasing <code>line-height</code> to leave room for inline borders</h6>&#13;
</div></figure>&#13;
&#13;
<p>This approach works because all of the text is the same&#13;
size. If the line contained other elements that changed the height&#13;
of the line box, our border situation might also change. Consider the&#13;
following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">14px</code><code class="p">;</code> <code class="k">line-height</code><code class="o">:</code> <code class="m">24px</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="nt">strong</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">150%</code><code class="p">;</code> <code class="k">line-height</code><code class="o">:</code> <code class="m">1.5em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Given these rules, the height of the inline box of a <code>&lt;strong&gt;</code> element&#13;
within a paragraph will be 31.5 pixels (14 × 1.5 × 1.5), and that will&#13;
also be the height of the line box. To keep baseline spacing&#13;
consistent, we must make the <code>&lt;p&gt;</code> element’s <code>line-height</code> equal to or&#13;
greater than <code>32px</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding baselines and line heights" data-type="sect3"><div class="sect3" id="baselines-and-line-heights">&#13;
<h3>Understanding baselines and line heights</h3>&#13;
&#13;
<p>The <a data-primary="baselines" data-secondary="line heights and" data-type="indexterm" id="idm45176105334880"/>actual height of each line box depends on the way its component&#13;
elements line up with one another. This alignment tends to depend very&#13;
much on where the baseline falls within each element (or piece of&#13;
anonymous text) because that location determines how the inline boxes&#13;
are arranged vertically.</p>&#13;
&#13;
<p>Consistent baseline spacing tends to be more of an art than a&#13;
science. If you declare all of your font sizes and line heights by using a&#13;
single unit, such as ems, you have a good chance of consistent&#13;
baseline spacing. If you mix units, however, that feat becomes a great&#13;
deal more difficult, if not impossible.</p>&#13;
&#13;
<p>As of late 2022, proposals call for properties that would let authors enforce consistent&#13;
baseline spacing regardless of the inline content, which would greatly&#13;
simplify certain aspects of online typography. None of these proposed&#13;
properties have been implemented, which makes their adoption a&#13;
distant hope at best.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Scaling line heights" data-type="sect3"><div class="sect3" id="scaling-line-heights">&#13;
<h3>Scaling line heights</h3>&#13;
&#13;
<p>The <a data-primary="scaling factor" data-type="indexterm" id="idm45176105356656"/>best way to set <code>line-height</code>, as it turns out, is to use a raw&#13;
number as the value. This method is best because the number becomes&#13;
the <em>scaling factor</em>, and that factor is an inherited, not a computed,&#13;
value. Let’s say we want the <code>line-height</code> of all elements in a document&#13;
to be one and a half times their <code>font-size</code>. We would declare the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code> <code class="p">{</code><code class="k">line-height</code><code class="o">:</code> <code class="m">1</code><code class="o">.</code><code class="m">5</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This scaling factor of 1.5 is passed down from element to element, and,&#13;
at each level, the factor is used as a multiplier of the <code>font-size</code> of&#13;
each element. Therefore, the following markup would be displayed as&#13;
shown in <a data-type="xref" href="#bvf_fig45">Figure 6-53</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">15px</code><code class="p">;</code> <code class="k">line-height</code><code class="o">:</code> <code class="m">1</code><code class="o">.</code><code class="m">5</code><code class="p">;}</code>&#13;
<code class="nt">small</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">66%</code><code class="p">;}</code>&#13;
<code class="nt">strong</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">200%</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">p</code><code class="o">&gt;</code><code class="nt">This</code> <code class="nt">paragraph</code> <code class="nt">has</code> <code class="nt">a</code> <code class="nt">line-height</code> <code class="nt">of</code> <code class="nt">1</code><code class="nc">.5</code> <code class="nt">times</code> <code class="nt">its</code> <code class="nt">font-size</code><code class="o">.</code> <code class="nt">In</code> <code class="nt">addition</code><code class="o">,</code>&#13;
<code class="nt">any</code> <code class="nt">elements</code> <code class="nt">within</code> <code class="nt">it</code> <code class="o">&lt;</code><code class="nt">small</code><code class="o">&gt;</code><code class="nt">such</code> <code class="nt">as</code> <code class="nt">this</code> <code class="nt">small</code> <code class="nt">element</code><code class="o">&lt;/</code><code class="nt">small</code><code class="o">&gt;</code> <code class="nt">also</code> <code class="nt">have</code>&#13;
<code class="nt">line-heights</code> <code class="nt">1</code><code class="nc">.5</code> <code class="nt">times</code> <code class="nt">their</code> <code class="nt">font-size</code><code class="o">..</code><code class="nc">.and</code> <code class="nt">that</code> <code class="nt">includes</code> <code class="o">&lt;</code><code class="nt">strong</code><code class="o">&gt;</code><code class="nt">this</code> <code class="nt">big</code>&#13;
<code class="nt">element</code> <code class="nt">right</code> <code class="nt">here</code><code class="o">&lt;/</code><code class="nt">strong</code><code class="o">&gt;.</code> <code class="nt">By</code> <code class="nt">using</code> <code class="nt">a</code> <code class="nt">scaling</code> <code class="nt">factor</code><code class="o">,</code> <code class="nt">line-heights</code> <code class="nt">scale</code>&#13;
<code class="nt">to</code> <code class="nt">match</code> <code class="nt">the</code> <code class="nt">font-size</code> <code class="nt">of</code> <code class="nt">any</code> <code class="nt">element</code><code class="o">.&lt;/</code><code class="nt">p</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>In this example, the line height for the <code>&lt;small&gt;</code> element turns out to be&#13;
15 pixels, and for the <code>&lt;strong&gt;</code> element, it’s 45 pixels.&#13;
If we don’t want our big <code>&lt;strong&gt;</code> text to generate too much extra&#13;
leading, we can give it its own <code>line-height</code> value, which will override the&#13;
inherited scaling factor:<a data-primary="" data-startref="ix_line_height_prop" data-type="indexterm" id="idm45176105223744"/><a data-primary="" data-startref="ix_inline_format_height" data-type="indexterm" id="idm45176105222800"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">15px</code><code class="p">;</code> <code class="k">line-height</code><code class="o">:</code> <code class="m">1</code><code class="o">.</code><code class="m">5</code><code class="p">;}</code>&#13;
<code class="nt">small</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">66%</code><code class="p">;}</code>&#13;
<code class="nt">strong</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">200%</code><code class="p">;</code> <code class="k">line-height</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="bvf_fig45">&#13;
<img alt="css5 0653" src="assets/css5_0653.png"/>&#13;
<h6><span class="label">Figure 6-53. </span>Using a scaling factor for <code>line-height</code></h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding Box Properties to Nonreplaced Elements" data-type="sect2"><div class="sect2" id="adding-box-properties">&#13;
<h2>Adding Box Properties to Nonreplaced Elements</h2>&#13;
&#13;
<p>As you <a data-primary="inline formatting" data-secondary="nonreplaced elements" data-type="indexterm" id="ix_inline_format_nonrep"/>may recall from previous discussions, while padding, margins, and borders may all be applied to inline nonreplaced elements, these properties have no impact on the height of the inline element’s line box.</p>&#13;
&#13;
<p>The <a data-primary="borders" data-secondary="inline elements" data-type="indexterm" id="idm45176105108032"/>border edge of inline elements is controlled by <code>font-size</code>, not&#13;
<code>line-height</code>. In other words, if a <code>&lt;span&gt;</code> element has a <code>font-size</code>&#13;
of <code>12px</code> and a <code>line-height</code> of <code>36px</code>, its content area is <code>12px</code>&#13;
high, and the border will surround that content area.</p>&#13;
&#13;
<p>Alternatively, we can assign padding to the inline element, which will&#13;
push the borders away from the text itself:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">span</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">4px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This <a data-primary="inline formatting" data-secondary="padding" data-type="indexterm" id="idm45176108993248"/><a data-primary="padding" data-secondary="inline elements" data-type="indexterm" id="idm45176108992400"/>padding does not alter the actual shape of the content&#13;
height, and so it will not affect the height of the inline box for this&#13;
element. Similarly, adding borders to an inline element will not affect&#13;
the way line boxes are generated and laid out, as illustrated in <a data-type="xref" href="#bvf_fig47">Figure 6-54</a> (both with and without the 4-pixel padding).</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig47">&#13;
<img alt="css5 0654" src="assets/css5_0654.png"/>&#13;
<h6><span class="label">Figure 6-54. </span>Padding and borders do not alter line height</h6>&#13;
</div></figure>&#13;
&#13;
<p>As for margins, they do not, practically speaking, apply to the block edges of an inline nonreplaced element, as they don’t affect the&#13;
height of the line box. The inline ends of the element are another story.</p>&#13;
&#13;
<p class="less_space pagebreak-before">Recall the idea that an inline element is basically laid out as a single&#13;
line and then broken into pieces. So, if we apply margins to an&#13;
inline element, those margins will appear at its beginning and end:&#13;
these are the inline-start and inline-end margins, respectively. Padding also appears&#13;
at these edges. Thus, although padding and margins (and borders) do not&#13;
affect line heights, they can still affect the layout of an element’s&#13;
content by pushing text away from its ends. In fact, negative inline-start and&#13;
-end margins can pull text closer to the inline element, or even cause&#13;
overlap.</p>&#13;
&#13;
<p>So, what <a data-primary="inline formatting" data-secondary="background" data-type="indexterm" id="idm45176105066912"/>happens when an inline element has a background and enough&#13;
padding to cause the lines’ backgrounds to overlap? Take the following&#13;
situation as an example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">15px</code><code class="p">;</code> <code class="k">line-height</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="nt">span</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="m">#FAA</code><code class="p">;</code>&#13;
     <code class="n">padding</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="n">padding</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">10px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>All of the text within the <code>&lt;span&gt;</code> element will have a content area 15&#13;
pixels tall, and we’ve applied 10 pixels of padding to the top and&#13;
bottom of each content area. The extra pixels won’t increase the height&#13;
of the line box, which would be fine, except there is a background&#13;
color. Thus, we get the result shown in <a data-type="xref" href="#bvf_fig48">Figure 6-55</a>.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig48">&#13;
<img alt="css5 0655" src="assets/css5_0655.png"/>&#13;
<h6><span class="label">Figure 6-55. </span>Padding and margins on inline elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>CSS explicitly states that the line boxes are drawn in document&#13;
order: “This will cause the borders on subsequent lines to paint over&#13;
the borders and text of previous lines.” The same principle applies to&#13;
backgrounds as well, as <a data-type="xref" href="#bvf_fig48">Figure 6-55</a> shows.<a data-primary="" data-startref="ix_inline_format_nonrep" data-type="indexterm" id="idm45176105013936"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Changing Breaking Behavior" data-type="sect2"><div class="sect2" id="changing-breaking-behavior">&#13;
<h2>Changing Breaking Behavior</h2>&#13;
&#13;
<p>In the <a data-primary="breaks" data-secondary="changing" data-type="indexterm" id="idm45176105011216"/><a data-primary="breaks" data-secondary="line" data-type="indexterm" id="idm45176105010208"/><a data-primary="inline formatting" data-secondary="line breaks" data-type="indexterm" id="idm45176105009264"/><a data-primary="line breaks" data-type="indexterm" id="idm45176105008320"/>previous section, you saw that when an inline nonreplaced element&#13;
is broken across multiple lines, it’s treated as if it were one long&#13;
single-line element that’s sliced into smaller boxes, one slice per line&#13;
break. <a data-primary="box-decoration-break property" data-type="indexterm" id="idm45176105007520"/>That’s just the default behavior, and it can be changed&#13;
via the property <code>box-decoration-break</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176105006240">&#13;
<h1>box-decoration-break</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>slice</code> | <code>clone</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>slice</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The default value, <code>slice</code>, is what you saw in the previous section. The&#13;
other value, <code>clone</code>, causes each fragment of the element to be drawn&#13;
as if it were a standalone box. What does that mean? Compare the two&#13;
examples in <a data-type="xref" href="#bvf_fig50">Figure 6-56</a>, in which exactly the same markup and styles are&#13;
treated as either sliced or cloned.</p>&#13;
&#13;
<p>Many of the differences may be apparent, but a few are perhaps more&#13;
subtle. Among the effects are the application of padding to each&#13;
element’s fragment, including at the ends where the line breaks&#13;
occur. Similarly, the border is drawn around each fragment&#13;
individually, instead of being broken up.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig50">&#13;
<img alt="css5 0656" src="assets/css5_0656.png"/>&#13;
<h6><span class="label">Figure 6-56. </span>Sliced and cloned inline fragments</h6>&#13;
</div></figure>&#13;
&#13;
<p>More subtly, notice how the <code>background-image</code> positioning changes&#13;
between the two. In the sliced version, background images are sliced&#13;
along with everything else, meaning that only one of the fragments&#13;
contains the origin image. In the cloned version, however, each&#13;
background acts as its own copy, so each has its own origin image. This&#13;
means, for example, that even if we have a nonrepeated background&#13;
image, it will appear once in each fragment instead of in only one&#13;
fragment.</p>&#13;
&#13;
<p>The <code>box-decoration-break</code> property will most often be used with inline&#13;
boxes, but it applies anytime there’s a break in&#13;
an element—for example, when a page break interrupts an element in paged media.&#13;
In such a case, each fragment is a separate slice. If we&#13;
set <code>box-decoration-break: clone</code>, each box fragment will be&#13;
treated as a copy when it comes to borders, padding, backgrounds, and so&#13;
on. The same holds true in multicolumn layout: if an element is split by&#13;
a column break, the value of&#13;
<code>box-decoration-break</code> will affect how it is rendered.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Glyphs Versus Content Area" data-type="sect2"><div class="sect2" id="glyphs-versus-content-area">&#13;
<h2>Glyphs Versus Content Area</h2>&#13;
&#13;
<p>Even <a data-primary="content area" data-secondary="versus glyphs" data-secondary-sortas="glyphs" data-type="indexterm" id="idm45176104952048"/><a data-primary="inline formatting" data-secondary="content area versus glyphs" data-type="indexterm" id="idm45176104950768"/>when you try to keep inline nonreplaced element&#13;
backgrounds from overlapping, it can still happen, depending on which&#13;
font is in use. The problem lies in the difference between a font’s em&#13;
box and its character glyphs. Most fonts, as it turns out, don’t have em&#13;
boxes whose heights match the character glyphs.</p>&#13;
&#13;
<p>That <a data-primary="em box (em square)" data-type="indexterm" id="idm45176104949344"/><a data-primary="boxes" data-secondary="em box (em square)" data-type="indexterm" id="idm45176104948608"/>may sound abstract, but it has practical consequences.&#13;
The “painting area” of an inline nonreplaced element is&#13;
left to the user agent. If a user agent takes the em box to be the&#13;
height of the content area, the background of an inline nonreplaced&#13;
element will be equal to the height of the em box (which is the value of&#13;
<code>font-size</code>). If a user agent uses the maximum ascender and descender of&#13;
the font, the background may be taller or shorter than the em box.&#13;
Therefore, you could give an inline nonreplaced element a <code>line-height</code>&#13;
of <code>1em</code> and still have its background overlap the content of other&#13;
lines.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inline Replaced Elements" data-type="sect2"><div class="sect2" id="inline-replaced-elements">&#13;
<h2>Inline Replaced Elements</h2>&#13;
&#13;
<p>Inline <a data-primary="replaced elements" data-secondary="inline" data-type="indexterm" id="ix_replaced_elem_inline"/><a data-primary="inline formatting" data-secondary="replaced elements" data-type="indexterm" id="ix_inline_format_replaced"/>replaced elements, such as images, are assumed to have an&#13;
intrinsic height and width; for example, an image will be a certain&#13;
number of pixels high and wide. Therefore, a replaced element with an&#13;
intrinsic height can cause a line box to become taller than normal. This&#13;
does <em>not</em> change the value of <code>line-height</code> for any element in the&#13;
line, <em>including the replaced element itself</em>. Instead, the line box is&#13;
made just tall enough to accommodate the replaced element, plus any&#13;
box properties. In other words, the entirety of the replaced&#13;
element—content, margins, borders, and padding—is used to define the&#13;
element’s inline box. The following styles lead to one such example, as&#13;
shown in <a data-type="xref" href="#bvf_fig51">Figure 6-57</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">15px</code><code class="p">;</code> <code class="k">line-height</code><code class="o">:</code> <code class="m">18px</code><code class="p">;}</code>&#13;
<code class="nt">img</code> <code class="p">{</code><code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">30px</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="nb">none</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="bvf_fig51">&#13;
<img alt="css5 0657" src="assets/css5_0657.png"/>&#13;
<h6><span class="label">Figure 6-57. </span>Replaced elements can increase the height of the line box but not the value of <code>line-height</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>Despite all the <a data-primary="vertical formatting" data-secondary="alignment setting" data-type="indexterm" id="idm45176104881392"/><a data-primary="alignment" data-secondary="vertical" data-type="indexterm" id="idm45176104880384"/><a data-primary="line-height property" data-type="indexterm" id="idm45176104879440"/>blank space, the effective value of <code>line-height</code> has&#13;
not changed, either for the paragraph or the image itself. The <code>line-height</code> value has no effect on the image’s inline box. Because the image in&#13;
<a data-type="xref" href="#bvf_fig51">Figure 6-57</a> has no padding, margins, or borders, its inline box is&#13;
equivalent to its content area, which is, in this case, 30 pixels tall.</p>&#13;
&#13;
<p>Nonetheless, an inline replaced element still has a value for&#13;
<code>line-height</code>. Why? In the most common case, it needs the value in order&#13;
to correctly position the element if it’s been vertically aligned.&#13;
Recall that, for example, percentage values for <code>vertical-align</code> are&#13;
calculated with respect to an element’s <code>line-height</code>. Thus:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">15px</code><code class="p">;</code> <code class="k">line-height</code><code class="o">:</code> <code class="m">18px</code><code class="p">;}</code>&#13;
<code class="nt">img</code> <code class="p">{</code><code class="k">vertical-align</code><code class="o">:</code> <code class="m">50%</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;</code>The<code class="w"> </code>image<code class="w"> </code>in<code class="w"> </code>this<code class="w"> </code>sentence<code class="w"> </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"test.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"test"</code><code class="nt">&gt;</code><code class="w"/>&#13;
will<code class="w"> </code>be<code class="w"> </code>raised<code class="w"> </code>9<code class="w"> </code>pixels.<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The inherited value of <code>line-height</code> causes the image to be raised 9&#13;
pixels instead of some other number. Without a value for <code>line-height</code>,&#13;
it wouldn’t be possible to perform percentage-value vertical alignments.&#13;
The height of the image itself has no relevance when it comes to&#13;
vertical alignment; the value of <code>line-height</code> is all that matters.</p>&#13;
&#13;
<p>However, for other replaced elements, it might be important to pass on a&#13;
<code>line-height</code> value to descendant elements within that replaced element.&#13;
An example would be an SVG image, which can use CSS to style text found&#13;
within the image.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding Box Properties to Replaced Elements" data-type="sect2"><div class="sect2" id="adding-box-properties-1">&#13;
<h2>Adding Box Properties to Replaced Elements</h2>&#13;
&#13;
<p>After everything we’ve just been through, applying margins, borders, and&#13;
padding to inline replaced elements seems almost simple.</p>&#13;
&#13;
<p>Padding and borders<a data-primary="replaced elements" data-secondary="padding" data-type="indexterm" id="idm45176104799872"/><a data-primary="replaced elements" data-secondary="borders for" data-type="indexterm" id="idm45176104798864"/><a data-primary="padding" data-secondary="replaced elements" data-type="indexterm" id="idm45176104797920"/><a data-primary="borders" data-secondary="replaced elements" data-type="indexterm" id="idm45176104796976"/> are applied to replaced elements as usual; padding&#13;
inserts space around the actual content, and the border surrounds the&#13;
padding. What’s unusual about the process is that the padding and border&#13;
actually influence the height of the line box because they are part of&#13;
the inline box of an inline replaced element (unlike with inline nonreplaced&#13;
elements). Consider <a data-type="xref" href="#bvf_fig52">Figure 6-58</a>, which results from the following styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code> <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">50px</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nc">.one</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">dotted</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nc">.two</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Note that the first line box is made tall enough to contain the image,&#13;
whereas the second is tall enough to contain the image, its padding, and&#13;
its border.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig52">&#13;
<img alt="css5 0658" src="assets/css5_0658.png"/>&#13;
<h6><span class="label">Figure 6-58. </span>Adding padding, borders, and margins to an inline replaced element &#13;
<span class="keep-together">increases</span> its inline box</h6>&#13;
</div></figure>&#13;
&#13;
<p>Margins<a data-primary="margins" data-secondary="replaced elements" data-type="indexterm" id="idm45176104728528"/><a data-primary="replaced elements" data-secondary="margins" data-type="indexterm" id="idm45176104727520"/> are also contained within the line box, but they have their own&#13;
wrinkles. Setting a positive margin is no mystery; it will make&#13;
the inline box of the replaced element taller. Setting negative margins&#13;
has a similar effect: it decreases the size of the replaced&#13;
element’s inline box. This is illustrated in <a data-type="xref" href="#bvf_fig53">Figure 6-59</a>, where we can see&#13;
that a negative top margin is pulling down the line above the image:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.two</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">start</code><code class="o">:</code> <code class="m">-10px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Negative <a data-primary="negative margins" data-type="indexterm" id="idm45176104683808"/>margins operate the same way on block-level elements, as shown earlier in the chapter. In this case, the negative margins make the replaced element’s&#13;
inline box smaller than ordinary. Negative margins are the only way to&#13;
cause inline replaced elements to bleed into other lines, and it’s why&#13;
the boxes that replaced inline elements generate are often assumed to be&#13;
inline-block.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_fig53">&#13;
<img alt="css5 0659" src="assets/css5_0659.png"/>&#13;
<h6><span class="label">Figure 6-59. </span>The effect of negative margins on inline replaced elements</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Replaced Elements and the Baseline" data-type="sect2"><div class="sect2" id="replaced-elements-and-the-baseline">&#13;
<h2>Replaced Elements and the Baseline</h2>&#13;
&#13;
<p>You may have <a data-primary="inline formatting" data-secondary="baselines" data-type="indexterm" id="ix_inline_format_baseline"/><a data-primary="baselines" data-secondary="inline replaced elements" data-type="indexterm" id="ix_baseline_replaced"/>noticed by now that, by default, inline replaced elements&#13;
sit on the baseline. If you add bottom (block-end) padding, a margin, or a border to&#13;
the replaced element, then the content area will move upward along the block axis.&#13;
Replaced elements do not have&#13;
baselines of their own, so the next best thing is to align the bottom of&#13;
their inline boxes with the baseline. Thus, it is actually the&#13;
outer block-end margin edge that is aligned with the baseline, as illustrated in&#13;
<a data-type="xref" href="#bvf_fig54">Figure 6-60</a>.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="bvf_fig54">&#13;
<img alt="css5 0660" src="assets/css5_0660.png"/>&#13;
<h6><span class="label">Figure 6-60. </span>Inline replaced elements sit on the baseline</h6>&#13;
</div></figure>&#13;
&#13;
<p>This baseline alignment leads to an unexpected (and unwelcome)&#13;
consequence: an image placed in a table cell all by itself should make&#13;
the table cell tall enough to contain the line box containing the image.&#13;
The resizing occurs even if no actual text, not even&#13;
whitespace, is in the table cell with the image. Therefore, the common&#13;
sliced-image and spacer-GIF designs of years past can fall apart quite&#13;
dramatically in modern browsers. (We know that <em>you</em> don’t create such&#13;
things, but this is still a handy context in which to explain this&#13;
behavior.) Consider the simplest case:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">td</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">12px</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;td&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"spacer.gif"</code><code class="w"> </code><code class="na">height=</code><code class="s">"1"</code><code class="w"> </code><code class="na">width=</code><code class="s">"10"</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="nt">&gt;&lt;/td&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Under the CSS inline formatting model, the table cell will be 12 pixels&#13;
tall, with the image sitting on the baseline of the cell. So we might have 3 pixels of space below the image and 8 above it, although&#13;
the exact distances would depend on the font family used and the&#13;
placement of its baseline.</p>&#13;
&#13;
<p>This behavior is not confined to images inside table cells; it will also&#13;
happen anytime an inline replaced element is the sole&#13;
descendant of a block-level or table-cell element. For example, an image&#13;
inside a <code>&lt;div&gt;</code> will also sit on the baseline.</p>&#13;
&#13;
<p>Here’s another interesting effect of inline replaced elements sitting on&#13;
the baseline: if we apply a negative bottom (block-end) margin, the element will&#13;
get pulled downward because the bottom of its inline box will&#13;
be higher than the bottom of its content area. Thus, the following rule&#13;
would have the result shown in <a data-type="xref" href="#bvf_fig55">Figure 6-61</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="nt">img</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">-10px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="bvf_fig55">&#13;
<img alt="css5 0661" src="assets/css5_0661.png"/>&#13;
<h6><span class="label">Figure 6-61. </span>Pulling inline replaced elements down with a negative block-end margin</h6>&#13;
</div></figure>&#13;
&#13;
<p>This can easily cause a replaced element to bleed into following lines&#13;
of text, as <a data-type="xref" href="#bvf_fig55">Figure 6-61</a> shows.<a data-primary="" data-startref="ix_inline_format_replaced" data-type="indexterm" id="idm45176104587440"/><a data-primary="" data-startref="ix_replaced_elem_inline" data-type="indexterm" id="idm45176104558000"/><a data-primary="" data-startref="ix_baseline_replaced" data-type="indexterm" id="idm45176104557056"/><a data-primary="" data-startref="ix_inline_format_baseline" data-type="indexterm" id="idm45176104556112"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inline-Block Elements" data-type="sect2"><div class="sect2" id="inline-block-elements">&#13;
<h2>Inline-Block Elements</h2>&#13;
&#13;
<p>As befits the <a data-primary="inline formatting" data-secondary="inline-block elements" data-type="indexterm" id="ix_inline_format_inblock"/>hybrid look of the value name <code>inline-block</code>, inline-block&#13;
elements are indeed a hybrid of block-level and inline elements.</p>&#13;
&#13;
<p>An inline-block element relates to other elements and content as an inline box just as an image would: inline-block elements are formatted within a line as a replaced element.&#13;
This means the bottom (block-end) edge of the inline-block&#13;
element will rest on the baseline of the text line by default and will&#13;
not line break within itself.</p>&#13;
&#13;
<p>Inside the inline-block element, the content is formatted as though the&#13;
element were block-level. The properties <code>width</code> and <code>height</code> apply to&#13;
the element (and thus so does <code>box-sizing</code>), as they do to any block-level or&#13;
inline replaced element, and those properties will increase the height&#13;
of the line if they are taller than the surrounding content.</p>&#13;
&#13;
<p>Let’s consider some example markup that should help make this clearer:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">id=</code><code class="s">"one"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">   </code>This<code class="w"> </code>text<code class="w"> </code>is<code class="w"> </code>the<code class="w"> </code>content<code class="w"> </code>of<code class="w"> </code>a<code class="w"> </code>block-level<code class="w"> </code>element.<code class="w"> </code>Within<code class="w"> </code>this<code class="w"/>&#13;
<code class="w">   </code>block-level<code class="w"> </code>element<code class="w"> </code>is<code class="w"> </code>another<code class="w"> </code>block-level<code class="w"> </code>element.<code class="w">  </code><code class="nt">&lt;p&gt;</code>Look,<code class="w"> </code>it's<code class="w"> </code>a<code class="w"/>&#13;
<code class="w">   </code>block-level<code class="w"> </code>paragraph.<code class="nt">&lt;/p&gt;</code><code class="w"> </code>Here's<code class="w"> </code>the<code class="w"> </code>rest<code class="w"> </code>of<code class="w"> </code>the<code class="w"> </code>DIV,<code class="w"> </code>which<code class="w"> </code>is<code class="w"> </code>still<code class="w"/>&#13;
<code class="w">   </code>block-level.<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">id=</code><code class="s">"two"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">   </code>This<code class="w"> </code>text<code class="w"> </code>is<code class="w"> </code>the<code class="w"> </code>content<code class="w"> </code>of<code class="w"> </code>a<code class="w"> </code>block-level<code class="w"> </code>element.<code class="w"> </code>Within<code class="w"> </code>this<code class="w"/>&#13;
<code class="w">   </code>block-level<code class="w"> </code>element<code class="w"> </code>is<code class="w"> </code>an<code class="w"> </code>inline<code class="w"> </code>element.<code class="w">  </code><code class="nt">&lt;p&gt;</code>Look,<code class="w"> </code>it's<code class="w"> </code>an<code class="w"> </code>inline<code class="w"/>&#13;
<code class="w">   </code>paragraph.<code class="nt">&lt;/p&gt;</code><code class="w">  </code>Here's<code class="w"> </code>the<code class="w"> </code>rest<code class="w"> </code>of<code class="w"> </code>the<code class="w"> </code>DIV,<code class="w"> </code>which<code class="w"> </code>is<code class="w"> </code>still<code class="w"> </code>block-level.<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">id=</code><code class="s">"three"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">   </code>This<code class="w"> </code>text<code class="w"> </code>is<code class="w"> </code>the<code class="w"> </code>content<code class="w"> </code>of<code class="w"> </code>a<code class="w"> </code>block-level<code class="w"> </code>element.<code class="w"> </code>Within<code class="w"> </code>this<code class="w"/>&#13;
<code class="w">   </code>block-level<code class="w"> </code>element<code class="w"> </code>is<code class="w"> </code>an<code class="w"> </code>inline-block<code class="w"> </code>element.<code class="w">  </code><code class="nt">&lt;p&gt;</code>Look,<code class="w"> </code>it's<code class="w"> </code>an<code class="w"> </code>inline-block<code class="w"/>&#13;
<code class="w">   </code>paragraph.<code class="nt">&lt;/p&gt;</code><code class="w">  </code>Here's<code class="w"> </code>the<code class="w"> </code>rest<code class="w"> </code>of<code class="w"> </code>the<code class="w"> </code>DIV,<code class="w"> </code>which<code class="w"> </code>is<code class="w"> </code>still<code class="w"> </code>block-level.<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>To this markup, we apply the following rules:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">1em</code> <code class="m">0</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">dotted</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#one</code> <code class="nt">p</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">block</code><code class="p">;</code> <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">6em</code><code class="p">;</code> <code class="k">text-align</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#two</code> <code class="nt">p</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">inline</code><code class="p">;</code> <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">6em</code><code class="p">;</code> <code class="k">text-align</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#three</code> <code class="nt">p</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">inline-block</code><code class="p">;</code> <code class="nb">inline</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">6em</code><code class="p">;</code> <code class="k">text-align</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#bvf_fig56">Figure 6-62</a> depicts the result of this stylesheet.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig56">&#13;
<img alt="css5 0662" src="assets/css5_0662.png"/>&#13;
<h6><span class="label">Figure 6-62. </span>The behavior of an inline-block element</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice that in the second <code>&lt;div&gt;</code>, the inline paragraph is formatted as&#13;
normal inline content, which means <code>width</code> and <code>text-align</code> get ignored&#13;
(since they do not apply to inline elements). For the third <code>&lt;div&gt;</code>,&#13;
however, the inline-block paragraph honors both properties, since it is&#13;
formatted as a block-level element. That paragraph’s margins also force&#13;
its line of text to be much taller, since it affects line height as&#13;
though it were a replaced &#13;
<span class="keep-together">element.</span></p>&#13;
&#13;
<p>If an inline-block element’s <code>width</code> is not defined or explicitly&#13;
declared <code>auto</code>, the element box will shrink to fit the content. The element box is exactly as wide as necessary to hold the content,&#13;
and no wider. Inline boxes act the same way, although they can break&#13;
across lines of text, whereas inline-block elements cannot. Thus, we have the&#13;
following rule, when applied to the previous markup example:<a data-primary="" data-startref="ix_inline_format_inblock" data-type="indexterm" id="idm45176104206768"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nf">#three</code> <code class="nt">p</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">inline-block</code><code class="p">;</code> <code class="nb">block</code><code class="o">-</code><code class="k">size</code><code class="o">:</code> <code class="m">4em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will create a tall box that’s just wide enough to enclose the&#13;
content, as shown in <a data-type="xref" href="#bvf_fig57">Figure 6-63</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="bvf_fig57">&#13;
<img alt="css5 0663" src="assets/css5_0663.png"/>&#13;
<h6><span class="label">Figure 6-63. </span>Autosizing of an inline-block element</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flow Display" data-type="sect2"><div class="sect2" id="flow-display">&#13;
<h2>Flow Display</h2>&#13;
&#13;
<p>The <code>display</code> values <code>flow</code> and <code>flow-root</code> deserve a moment of explanation.  <a data-primary="display property" data-secondary="flow display" data-type="indexterm" id="idm45176104189136"/><a data-primary="display roles" data-secondary="flow and flow-root display" data-type="indexterm" id="idm45176104161872"/><a data-primary="flow display" data-type="indexterm" id="idm45176104161024"/><a data-primary="flow-root display" data-type="indexterm" id="idm45176104160416"/><a data-primary="inline formatting" data-secondary="flow display" data-type="indexterm" id="idm45176104159744"/>Declaring an element to be laid out using <code>display: flow</code> means that it should use block-and-inline layout, the same as normal—that is, unless it’s combined with <code>inline</code>, in which case it generates an inline box.</p>&#13;
&#13;
<p>In other words, the first two of the following rules will result in a block box, whereas the third will yield an inline box:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#first</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flow</code><code class="p">;}</code>&#13;
<code class="nf">#second</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">block</code> <code class="nb">flow</code><code class="p">;}</code>&#13;
<code class="nf">#third</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">inline</code> <code class="nb">flow</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The <a data-primary="display roles" data-secondary="inner and outer display types for" data-type="indexterm" id="idm45176104130480"/><a data-primary="inner display type" data-type="indexterm" id="idm45176104129632"/><a data-primary="outer display type" data-type="indexterm" id="idm45176104128992"/>reason for this pattern is that CSS is (very) slowly moving to a system that supports two kinds of display: the <em>outer display type</em> and the <em>inner display type</em>.  Value keywords like <code>block</code> and <code>inline</code> represent the outer display type, which determines how the display box interacts with its surroundings.  The inner display (in this case, <code>flow</code>), describes what should happen inside the element.</p>&#13;
&#13;
<p>This approach allows for declarations like <code>display: inline block</code> to indicate that an element should generate a block-formatting context within, but relate to its surrounding content as an inline element.  (The new two-term <code>display</code> value has the same effect as the fully supported  <code>inline-block</code> value.)</p>&#13;
&#13;
<p>Using <code>display: flow-root</code>, on the other hand, always generates a block box, with a new block formatting context inside itself.  This is the sort of thing that would be applied to the root element of a document, like <code>&lt;html&gt;</code>, to say, “This is where the formatting root lies.”</p>&#13;
&#13;
<p>The old <code>display</code> values you may be familiar with are still available.  <a data-type="xref" href="#display_values_reference">Table 6-1</a> shows how the old values will be represented using the new values.</p>&#13;
<table class="less_space pagebreak-before" id="display_values_reference">&#13;
<caption><span class="label">Table 6-1. </span>Equivalent <code>display</code> values</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Old values</th>&#13;
<th>New values</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>block</code></p></td>&#13;
<td><p><code>block flow</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>inline</code></p></td>&#13;
<td><p><code>inline flow</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>inline-block</code></p></td>&#13;
<td><p><code>inline flow-root</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>list-item</code></p></td>&#13;
<td><p><code>list-item block flow</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>inline-list-item</code></p></td>&#13;
<td><p><code>list-item inline flow</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>table</code></p></td>&#13;
<td><p><code>block table</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>inline-table</code></p></td>&#13;
<td><p><code>inline table</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>flex</code></p></td>&#13;
<td><p><code>block flex</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>inline-flex</code></p></td>&#13;
<td><p><code>inline flex</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>grid</code></p></td>&#13;
<td><p><code>block grid</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>inline-grid</code></p></td>&#13;
<td><p><code>inline grid</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Content Display" data-type="sect2"><div class="sect2" id="contents-display">&#13;
<h2>Content Display</h2>&#13;
&#13;
<p>A <a data-primary="display roles" data-secondary="contents display" data-type="indexterm" id="idm45176104076240"/><a data-primary="inline formatting" data-secondary="content display" data-type="indexterm" id="idm45176104075232"/>fascinating new addition to <code>display</code> is the value <code>contents</code>.  When applied to an element, <code>display: contents</code> causes the element to be removed from page formatting, and effectively “elevates” its child elements to its level.  As an example, consider the following basic CSS and HTML:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ul</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">li</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>The<code class="w"> </code>first<code class="w"> </code>list<code class="w"> </code>item.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>List<code class="w"> </code>Item<code class="w"> </code>II:<code class="w"> </code>The<code class="w"> </code>Listening.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>the<code class="w"> </code>third.<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/ul&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This yields an unordered list with a red border, and three list items with silver borders.</p>&#13;
&#13;
<p>If we then apply <code>display: contents</code> to the <code>&lt;ul&gt;</code> element, the user agent will render the list as if the <code>&lt;ul&gt;</code> and <code>&lt;/ul&gt;</code> lines had been deleted from the document source. <a data-type="xref" href="#bvf_css4_display_contents">Figure 6-64</a> shows the difference between the regular result and the <code>contents</code> result.</p>&#13;
&#13;
<figure><div class="figure" id="bvf_css4_display_contents">&#13;
<img alt="css5 0664" src="assets/css5_0664.png"/>&#13;
<h6><span class="label">Figure 6-64. </span>A regular unordered list, and one with <code>display: contents</code></h6>&#13;
</div></figure>&#13;
&#13;
<p class="less_space pagebreak-before">The list items are still list items, and act like them, but visually, the <code>&lt;ul&gt;</code> is gone, as if it had never been.  Not only does the list’s border go away, but also the top and bottom margins that usually separate the list from surrounding content.  This is why the second list in <a data-type="xref" href="#bvf_css4_display_contents">Figure 6-64</a> appears higher up than the first.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Display Values" data-type="sect2"><div class="sect2" id="other-display-values">&#13;
<h2>Other Display Values</h2>&#13;
&#13;
<p>We haven’t covered a great many more display values in this chapter, and won’t.  The various table-related values will come up in <a data-type="xref" href="ch13.html#title-table-layout-in-css">Chapter 13</a>, and we’ll talk about list items again in <a data-type="xref" href="ch16.html#lists-and-generated-content">Chapter 16</a>.</p>&#13;
&#13;
<p>The values we won’t really talk about are the Ruby-related values, which need their own book and are poorly supported as of late 2022.<a data-primary="" data-startref="ix_inline_format_ch6" data-type="indexterm" id="idm45176103971248"/><a data-primary="" data-startref="ix_vis_format_inline" data-type="indexterm" id="idm45176103970272"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Element Visibility" data-type="sect1"><div class="sect1" id="element-visibility">&#13;
<h1>Element Visibility</h1>&#13;
&#13;
<p>In <a data-primary="visual formatting" data-secondary="visibility of elements" data-type="indexterm" id="ix_vis_format_elem_vis"/><a data-primary="elements" data-secondary="visibility" data-type="indexterm" id="ix_elements_vis"/>addition to everything we’ve discussed in the chapter, you can also control&#13;
the visibility of an <a data-primary="visibility property" data-secondary="elements" data-type="indexterm" id="idm45176103964896"/>entire element.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176103963696">&#13;
<h1>visibility</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>visible</code> | <code>hidden</code> | <code>collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>visible</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>A visibility</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>No, really, that’s what the specification says: “A visibility”</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>If an <a data-primary="visible keyword" data-type="indexterm" id="idm45176103948000"/><a data-primary="hidden keyword" data-type="indexterm" id="idm45176103947296"/>element is set to have&#13;
<code>visibility: visible</code>, it is, as you might expect, visible. If an element is set to <code>visibility: hidden</code>, it is made “invisible” (to&#13;
use the wording in the specification). In its invisible state, the&#13;
element still affects the document’s layout as though it were <code>visible</code>.&#13;
In other words, the element is still there—you just can’t see it.</p>&#13;
&#13;
<p>Note the difference between this and <code>display: none</code>. In the latter&#13;
case, the element is not displayed <em>and</em> is removed from the document&#13;
altogether so that it doesn’t have any effect on document layout.&#13;
<a data-type="xref" href="#making_elements_invisible">Figure 6-65</a> shows a document in which an inline element inside a paragraph has been set to <code>hidden</code>,&#13;
based on the following styles and markup:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">em</code><code class="nc">.trans</code> <code class="p">{</code><code class="k">visibility</code><code class="o">:</code> <code class="nb">hidden</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code>&#13;
    <code class="k">margin</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
    This is a paragraph that should be visible. Nulla berea consuetudium ohio&#13;
    city, mutationem dolore. <code class="p">&lt;</code><code class="nt">em</code> <code class="na">class</code><code class="o">=</code><code class="s">"trans"</code><code class="p">&gt;</code>Humanitatis molly shannon&#13;
    ut lorem.<code class="p">&lt;/</code><code class="nt">em</code><code class="p">&gt;</code> Doug dieken dolor possim south euclid.&#13;
<code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="making_elements_invisible">&#13;
<img alt="css5 0665" src="assets/css5_0665.png"/>&#13;
<h6><span class="label">Figure 6-65. </span>Making elements invisible without suppressing their element boxes</h6>&#13;
</div></figure>&#13;
&#13;
<p>Everything visible about a hidden element—such as content, background,&#13;
and borders—is made invisible. The space is still there because the&#13;
element is still part of the document’s layout. We just can’t see it.</p>&#13;
&#13;
<p>We can set the descendant element of a <code>hidden</code> element to be&#13;
<code>visible</code>. This causes the element to appear wherever it normally would,&#13;
even though the ancestor is invisible. To do so, we&#13;
explicitly declare the descendant element <code>visible</code>, since <code>visibility</code>&#13;
is &#13;
<span class="keep-together">inherited:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.clear</code> <code class="p">{</code><code class="k">visibility</code><code class="o">:</code> <code class="nb">hidden</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.clear</code> <code class="nt">em</code> <code class="p">{</code><code class="k">visibility</code><code class="o">:</code> <code class="nb">visible</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As for <code>visibility: collapse</code>, this value is used in CSS table rendering and flexible box layout, where it has an effect very similar to <code>display: none</code>.  The difference is that in table rendering, a row or column that’s been set to <code>visibility: hidden</code> is hidden and the space it would have occupied is removed, but any cells in the hidden row or column are used to determine the layout of intersecting columns or rows.  This allows you to quickly hide or show rows and columns without forcing the browser to recalculate the layout of the whole table.</p>&#13;
&#13;
<p>If <code>collapse</code> is applied to an element that isn’t a flex item or part of a table, it has the same meaning as <code>hidden</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Animating Visibility" data-type="sect2"><div class="sect2" id="animating_visibility">&#13;
<h2>Animating Visibility</h2>&#13;
&#13;
<p>If you <a data-primary="animation" data-secondary="of visibility" data-secondary-sortas="visibility" data-type="indexterm" id="idm45176103820864"/>want to animate a change from visible visibility to one of the other values of &#13;
<span class="keep-together"><code>visibility</code>,</span> that is possible.  The catch is that you won’t see a slow fade from one to the other.  Instead, the browser calculates where in the animation a change from <code>0</code> to <code>1</code> (or vice versa) would reach the end value, and instantly changes the value of <code>visibility</code> at that point.  Thus, if an element is set to <code>visibility: hidden</code> and then animated to <code>&#13;
<span class="keep-together">visibility:</span> visible</code>, the element will be completely invisible until the end point is reached, at which time it will become instantly visible.  (See Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch18.html#x-transitions">18</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch19.html#animation">19</a> for more information on animating CSS properties.)</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you want to fade from being invisible to visible, don’t animate <code>visibility</code>.  Animate <code>opacity</code> instead.<a data-primary="" data-startref="ix_elements_vis" data-type="indexterm" id="idm45176103811120"/><a data-primary="" data-startref="ix_vis_format_elem_vis" data-type="indexterm" id="idm45176103810112"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="bvf_summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Although some aspects of the CSS formatting model may seem&#13;
counterintuitive at first, they begin to make sense the more you work&#13;
with them. In many cases, rules that seem nonsensical or even idiotic&#13;
turn out to exist in order to prevent bizarre or otherwise undesirable&#13;
document displays. Block-level elements are in many ways easy to&#13;
understand, and affecting their layout is typically a simple task.<a data-primary="" data-startref="ix_vis_format_ch6" data-type="indexterm" id="idm45176103807344"/>&#13;
Inline elements, on the other hand, can be trickier to manage, as multiple factors come into play, not the least of which is whether the&#13;
element is replaced or nonreplaced.</p>&#13;
</div></section>&#13;
</div></section></body></html>