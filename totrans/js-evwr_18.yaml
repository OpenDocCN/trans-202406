- en: Chapter 17\. Deploying a Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first began doing web development professionally, a “deployment” meant
    uploading files from my local machine to a web server through an FTP client. There
    weren’t any build steps or pipelines, meaning that the raw files on my machine
    were the same as those on my web server. If something went wrong, I would either
    frantically try to fix the issue or roll back the change by replacing it with
    copies of the old files. This wild west approach worked OK at the time, but also
    led to a lot of site downtime and unexpected issues.
  prefs: []
  type: TYPE_NORMAL
- en: In today’s world of web development, the needs of our local development environment
    and our web servers are quite different. On my local machine, I want to see instant
    changes when I update a file and have uncompressed files for debugging. On my
    web server, I only expect to see changes when I deploy them and value small file
    sizes. In this chapter, we’ll look at one way that we can deploy a static application
    to the web.
  prefs: []
  type: TYPE_NORMAL
- en: Static Websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web browser parses HTML, CSS, and JavaScript to generate the web pages that
    we interact with. Unlike frameworks such as Express, Rails, and Django, which
    generate the markup for a page server-side at the time of the request, static
    websites are simply a collection of HTML, CSS, and JavaScript stored on a server.
    This can range in complexity from a single HTML file containing markup to complicated
    frontend build processes that compile templating languages, multiple JavaScript
    files, and CSS pre-processors. In the end, however, static websites are a collection
    of those three file types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application, Notedly, is a static web app. It contains some markup, CSS,
    and JavaScript. Our build tool, [Parcel](https://parceljs.org), compiles the components
    that we write into files usable by the browser. In local development, we run a
    web server and these files are updated on the fly using Parcel’s hot module replacement
    feature. If we look at our *package.json* file, you’ll see that I’ve included
    two `deploy` scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the application, open your terminal application, **`cd`** into the
    root of your *web* directory, which contains the project, and then run the **`build`**
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve been following along with the book and developing your web application
    in the *src* directory, running `npm run deploy:src` in the terminal, as just
    described, will generate the built application from your code. If you would prefer
    to use the final version of the application that is bundled with the sample code,
    using `npm run deploy:final` will build the code from the *final* application
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the chapter, I’ll demonstrate one way to deploy a statically
    built application, but these files could be hosted anywhere that can serve HTML—from
    a web hosting provider to a Raspberry Pi left running on your desk. While there
    are many tangible benefits to the type of process we’ll be working through, your
    deploy could be as simple as updating the *.env* file to point to the remote API,
    running the build script, and uploading the files.
  prefs: []
  type: TYPE_NORMAL
- en: Server-Side Rendered React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though we’re building our React application as a static web application, it
    is also possible to render JSX on the server. This technique is often referred
    to as “universal JavaScript” and can have many benefits, including performance
    gains, client-side JavaScript fallbacks, and SEO improvements. Frameworks such
    as [Next.js](https://nextjs.org) have sought to simplify this setup. Though we’re
    not covering server-side rendered JavaScript applications in this book, I highly
    recommend exploring this approach once you’re comfortable with client-side JavaScript
    application development.
  prefs: []
  type: TYPE_NORMAL
- en: Our Deployment Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our application’s deployment, we’ll make use of a simple pipeline, which
    will allow us to automatically deploy changes to our codebase. For our pipeline
    we’ll be using two services. The first will be our source code repository, [GitHub](https://github.com).
    The second will be our web host, [Netlify](https://www.netlify.com). I’ve chosen
    Netlify for its extensive, but easy-to-use, feature set for deployments as well
    as its focus on static and serverless applications.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is for any commit to the `master` branch of our application to be automatically
    deployed to our web host. We could visualize that process as shown in [Figure 17-1](#web_deploy).
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of our deployment process. Each commit is pushed to GitHub, then
    built by Netlify, and finally pushed to a public web server.](assets/jsev_1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. Our deployment process
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Hosting Source Code with Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in our deployment process is to set up our source code repository.
    You may have already done this, in which case feel free to skip ahead. As noted
    before we’ll be using [GitHub](https://github.com), but this process could be
    configured with other public Git hosts, such as [GitLab](https://about.gitlab.com)
    or [Bitbucket](https://bitbucket.org).
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll be creating a new GitHub repository, but if you prefer, you can use the
    official code sample at [*https://github.com/javascript​everywhere/web*](https://oreil.ly/MLMS7)
    by creating a fork to your GitHub account.
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate to GitHub and create an account or sign in to your existing
    account. Then click the New Repository button. Provide a name and click the Create
    Repository button ([Figure 17-2](#new_repo)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of GitHub''s new repository page](assets/jsev_1702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-2\. GitHub’s new repository page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, in your terminal application, navigate to your web application’s directory,
    set the Git origin to the new GitHub repository, and push the code. Because we
    are updating an existing Git repo, our instructions will differ slightly from
    GitHub’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you navigate to *https://github.com/<your_username>/<your_repo_name>*,
    you will see the source code of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy with Netlify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our source code in a remote Git repository, we can now configure our web
    host, Netlify, to build and deploy our code. First, go to [*netlify.com*](https://www.netlify.com)
    and register for an account. Once you’ve created an account, click the “New site
    from Git” button. This will walk you through setting up your site deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose your Git provider by selecting GitHub, which will connect and authorize
    your GitHub account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the repository that contains the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, set up your build settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our build settings, add the following ([Figure 17-3](#web-netlify-deploy)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build command: `npm run deploy:src` (or `npm run deploy:final`, if deploying
    the final example code).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Publish directory: `dist`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under “Advanced settings,” click “New variable” and add a variable name of `API_URI`
    with a variable value of *https://<your_api_name>.herokuapp.com/api* (this will
    be the URL of the API application, which we deployed to Heroku).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’ve configured the application, click the “Deploy site” button. After
    a few minutes your application will be running at the Netlify-supplied URL. Now,
    anytime we push a change to our GitHub repo, our site will be automatically deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Slow Initial Load
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our deployed web application will be loading data from our deployed Heroku API.
    With Heroku’s free plan, application containers sleep after one hour of inactivity.
    If you haven’t used your API in a while, the initial data load will be slow while
    the container spins back up.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Netlify deployment configuration](assets/jsev_1703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-3\. With Netlify we can configure our build process and environment
    variables
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we’ve deployed a static web application. To do this, we’ve used
    Netlify’s deployment pipeline features to watch for changes to our Git repository,
    run our build processes, and store environment variables. With this foundation,
    we have everything we need to publicly release web applications.
  prefs: []
  type: TYPE_NORMAL
