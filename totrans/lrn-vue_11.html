<html><head></head><body><section data-pdf-bookmark="Chapter 11. Testing in Vue" data-type="chapter" epub:type="chapter"><div class="chapter" id="unique_chapter_id_10">&#13;
<h1><span class="label">Chapter 11. </span>Testing in Vue</h1>&#13;
&#13;
&#13;
<p>To this point, we have learned about developing a complete Vue application from scratch with different Vue APIs. Our application is now ready for deployment, but before we do that, we need to make sure that our application is bug-free and ready for production. This is where testing comes in.</p>&#13;
&#13;
<p>Testing is crucial to any application development, as it helps to increase code confidence and quality before releasing it to production. In this chapter, we will learn about the different types of testing and how to use them in Vue applications. We will also explore the various tools, such as Vitest and Vue Test Utils, for unit testing and PlaywrightJS for end-to-end (E2E) testing.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introduction to Unit Testing and E2E Testing" data-type="sect1"><div class="sect1" id="id118">&#13;
<h1>Introduction to Unit Testing and E2E Testing</h1>&#13;
&#13;
<p>Software development has both manual and automated testing practices and techniques to ensure your application works as expected. While manual testing requires a tester to interact with the software manually and can be expensive, automated testing is mainly about executing a predefined test script containing a set of tests in an automated manner. The collection of automated tests can validate simple to more complex application scenarios, from a single function to a combination of different parts<a data-primary="testing" data-secondary="importance of" data-type="indexterm" id="id1543"/><a data-primary="testing" data-secondary="manual" data-type="indexterm" id="id1544"/><a data-primary="unit testing" data-type="indexterm" id="id1545"/><a data-primary="testing" data-seealso="E2E (end-to-end) testing; unit testing; Vue Test Utils" data-type="indexterm" id="id1546"/>.</p>&#13;
&#13;
<p>Automated testing is more reliable and scalable than manual testing, assuming we write the tests correctly, and performs the following testing processes:</p>&#13;
<dl class="pagebreak-before">&#13;
<dt>Unit testing</dt>&#13;
<dd>&#13;
<p>The most common and lowest level of testing in software development. We use unit testing to validate a unit of code (or code block) that performs a specific action, such as functions, hooks, and modules. We can combine unit testing with test-driven development (TDD)<sup><a data-type="noteref" href="ch11.html#id1547" id="id1547-marker">1</a></sup> as a standard development practice<a data-primary="test-driven development (TDD)" data-type="indexterm" id="id1548"/><a data-primary="testing" data-secondary="resources on" data-type="indexterm" id="id1549"/>.</p>&#13;
</dd>&#13;
<dt>Integrating testing</dt>&#13;
<dd>&#13;
<p>This testing type validates the integration of different unit blocks of code. Integrating testing aims to assert the flow of logic functions, components, or modules. Component testing integrates testing with its internal logic as a unit test. We also mock most upstream services and other functions outside the test scope to ensure testing quality<a data-primary="testing" data-secondary="integrating testing" data-type="indexterm" id="id1550"/><a data-primary="integration testing" data-type="indexterm" id="id1551"/>.</p>&#13;
</dd>&#13;
<dt>End-to-end (E2E) testing</dt>&#13;
<dd>&#13;
<p>The highest level of testing in software development. We use E2E testing to validate the entire application flow from the client side to the backend, usually by simulating actual user behaviors. There would not be any mocked services or functions in E2E testing, as we want to test the entire application flow<a data-primary="E2E (end-to-end) testing" data-type="indexterm" id="id1552"/>.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Test-driven development (TDD) means you design and write the test cases first (red phase), work on the code to pass the tests (green phase), and improve the code implementation (refactor phase). It helps to verify the logic and design before actual development.</p>&#13;
</div>&#13;
&#13;
<p>These three testing types form a pyramid of testing, as shown in <a data-type="xref" href="#figure_ch10_01">Figure 11-1</a>, where the focus should be mainly on the unit tests, then integration testing, leaving the smallest number to E2E testing as it is primarily for sanity and can be expensive to trigger. Since we create an application from any components, services, and modules, performing unit testing for each isolated function or feature can be sufficient for keeping your codebase’s quality at the minimum cost and effort<a data-primary="testing" data-secondary="pyramid" data-type="indexterm" id="id1553"/>.</p>&#13;
&#13;
<p>And as the primary ground for the testing system in our application, we start with unit tests using Vitest.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_01">&#13;
<img alt="A screenshot showing a pyramid, divided into three levels representing unit testing, integration testing, and E2E testing" src="assets/lvue_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>Pyramid of testing</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Vitest as a Unit Testing Tool" data-type="sect1"><div class="sect1" id="vitest_chap10">&#13;
<h1>Vitest as a Unit Testing Tool</h1>&#13;
&#13;
<p><a href="https://oreil.ly/1upy0">Vitest</a> is the test runner for unit testing built on Vite for Vite-powered projects. Its API is similar to Jest and Chai while offering a more modular approach to testing. Focusing on speed and developer experience, Vitest offers several significant features, including multithreading workers, TypeScript and JSX support, and component testing for frameworks such as Vue and React<a data-primary="testing" data-secondary="with Vitest" data-secondary-sortas="Vitest" data-type="indexterm" id="ix-test-unit1"/><a data-primary="unit testing" data-secondary="with Vitest" data-secondary-sortas="Vitest" data-type="indexterm" id="ix-test-unit1a"/><a data-primary="Vitest" data-secondary="using" data-type="indexterm" id="ix-test-unit1b"/>.</p>&#13;
&#13;
<p>To use Vitest, we need to install it as a dev dependency in our project<a data-primary="installing" data-secondary="Vitest" data-type="indexterm" id="id1554"/><a data-primary="Vitest" data-secondary="installing" data-type="indexterm" id="id1555"/>:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">yarn<code class="w"> </code>add<code class="w"> </code>-D<code class="w"> </code>vitest<code class="w"/></pre>&#13;
&#13;
<p>Then in the <code>package.json</code> file, we can add a new script command to run our tests in the watch mode:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="nt">"script"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"test"</code><code class="p">:</code><code class="w"> </code><code class="s2">"vitest"</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Alternatively, during the Vue project initialization, we can choose to install Vitest as a unit testing tool (<a data-type="xref" href="ch01.html#chapter_01_newVueApp">“Create a New Vue Application”</a>), and Vite will take care of the rest, including some sample tests as the starter.</p>&#13;
</div>&#13;
&#13;
<p>Once we run the command <code>yarn test</code> in the terminal (or command line), Vitest will automatically detect the test files whose name contains the pattern <code>.spec.</code> or <code>.test.</code> in the project directory. For example, a test file for the <code>useFetch</code> hook will be either <code>useFetch.spec.ts</code> or <code>useFetch.test.ts</code>.&#13;
Whenever you change any test file, Vitest will rerun the test in your local environment.</p>&#13;
<div data-type="tip"><h1>Using vitest with Extra Commands</h1>&#13;
<p>You can specify the mode for the <code>vitest</code> command, such as <code>vitest watch</code> for watch mode explicitly or <code>vitest run</code> for a one-time run on all the tests. Vite will automatically switch to the single run mode when using the <code>vitest</code> command alone in a continuous integration (CI) environment<a data-primary="vitest command" data-type="indexterm" id="id1556"/><a data-primary="watch mode, Vitest" data-type="indexterm" id="id1557"/><a data-primary="Vitest" data-secondary="watch mode" data-type="indexterm" id="id1558"/><a data-primary="testing" data-secondary="CI/CD and" data-type="indexterm" id="id1559"/><a data-primary="Continuous Integration/Continuous Deployment (CI/CD)" data-secondary="testing" data-type="indexterm" id="id1560"/><a data-primary="Vitest" data-secondary="continuous integration (CI) and" data-type="indexterm" id="id1561"/>.</p>&#13;
</div>&#13;
&#13;
<p>We can further customize the settings for Vitest using the command parameters or the Vite config file <code>vite.config.js</code> in the next section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuring Vitest Using Parameters and Config File" data-type="sect1"><div class="sect1" id="id120">&#13;
<h1>Configuring Vitest Using Parameters and Config File</h1>&#13;
&#13;
<p>By default, Vitest will scan for tests starting from the project folder as its current directory. We can specify a target folder for Vitest to check by passing the folder path as an argument to the test command, such as the <code>tests</code> folder within the source <code>src</code> directory<a data-primary="unit testing" data-secondary="specifying target folder" data-type="indexterm" id="id1562"/><a data-primary="Vitest" data-secondary="specifying target folder" data-type="indexterm" id="id1563"/><a data-primary="configuring" data-secondary="Vitest" data-type="indexterm" id="ix-test-unit2"/><a data-primary="Vitest" data-secondary="configuring" data-type="indexterm" id="ix-test-unit2a"/>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="nt">"script"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"test"</code><code class="p">:</code><code class="w"> </code><code class="s2">"vitest --root src/tests"</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In this chapter, we will put our tests under the <code>tests</code> folder, with the test file name convention <code>&lt;test-file-name.test&gt;.ts</code> (such as <code>myComponent.test.ts</code>)<a data-primary="testing" data-secondary="files and directories for" data-type="indexterm" id="id1564"/><a data-primary="tests folder" data-type="indexterm" id="id1565"/>.</p>&#13;
</div>&#13;
&#13;
<p>We can also specify the test files to run by passing the file path as an argument to the <code>yarn test</code> command:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">yarn<code class="w"> </code><code class="nb">test</code><code class="w"> </code>src/tests/useFetch.test.ts<code class="w"/></pre>&#13;
&#13;
<p>This command is handy when working on a file and wanting to enable the watch mode for that test file exclusively.</p>&#13;
&#13;
<p>We also need to set the <code>environment</code> parameter to <code>jsdom</code> (JSDOM<sup><a data-type="noteref" href="ch11.html#id1566" id="id1566-marker">2</a></sup>) as the DOM environment runner for our Vue project<a data-primary="environment parameter, Vitest" data-type="indexterm" id="id1567"/><a data-primary="JSDOM" data-type="indexterm" id="id1568"/>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="nt">"script"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"test"</code><code class="p">:</code><code class="w"> </code><code class="s2">"vitest --root src/tests --environment jsdom"</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Without setting the environment, Vitest will use the default environment <code>node</code>, which is unsuitable for testing UI components and interactions.</p>&#13;
&#13;
<p>Instead of using the command parameters, we can also modify the <code>vite.config.js</code> file to configure our Vitest runner, using the field <code>test</code> with the relevant properties <code>root</code> and <code>environment</code><a data-primary="test field, configuring Vitest runner" data-type="indexterm" id="id1569"/>:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="nx">defineConfig</code><code class="p">({</code>&#13;
  <code class="cm">/**other settings */</code>&#13;
  <code class="nx">test</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">environment</code><code class="o">:</code> <code class="s1">'jsdom'</code><code class="p">,</code>&#13;
    <code class="nx">root</code><code class="o">:</code> <code class="err">'</code><code class="nx">src</code><code class="o">/</code><code class="nx">tests</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>You also need to add the reference to Vitest using the <code>&lt;reference&gt;</code> tag within this file by adding the following line to the top of the <code>vite.config.ts</code> file<a data-primary="reference tag, configuring Vitest" data-type="indexterm" id="id1570"/>:</p>&#13;
&#13;
<pre data-type="programlisting">/// &lt;reference types="vitest" /&gt;</pre>&#13;
&#13;
<p>As a result, Vite will know that we are using Vitest as the test runner and will provide the relevant type definitions for the <code>test</code> field in the config file for TypeScript type checking<a data-primary="type checking" data-secondary="testing with Vitest" data-type="indexterm" id="id1571"/><a data-primary="configuring" data-secondary="TypeScript" data-type="indexterm" id="id1572"/><a data-primary="TypeScript" data-secondary="configuration options" data-type="indexterm" id="id1573"/>.</p>&#13;
&#13;
<p>We also can turn on the global mode for the Vitest APIs across the entire project, so we don’t need to import any function explicitly from the <code>vitest</code> package into our test files. We can do this by enabling the <code>globals</code> flag of the <code>test</code> object in the &#13;
<span class="keep-together"><code>vite.config.ts</code></span><a data-primary="globals flag, Vitest" data-type="indexterm" id="id1574"/><a data-primary="Vitest" data-secondary="global mode" data-type="indexterm" id="id1575"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">/// &lt;reference types="vitest" /&gt;</code>&#13;
<code class="cm">/*...imports...*/</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">defineConfig</code><code class="p">({</code>&#13;
  <code class="cm">/**other settings */</code>&#13;
  <code class="nx">test</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">environment</code><code class="o">:</code> <code class="s1">'jsdom'</code><code class="p">,</code>&#13;
    <code class="nx">root</code><code class="o">:</code> <code class="err">'</code><code class="nx">src</code><code class="o">/</code><code class="nx">tests</code>&#13;
    <code class="nx">globals</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>Once <code>globals</code> is enabled, for TypeScript to be able to detect the availability of Vitest APIs as global, we still have one more step to perform: adding <code>vitest/globals</code> type definitions to the <code>types</code> array in the <code>tsconfig.json</code> file<a data-primary="tsconfig.json file" data-type="indexterm" id="id1576"/>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="c1">//tsconfig.json</code><code class="w"/>&#13;
<code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"types"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"vitest/globals"</code><code class="p">]</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>With these settings, we are now ready to start writing our tests<a data-primary="" data-startref="ix-test-unit2" data-type="indexterm" id="id1577"/><a data-primary="" data-startref="ix-test-unit2a" data-type="indexterm" id="id1578"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing Your First Test" data-type="sect1"><div class="sect1" id="id121">&#13;
<h1>Writing Your First Test</h1>&#13;
&#13;
<p>Following the TDD approach, let’s start with a simple test to check if a function to filter an array based on a given string and an array element’s property key is working as expected<a data-primary="unit testing" data-secondary="writing tests" data-type="indexterm" id="ix-test-unit3"/><a data-primary="Vitest" data-secondary="writing tests" data-type="indexterm" id="ix-test-unit3a"/><a data-primary="test-driven development (TDD)" data-type="indexterm" id="id1579"/>.</p>&#13;
&#13;
<p>We will create a new file, <code>filterArray.test.ts</code>, in the <code>src/tests</code> folder and another one, <code>filterArray.ts</code> in the <code>src/utils</code> folder. The <code>filterArray.ts</code> should export a function <code>filterArray</code>, which takes three arguments (the original array to filter of type <code>ArrayObject</code>, a <code>string</code> property key, and the <code>string</code> term to filter with) and returns the filtered elements of type <code>ArrayObject</code><a data-primary="string property key, unit testing with Vitest" data-type="indexterm" id="id1580"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">type</code> <code class="nx">ArrayObject</code> <code class="o">=</code> <code class="p">{</code> <code class="p">[</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">};</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">filterArray</code><code class="p">(</code>&#13;
  <code class="nx">array</code><code class="o">:</code> <code class="nx">ArrayObject</code><code class="p">[],</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">term</code><code class="o">:</code> <code class="kt">string</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">ArrayObject</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="c1">// code to filter the array</code>&#13;
  <code class="k">return</code> <code class="p">[];</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>{ [key: string]: string }</code> is a type for an object with a <code>string</code> key and a <code>string</code> value. Specify using type instead of the generic <code>Object</code> (similar to using <code>any</code>) to avoid the potential bug of passing the wrong object type to the function<a data-primary="types" data-secondary="specifying in unit testing with Vitest" data-type="indexterm" id="id1581"/>.</p>&#13;
</div>&#13;
&#13;
<p>In the <code>filterArray.test.ts</code> file, we will import the <code>filterArray</code> function and model its functionality. We will use the <code>it()</code> method and <code>expect()</code> from the <code>@vitest</code> package to define a single test case, and to assert the expected result, respectively<a data-primary="it(), unit testing with Vitest" data-type="indexterm" id="ix-test-unit3b"/><a data-primary="expect(), unit testing with Vitest" data-type="indexterm" id="ix-test-unit3c"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">it</code><code class="p">,</code> <code class="nx">expect</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@vitest'</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">filterArray</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'../utils/filterArray'</code>&#13;
&#13;
<code class="nx">it</code><code class="p">(</code><code class="s1">'should return a filtered array'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">expect</code><code class="p">()</code>&#13;
<code class="p">})</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We can remove the <code>import { it, expect } from <em>@vitest</em></code> line if we have <code>globals</code> set to <code>true</code> in the <code>vite.config.ts</code> file or the command line with the <code>--globals</code> parameter<a data-primary="globals flag, Vitest" data-type="indexterm" id="id1582"/><a data-primary="--globals parameter, Vitest" data-primary-sortas="globals parameter" data-type="indexterm" id="id1583"/><a data-primary="Vitest" data-secondary="global mode" data-type="indexterm" id="id1584"/>.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">The <code>it()</code> method takes a string representing the test case’s name (<code>should return a filtered array</code>), a function containing the test logic to run, and an optional timeout for waiting for the test to complete. By default, we have five seconds for the test’s timeout<a data-primary="timeouts" data-secondary="unit testing with Vitest" data-type="indexterm" id="id1585"/>.</p>&#13;
&#13;
<p>We can now implement the test logic for our first test case. We also assume that we have a list of pizzas that we need to filter by <code>title</code> containing <code>Hawaiian</code><a data-primary="not modifier, expect()" data-type="indexterm" id="id1586"/><a data-primary="rejects modifier, expect()" data-type="indexterm" id="id1587"/><a data-primary="resolves modifier, expect()" data-type="indexterm" id="id1588"/><a data-primary="toBe matcher, expect()" data-type="indexterm" id="id1589"/><a data-primary="toEqual matcher, expect()" data-type="indexterm" id="id1590"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">it</code><code class="p">,</code> <code class="nx">expect</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@vitest'</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">filterArray</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'../utils/filterArray'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">pizzas</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"1"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Pina Colada Pizza"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="s2">"10.00"</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code>&#13;
      <code class="s2">"A delicious combination of pineapple, coconut, and coconut milk."</code><code class="p">,</code>&#13;
    <code class="nx">quantity</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"4"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Hawaiian Pizza"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="s2">"11.00"</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code>&#13;
      <code class="s2">"A delicious combination of ham, pineapple, and pineapple."</code><code class="p">,</code>&#13;
    <code class="nx">quantity</code><code class="o">:</code> <code class="mi">5</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"5"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Meat Lovers Pizza"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="s2">"13.00"</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code>&#13;
      <code class="s2">"A delicious combination of pepperoni, sausage, and bacon."</code><code class="p">,</code>&#13;
    <code class="nx">quantity</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">]</code>&#13;
&#13;
<code class="nx">it</code><code class="p">(</code><code class="s1">'should return a filtered array'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">filterArray</code><code class="p">(</code><code class="nx">pizzas</code><code class="p">,</code> <code class="s1">'title'</code><code class="p">,</code> <code class="s1">'Hawaiian'</code><code class="p">))</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p><code>expect()</code> returns a test instance that has various modifiers such as <code>not</code>, <code>resolves</code>, <code>rejects</code>, and matcher functions like <code>toEqual</code> and <code>toBe</code>. While <code>toEqual</code> performs a deep comparison for equality on the target object, <code>toBe</code> performs an additional check to the target value’s instance reference in the memory. In most scenarios, using &#13;
<span class="keep-together"><code>toEqual</code></span> is good enough for validating our logic, such as checking the returned value to match our desired array. We will define our target <code>result</code> array as follows:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="ts" data-type="programlisting"><code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"4"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Hawaiian Pizza"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="s2">"11.00"</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code>&#13;
      <code class="s2">"A delicious combination of ham, pineapple, and pineapple."</code><code class="p">,</code>&#13;
    <code class="nx">quantity</code><code class="o">:</code> <code class="mi">5</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>Let’s modify our <code>pizzas</code> to ensure it contains elements of <code>result</code> before passing it to the <code>filterArray</code> function:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">const</code> <code class="nx">pizzas</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"1"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Pina Colada Pizza"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="s2">"10.00"</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code>&#13;
      <code class="s2">"A delicious combination of pineapple, coconut, and coconut milk."</code><code class="p">,</code>&#13;
    <code class="nx">quantity</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"5"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Meat Lovers Pizza"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="s2">"13.00"</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code>&#13;
      <code class="s2">"A delicious combination of pepperoni, sausage, and bacon."</code><code class="p">,</code>&#13;
    <code class="nx">quantity</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">...</code><code class="nx">result</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>Then we use <code>.toEqual()</code> to assert the expected result:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">it</code><code class="p">(</code><code class="s1">'should return a filtered array'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">filterArray</code><code class="p">(</code><code class="nx">pizzas</code><code class="p">,</code> <code class="s1">'title'</code><code class="p">,</code> <code class="s1">'Hawaiian'</code><code class="p">)).</code><code class="nx">toEqual</code><code class="p">(</code><code class="nx">result</code><code class="p">)</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>Let’s run our tests in the watch mode using the <code>yarn test</code> command. The test will fail, and Vitest will display the failure’s details, including the expected result and the actual result, as seen in <a data-type="xref" href="#figure_chap10_02">Figure 11-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_chap10_02">&#13;
<img alt="Screenshot displaying a stack trace for each test and details of the failed test" src="assets/lvue_1102.png"/>&#13;
<h6><span class="label">Figure 11-2. </span>Test failure details</h6>&#13;
</div></figure>&#13;
&#13;
<p>Part of the TDD approach is to define the tests and watch them fail before implementing the actual code. The next step is working on the <code>filterArray</code> function to make the test pass with the minimum code required.</p>&#13;
&#13;
<p>Here is an example implementation of <code>filterArray</code> using <code>filter()</code> and <code>toLowerCase()</code><a data-primary="test-driven development (TDD)" data-type="indexterm" id="id1591"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">type</code> <code class="nx">ArrayObject</code> <code class="o">=</code> <code class="p">{</code> <code class="p">[</code><code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">};</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">filterArray</code><code class="p">(</code>&#13;
  <code class="nx">array</code><code class="o">:</code> <code class="nx">ArrayObject</code><code class="p">[],</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">term</code><code class="o">:</code> <code class="kt">string</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">ArrayObject</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">filterTerm</code> <code class="o">=</code> <code class="nx">term</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">();</code>&#13;
&#13;
  <code class="k">return</code> <code class="nx">array</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code>&#13;
    <code class="p">(</code><code class="nx">item</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">item</code><code class="p">[</code><code class="nx">key</code><code class="p">].</code><code class="nx">toLowerCase</code><code class="p">().</code><code class="nx">includes</code><code class="p">(</code><code class="nx">filterTerm</code><code class="p">)</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">With this code, our test should pass (<a data-type="xref" href="#figure_chap10_03">Figure 11-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_chap10_03">&#13;
<img alt="Screenshot displaying a stack trace for each test and details of the failed test" src="assets/lvue_1103.png"/>&#13;
<h6><span class="label">Figure 11-3. </span>Test passes</h6>&#13;
</div></figure>&#13;
&#13;
<p>At this point, you can create more tests to cover the rest of the function’s scenarios. For example, when the key doesn’t exist in the array’s element (<code>item[key]</code> is &#13;
<span class="keep-together"><code>undefined</code></span>), or when the <code>term</code> is case-insensitive:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">it</code><code class="p">(</code><code class="s2">"should return a empty array when key doesn't exist"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">filterArray</code><code class="p">(</code><code class="nx">pizzas</code><code class="p">,</code> <code class="s1">'name'</code><code class="p">,</code> <code class="s1">'Hawaiian'</code><code class="p">)).</code><code class="nx">toEqual</code><code class="p">([])</code>&#13;
<code class="p">})</code>&#13;
&#13;
<code class="nx">it</code><code class="p">(</code><code class="s1">'should return matching array when term is upper-cased'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">filterArray</code><code class="p">(</code><code class="nx">pizzas</code><code class="p">,</code> <code class="s1">'name'</code><code class="p">,</code> <code class="s1">'HAWAIIAN'</code><code class="p">)).</code><code class="nx">toEqual</code><code class="p">(</code><code class="nx">result</code><code class="p">)</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>In the terminal, you will see the tests displayed with the relevant name (<a data-type="xref" href="#figure_chap10_04">Figure 11-4</a>) in a flat order<a data-primary="order" data-secondary="unit tests" data-type="indexterm" id="id1592"/><a data-primary="unit testing" data-secondary="order of tests" data-type="indexterm" id="id1593"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_chap10_04">&#13;
<img alt="Screenshot displaying a stack trace for each test and details of the failed test" src="assets/lvue_1104.png"/>&#13;
<h6><span class="label">Figure 11-4. </span>Displaying the tests in a flat order</h6>&#13;
</div></figure>&#13;
&#13;
<p>As the number of tests in a file and the number of test files grow, the flat order can be hard to read and understand. To make it readable per functionality, use <code>describe()</code> to group the tests into logical blocks, each with the appropriate block name<a data-primary="describe()" data-secondary="grouping tests in Vitest" data-type="indexterm" id="id1594"/><a data-primary="unit testing" data-secondary="grouping tests" data-type="indexterm" id="id1595"/><a data-primary="Vitest" data-secondary="grouping tests" data-type="indexterm" id="id1596"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">describe</code><code class="p">(</code><code class="s1">'filterArray'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">it</code><code class="p">(</code><code class="s1">'should return a filtered array'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">filterArray</code><code class="p">(</code><code class="nx">pizzas</code><code class="p">,</code> <code class="s1">'title'</code><code class="p">,</code> <code class="s1">'Hawaiian'</code><code class="p">)).</code><code class="nx">toEqual</code><code class="p">(</code><code class="nx">result</code><code class="p">)</code>&#13;
  <code class="p">})</code>&#13;
  <code class="nx">it</code><code class="p">(</code><code class="sb">`should return a empty array when key doesn't exist`</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">filterArray</code><code class="p">(</code><code class="nx">pizzas</code><code class="p">,</code> <code class="s1">'name'</code><code class="p">,</code> <code class="s1">'Hawaiian'</code><code class="p">)).</code><code class="nx">toEqual</code><code class="p">([])</code>&#13;
  <code class="p">})</code>&#13;
&#13;
  <code class="nx">it</code><code class="p">(</code><code class="s1">'should return matching array when term is upper-cased'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">filterArray</code><code class="p">(</code><code class="nx">pizzas</code><code class="p">,</code> <code class="s1">'name'</code><code class="p">,</code> <code class="s1">'HAWAIIAN'</code><code class="p">)).</code><code class="nx">toEqual</code><code class="p">(</code><code class="nx">result</code><code class="p">)</code>&#13;
  <code class="p">})</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>Vitest will display the tests in a more organized hierarchy, as seen in <a data-type="xref" href="#figure_chap10_05">Figure 11-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_chap10_05">&#13;
<img alt="Screenshot displaying a stack trace for each test and details of the failed test" src="assets/lvue_1105.png"/>&#13;
<h6><span class="label">Figure 11-5. </span>Displaying the tests per group</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We can move <code>pizzas</code> and <code>result</code> inside the <code>describe</code> block. This ensures the scope of these variables is relevant only within the <code>filterArray</code> test group. Otherwise, once this test suite runs, these two variables will be available in the global test scope and can overlap other variables with the same name, causing unwanted &#13;
<span class="keep-together">behavior</span><a data-primary="scope, unit testing and" data-type="indexterm" id="id1597"/><a data-primary="unit testing" data-secondary="scope and" data-type="indexterm" id="id1598"/>.</p>&#13;
</div>&#13;
&#13;
<p>At this point, we have learned how to write tests for a function with the TDD approach using <code>it()</code>, <code>expect()</code>, and grouping them with <code>expect()</code>. While TDD is handy if we understand all the desired scenarios for our function, it can be challenging for beginners to adapt and follow. Consider combining TDD and other approaches rather than following a single process<a data-primary="test-driven development (TDD)" data-type="indexterm" id="id1599"/>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You can also use <code>test()</code> for <code>it()</code>, <code>assert()</code>, and for <code>expect()</code> as their alternatives. While its name should start with “should do something” representing a coherent sentence (such as “it should return a filtered array”), <code>test</code> can be any meaningful name<a data-primary="test()" data-type="indexterm" id="id1600"/>.</p>&#13;
</div>&#13;
&#13;
<p>Since composables in Vue are JavaScript functions that use Vue’s Composition API, using Vitest to test them is simple. Next, we will explore how to write tests for composables, starting with the non-lifecycle ones<a data-primary="" data-startref="ix-test-unit3" data-type="indexterm" id="id1601"/><a data-primary="" data-startref="ix-test-unit3a" data-type="indexterm" id="id1602"/><a data-primary="" data-startref="ix-test-unit3b" data-type="indexterm" id="id1603"/><a data-primary="" data-startref="ix-test-unit3c" data-type="indexterm" id="id1604"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing Non-Lifecycle Composables" data-type="sect1"><div class="sect1" id="id122">&#13;
<h1>Testing Non-Lifecycle Composables</h1>&#13;
&#13;
<p>We will start with a composition function, <code>useFilter</code>, that returns an object containing the following variables<a data-primary="composables" data-secondary="testing" data-type="indexterm" id="ix-test-unit4"/><a data-primary="testing" data-secondary="composables" data-type="indexterm" id="ix-test-unit4a"/><a data-primary="unit testing" data-secondary="composables" data-type="indexterm" id="ix-test-unit4b"/><a data-primary="Vitest" data-secondary="testing composables" data-type="indexterm" id="ix-test-unit4c"/>:</p>&#13;
<dl>&#13;
<dt><code>filterBy</code></dt>&#13;
<dd>&#13;
<p>The key to filtering by</p>&#13;
</dd>&#13;
<dt><code>filterTerm</code></dt>&#13;
<dd>&#13;
<p>The term to filter by</p>&#13;
</dd>&#13;
<dt><code>filteredArray</code></dt>&#13;
<dd>&#13;
<p>The filtered array</p>&#13;
</dd>&#13;
<dt><code>order</code></dt>&#13;
<dd>&#13;
<p>The order of the filtered array, with the default value of <code>asc</code></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>It accepts a reactive array, <code>arr</code>, a <code>key</code>, and a <code>term</code> as initial values for the filtered array, the filter key, and the filter term.</p>&#13;
&#13;
<p>The implementation for <code>useFilter</code> is as follows:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** composables/useFilter.ts */</code><code>&#13;
</code><code class="kr">import</code><code> </code><code class="p">{</code><code> </code><code class="nx">ref</code><code class="p">,</code><code> </code><code class="nx">computed</code><code class="p">,</code><code> </code><code class="kr">type</code><code> </code><code class="nx">Ref</code><code> </code><code class="p">}</code><code> </code><code class="nx">from</code><code> </code><code class="s1">'vue'</code><code>&#13;
&#13;
</code><code class="kr">type</code><code> </code><code class="nx">ArrayObject</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><code class="p">[</code><code class="nx">key</code><code class="o">:</code><code> </code><code class="kt">string</code><code class="p">]</code><code class="o">:</code><code> </code><code class="kt">string</code><code> </code><code class="p">}</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="kr">export</code><code> </code><code class="kd">function</code><code> </code><code class="nx">useFilter</code><code class="p">(</code><code>&#13;
  </code><code class="nx">arr</code><code class="o">:</code><code> </code><code class="nx">Ref</code><code class="o">&lt;</code><code class="nx">ArrayObject</code><code class="p">[</code><code class="p">]</code><code class="o">&gt;</code><code class="p">,</code><code>&#13;
  </code><code class="nx">key</code><code class="o">:</code><code> </code><code class="kt">string</code><code class="p">,</code><code>&#13;
  </code><code class="nx">term</code><code class="o">:</code><code> </code><code class="kt">string</code><code>&#13;
</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_testing_in_vue_CO1-1" id="co_testing_in_vue_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">filterBy</code><code> </code><code class="o">=</code><code> </code><code class="nx">ref</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code><code> </code><a class="co" href="#callout_testing_in_vue_CO1-2" id="co_testing_in_vue_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">filterTerm</code><code> </code><code class="o">=</code><code> </code><code class="nx">ref</code><code class="p">(</code><code class="nx">term</code><code class="p">)</code><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">order</code><code> </code><code class="o">=</code><code> </code><code class="nx">ref</code><code class="p">(</code><code class="s1">'asc'</code><code class="p">)</code><code>&#13;
&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">filteredArray</code><code> </code><code class="o">=</code><code> </code><code class="nx">computed</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_testing_in_vue_CO1-3" id="co_testing_in_vue_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="nx">arr</code><code class="p">.</code><code class="nx">value</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="p">(</code><code class="nx">item</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code>&#13;
      </code><code class="nx">item</code><code class="p">[</code><code class="nx">filterBy</code><code class="p">.</code><code class="nx">value</code><code class="p">]</code><code class="o">?</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code>&#13;
        </code><code class="nx">filterTerm</code><code class="p">.</code><code class="nx">value</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
    </code><code class="p">)</code><code class="p">.</code><code class="nx">sort</code><code class="p">(</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code> </code><code class="nx">b</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
      </code><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">order</code><code class="p">.</code><code class="nx">value</code><code> </code><code class="o">===</code><code> </code><code class="s1">'asc'</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
        </code><code class="k">return</code><code> </code><code class="nx">a</code><code class="p">[</code><code class="nx">filterBy</code><code class="p">.</code><code class="nx">value</code><code class="p">]</code><code> </code><code class="o">&gt;</code><code> </code><code class="nx">b</code><code class="p">[</code><code class="nx">filterBy</code><code class="p">.</code><code class="nx">value</code><code class="p">]</code><code> </code><code class="o">?</code><code> </code><code class="mi">1</code><code> </code><code class="o">:</code><code> </code><code class="o">-</code><code class="mi">1</code><code>&#13;
      </code><code class="p">}</code><code> </code><code class="k">else</code><code> </code><code class="p">{</code><code>&#13;
        </code><code class="k">return</code><code> </code><code class="nx">a</code><code class="p">[</code><code class="nx">filterBy</code><code class="p">.</code><code class="nx">value</code><code class="p">]</code><code> </code><code class="o">&lt;</code><code> </code><code class="nx">b</code><code class="p">[</code><code class="nx">filterBy</code><code class="p">.</code><code class="nx">value</code><code class="p">]</code><code> </code><code class="o">?</code><code> </code><code class="mi">1</code><code> </code><code class="o">:</code><code> </code><code class="o">-</code><code class="mi">1</code><code>&#13;
      </code><code class="p">}</code><code>&#13;
    </code><code class="p">}</code><code class="p">)</code><code>&#13;
  </code><code class="p">)</code><code class="p">;</code><code>&#13;
&#13;
  </code><code class="k">return</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">filterBy</code><code class="p">,</code><code>&#13;
    </code><code class="nx">filterTerm</code><code class="p">,</code><code>&#13;
    </code><code class="nx">filteredArray</code><code class="p">,</code><code>&#13;
    </code><code class="nx">order</code><code class="p">,</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_testing_in_vue_CO1-1" id="callout_testing_in_vue_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Declare <code>arr</code> as a reactive <code>Ref</code> type of <code>ArrayObject</code> and <code>key</code> and <code>term</code> as <code>string</code> types</p></dd>&#13;
<dt><a class="co" href="#co_testing_in_vue_CO1-2" id="callout_testing_in_vue_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create <code>filterBy</code>, <code>filterTerm</code>, and <code>order</code> as <code>ref()</code> with the initial values</p></dd>&#13;
<dt><a class="co" href="#co_testing_in_vue_CO1-3" id="callout_testing_in_vue_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Create <code>filteredArray</code> as <code>computed()</code>, reacting to changes of <code>filterBy</code>, <code>filterTerm</code>, <code>order</code>, and <code>arr</code></p></dd>&#13;
</dl>&#13;
&#13;
<p>In the <code>tests/</code> folder, we create a file <code>useFilter.test.ts</code> to test <code>useFilter</code>, with the following setup:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">useFilter</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@/composables/useFilter'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">books</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s1">'1'</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s1">'Gone with the wind'</code><code class="p">,</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="s1">'Margaret Mitchell'</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code>&#13;
    <code class="s1">'A novel set in the American South during the Civil War and Reconstruction'</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s1">'2'</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s1">'The Great Gatsby'</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code>&#13;
      <code class="s1">'The story primarily concerns the mysterious millionaire Jay Gatsby'</code><code class="p">,</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="s1">'F. Scott Fitzgerald'</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s1">'3'</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s1">'Little women'</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code> <code class="s1">'The March sisters live and grow in post-Civil War America'</code><code class="p">,</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="s1">'Louisa May Alcott'</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">]</code>&#13;
&#13;
<code class="nx">describe</code><code class="p">(</code><code class="s1">'useFilter'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>Since <code>books</code> is a constant array and not a Vue-reactive object, in our test case we will wrap it with <code>ref()</code> to enable its reactivity before passing it to the function for testing<a data-primary="reactivity" data-secondary="unit tests and" data-type="indexterm" id="id1605"/><a data-primary="ref()" data-secondary="wrapping in unit tests" data-type="indexterm" id="id1606"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">useFilter</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@/composables/useFilter'</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ref</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">books</code> <code class="o">=</code> <code class="nx">ref</code><code class="p">([</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">]);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">[</code><code class="nx">books</code><code class="p">.</code><code class="nx">value</code><code class="p">[</code><code class="mi">0</code><code class="p">]]</code></pre>&#13;
&#13;
<p>We also declare the expected <code>result</code> based on the <code>books</code> array value. Now we can write our first reactivity test case, where we assert the <code>useFilter</code> function to return the updated filtered array when changing <code>filterTerm</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">it</code><code class="p">(</code>&#13;
  <code class="s1">'should reactively return the filtered array when filterTerm is changed'</code><code class="p">,</code>&#13;
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">filteredArray</code><code class="p">,</code> <code class="nx">filterTerm</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">useFilter</code><code class="p">(</code><code class="nx">books</code><code class="p">,</code> <code class="s1">'title'</code><code class="p">,</code> <code class="s1">''</code><code class="p">);</code>&#13;
&#13;
  <code class="nx">filterTerm</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">books</code><code class="p">.</code><code class="nx">value</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">title</code><code class="p">;</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">filteredArray</code><code class="p">.</code><code class="nx">value</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>When we run the test, it should pass with the output shown in <a data-type="xref" href="#figure_ch10_composable_1">Figure 11-6</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_composable_1">&#13;
<img alt="A screenshot of the passing tests for +useFilter+" src="assets/lvue_1106.png"/>&#13;
<h6><span class="label">Figure 11-6. </span>All the tests for <code>useFilter</code> pass</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can continue writing the test cases for <code>filterBy</code> and <code>order</code> in the same approach and have <code>useFilter</code> fully test-covered. In this example of <code>useFilter</code>, we asserted a composable that uses <code>ref</code> and <code>computed</code> under the hood. We can apply the same asserting practice to composables with similar APIs like <code>watch</code>, <code>reactive</code>, <code>provide</code>, etc. However, for composables that use <code>onMounted</code>, <code>onUpdated</code>, <code>onUnmounted</code>, etc., we use a different approach to test them, discussed next<a data-primary="" data-startref="ix-test-unit1" data-type="indexterm" id="id1607"/><a data-primary="" data-startref="ix-test-unit1a" data-type="indexterm" id="id1608"/><a data-primary="" data-startref="ix-test-unit1b" data-type="indexterm" id="id1609"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing Composables with Lifecycle Hook" data-type="sect1"><div class="sect1" id="id123">&#13;
<h1>Testing Composables with Lifecycle Hook</h1>&#13;
&#13;
<p>The following composable, <code>useFetch</code>, uses <code>onMounted</code> to fetch data from an API<a data-primary="lifecycle hooks" data-secondary="testing composables with" data-type="indexterm" id="ix-test-unit5"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** composables/useFetch.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ref</code><code class="p">,</code> <code class="nx">onMounted</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">useFetch</code><code class="p">(</code><code class="nx">url</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">data</code> <code class="o">=</code> <code class="nx">ref</code><code class="p">(</code><code class="kc">null</code><code class="p">)</code>&#13;
  <code class="kr">const</code> <code class="nx">error</code> <code class="o">=</code> <code class="nx">ref</code><code class="p">(</code><code class="kc">null</code><code class="p">)</code>&#13;
  <code class="kr">const</code> <code class="nx">loading</code> <code class="o">=</code> <code class="nx">ref</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">fetchData</code> <code class="o">=</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">try</code> <code class="p">{</code>&#13;
      <code class="kr">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>&#13;
&#13;
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`Failed to fetch data for </code><code class="si">${</code><code class="nx">url</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
      <code class="p">}</code>&#13;
&#13;
      <code class="nx">data</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">error</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">;</code>&#13;
    <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>&#13;
      <code class="nx">loading</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="nx">onBeforeMount</code><code class="p">(</code><code class="nx">fetchData</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">data</code><code class="p">,</code> <code class="nx">error</code><code class="p">,</code> <code class="nx">loading</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The function receives a <code>url</code> parameter; fetches data from the given <code>url</code> before mounting the component; updates data, errors, and loading values accordingly; and returns them. Since this composable relies on <code>onBeforeMount</code> of a component’s lifecycle to fetch data, we must create a Vue component and simulate the mounting process to test it<a data-primary="onBeforeMount() hook" data-type="indexterm" id="ix-test-unit5a"/>.</p>&#13;
&#13;
<p>We can do this by using <code>createApp</code> from the <code>vue</code> package and creating a component/app that uses <code>useFetch</code> in its <code>setup</code> hook:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** tests/useFetch.test.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code><code class="p">,</code> <code class="kr">type</code> <code class="nx">App</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">withSetup</code><code class="p">(</code><code class="nx">composable</code><code class="o">:</code> <code class="nb">Function</code><code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="kr">any</code><code class="p">,</code> <code class="nx">App</code><code class="o">&lt;</code><code class="nx">Element</code><code class="o">&gt;</code><code class="p">]</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nx">result</code><code class="p">;</code>&#13;
&#13;
    <code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">({</code>&#13;
        <code class="nx">setup</code><code class="p">()</code> <code class="p">{</code>&#13;
            <code class="nx">result</code> <code class="o">=</code> <code class="nx">composable</code><code class="p">();</code>&#13;
            <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{};</code>&#13;
        <code class="p">},</code>&#13;
    <code class="p">});</code>&#13;
&#13;
    <code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"div"</code><code class="p">));</code>&#13;
&#13;
    <code class="k">return</code> <code class="p">[</code><code class="nx">result</code><code class="p">,</code> <code class="nx">app</code><code class="p">];</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>withSetup</code> function takes a <code>composable</code> and returns an array of <code>result</code> of the composable execution and the <code>app</code> instance created. We can then use <code>withSetup</code> in all our test cases to mimic the creation process of a component that uses <code>useFetch</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">useFetch</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@/composables/useFetch'</code>&#13;
&#13;
<code class="nx">describe</code><code class="p">(</code><code class="s1">'useFetch'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">it</code><code class="p">(</code><code class="s1">'should fetch data from the given url'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="p">[</code><code class="nx">result</code><code class="p">,</code> <code class="nx">app</code><code class="p">]</code> <code class="o">=</code> <code class="nx">withSetup</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">useFetch</code><code class="p">(</code><code class="s1">'your-test-url'</code><code class="p">));</code>&#13;
&#13;
    <code class="nx">expect</code><code class="p">();</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>However, there is one issue here. <code>useFetch</code> is using <code>fetch</code> API to fetch data; it is not a good practice to use the actual API in the test for these reasons<a data-primary="fetch" data-secondary="mocking for unit tests and" data-type="indexterm" id="ix-test-unit5b"/><a data-primary="mocks" data-type="indexterm" id="ix-test-unit5c"/>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The test will fail if the API is down or the URL is invalid.</p>&#13;
</li>&#13;
<li>&#13;
<p>The test will fail if the API is slow.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Thus, we need to mock the <code>fetch</code> API to simulate the response by using the <code>vi.spyOn</code> method<a data-primary="spyOn" data-type="indexterm" id="id1610"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">vi</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vitest'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">fetchSpy</code> <code class="o">=</code> <code class="nx">vi</code><code class="p">.</code><code class="nx">spyOn</code><code class="p">(</code><code class="nx">global</code><code class="p">,</code> <code class="s1">'fetch'</code><code class="p">);</code></pre>&#13;
&#13;
<p>We can place the <code>fetchSpy</code> declaration within the <code>describe</code> section to ensure the isolation of this spy from other test suites. And in the <code>beforeEach</code> hook, we need to reset every mocked implementation and value before running the test case with the <code>mockClear()</code> method<a data-primary="beforeEach hook" data-secondary="testing composables" data-type="indexterm" id="id1611"/><a data-primary="cleanup" data-secondary="test environment" data-type="indexterm" id="id1612"/><a data-primary="Clear()" data-type="indexterm" id="id1613"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">describe</code><code class="p">(</code><code class="s1">'useFetch'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">fetchSpy</code> <code class="o">=</code> <code class="nx">vi</code><code class="p">.</code><code class="nx">spyOn</code><code class="p">(</code><code class="nx">global</code><code class="p">,</code> <code class="s1">'fetch'</code><code class="p">);</code>&#13;
&#13;
  <code class="nx">beforeEach</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">fetchSpy</code><code class="p">.</code><code class="nx">mockClear</code><code class="p">();</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="nx">it</code><code class="p">(</code><code class="s1">'should fetch data from the given url'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">//...</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Let’s write our test. We will first mock the <code>fetch</code> API to return a successful response with the <code>mockResolvedValueOnce</code> method<a data-primary="mockResolvedValueOnce()" data-type="indexterm" id="id1614"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">it</code><code class="p">(</code><code class="s1">'should fetch data from the given url'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">fetchSpy</code><code class="p">.</code><code class="nx">mockResolvedValueOnce</code><code class="p">({</code>&#13;
    <code class="nx">ok</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nx">json</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">({</code> <code class="nx">data</code><code class="o">:</code> <code class="s1">'test'</code> <code class="p">}),</code>&#13;
  <code class="p">}</code> <code class="kr">as</code> <code class="kr">any</code><code class="p">);</code>&#13;
&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">result</code><code class="p">,</code> <code class="nx">app</code><code class="p">]</code> <code class="o">=</code> <code class="nx">withSetup</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">useFetch</code><code class="p">(</code><code class="s1">'your-test-url'</code><code class="p">));</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>After that, we can assert the <code>data</code> value of the <code>result</code> to be equal to the mocked data:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">it</code><code class="p">(</code><code class="s1">'should fetch data from the given url'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">result</code><code class="p">,</code> <code class="nx">app</code><code class="p">]</code> <code class="o">=</code> <code class="nx">withSetup</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">useFetch</code><code class="p">(</code><code class="s1">'your-test-url'</code><code class="p">));</code>&#13;
&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">result</code><code class="o">?</code><code class="p">.</code><code class="nx">data</code><code class="p">.</code><code class="nx">value</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">({</code> <code class="nx">data</code><code class="o">:</code> <code class="s1">'test'</code> <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We can also expect calling the <code>fetch</code> with the given <code>url</code> with the <code>toHaveBeenCalledWith</code> method<a data-primary="toHaveBeenCalledWith()" data-type="indexterm" id="id1615"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">it</code><code class="p">(</code><code class="s1">'should fetch data from the given url'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">fetchSpy</code><code class="p">).</code><code class="nx">toHaveBeenCalledWith</code><code class="p">(</code><code class="s1">'your-test-url'</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>And finally, we need to unmount the app to clean up the test environment:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">it</code><code class="p">(</code><code class="s1">'should fetch data from the given url'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
  <code class="kr">await</code> <code class="nx">app</code><code class="p">.</code><code class="nx">unmount</code><code class="p">();</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>At this point, we expect the test to pass successfully. Unfortunately, the test will still fail. The reason is that while the <code>fetch</code> API is asynchronous, the component’s lifecycle hook <code>beforeMount</code> isn’t. The hook execution can finish before the <code>fetch</code> API is resolved, causing the <code>data</code> value to stay unchanged (<a data-type="xref" href="#figure_ch10_failing_fetch_test">Figure 11-7</a>)<a data-primary="asynchronous calls" data-secondary="testing composables" data-type="indexterm" id="id1616"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_failing_fetch_test">&#13;
<img alt="A screenshot showing the details of the failing test for useFetch" src="assets/lvue_1107.png"/>&#13;
<h6><span class="label">Figure 11-7. </span>Failing test for <code>useFetch</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>To fix this issue, we need help from another package, Vue Test Utils (<code>@vue/test-utils</code>), <a href="https://oreil.ly/dZILU">the official testing utility library for Vue</a>. This package offers a set of utility methods to help test Vue components. We will import and use <code>flushPromises</code> from this package to wait for the <code>fetch</code> API to resolve before asserting the <code>data</code> value<a data-primary="flushPromises" data-type="indexterm" id="id1617"/><a data-primary="Promises" data-secondary="flushing" data-type="indexterm" id="id1618"/><a data-primary="testing" data-secondary="tools" data-type="indexterm" id="id1619"/><a data-primary="Vue Test Utils" data-secondary="composables testing" data-type="indexterm" id="id1620"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">flushPromises</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@vue/test-utils'</code>&#13;
&#13;
<code class="nx">it</code><code class="p">(</code><code class="s1">'should fetch data from the given url'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
&#13;
  <code class="kr">await</code> <code class="nx">flushPromises</code><code class="p">();</code>&#13;
&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">data</code><code class="p">.</code><code class="nx">value</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">({</code> <code class="nx">data</code><code class="o">:</code> <code class="s1">'test'</code> <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>The test should pass successfully (<a data-type="xref" href="#figure_ch10_passing_fetch_test">Figure 11-8</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_passing_fetch_test">&#13;
<img alt="A screenshot showing the tests passed for useFetch in green" src="assets/lvue_1108.png"/>&#13;
<h6><span class="label">Figure 11-8. </span>Passing the test for <code>useFetch</code></h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">You can also assert the <code>loading</code> value by placing the assertion before the <code>flush</code>&#13;
<span class="keep-together"><code>Promises</code></span> call:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">it</code><code class="p">(</code><code class="s1">'should change loading value'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">loading</code><code class="p">.</code><code class="nx">value</code><code class="p">).</code><code class="nx">toBe</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code>&#13;
&#13;
  <code class="kr">await</code> <code class="nx">flushPromises</code><code class="p">();</code>&#13;
&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">loading</code><code class="p">.</code><code class="nx">value</code><code class="p">).</code><code class="nx">toBe</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Another benefit of mocking the <code>fetch</code> API is that we can simulate the failure response by using the <code>mockRejectedValueOnce</code> method and test our composable’s error-handling logic<a data-primary="errors" data-secondary="unit testing" data-type="indexterm" id="id1621"/><a data-primary="mockRejectedValueOnce()" data-type="indexterm" id="id1622"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">it</code><code class="p">(</code><code class="s1">'should change error value'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">fetchSpy</code><code class="p">.</code><code class="nx">mockRejectedValueOnce</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'test error'</code><code class="p">));</code>&#13;
&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">result</code><code class="p">,</code> <code class="nx">app</code><code class="p">]</code> <code class="o">=</code> <code class="nx">withSetup</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">useFetch</code><code class="p">(</code><code class="s1">'your-test-url'</code><code class="p">));</code>&#13;
&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">error</code><code class="p">.</code><code class="nx">value</code><code class="p">).</code><code class="nx">toBe</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>&#13;
&#13;
  <code class="kr">await</code> <code class="nx">flushPromises</code><code class="p">();</code>&#13;
&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">error</code><code class="p">.</code><code class="nx">value</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'test error'</code><code class="p">));</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>That’s it. You can apply the same mocking approach to external test APIs in your applications or mock any dependent functions that are already tested and reduce the complexity of your test suites. We have successfully tested our <code>useFetch</code> method with Vitest and Vue Test Utils.</p>&#13;
&#13;
<p>Next, we will explore how to test a Vue component with Vitest and Vue Test Utils<a data-primary="" data-startref="ix-test-unit4" data-type="indexterm" id="id1623"/><a data-primary="" data-startref="ix-test-unit4a" data-type="indexterm" id="id1624"/><a data-primary="" data-startref="ix-test-unit4b" data-type="indexterm" id="id1625"/><a data-primary="" data-startref="ix-test-unit4c" data-type="indexterm" id="id1626"/><a data-primary="" data-startref="ix-test-unit5" data-type="indexterm" id="id1627"/><a data-primary="" data-startref="ix-test-unit5a" data-type="indexterm" id="id1628"/><a data-primary="" data-startref="ix-test-unit5b" data-type="indexterm" id="id1629"/><a data-primary="" data-startref="ix-test-unit5c" data-type="indexterm" id="id1630"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing Components Using Vue Test Utils" data-type="sect1"><div class="sect1" id="id124">&#13;
<h1>Testing Components Using Vue Test Utils</h1>&#13;
&#13;
<p>The Vue engine uses the configurations of the Vue components to create and manage component instance updates on the browser DOM. Testing components means we will test the components’ rendering results to the DOM. We set our &#13;
<span class="keep-together"><code>test.environment</code></span> to <code>jsdom</code> in the <code>vite.config.ts</code> for simulating the browser environment, which doesn’t exist in the Node.js environment where the tests are running. We also use the methods like <code>mount</code>, <code>shallowMount</code>, etc., from the <code>@vue/test-utils</code> package to help mount the component and assert the rendering results from a virtual Vue node to a DOM element<a data-primary="mounting" data-secondary="testing components with Vue Test Utils" data-type="indexterm" id="id1631"/><a data-primary="mount() method" data-secondary="testing components with Vue Test Utils" data-type="indexterm" id="ix-test-unit6"/><a data-primary="shallowMount()" data-type="indexterm" id="ix-test-unit6a"/><a data-primary="components" data-secondary="testing" data-type="indexterm" id="ix-test-unit7"/><a data-primary="testing" data-secondary="components" data-type="indexterm" id="ix-test-unit7a"/><a data-primary="Vitest" data-secondary="components testing" data-type="indexterm" id="ix-test-unit7b"/><a data-primary="Vue Test Utils" data-secondary="components testing" data-type="indexterm" id="ix-test-unit7c"/>.</p>&#13;
&#13;
<p>Let’s look at our <code>PizzaCard.vue</code> component, shown in <a data-type="xref" href="#ch10_pizza_card">Example 11-1</a>.</p>&#13;
<div data-type="example" id="ch10_pizza_card">&#13;
<h5><span class="label">Example 11-1. </span><code>PizzaCard</code> component</h5>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">article</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizza--details-wrapper"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">img</code> <code class="na">:src</code><code class="o">=</code><code class="s">"pizza.image"</code> <code class="na">:alt</code><code class="o">=</code><code class="s">"pizza.title"</code> <code class="na">height</code><code class="o">=</code><code class="s">"200"</code> <code class="na">width</code><code class="o">=</code><code class="s">"300"</code> <code class="p">/&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>{{ pizza.description }}<code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizza--inventory"</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizza--inventory-stock"</code><code class="p">&gt;</code>Stock: {{ pizza.quantity || 0 }}<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizza--inventory-price"</code><code class="p">&gt;</code>$ {{ pizza.price }}<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">article</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">setup</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">type</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">Pizza</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/types/Pizza"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">type</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">PropType</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"vue"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">props</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">defineProps</code><code class="p">({</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">pizza</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">type</code><code class="o">:</code><code class="w"> </code><code class="nb">Object</code><code class="w"> </code><code class="kr">as</code><code class="w"> </code><code class="nx">PropType</code><code class="p">&lt;</code><code class="nt">Pizza</code><code class="p">&gt;,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">required</code><code class="o">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre></div>&#13;
&#13;
<p>We will create a test file <code>tests/PizzaCard.test.ts</code> to test the component. We will import the <code>shallowMount</code> method from <code>@vue/test-utils</code> to mount the element within the file. The <code>shallowMount</code> function receives two main arguments: the Vue component to mount, and an object containing additional data for mounting the component, such as props’ values, stubs, etc. The following code demonstrates how the test file looks, with the initial value for the <code>pizza</code> prop:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** tests/PizzaCard.test.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">shallowMount</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@vue/test-utils'</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">PizzaCard</code> <code class="nx">from</code> <code class="s1">'@/components/PizzaCard.vue'</code><code class="p">;</code>&#13;
&#13;
<code class="nx">describe</code><code class="p">(</code><code class="s1">'PizzaCard'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">it</code><code class="p">(</code><code class="s1">'should render the pizza details'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">pizza</code> <code class="o">=</code> <code class="p">{</code>&#13;
      <code class="nx">id</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
      <code class="nx">title</code><code class="o">:</code> <code class="s1">'Test Pizza'</code><code class="p">,</code>&#13;
      <code class="nx">description</code><code class="o">:</code> <code class="s1">'Test Pizza Description'</code><code class="p">,</code>&#13;
      <code class="nx">image</code><code class="o">:</code> <code class="s1">'test-pizza.jpg'</code><code class="p">,</code>&#13;
      <code class="nx">price</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code>&#13;
      <code class="nx">quantity</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code>&#13;
    <code class="p">};</code>&#13;
&#13;
    <code class="kr">const</code> <code class="nx">wrapper</code> <code class="o">=</code> <code class="nx">shallowMount</code><code class="p">(</code><code class="nx">PizzaCard</code><code class="p">,</code> <code class="p">{</code>&#13;
      <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">pizza</code><code class="p">,</code>&#13;
      <code class="p">},</code>&#13;
    <code class="p">});</code>&#13;
&#13;
    <code class="nx">expect</code><code class="p">();</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
<div data-type="tip"><h1>Using shallowMount vs mount</h1>&#13;
<p>The <code>shallowMount</code> method is a wrapper around the <code>mount</code> method with its <code>shallow</code> flag active. It is best to use <code>shallowMount</code> to render and test the component without caring about its children. If you want to try the children components, use the <code>mount</code> method instead.</p>&#13;
</div>&#13;
&#13;
<p>The <code>shallowMount</code> method returns a Vue instance, <code>wrapper</code>, with some helper methods to allow us to mimic UI interactions with the component. Once we have the wrapper instance, we can write our assertions. For example, we can use the <code>find</code> method to find the DOM element with the class selector <code>pizza- -details-wrapper</code> and assert its existence<a data-primary="find(), testing components with Vue Test Utils" data-type="indexterm" id="id1632"/><a data-primary="wrapper, testing components with Vue Test Utils" data-type="indexterm" id="id1633"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** tests/PizzaCard.test.ts */</code>&#13;
<code class="c1">//...</code>&#13;
&#13;
<code class="nx">expect</code><code class="p">(</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="s1">'.pizza--details-wrapper'</code><code class="p">)).</code><code class="nx">toBeTruthy</code><code class="p">();</code></pre>&#13;
&#13;
<p>Similarly, we can assert the text content of the <code>.pizza- -inventory-stock</code> and <code>.pizza- -inventory-price</code> elements with the <code>text()</code> method<a data-primary="text(), testing components with Vue Test Utils" data-type="indexterm" id="id1634"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** tests/PizzaCard.test.ts */</code>&#13;
<code class="c1">//...</code>&#13;
&#13;
<code class="nx">expect</code><code class="p">(</code>&#13;
  <code class="nx">wrapper</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="s1">'.pizza--inventory-stock'</code><code class="p">).</code><code class="nx">text</code><code class="p">()</code>&#13;
<code class="p">).</code><code class="nx">toBe</code><code class="p">(</code><code class="sb">`Stock: </code><code class="si">${</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">quantity</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
<code class="nx">expect</code><code class="p">(</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="s1">'.pizza--inventory-price'</code><code class="p">).</code><code class="nx">text</code><code class="p">()).</code><code class="nx">toBe</code><code class="p">(</code><code class="sb">`$ </code><code class="si">${</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">price</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code></pre>&#13;
&#13;
<p>The <code>shallowMount</code> method also provides the <code>html</code> property to assert the rendered HTML of the component. We can then use <code>toMatchSnapshot</code> to test the HTML snapshot of the element<a data-primary="snapshots, testing components with Vue Test Utils" data-type="indexterm" id="id1635"/><a data-primary="toMatchSnapshot()" data-type="indexterm" id="id1636"/><a data-primary="html property, testing components with Vue Test Utils" data-type="indexterm" id="id1637"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** tests/PizzaCard.test.ts */</code>&#13;
&#13;
<code class="nx">expect</code><code class="p">(</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">html</code><code class="p">()).</code><code class="nx">toMatchSnapshot</code><code class="p">();</code></pre>&#13;
&#13;
<p>Upon running the test, the testing engine will create a snapshot file, <code>PizzaCard.test.ts.snap</code>, and store the HTML snapshot of the component. On the next test run, Vitest will validate the component’s HTML rendering against the existing snapshot, ensuring the component’s stability in complex app development<a data-primary="" data-startref="ix-test-unit6" data-type="indexterm" id="id1638"/><a data-primary="" data-startref="ix-test-unit6a" data-type="indexterm" id="id1639"/>.</p>&#13;
<div data-type="warning" epub:type="warning"><h1>Using Snapshots</h1>&#13;
<p>If you change the component’s template, the snapshot test will fail. To solve this issue, you must update the snapshot by running the test with the <code>-u</code> flag as <code>yarn test -u</code><a data-primary="-u flag for updating snapshots" data-primary-sortas="u flag for updating snapshots" data-type="indexterm" id="id1640"/><a data-primary="E2E (end-to-end) testing" data-secondary="testing HTML rendering with PlaywrightJS" data-type="indexterm" id="id1641"/><a data-primary="PlaywrightJS" data-type="indexterm" id="id1642"/><a data-primary="rendering" data-secondary="testing with PlaywrightJS" data-type="indexterm" id="id1643"/>.</p>&#13;
&#13;
<p>Due to the limitations of snapshot testing, you should use it only for the components that are not likely to change. A more recommended approach is to test HTML rendering in E2E tests using PlaywrightJS.</p>&#13;
</div>&#13;
&#13;
<p>The instance received from the <code>find()</code> method is a wrapper around the DOM element, with various methods to assert the element’s attributes and properties. We will add another test case where we will assert the <code>src</code> and <code>alt</code> attributes of the <code>img</code> element using the <code>attributes()</code> method<a data-primary="testing components with Vue Test Utils" data-type="indexterm" id="id1644"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** tests/PizzaCard.test.ts */</code>&#13;
&#13;
<code class="nx">describe</code><code class="p">(</code><code class="s1">'PizzaCard'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">it</code><code class="p">(</code><code class="s1">'should render the pizza image and alt text'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">//...</code>&#13;
&#13;
    <code class="kr">const</code> <code class="nx">wrapper</code> <code class="o">=</code> <code class="nx">shallowMount</code><code class="p">(</code><code class="nx">PizzaCard</code><code class="p">,</code> <code class="p">{</code>&#13;
      <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">pizza</code><code class="p">,</code>&#13;
      <code class="p">},</code>&#13;
    <code class="p">});</code>&#13;
&#13;
    <code class="kr">const</code> <code class="nx">img</code> <code class="o">=</code> <code class="nx">wrapper</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="s1">'img'</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">img</code><code class="p">.</code><code class="nx">attributes</code><code class="p">().</code><code class="nx">alt</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">(</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">img</code><code class="p">.</code><code class="nx">attributes</code><code class="p">().</code><code class="nx">src</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">(</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">image</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Let’s make the test fail by changing the <code>pizza.title</code> to a text of <code>Pineapple pizza</code>. As <a data-type="xref" href="#ch10_pineapple-pizza-fail">Figure 11-9</a> shows, the test will fail and show this message.</p>&#13;
&#13;
<figure><div class="figure" id="ch10_pineapple-pizza-fail">&#13;
<img alt="Test failure message when trying to test the image alt text" src="assets/lvue_1109.png"/>&#13;
<h6><span class="label">Figure 11-9. </span>Assertion of image alt text failed</h6>&#13;
</div></figure>&#13;
&#13;
<p>As this screenshot shows, the received value is <code>Test Pizza</code>, highlighted in red, and the expected value is green. We also know the reason for the failure: “expected <code>Test Pizza</code> to deeply equal <code>Pineapple pizza</code>,” with a pointer to the line where the test fails. This information lets us quickly fix the test or check our implementation to ensure the expected behavior is correct.</p>&#13;
&#13;
<p>Other practical methods for asserting the component’s interaction and data communication are the <code>trigger()</code> method of the DOM wrapper instance and <code>emitted()</code> of the wrapper instance. We will modify the implementation of the <code>PizzaCard</code> component to add an “Add to cart” button and test the button’s behavior<a data-primary="trigger()" data-type="indexterm" id="id1645"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing Interaction and Events of a Component" data-type="sect1"><div class="sect1" id="id125">&#13;
<h1>Testing Interaction and Events of a Component</h1>&#13;
&#13;
<p>We will add the following code to the <code>PizzaCard</code> component for a new Add to cart button<a data-primary="carts" data-secondary="testing interactions" data-type="indexterm" id="id1646"/><a data-primary="events" data-secondary="testing interactions" data-type="indexterm" id="id1647"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting">/** src/components/PizzaCard.vue */&#13;
&#13;
<code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">section</code> <code class="na">v-if</code><code class="o">=</code><code class="s">"pizza"</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizza--container"</code><code class="p">&gt;</code>&#13;
    <code class="cm">&lt;!-- ... --&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">button</code> <code class="err">@</code><code class="na">click</code><code class="o">=</code><code class="s">"addCart"</code><code class="p">&gt;</code>Add to cart<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">section</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code> <code class="na">setup</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="c1">//...</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">emits</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">defineEmits</code><code class="p">([</code><code class="s1">'add-to-cart'</code><code class="p">])</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">addCart</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">emits</code><code class="p">(</code><code class="s1">'add-to-cart'</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">id</code><code class="o">:</code><code class="w"> </code><code class="nx">props</code><code class="p">.</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">id</code><code class="p">,</code><code class="w"> </code><code class="nx">quantity</code><code class="o">:</code><code class="w"> </code><code class="mf">1</code><code class="w"> </code><code class="p">})</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>The button accepts a <code>click</code> event, which triggers the <code>addCart</code> method. The <code>addCart</code> method will emit a <code>add-to-cart</code> event with the <code>pizza.id</code> and the new quantity as the payload. We can then test the <code>addCart</code> method by asserting the emitted event and its payload. First, we will look for the button using the <code>find()</code> method, and then trigger the <code>click</code> event using the <code>trigger()</code> method<a data-primary="emits(), testing emitted events" data-type="indexterm" id="id1648"/><a data-primary="emitters, event" data-secondary="testing" data-type="indexterm" id="id1649"/><a data-primary="find(), testing components with Vue Test Utils" data-type="indexterm" id="id1650"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** tests/PizzaCard.test.ts */</code>&#13;
&#13;
<code class="nx">describe</code><code class="p">(</code><code class="s1">'PizzaCard'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">it</code><code class="p">(</code><code class="s1">'should emit add-to-cart event when add to cart button is clicked'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">//...</code>&#13;
&#13;
    <code class="kr">const</code> <code class="nx">wrapper</code> <code class="o">=</code> <code class="nx">shallowMount</code><code class="p">(</code><code class="nx">PizzaCard</code><code class="p">,</code> <code class="p">{</code>&#13;
      <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">pizza</code><code class="p">,</code>&#13;
      <code class="p">},</code>&#13;
    <code class="p">});</code>&#13;
&#13;
    <code class="kr">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nx">wrapper</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="s1">'button'</code><code class="p">);</code>&#13;
    <code class="nx">button</code><code class="p">.</code><code class="nx">trigger</code><code class="p">(</code><code class="s1">'click'</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We will execute the <code>wrapper.emitted()</code> function to receive a map of emitted events, with the key being the event name, and the value is an array of received payloads. Each payload is an array of arguments passed to the <code>emits()</code> function apart from the event name. For instance, when we emit the <code>add-to-cart</code> event with the payload <code>{ id: 1, quantity: 1 }</code>, the emitted event will be <code>{ <em>add-to-cart</em>: [[{ id: 1, quantity: 1 }]] }</code>.</p>&#13;
&#13;
<p>We can now assert the emitted event and its payload with the following code<a data-primary="emitted(), testing event components" data-type="indexterm" id="id1651"/><a data-primary="wrapper, testing components with Vue Test Utils" data-type="indexterm" id="id1652"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** tests/PizzaCard.test.ts */</code>&#13;
&#13;
<code class="nx">describe</code><code class="p">(</code><code class="s1">'PizzaCard'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">it</code><code class="p">(</code><code class="s1">'should emit add-to-cart event when add to cart button is clicked'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">//...</code>&#13;
&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">emitted</code><code class="p">()[</code><code class="s1">'add-to-cart'</code><code class="p">]).</code><code class="nx">toBeTruthy</code><code class="p">();</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">emitted</code><code class="p">()[</code><code class="s1">'add-to-cart'</code><code class="p">][</code><code class="mi">0</code><code class="p">]).</code><code class="nx">toEqual</code><code class="p">([</code>&#13;
      <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">pizza</code><code class="p">.</code><code class="nx">id</code><code class="p">,</code> <code class="nx">quantity</code><code class="o">:</code> <code class="mi">1</code> <code class="p">}</code>&#13;
    <code class="p">]);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
<div data-type="tip"><h1>Testing a Component That Uses a Pinia Store</h1>&#13;
<p>You can use <code>createTestingPinia()</code> from the <code>@pinia/testing</code> package to create a testing Pinia instance and plug it in the component as a global plugin during mounting. This will allow you to test the component without mocking the store or using the real store instance<a data-primary="createTestingPinia()" data-type="indexterm" id="id1653"/><a data-primary="Pinia" data-secondary="stores, testing events with" data-type="indexterm" id="id1654"/><a data-primary="stores" data-secondary="testing" data-type="indexterm" id="id1655"/><a data-primary="testing" data-secondary="events with Pinia stores" data-type="indexterm" id="id1656"/><a data-primary="testing" data-secondary="stores" data-type="indexterm" id="id1657"/>.</p>&#13;
</div>&#13;
&#13;
<p>The test passes successfully, as expected. At this point, we have covered the basic testing of components and composables with Vitest and Vue Test Utils. The following section will look at using Vitest with a GUI<a data-primary="" data-startref="ix-test-unit7" data-type="indexterm" id="id1658"/><a data-primary="" data-startref="ix-test-unit7a" data-type="indexterm" id="id1659"/><a data-primary="" data-startref="ix-test-unit7b" data-type="indexterm" id="id1660"/><a data-primary="" data-startref="ix-test-unit7c" data-type="indexterm" id="id1661"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Vitest with a GUI" data-type="sect1"><div class="sect1" id="id126">&#13;
<h1>Using Vitest with a GUI</h1>&#13;
&#13;
<p>In some scenarios, looking at the terminal (or command line) outputs can be complex, and having a Graphic User Interface (GUI) can be beneficial. For such cases, Vitest offers <code>@vitest/ui</code> as its extra dependency along the command parameter <code>--ui</code>. To start using the Vitest UI, you need to install <code>@vitest/ui</code> with the following command in the terminal<a data-primary="Vitest" data-secondary="GUI" data-type="indexterm" id="ix-test-unit8"/><a data-primary="testing" data-secondary="GUI for" data-type="indexterm" id="ix-test-unit8a"/><a data-primary="installing" data-secondary="Vitest UI" data-type="indexterm" id="id1662"/>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">yarn<code class="w"> </code>add<code class="w"> </code>-D<code class="w"> </code>@vitest/ui<code class="w"/></pre>&#13;
&#13;
<p>When running the command <code>yarn test --ui</code>, Vite will start a local server for its UI app and launch it on the browser, as shown in <a data-type="xref" href="#ch10_vitest-ui">Figure 11-10</a>.</p>&#13;
&#13;
<figure><div class="figure" id="ch10_vitest-ui">&#13;
<img alt="Vitest UI dashboard screenshot" src="assets/lvue_1110.png"/>&#13;
<h6><span class="label">Figure 11-10. </span>Vitest UI</h6>&#13;
</div></figure>&#13;
&#13;
<p>On the left-side pane, we can see the list of test files with their status, indicated by relevant colors and icons. On the main dashboard is a quick summary of the test results, including the number of tests, the number of passed tests, and the number of failed tests. We can select a single test using the left-side pane and review each test case report, its module graph, and the implementation code for the tests. <a data-type="xref" href="#figure-ch10_vitest-ui">Figure 11-11</a> shows the test report for the <code>PizzaCard</code> component.</p>&#13;
&#13;
<figure><div class="figure" id="figure-ch10_vitest-ui">&#13;
<img alt="Vitest UI test report for PizzaCard component" src="assets/lvue_1111.png"/>&#13;
<h6><span class="label">Figure 11-11. </span>Vitest UI test report for <code>PizzaCard</code> component</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can also run the tests using the GUI by clicking the Run (or Rerun all) tests icon, as seen in <a data-type="xref" href="#figure_ch10_run-tests">Figure 11-12</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_run-tests">&#13;
<img alt="Run tests icon" src="assets/lvue_1112.png"/>&#13;
<h6><span class="label">Figure 11-12. </span>Run tests using the GUI</h6>&#13;
</div></figure>&#13;
&#13;
<p>Using the GUI can be beneficial in some cases, but it can also be a distraction when you are working on a project and need to watch the tests during development. In this case, using the terminal may be a better option, and to review the test results, you can choose between the GUI, or the test coverage runner, which we will discuss next<a data-primary="" data-startref="ix-test-unit8" data-type="indexterm" id="id1663"/><a data-primary="" data-startref="ix-test-unit8a" data-type="indexterm" id="id1664"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Vitest with a Coverage Runner" data-type="sect1"><div class="sect1" id="id127">&#13;
<h1>Using Vitest with a Coverage Runner</h1>&#13;
&#13;
<p>Writing tests is straightforward, but knowing if we write enough tests to cover all the scenarios of our test target is not. To create a sufficient testing system for our application, we use <em>code coverage</em> practice, which measures how much of our code we cover with our tests<a data-primary="Vitest" data-secondary="coverage runner" data-type="indexterm" id="ix-test-unit9"/><a data-primary="coverage, code" data-secondary="testing with Vitest" data-type="indexterm" id="ix-test-unit9a"/><a data-primary="Istanbul" data-type="indexterm" id="ix-test-unit9b"/><a data-primary="testing" data-secondary="with coverage runners" data-secondary-sortas="coverage runners" data-type="indexterm" id="ix-test-unit9c"/><a data-primary="testing" data-secondary="with Vitest" data-secondary-sortas="Vitest" data-type="indexterm" id="ix-test-unit9d"/><a data-primary="code" data-secondary="coverage testing" data-type="indexterm" id="ix-test-unit10"/><a data-primary="installing" data-secondary="Istanbul" data-type="indexterm" id="id1665"/>.</p>&#13;
&#13;
<p>There are various tools for measuring code coverage and generating understandable reports. One of the most common tools is Istanbul, a JavaScript testing coverage tool. With Vitest, we can integrate Istanbul into our testing system using the <code>@vitest/coverage-istanbul</code> package. To install the package, run the following command in the terminal:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">yarn<code class="w"> </code>add<code class="w"> </code>-D<code class="w"> </code>@vitest/coverage-istanbul<code class="w"/></pre>&#13;
&#13;
<p>After installing the package, we can configure the <code>test.coverage</code> section in the <code>vite.config.ts</code> file with the provider as <code>istanbul</code><a data-primary="configuring" data-secondary="Vitest" data-type="indexterm" id="id1666"/><a data-primary="Vitest" data-secondary="configuring" data-type="indexterm" id="id1667"/><a data-primary="vite.config.ts file" data-type="indexterm" id="id1668"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** vite.config.ts */</code>&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">defineConfig</code><code class="p">({</code>&#13;
  <code class="c1">//...</code>&#13;
  <code class="nx">test</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="c1">//...</code>&#13;
    <code class="nx">coverage</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">provider</code><code class="o">:</code> <code class="s1">'istanbul'</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p class="pagebreak-before">We also add a new script command in <code>package.json</code> to run the tests with coverage reports:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">//...</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"scripts"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">//...</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"test:coverage"</code><code class="p">:</code><code class="w"> </code><code class="s2">"vite test --coverage"</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>When we run our tests using the command <code>yarn test:coverage</code>, we will see the coverage reports displayed in the terminal, as shown in <a data-type="xref" href="#figure_ch10_coverage-report">Figure 11-13</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_coverage-report">&#13;
<img alt="Coverage report on terminal" src="assets/lvue_1113.png"/>&#13;
<h6><span class="label">Figure 11-13. </span>Coverage report in terminal</h6>&#13;
</div></figure>&#13;
&#13;
<p>The Istanbul report tool will show you the percentage of your code in each file your tests cover during the testing execution process, dividing it into four categories: statements, branches, functions, and lines. It will also inform you of the line numbers of the uncovered code in the last column. For example, in <a data-type="xref" href="#figure_ch10_coverage-report">Figure 11-13</a>, for &#13;
<span class="keep-together"><code>composables/</code></span><code>useFetch.ts</code>, we saw <code>13,18</code> in the <em>Uncovered Lines</em> column, indicating that our test for this file didn’t cover the code in line 13 and line 18.</p>&#13;
&#13;
<p>However, the terminal report is not always readable. For such a purpose, Istanbul will also generate a <code>coverage</code> folder in the <code>test.root</code> directory defined in <code>vite.config.ts</code>, or the root of the project. This folder contains the HTML reports for the coverage, denoted by <code>index.html</code>. You can open this file in the browser to see a prettier and more readable version of the coverage report, as shown in <a data-type="xref" href="#figure_ch10_coverage-report-html">Figure 11-14</a><a data-primary="test.root directory" data-type="indexterm" id="id1669"/><a data-primary="coverage folder" data-type="indexterm" id="id1670"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_coverage-report-html">&#13;
<img alt="Coverage report in HTML" src="assets/lvue_1114.png"/>&#13;
<h6><span class="label">Figure 11-14. </span>Coverage report in HTML</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you set the <code>root</code> to point to the <code>src/tests</code> folder, you should change it to <code>src</code>. Otherwise, Istanbul can’t locate and analyze the source files’ coverage<a data-primary="testing" data-secondary="files and directories for" data-type="indexterm" id="id1671"/><a data-primary="tests folder" data-type="indexterm" id="id1672"/>.</p>&#13;
</div>&#13;
&#13;
<p>The HTML version displays test coverage by folders and files, with their names on the first column, <em>File</em>. The second column, with the progress bar, shows the coverage percentage for each file in colors (green means fully covered, yellow means partly covered, and red means not meeting the acceptance coverage level). The other columns show the coverage breakdown in statements, branches, functions, and lines.</p>&#13;
&#13;
<p>We can click on each folder name to see the breakdown report per file within this folder, such as in <em>/composables</em> in <a data-type="xref" href="#figure_ch10_coverage_composables">Figure 11-15</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_coverage_composables">&#13;
<img alt="Coverage report for composables" src="assets/lvue_1115.png"/>&#13;
<h6><span class="label">Figure 11-15. </span>Coverage report for composables</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">You can click on each file name to see the highlights of untested code lines in red and the number of times a line we covered (like <code>3x</code>), as shown in <a data-type="xref" href="#figure_ch10_coverage_composables-useFetch">Figure 11-16</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_coverage_composables-useFetch">&#13;
<img alt="Coverage report for useFetch" src="assets/lvue_1116.png"/>&#13;
<h6><span class="label">Figure 11-16. </span>Coverage report for useFetch</h6>&#13;
</div></figure>&#13;
&#13;
<p>The HTML report version is also interactive during watch mode, meaning that it will update the coverage report automatically when you change the code or the tests. This mechanism is handy during development, as you can see the coverage report changes in real time<a data-primary="Vitest" data-secondary="watch mode" data-type="indexterm" id="id1673"/><a data-primary="watch mode, Vitest" data-type="indexterm" id="id1674"/>.</p>&#13;
&#13;
<p>We can also set the coverage threshold for each category using the <code>test.coverage</code> section in <code>vite.config.ts</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** vite.config.ts */</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">defineConfig</code><code class="p">({</code>&#13;
  <code class="c1">//...</code>&#13;
  <code class="nx">test</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="c1">//...</code>&#13;
    <code class="nx">coverage</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">provider</code><code class="o">:</code> <code class="s1">'istanbul'</code><code class="p">,</code>&#13;
      <code class="nx">statements</code><code class="o">:</code> <code class="mi">80</code><code class="p">,</code>&#13;
      <code class="nx">branches</code><code class="o">:</code> <code class="mi">80</code><code class="p">,</code>&#13;
      <code class="nx">functions</code><code class="o">:</code> <code class="mi">80</code><code class="p">,</code>&#13;
      <code class="nx">lines</code><code class="o">:</code> <code class="mi">80</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>In this code, we set the coverage threshold for each category to 80%. If the coverage percentage for any type is lower than the threshold, the test will fail with an error message, as seen in <a data-type="xref" href="#figure_ch10_coverage-threshold">Figure 11-17</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_coverage-threshold">&#13;
<img alt="Coverage threshold error" src="assets/lvue_1117.png"/>&#13;
<h6><span class="label">Figure 11-17. </span>Error when a test doesn’t meet the coverage threshold</h6>&#13;
</div></figure>&#13;
&#13;
<p>Code coverage is essential for testing since it provides the benchmark to help you protect your code from bugs and ensure the quality of your application. However, it is just a tool to help you manage your tests, and you still need to write good tests to ensure your code quality and standards.</p>&#13;
<div data-type="tip"><h1>Setting the Threshold Number</h1>&#13;
<p>Try to keep your coverage threshold number between 80% and 85%. It can be overkill if you set it to more than 85%. If less than 80%, it can be too low since you may miss some edge cases that cause bugs in your application<a data-primary="threshold number for code coverage" data-type="indexterm" id="id1675"/>.</p>&#13;
</div>&#13;
&#13;
<p>We have explored unit testing using Vitest and other tools like Vue Test Utils for Vue-specific testing and Istanbul for code coverage. We will move to the next testing level, where we will learn how to write E2E tests for our application using PlaywrightJS<a data-primary="" data-startref="ix-test-unit9" data-type="indexterm" id="id1676"/><a data-primary="" data-startref="ix-test-unit9a" data-type="indexterm" id="id1677"/><a data-primary="" data-startref="ix-test-unit9b" data-type="indexterm" id="id1678"/><a data-primary="" data-startref="ix-test-unit9c" data-type="indexterm" id="id1679"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="End-to-End Testing with PlaywrightJS" data-type="sect1"><div class="sect1" id="id128">&#13;
<h1>End-to-End Testing with PlaywrightJS</h1>&#13;
&#13;
<p><a href="https://oreil.ly/sIUKp">PlaywrightJS</a>, or Playwright, is a fast, reliable cross-browser end-to-end testing framework. It supports programming languages besides JavaScript, such as Python, Java, and C#. It also supports multiple browser rendering engines like  WebKit, Firefox, and Chromium, allowing us to perform testing in cross-browser environments on the same codebase<a data-primary="E2E (end-to-end) testing" data-secondary="with PlaywrightJS" data-secondary-sortas="PlaywrightJS" data-type="indexterm" id="ix-test-unit11"/><a data-primary="PlaywrightJS" data-type="indexterm" id="ix-test-unit11a"/>.</p>&#13;
&#13;
<p>To start using Playwright, run the following command<a data-primary="E2E (end-to-end) testing" data-secondary="setup" data-type="indexterm" id="ix-test-unit12"/>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">yarn<code class="w"> </code>create<code class="w"> </code>Playwright<code class="w"/></pre>&#13;
&#13;
<p>Yarn will run the creation script for Playwright, with the prompts asking for the test location (<code>e2e</code>), if we want to install GitHub Actions as the pipeline tool for CI/CD, and if it should install Playwright browsers. <a data-type="xref" href="#figure_ch10_playwright-creation">Figure 11-18</a> shows an example of a configuration for initializing Playwright in our application<a data-primary="browsers" data-secondary="Playwright setup" data-type="indexterm" id="id1680"/><a data-primary="Continuous Integration/Continuous Deployment (CI/CD)" data-secondary="Playwright setup" data-type="indexterm" id="id1681"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_playwright-creation">&#13;
<img alt="A screenshot of the prompts for initializing Playwright" src="assets/lvue_1118.png"/>&#13;
<h6><span class="label">Figure 11-18. </span>Initializing Playwright with prompts</h6>&#13;
</div></figure>&#13;
&#13;
<p>After the initialization process, we will see a new <code>e2e</code> folder in the root of our project, with a single <code>example.spec.ts</code> file. Also, Playwright will generate a configuration file, <code>playwright.config.ts</code>, for our project, modifying the <code>package.json</code> with the relevant packages and another <code>test-examples</code> folder containing a working test example for a todo component using Playwright<a data-primary="configuring" data-secondary="Playwright" data-type="indexterm" id="id1682"/><a data-primary="e2e folder" data-type="indexterm" id="id1683"/><a data-primary="playwright.config.ts file" data-type="indexterm" id="id1684"/>.</p>&#13;
&#13;
<p>We can now add a new script command in our <code>package.json</code> to run our E2E tests using Playwright:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="nt">"scripts"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">//...</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"test:e2e"</code><code class="p">:</code><code class="w"> </code><code class="s2">"npx playwright test"</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Similarly, we can add the following command to run the coverage reporter on our tests<a data-primary="" data-startref="ix-test-unit10" data-type="indexterm" id="id1685"/><a data-primary="coverage, code" data-secondary="E2E testing with Playwright" data-type="indexterm" id="id1686"/><a data-primary="testing" data-secondary="with coverage runners" data-secondary-sortas="coverage runners" data-type="indexterm" id="id1687"/>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="nt">"scripts"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">//...</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"test:e2e-report"</code><code class="p">:</code><code class="w"> </code><code class="s2">"npx playwright show-report"</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>By default, Playwright comes with an HTML coverage reporter, and this reporter runs when any test fails during the test run. We can try to run the tests using these commands and see the example tests passed.</p>&#13;
&#13;
<p>Let’s look at the <code>playwright.config.ts</code> and see what it contains:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">defineConfig</code><code class="p">,</code> <code class="nx">devices</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@playwright/test'</code><code class="p">;</code>&#13;
&#13;
<code class="cm">/** playwright.config.ts */</code>&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">defineConfig</code><code class="p">({</code>&#13;
  <code class="nx">testDir</code><code class="o">:</code> <code class="s1">'./e2e'</code><code class="p">,</code>&#13;
  <code class="nx">fullyParallel</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nx">forbidOnly</code><code class="o">:</code> <code class="o">!!</code><code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">CI</code><code class="p">,</code>&#13;
  <code class="nx">retries</code><code class="o">:</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">CI</code> <code class="o">?</code> <code class="mi">2</code> <code class="o">:</code> <code class="mi">0</code><code class="p">,</code>&#13;
  <code class="nx">workers</code><code class="o">:</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">CI</code> <code class="o">?</code> <code class="mi">1</code> <code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code>&#13;
  <code class="nx">reporter</code><code class="o">:</code> <code class="s1">'html'</code><code class="p">,</code>&#13;
  <code class="nx">use</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">trace</code><code class="o">:</code> <code class="s1">'on-first-retry'</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">projects</code><code class="o">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nx">name</code><code class="o">:</code> <code class="s1">'chromium'</code><code class="p">,</code>&#13;
      <code class="nx">use</code><code class="o">:</code> <code class="p">{</code> <code class="p">...</code><code class="nx">devices</code><code class="p">[</code><code class="s1">'Desktop Chrome'</code><code class="p">]</code> <code class="p">},</code>&#13;
    <code class="p">},</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nx">name</code><code class="o">:</code> <code class="s1">'webkit'</code><code class="p">,</code>&#13;
      <code class="nx">use</code><code class="o">:</code> <code class="p">{</code> <code class="p">...</code><code class="nx">devices</code><code class="p">[</code><code class="s1">'Desktop Safari'</code><code class="p">]</code> <code class="p">},</code>&#13;
    <code class="p">},</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>The configuration file exports an instance created by the <code>defineConfig()</code> method, based on a set of configuration options with the following main properties<a data-primary="defineConfig(), E2E testing with Playwright" data-type="indexterm" id="id1688"/>:</p>&#13;
<dl>&#13;
<dt><code>testDir</code></dt>&#13;
<dd>&#13;
<p>The directory where we store the tests. We usually define it during the initialization process (<code>e2e</code> in our case)<a data-primary="testDir" data-type="indexterm" id="id1689"/><a data-primary="testing" data-secondary="files and directories for" data-type="indexterm" id="id1690"/>.</p>&#13;
</dd>&#13;
<dt><code>projects</code></dt>&#13;
<dd>&#13;
<p>The list of browser projects for running the tests. We can import <code>devices</code> from the same <code>@playwright/test</code> package and select the relevant setup to define the browser’s configuration for Playwright to <code>use</code>, such as <code>devices[<em>Desktop Chrome</em>]</code> for the Chromium browser<a data-primary="projects configuration option, E2E testing with Playwright" data-type="indexterm" id="id1691"/>.</p>&#13;
</dd>&#13;
<dt><code>worker</code></dt>&#13;
<dd>&#13;
<p>The number of parallel workers to run the tests on. This feature is helpful when we have many tests and need to run them in parallel to speed up the test process<a data-primary="worker configuration option, E2E testing with Playwright" data-type="indexterm" id="id1692"/>.</p>&#13;
</dd>&#13;
<dt><code>use</code></dt>&#13;
<dd>&#13;
<p>The configuration object for the test runner, including an optional <code>baseURL</code> as the base URL and <code>trace</code> to enable the trace recording for failed tests on retry<a data-primary="use configuration option, E2E testing with Playwright" data-type="indexterm" id="id1693"/><a data-primary="URLs (Uniform Resource Locators)" data-secondary="base URL" data-type="indexterm" id="id1694"/><a data-primary="base URLs" data-type="indexterm" id="id1695"/><a data-primary="trace recording, E2E testing with Playwright" data-type="indexterm" id="id1696"/>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Other properties can customize our Playwright test runner as needed. See the complete list of configuration options at the <a href="https://oreil.ly/nXapE">Playwright documentation</a>.</p>&#13;
&#13;
<p>We will leave the file as is and write our first E2E test for our application. Let’s head to the <code>vite.config.ts</code> and make sure we have the following configuration for the local server<a data-primary="" data-startref="ix-test-unit12" data-type="indexterm" id="id1697"/><a data-primary="E2E (end-to-end) testing" data-secondary="writing tests" data-type="indexterm" id="ix-test-unit13"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">//...</code>&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">defineConfig</code><code class="p">({</code>&#13;
  <code class="c1">//...</code>&#13;
  <code class="nx">server</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">port</code><code class="o">:</code> <code class="mi">3000</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>By setting the port to 3000, we ensure our local URL will always be <em>http://localhost:3000</em>. Next, we will create a new E2E test file in the <code>e2e</code> folder with the name <code>PizzasView.spec.ts</code>, dedicated to testing the <em>“/pizzas”</em> page. The <em>“/pizzas”</em> page uses the &#13;
<span class="keep-together"><code>PizzasView</code></span> view component to display a list of pizzas with the following template:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizzas-view--container"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>Pizzas<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">input</code> <code class="na">v-model</code><code class="o">=</code><code class="s">"search"</code> <code class="na">placeholder</code><code class="o">=</code><code class="s">"Search for a pizza"</code> <code class="p">/&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code> <code class="na">v-for</code><code class="o">=</code><code class="s">"pizza in searchResults"</code> <code class="na">:key</code><code class="o">=</code><code class="s">"pizza.id"</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;</code><code class="nt">PizzaCard</code> <code class="na">:pizza</code><code class="o">=</code><code class="s">"pizza"</code> <code class="p">/&gt;</code>&#13;
      <code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code> <code class="na">setup</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">usePizzas</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/composables/usePizzas"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">PizzaCard</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/components/PizzaCard.vue"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useSearch</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/composables/useSearch"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">pizzas</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">usePizzas</code><code class="p">();</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">search</code><code class="p">,</code><code class="w"> </code><code class="nx">searchResults</code><code class="w"> </code><code class="p">}</code><code class="o">:</code><code class="w"> </code><code class="nx">PizzaSearch</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useSearch</code><code class="p">({</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">items</code><code class="o">:</code><code class="w"> </code><code class="nx">pizzas</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">defaultSearch</code><code class="o">:</code><code class="w"> </code><code class="s1">''</code><code class="p">,</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>We want to write the tests for this page. Like Vitest, we start by wrapping the test file with a <code>test.describe()</code> block, where we import <code>test</code> from <code>@playwright/test</code> package. We then ensure the test runner will always navigate to our target page before testing the page content using the <code>test.beforeEach()</code> hook<a data-primary="describe()" data-secondary="E2E testing with Playwright" data-type="indexterm" id="id1698"/><a data-primary="beforeEach hook" data-secondary="E2E testing with Playwright" data-type="indexterm" id="id1699"/><a data-primary="afterEach hook" data-secondary="E2E testing with Playwright" data-type="indexterm" id="id1700"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** e2e/PizzasView.spec.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">expect</code><code class="p">,</code> <code class="nx">test</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@playwright/test'</code><code class="p">;</code>&#13;
&#13;
<code class="nx">test</code><code class="p">.</code><code class="nx">describe</code><code class="p">(</code><code class="s1">'Pizzas View'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">test</code><code class="p">.</code><code class="nx">beforeEach</code><code class="p">(</code><code class="kr">async</code> <code class="p">({</code> <code class="nx">page</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">await</code> <code class="nx">page</code><code class="p">.</code><code class="kr">goto</code><code class="p">(</code><code class="s1">'http://localhost:3000/pizzas'</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We also ensure the page is closed after finishing the tests using the <code>test.afterEach()</code> hook:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** e2e/PizzasView.spec.ts */</code>&#13;
&#13;
<code class="nx">test</code><code class="p">.</code><code class="nx">describe</code><code class="p">(</code><code class="s1">'Pizzas View'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
&#13;
  <code class="nx">test</code><code class="p">.</code><code class="nx">afterEach</code><code class="p">(</code><code class="kr">async</code> <code class="p">({</code> <code class="nx">page</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">await</code> <code class="nx">page</code><code class="p">.</code><code class="nx">close</code><code class="p">();</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We can start writing our first test for the page, such as checking the page title. We can use the <code>page.locator()</code> method to locate the page element. In this case, it is the <code>h1</code> element and asserts its content to be the text <code>Pizzas</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** e2e/PizzasView.spec.ts */</code>&#13;
&#13;
<code class="nx">test</code><code class="p">.</code><code class="nx">describe</code><code class="p">(</code><code class="s1">'Pizzas View'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
&#13;
  <code class="nx">test</code><code class="p">(</code><code class="s1">'should display the page title'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">({</code> <code class="nx">page</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">title</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">page</code><code class="p">.</code><code class="nx">locator</code><code class="p">(</code><code class="s1">'h1'</code><code class="p">);</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="kr">await</code> <code class="nx">title</code><code class="p">.</code><code class="nx">textContent</code><code class="p">()).</code><code class="nx">toBe</code><code class="p">(</code><code class="s1">'Pizzas'</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We can run the test using the <code>yarn test:e2e</code> command and see the test passed (<a data-type="xref" href="#figure_ch10_test_passed_pw">Figure 11-19</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_test_passed_pw">&#13;
<img alt="Passing E2E test with Playwright" src="assets/lvue_1119.png"/>&#13;
<h6><span class="label">Figure 11-19. </span>Test report showing passing E2E tests with Playwright</h6>&#13;
</div></figure>&#13;
&#13;
<p>Great! We can add more tests to the file, such as checking the search functionality. We can locate the search <code>input</code> element using its tag name or the <code>data-testid</code> attribute as a better approach. To use the <code>data-testid</code> attribute, we need to add it to the <code>input</code> in the <code>PizzasView</code> component template<a data-primary="data-testing attribute, E2E testing with Playwright" data-type="indexterm" id="id1701"/><a data-primary="input element" data-secondary="E2E testing with Playwright" data-type="indexterm" id="id1702"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">input</code>&#13;
  <code class="na">v-model</code><code class="o">=</code><code class="s">"search"</code>&#13;
  <code class="na">placeholder</code><code class="o">=</code><code class="s">"Search for a pizza"</code>&#13;
  <code class="na">data-testid</code><code class="o">=</code><code class="s">"search-input"</code>&#13;
<code class="p">/&gt;</code></pre>&#13;
&#13;
<p>Then, we can locate the element using the <code>data-testid</code> attribute in our new test and <code>fill</code> it with the search term <code>Hawaiian</code><a data-primary="" data-startref="ix-test-unit13" data-type="indexterm" id="id1703"/>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** e2e/PizzasView.spec.ts */</code>&#13;
&#13;
<code class="nx">test</code><code class="p">.</code><code class="nx">describe</code><code class="p">(</code><code class="s1">'Pizzas View'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
&#13;
  <code class="nx">test</code><code class="p">(</code><code class="s1">'should search for a pizza'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">({</code> <code class="nx">page</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">searchInput</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">page</code><code class="p">.</code><code class="nx">locator</code><code class="p">(</code><code class="s1">'[data-testid="search-input"]'</code><code class="p">);</code>&#13;
&#13;
    <code class="kr">await</code> <code class="nx">searchInput</code><code class="p">.</code><code class="nx">fill</code><code class="p">(</code><code class="s1">'Hawaiian'</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>To assert the result of the search, we will head to the <code>PizzaCard</code> implementation and add the <code>data-testid</code> attribute to the container element with the value of <code>pizza.title</code>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cm">&lt;!-- src/components/PizzaCard.vue --&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">article</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizza--details-wrapper"</code> <code class="na">:data-testid</code><code class="o">=</code><code class="s">"pizza.title"</code><code class="p">&gt;</code>&#13;
    <code class="cm">&lt;!--...--&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">article</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Back to our <code>PizzasView.spec.ts</code> file, we can assert the visibility of pizza card with the <code>data-testid</code> attribute containing the search term on the page:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** e2e/PizzasView.spec.ts */</code>&#13;
&#13;
<code class="nx">test</code><code class="p">.</code><code class="nx">describe</code><code class="p">(</code><code class="s1">'Pizzas View'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
  <code class="nx">test</code><code class="p">(</code><code class="s1">'should search for a pizza'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">({</code> <code class="nx">page</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">searchInput</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">page</code><code class="p">.</code><code class="nx">locator</code><code class="p">(</code><code class="s1">'[data-testid="search-input"]'</code><code class="p">);</code>&#13;
&#13;
    <code class="kr">await</code> <code class="nx">searchInput</code><code class="p">.</code><code class="nx">fill</code><code class="p">(</code><code class="s1">'Hawaiian'</code><code class="p">);</code>&#13;
&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="kr">await</code> <code class="nx">page</code><code class="p">.</code><code class="nx">isVisible</code><code class="p">(</code><code class="s1">'[data-testid*="Hawaiian"]'</code><code class="p">)).</code><code class="nx">toBeTruthy</code><code class="p">();</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We can rerun the test suite and see the tests passed (<a data-type="xref" href="#figure_ch10_test_passed_pw_2">Figure 11-20</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_test_passed_pw_2">&#13;
<img alt="Passing E2E test with Playwright" src="assets/lvue_1120.png"/>&#13;
<h6><span class="label">Figure 11-20. </span>Test report showing the search tests passed</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can also click on each test displayed in the report to view the test details, including the test steps, their execution time, and any errors that occurred during the test execution in a target browser environment (<a data-type="xref" href="#figure_ch10_test_details_pw">Figure 11-21</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_test_details_pw">&#13;
<img alt="Test details report with Playwright in Chromium" src="assets/lvue_1121.png"/>&#13;
<h6><span class="label">Figure 11-21. </span>Details report for a single test run on Chromium</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You must use <code>await</code> for <code>page.isVisible()</code> method, as it returns a <code>Promise</code>. Otherwise, the test will fail since Playwright will execute the assertion before the <code>isVisible()</code> process returns the result<a data-primary="asynchronous calls" data-secondary="E2E testing with Playwright" data-type="indexterm" id="id1704"/><a data-primary="isVisible()" data-secondary="E2E testing with Playwright" data-type="indexterm" id="id1705"/>.</p>&#13;
</div>&#13;
&#13;
<p>Let’s edit our search test to make it fail by changing the search term to <code>Cheese</code> instead of <code>Hawaiian</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="cm">/** e2e/PizzasView.spec.ts */</code>&#13;
&#13;
<code class="nx">test</code><code class="p">.</code><code class="nx">describe</code><code class="p">(</code><code class="s1">'Pizzas View'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
  <code class="nx">test</code><code class="p">(</code><code class="s1">'should search for a pizza'</code><code class="p">,</code> <code class="kr">async</code> <code class="p">({</code> <code class="nx">page</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">searchInput</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">page</code><code class="p">.</code><code class="nx">locator</code><code class="p">(</code><code class="s1">'[data-testid="search-input"]'</code><code class="p">);</code>&#13;
&#13;
    <code class="kr">await</code> <code class="nx">searchInput</code><code class="p">.</code><code class="nx">fill</code><code class="p">(</code><code class="s1">'Cheese'</code><code class="p">);</code>&#13;
&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="kr">await</code> <code class="nx">page</code><code class="p">.</code><code class="nx">isVisible</code><code class="p">(</code><code class="s1">'[data-testid*="Hawaiian"]'</code><code class="p">)).</code><code class="nx">toBeTruthy</code><code class="p">();</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We can rerun the test suite and see if the test failed (<a data-type="xref" href="#figure_ch10_test_failed_pw">Figure 11-22</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_test_failed_pw">&#13;
<img alt="Failed E2E test with Playwright for a search term" src="assets/lvue_1122.png"/>&#13;
<h6><span class="label">Figure 11-22. </span>Test report showing the search test failed</h6>&#13;
</div></figure>&#13;
&#13;
<p>The report shows which step the test failed. Let’s debug it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Debugging E2E Tests Using Playwright Test Extension &#10;for VSCode" data-type="sect1"><div class="sect1" id="id129">&#13;
<h1>Debugging E2E Tests Using Playwright Test Extension &#13;
<span class="keep-together">for VSCode</span></h1>&#13;
&#13;
<p>We can install the <a href="https://oreil.ly/9zlFB">Playwright Test for VSCode extension</a> to debug a failed test. This extension will add another section on the Testing tab of VSCode, and auto-detect the relevant Playwright tests within the project, as shown in <a data-type="xref" href="#figure_ch10_test_debug_pw_2">Figure 11-23</a><a data-primary="E2E (end-to-end) testing" data-secondary="debugging" data-type="indexterm" id="ix-test-unit14"/><a data-primary="debugging" data-secondary="E2E testing with Playwright Test for VSCode" data-type="indexterm" id="ix-test-unit14a"/><a data-primary="Playwright Test for VSCode" data-type="indexterm" id="ix-test-unit14b"/><a data-primary="VSCode" data-secondary="debugging E2E testing with Playwright" data-type="indexterm" id="ix-test-unit14c"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_test_debug_pw_2">&#13;
<img alt="A screenshot showing the Playwright tests in the project listed in the Testing tab of VSCode" src="assets/lvue_1123.png"/>&#13;
<h6><span class="label">Figure 11-23. </span>Testing tab displays the Playwright tests in the project</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can run the tests or a single test using the actions available on this view. We can also add breakpoints (denoted by the red dot) to debug a target test (<a data-type="xref" href="#figure_ch10_test_debug_pw_3">Figure 11-24</a>)<a data-primary="breakpoints for debugging" data-type="indexterm" id="id1706"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_test_debug_pw_3">&#13;
<img alt="Adding breakpoints to debug a test" src="assets/lvue_1124.png"/>&#13;
<h6><span class="label">Figure 11-24. </span>Adding breakpoints to debug a test</h6>&#13;
</div></figure>&#13;
&#13;
<p>To start debugging, navigate to the search test in the Test Explorer pane and click on the “Debug” icon (<a data-type="xref" href="#figure_ch10_test_debug_pw_4">Figure 11-25</a>). Hovering on the “Debug” icon will display the text “Debug Text.”</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_test_debug_pw_4">&#13;
<img alt="Debugging a test button" src="assets/lvue_1125.png"/>&#13;
<h6><span class="label">Figure 11-25. </span>Run a test in debug mode</h6>&#13;
</div></figure>&#13;
&#13;
<p>Upon running, Playwright will open a browser window (such as Chromium) and execute the test steps. Once the test runner reaches the breakpoint, it will stop and wait for us to continue the execution manually. Then we can hover over the variables to see their values or head to the testing browser to inspect the elements (<a data-type="xref" href="#figure_ch10_test_debug_pw_5">Figure 11-26</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch10_test_debug_pw_5">&#13;
<img alt="Debugging a test" src="assets/lvue_1126.png"/>&#13;
<h6><span class="label">Figure 11-26. </span>Debugging the search test</h6>&#13;
</div></figure>&#13;
&#13;
<p>What’s left is to fix the test and continue the debugging process until the test passes.</p>&#13;
&#13;
<p>We have learned how to create basic E2E tests with Playwright and how to debug them with the help of external tools. Playwright provides many other features, such as generating the test based on the actual interaction with the application or performing accessibility testing with the <code>@axe-core/playwright</code> package. Check out other features and see how Playwright can help create better E2E tests for your application<a data-primary="" data-startref="ix-test-unit11" data-type="indexterm" id="id1707"/><a data-primary="" data-startref="ix-test-unit11a" data-type="indexterm" id="id1708"/><a data-primary="" data-startref="ix-test-unit14" data-type="indexterm" id="id1709"/><a data-primary="" data-startref="ix-test-unit14a" data-type="indexterm" id="id1710"/><a data-primary="" data-startref="ix-test-unit14b" data-type="indexterm" id="id1711"/><a data-primary="" data-startref="ix-test-unit14c" data-type="indexterm" id="id1712"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id366">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter introduced the concept of testing and how to use Vitest as a unit testing tool for Vue applications. We learned how to write basic tests for components and composables with Vitest and Vue Test Utils and how to use external packages such as a coverage runner and Vitest UI for a better UI experience. We also explored creating E2E tests with PlaywrightJS, ensuring code confidence throughout our application.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id1547"><sup><a href="ch11.html#id1547-marker">1</a></sup> If you are new to TDD, start with <a class="orm:hideurl" href="https://oreil.ly/TqUwM"><em>Learning Test-Driven Development</em> by Saleem Siddiqui (O’Reilly)</a>.</p><p data-type="footnote" id="id1566"><sup><a href="ch11.html#id1566-marker">2</a></sup> JSDOM is an open source library that acts as a headless browser that implements the web standards, providing a simulated environment for testing any web-related code.</p></div></div></section></body></html>