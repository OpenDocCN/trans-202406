<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 19. Securing Applications in Kubernetes" data-type="chapter" epub:type="chapter"><div class="chapter" id="securing_pods">
<h1><span class="label">Chapter 19. </span>Securing Applications in Kubernetes</h1>
<p>Providing a secure platform to run your workloads is critical for Kubernetes to be broadly used in production.<a data-primary="security" data-secondary="securing applications in Kubernetes" data-type="indexterm" id="ix_secuapp"/> Thankfully, Kubernetes ships with many different security-focused APIs that allow you to construct a secure operating environment. The challenge is that there are many different security APIs, and you have to declaratively opt-in to use them. Using these security-focused APIs can be cumbersome and convoluted, which makes it difficult to achieve your desired security goals.</p>
<p>It’s important to understand the following two concepts when securing Pods in Kubernetes: defense in depth and principle of least privilege. <em>Defense in depth</em> is a concept where you use multiple layers of security controls across your computing systems that include Kubernetes. The <em>principle of least privilege</em> means giving your workloads access only to resources that are required for them to operate. Both these concepts are not destinations, but constantly applied to the ever-changing computing system landscape.</p>
<p>In this chapter, we will take a look at security-focused Kubernetes APIs that can be incrementally applied to help secure your workloads at the Pod level.</p>
<section data-pdf-bookmark="Understanding SecurityContext" data-type="sect1"><div class="sect1" id="idm45664069992016">
<h1>Understanding SecurityContext</h1>
<p>At the core of securing Pods is SecurityContext, which is an aggregation of all security-focused fields that may be applied at both the Pod and container specification level.<a data-primary="security" data-secondary="securing applications in Kubernetes" data-tertiary="SecurityContext, understanding" data-type="indexterm" id="ix_secuappSCtxt"/><a data-primary="SecurityContext" data-type="indexterm" id="ix_SecCtx"/> Here are some example security controls covered by SecurityContext:</p>
<ul>
<li>
<p>User permissions and access control (e.g., setting User ID and Group ID)</p>
</li>
<li>
<p>Read-only root filesystem</p>
</li>
<li>
<p>Allow privilege escalation</p>
</li>
<li>
<p>Seccomp, AppArmor, and SELinux profile and label assignments</p>
</li>
<li>
<p>Run as privileged or unprivileged</p>
</li>
</ul>
<p>Let’s take a look at an example Pod with a SecurityContext defined in <a data-type="xref" href="#example1901">Example 19-1</a>.</p>
<div data-type="example" id="example1901">
<h5><span class="label">Example 19-1. </span>kuard-pod-securitycontext.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">runAsNonRoot</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">    </code><code class="nt">runAsUser</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1000</code><code class="w"/>
<code class="w">    </code><code class="nt">runAsGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3000</code><code class="w"/>
<code class="w">    </code><code class="nt">fsGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2000</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/kuar-demo/kuard-amd64:blue</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="w">      </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">allowPrivilegeEscalation</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">          </code><code class="nt">readOnlyRootFilesystem</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">          </code><code class="nt">privileged</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">http</code><code class="w"/>
<code class="w">          </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/></pre></div>
<p>You can see in this example that there is a SecurityContext at both the Pod and the container level.<a data-primary="containers" data-secondary="SecurityContext" data-type="indexterm" id="idm45664069916528"/><a data-primary="Pods" data-secondary="SecurityContext" data-type="indexterm" id="idm45664069874384"/> Many of the security controls can be applied at both of these levels. In the case that they are applied in both, the container level configuration takes precedence. <a data-primary="SecurityContext" data-secondary="fields defined in Pod specification" data-type="indexterm" id="idm45664069873376"/>Let’s take a look at fields we have defined in the Pod specification in this example and the impact they have on securing your workload:</p>
<dl>
<dt><code>runAsNonRoot</code></dt>
<dd>
<p>The Pod or container must run as a nonroot user. The container will fail to start if it is running as a root user. Running as a nonroot user is considered best practice as many misconfigurations and exploits happen via the container runtime conflating the container process running as the root user with the host root user.<a data-primary="PodSecurityContext" data-type="indexterm" id="idm45664069870352"/> This can be set at both the PodSecurityContext and the SecurityContext. The kuard container image is configured to run as user “nobody” as defined in the <a href="https://oreil.ly/4IZI7">Dockerfile</a>. It’s always best practice to run your container as a nonroot user; however, if you are running a container downloaded from another source that doesn’t explicitly set the container user, you may have to extend the original Dockerfile to do so. This method doesn’t always work, as the application may have other requirements that needs to be considered.</p>
</dd>
<dt><code>runAsUser/runAsGroup</code></dt>
<dd>
<p>This setting overrides the user and group that the container process is run as. Container images may have this configured as part of the Dockerfile.</p>
</dd>
<dt><code>fsgroup</code></dt>
<dd>
<p>Configures Kubernetes to change the group of all files in a volume when they are mounted into a Pod. An additional field, <code>fsGroupChangePolicy</code>, may be used to configure the exact behavior.</p>
</dd>
<dt><code>allowPrivilegeEscalation</code></dt>
<dd>
<p>Configures whether a process in a container can gain more privileges than its parent. This is a common vector for attack, and it’s important to explicitly set this to false. It’s also important to understand that this will be set to true if <code>privileged: true</code> is set.</p>
</dd>
<dt><code>privileged</code></dt>
<dd>
<p>Runs the container as privileged, which elevates the container to the same permissions as the host.</p>
</dd>
<dt><code>readOnlyRootFilesystem</code></dt>
<dd>
<p>Mounts the container root filesystem to read-only. This is a common attack vector and is best practice to enable. Any data or logs that the workloads need write access to can be mounted via a volume.</p>
</dd>
</dl>
<p>The fields in this example aren’t a complete list of all the security controls available; however, they represent a good starting point when working with SecurityContext. We will cover some more in context later in this chapter.</p>
<p>Let’s now create the Pod by saving this example to a file called <em>kuard-pod-securitycontext.yaml</em>. We will demonstrate how the SecurityContext configuration is being applied to a running Pod.<a data-primary="Pods" data-secondary="Security Context config applied to running Pod" data-type="indexterm" id="idm45664069808976"/> Create the Pod using the following command:</p>
<pre data-type="programlisting">$ <strong>kubectl create -f kuard-pod-securitycontext.yaml</strong>
pod/kuard created</pre>
<p>Now we’ll <a data-primary="shell, starting inside kuard container" data-type="indexterm" id="idm45664069806608"/>start a shell inside the kuard container and check which user ID and group ID the processes are running as:</p>
<pre data-type="programlisting">$ <strong>kubectl exec -it kuard -- ash</strong>
/ $ id
uid=1000 gid=3000 groups=2000
/ $ ps
PID   USER     TIME  COMMAND
    1 1000      0:00 /kuard
   30 1000      0:00 ash
   37 1000      0:00 ps
/ $ touch file
touch: file: Read-only file system</pre>
<p>We can see that the shell that we started, <code>ash</code>, is running as user ID (uid) 1000, group ID (gid) 3000, and is in group 2000. We can also see that the <code>kuard</code> process is running as user 1000 as defined by the SecurityContext in the Pod specification. We also confirmed that we aren’t able to create any new files because the container is read-only. If you only apply the following changes to you workloads, you’re already off to a great start.</p>
<p>We will now introduce several other security controls covered by SecurityContext, which enable even more fine-grained control over what access and privileges your workloads have. First, we will introduce the operating system level security controls and then how to configure them via SecurityContext. It’s important to note that many of these controls are host operating system dependent. This means that they may only apply to containers running on Linux operating systems as opposed to other supported Kubernetes operating systems like Windows.<a data-primary="SecurityContext" data-secondary="core set of operating system controls covered by" data-type="indexterm" id="idm45664069802720"/> Here are a list of the core set of operating system controls that are covered by SecurityContext:</p>
<dl>
<dt>Capabilities</dt>
<dd>
<p>Allow either the addition or removal of groups of privilege that may be required for a workload to operate. For example, your workload may configure the host’s network configuration. Rather than configuring the Pod to be privileged, which is effectively host root access, you could add the specific capability to configure the host networking configuration (NET_ADMIN is the specific capability name). This follows the principal of least privilege.</p>
</dd>
<dt>AppArmor</dt>
<dd>
<p>Controls which files processes can access. AppArmor profiles can be applied to containers via the addition of an annotation of <code>container.apparmor.security.beta.kubernetes.io/&lt;container_name&gt;: &lt;profile_ref&gt;</code> to the Pod specification. Acceptable values for <code>&lt;profile ref&gt;</code> include <code>runtime/default</code>, <code>localhost/&lt;path to profile&gt;</code>, and <code>unconfined</code>. The default is <code>unconfined</code>, which explicitly sets no profile to be applied.</p>
</dd>
<dt>Seccomp</dt>
<dd>
<p>Seccomp (secure computing) profiles allow the creation of syscall filters. These filters allow specific syscalls to be allowed or blocked, which limits the surface area of the Linux kernel that is exposed to the processes in the Pods.</p>
</dd>
<dt>SELinux</dt>
<dd>
<p>Defines access controls for files and processes. SELinux operators use labels that are grouped together to create a security context (not to be mistaken with a Kubernetes SecurityContext), which is used to limit access to a process. By default, Kubernetes allocates a random SELinux context for each container; however, you may choose to set one via SecurityContext.</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Both AppArmor and seccomp have the ability to set the runtime default profile to be used. Each container runtime ships with default AppArmor and seccomp profiles that have been carefully curated to reduce the attack surface area by removing syscalls and file access that are known to be attack vectors or aren’t commonly used by applications. These defaults are rarely workload impacting and offer a great starting point.</p>
</div>
<p>To demonstrate how these security controls are applied to a Pod, we will use a tool called <a href="https://oreil.ly/6ubkU">amicontained</a> (“Am I contained”) written by Jess Frazelle. Save the Pod specification in <a data-type="xref" href="#example1902">Example 19-2</a> to a file called <em>amicontained-pod.yaml</em>. The first Pod has no SecurityContext applied and will be used to show which security controls are applied to a Pod by default. Note that your output may look different because different Kubernetes distributions and managed services provide different defaults.</p>
<div data-type="example" id="example1902">
<h5><span class="label">Example 19-2. </span>amicontained-pod.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">amicontained</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">r.j3ss.co/amicontained:v0.4.9</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">amicontained</code><code class="w"/>
<code class="w">      </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"/bin/sh"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"--"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">      </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"amicontained"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w"/></pre></div>
<p>Create the <code>amicontainer</code> Pod:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f amicontained-pod.yaml</strong>
pod/amicontained created</pre>
<p>Let’s review the Pod logs to examine the output of the <code>amicontained</code> tool:</p>
<pre data-type="programlisting">$ <strong>kubectl logs amicontained</strong>
Container Runtime: kube
Has Namespaces:
	pid: true
	user: false
AppArmor Profile: docker-default (enforce)
Capabilities:
	BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid
	setpcap net_bind_service net_raw sys_chroot mknod audit_write
	setfcap
Seccomp: disabled
Blocked Syscalls (21):
	SYSLOG SETPGID SETSID VHANGUP PIVOT_ROOT ACCT SETTIMEOFDAY UMOUNT2
	SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME INIT_MODULE
	DELETE_MODULE LOOKUP_DCOOKIE KEXEC_LOAD FANOTIFY_INIT
	OPEN_BY_HANDLE_AT FINIT_MODULE KEXEC_FILE_LOAD
Looking for Docker.sock</pre>
<p>From the output above we see that the AppArmor runtime default is being applied. We  also see the capabilities that are allowed by default along with seccomp being disabled. Finally, we see that a total of 21 syscalls are being blocked by default. Now that we have a baseline, let’s apply seccomp, AppArmor, and Capabilities security controls to the Pod specification. Create a file called <em>amicontained-pod-securitycontext.yaml</em> with the contents of <a data-type="xref" href="#example1903">Example 19-3</a>.</p>
<div data-type="example" id="example1903">
<h5><span class="label">Example 19-3. </span>amicontained-pod-securitycontext.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">amicontained</code><code class="w"/>
<code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">container.apparmor.security.beta.kubernetes.io/amicontained</code><code class="p">:</code><code class="w"> </code><code class="s">"runtime/default"</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">runAsNonRoot</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">    </code><code class="nt">runAsUser</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1000</code><code class="w"/>
<code class="w">    </code><code class="nt">runAsGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3000</code><code class="w"/>
<code class="w">    </code><code class="nt">fsGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2000</code><code class="w"/>
<code class="w">    </code><code class="nt">seccompProfile</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RuntimeDefault</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">r.j3ss.co/amicontained:v0.4.9</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">amicontained</code><code class="w"/>
<code class="w">      </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"/bin/sh"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"--"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">      </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"amicontained"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">      </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">capabilities</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">add</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"SYS_TIME"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">            </code><code class="nt">drop</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"NET_BIND_SERVICE"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">        </code><code class="nt">allowPrivilegeEscalation</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">        </code><code class="nt">readOnlyRootFilesystem</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">        </code><code class="nt">privileged</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/></pre></div>
<p>First, we need to delete the existing <code>amicontained</code> Pod:</p>
<pre data-type="programlisting">$ <strong>kubectl delete pod amicontained</strong>
pod "amicontained" deleted</pre>
<p>Now we can create the new Pod with the SecurityContext applied. We are specifically declaring that the runtime default AppArmor and seccomp profiles be applied. In addition, we have added and dropped a Capability:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f amicontained-pod-securitycontext.yaml</strong>
pod/amicontained created</pre>
<p>Let’s again review the Pod logs to examine the output of the <code>amicontained</code> tool:</p>
<pre data-type="programlisting">$ <strong>kubectl logs amicontained</strong>
Container Runtime: kube
Has Namespaces:
	pid: true
	user: false
AppArmor Profile: docker-default (enforce)
Capabilities:
	BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid setpcap
	net_raw sys_chroot sys_time mknod audit_write setfcap
Seccomp: filtering
Blocked Syscalls (67):
	SYSLOG SETUID SETGID SETPGID SETSID SETREUID SETREGID SETGROUPS
	SETRESUID SETRESGID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT_SYSCTL ACCT
	SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME
	SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE
	GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG
	AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE VSERVER MBIND SET_MEMPOLICY
	GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES
	FUTIMESAT UNSHARE MOVE_PAGES PERF_EVENT_OPEN FANOTIFY_INIT
	NAME_TO_HANDLE_AT OPEN_BY_HANDLE_AT SETNS PROCESS_VM_READV
	PROCESS_VM_WRITEV KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD
	PKEY_MPROTECT PKEY_ALLOC PKEY_FREE
Looking for Docker.sock</pre>
<section data-pdf-bookmark="SecurityContext Challenges" data-type="sect2"><div class="sect2" id="idm45664069611552">
<h2>SecurityContext Challenges</h2>
<p>As you can see, there is a lot to understand to use a SecurityContext, and it is not easy to apply a baseline set of security controls by directly configuring all fields of every Pod.<a data-primary="SecurityContext" data-secondary="challenges" data-type="indexterm" id="idm45664069610096"/><a data-primary="security" data-secondary="securing applications in Kubernetes" data-tertiary="SecurityContext challenges" data-type="indexterm" id="idm45664069609120"/> The creation and management of AppArmor, seccomp, and SELinux profiles and contexts is not easy and is error prone. The cost of an error is breaking the ability for an application to perform its function. There are several tools out there that create a way to generate a seccomp profile from a running Pod, which can then be applied using SecurityContext. One such project is the <a href="https://oreil.ly/grPCN">Security Profiles Operator</a>, which makes it easy to generate and manage Seccomp profiles. We will now take a look at other security APIs that make the management of how SecurityContext is applied consistent across a cluster.<a data-primary="SecurityContext" data-startref="ix_SecCtx" data-type="indexterm" id="idm45664069607040"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Pod Security" data-type="sect1"><div class="sect1" id="idm45664069991104">
<h1>Pod Security</h1>
<p>Now that we’ve taken a look at SecurityContext as a way to manage security controls applied to Pods and containers, we will cover how to make sure that a set of Securi⁠ty​Context values are applied at scale. <a data-primary="SecurityContext" data-secondary="values applied at scale" data-seealso="Pod Security" data-type="indexterm" id="idm45664069604624"/><a data-primary="Pod Security" data-type="indexterm" id="ix_Podsec"/><a data-primary="security" data-secondary="securing applications in Kubernetes" data-tertiary="Pod Security" data-type="indexterm" id="ix_secuappPod"/>Kubernetes has a now-deprecated PodSecurityPolicy (PSP) API, which enabled both validation and mutation. <em>Validation</em> will not allow the creation of Kubernetes resources unless they have a specific SecurityContext applied. <em>Mutation</em>, on the other hand, will change Kubernetes resources and apply a specific SecurityContext based on criteria applied via the PSP. Given that PSP is deprecated and will be removed in Kubernetes v1.25, we will not cover it in depth but will instead cover its successor, Pod Security. One of the main differences between Pod Security and its predecessor is that Pod Security only performs validation and not mutation. If you want to learn more about mutation, we encourage you to take a look at <a data-type="xref" href="ch20.xhtml#policy_and_governance_for_kubernetes_clusters">Chapter 20</a>.</p>
<section data-pdf-bookmark="What Is Pod Security?" data-type="sect2"><div class="sect2" id="idm45664069598944">
<h2>What Is Pod Security?</h2>
<p>Pod Security allows you to declare different security profiles for Pods.<a data-primary="Pod Security" data-secondary="about" data-type="indexterm" id="idm45664069597376"/> These security profiles are known as Pod Security Standards and are applied at the namespace level. Pod Security Standards are a collection of security-sensitive fields in a Pod specification (including, but not limited to, SecurityContext) and their associated values. There are three different standards that range from restricted to permissive. The idea is that you can apply a general security posture to all Pods in a given namespace.<a data-primary="Pod Security" data-secondary="standards" data-type="indexterm" id="idm45664069596272"/> The three Pod Security Standards are as follows:</p>
<dl>
<dt>Baseline</dt>
<dd>
<p>Most common privilege escalation while enabling easier onboarding.</p>
</dd>
<dt>Restricted</dt>
<dd>
<p>Highly restricted, covering security best practices. May cause workloads to break.</p>
</dd>
<dt>Privileged</dt>
<dd>
<p>Open and unrestricted.</p>
</dd>
</dl>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Pod Security is currently a beta feature as of Kubernetes v1.23 and may be subject to change.</p>
</div>
<p>Each Pod Security Standard defines a list of fields in the Pod specification and their allowed values. Here are some fields that are covered by these standards:</p>
<ul>
<li>
<p><code>spec.securityContext</code></p>
</li>
<li>
<p><code>spec.containers[*].securityContext</code></p>
</li>
<li>
<p><code>spec.containers[*].ports</code></p>
</li>
<li>
<p><code>spec.volumes[*].hostPath</code></p>
</li>
</ul>
<p>You can view the complete list of fields covered by each of the Pod Security Standards in the <a href="https://oreil.ly/xPK2p">offical documentation</a>.</p>
<p>Each standard is applied to a namespace using a given mode. There are three modes a policy may be applied to.<a data-primary="Enforce mode (Pod Security Standard)" data-type="indexterm" id="idm45664069444864"/> They are as follows:</p>
<dl>
<dt>Enforce</dt>
<dd>
<p>Any Pods that violate the policy will be denied.</p>
</dd>
<dt>Warn</dt>
<dd>
<p>Any Pods that violate the policy will be allowed, and a warning message will be displayed to the user.<a data-primary="Warn mode (Pod Security Standard)" data-type="indexterm" id="idm45664069440784"/></p>
</dd>
<dt>Audit</dt>
<dd>
<p>Any Pods that violate the policy will generate an audit message in the audit log.<a data-primary="Audit mode (Pod Security Standard)" data-type="indexterm" id="idm45664069438832"/></p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Applying Pod Security Standards" data-type="sect2"><div class="sect2" id="idm45664069437904">
<h2>Applying Pod Security Standards</h2>
<p>Pod Security Standards are applied to a namespace using labels<a data-primary="labels" data-secondary="using to apply Pod Security Standards" data-type="indexterm" id="idm45664069436304"/><a data-primary="Pod Security" data-secondary="applying Pod Security Standards" data-type="indexterm" id="ix_Podsecstnd"/> as follows:</p>
<ul>
<li>
<p>Required: <code>pod-security.kubernetes.io/&lt;MODE&gt;: &lt;LEVEL&gt;</code></p>
</li>
<li>
<p>Optional: <code>pod-security.kubernetes.io/&lt;MODE&gt;-version: &lt;VERSION&gt;</code> (defaults to latest)</p>
</li>
</ul>
<p>The namespace in <a data-type="xref" href="#example1904">Example 19-4</a> illustrates how you may use multiple modes to enforce at one standard (baseline in this example) and audit and warn at another (restricted). Using multiple modes allows you to deploy a policy with a lower security posture and audit which workloads violate a standard with a more restricted policy. You can then remediate the policy violations before enforcing the more restricted standard. You can also pin a mode to a specific version, e.g., v1.22. This allows the policy standards to change with each Kubernetes release and allows you to pin a specific version. In <a data-type="xref" href="#example1904">Example 19-4</a>, we are enforcing the baseline standard and both warning and auditing the restricted standard. All modes are pinned to v1.22 of the standard.</p>
<div data-type="example" id="example1904">
<h5><span class="label">Example 19-4. </span>baseline-ns.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespace</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">baseline-ns</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/enforce</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">baseline</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/enforce-version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1.22</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/audit</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">restricted</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/audit-version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1.22</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/warn</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">restricted</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/warn-version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1.22</code><code class="w"/></pre></div>
<p>Deploying a policy for the first time can be a daunting task. Thankfully, Pod Security has made it easy to see which existing workloads violate a Pod Security Standard with a single dry-run command:</p>
<pre data-type="programlisting">$ <strong>kubectl label --dry-run=server --overwrite ns \
  --all pod-security.kubernetes.io/enforce=baseline</strong>
Warning: kuard: privileged
namespace/default labeled
namespace/kube-node-lease labeled
namespace/kube-public labeled
Warning: kube-proxy-vxjwb: host namespaces, hostPath volumes, privileged
Warning: kube-proxy-zxqzz: host namespaces, hostPath volumes, privileged
Warning: kube-apiserver-kind-control-plane: host namespaces, hostPath volumes
Warning: etcd-kind-control-plane: host namespaces, hostPath volumes
Warning: kube-controller-manager-kind-control-plane: host namespaces, ...
Warning: kube-scheduler-kind-control-plane: host namespaces, hostPath volumes
namespace/kube-system labeled
namespace/local-path-storage labeled</pre>
<p>This command evaluates all Pods on a Kubernetes cluster against the baseline Pod Security Standard and reports violations as warning messages in the output.</p>
<p>Let’s see Pod Security in action. Create a file called <em>baseline-ns.yaml</em> with the content in <a data-type="xref" href="#example1905">Example 19-5</a>.</p>
<div data-type="example" id="example1905">
<h5><span class="label">Example 19-5. </span>baseline-ns.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespace</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">baseline-ns</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/enforce</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">baseline</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/enforce-version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1.22</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/audit</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">restricted</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/audit-version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1.22</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/warn</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">restricted</code><code class="w"/>
<code class="w">    </code><code class="nt">pod-security.kubernetes.io/warn-version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1.22</code><code class="w"/></pre></div>
<pre data-type="programlisting">$ <strong>kubectl apply -f baseline-ns.yaml</strong>
namespace/baseline-ns created</pre>
<p>Create a file called <em>kuard-pod.yaml</em> with the content in <a data-type="xref" href="#example1906">Example 19-6</a>.</p>
<div data-type="example" id="example1906">
<h5><span class="label">Example 19-6. </span>kuard-pod.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/kuar-demo/kuard-amd64:blue</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">http</code><code class="w"/>
<code class="w">          </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/></pre></div>
<p>Create the Pod and review the output with the following command:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f kuard-pod.yaml --namespace baseline-ns</strong>
Warning: would violate "v1.22" version of "restricted" PodSecurity profile:
allowPrivilegeEscalation != false (container "kuard" must set
securityContext.allowPrivilegeEscalation=false), unrestricted capabilities
(container "kuard" must set securityContext.capabilities.drop=["ALL"]),
runAsNonRoot != true (pod or container "kuard" must set securityContext.
runAsNonRoot=true), seccompProfile (pod or container "kuard" must set
securityContext.seccompProfile.type to "RuntimeDefault" or "Localhost")
pod/kuard created</pre>
<p>In this output, you can see that the Pod was successfully created; however, it violated the restricted Pod Security Standard, and the details of the violations are provided in the output so that you can remediate. We can also see the message in the API server audit log because we configured the audit mode:</p>
<pre data-type="programlisting">{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"...</pre>
<p>Pod Security is a great way to manage the security posture of your workloads by applying policy at the namespace level and allowing Pods to be created only if they don’t violate the policy. It’s flexible and offers different prebuilt policies from permissive to restricted along with tooling to easily roll out policy changes without the risk of breaking workloads.<a data-primary="Pod Security" data-secondary="applying Pod Security Standards" data-startref="ix_Podsecstnd" data-type="indexterm" id="idm45664069160576"/><a data-primary="Pod Security" data-startref="ix_Podsec" data-type="indexterm" id="idm45664069159360"/><a data-primary="security" data-secondary="securing applications in Kubernetes" data-startref="ix_secuappPod" data-tertiary="Pod Security" data-type="indexterm" id="idm45664069158416"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Service Account Management" data-type="sect1"><div class="sect1" id="idm45664069156832">
<h1>Service Account Management</h1>
<p>Service accounts are Kubernetes resources that provide an identity to workloads that run inside Pods.<a data-primary="service accounts" data-secondary="management of" data-type="indexterm" id="idm45664069155104"/><a data-primary="RBAC (role-based access control)" data-secondary="application to service accounts" data-type="indexterm" id="idm45664069154128"/><a data-primary="security" data-secondary="securing applications in Kubernetes" data-tertiary="service account management" data-type="indexterm" id="idm45664069153248"/> RBAC can be applied to service accounts to control what resources, via the Kubernetes API, the identity has access to. Please see <a data-type="xref" href="ch14.xhtml#chapterbac_id">Chapter 14</a> to learn more. If your application doesn’t require access to the Kubernetes API, you should disable access following the least privilege principal. By default, Kubernetes creates a default service account in each namespace, which is automatically set as the service account for all Pods. This service account contains a token that is automounted in each Pod and is used to access the Kubernetes API. To disable this behavior, you must add <code>automountServiceAccountToken: false</code> to the service account configuration. <a data-type="xref" href="#example1907">Example 19-7</a> demonstrates how this can be done for the default service account. This must be done in each namespace.</p>
<div data-type="example" id="example1907">
<h5><span class="label">Example 19-7. </span>service-account.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>
<code class="nt">automountServiceAccountToken</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/></pre></div>
<p>Service accounts are often overlooked when considering Pod security; however, they allow direct access to the Kubernetes API and, without adequate RBAC, could allow an attacker access to Kubernetes. It’s important to understand how to limit access by making a simple change to how service account tokens are handled.</p>
</div></section>
<section data-pdf-bookmark="Role-Based Access Control" data-type="sect1"><div class="sect1" id="idm45664069099088">
<h1>Role-Based Access Control</h1>
<p>We would be remiss not to mention Kubernetes role-based access control (RBAC) in a chapter about securing Pods.<a data-primary="security" data-secondary="securing applications in Kubernetes" data-tertiary="RBAC" data-type="indexterm" id="idm45664069097824"/> Everything you need to know about RBAC can be found in <a data-type="xref" href="ch14.xhtml#chapterbac_id">Chapter 14</a> and can be applied to complement you workload’s security posture.</p>
</div></section>
<section data-pdf-bookmark="RuntimeClass" data-type="sect1"><div class="sect1" id="idm45664069087136">
<h1>RuntimeClass</h1>
<p>Kubernetes interacts with the container runtime on the node’s operating system via the Container Runtime Interface (CRI).<a data-primary="security" data-secondary="securing applications in Kubernetes" data-tertiary="RuntimeClass" data-type="indexterm" id="ix_secuappRunCls"/><a data-primary="RuntimeClass" data-type="indexterm" id="ix_RunCls"/><a data-primary="CRI (Container Runtime Interface)" data-type="indexterm" id="idm45664069083168"/> The creation and standardization of this interface has allowed for an ecosystem of container runtimes to exist. These container runtimes may offer different levels of isolation, which include stronger security guarantees based on how they are implemented. Projects like Kata Containers, Firecracker, and gVisor are based on different isolation mechanisms from nested virtualization to more sophisticated syscall filtering. These security and isolation guarantees provide a Kubernetes administrator the flexibility to allow users to select a container runtime based on their workload type. For example, if your workload needs stronger security guarantees, then you can choose to run in a Pod that uses a different container runtime.</p>
<p>The RuntimeClass API was introduced to allow container runtime selection.<a data-primary="containers" data-secondary="runtime selection" data-type="indexterm" id="idm45664069082016"/> It allows users to select one of a supported list of container runtimes in the cluster. <a data-type="xref" href="#fig1901">Figure 19-1</a> depicts how RuntimeClass functions.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Different RuntimeClasses must be configured by a cluster administrator and may required specific <code>nodeSelectors</code> or <code>tolerations</code> on your workload to be scheduled to the correct node.</p>
</div>
<figure><div class="figure" id="fig1901">
<img alt="kur3 1901" height="838" src="assets/kur3_1901.png" width="846"/>
<h6><span class="label">Figure 19-1. </span><code>RuntimeClass</code> flow diagram</h6>
</div></figure>
<p>You can use a RuntimeClass by specifying <code>runtimeClassName</code> in the Pod specification. <a data-type="xref" href="#example1912">Example 19-8</a> is an example Pod that specifies a RuntimeClass.</p>
<div data-type="example" id="example1912">
<h5><span class="label">Example 19-8. </span>kuard-pod-runtimeclass.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">runtimeClassName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">firecracker</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/kuar-demo/kuard-amd64:blue</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">http</code><code class="w"/>
<code class="w">          </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/></pre></div>
<p>RuntimeClass allows users to select different container runtimes that may have different security isolation. Using RuntimeClass can help complement the overall security of your workloads, especially if workloads are processing sensitive information or running untrusted code.<a data-primary="security" data-secondary="securing applications in Kubernetes" data-startref="ix_secuappRunCls" data-tertiary="RuntimeClass" data-type="indexterm" id="idm45664069017120"/><a data-primary="RuntimeClass" data-startref="ix_RunCls" data-type="indexterm" id="idm45664068950688"/></p>
</div></section>
<section data-pdf-bookmark="Network Policy" data-type="sect1"><div class="sect1" id="idm45664068949648">
<h1>Network Policy</h1>
<p>Kubernetes also has a Network Policy API that allows you to create both ingress and egress network policies for your workload.<a data-primary="security" data-secondary="securing applications in Kubernetes" data-tertiary="Network Policy" data-type="indexterm" id="ix_secuappNetPol"/><a data-primary="Network Policy" data-type="indexterm" id="ix_NetPol"/> Network policies are configured using labels that allow you to select specific Pods and define how they can communicate with other Pods and endpoints. A Network Policy like Ingress doesn’t actually ship with an associated Kubernetes controller. This means that you can create Network Policy resources but if you haven’t installed a controller that acts upon the creation of Network Policy resources, then they will not be enforced. Network Policy resources are implemented by network plug-ins, such as Calico, Cilium, and Weave Net.</p>
<p>The Network Policy resource is namespaced and is structured with the <code>podSelector</code>, <code>policyTypes</code>, <code>ingress</code>, and <code>egress</code> sections with the only required field being <code>pod​Se⁠lector</code>. If the <code>podSelector</code> field is empty, the policy matches all Pods in a namespace. This field may also contain a <code>matchLabels</code> section, which functions in the same way as a Service resource, allowing you to add a set of labels to match a specific set of Pods.</p>
<p>There are several idiosyncrasies when using Network Policy that you need to be aware of. If a Pod is matched by any Network Policy resource, then any ingress or egress communication must be explicitly defined, otherwise it will be blocked. If a Pod matches multiple Network Policy resources, then the policies are additive. If a Pod isn’t matched by any Network Policy, then traffic is allowed. This decision was intentionally made to ease onboarding of new workloads. If you do, however, want all traffic to be blocked by default, you can create a default deny rule per namespace. <a data-type="xref" href="#example1908">Example 19-9</a> shows a default deny rule that can be applied per namespace.</p>
<div data-type="example" id="example1908">
<h5><span class="label">Example 19-9. </span>networkpolicy-default-deny.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NetworkPolicy</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default-deny-ingress</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/>
<code class="w">  </code><code class="nt">policyTypes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">Ingress</code><code class="w"/></pre></div>
<p>Let’s walk through an example set of network policies to demonstrate how you can use them to secure your workloads. First, create a namespace to test using the following command:</p>
<pre data-type="programlisting">$ <strong>kubectl create ns kuard-networkpolicy</strong>
namespace/kuard-networkpolicy created</pre>
<p>Create a file named <em>kuard-pod.yaml</em> with the contents of <a data-type="xref" href="#example1909">Example 19-10</a>.</p>
<div data-type="example" id="example1909">
<h5><span class="label">Example 19-10. </span>kuard-pod.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/kuar-demo/kuard-amd64:blue</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">http</code><code class="w"/>
<code class="w">          </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/></pre></div>
<p>Create the <code>kuard</code> Pod in the <code>kuard-networkpolicy</code> namespace:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f kuard-pod.yaml \
  --namespace kuard-networkpolicy</strong>
pod/kuard created</pre>
<p>Expose the <code>kuard</code> Pod as a service:</p>
<pre data-type="programlisting">$ <strong>kubectl expose pod kuard --port=80 --target-port=8080 \
  --namespace kuard-networkpolicy</strong>
pod/kuard created</pre>
<p>Now we can use <code>kubectl run</code> to spin up a Pod to test as our source and test access to the <code>kuard</code> Pod without applying any Network Policy:</p>
<pre data-type="programlisting">$ <strong>kubectl run test-source --rm -ti --image busybox /bin/sh \
  --namespace kuard-networkpolicy</strong>
If you don't see a command prompt, try pressing enter.
/ # wget -q kuard -O -
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;

  &lt;title&gt;&lt;KUAR Demo&gt;&lt;/title&gt;
...
</pre>
<p>We can successfully connect to the <code>kuard</code> Pod from our test-source Pod. Now let’s apply a default deny policy and test again. Create a file called <em>networkpolicy-default-deny.yaml</em> with the contents of <a data-type="xref" href="#example1910">Example 19-11</a>.</p>
<div data-type="example" id="example1910">
<h5><span class="label">Example 19-11. </span>networkpolicy-default-deny.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NetworkPolicy</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default-deny-ingress</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/>
<code class="w">  </code><code class="nt">policyTypes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">Ingress</code><code class="w"/></pre></div>
<p>Now apply the default deny network policy:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f networkpolicy-default-deny.yaml \
  --namespace kuard-networkpolicy</strong>
networkpolicy.networking.k8s.io/default-deny-ingress created</pre>
<p>Now let’s test access to the <code>kuard</code> Pod from the test-source Pod:</p>
<pre data-type="programlisting">$ <strong>kubectl run test-source --rm -ti --image busybox /bin/sh \
  --namespace kuard-networkpolicy</strong>
If you don't see a command prompt, try pressing enter.
/ # wget -q --timeout=5 kuard -O -
wget: download timed out
</pre>
<p>We can no longer access the <code>kuard</code> Pod from the test-source Pod due to the default deny Network Policy. Create a Network Policy that allows access from the test-source to the <code>kuard</code> Pod. Create a file called <em>networkpolicy-kuard-allow-test-source.yaml</em> with the contents of <a data-type="xref" href="#example1911">Example 19-12</a>.</p>
<div data-type="example" id="example1911">
<h5><span class="label">Example 19-12. </span>networkpolicy-kuard-allow-test-source.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">NetworkPolicy</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">access-kuard</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard</code><code class="w"/>
<code class="w">  </code><code class="nt">ingress</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">from</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">podSelector</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">run</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">test-source</code><code class="w"/></pre></div>
<p>Apply the Network Policy:</p>
<pre data-type="programlisting">$ <strong>kubectl apply \
  -f code/chapter-security/networkpolicy-kuard-allow-test-source.yaml \
  --namespace kuard-networkpolicy</strong>
networkpolicy.networking.k8s.io/access-kuard created</pre>
<p>Again, verify that the test-source Pod can indeed access the <code>kuard</code> Pod:</p>
<pre data-type="programlisting">$ <strong>kubectl run test-source --rm -ti --image busybox /bin/sh \
  --namespace kuard-networkpolicy</strong>
If you don't see a command prompt, try pressing enter.
/ # wget -q kuard -O -
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;

  &lt;title&gt;&lt;KUAR Demo&gt;&lt;/title&gt;
...
</pre>
<p>Clean up the namespace by running the following command:</p>
<pre data-type="programlisting">$ <strong>kubectl delete namespace kuard-networkpolicy</strong>
namespace "kuard-networkpolicy" deleted</pre>
<p>Applying Network Policy provides an extra layer of security for your workloads and continues to build on the defense in depth and principle of least privilege concepts.<a data-primary="security" data-secondary="securing applications in Kubernetes" data-startref="ix_secuappNetPol" data-tertiary="Network Policy" data-type="indexterm" id="idm45664068619152"/><a data-primary="Network Policy" data-startref="ix_NetPol" data-type="indexterm" id="idm45664068617776"/></p>
</div></section>
<section data-pdf-bookmark="Service Mesh" data-type="sect1"><div class="sect1" id="idm45664068948736">
<h1>Service Mesh</h1>
<p>Service mesh can also be used to increase your workload’s security posture. Service meshes offer access policies, which allow the configuration of protocol-aware policies based on services.<a data-primary="service meshes" data-secondary="increasing security with" data-type="indexterm" id="idm45664068615936"/> For example, your access policy might declare that ServiceA connects to ServiceB via HTTPS on port 443. In addition, service meshes typically implement mutual TLS on all service-to-service communication, which means that not only is the communication encrypted but the service identities are also verified. If you would like to learn more about service meshes and how they can be used to secure your workloads, check out <a data-type="xref" href="ch15.xhtml#service_mesh">Chapter 15</a>.</p>
</div></section>
<section data-pdf-bookmark="Security Benchmark Tools" data-type="sect1"><div class="sect1" id="idm45664068613808">
<h1>Security Benchmark Tools</h1>
<p>There are several open source tools that allow you to run a suite of security benchmarks against your Kubernetes cluster to determine if your configuration meets a predefined set of security baselines.<a data-primary="security" data-secondary="securing applications in Kubernetes" data-tertiary="security benchmark tools" data-type="indexterm" id="idm45664068612048"/> Once such tool is called <a href="https://oreil.ly/TnUlm"><code>kube-bench</code></a>. <code>kube-bench</code> can be used to run the <a href="https://oreil.ly/VvUe5">CIS Benchmarks</a> for Kubernetes. Tools like <code>kube-bench</code> running the CIS Benchmarks aren’t specifically focused on Pod security; however, they can certainly expose any cluster misconfigurations and help identify remediations. <code>kube-bench</code> can be run using the following command:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f https://raw.githubusercontent.com/aquasecurity/kube-bench...</strong>
job.batch/kube-bench created</pre>
<p class="pagebreak-before less_space">You can then review the benchmark output and remediations via the Pod logs:</p>
<pre data-type="programlisting">$ <strong>kubectl logs job/kube-bench</strong>
[INFO] 4 Worker Node Security Configuration
[INFO] 4.1 Worker Node Configuration Files
[PASS] 4.1.1 Ensure that the kubelet service file permissions are set to 644...
[PASS] 4.1.2 Ensure that the kubelet service file ownership is set to root  ...
[PASS] 4.1.3 If proxy kubeconfig file exists ensure permissions are set to  ...
[PASS] 4.1.4 Ensure that the proxy kubeconfig file ownership is set to root ...
[PASS] 4.1.5 Ensure that the --kubeconfig kubelet.conf file permissions are ...
[PASS] 4.1.6 Ensure that the --kubeconfig kubelet.conf file ownership is set...
[PASS] 4.1.7 Ensure that the certificate authorities file permissions are   ...
[PASS] 4.1.8 Ensure that the client certificate authorities file ownership  ...
[PASS] 4.1.9 Ensure that the kubelet --config configuration file has permiss...
[PASS] 4.1.10 Ensure that the kubelet --config configuration file ownership ...
[INFO] 4.2 Kubelet
[PASS] 4.2.1 Ensure that the anonymous-auth argument is set to false (Automated)
[PASS] 4.2.2 Ensure that the --authorization-mode argument is not set to    ...
[PASS] 4.2.3 Ensure that the --client-ca-file argument is set as appropriate...
[PASS] 4.2.4 Ensure that the --read-only-port argument is set to 0 (Manual)
[PASS] 4.2.5 Ensure that the --streaming-connection-idle-timeout argument is...
[FAIL] 4.2.6 Ensure that the --protect-kernel-defaults argument is set to   ...
[PASS] 4.2.7 Ensure that the --make-iptables-util-chains argument is set to ...
[PASS] 4.2.8 Ensure that the --hostname-override argument is not set (Manual)
[WARN] 4.2.9 Ensure that the --event-qps argument is set to 0 or a level    ...
[WARN] 4.2.10 Ensure that the --tls-cert-file and --tls-private-key-file arg...
[PASS] 4.2.11 Ensure that the --rotate-certificates argument is not set to  ...
[PASS] 4.2.12 Verify that the RotateKubeletServerCertificate argument is set...
[WARN] 4.2.13 Ensure that the Kubelet only makes use of Strong Cryptographic...

== Remediations node ==
4.2.6 If using a Kubelet config file, edit the file to set protectKernel...
If using command line arguments, edit the kubelet service file
/etc/systemd/system/kubelet.service.d/10-kubeadm.conf on each worker node and
set the below parameter in KUBELET_SYSTEM_PODS_ARGS variable.
--protect-kernel-defaults=true
Based on your system, restart the kubelet service. For example:
systemctl daemon-reload
systemctl restart kubelet.service

4.2.9 If using a Kubelet config file, edit the file to set eventRecordQPS...
If using command line arguments, edit the kubelet service file
/etc/systemd/system/kubelet.service.d/10-kubeadm.conf on each worker node and
set the below parameter in KUBELET_SYSTEM_PODS_ARGS variable.
Based on your system, restart the kubelet service. For example:
systemctl daemon-reload
systemctl restart kubelet.service
...
</pre>
<p>Using tools like <code>kube-bench</code> with the CIS benchmarks can help identify whether your Kubernetes cluster meets a security baseline and provide remediations if needed.</p>
</div></section>
<section data-pdf-bookmark="Image Security" data-type="sect1"><div class="sect1" id="idm45664068545664">
<h1>Image Security</h1>
<p>Another important part of Pod security is keeping the code and application within the Pod secure.<a data-primary="security" data-secondary="securing applications in Kubernetes" data-tertiary="container image security" data-type="indexterm" id="idm45664068544192"/><a data-primary="container images" data-secondary="security" data-type="indexterm" id="idm45664068543072"/> Securing an application’s code is a complex topic
beyond the scope of this chapter; however, the basics for container image security include making sure that your container image registry is doing
<em>static scanning</em> for known code vulnerabilities.<a data-primary="runtime scanning" data-type="indexterm" id="idm45664068541616"/><a data-primary="static scanning" data-type="indexterm" id="idm45664068540912"/> Additionally, you should
have a tool for doing <em>runtime scanning</em> that identifies vulnerabilities
that have been discovered after an image started running and also looks
for potentially malicious activity like intrusions. There are many scanning
tools provided by both open source and proprietary companies. In addition
to security scanning, focusing on minimizing the contents of your container
image to remove unnecessary dependencies minimizes the noise from this
scanning. Finally, image security is another great reason to invest in continuous delivery so that you can rapidly patch and redeploy an image when
vulnerabilities are found.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45664068539536">
<h1>Summary</h1>
<p>In this chapter, we covered many different security-focused APIs and resources that can be used to improve the security posture of your workloads. By practicing defense in depth and principle of least privilege, you can incrementally improve the baseline security of your Kubernetes cluster. It’s never too late to start practicing better security, and this chapter provides everything you need to be confident that you have an understanding of the security controls Kubernetes offers.<a data-primary="security" data-secondary="securing applications in Kubernetes" data-startref="ix_secuapp" data-type="indexterm" id="idm45664068538208"/></p>
</div></section>
</div></section></div></body></html>