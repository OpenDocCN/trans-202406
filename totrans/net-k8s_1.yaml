- en: Chapter 1\. Networking Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 网络介绍
- en: “Guilty until proven innocent.” That’s the mantra of networks and the engineers
    who supervise them. In this opening chapter, we will wade through the development
    of networking technologies and standards, give a brief overview of the dominant
    theory of networking, and introduce our Golang web server that will be the basis
    of the networking examples in Kubernetes and the cloud throughout the book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “有罪直到证明无罪。” 这是网络及其监督者的口头禅。 在本章的开篇中，我们将浏览网络技术和标准的发展，简要介绍网络的主要理论，并介绍我们的Golang
    Web服务器，这将是本书中Kubernetes和云中网络示例的基础。
- en: Let’s begin…at the beginning.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从…开始。
- en: Networking History
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络历史
- en: The internet we know today is vast, with cables spanning oceans and mountains
    and connecting cities with lower latency than ever before. Barrett Lyon’s “Mapping
    the Internet,” shown in [Figure 1-1](#img-internet-map), shows just how vast it
    truly is. That image illustrates all the connections between the networks of networks
    that make up the internet. The purpose of a network is to exchange information
    from one system to another system. That is an enormous ask of a distributed global
    system, but the internet was not always global; it started as a conceptual model
    and slowly was built up over time, to the behemoth in Lyon’s visually stunning
    artwork. There are many factors to consider when learning about networking, such
    as the last mile, the connectivity between a customer’s home and their internet
    service provider’s network—all the way to scaling up to the geopolitical landscape
    of the internet. The internet is integrated into the fabric of our society. In
    this book, we will discuss how networks operate and how Kubernetes abstracts them
    for us.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天所知的互联网是庞大的，海量电缆横跨海洋和山脉，连接城市的延迟低于以往任何时候。 巴雷特·里昂（Barrett Lyon）的“Mapping the
    Internet”，显示在[图 1-1](#img-internet-map)，展示了它的真实广度。 那幅图像展示了构成互联网的网络之间的所有连接。 网络的目的是从一个系统向另一个系统交换信息。
    这对于一个分布式全球系统来说是一个巨大的要求，但互联网并不总是全球化的； 它始于一个概念模型，随着时间的推移逐渐建立起来，成为里昂视觉上令人惊叹的艺术作品中的庞然大物。
    学习网络时需要考虑许多因素，例如最后一英里，客户家庭与其互联网服务提供商网络之间的连接，一直到互联网地缘政治格局的扩展。 互联网已融入我们社会的结构中。 在本书中，我们将讨论网络的运作方式以及Kubernetes如何为我们抽象它们。
- en: '![Internet Art](Images/neku_0101.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![互联网艺术](Images/neku_0101.png)'
- en: Figure 1-1\. Barrett Lyon, “Mapping the Internet,” 2003
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 巴雷特·里昂，“Mapping the Internet”，2003
- en: '[Table 1-1](#a_brief_history_of_networking) briefly outlines the history of
    networking before we dive into a few of the important details.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 1-1](#a_brief_history_of_networking) 简要概述了我们深入探讨前的网络历史。'
- en: Table 1-1\. A brief history of networking
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1-1\. 网络历史简要概述
- en: '| Year | Event |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 年份 | 事件 |'
- en: '| --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1969 | ARPANET’s first connection test |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 1969 | ARPANET首次连接测试 |'
- en: '| 1969 | Telnet 1969 Request for Comments (RFC) 15 drafted |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 1969 | Telnet 1969 请求评论（RFC）15 起草 |'
- en: '| 1971 | FTP RFC 114 drafted |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 1971 | FTP RFC 114 起草 |'
- en: '| 1973 | FTP RFC 354 drafted |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 1973 | FTP RFC 354 起草 |'
- en: '| 1974 | TCP RFC 675 by Vint Cerf, Yogen Dalal, and Carl Sunshine drafted |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 1974 | 由文特·瑟夫（Vint Cerf）、约根·达拉尔（Yogen Dalal）和卡尔·阳光（Carl Sunshine）起草的TCP RFC
    675发布 |'
- en: '| 1980 | Development of Open Systems Interconnection model begins |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 1980 | 开放系统互联模型的开发开始 |'
- en: '| 1981 | IP RFC 760 drafted |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 1981 | IP RFC 760 起草 |'
- en: '| 1982 | NORSAR and University College London left the ARPANET and began using
    TCP/IP over SATNET |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 1982 | NORSAR和伦敦大学学院离开ARPANET，并开始在SATNET上使用TCP/IP |'
- en: '| 1984 | ISO 7498 Open Systems Interconnection (OSI) model published |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 1984 | ISO 7498 开放系统互联模型（OSI模型）发布 |'
- en: '| 1991 | National Information Infrastructure (NII) Bill passed with Al Gore’s
    help |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 1991 | 在阿尔·戈尔（Al Gore）的帮助下通过了国家信息基础设施（NII）法案 |'
- en: '| 1991 | First version of Linux released |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 1991 | Linux首个版本发布 |'
- en: '| 2015 | First version of Kubernetes released |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 2015 | Kubernetes首个版本发布 |'
- en: In its earliest forms, networking was government run or sponsored; in the United
    States, the Department of Defense (DOD) sponsored the Advanced Research Projects
    Agency Network (ARPANET), well before Al Gore’s time in politics, which will be
    relevant in a moment. In 1969, ARPANET was deployed at the University of California–Los
    Angeles, the Augmentation Research Center at Stanford Research Institute, the
    University of California–Santa Barbara, and the University of Utah School of Computing.
    Communication between these nodes was not completed until 1970, when they began
    using the Network Control Protocol (NCP). NCP led to the development and use of
    the first computer-to-computer protocols like Telnet and File Transfer Protocol
    (FTP).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最早期的形式中，网络是由政府运营或赞助的；在美国，国防部（DOD）赞助了先进研究项目署网络（ARPANET），早在阿尔·戈尔进入政界之前，这对后面将要讨论的话题非常重要。1969年，ARPANET在加州大学洛杉矶分校、斯坦福研究所增强研究中心、加州大学圣塔芭芭拉分校和犹他大学计算机学院部署。这些节点之间的通信直到1970年才完成，当时开始使用网络控制协议（NCP）。NCP导致了像Telnet和文件传输协议（FTP）等第一个计算机对计算机协议的开发和使用。
- en: The success of ARPANET and NCP, the first protocol to power ARPANET, led to
    NCP’s downfall. It could not keep up with the demands of the network and the variety
    of networks connected. In 1974, Vint Cerf, Yogen Dalal, and Carl Sunshine began
    drafting RFC 675 for Transmission Control Protocol (TCP). (You’ll learn more about
    RFCs in a few paragraphs.) TCP would go on to become the standard for network
    connectivity. TCP allowed for exchanging packets across different types of networks.
    In 1981, the Internet Protocol (IP), defined in RFC 791, helped break out the
    responsibilities of TCP into a separate protocol, increasing the modularity of
    the network. In the following years, many organizations, including the DOD, adopted
    TCP as the standard. By January 1983, TCP/IP had become the only approved protocol
    on ARPANET, replacing the earlier NCP because of its versatility and modularity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ARPANET和NCP的成功，第一个支持ARPANET的协议，导致了NCP的失败。它无法满足网络和连接的各种网络的需求。1974年，文特·瑟夫（Vint
    Cerf）、约根·达拉尔（Yogen Dalal）和卡尔·阳光（Carl Sunshine）开始起草RFC 675，用于传输控制协议（TCP）。（您将在几段后了解更多关于RFC的信息。）TCP随后成为了网络连接的标准。TCP允许在不同类型的网络之间交换数据包。1981年，《Internet
    Protocol》（IP），在RFC 791中定义，帮助将TCP的职责拆分为一个单独的协议，增加了网络的模块化。在接下来的几年中，包括国防部在内的许多组织采用了TCP作为标准。到1983年1月，TCP/IP已成为ARPANET上唯一批准的协议，取代了早期的NCP，因为它的多功能性和模块化。
- en: A competing standards organization, the International Organization for Standardization
    (ISO), developed and published ISO 7498, “Open Systems Interconnection Reference
    Model,” which detailed the OSI model. With its publication also came the protocols
    to support it. Unfortunately, the OSI model protocols never gained traction and
    lost out to the popularity of TCP/IP. The OSI model is still an excellent learning
    tool for understanding the layered approach to networking, however.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个竞争的标准组织，国际标准化组织（ISO），开发并发布了ISO 7498，“开放系统互联参考模型”，详细描述了OSI模型。随着其出版，也推出了支持它的协议。不幸的是，OSI模型协议从未获得广泛应用，并输给了TCP/IP的流行。然而，OSI模型仍然是理解网络分层方法的优秀学习工具。
- en: In 1991, Al Gore invented the internet (well, really he helped pass the National
    Information Infrastructure [NII] Bill), which helped lead to the creation of the
    Internet Engineering Task Force (IETF). Nowadays standards for the internet are
    under the management of the IETF, an open consortium of leading experts and companies
    in the field of networking, like Cisco and Juniper. RFCs are published by the
    Internet Society and the Internet Engineering Task Force. RFCs are prominently
    authored by individuals or groups of engineers and computer scientists, and they
    detail their processes, operations, and applications for the internet’s functioning.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 1991年，阿尔·戈尔发明了互联网（实际上是他帮助通过了国家信息基础设施[NII]法案），这有助于创建了互联网工程任务组（IETF）。如今，互联网的标准由IETF管理，这是一个由网络领域的领先专家和公司（如思科和瞻博）组成的开放联盟。RFC由互联网协会和互联网工程任务组发布。RFC通常由个人或工程师和计算机科学家小组撰写，详细描述了他们的过程、操作和互联网功能的应用。
- en: 'An IETF RFC has two states:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: IETF的RFC有两种状态：
- en: Proposed Standard
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 提议标准
- en: A protocol specification has reached enough community support to be considered
    a standard. The designs are stable and well understood. A proposed standard can
    be deployed, implemented, and tested. It may be withdrawn from further consideration,
    however.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 协议规范已经得到足够的社区支持，被视为标准。设计稳定且广为人知。提议的标准可以部署、实施和测试。然而，可能会被进一步考虑。
- en: Internet Standard
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网标准
- en: 'Per RFC 2026: “In general, an internet standard is a stable specification and
    well understood, technically competent, has multiple, independent, and interoperable
    implementations with substantial operational experience, enjoys significant public
    support, and is recognizably useful in some parts of the internet.”'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC 2026：“总的来说，互联网标准是一个稳定的规范，技术上具备了充分的理解，有多个独立且可互操作的实施经验，享有显著的公众支持，在互联网的某些部分被认为是有用的。”
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Draft standard is a third classification that was discontinued in 2011.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 草案标准是2011年停止使用的第三类分类。
- en: There are thousands of internet standards defining how to implement protocols
    for all facets of networking, including wireless, encryption, and data formats,
    among others. Each one is implemented by contributors of open source projects
    and privately by large organizations like Cisco.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数千种互联网标准定义了如何实施网络的各个方面的协议，包括无线、加密和数据格式等。每个标准都是由开源项目的贡献者和大型组织如思科私下实施的。
- en: A lot has happened in the nearly 50 years since those first connectivity tests.
    Networks have grown in complexity and abstractions, so let’s start with the OSI
    model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自从最初的连接测试以来，近50年来发生了很多事情。网络变得更加复杂和抽象，所以让我们从OSI模型开始。
- en: OSI Model
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSI模型
- en: The OSI model is a conceptual framework for describing how two systems communicate
    over a network. The OSI model breaks down the responsibility of sending data across
    networks into layers. This works well for educational purposes to describe the
    relationships between each layer’s responsibility and how data gets sent over
    networks. Interestingly enough, it was meant to be a protocol suite to power networks
    but lost to TCP/IP.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型是描述两个系统如何在网络上通信的概念框架。OSI模型将跨网络发送数据的责任分解为多个层次。这对于教育目的来说描述了每个层次之间的关系及数据如何在网络上传输。有趣的是，它本来是一套用于驱动网络的协议套件，但输给了TCP/IP。
- en: 'Here are the ISO standards that outline the OSI model and protocols:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是概述OSI模型和协议的ISO标准：
- en: ISO/IEC 7498-1, “The Basic Model”
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO/IEC 7498-1，“基本模型”
- en: ISO/IEC 7498-2, “Security Architecture”
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO/IEC 7498-2，“安全架构”
- en: ISO/IEC 7498-3, “Naming and Addressing”
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO/IEC 7498-3，“命名与寻址”
- en: ISO/IEC 7498-4, “Management Framework”
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO/IEC 7498-4，“管理框架”
- en: 'The ISO/IEC 7498-1 describes what the OSI model attempts to convey:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ISO/IEC 7498-1描述了OSI模型试图传达的内容：
- en: 5.2.2.1 The basic structuring technique in the Reference Model of Open Systems
    Interconnection is layering. According to this technique, each open system is
    viewed as logically composed of an ordered set of (N)-subsystems…Adjacent (N)-subsystems
    communicate through their common boundary. (N)-subsystems of the same rank (N)
    collectively form the (N)-layer of the Reference Model of Open Systems Interconnection.
    There is one and only one (N)-subsystem in an open system for layer N. An (N)-subsystem
    consists of one or several (N)-entities. Entities exist in each (N)-layer. Entities
    in the same (N)-layer are termed peer-(N)-entities. Note that the highest layer
    does not have an (N+l)-layer above it, and the lowest layer does not have an (N-1)-layer
    below it.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.2.2.1 开放系统互联参考模型中的基本结构技术是分层。根据这种技术，每个开放系统被视为由一组有序的（N）子系统逻辑组成…相邻的（N）子系统通过它们的公共边界进行通信。同等级（N）的（N）子系统共同形成开放系统中的（N）层。每个开放系统中有且仅有一个（N）子系统用于第N层。一个（N）子系统由一个或多个（N）实体组成。每个（N）层中都存在实体。同一（N）层中的实体称为对等（N）实体。请注意，最高层没有（N+1）层在其上面，最低层没有（N-1）层在其下面。
- en: The OSI model description is a complex and exact way of saying networks have
    layers like cakes or onions. The OSI model breaks the responsibilities of the
    network into seven distinct layers, each with different functions to aid in transmitting
    information from one system to another, as shown in [Figure 1-2](#osi-model).
    The layers encapsulate information from the layer below it; these layers are Application,
    Presentation, Session, Transport, Network, Data Link, and Physical. Over the next
    few pages, we will go over each layer’s functionality and how it sends data between
    two systems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: OSI 模型的描述是一种复杂而准确的方式，类似于蛋糕或洋葱，来表达网络具有层次结构。OSI 模型将网络的责任分解为七个不同的层次，每个层次具有不同的功能，以帮助从一个系统向另一个系统传输信息，如[图1-2](#osi-model)所示。每一层将信息从其下面的层次封装起来；这些层次是应用、表示、会话、传输、网络、数据链路和物理层。在接下来的几页中，我们将详细介绍每一层的功能以及它们如何在两个系统之间发送数据。
- en: '![OSI Model](Images/neku_0102.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![OSI 模型](Images/neku_0102.png)'
- en: Figure 1-2\. OSI model layers
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. OSI 模型层
- en: 'Each layer takes data from the previous layer and encapsulates it to make its
    Protocol Data Unit (PDU). The PDU is used to describe the data at each layer.
    PDUs are also part of TCP/IP. The applications of the Session layer are considered
    “data” for the PDU, preparing the application information for communication. Transport
    uses ports to distinguish what process on the local system is responsible for
    the data. The Network layer PDU is the packet. Packets are distinct pieces of
    data routed between networks. The Data Link layer is the frame or segment. Each
    packet is broken up into frames, checked for errors, and sent out on the local
    network. The Physical layer transmits the frame in bits over the medium. Next
    we will outline each layer in detail:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层从前一层接收数据并封装它以创建其协议数据单元（PDU）。PDU 用于描述每一层的数据。PDU 也是 TCP/IP 的一部分。会话层的应用程序被视为
    PDU 的“数据”，为通信准备应用程序信息。传输使用端口来区分本地系统上负责数据的进程。网络层的 PDU 是数据包。数据包是在网络之间路由的不同数据片段。数据链路层是帧或段。每个数据包被分割成帧，检查错误并通过本地网络发送。物理层以比特形式在介质上传输帧。接下来我们将详细介绍每一层：
- en: Application
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用
- en: The Application layer is the top layer of the OSI model and is the one the end
    user interacts with every day. This layer is not where actual applications live,
    but it provides the interface for applications that use it like a web browser
    or Office 365\. The single biggest interface is HTTP; you are probably reading
    this book on a web page hosted by an O’Reilly web server. Other examples of the
    Application layer that we use daily are DNS, SSH, and SMTP. Those applications
    are responsible for displaying and arranging data requested and sent over the
    network.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层是 OSI 模型的顶层，也是最终用户每天与之交互的层。这一层不是实际应用程序所在的地方，但它为像 web 浏览器或 Office 365 这样使用它的应用程序提供接口。最大的接口是
    HTTP；你可能正在通过 O'Reilly 的 web 服务器上的网页阅读这本书。我们每天使用的应用层的其他例子包括 DNS、SSH 和 SMTP。这些应用程序负责显示和安排通过网络请求和发送的数据。
- en: Presentation
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表示
- en: This layer provides independence from data representation by translating between
    application and network formats. It can be referred to as the *syntax layer*.
    This layer allows two systems to use different encodings for data and still pass
    data between them. Encryption is also done at this layer, but that is a more complicated
    story we’ll save for [“TLS”](#tlssection).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该层通过在应用程序和网络格式之间进行转换提供了对数据表示的独立性。它可以称为*语法层*。该层允许两个系统使用不同的数据编码并仍然在它们之间传递数据。加密也在此层进行，但这是一个更复杂的故事，我们将其保留给[“TLS”](#tlssection)。
- en: Session
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 会话
- en: The Session layer is responsible for the duplex of the connection, in other
    words, whether sending and receiving data at the same time. It also establishes
    procedures for performing checkpointing, suspending, restarting, and terminating
    a session. It builds, manages, and terminates the connections between the local
    and remote applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 会话层负责连接的双工性，换句话说，即同时发送和接收数据。它还建立了执行会话检查点、挂起、重新启动和终止会话的过程。它建立、管理和终止本地和远程应用程序之间的连接。
- en: Transport
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 传输
- en: 'The Transport layer transfers data between applications, providing reliable
    data transfer services to the upper layers. The Transport layer controls a given
    connection’s reliability through flow control, segmentation and desegmentation,
    and error control. Some protocols are state- and connection-oriented. This layer
    tracks the segments and retransmits those that fail. It also provides the acknowledgment
    of successful data transmission and sends the next data if no errors occurred.
    TCP/IP has two protocols at this layer: TCP and User Datagram Protocol (UDP).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层在应用程序之间传输数据，为上层提供可靠的数据传输服务。传输层通过流量控制，分段和重新组合以及错误控制来控制给定连接的可靠性。一些协议是状态和连接导向的。该层跟踪段并重新传输失败的段。它还确认成功的数据传输并在没有错误发生时发送下一个数据。TCP/IP在这一层有两个协议：TCP和用户数据报协议（UDP）。
- en: Network
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 网络
- en: The Network layer implements a means of transferring variable-length data flows
    from a host on one network to a host on another network while sustaining service
    quality. The Network layer performs routing functions and might also perform fragmentation
    and reassembly while reporting delivery errors. Routers operate at this layer,
    sending data throughout the neighboring networks. Several management  protocols 
    belong  to  the  Network  layer,  including  routing  protocols,  multicast  group 
    management,  network-layer information, error handling, and network-layer address
    assignment, which we will discuss further in [“TCP/IP”](#tcp_ip).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层实现从一个网络上的主机到另一个网络上的主机的可变长度数据流的传输方式，并保持服务质量。网络层执行路由功能，并可能在报告传递错误时执行分段和重组。路由器在这一层操作，通过相邻网络发送数据。几个管理协议属于网络层，包括路由协议，组播组管理，网络层信息，错误处理和网络层地址分配，我们将在["TCP/IP"](#tcp_ip)中进一步讨论。
- en: Data Link
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路
- en: This layer is responsible for the host-to-host transfers on the same network.
    It defines the protocols to create and terminate the connections between two devices.
    The Data Link layer transfers data between network hosts and provides the means
    to detect and possibly correct errors from the Physical layer. Data Link frames,
    the PDU for layer 2, do not cross the boundaries of a local network.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此层负责同一网络上的主机到主机的传输。它定义了创建和终止两个设备之间连接的协议。数据链路层在网络主机之间传输数据，并提供检测和可能纠正物理层错误的手段。数据链路帧作为第2层的PDU不会跨越本地网络的边界。
- en: Physical
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 物理
- en: The Physical layer is represented visually by an Ethernet cord plugged into
    a switch. This layer converts data in the form of digital bits into electrical,
    radio, or optical signals. Think of this layer as the physical devices, like cables,
    switches, and wireless access points. The wire signaling protocols are also defined
    at this layer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层通过插入交换机的以太网线缆来进行可视化表示。这一层将数字比特形式的数据转换为电气、无线电或光信号。可以将这一层视为物理设备，如电缆、交换机和无线接入点。该层还定义了电线信号协议。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are many mnemonics to remember the layers of the OSI model; our favorite
    is All People Seem To Need Data Processing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多助记符可以记住OSI模型的层次；我们最喜欢的是"All People Seem To Need Data Processing"。
- en: '[Table 1-2](#osi_layers_details) summarizes the OSI layers.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[表1-2](#osi_layers_details)总结了OSI层。'
- en: Table 1-2\. OSI layer details
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-2\. OSI层详细信息
- en: '| Layer number | Layer name | Protocol data unit | Function overview |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 层号 | 层名 | 协议数据单元 | 功能概述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 7 | Application | Data | High-level APIs and application protocols like HTTP,
    DNS, and SSH. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 应用 | 数据 | 高级API和应用协议，如HTTP，DNS和SSH。'
- en: '| 6 | Presentation | Data | Character encoding, data compression, and encryption/decryption.
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 展示 | 数据 | 字符编码，数据压缩和加密/解密。'
- en: '| 5 | Session | Data | Continuous data exchanges between nodes are managed
    here: how much data to send, when to send more. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 会话 | 数据 | 这里管理节点之间的连续数据交换：发送多少数据，何时发送更多。'
- en: '| 4 | Transport | Segment, datagram | Transmission of data segments between
    endpoints on a network, including segmentation, acknowledgment, and multiplexing.
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 传输 | 段，数据报 | 在网络上的端点之间传输数据段，包括分段，确认和多路复用。'
- en: '| 3 | Network | Packet | Structuring and managing addressing, routing, and
    traffic control for all endpoints on the network. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 网络 | 包 | 为网络上所有端点结构化和管理寻址，路由和流量控制。'
- en: '| 2 | Data Link | Frame | Transmission of data frames between two nodes connected
    by a Physical layer. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 数据链路 | 帧 | 在物理层连接的两个节点之间传输数据帧。'
- en: '| 1 | Physical | Bit | Sending and receiving of bitstreams over the medium.
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 物理层 | 位 | 在介质上发送和接收位流。 |'
- en: The OSI model breaks down all the necessary functions to send a data packet
    over a network between two hosts. In the late 1980s and early 1990s, it lost out
    to TCP/IP as the standard adopted by the DOD and all other major players in networking.
    The standard defined in ISO 7498 gives a brief glimpse into the implementation
    details that were considered by most at the time to be complicated, inefficient,
    and to an extent unimplementable. The OSI model at a high level still allows those
    learning networking to comprehend the basic concepts and challenges in networking.
    In addition, these terms and functions are used in the TCP/IP model covered in
    the next section and ultimately in Kubernetes abstractions. Kubernetes services
    break out each function depending on the layer it is operating at, for example,
    a layer 3 IP address or a layer 4 port; you will learn more about that in [Chapter 4](ch04.xhtml#kubernetes_networking_introduction).
    Next, we will do a deep dive into the TCP/IP suite with an example walk-through.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型分解了在两个主机之间通过网络发送数据包所需的所有必要功能。在1980年代末和1990年代初，它输给了TCP/IP，在DOD和所有其他主要网络参与者中成为标准。ISO
    7498中定义的标准简要展示了当时大多数人认为复杂、低效且在某种程度上不可实施的实现细节。高层次上的OSI模型仍允许学习网络的人理解网络中的基本概念和挑战。此外，这些术语和功能在下一节涵盖的TCP/IP模型以及最终在Kubernetes抽象中使用。Kubernetes服务根据其操作的层级来分解每个功能，例如层3的IP地址或层4的端口；您将在[第4章](ch04.xhtml#kubernetes_networking_introduction)中了解更多信息。接下来，我们将通过一个示例深入了解TCP/IP套件。
- en: TCP/IP
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP
- en: TCP/IP creates a heterogeneous network with open protocols that are independent
    of the operating system and architectural differences. Whether the hosts are running
    Windows, Linux, or another OS, TCP/IP allows them to communicate; TCP/IP does
    not care if you are running Apache or Nginx for your web server at the Application
    layer. The separation of responsibilities similar to the OSI model makes that
    possible. In [Figure 1-3](#img-osi-tcp), we compare the OSI model to TCP/IP.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP创建了一个异构网络，具有独立于操作系统和架构差异的开放协议。无论主机运行Windows、Linux还是其他操作系统，TCP/IP都允许它们通信；TCP/IP并不关心您在应用层运行Apache还是Nginx作为您的Web服务器。与OSI模型类似的责任分离使这一点成为可能。在[图1-3](#img-osi-tcp)中，我们比较了OSI模型和TCP/IP。
- en: '![OSI Model](Images/neku_0103.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![OSI模型](Images/neku_0103.png)'
- en: Figure 1-3\. OSI model compared to TCP/IP
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. OSI模型与TCP/IP的比较
- en: 'Here we expand on the differences between the OSI model and the TCP/IP:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们详细探讨了OSI模型与TCP/IP之间的差异：
- en: Application
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层
- en: In TCP/IP, the Application layer comprises the communications protocols used
    in process-to-process communications across an IP network. The Application layer
    standardizes communication and depends upon the underlying Transport layer protocols
    to establish the host-to-host data transfer. The lower Transport layer also manages
    the data exchange in network communications. Applications at this layer are defined
    in RFCs; in this book, we will continue to use HTTP, RFC 7231 as our example for
    the Application layer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP/IP中，应用层包括在IP网络中进程间通信所使用的通信协议。应用层标准化通信，并依赖底层传输层协议建立主机间的数据传输。较低的传输层还管理网络通信中的数据交换。此层的应用程序在RFC中定义；在本书中，我们将继续以HTTP，RFC
    7231作为应用层的示例。
- en: Transport
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 传输
- en: TCP and UDP are the primary protocols of the Transport layer that provide host-to-host
    communication services for applications. Transport protocols are responsible for
    connection-oriented communication, reliability, flow control, and multiplexing.
    In TCP, the window size manages flow control, while UDP does not manage the congestion
    flow and is considered unreliable; you’ll learn more about that in [“UDP”](#udpsection).
    Each port identifies the host process responsible for processing the information
    from the network communication. HTTP uses the well-known port 80 for nonsecure
    communication and 443 for secure communication. Each port on the server identifies
    its traffic, and the sender generates a random port locally to identify itself.
    The governing body that manages port number assignments is the Internet Assigned
    Number Authority (IANA); there are 65,535 ports.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP是传输层的主要协议，为应用程序提供主机到主机的通信服务。传输协议负责面向连接的通信、可靠性、流量控制和多路复用。在TCP中，窗口大小管理流量控制，而UDP不管理拥塞流，并且被认为是不可靠的；你可以在[“UDP”](#udpsection)中了解更多信息。每个端口标识负责处理来自网络通信的信息的主机进程。HTTP使用80号端口进行非安全通信和443号端口进行安全通信。服务器上的每个端口标识其流量，并且发送方在本地生成一个随机端口来标识自己。管理端口号分配的机构是互联网分配号码管理局（IANA）；共有65535个端口。
- en: Internet
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网
- en: The Internet, or Network layer, is responsible for transmitting data between
    networks. For an outgoing packet, it selects the next-hop host and transmits it
    to that host by passing it to the appropriate link-layer. Once the packet is received
    by the destination, the Internet layer will pass the packet payload up to the
    appropriate Transport layer protocol.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网或网络层负责在网络之间传输数据。对于传出的数据包，它选择下一个跳点主机，并通过将其传递给适当的链路层将其传输到该主机。一旦数据包被目标接收，互联网层将把数据包载荷传递给适当的传输层协议。
- en: IP provides the fragmentation or defragmentation of packets based on the maximum
    transmission unit (MTU); this is the maximum size of the IP packet. IP makes no
    guarantees about packets’ proper arrival. Since packet delivery across diverse
    networks is inherently unreliable and failure-prone, that burden is with the endpoints
    of a communication path, rather than on the network. The function of providing
    service reliability is in the Transport layer. A checksum ensures that the information
    in a received packet is accurate, but this layer does not validate data integrity.
    The IP address identifies packets on the network.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: IP根据最大传输单元（MTU）对数据包进行分段或重组；这是IP数据包的最大大小。IP不保证数据包的正确到达。由于跨不同网络的数据包传输本质上是不可靠且容易出错的，这种负担在通信路径的端点而不是网络上。提供服务可靠性的功能位于传输层。校验和确保接收到的数据包信息准确，但此层不验证数据完整性。IP地址用于标识网络上的数据包。
- en: Link
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 链路
- en: The Link layer in the TCP/IP model comprises networking protocols that operate
    only on the local network that a host connects to. Packets are not routed to nonlocal
    networks; that is the Internet layer’s role. Ethernet is the dominant protocol
    at this layer, and hosts are identified by the link-layer address or commonly
    their Media Access Control addresses on their network interface cards. Once determined
    by the host using Address Resolution Protocol 9 (ARP), data sent off the local
    network is processed by the Internet layer. This layer also includes protocols
    for moving packets between two Internet layer hosts.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP模型中的链路层包括仅在主机连接到的本地网络上运行的网络协议。数据包不会路由到非本地网络；这是互联网层的角色。以太网是该层的主要协议，并且主机通过链路层地址或通常是它们网络接口卡上的媒体访问控制地址来识别。一旦主机通过地址解析协议9（ARP）确定了这些数据，远程网络上发送的数据由互联网层处理。该层还包括在两个互联网层主机之间移动数据包的协议。
- en: Physical layer
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层
- en: The Physical layer defines the components of the hardware to use for the network.
    For example, the Physical network layer stipulates the physical characteristics
    of the communications media. The Physical layer of TCP/IP details hardware standards
    such as IEEE 802.3, the specification for Ethernet network media. Several interpretations
    of RFC 1122 for the Physical layer are included with the other layers; we have
    added this for completeness.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层定义了用于网络的硬件组件。例如，物理网络层规定了通信介质的物理特性。TCP/IP的物理层详细描述了硬件标准，如IEEE 802.3，即以太网网络介质的规范。RFC
    1122的物理层有几种解释，与其他层一起包含在内；我们为完整性而添加这些。
- en: Throughout this book, we will use the minimal Golang web server (also called
    Go) from [Example 1-1](#minmal_web_server_in_go) to show various levels of networking
    components from `tcpdump`, a Linux syscall, to show how Kubernetes abstracts the
    syscalls. This section will use it to demonstrate what is happening at the Application,
    Transport, Network, and Data Link layers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用最小的Golang Web服务器（也称为Go）来展示从[示例 1-1](#minmal_web_server_in_go)开始的各种网络组件层次，从Linux系统调用的`tcpdump`到展示Kubernetes如何抽象系统调用的过程。本节将使用它来演示在应用程序、传输、网络和数据链路层各层发生的情况。
- en: Application
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: As mentioned, Application is the highest layer in the TCP/IP stack; it is where
    the user interacts with data before it gets sent over the network. In our example
    walk-through, we are going to use Hypertext Transfer Protocol (HTTP) and a simple
    HTTP transaction to demonstrate what happens at each layer in the TCP/IP stack.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序是TCP/IP堆栈中的最高层；在数据通过网络发送之前，用户与数据交互的地方。在我们的示例演示中，我们将使用超文本传输协议（HTTP）和简单的HTTP事务来演示TCP/IP堆栈的每一层发生了什么。
- en: HTTP
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP
- en: 'HTTP is responsible for sending and receiving Hypertext Markup Language (HTML)
    documents—you know, a web page. A vast majority of what we see and do on the internet
    is over HTTP: Amazon purchases, Reddit posts, and tweets all use HTTP. A client
    will make an HTTP request to our minimal Golang web server from [Example 1-1](#minmal_web_server_in_go),
    and it will send an HTTP response with “Hello” text. The web server runs locally
    in an Ubuntu virtual machine to test the full TCP/IP stack.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP负责发送和接收超文本标记语言（HTML）文档——你知道，网页。互联网上大部分我们看到和做的事情都是通过HTTP完成的：亚马逊购物、Reddit帖子和推特都使用HTTP。客户端将向我们的最小Golang
    Web服务器（来自[示例 1-1](#minmal_web_server_in_go)）发出HTTP请求，它将发送一个带有“Hello”文本的HTTP响应。该Web服务器在Ubuntu虚拟机中本地运行，以测试完整的TCP/IP堆栈。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: See the example code [repository](https://oreil.ly/Jan5M) for full instructions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 查看示例代码[存储库](https://oreil.ly/Jan5M)获取完整说明。
- en: Example 1-1\. Minimal web server in Go
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-1\. Go中的最小Web服务器
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our Ubuntu virtual machine we need to start our minimal web server, or if
    you have Golang installed locally, you can just run this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Ubuntu虚拟机中，我们需要启动我们的最小Web服务器；或者，如果您在本地安装了Golang，您可以直接运行以下命令：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s break down the request for each layer of the TPC/IP stack.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解每个TCP/IP堆栈层的请求。
- en: cURL is the requesting client for our HTTP request example. Generally, for a
    web page, the client would be a web browser, but we’re using cURL to simplify
    and show the command line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: cURL是我们HTTP请求示例中的请求客户端。通常情况下，对于网页，客户端将是Web浏览器，但我们使用cURL来简化并显示命令行。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[cURL](https://curl.haxx.se) is meant for uploading and downloading data specified
    with a URL. It is a client-side program (the *c*) to request data from a URL and
    return the response.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[cURL](https://curl.haxx.se) 旨在通过URL上传和下载指定的数据。它是一个客户端程序（*c*），用于请求URL上的数据并返回响应。'
- en: In [Example 1-2](#client_request), we can see each part of the HTTP request
    that the cURL client is making and the response. Let’s review what all those options
    and outputs are.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 1-2](#client_request)中，我们可以看到cURL客户端正在进行的每个HTTP请求的各个部分以及响应。让我们审视所有这些选项和输出是什么。
- en: Example 1-2\. Client request
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-2\. 客户端请求
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_networking_introduction_CO1-1)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_networking_introduction_CO1-1)'
- en: '`curl` `localhost:8080` `-vvv`: This is the `curl` command that opens a connection
    to the locally running web server, `localhost` on TCP port 8080\. `-vvv` sets
    the verbosity of the output so we can see everything happening with the request.
    Also, `TCP_NODELAY` instructs the TCP connection to send the data without delay,
    one of many options available to the client to set.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` `localhost:8080` `-vvv`：这是打开与本地运行的Web服务器`localhost`在TCP端口8080上的连接的`curl`命令。`-vvv`设置输出的冗长程度，以便我们可以看到请求中发生的一切。此外，`TCP_NODELAY`指令TCP连接发送数据而无需延迟，这是客户端可设置的众多选项之一。'
- en: '[![2](Images/2.png)](#co_networking_introduction_CO1-2)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_networking_introduction_CO1-2)'
- en: '`Connected` `to` `localhost` `(::1)` `port` `8080`: It worked! cURL connected
    to the web server on localhost and over port 8080.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`已连接` `到` `localhost` `(::1)` `端口` `8080`：成功了！cURL连接到了本地主机上的Web服务器，并通过端口8080进行了连接。'
- en: '[![3](Images/3.png)](#co_networking_introduction_CO1-3)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_networking_introduction_CO1-3)'
- en: '`Get` `/` `HTTP/1.1`: HTTP has several methods for retrieving or updating information.
    In our request, we are performing an HTTP GET to retrieve our “Hello” response.
    The forward slash is the next part, a Uniform Resource Locator (URL), which indicates
    where we are sending the client request to the server. The last section of this
    header is the version of HTTP the server is using, 1.1.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get` `/` `HTTP/1.1`: HTTP有多种方法用于检索或更新信息。在我们的请求中，我们正在执行HTTP GET来检索我们的“Hello”响应。斜杠是下一个部分，Uniform
    Resource Locator (URL)，它指示我们将客户端请求发送到服务器的位置。此头部的最后部分是服务器正在使用的HTTP版本，1.1。'
- en: '[![4](Images/4.png)](#co_networking_introduction_CO1-4)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_networking_introduction_CO1-4)'
- en: '`Host:` `localhost:8080`: HTTP has several options for sending information
    about the request. In our request, the cURL process has set the HTTP Host header.
    The client and server can transmit information with an HTTP request or response.
    An HTTP header contains its name followed by a colon (:) and then its value.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Host:` `localhost:8080`: HTTP有多个选项可用于发送关于请求的信息。在我们的请求中，cURL进程已设置了HTTP Host头。客户端和服务器可以在HTTP请求或响应中传输信息。HTTP头部包含其名称后跟一个冒号（:），然后是其值。'
- en: '[![5](Images/5.png)](#co_networking_introduction_CO1-5)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_networking_introduction_CO1-5)'
- en: '`User-Agent: cURL/7.64.1`: The user agent is a string that indicates the computer
    program making the HTTP request on behalf of the end user; it is cURL in our context.
    This string often identifies the browser, its version number, and its host operating
    system.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`User-Agent: cURL/7.64.1`: 用户代理是指示代表最终用户发出HTTP请求的计算机程序的字符串；在我们的情况下是cURL。此字符串通常标识浏览器、其版本号和其主机操作系统。'
- en: '[![6](Images/6.png)](#co_networking_introduction_CO1-6)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_networking_introduction_CO1-6)'
- en: '`Accept:` `*/*`: This header instructs the web server what content types the
    client understands. [Table 1-3](#common_content_types_for_http_data) shows examples
    of common content types that can be sent.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Accept:` `*/*`: 此头部指示Web服务器客户端理解的内容类型。[表 1-3](#common_content_types_for_http_data)展示了可以发送的常见内容类型示例。'
- en: '[![7](Images/7.png)](#co_networking_introduction_CO1-7)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_networking_introduction_CO1-7)'
- en: '`HTTP/1.1` `200` `OK`: This is the server response to our request. The server
    responds with the HTTP version and the response status code. There are several
    possible responses from the server. A status code of 200 indicates the response
    was successful. 1XX means informational, 2XX means successful, 3XX means redirects,
    4XX responses indicate there are issues with the requests, and 5XX generally refers
    to issues from the server.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTP/1.1` `200` `OK`: 这是我们请求的服务器响应。服务器用HTTP版本和响应状态码进行响应。服务器可能会有多种响应。状态码200表示响应成功。1XX表示信息性响应，2XX表示成功，3XX表示重定向，4XX表示请求存在问题，5XX通常指服务器问题。'
- en: '[![8](Images/8.png)](#co_networking_introduction_CO1-8)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_networking_introduction_CO1-8)'
- en: '`Date: Sat, July 25, 2020, 14:57:46 GMT`: The `Date` header field represents
    the date and time at which the message originated. The sender generates the value
    as the approximate date and time of message generation.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date: Sat, July 25, 2020, 14:57:46 GMT`: `Date` 头字段表示消息生成的日期和时间。发送者生成该值作为消息生成的大致日期和时间。'
- en: '[![9](Images/9.png)](#co_networking_introduction_CO1-9)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](Images/9.png)](#co_networking_introduction_CO1-9)'
- en: '`Content-Length: 5`: The `Content-Length` header indicates the size of the
    message body, in bytes, sent to the recipient; in our case, the message is 5 bytes.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Length: 5`: `Content-Length` 头部指示发送到接收者的消息正文大小，以字节为单位；在我们的情况下，消息为5字节。'
- en: '[![10](Images/10.png)](#co_networking_introduction_CO1-10)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](Images/10.png)](#co_networking_introduction_CO1-10)'
- en: '`Content-Type: text/plain; charset=utf-8`: The `Content-Type` entity header
    is used to indicate the resource’s media type. Our response is indicating that
    it is returning a plain-text file that is UTF-8 encoded.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Type: text/plain; charset=utf-8`: `Content-Type` 实体头部用于指示资源的媒体类型。我们的响应指示返回的是一个纯文本文件，使用UTF-8编码。'
- en: '[![11](Images/11.png)](#co_networking_introduction_CO1-11)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](Images/11.png)](#co_networking_introduction_CO1-11)'
- en: '`Hello* Closing connection 0`: This prints out the response from our web server
    and closes out the HTTP connection.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello* Closing connection 0`: 这打印出我们的Web服务器的响应并关闭HTTP连接。'
- en: Table 1-3\. Common content types for HTTP data
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-3\. HTTP数据的常见内容类型
- en: '| Type | Description |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| application | Any kind of binary data that doesn’t fall explicitly into one
    of the other types. Common examples include application/json, application/pdf,
    application/pkcs8, and application/zip. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| application | 任何不明确属于其他类型的二进制数据。常见示例包括 application/json、application/pdf、application/pkcs8
    和 application/zip。 |'
- en: '| audio | Audio or music data. Examples include audio/mpeg and audio/vorbis.
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| audio | 音频或音乐数据。例如 audio/mpeg 和 audio/vorbis。 |'
- en: '| font | Font/typeface data. Common examples include font/woff, font/ttf, and
    font/otf. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| font | 字体/字型数据。常见示例包括 font/woff、font/ttf 和 font/otf。 |'
- en: '| image | Image or graphical data including both bitmap and vector such as
    animated GIF or APNG. Common examples are image/jpg, image/png, and image/svg+xml.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| image | 包括位图和矢量图像的图像或图形数据，例如动画 GIF 或 APNG。常见示例包括 image/jpg、image/png 和 image/svg+xml。
    |'
- en: '| model | Model data for a 3D object or scene. Examples include model/3mf and
    model/vrml. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| model | 用于 3D 对象或场景的模型数据。示例包括 model/3mf 和 model/vrml。 |'
- en: '| text | Text-only data including human-readable content, source code, or text
    data. Examples include text/plain, text/csv, and text/html. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| text | 仅包含人类可读内容、源代码或文本数据的文本。例如 text/plain、text/csv 和 text/html。 |'
- en: '| video | Video data or files, such as video/mp4. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| video | 视频数据或文件，例如 video/mp4。 |'
- en: This is a simplistic view that happens with every HTTP request. Today, a single
    web page makes an exorbitant number of requests with one load of a page, and in
    just a matter of seconds! This is a brief example for cluster administrators of
    how HTTP (and for that matter, the other seven layers’ applications) operate.
    We will continue to build our knowledge of how this request is completed at each
    layer of the TCP/IP stack and then how Kubernetes completes those same requests.
    All this data is formatted and options are set at layer 7, but the real heavy
    lifting is done at the lower layers of the TCP/IP stack, which we will go over
    in the next sections.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个 HTTP 请求中发生的简单视图。今天，单个网页在短短几秒钟内进行大量请求！这是一个针对集群管理员的简要示例，说明 HTTP（以及其他七层应用程序）的操作方式。我们将继续建立对
    TCP/IP 协议栈各层如何完成这些请求的了解，然后介绍 Kubernetes 如何完成相同的请求。所有这些数据都在第 7 层格式化和设置选项，但真正的重活儿在
    TCP/IP 协议栈的更低层完成，我们将在接下来的部分讨论它们。
- en: Transport
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输
- en: The Transport layer protocols are responsible for connection-oriented communication,
    reliability, flow control, and multiplexing; this is mostly true of TCP. We’ll
    describe the differences in the following sections. Our Golang web server is a
    layer 7 application using HTTP; the Transport layer that HTTP relies on is TCP.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层协议负责面向连接的通信、可靠性、流量控制和复用；这在 TCP 中是大部分正确的。我们将在以下部分描述差异。我们的 Golang Web 服务器是一个使用
    HTTP 的第 7 层应用程序；HTTP 依赖的传输层是 TCP。
- en: TCP
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP
- en: As already mentioned, TCP is a connection-oriented, reliable protocol, and it
    provides flow control and multiplexing. TCP is considered connection-oriented
    because it manages the connection state through the life cycle of the connection.
    In TCP, the window size manages flow control, unlike UDP, which does not manage
    the congestion flow. In addition, UDP is unreliable, and data may arrive out of
    sequence. Each port identifies the host process responsible for processing the
    information from the network communication. TCP is known as a host-to-host layer
    protocol. To identify the process on the host responsible for the connection,
    TCP identifies the segments with a 16-bit port number. HTTP servers use the well-known
    port of 80 for nonsecure communication and 443 for secure communication using
    Transport Layer Security (TLS). Clients requesting a new connection create a source
    port local in the range of 0–65534.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，TCP 是一种面向连接的可靠协议，它提供流量控制和复用。TCP 被认为是面向连接的，因为它通过连接的生命周期管理连接状态。在 TCP 中，窗口大小管理流量控制，不像
    UDP 那样管理拥塞流。此外，UDP 是不可靠的，数据可能无序到达。每个端口标识负责处理网络通信信息的主机进程。TCP 被称为主机到主机层协议。为了识别主机上负责连接的进程，TCP
    使用 16 位端口号标识段。HTTP 服务器使用非安全通信的众所周知端口 80 和使用传输层安全性（TLS）进行安全通信的端口 443。请求建立新连接的客户端在本地使用
    0–65534 范围内的源端口。
- en: 'To understand how TCP performs multiplexing, let’s review a simple HTML page
    retrieval:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 TCP 如何执行复用，请回顾一个简单的 HTML 页面检索：
- en: In a web browser, type in a web page address.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Web 浏览器中键入网页地址。
- en: The browser opens a connection to transfer the page.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器打开连接以传输页面。
- en: The browser opens connections for each image on the page.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器为页面上的每个图像打开连接。
- en: The browser opens another connection for the external CSS.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器为外部CSS打开另一个连接。
- en: Each of these connections uses a different set of virtual ports.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个连接使用不同的虚拟端口集。
- en: All the page’s assets download simultaneously.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有页面资源同时下载。
- en: The browser reconstructs the page.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器重建页面。
- en: 'Let’s walk through how TCP manages multiplexing with the information provided
    in the TCP segment headers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过TCP段头部中提供的信息来了解TCP如何管理多路复用：
- en: '`Source port` (16 bits)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`源端口`（16 位）'
- en: This identifies the sending port.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这标识了发送端口。
- en: '`Destination port` (16 bits)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`目的端口`（16 位）'
- en: This identifies the receiving port.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这标识了接收端口。
- en: '`Sequence number` (32 bits)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`序列号`（32 位）'
- en: If the SYN flag is set, this is the initial sequence number. The sequence number
    of the first data byte and the acknowledged number in the corresponding ACK is
    this sequence number plus 1\. It is also used to reassemble data if it arrives
    out of order.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了SYN标志，则这是初始序列号。第一个数据字节的序列号以及对应ACK中的确认号是此序列号加1。它还用于重新组装到达的乱序数据。
- en: '`Acknowledgment number` (32 bits)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`确认号`（32 位）'
- en: If the ACK flag is set, then this field’s value is the next sequence number
    of the ACK the sender is expecting. This acknowledges receipt of all preceding
    bytes (if any). Each end’s first ACK acknowledges the other end’s initial sequence
    number itself, but no data has been sent.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了ACK标志，则此字段的值是发送方期望的下一个确认号。这确认接收到所有之前的字节（如果有的话）。每端的第一个ACK确认了另一端的初始序列号本身，但尚未发送任何数据。
- en: '`Data offset` (4 bits)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`数据偏移量`（4 位）'
- en: This specifies the size of the TCP header in 32-bit words.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了TCP头部的大小，以32位字为单位。
- en: '`Reserved` (3 bits)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`保留`（3 位）'
- en: This is for future use and should be set to zero.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是未来使用的，并应设置为零。
- en: '`Flags` (9 bits)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`标志`（9 位）'
- en: 'There are nine 1-bit fields defined for the TCP header:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: TCP头部定义了九个1位字段：
- en: 'NS–ECN-nonce: Concealment protection.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NS-ECN-nonce：掩蔽保护。
- en: 'CWR: Congestion Window Reduced; the sender reduced its sending rate.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CWR：拥塞窗口减少；发送方降低了其发送速率。
- en: 'ECE: ECN Echo; the sender received an earlier congestion notification.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECE：ECN Echo；发送方接收到先前的拥塞通知。
- en: 'URG: Urgent; the Urgent Pointer field is valid, but this is rarely used.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URG：紧急；紧急指针字段有效，但很少使用。
- en: 'ACK: Acknowledgment; the Acknowledgment Number field is valid and is always
    on after a connection is established.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACK：确认；确认号字段有效，在建立连接后始终打开。
- en: 'PSH: Push; the receiver should pass this data to the application as soon as
    possible.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PSH：推送；接收方应尽快将此数据传递给应用程序。
- en: 'RST: Reset the connection or connection abort, usually because of an error.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RST：重置连接或连接中止，通常是因为错误。
- en: 'SYN: Synchronize sequence numbers to initiate a connection.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN：同步序列号以启动连接。
- en: 'FIN: The sender of the segment is finished sending data to its peer.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FIN：段的发送方完成向其对等体发送数据。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The NS bit field is further explained in RFC 3540, “Robust Explicit Congestion
    Notification (ECN) Signaling with Nonces.” This specification describes an optional
    addition to ECN improving robustness against malicious or accidental concealment
    of marked packets.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: NS位字段在RFC 3540中进一步解释，“使用非掩码的鲁棒显式拥塞通知（ECN）信号”。该规范描述了ECN的可选增强部分，以提高对标记数据包的恶意或意外掩蔽的鲁棒性。
- en: '`Window size` (16 bits)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`窗口大小`（16 位）'
- en: This is the size of the receive window.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接收窗口的大小。
- en: '`Checksum` (16 bits)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`校验和`（16 位）'
- en: The checksum field is used for error checking of the TCP header.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和字段用于检查TCP头部的错误。
- en: '`Urgent pointer` (16 bits)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`紧急指针`（16 位）'
- en: This is an offset from the sequence number indicating the last urgent data byte.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从序列号指示的最后紧急数据字节的偏移量。
- en: '`Options`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`选项`'
- en: Variable 0–320 bits, in units of 32 bits.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 0-320 位，以32位为单位。
- en: '`Padding`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`填充`'
- en: The TCP header padding is used to ensure that the TCP header ends, and data
    begins on a 32-bit boundary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: TCP头部填充用于确保TCP头部结束，并且数据从32位边界开始。
- en: '`Data`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`数据`'
- en: This is the piece of application data being sent in this segment.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在此段中发送的应用数据片段。
- en: In [Figure 1-4](#img-tcp-data), we can see all the TCP segment headers that
    provide metadata about the TCP streams.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-4](#img-tcp-data)中，我们可以看到所有提供关于TCP流的TCP段头部的元数据。
- en: '![TCP Segment Header](Images/neku_0104.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![TCP Segment Header](Images/neku_0104.png)'
- en: Figure 1-4\. TCP segment header
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. TCP段头部
- en: These fields help manage the flow of data between two systems. [Figure 1-5](#img-osi-model)
    shows how each step of the TCP/IP stack sends data from one application on one
    host, through a network communicating at layers 1 and 2, to get data to the destination
    host.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段帮助管理两个系统之间的数据流。[图 1-5](#img-osi-model) 显示了 TCP/IP 协议栈的每个步骤如何将数据从一个主机上的一个应用程序通过在层
    1 和层 2 通信的网络，发送到目标主机上。
- en: '![neku 0105](Images/neku_0105.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![neku 0105](Images/neku_0105.png)'
- en: Figure 1-5\. tcp/ip data flow
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-5\. tcp/ip 数据流
- en: In the next section, we will show how TCP uses these fields to initiate a connection
    through the three-way handshake.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将展示 TCP 如何利用这些字段通过三次握手初始化连接。
- en: TCP handshake
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 握手
- en: 'TCP uses a three-way handshake, pictured in [Figure 1-6](#three-way-tcp), to
    create a connection by exchanging information along the way with various options
    and flags:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 使用三次握手（详见 [图 1-6](#three-way-tcp)）来创建连接，通过沿途交换各种选项和标志的信息：
- en: The requesting node sends a connection request via a SYN packet to get the transmission
    started.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求节点通过 SYN 包发送连接请求以启动传输。
- en: If the receiving node is listening on the port the sender requests, the receiving
    node replies with a SYN-ACK, acknowledging that it has heard the requesting node.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果接收节点正在监听发送方请求的端口，则接收节点将以 SYN-ACK 回复，确认已收到请求节点。
- en: The requesting node returns an ACK packet, exchanging information and letting
    them know the nodes are good to send each other information.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求节点返回一个 ACK 包，交换信息并让对方知道节点可以相互发送信息。
- en: '![OSI Model](Images/neku_0106.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![OSI 模型](Images/neku_0106.png)'
- en: Figure 1-6\. TCP three-way handshake
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-6\. TCP 三次握手
- en: Now the connection is established. Data can be transmitted over the physical
    medium, routed between networks, to find its way to the local destination—but
    how does the endpoint know how to handle the information? On the local and remote
    hosts, a socket gets created to track this connection. A socket is just a logical
    endpoint for communication. In [Chapter 2](ch02.xhtml#linux_networking), we will
    discuss how a Linux client and server handle sockets.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在连接已经建立。数据可以通过物理介质传输，在网络之间路由，以找到本地目的地，但是终端如何知道如何处理信息？在本地和远程主机上，创建了一个套接字来跟踪这个连接。套接字只是通信的逻辑端点。在
    [第 2 章](ch02.xhtml#linux_networking) 中，我们将讨论 Linux 客户端和服务器如何处理套接字。
- en: TCP is a stateful protocol, tracking the connection’s state throughout its life
    cycle. The state of the connection depends on both the sender and the receiver
    agreeing where they are in the connection flow. The connection state is concerned
    about who is sending and receiving data in the TCP stream. TCP has a complex state
    transition for explaining when and where the connection is, using the 9-bit TCP
    flags in the TCP segment header, as you can see in [Figure 1-7](#tcp-state).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是一种有状态的协议，跟踪连接在其生命周期中的状态。连接状态取决于发送方和接收方在连接流中的协商。连接状态关注的是谁在 TCP 流中发送和接收数据。TCP
    在 TCP 段头部使用 9 位 TCP 标志进行复杂的状态转换，您可以在 [图 1-7](#tcp-state) 中看到。
- en: 'The TCP connection states are:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 连接状态包括：
- en: '`LISTEN` (server)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`LISTEN`（服务器）'
- en: Represents waiting for a connection request from any remote TCP and port
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 表示等待来自任何远程 TCP 和端口的连接请求
- en: '`SYN-SENT` (client)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYN-SENT`（客户端）'
- en: Represents waiting for a matching connection request after sending a connection
    request
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表示在发送连接请求后等待匹配的连接请求确认
- en: '`SYN-RECEIVED` (server)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYN-RECEIVED`（服务器）'
- en: Represents waiting for a confirming connection request acknowledgment after
    having both received and sent a connection request
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 表示在收到并发送连接请求后等待确认连接请求的确认连接请求
- en: '`ESTABLISHED` (both server and client)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`ESTABLISHED`（服务器和客户端都是）'
- en: Represents an open connection; data received can be delivered to the user—the
    intermediate state for the data transfer phase of the connection
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 表示已建立连接；接收到的数据可以传递给用户——连接传输阶段的中间状态
- en: '`FIN-WAIT-1` (both server and client)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIN-WAIT-1`（服务器和客户端都是）'
- en: Represents waiting for a connection termination request from the remote host
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 表示等待远程主机的连接终止请求
- en: '`FIN-WAIT-2` (both server and client)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIN-WAIT-2`（服务器和客户端都是）'
- en: Represents waiting for a connection termination request from the remote TCP
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表示等待来自远程 TCP 的连接终止请求
- en: '`CLOSE-WAIT` (both server and client)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLOSE-WAIT`（服务器和客户端都是）'
- en: Represents waiting for a local user’s connection termination request
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表示等待本地用户的连接终止请求
- en: '`CLOSING` (both server and client)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLOSING`（服务器和客户端都是）'
- en: Represents waiting for a connection termination request acknowledgment from
    the remote TCP
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 表示等待远程 TCP 的连接终止请求确认。
- en: '`LAST-ACK` (both server and client)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`LAST-ACK`（服务器和客户端均是如此）'
- en: Represents waiting for an acknowledgment of the connection termination request
    previously sent to the remote host
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表示等待先前发送到远程主机的连接终止请求的确认。
- en: '`TIME-WAIT` (either server or client)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIME-WAIT`（无论是服务器还是客户端）'
- en: Represents waiting for enough time to pass to ensure the remote host received
    the acknowledgment of its connection termination request
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表示等待足够的时间以确保远程主机收到其连接终止请求的确认。
- en: '`CLOSED` (both server and client)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLOSED`（服务器和客户端均是如此）'
- en: Represents no connection state at all
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 表示没有任何连接状态
- en: '![TCP State Diagram](Images/neku_0107.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![TCP 状态图](Images/neku_0107.png)'
- en: Figure 1-7\. TCP state transition diagram
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-7\. TCP 状态转换图
- en: '[Example 1-3](#tcp_connection_states) is a sample of a Mac’s TCP connections,
    their state, and the addresses for both ends of the connection.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 1-3](#tcp_connection_states) 是 Mac 的 TCP 连接示例，显示了它们的状态以及连接两端的地址。'
- en: Example 1-3\. TCP connection states
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-3\. TCP 连接状态
- en: '[PRE3]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we know more about how TCP constructs and tracks connections, let’s
    review the HTTP request for our web server at the Transport layer using TCP. To
    accomplish this, we use a command-line tool called `tcpdump`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更了解 TCP 如何构建和跟踪连接，让我们使用一个名为 `tcpdump` 的命令行工具，来回顾在传输层上使用 TCP 的我们的 Web 服务器的
    HTTP 请求。为了实现这一目标，我们使用一个叫做 `tcpdump` 的命令行工具。
- en: tcpdump
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tcpdump
- en: '`tcpdump` prints out a description of the contents of packets on a network
    interface that matches the boolean expression.'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`tcpdump` 打印出与布尔表达式匹配的网络接口上数据包内容的描述。'
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: tcpdump man page
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: tcpdump 手册页
- en: '`tcpdump` allows administrators and users to display all the packets processed
    on the system and filter them out based on many TCP segment header details. In
    the request, we filter all packets with the destination port 8080 on the network
    interface labeled lo0; this is the local loopback interface on the Mac. Our web
    server is running on 0.0.0.0:8080\. [Figure 1-8](#img-curl) shows where `tcpdump`
    is collecting data in reference to the full TCP/IP stack, between the network
    interface card (NIC) driver and layer 2.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcpdump` 允许管理员和用户显示系统上处理的所有数据包，并根据许多 TCP 段头部细节进行过滤。在请求中，我们过滤所有目的端口为 8080 的网络接口
    lo0 上的数据包；这是 Mac 上的本地回环接口。我们的 Web 服务器运行在 0.0.0.0:8080。图 1-8\. [Figure 1-8](#img-curl)
    显示了 `tcpdump` 收集数据的位置，参考完整的 TCP/IP 栈，位于网络接口卡（NIC）驱动程序和第二层之间。'
- en: '![neku 0108](Images/neku_0108.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![neku 0108](Images/neku_0108.png)'
- en: Figure 1-8\. `tcpdump` packet capture
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-8\. `tcpdump` 数据包捕获
- en: Note
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A loopback interface is a logical, virtual interface on a device. A loopback
    interface is not a physical interface like Ethernet interface. Loopback interfaces
    are always up and running and always available, even if other interfaces are down
    on the host.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 回环接口是设备上的逻辑虚拟接口。回环接口不像以太网接口那样是物理接口。回环接口始终处于活动状态，即使主机上的其他接口关闭，它们也始终可用。
- en: 'The general format of a `tcpdump` output will contain the following fields:
    `tos`,`TTL`, `id`, `offset`, `flags`, `proto`, `length`, and `options`. Let’s
    review these:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcpdump` 的一般输出格式将包含以下字段：`tos`, `TTL`, `id`, `offset`, `flags`, `proto`, `length`
    和 `options`。让我们来回顾一下这些：'
- en: '`tos`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`tos`'
- en: The type of service field.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类型字段。
- en: '`TTL`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`TTL`'
- en: The time to live; it is not reported if it is zero.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 存活时间；如果为零则不报告。
- en: '`id`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`'
- en: The IP identification field.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: IP 标识字段。
- en: '`offset`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`offset`'
- en: The fragment offset field; it is printed whether this is part of a fragmented
    datagram or not.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 分段偏移字段；无论是否是分段数据报的一部分，都会打印此字段。
- en: '`flags`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags`'
- en: The DF, Don’t Fragment, flag, which indicates that the packet cannot be fragmented
    for transmission. When unset, it indicates that the packet can be fragmented.
    The MF, More Fragments, flag indicates there are packets that contain more fragments
    and when unset, it indicates that no more fragments remain.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: DF（不分片）标志，指示数据包不能用于传输时分片。当未设置时，表示数据包可以分片。MF（更多分片）标志指示有包含更多分片的数据包，当未设置时，表示不再有分片。
- en: '`proto`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`proto`'
- en: The protocol ID field.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 协议 ID 字段。
- en: '`length`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`'
- en: The total length field.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 总长度字段。
- en: '`options`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`'
- en: The IP options.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: IP 选项。
- en: Systems that support checksum offloading and IP, TCP, and UDP checksums are
    calculated on the NIC before being transmitted on the wire. Since we are running
    a `tcpdump` packet capture before the NIC, errors like `cksum 0xfe34 (incorrect
    -> 0xb4c1)` appear in the output of [Example 1-4](#tcp_dump).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 支持校验和卸载和IP、TCP和UDP校验和在传输到线路之前在NIC上计算的系统。由于我们在NIC之前运行`tcpdump`数据包捕获，所以像`cksum
    0xfe34 (incorrect -> 0xb4c1)`这样的错误会出现在[示例 1-4](#tcp_dump)的输出中。
- en: To produce the output for [Example 1-4](#tcp_dump), open another terminal and
    start a `tcpdump` trace on the loopback for only TCP and port 8080; otherwise,
    you will see a lot of other packets not relevant to our example. You’ll need to
    use escalated privileges to trace packets, so that means using `sudo` in this
    case.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成[示例 1-4](#tcp_dump)的输出，请在另一个终端打开并在环回接口上开始`tcpdump`跟踪，仅针对TCP和端口8080；否则，您将看到许多与我们示例无关的其他数据包。您需要使用升级特权来跟踪数据包，这意味着在这种情况下使用`sudo`。
- en: Example 1-4\. `tcpdump`
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-4\. `tcpdump`
- en: '[PRE4]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_networking_introduction_CO2-1)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_networking_introduction_CO2-1)'
- en: This is the start of the `tcpdump` collection with its command and all of its
    options. The `sudo` packet captures the required escalated privileges. `tcpdump`
    is the `tcpdump` binary. `-i lo0` is the interface from which we want to capture
    packets. `dst port 8080` is the matching expression that the man page discussed;
    here we are matching on all packets destined for TCP port 8080, which is the port
    the web service is listening to for requests. `-v` is the verbose option, which
    allows us to see more details from the `tcpdump` capture.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用其命令及其所有选项进行`tcpdump`收集的开始。`sudo`数据包捕获了所需的升级特权。`tcpdump`是`tcpdump`二进制文件。`-i
    lo0`是我们想要捕获数据包的接口。`dst port 8080`是匹配表达式，即手册中讨论的内容；这里我们匹配所有发送到TCP端口8080的数据包，这是Web服务用于接收请求的端口。`-v`是详细选项，允许我们从`tcpdump`捕获中查看更多细节。
- en: '[![2](Images/2.png)](#co_networking_introduction_CO2-2)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_networking_introduction_CO2-2)'
- en: Feedback from `tcpdump` letting us know about the `tcpdump` filter running.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcpdump`的反馈告诉我们关于运行的`tcpdump`过滤器。'
- en: '[![3](Images/3.png)](#co_networking_introduction_CO2-3)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_networking_introduction_CO2-3)'
- en: This is the first packet in the TCP handshake. We can tell it’s the SYN because
    the flags bit is set with `[S]`, and the sequence number is set to `2784345138`
    by cURL, with the localhost process number being `50399`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是TCP握手中的第一个数据包。我们可以通过设置的标志位`[S]`和由cURL设置的序列号`2784345138`来判断这是SYN，本地进程号为`50399`。
- en: '[![4](Images/4.png)](#co_networking_introduction_CO2-4)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_networking_introduction_CO2-4)'
- en: The SYN-ACK packet is the the one filtered by `tcpdump` from the `localhost.http-alt`
    process, the Golang web server. The flag is to `[S.]`, so it is a SYN-ACK. The
    packet sends `195606347` as the next sequence number, and ACK `2784345139` is
    set to acknowledge the previous packet.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由`tcpdump`从`localhost.http-alt`进程中过滤出的SYN-ACK数据包，即Golang Web服务器。标志为`[S.]`，因此是SYN-ACK。数据包发送`195606347`作为下一个序列号，ACK设置为`2784345139`以确认前一个数据包。
- en: '[![5](Images/5.png)](#co_networking_introduction_CO2-5)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_networking_introduction_CO2-5)'
- en: The acknowledgment packet from cURL is now sent back to the server with the
    ACK flag set, `[.]`, with the ACK and SYN numbers set to 1, indicating it is ready
    to send data.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: cURL的确认数据包现在带有设置的ACK标志`[.]`，ACK和SYN号设置为1，表示准备发送数据。
- en: '[![6](Images/6.png)](#co_networking_introduction_CO2-6)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_networking_introduction_CO2-6)'
- en: The acknowledgment number is set to 1 to indicate the client’s SYN flag’s receipt
    in the opening data push.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 确认号设置为1，以指示在开放数据推送中客户端的SYN标志的接收。
- en: '[![7](Images/7.png)](#co_networking_introduction_CO2-7)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_networking_introduction_CO2-7)'
- en: The TCP connection is established; both the client and server are ready for
    data transmission. The next packets are our data transmissions of the HTTP request
    with the flag set to a data push and ACK, `[P.]`. The previous packets had a length
    of zero, but the HTTP request is 78 bytes long, with a sequence number of 1:79.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接已建立；客户端和服务器均已准备好进行数据传输。接下来的数据包是我们的HTTP请求数据传输，标志设置为数据推送和ACK`[P.]`。前面的数据包长度为零，但HTTP请求为78字节长，序列号为1:79。
- en: '[![8](Images/8.png)](#co_networking_introduction_CO2-8)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_networking_introduction_CO2-8)'
- en: The server acknowledges the receipt of the data transmission, with the ACK flag
    set, `[.]`, by sending the acknowledgment number of 79.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器确认数据传输的接收，设置了ACK标志`[.]`，发送了序列号为79的确认号。
- en: '[![9](Images/9.png)](#co_networking_introduction_CO2-9)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](Images/9.png)](#co_networking_introduction_CO2-9)'
- en: This packet is the HTTP server’s response to the cURL request. The data push
    flag is set, `[P.]`, and it acknowledges the previous packet with an ACK number
    of 79\. A new sequence number is set with the data transmission, 122, and the
    data length is 121 bytes.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包是 HTTP 服务器对 cURL 请求的响应。数据推送标志被设置，`[P.]`，并用 ACK 数字 79 确认了前一个包。设置数据传输的新序列号为
    122，数据长度为 121 字节。
- en: '[![10](Images/10.png)](#co_networking_introduction_CO2-10)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](Images/10.png)](#co_networking_introduction_CO2-10)'
- en: The cURL client acknowledges the receipt of the packet with the ACK flag set,
    sets the acknowledgment number to 122, and sets the sequence number to 79.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: cURL 客户端用设置 ACK 标志的包确认接收该包，将确认号设置为 122，并将序列号设置为 79。
- en: '[![11](Images/11.png)](#co_networking_introduction_CO2-11)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](Images/11.png)](#co_networking_introduction_CO2-11)'
- en: The start of closing the TCP connection, with the client sending the FIN-ACK
    packet, the `[F.]`, acknowledging the receipt of the previous packet, number 122,
    and a new sequence number to 80.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 开始关闭 TCP 连接，客户端发送 FIN-ACK 包，`[F.]`，确认接收了前一个包，编号为 122，并将新的序列号设为 80。
- en: '[![12](Images/12.png)](#co_networking_introduction_CO2-12)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](Images/12.png)](#co_networking_introduction_CO2-12)'
- en: The server increments the acknowledgment number to 80 and sets the ACK flag.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将确认号增加到 80 并设置 ACK 标志。
- en: '[![13](Images/13.png)](#co_networking_introduction_CO2-13)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](Images/13.png)](#co_networking_introduction_CO2-13)'
- en: TCP requires that both the sender and the receiver set the FIN packet for closing
    the connection. This is the packet where the FIN and ACK flags are set.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 要求发送方和接收方都设置 FIN 包以关闭连接。这是 FIN 和 ACK 标志被设置的包。
- en: '[![14](Images/14.png)](#co_networking_introduction_CO2-14)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[![14](Images/14.png)](#co_networking_introduction_CO2-14)'
- en: This is the final ACK from the client, with acknowledgment number 123\. The
    connection is closed now.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端的最终 ACK，确认号为 123。连接现在已关闭。
- en: '[![15](Images/15.png)](#co_networking_introduction_CO2-15)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[![15](Images/15.png)](#co_networking_introduction_CO2-15)'
- en: '`tcpdump` on exit lets us know the number of packets in this capture, the total
    number of the packets captured during the `tcpdump`, and how many packets were
    dropped by the operating system.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcpdump` 在退出时会告诉我们此次捕获的包数、在 `tcpdump` 期间捕获的包的总数，以及操作系统丢弃了多少包。'
- en: '`tcpdump` is an excellent troubleshooting application for network engineers
    as well as cluster administrators. Being able to verify connectivity at many levels
    in the cluster and the network are valuable skills to have. You will see in [Chapter 6](ch06.xhtml#kubernetes_and_cloud_networking)
    how useful `tcpdump` can be.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcpdump` 是网络工程师和集群管理员的一个优秀故障排除工具。能够在集群和网络的多个层面验证连通性是非常有价值的技能。你将在 [第 6 章](ch06.xhtml#kubernetes_and_cloud_networking)
    中看到 `tcpdump` 的用处。'
- en: Our example was a simple HTTP application using TCP. All of this data was sent
    over the network in plain text. While this example was a simple Hello World, other
    requests like our bank logins need to have some security. The Transport layer
    does not offer any security protection for data transiting the network. TLS adds
    additional security on top of TCP. Let’s dive into that in our next section.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例是一个使用 TCP 的简单 HTTP 应用程序。所有这些数据都是以明文形式通过网络发送的。虽然这个示例是一个简单的 Hello World，但其他请求，如我们的银行登录，需要一些安全措施。传输层不会为通过网络传输的数据提供任何安全保护。TLS
    在 TCP 上添加了额外的安全保护。让我们在下一节中深入了解。
- en: TLS
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLS
- en: 'TLS adds encryption to TCP. TLS is an add-on to the TCP/IP suite and is not
    considered to be part of the base operation for TCP. HTTP transactions can be
    completed without TLS but are not secure from eavesdroppers on the wire. TLS is
    a combination of protocols used to ensure traffic is seen between the sender and
    the intended recipient. TLS, much like TCP, uses a handshake to establish encryption
    capabilities and exchange keys for encryption. The following steps detail the
    TLS handshake between the client and the server, which can also be seen in [Figure 1-9](#img-tls-handshake):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 为 TCP 添加了加密。TLS 是 TCP/IP 套件的一个附加组件，不被视为 TCP 基本操作的一部分。HTTP 事务可以在没有 TLS 的情况下完成，但在网络中不会受到窃听者的攻击。TLS
    是一种协议组合，用于确保发送者和接收者之间的流量安全。TLS 与 TCP 类似，使用握手建立加密能力并交换加密密钥。以下步骤详细介绍了客户端和服务器之间的
    TLS 握手，也可以在 [图 1-9](#img-tls-handshake) 中看到：
- en: 'ClientHello: This contains the cipher suites supported by the client and a
    random number.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ClientHello：这包含客户端支持的密码套件和一个随机数。
- en: 'ServerHello: This message contains the cipher it supports and a random number.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ServerHello：此消息包含它支持的密码及一个随机数。
- en: 'ServerCertificate: This contains the server’s certificate and its server public
    key.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ServerCertificate：包含服务器的证书及其服务器公钥。
- en: 'ServerHelloDone: This is the end of the ServerHello. If the client receives
    a request for its certificate, it sends a ClientCertificate message.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ServerHelloDone：这是 ServerHello 的结束。如果客户端收到要求其证书的请求，则发送 ClientCertificate 消息。
- en: 'ClientKeyExchange: Based on the server’s random number, our client generates
    a random premaster secret, encrypts it with the server’s public key certificate,
    and sends it to the server.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ClientKeyExchange：基于服务器的随机数，我们的客户端生成一个随机的预主密钥，用服务器的公钥证书加密后发送给服务器。
- en: 'Key Generation: The client and server generate a master secret from the premaster
    secret and exchange random values.'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密钥生成：客户端和服务器从预主密钥生成一个主密钥，并交换随机值。
- en: 'ChangeCipherSpec: Now the client and server swap their ChangeCipherSpec to
    begin using the new keys for encryption.'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ChangeCipherSpec：现在客户端和服务器交换它们的 ChangeCipherSpec 以开始使用新密钥进行加密。
- en: 'Finished Client: The client sends the finished message to confirm that the
    key exchange and authentication were successful.'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成客户端：客户端发送完成消息以确认密钥交换和认证成功。
- en: 'Finished Server: Now, the server sends the finished message to the client to
    end the handshake.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成服务器：现在，服务器向客户端发送完成消息以结束握手。
- en: Kubernetes applications and components will manage TLS for developers, so a
    basic introduction is required; [Chapter 5](ch05.xhtml#kubernetes_networking_abstractions)
    reviews more about TLS and Kubernetes.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 应用程序和组件将为开发人员管理 TLS，因此需要基本介绍；[第 5 章](ch05.xhtml#kubernetes_networking_abstractions)
    将进一步审视 TLS 和 Kubernetes。
- en: As demonstrated with our web server, cURL, and `tcpdump`, TCP is a stateful
    and reliable protocol for sending data between hosts. Its use of flags, combined
    with the sequence and acknowledgment number dance it performs, delivers thousands
    of messages over unreliable networks across the globe. That reliability comes
    at a cost, however. Of the 12 packets we set, only two were real data transfers.
    For applications that do not need reliability such as voice, the overhead that
    comes with UDP offers an alternative. Now that we understand how TCP works as
    a reliable connection-oriented protocol, let’s review how UDP differs from TCP.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们的 Web 服务器、cURL 和 `tcpdump` 所示，TCP 是一种在主机之间发送数据的有状态可靠协议。它使用标志位、序列号和确认号的交互来在全球不可靠网络上传递数千条消息。然而，这种可靠性是有代价的。在我们设置的
    12 个数据包中，只有两个是真正的数据传输。对于不需要像语音这样可靠性的应用程序来说，UDP 带来的开销提供了一种替代选择。现在我们理解了作为可靠连接导向协议的
    TCP 如何运作，让我们来回顾一下 UDP 与 TCP 的区别。
- en: '![TLS Handshake](Images/neku_0109.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![TLS 握手](Images/neku_0109.png)'
- en: Figure 1-9\. TLS handshake
  id: totrans-315
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-9\. TLS 握手
- en: UDP
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UDP
- en: UDP offers an alternative to applications that do not need the reliability that
    TCP provides. UDP is an excellent choice for applications that can withstand packet
    loss such as voice and DNS. UDP offers little overhead from a network perspective,
    only having four fields and no data acknowledgment, unlike its verbose brother
    TCP.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 为那些不需要 TCP 提供的可靠性的应用程序提供了一种选择。UDP 对于能够承受数据包丢失的应用程序（例如语音和 DNS）非常适合。从网络角度来看，UDP
    的开销很小，只有四个字段，没有数据确认，不像其冗长的兄弟 TCP。
- en: It is transaction-oriented, suitable for simple query and response protocols
    like the Domain Name System (DNS) and Simple Network Management Protocol (SNMP).
    UDP slices a request into datagrams, making it capable for use with other protocols
    for tunneling like a virtual private network (VPN). It is lightweight and straightforward,
    making it great for bootstrapping application data in the case of DHCP. The stateless
    nature of data transfer makes UDP perfect for applications, such as voice, that
    can withstand packet loss—did you hear that? UDP’s lack of retransmit also makes
    it an apt choice for streaming video.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 它是事务导向的，适用于简单的查询和响应协议，如域名系统（DNS）和简单网络管理协议（SNMP）。UDP 将请求分割成数据报，因此适用于其他隧道协议（如虚拟专用网络（VPN））。它轻量且简单，非常适合在
    DHCP 的情况下引导应用程序数据。数据传输的无状态性使 UDP 成为能够承受数据包丢失的应用程序（例如语音）的完美选择——你听到了吗？UDP 的不重新传输也使其成为流媒体视频的适当选择。
- en: 'Let’s look at the small number of headers required in a UDP datagram (see [Figure 1-10](#udp-header)):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 UDP 数据报中所需的少量头部信息（参见[图 1-10](#udp-header)）：
- en: '`Source port number` (2 bytes)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`源端口号`（2 字节）'
- en: Identifies the sender’s port. The source host is the client; the port number
    is ephemeral. UDP ports have well-known numbers like DNS on 53 or DHCP 67/68.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 标识发送端口。源主机是客户端；端口号是临时的。UDP端口有像DNS的53或DHCP的67/68这样的众所周知的数字。
- en: '`Destination port number` (2 bytes)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`目标端口号`（2字节）'
- en: Identifies the receiver’s port and is required.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 标识接收端口并且是必需的。
- en: '`Length` (2 bytes)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`长度`（2字节）'
- en: Specifies the length in bytes of the UDP header and UDP data. The minimum length
    is 8 bytes, the length of the header.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 指定UDP头部和UDP数据的长度（以字节为单位）。最小长度为8字节，即头部的长度。
- en: '`Checksum` (2 bytes)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`校验和`（2字节）'
- en: Used for error checking of the header and data. It is optional in IPv4, but
    mandatory in IPv6, and is all zeros if unused.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 用于对头部和数据进行错误检查。在IPv4中是可选的，但在IPv6中是强制的，如果未使用则全部为零。
- en: UDP and TCP are general transport protocols that help ship and receive data
    between hosts. Kubernetes supports both protocols on the network, and services
    allow users to load balance many pods using services. Also important to note is
    that in each service, developers must define the transport protocol; if they do
    not TCP is the default used.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: UDP和TCP是通用的传输协议，帮助主机之间发送和接收数据。Kubernetes在网络上支持这两种协议，服务允许用户通过服务来负载均衡许多Pod。还需要注意的是，在每个服务中，开发人员必须定义传输协议；如果未定义，则默认使用TCP。
- en: '![udp header](Images/neku_0110.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![udp头部](Images/neku_0110.png)'
- en: Figure 1-10\. UDP header
  id: totrans-330
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-10\. UDP头部
- en: The next layer in the TCP/IP stack is the Internetworking layer—these are packets
    that can get sent across the globe on the vast networks that make up the internet.
    Let’s review how that gets completed.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP堆栈中的下一层是互联网层——这些是可以在组成互联网的广阔网络上发送的数据包。让我们回顾一下如何完成这个过程。
- en: Network
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: All TCP and UDP data gets transmitted as IP packets in TCP/IP in the Network
    layer. The Internet or Network layer is responsible for transferring data between
    networks. Outgoing packets select the next-hop host and send the data to that
    host by passing it the appropriate Link layer details; packets are received by
    a host, de-encapsulated, and sent up to the proper Transport layer protocol. In
    IPv4, both transmit and receive, IP provides fragmentation or defragmentation
    of packets based on the MTU; this is the maximum size of the IP packet.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的TCP和UDP数据在TCP/IP网络层中作为IP数据包进行传输。互联网或网络层负责在网络之间传输数据。出站数据包选择下一跳主机，并通过传递适当的链路层细节将数据发送给该主机；数据包由主机接收，去封装后发送到适当的传输层协议上。在IPv4中，无论是发送还是接收，IP根据MTU提供数据包的分段或重组；这是IP数据包的最大大小。
- en: IP makes no guarantees about packets’ proper arrival; since packet delivery
    across diverse networks is inherently unreliable and failure-prone, that burden
    is with the endpoints of a communication path, rather than on the network. As
    discussed in the previous section, providing service reliability is a function
    of the Transport layer. Each packet has a checksum to ensure that the received
    packet’s information is accurate, but this layer does not validate data integrity.
    Source and destination IP addresses identify packets on the network, which we’ll
    address next.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: IP不保证数据包的正确到达；因为跨不同网络的数据包传递本质上是不可靠和容易出错的，这个负担在通信路径的端点上而不是网络上。如前所述，提供服务可靠性是传输层的功能。每个数据包都有一个校验和来确保接收到的数据包信息准确，但此层不验证数据完整性。源和目标IP地址标识网络上的数据包，我们将在下一步讨论。
- en: Internet Protocol
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网协议
- en: This almighty packet is defined in RFC 791 and is used for sending data across
    networks. [Figure 1-11](#img-ipv4-header) shows the IPv4 header format.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个强大的数据包在RFC 791中定义，用于在网络间发送数据。[图1-11](#img-ipv4-header)展示了IPv4头部的格式。
- en: '![neku 0111](Images/neku_0111.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![neku 0111](Images/neku_0111.png)'
- en: Figure 1-11\. IPv4 header format
  id: totrans-338
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-11\. IPv4头部格式
- en: 'Let’s look at the header fields in more detail:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看头部字段：
- en: '`Version`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`版本`'
- en: The first header field in the IP packet is the four-bit version field. For IPv4,
    this is always equal to four.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: IP数据包中的第一个头部字段是四位版本字段。对于IPv4，这总是等于四。
- en: '`Internet Header Length` (IHL)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`互联网头部长度`（IHL）'
- en: The IPv4 header has a variable size due to the optional 14th field option.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4头部由于可选的第14个字段选项而具有可变大小。
- en: '`Type of Service`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`服务类型`'
- en: Originally defined as the type of service (ToS), now Differentiated Services
    Code Point (DSCP), this field specifies differentiated services. DSC Pallows for
    routers and networks to make decisions on packet priority during times of congestion.
    Technologies such as Voice over IP use DSCP to ensure calls take precedence over
    other traffic.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最初定义为服务类型（ToS），现在是区分服务代码点（DSCP），此字段指定不同的服务。DSCP允许路由器和网络在拥塞时对数据包优先级进行决策。诸如VoIP等技术使用DSCP以确保通话优先于其他流量。
- en: '`Total Length`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`总长度`'
- en: This is the entire packet size in bytes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个数据包大小（以字节为单位）。
- en: '`Identification`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`标识`'
- en: This is the identification field and is used for uniquely identifying the group
    of fragments of a single IP datagram.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标识字段，用于唯一标识单个IP数据报的片段组。
- en: '`Flags`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`标志`'
- en: 'This is used to control or identify fragments. In order from most significant
    to least:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于控制或识别片段。从最重要到最不重要的顺序：
- en: 'bit 0: Reserved, set to zero'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0位：保留，设为零
- en: 'bit 1: Do not Fragment'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1位：不分段
- en: 'bit 2: More Fragments'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2位：更多片段
- en: '`Fragment Offset`'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`片段偏移`'
- en: This specifies the offset of a distinct fragment relative to the first unfragmented
    IP packet. The first fragment always has an offset of zero.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定相对于第一个未分段IP数据包的明显片段的偏移量。第一个片段的偏移量始终为零。
- en: '`Time To Live (TTL)`'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`生存时间（TTL）`'
- en: An 8-bit time to live field helps prevent datagrams from going in circles on
    a network.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 8位生存时间字段有助于防止数据包在网络上循环。
- en: '`Protocol`'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`协议`'
- en: This is used in the data section of the IP packet. IANA has a list of IP protocol
    numbers in RFC 790; some well-known protocols are also detailed in [Table 1-4](#ip_protocol_numbers).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于IP数据包的数据部分。IANA在RFC 790中列出了IP协议号的列表；一些知名协议也在表1-4中详细说明。
- en: Table 1-4\. IP protocol numbers
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-4. IP协议号
- en: '| Protocol number | Protocol name | Abbreviation |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 协议号 | 协议名称 | 缩写 |'
- en: '| --- | --- | --- |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Internet Control Message Protocol | ICMP |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 互联网控制消息协议 | ICMP |'
- en: '| 2 | Internet Group Management Protocol | IGMP |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 互联网组管理协议 | IGMP |'
- en: '| 6 | Transmission Control Protocol | TCP |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 传输控制协议 | TCP |'
- en: '| 17 | User Datagram Protocol | UDP |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 用户数据报协议 | UDP |'
- en: '| 41 | IPv6 Encapsulation | ENCAP |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 41 | IPv6封装 | ENCAP |'
- en: '| 89 | Open Shortest Path First | OSPF |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 开放最短路径优先 | OSPF |'
- en: '| 132 | Stream Control Transmission Protocol | SCTP |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 132 | 流控制传输协议 | SCTP |'
- en: '`Header Checksum` (16-bit)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`头部校验和`（16位）'
- en: The IPv4 header checksum field is used for error checking. When a packet arrives,
    a router computes the header’s checksum; the router drops the packet if the two
    values do not match. The encapsulated protocol must handle errors in the data
    field. Both UDP and TCP have checksum fields.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4头部校验和字段用于错误检查。当数据包到达时，路由器计算头部的校验和；如果两个值不匹配，路由器将丢弃数据包。封装协议必须处理数据字段中的错误。UDP和TCP均有校验和字段。
- en: Note
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When the router receives a packet, it lowers the TTL field by one. As a consequence,
    the router must compute a new checksum.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器接收到一个数据包时，它将TTL字段减一。因此，路由器必须计算新的校验和。
- en: '`Source address`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`源地址`'
- en: This is the IPv4 address of the sender of the packet.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据包发送者的IPv4地址。
- en: Note
  id: totrans-377
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The source address may be changed in transit by a network address translation
    device; NAT will be discussed later in this chapter and extensively in [Chapter 3](ch03.xhtml#container_networking_basics).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 源地址可能会在传输过程中被网络地址转换设备更改；NAT将在本章后面讨论，并在[第3章](ch03.xhtml#container_networking_basics)中广泛讨论。
- en: '`Destination address`'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`目标地址`'
- en: This is the IPv4 address of the receiver of the packet. As with the source address,
    a NAT device can change the destination IP address.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据包接收者的IPv4地址。与源地址一样，NAT设备可以更改目标IP地址。
- en: '`Options`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`选项`'
- en: The possible options in the header are Copied, Option Class, Option Number,
    Option Length, and Option Data.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 头部中的可能选项是复制、选项类别、选项编号、选项长度和选项数据。
- en: The crucial component here is the address; it’s how networks are identified.
    They simultaneously identify the host on the network and the whole network itself
    (more on that in [“Getting round the network”](#getround)). Understanding how
    to identify an IP address is critical for an engineer. First, we will review IPv4
    and then understand the drastic changes in IPv6.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键组件是地址；这是网络识别的方式。它同时标识网络上的主机和整个网络本身（更多内容请参见“在网络中四处走动”）。理解如何识别IP地址对于工程师至关重要。首先，我们将回顾IPv4，然后了解IPv6中的重大变化。
- en: 'IPv4 addresses are in the dotted-decimal notation for us humans; computers
    read them out as binary strings. [Figure 1-12](#ipv-four-address) details the
    dotted-decimal notation and binary. Each section is 8 bits in length, with four
    sections, making the complete length 32 bits. IPv4 addresses have two sections:
    the first part is the network, and the second is the host’s unique identifier
    on the network.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址对我们人类来说是点分十进制表示法；计算机将其读取为二进制字符串。[图 1-12](#ipv-four-address)详细描述了点分十进制表示法和二进制表示法。每个部分的长度为8位，共有四个部分，总长度为32位。IPv4地址有两个部分：第一部分是网络，第二部分是网络上主机的唯一标识符。
- en: '![IPv4 Address](Images/neku_0112.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4地址](Images/neku_0112.png)'
- en: Figure 1-12\. IPv4 address
  id: totrans-386
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-12\. IPv4地址
- en: In [Example 1-5](#ip_address), we have the output of a computer’s IP address
    for its network interface card and we can see its IPv4 address is `192.168.1.2`.
    The IP address also has a subnet mask or netmask associated with it to make out
    what network it is assigned. The example’s subnet is `netmask 0xffffff00` in dotted-decimal,
    which is `255.255.255.0`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 1-5](#ip_address)中，我们有计算机网络接口卡的IP地址输出，我们可以看到其IPv4地址是`192.168.1.2`。该IP地址还有与之关联的子网掩码或网络掩码，以确定其所分配的网络。示例的子网是以点分十进制表示的`netmask
    0xffffff00`，即`255.255.255.0`。
- en: Example 1-5\. IP address
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-5\. IP地址
- en: '[PRE5]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The subnet brings up the idea of classful addressing. Initially, when an IP
    address range was assigned, a range was considered to be the combination of an
    8-, 16-, or 24-bit network prefix along with a 24-, 16-, or 8-bit host identifier,
    respectively. Class A had 8 bits for the host, Class B 16, and Class C 24\. Following
    that, Class A had 2 to the power of 16 hosts available, 16,777,216; Class B had
    65,536; and Class C had 256\. Each class had a host address, the first one in
    its boundary, and the last one was designated as the broadcast address. [Figure 1-13](#ipv-four-class-address)
    demonstrates this for us.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 子网提出了类地址分配的概念。最初，当分配IP地址范围时，一个范围被认为是8位、16位或24位网络前缀与24位、16位或8位主机标识符的组合。类A有8位用于主机，类B有16位，类C有24位。因此，类A有2的16次方个可用主机，即16,777,216个；类B有65,536个；类C有256个。每个类都有一个主机地址，第一个在其边界内，最后一个被指定为广播地址。[图 1-13](#ipv-four-class-address)为我们演示了这一点。
- en: Note
  id: totrans-391
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are two other classes, but they are not generally used in IP addressing.
    Class D addresses are used for IP multicasting, and Class E addresses are reserved
    for experimental use.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他两个类别，但它们在IP寻址中通常不使用。类D地址用于IP多播，类E地址保留用于实验。
- en: '![IPv4 Class Address](Images/neku_0113.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4类地址](Images/neku_0113.png)'
- en: Figure 1-13\. IP class
  id: totrans-394
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-13\. IP类
- en: Classful addressing was not scalable on the internet, so to help alleviate that
    scale issue, we began breaking up the class boundaries using Classless Inter-Domain
    Routing (CIDR) ranges. Instead of having the full 16 million-plus addresses in
    a class address range, an internet entity gives only a subsection of that range.
    This effectively allows network engineers to move the subnet boundary to anywhere
    inside the class range, giving them more flexibility with CIDR ranges, and helping
    to scale IP address ranges.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的地址分配在互联网上是不可扩展的，为了帮助缓解这个规模问题，我们开始使用无类域间路由（CIDR）范围来打破类别边界。与其说是在一个类地址范围内拥有1600多万个地址，不如说互联网实体只分配该范围的一个子范围。这有效地允许网络工程师将子网边界移动到类范围内的任意位置，从而使他们在CIDR范围内更加灵活，并有助于扩展IP地址范围。
- en: In [Figure 1-14](#cidr-example), we can see the breakdown of the `208.130.29.33`
    IPv4 address and the hierarchy that it creates. The `208.128.0.0/11` CIDR range
    is assigned to ARIN from IANA. ARIN further breaks down the subnet to smaller
    and smaller subnets for its purposes, leading to the single host on the network
    `208.130.29.33/32`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-14](#cidr-example)中，我们可以看到`208.130.29.33` IPv4地址的分解及其创建的层次结构。`208.128.0.0/11`
    CIDR范围从IANA分配给ARIN。ARIN进一步将子网分解为更小的子网，以满足其需求，导致网络上的单个主机`208.130.29.33/32`。
- en: '![CIDR example](Images/neku_0114.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![CIDR示例](Images/neku_0114.png)'
- en: Figure 1-14\. CIDR example
  id: totrans-398
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-14\. CIDR示例
- en: Note
  id: totrans-399
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The global coordination of the DNS root, IP addressing, and other internet protocol
    resources is performed by IANA.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: IANA负责全球DNS根、IP寻址和其他互联网协议资源的协调。
- en: Eventually, though, even this practice of using CIDR to extend the range of
    an IPv4 address led to an exhaustion of address spaces that could be doled out,
    leading network engineers and IETF to develop the IPv6 standard.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，即使这种使用CIDR扩展IPv4地址范围的做法也导致了可分配的地址空间的枯竭，这促使网络工程师和IETF制定了IPv6标准。
- en: In [Figure 1-15](#ipv-six-address), we can see that IPv6, unlike IPv4, uses
    hexadecimal to shorten addresses for writing purposes. It has similar characteristics
    to IPv4 in that it has a host and network prefix.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图1-15](#ipv-six-address)中，我们可以看到IPv6与IPv4不同，它使用十六进制缩短地址以便书写。它与IPv4类似，具有主机和网络前缀的特性。
- en: 'The most significant difference between IPv4 and IPv6 is the size of the address
    space. IPv4 has 32 bits, while IPv6 has 128 bits to produce its addresses. To
    put that size differential in perspective, here are those numbers:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4与IPv6最显著的差异是地址空间的大小。IPv4有32位，而IPv6有128位来生成其地址。为了让这种大小差异更具体化，这些数字如下：
- en: IPv4 has 4,294,967,296.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4有4,294,967,296。
- en: IPv6 has 340,282,366,920,938,463,463,374,607,431,768,211,456.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6有340,282,366,920,938,463,463,374,607,431,768,211,456。
- en: '![IPv4 Address](Images/neku_0115.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4地址](Images/neku_0115.png)'
- en: Figure 1-15\. IPv6 address
  id: totrans-407
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-15\. IPv6地址
- en: Now that we understand how an individual host on the network is identified and
    what network it belongs to, we will explore how those networks exchange information
    between themselves using routing protocols.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何识别网络中的单个主机以及它所属的网络，我们将探讨这些网络如何使用路由协议在彼此之间交换信息。
- en: Getting round the network
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过网络
- en: Packets are addressed, and data is ready to be sent, but how do our packets
    get from our host on our network to the intended hosted on another network halfway
    around the world? That is the job of routing. There are several routing protocols,
    but the internet relies on Border Gateway Protocol (BGP), a dynamic routing protocol
    used to manage how packets get routed between edge routers on the internet. It
    is relevant for us because some Kubernetes network implementations use BGP to
    route cluster network traffic between nodes. Between each node on separate networks
    is a series of routers.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 封包被寄出且数据准备好要送，但是我们的封包如何从我们的网络上的主机到达位于世界另一端的目标网络？这是路由的工作。有几种路由协议，但互联网依赖于边界网关协议（BGP），这是一种动态路由协议，用于管理互联网上边缘路由器之间的封包路由。对我们来说它是相关的，因为一些Kubernetes网络实现使用BGP在节点之间路由集群网络流量。在分隔的网络节点之间有一系列路由器。
- en: If we refer to the map of the internet in [Figure 1-1](#img-internet-map), each
    network on the internet is assigned a BGP autonomous system number (ASN) to designate
    a single administrative entity or corporation that represents a common and clearly
    defined routing policy on the internet. BGP and ASNs allows network administrators
    to maintain control of their internal network routing while announcing and summarizing
    their routes on the internet. [Table 1-5](#complete_table_of_asn_available) lists
    the available ASNs managed by IANA and other regional entities.^([1](ch01.xhtml#idm46219953252264))
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们参考[图1-1](#img-internet-map)中的互联网地图，互联网上的每个网络都被分配一个BGP自治系统号（ASN），用于指定代表互联网上通用和明确定义的路由策略的单个管理实体或公司。
    BGP和ASN允许网络管理员在互联网上宣布和总结其路由的同时，维护其内部网络路由的控制。[表1-5](#complete_table_of_asn_available)列出了由IANA和其他区域实体管理的可用ASN。^([1](ch01.xhtml#idm46219953252264))
- en: Table 1-5\. ASNs available
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-5\. 可用的自治系统号（ASN）
- en: '| Number | Bits | Description | Reference |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 编号 | 位 | 描述 | 参考 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 16 | Reserved | RFC 1930, RFC 7607 |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 16 | 保留 | RFC 1930, RFC 7607 |'
- en: '| 1–23455 | 16 | Public ASNs |  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 1–23455 | 16 | 公共ASN |  |'
- en: '| 23456 | 16 | Reserved for AS Pool Transition | RFC 6793 |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 23456 | 16 | 保留用于AS池过渡 | RFC 6793 |'
- en: '| 23457–64495 | 16 | Public ASNs |  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| 23457–64495 | 16 | 公共ASN |  |'
- en: '| 64496–64511 | 16 | Reserved for use in documentation/sample code | RFC 5398
    |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 64496–64511 | 16 | 用于文档/示例代码保留 | RFC 5398 |'
- en: '| 64512–65534 | 16 | Reserved for private use | RFC 1930, RFC 6996 |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 64512–65534 | 16 | 保留供私人使用 | RFC 1930, RFC 6996 |'
- en: '| 65535 | 16 | Reserved | RFC 7300 |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 65535 | 16 | 保留 | RFC 7300 |'
- en: '| 65536–65551 | 32 | Reserved for use in documentation and sample code | RFC
    4893, RFC 5398 |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 65536–65551 | 32 | 用于文档和示例代码保留 | RFC 4893, RFC 5398 |'
- en: '| 65552–131071 | 32 | Reserved |  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| 65552–131071 | 32 | 保留 |  |'
- en: '| 131072–4199999999 | 32 | Public 32-bit ASNs |  |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| 131072–4199999999 | 32 | 公共32位ASN |  |'
- en: '| 4200000000–4294967294 | 32 | Reserved for private use | RFC 6996 |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| 4200000000–4294967294 | 32 | 保留供私人使用 | RFC 6996 |'
- en: '| 4294967295 | 32 | Reserved | RFC 7300 |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 4294967295 | 32 | 保留 | RFC 7300 |'
- en: In [Figure 1-16](#bgp-routing) ,we have five ASNs, 100–500\. A host on `130.10.1.200`
    wants to reach a host destined on `150.10.2.300`. Once the local router or default
    gateway for the host `130.10.1.200` receives the packet, it will look for the
    interface and path for `150.10.2.300` that BGP has determined for that route.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 1-16](#bgp-routing) 中，我们有五个 AS 号码，100–500\. 位于 `130.10.1.200` 的主机想要到达位于
    `150.10.2.300` 的目标主机。一旦位于主机 `130.10.1.200` 的本地路由器或默认网关接收到数据包，它将查找 BGP 为该路由确定的接口和路径。
- en: '![BGP Routing](Images/neku_0116.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![BGP 路由](Images/neku_0116.png)'
- en: Figure 1-16\. BGP routing example
  id: totrans-429
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-16\. BGP 路由示例
- en: Based on the routing table in [Figure 1-17](#route-table), the router for AS
    100 determined the packet belongs to AS 300, and the preferred path is out interface
    `140.10.1.1`. Rinse and repeat on AS 200 until the local router for `150.10.2.300`
    on AS 300 receives that packet. The flow here is described in [Figure 1-6](#three-way-tcp),
    which shows the TCP/IP data flow between networks. A basic understanding of BGP
    is needed because some container networking projects, like Calico, use it for
    routing between nodes; you’ll learn more about this in [Chapter 3](ch03.xhtml#container_networking_basics).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 [图 1-17](#route-table) 中的路由表，AS 100 的路由器确定数据包属于 AS 300，并且首选路径是通过接口 `140.10.1.1`
    出去。在 AS 200 上重复此操作，直到 AS 300 上的本地路由器接收到该数据包。这里的流程在 [图 1-6](#three-way-tcp) 中描述，显示了网络之间的
    TCP/IP 数据流动。需要对 BGP 有基本的理解，因为一些容器网络项目（如 Calico）使用它进行节点之间的路由；您将在 [第 3 章](ch03.xhtml#container_networking_basics)
    中了解更多信息。
- en: '![Route Table](Images/neku_0117.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![路由表](Images/neku_0117.png)'
- en: Figure 1-17\. Local routing table
  id: totrans-432
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-17\. 本地路由表
- en: '[Figure 1-17](#route-table) displays a local route table. In the route table,
    we can see the interface that a packet will be sent out is based on the destination
    IP address. For example, a packet destined for `192.168.1.153` will be sent out
    the `link#11` gateway, which is local to the network, and no routing is needed.
    `192.168.1.254` is the router on the network attached to our internet connection.
    If the destination network is unknown, it is sent out the default route.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-17](#route-table) 显示了一个本地路由表。在路由表中，我们可以看到一个数据包将基于目标 IP 地址发送的接口。例如，一个目标为
    `192.168.1.153` 的数据包将通过本地网络的 `link#11` 网关发送，无需进行路由。`192.168.1.254` 是连接到我们互联网的网络中的路由器。如果目标网络不可知，则发送到默认路由。'
- en: Note
  id: totrans-434
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Like all Linux and BSD OSs, you can find more information on `netstat`’s man
    page (`man netstat`). Apple’s `netstat` is derived from the BSD version. More
    information can be found in the [FreeBSD Handbook](https://oreil.ly/YM0eQ).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有的 Linux 和 BSD 操作系统一样，您可以在 `netstat` 的 man 页面中找到更多信息（`man netstat`）。Apple
    的 `netstat` 源自 BSD 版本。在 [FreeBSD Handbook](https://oreil.ly/YM0eQ) 中可以找到更多信息。
- en: Routers continuously communicate on the internet, exchanging route information
    and informing each other of changes on their respective networks. BGP takes care
    of a lot of that data exchange, but network engineers and system administrators
    can use the ICMP protocol and `ping` command line tools to test connectivity between
    hosts and routers.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器在互联网上持续通信，交换路由信息，并相互通知各自网络上的变化。BGP 负责处理大部分数据交换，但网络工程师和系统管理员可以使用 ICMP 协议和
    `ping` 命令行工具来测试主机和路由器之间的连接。
- en: ICMP
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ICMP
- en: '`ping` is a network utility that uses ICMP for testing connectivity between
    hosts on the network. In [Example 1-6](#icmp_echo_request), we see a successful
    `ping` test to `192.168.1.2`, with five packets all returning an ICMP echo reply.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping` 是一种网络实用工具，用于使用 ICMP 在网络上测试主机之间的连接。在 [示例 1-6](#icmp_echo_request) 中，我们看到对
    `192.168.1.2` 的 `ping` 测试成功，五个数据包均返回了 ICMP 回显回复。'
- en: Example 1-6\. ICMP echo request
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-6\. ICMP 回显请求
- en: '[PRE6]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Example 1-7](#icmp_echo_request_failed) shows a failed ping attempt that times
    out trying to reach host `1.2.3.4`. Routers and administrators will use `ping`
    for testing connections, and it is useful in testing container connectivity as
    well. You’ll learn more about this in Chapters [2](ch02.xhtml#linux_networking)
    and [3](ch03.xhtml#container_networking_basics) as we deploy our minimal Golang
    web server into a container and a pod.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-7](#icmp_echo_request_failed) 显示了尝试到达主机 `1.2.3.4` 的 `ping` 失败的情况，超时。路由器和管理员将使用
    `ping` 进行连接测试，并在测试容器连接时也很有用。在 [第 2](ch02.xhtml#linux_networking) 和 [第 3 章](ch03.xhtml#container_networking_basics)
    中，当我们将我们的极简 Golang Web 服务器部署到容器和 Pod 中时，您将了解更多相关内容。'
- en: Example 1-7\. ICMP echo request failed
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-7\. ICMP 回显请求失败
- en: '[PRE7]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As with TCP and UDP, there are headers, data, and options in ICMP packets;
    they are reviewed here and shown in [Figure 1-18](#ICMP-header):'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 与TCP和UDP一样，ICMP数据包中有头部、数据和选项；它们在这里进行了审查，并在[图1-18](#ICMP-header)中显示：
- en: '`Type`'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`类型`'
- en: ICMP type.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP类型。
- en: '`Code`'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`代码`'
- en: ICMP subtype.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP子类型。
- en: '`Checksum`'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`校验和`'
- en: Internet checksum for error checking, calculated from the ICMP header and data
    with value 0 substitutes for this field.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网校验和用于错误检查，由ICMP头部和数据计算，此字段的值为0。
- en: '`Rest of Header` (4-byte field)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`其余头部`（4字节字段）'
- en: Contents vary based on the ICMP type and code.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 内容根据ICMP类型和代码而变化。
- en: '`Data`'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`数据`'
- en: ICMP error messages contain a data section that includes a copy of the entire
    IPv4 header.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP错误消息包含一个数据部分，其中包括整个IPv4头。
- en: '![icmp header](Images/neku_0118.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![ICMP头部](Images/neku_0118.png)'
- en: Figure 1-18\. ICMP header
  id: totrans-456
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-18\. ICMP头部
- en: Note
  id: totrans-457
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some consider ICMP a Transport layer protocol since it does not use TCP or UDP.
    Per RFC 792, it defines ICMP, which provides routing, diagnostic, and error functionality
    for IP. Although ICMP messages are encapsulated within IP datagrams, ICMP processing
    is considered and is typically implemented as part of the IP layer. ICMP is IP
    protocol 1, while TCP is 6, and UDP is 17.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为ICMP是传输层协议，因为它不使用TCP或UDP。根据RFC 792，ICMP定义了提供IP路由、诊断和错误功能的协议。虽然ICMP消息封装在IP数据报中，但ICMP处理被认为并通常作为IP层的一部分实现。ICMP是IP协议1，而TCP是6，UDP是17。
- en: The value identifies control messages in the `Type` field. The `code` field
    gives additional context information for the message. You can find some standard
    ICMP type numbers in [Table 1-6](#common_icmp_type_numbers).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段的值标识`类型`字段中的控制消息。`代码`字段为消息提供了额外的上下文信息。您可以在[表1-6](#common_icmp_type_numbers)中找到一些标准的ICMP类型编号。
- en: Table 1-6\. Common ICMP type numbers
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-6\. 常见的ICMP类型编号
- en: '| Number | Name | Reference |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| 编号 | 名称 | 参考 |'
- en: '| --- | --- | --- |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Echo reply | RFC 792 |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 回显应答 | RFC 792 |'
- en: '| 3 | Destination unreachable | RFC 792 |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 目标不可达 | RFC 792 |'
- en: '| 5 | Redirect | RFC 792 |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 重定向 | RFC 792 |'
- en: '| 8 | Echo | RFC 792 |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 回显 | RFC 792 |'
- en: Now that our packets know which networks they are being sourced and destined
    to, it is time to start physically sending this data request across the network;
    this is the responsibility of the Link layer.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据包知道它们的源和目的地是哪些网络，是时候开始物理上将这些数据请求发送到网络上了；这是链路层的责任。
- en: Link Layer
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链路层
- en: 'The HTTP request has been broken up into segments, addressed for routing across
    the internet, and now all that is left is to send the data across the wire. The
    Link layer of the TCP/IP stack comprises two sublayers: the Media Access Control
    (MAC) sublayer and the Logical Link Control (LLC) sublayer. Together, they perform
    OSI layers 1 and 2, Data Link and Physical. The Link layer is responsible for
    connectivity to the local network. The first sublayer, MAC, is responsible for
    access to the physical medium. The LLC layer has the privilege of managing flow
    control and multiplexing protocols over the MAC layer to transmit and demultiplexing
    when receiving, as shown in [Figure 1-19](#net-demux). IEEE standard 802.3, Ethernet,
    defines the protocols for sending and receiving frames to encapsulate IP packets.
    IEEE 802 is the overarching standard for LLC (802.2), wireless (802.11), and Ethernet/MAC
    (802.3).'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求已分成段，用于在互联网上进行路由，并且现在剩下的就是将数据发送到电线上。TCP/IP堆栈的链路层包括两个子层：介质访问控制（MAC）子层和逻辑链路控制（LLC）子层。它们共同执行OSI模型的第1层和第2层，即数据链路层和物理层。链路层负责与本地网络的连接。第一个子层MAC负责访问物理介质。LLC层有权管理流量控制和多路复用协议，通过MAC层发送和接收时进行解复用，如[图1-19](#net-demux)所示。IEEE标准802.3，即以太网，定义了用于封装IP数据包的协议。IEEE
    802是LLC（802.2）、无线（802.11）和以太网/MAC（802.3）的总体标准。
- en: '![ethernet-demux](Images/neku_0119.png)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![以太网解复用](Images/neku_0119.png)'
- en: Figure 1-19\. Ethernet demultiplexing example
  id: totrans-471
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-19\. 以太网解复用示例
- en: As with the other PDUs, Ethernet has a header and footers, as shown in [Figure 1-20](#ethernet-header).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他PDU一样，以太网具有头部和页脚，如[图1-20](#ethernet-header)所示。
- en: '![ethernet header](Images/neku_0120.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![以太网头部](Images/neku_0120.png)'
- en: Figure 1-20\. Ethernet header and footer
  id: totrans-474
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-20\. 以太网头部和页脚
- en: 'Let’s review these in detail:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细审查这些：
- en: '`Preamble` (8 bytes)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`前导码`（8字节）'
- en: Alternating string of ones and zeros indicate to the receiving host that a frame
    is incoming.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 交替的1和0位字符串指示接收主机即将收到帧。
- en: '`Destination MAC Address` (6 bytes)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`目的MAC地址`（6字节）'
- en: MAC destination address; the Ethernet frame recipient.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: MAC目的地址；以太网帧的接收者。
- en: '`Source MAC Address` (6 bytes)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`源MAC地址`（6字节）'
- en: MAC source address; the Ethernet frame source.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: MAC源地址；以太网帧源。
- en: '`VLAN tag` (4 bytes)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`VLAN标签`（4字节）'
- en: Optional 802.1Q tag to differentiate traffic on the network segments.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 用于区分网络段上的流量的可选802.1Q标记。
- en: '`Ether-type` (2 bytes)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ether-type`（2字节）'
- en: Indicates which protocol is encapsulated in the payload of the frame.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 指示封装在帧的有效载荷中的协议。
- en: '`Payload` (variable length)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`有效载荷`（可变长度）'
- en: The encapsulated IP packet.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的IP数据包。
- en: '`Frame Check Sequence (FCS)` or `Cycle Redundancy Check (CRC)` (4 bytes)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`帧校验序列（FCS）`或`循环冗余校验（CRC）`（4字节）'
- en: The frame check sequence (FCS) is a four-octet cyclic redundancy check (CRC)
    that allows the detection of corrupted data within the entire frame as received
    on the receiver side. The CRC is part of the Ethernet frame footer.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 帧校验序列（FCS）是一个四字节的循环冗余校验（CRC），允许在接收端检测整个帧中的损坏数据。 CRC是以太网帧尾部的一部分。
- en: '[Figure 1-21](#mac-address) shows that MAC addresses get assigned to network
    interface hardware at the time of manufacture. MAC addresses have two parts: the
    organization unit identifier (OUI) and the NIC-specific parts.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-21](#mac-address) 显示MAC地址在制造时分配给网络接口硬件。 MAC地址有两部分：组织单位标识符（OUI）和NIC特定部分。'
- en: '![Mac Address](Images/neku_0121.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![MAC地址](Images/neku_0121.png)'
- en: Figure 1-21\. MAC address
  id: totrans-492
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-21\. MAC地址
- en: The frame indicates to the recipient of the Network layer packet type. [Table 1-7](#common_ethertype_protocols)
    details the common protocols handled. In Kubernetes, we are mostly interested
    in IPv4 and ARP packets. IPv6 has recently been introduced to Kubernetes in the
    1.19 release.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 帧向网络层数据包的接收方指示类型。 [表 1-7](#common_ethertype_protocols) 详细介绍了常见的处理的协议。 在Kubernetes中，我们主要关注IPv4和ARP数据包。
    IPv6最近在1.19版本中引入到Kubernetes中。
- en: Table 1-7\. Common EtherType protocols
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-7\. 常见的EtherType协议
- en: '| EtherType | Protocol |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| EtherType | 协议 |'
- en: '| --- | --- |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0x0800 | Internet Protocol version 4 (IPv4) |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| 0x0800 | 互联网协议版本4（IPv4） |'
- en: '| 0x0806 | Address Resolution Protocol (ARP) |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| 0x0806 | 地址解析协议（ARP） |'
- en: '| 0x8035 | Reverse Address Resolution Protocol (RARP) |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| 0x8035 | 反向地址解析协议（RARP） |'
- en: '| 0x86DD | Internet Protocol version 6 (IPv6) |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| 0x86DD | 互联网协议版本6（IPv6） |'
- en: '| 0x88E5 | MAC security (IEEE 802.1AE) |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| 0x88E5 | MAC安全（IEEE 802.1AE） |'
- en: '| 0x9100 | VLAN-tagged (IEEE 802.1Q) frame with double tagging |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| 0x9100 | 带有双标记的VLAN标记（IEEE 802.1Q）帧 |'
- en: When an IP packet reaches its destination network, the destination IP address
    is resolved with the Address Resolution Protocol for IPv4 (Neighbor Discovery
    Protocol in the case of IPv6) into the destination host’s MAC address. The Address
    Resolution Protocol must manage address translation from internet addresses to
    Link layer addresses on Ethernet networks. The ARP table is for fast lookups for
    those known hosts, so it does not have to send an ARP request for every frame
    the host wants to send out. [Example 1-8](#arp_table) shows the output of a local
    ARP table. All devices on the network keep a cache of ARP addresses for this purpose.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 当IP数据包到达目标网络时，目标IP地址通过IPv4的地址解析协议（IPv6的邻居发现协议）解析为目标主机的MAC地址。 地址解析协议必须在以太网网络上管理从互联网地址到链路层地址的地址转换。
    ARP表用于快速查找已知主机，因此不必为主机要发送的每个帧发送ARP请求。 [示例 1-8](#arp_table) 显示了本地ARP表的输出。 网络上的所有设备都为此目的保留了ARP地址的缓存。
- en: Example 1-8\. ARP table
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-8\. ARP表
- en: '[PRE8]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Figure 1-22](#arp-request) shows the exchange between hosts on the local network.
    The browser makes an HTTP request for a website hosted by the target server. Through
    DNS, it determines that the server has the IP address `10.0.0.1`. To continue
    to send the HTTP request, it also requires the server’s MAC address. First, the
    requesting computer consults a cached ARP table to look up `10.0.0.1` for any
    existing records of the server’s MAC address. If the MAC address is found, it
    sends an Ethernet frame with the destination address of the server’s MAC address,
    containing the IP packet addressed to `10.0.0.1` onto the link. If the cache did
    not produce a hit for `10.0.0.2`, the requesting computer must send a broadcast
    ARP request message with a destination MAC address of `FF:FF:FF:FF:FF:FF`, which
    is accepted by all hosts on the local network, requesting an answer for `10.0.0.1`.
    The server responds with an ARP response message containing its MAC and IP address.
    As part of answering the request, the server may insert an entry for requesting
    the computer’s MAC address into its ARP table for future use. The requesting computer
    receives and caches the response information in its ARP table and can now send
    the HTTP packets.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-22](#arp-request)展示了本地网络上主机之间的交换。浏览器向目标服务器发出一个获取托管网站的HTTP请求。通过DNS，它确定服务器的IP地址为`10.0.0.1`。为了继续发送HTTP请求，还需要服务器的MAC地址。首先，请求计算机查询缓存的ARP表，查找`10.0.0.1`是否存在服务器MAC地址的记录。如果找到MAC地址，则发送一个以服务器MAC地址为目的地地址的以`10.0.0.1`寻址的IP数据包的以太网帧到链路上。如果缓存没有命中`10.0.0.2`的记录，则请求计算机必须发送一个以广播地址`FF:FF:FF:FF:FF:FF`为目的地MAC地址的ARP请求消息。该消息被本地网络上的所有主机接受，请求`10.0.0.1`的答复。服务器用包含其MAC和IP地址的ARP响应消息回应。作为响应请求的一部分，服务器可能会将请求计算机的MAC地址插入其ARP表以供将来使用。请求计算机接收并缓存响应信息到其ARP表中，现在可以发送HTTP数据包了。'
- en: This also brings up a crucial concept on the local networks, broadcast domains.
    All packets on the broadcast domain receive all the ARP messages from hosts. In
    addition, all frames are sent all nodes on the broadcast, and the host compares
    the destination MAC address to its own. It will discard frames not destined for
    itself. As hosts on the network grow, so too does the broadcast traffic.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这也引出了本地网络上的一个关键概念，即广播域。广播域上的所有主机都接收来自主机的所有ARP消息。此外，所有帧都发送到广播上的所有节点，主机将目标MAC地址与自身的MAC地址进行比较。不属于自身的帧将被丢弃。随着网络上主机的增加，广播流量也随之增加。
- en: '![ARP Request](Images/neku_0122.png)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![ARP 请求](Images/neku_0122.png)'
- en: Figure 1-22\. ARP request
  id: totrans-509
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-22\. ARP 请求
- en: We can use `tcpdump` to view all the ARP requests happening on the local network
    as in [Example 1-9](#arp_tcpdump). The packet capture details the ARP packets;
    the Ethernet type used, `Ethernet (len 6)`; and the higher-level protocol, `IPv4`.
    It also includes who is requesting the MAC address of the IP address, `Request
    who-has 192.168.0.1 tell 192.168.0.12`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`tcpdump`来查看在本地网络上发生的所有ARP请求，如[示例 1-9](#arp_tcpdump)所示。数据包捕获详细描述了ARP数据包，使用的以太网类型为`Ethernet
    (len 6)`；以及更高层协议为`IPv4`。它还包括谁在请求IP地址的MAC地址，`Request who-has 192.168.0.1 tell 192.168.0.12`。
- en: Example 1-9\. ARP `tcpdump`
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-9\. ARP `tcpdump`
- en: '[PRE9]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To further segment the layer 2 network, network engineers can use virtual local
    area network (VLAN) tagging. Inside the Ethernet frame header is an optional VLAN
    tag that differentiates traffic on the LAN. It is useful to use VLANs to break
    up LANs and manage networks on the same switch or different ones across the network
    campus. Routers between VLANs filter broadcast traffic, enable network security,
    and alleviate network congestion. They are useful to the network administrator
    for those purposes, but Kubernetes network administrators can use the extended
    version of the VLAN technology known as a *virtual extensible LAN* (VXLAN).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步分割第二层网络，网络工程师可以使用虚拟局域网（VLAN）标记。在以太网帧头部内有一个可选的VLAN标签，用于区分LAN上的流量。使用VLAN来分割LAN并管理网络在同一个交换机或跨网络校园内的不同交换机上是很有用的。VLAN之间的路由器过滤广播流量，启用网络安全性并减轻网络拥塞。它们对网络管理员来说在这些目的上是有用的，但是Kubernetes网络管理员可以使用VLAN技术的扩展版本，即*虚拟可扩展局域网*（VXLAN）。
- en: '[Figure 1-23](#vxlan) shows how a VXLAN is an extension of a VLAN that allows
    network engineers to encapsulate layer 2 frames into layer 4 UDP packets. A VXLAN
    increases scalability up to 16 million logical networks and allows for layer 2
    adjacency across IP networks. This technology is used in Kubernetes networks to
    produce overlay networks, which you’ll learn more about in later chapters.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-23](#vxlan)展示了 VXLAN 是 VLAN 的扩展，允许网络工程师将层 2 帧封装到层 4 UDP 数据包中。VXLAN 增加了可扩展性，达到了1600万个逻辑网络，并允许在
    IP 网络上实现层 2 邻接。这项技术用于 Kubernetes 网络以生成叠加网络，在后面的章节中您将更多了解。'
- en: '![VXLAN](Images/neku_0123.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![VXLAN](Images/neku_0123.png)'
- en: Figure 1-23\. VXLAN packet
  id: totrans-516
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-23\. VXLAN 数据包
- en: Ethernet also details the specifications for the medium to transmit frames on,
    such as twisted pair, coaxial cable, optical fiber, wireless, or other transmission
    media yet to be invented, such as the gamma-ray network that powers the Philotic
    Parallax Instantaneous Communicator.^([2](ch01.xhtml#idm46219944723976)) Ethernet
    even defines the encoding and signaling protocols used on the wire; this is out
    of scope for our proposes.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: Ethernet 还详细说明了用于传输帧的媒介规格，例如双绞线、同轴电缆、光纤、无线或其他尚未发明的传输介质，例如驱动 Philotic Parallax
    即时通信装置的 γ 射线网络。^([2](ch01.xhtml#idm46219944723976)) Ethernet 甚至定义了在电线上使用的编码和信令协议；这超出了我们的讨论范围。
- en: The Link layer has multiple other protocols involved from a network perspective.
    Like the layers discussed previously, we have only touched the surface of the
    Link layer. We constrained this book to those details needed for a base understanding
    of the Link layer for the Kubernetes networking model.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络角度，链路层还涉及多个其他协议。像前面讨论的层一样，我们仅仅触及了链路层的表面。我们将本书限制在对 Kubernetes 网络模型链路层所需了解的细节。
- en: Revisiting Our Web Server
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视我们的 Web 服务器
- en: Our journey through all the layers of TCP/IP is complete. [Figure 1-24](#all-headers)
    outlines all the headers and footers each layer of the TCP/IP model produces to
    send data across the internet.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 TCP/IP 所有层的旅程完成了。[图 1-24](#all-headers)概述了 TCP/IP 模型的每一层产生的所有头部和尾部，以便在互联网上传输数据。
- en: '![Full view](Images/neku_0124.png)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![全景](Images/neku_0124.png)'
- en: Figure 1-24\. TCP/IP PDU full view
  id: totrans-522
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-24\. TCP/IP PDU 全景
- en: Let’s review the journey and remind ourselves again what is going on now that
    we understand each layer in detail. [Example 1-10](#EX1) shows our web server
    again, and [Example 1-11](#EX0111) shows the cURL request for it from earlier
    in the chapter.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾旅程，并再次提醒自己我们现在详细了解每一层正在发生的事情。[示例 1-10](#EX1)再次显示我们的 Web 服务器，[示例 1-11](#EX0111)显示了本章前面
    cURL 请求的内容。
- en: Example 1-10\. Minimal web server in Go
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-10\. Go 中的最小 Web 服务器
- en: '[PRE10]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 1-11\. Client request
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-11\. 客户端请求
- en: '[PRE11]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We begin with the web server waiting for a connection in [Example 1-10](#EX1).
    cURL requests the HTTP server at `0.0.0.0` on port 8080\. cURL determines the
    IP address and port number from the URL and proceeds to establish a TCP connection
    to the server. Once the connection is set up, via a TCP handshake, cURL sends
    the HTTP request. When the web server starts up, a socket of 8080 is created on
    the HTTP server, which matches TCP port 8080; the same is done on the cURL client
    side with a random port number. Next, this information is sent to the Network
    layer, where the source and destination IP addresses are attached to the packet’s
    IP header. At the client’s Data Link layer, the source MAC address of the NIC
    is added to the Ethernet frame. If the destination MAC address is unknown, an
    ARP request is made to find it. Next, the NIC is used to transmit the Ethernet
    frames to the web server.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Web 服务器在[示例 1-10](#EX1)等待连接开始。cURL 请求 HTTP 服务器的`0.0.0.0`端口8080。cURL 从 URL
    确定 IP 地址和端口号，并建立与服务器的 TCP 连接。一旦建立连接，通过 TCP 握手，cURL 发送 HTTP 请求。当 Web 服务器启动时，在 HTTP
    服务器上创建一个名为8080的套接字，该套接字与 TCP 端口8080匹配；在 cURL 客户端的随机端口上也是如此。接下来，此信息发送到网络层，将源和目标
    IP 地址附加到数据包的 IP 头部。在客户端的数据链路层，将 NIC 的源 MAC 地址添加到以太网帧中。如果目标 MAC 地址未知，则发出 ARP 请求以查找它。然后，使用
    NIC 将以太网帧传输到 Web 服务器。
- en: When the web server receives the request, it creates packets of data that contain
    the HTTP response. The packets are sent back to the cURL process by routing them
    through the internet using the source IP address on the request packet. Once received
    by the cURL process, the packet is sent from the device to the drivers. At the
    Data Link layer, the MAC address is removed. At the Network Protocol layer, the
    IP address is verified and then removed from the packet. For this reason, if an
    application requires access to the client IP, it needs to be stored at the Application
    layer; the best example here is in HTTP requests and the X-Forwarded-For header.
    Now the socket is determined from the TCP data and removed. The packet is then
    forwarded to the client application that creates that socket. The client reads
    it and processes the response data. In this case, the socket ID was random, corresponding
    to the cURL process. All packets are sent to cURL and pieced together into one
    HTTP response. If we were to use the `-O` output option, it would have been saved
    to a file; otherwise, cURL outputs the response to the terminal’s standard out.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 当Web服务器接收到请求时，它会创建包含HTTP响应的数据包。这些数据包通过使用请求数据包上的源IP地址经过互联网路由发送回cURL进程。一旦cURL进程接收到数据包，数据包就会从设备发送到驱动程序。在数据链路层，MAC地址被移除。在网络协议层，IP地址被验证，然后从数据包中移除。因此，如果应用程序需要访问客户端IP，则需要在应用程序层存储它；HTTP请求和X-Forwarded-For头部就是最好的例子。现在根据TCP数据确定套接字并移除它。然后将数据包转发到创建该套接字的客户端应用程序。客户端读取并处理响应数据。在本例中，套接字ID是随机的，对应于cURL进程。所有数据包都发送到cURL并组合成一个HTTP响应。如果我们使用了`-O`输出选项，响应将保存到文件中；否则，cURL将响应输出到终端的标准输出。
- en: Whew, that is a mouthful, 50 pages and 50 years of networking condensed into
    two paragraphs! The basics of networking we have reviewed are just the beginning
    but are required knowledge if you want to run Kubernetes clusters and networks
    at scale.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这真是一大口气，50页和50年的网络发展被压缩成了两段话！我们回顾的网络基础只是一个开始，但如果您想要运行规模化的Kubernetes集群和网络，这些知识是必不可少的。
- en: Conclusion
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: The HTTP transactions modeled in this chapter happen every millisecond, globally,
    all day on the internet and data center network. This is the type of scale that
    the Kubernetes networks’ APIs help developers abstract away into simple YAML.
    Understanding the scale of the problem is our first in step in mastering the management
    of a Kubernetes network. By taking our simple example of the Golang web server
    and learning the first principles of networking, you can begin to wrangle the
    packets flowing into and out of your clusters.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中建模的HTTP事务每毫秒在全球范围内的互联网和数据中心网络中发生。这种规模是Kubernetes网络API帮助开发人员将复杂问题抽象为简单YAML的类型。了解问题的规模是我们掌握Kubernetes网络管理的第一步。通过我们的简单示例——Golang
    Web服务器，并学习网络的第一原则，您可以开始处理流入和流出集群的数据包。
- en: 'So far, we have covered the following:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了以下内容：
- en: History of networking
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络的历史
- en: OSI model
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSI模型
- en: TCP/IP
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/IP
- en: Throughout this chapter, we discussed many things related to networks but only
    those needed to learn about using the Kubernetes abstractions. There are several
    O’Reilly books about TCP/IP; [*TCP/IP Network Administration*](https://oreil.ly/UIP62)
    by Craig Hunt (O’Reilly) is a great in-depth read on all aspects of TCP.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了与网络相关的许多内容，但只涉及学习使用Kubernetes抽象所需的内容。关于TCP/IP有几本O’Reilly的书籍；[*TCP/IP网络管理*](https://oreil.ly/UIP62)
    由克雷格·亨特（O’Reilly）是关于TCP所有方面的深度阅读。
- en: We discussed how networking evolved, walked through the OSI model, translated
    it to the TCP/IP stack, and with that stack completed an example HTTP request.
    In the next chapter, we will walk through how this is implemented for the client
    and server with Linux networking.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了网络如何演变，走过了OSI模型，将其转化为TCP/IP协议栈，并通过该协议栈完成了一个示例HTTP请求。在下一章中，我们将详细讲解这是如何在Linux网络中为客户端和服务器实现的。
- en: ^([1](ch01.xhtml#idm46219953252264-marker)) [“Autonomous System (AS) Numbers”.](https://oreil.ly/Jgi2c)
    IANA.org. 2018-12-07\. Retrieved 2018-12-31.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.xhtml#idm46219953252264-marker)) [“自治系统（AS）编号”。](https://oreil.ly/Jgi2c)
    IANA.org. 2018-12-07\. 检索于2018-12-31.
- en: ^([2](ch01.xhtml#idm46219944723976-marker)) In the movie *Ender’s Game*, they
    use the Ansible network to communicate across the galaxy instantly. Philotic Parallax
    Instantaneous Communicator is the official name of the Ansible network.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.xhtml#idm46219944723976-marker)) 在电影《异星战场》中，他们使用“安西布尔”网络实现了跨银河瞬时通信。Philotic
    Parallax即时通信器是安西布尔网络的官方名称。
