- en: Chapter 21\. Building Web Applications with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Express](https://expressjs.com) is a lightweight web framework that has been
    the long-standing leader in web application development in Node. Similar to Ruby’s
    Sinatra and Python’s Flask, the Express framework by itself is very minimal, but
    can be extended to build any type of web application. Express is also the backbone
    of batteries included in web application frameworks, such as [Keystone.js](https://keystonejs.com),
    [Sails](https://sailsjs.com), and [Vulcan.js](http://vulcanjs.org). If you are
    doing web application development in Node, you are likely to encounter Express.
    This chapter focuses on a handful of basic recipes for working with Express, which
    can be extended to build out all sorts of web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Express to Respond to Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your Node application needs to respond to HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install the Express package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up Express, we require the module, call the module, and specify a port
    for connections in a file named *index.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To respond to a request, specify a route and the response using Express’s `.get`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To serve static files, we can specify a directory with the `express.static`
    middleware
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To respond with HTML generated from a template, first install the templating
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the *index.js* file, set the `view engine` and specify the route that
    will respond with the template content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And then create a template file in the *views* subdirectory of the project
    with a new file. The template filename should match the name specified in `res.render`.
    In *views/template.pug*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now requests to *http://localhost:3000/template* will return the template content
    as HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Express is a minimalist, but highly configurable framework for responding to
    HTTP requests and building out web applications. In the example, we set the port
    to `process.env.PORT` or port `3000`. In development, we can then specify a new
    port using an environment variable, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: or by using a *.env* file paired with the `dotenv` Node module. When deploying
    the application, the application hosting platform may require a specific port
    number or allow us to configure the port number ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Express `get` method, the application receives a request to a specific
    URI and then responds. In our example, when the application receives a request
    to the root URI (*/*), we respond with the text “Hello World”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These responses can also be HTML, templates rendered to HTML, static files,
    and formatted data (such as JSON or XML).
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to its minimal nature, Express itself contains minimal functionality, but
    can be extended using middleware. In Express, middleware functions have access
    to the `request` and `response` objects. Application-level middleware is bound
    to an instance of the `app` object through `app.use(MIDDLEWARE)`. In the example,
    we’re making use of the built-in static files middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Middleware packages can be used to extend Express’s functionality in many ways.
    The `helmet` middleware package can be used to improve the Express security defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Templating engines simplify the process of writing HTML and allow you to pass
    data from your application to the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I am passing the data from the `userData` object to the template found
    at *views/user.pug*, which will be accessible at the */user* route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in our template, we can make use of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Pug templating engine is maintained by the Express core team and is a popular
    choice for Express applications, but its whitespace-driven syntax is not for everyone.
    [EJS](https://ejs.co) is an excellent alternative that offers a more HTML-like
    syntax. Here’s how the above example would look using EJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, specify to install the `ejs` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then set EJS as the view engine in your Express application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And in *views/user.ejs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the Express-Generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re interested in using Express to manage your server-side data application,
    but you don’t want to manage all of the setup yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To kickstart your Express application, use the Express-Generator. This is a
    command-line tool that generates the skeleton infrastructure of a typical Express
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a working directory where the tool can safely install a new application
    subdirectory. Next, run the `express-generator` command with `npx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve passed two options with the command: `--pug` will result in the use of
    the Pug templating engine, while `--git` will generate a default *.gitignore*
    file in the project directory. For the full list of options, run the generator
    with the `-h` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The generator creates a new directory with several subdirectories, some basic
    files to get you started, and a *package.json* file with all of the dependencies.
    To install the dependencies, change to the newly created directory and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all of the dependencies are installed, run the application using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can now access the generated Express application, using your IP address
    or domain and port 3000, the default Express port.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Express provides a web application framework based on Node and with support
    for multiple templating engines and CSS preprocessors. In the solution, the options
    I chose for the example application are Pug as the template engine (the default)
    and the default of plain CSS (no CSS preprocessor). Though building the application
    from scratch enables a wider selection, Express supports only the following template
    engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--ejs`'
  prefs: []
  type: TYPE_NORMAL
- en: Adds support for the EJS template engine
  prefs: []
  type: TYPE_NORMAL
- en: '`--pug`'
  prefs: []
  type: TYPE_NORMAL
- en: Adds support for the Pug template engine
  prefs: []
  type: TYPE_NORMAL
- en: '`--hbs`'
  prefs: []
  type: TYPE_NORMAL
- en: Adds support for the Handlebar template engine
  prefs: []
  type: TYPE_NORMAL
- en: '`--hogan`'
  prefs: []
  type: TYPE_NORMAL
- en: Adds support for the Hogan.js template engine
  prefs: []
  type: TYPE_NORMAL
- en: 'Express also supports the following CSS preprocessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`express --css sass`'
  prefs: []
  type: TYPE_NORMAL
- en: Support for Sass
  prefs: []
  type: TYPE_NORMAL
- en: '`express --css less`'
  prefs: []
  type: TYPE_NORMAL
- en: Support for Less
  prefs: []
  type: TYPE_NORMAL
- en: '`express --css stylus`'
  prefs: []
  type: TYPE_NORMAL
- en: Support for Stylus
  prefs: []
  type: TYPE_NORMAL
- en: '`express --css compass`'
  prefs: []
  type: TYPE_NORMAL
- en: Support for Compass
  prefs: []
  type: TYPE_NORMAL
- en: Not specifying any CSS preprocessor defaults to plain CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Express also assumes that the project directory is empty. If it isn’t, force
    the Express generator to generate the content by using the `-f` or `--force` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The newly generated subdirectory has the following structure (disregarding
    `node​_mod⁠ules`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The *app.js* file is the core of the Express application. It includes the references
    to the necessary libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although the convention followed in this book is to use `const` and `let` to
    define variables, at the time of writing, the Express generator uses `var`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also creates the Express app with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it establishes Pug as the view engine by defining the `views` and `view
    engine` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The *middleware* calls are loaded next with `app.use()`. Middleware is functionality
    that sits between the raw request and the routing, processing specific types of
    requests. The rule for the middleware is if a path is not given as the first parameter,
    it defaults to a path of `/`, which means the middleware functions are loaded
    with the default path. In the following generated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first several middleware are loaded with every app request. Among the middleware
    includes support for development logging, as well as parsers for both JSON and
    *urlencoded* bodies. It’s only when we get to the `static` entry that we see assignment
    to specific paths: the static file request middleware are loaded when requests
    are made to the *public* directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The routing is handled next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The top-level web request (*/*) is directed to the `routes` module, while all
    user requests (*/users*) get routed to the `users` module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Read more about routing with Express in [“Routing”](#express-routing).
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is the error handling. First up is `404` error handling when a
    request is made to a nonexistent web resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next comes the server error handling, for both production and development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line of the generated file is the `module.exports` for the `app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the *routes* subdirectory, the default routing is included in the *routes/index.js*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s happening in the file is the Express router is used to route any HTTP
    GET requests to `/` to a callback where the request response receives a view rendered
    for the specific resource page. This is in contrast to what happens in the *routes/users.js*
    file, where the response receives a text message rather than a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens with the view rendering in the first request? There are three
    Pug files in the *views* subdirectory: one for error handling, one defining the
    page layout, and one, *index.pug*, that renders the page. The *index.pug* file
    contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It extends the *layout.pug* file, which contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The *layout.pug* file defines the overall structure of the page, regardless
    of content, including a reference to an automatically generated CSS file. The
    `block content` setting defines where the location of the content is placed. The
    format for the content is defined in *index.js*, in the equivalently named `block
    content` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Pug templating engine (formerly known as Jade) was popularized by Express
    and offers a minimalist take on templating that makes use of whitespace in place
    of traditional HTML style tags. This approach may not be for everyone, and the
    Pug alternatives (Handlebars, Hogan.js, and EJS) all offer a more HTML-like syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The two Pug files define a basic web page with an `h1` element assigned a title
    variable, and a paragraph with a welcome message. [Figure 21-1](#page_using_default_settings)
    shows the default page.
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 2101](assets/jsc3_2101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-1\. The Express-generated web page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 21-1](#page_using_default_settings) shows that the page isn’t especially
    fascinating, but it does represent how the pieces are holding together: the application
    router routes the request to the appropriate route module, which directs the response
    to the appropriate rendered view, and the rendered view uses data passed to it
    to generate the web page. If you make the following web request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: you’ll see the plain text message, rather than the rendered view.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Express is set up to run in *development mode*. To change the application
    to *production mode*, you need to set an *environment variable*, `NODE-ENV` to
    “production.” In a Linux or Unix environment, the following could be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to route users to different resources in your application based on
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use routes in Express to send specific resources based on the request path
    and parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Express, we can return a response to the user when they make an HTTP request.
    In the above examples, I’m using `get` requests, but Express supports a number
    of additional methods. The most common of these methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get`: request data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.post`: send data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.put`: send or update data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.delete`: delete data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Often we may want to enable multiple HTTP methods to a specific route. We can
    accomplish this by chaining them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Often requests have parameters with specific values that we will make use of
    in our application. We can specify these in the URL using a colon (`:`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, when a user visits a URL at */users/adam123*, the browser
    will send the response of `Hello user adam123`. While this is a simple example,
    we could also make use of the URL parameter to retrieve data from our database,
    passing the information on to a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re also able to specify formats for the request parameters. In the following
    example, I make use of a regular expression to limit the `noteId` parameter to
    a six-digit integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also able to use a regular expression to define an entire route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The above example will route any request ending in `day`. For example, in local
    development a request to *http://localhost:3000/Sunday* will result in “Every
    day feels like Sunday” being printed to the page.
  prefs: []
  type: TYPE_NORMAL
- en: Working with OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need access to a third-party API (such as GitHub, Facebook, or Twitter)
    in your Node application, but it requires authorization. Specifically, it requires
    OAuth authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll need to incorporate an OAuth client in your application. You’ll also
    need to meet the OAuth requirements demanded by the resource provider.
  prefs: []
  type: TYPE_NORMAL
- en: See the discussion for details.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth is an authorization framework used with most popular social media and
    cloud content applications. If you’ve ever gone to a site and it’s asked you to
    authorize access to data from a third-party service, such as GitHub, you’ve participated
    in the OAuth authorization *flow*.
  prefs: []
  type: TYPE_NORMAL
- en: There are two versions of OAuth, 1.0 and 2.0, which are not compatible with
    one another. OAuth 1.0 was based on proprietary APIs developed by Flickr and Google,
    was heavily web page focused, and didn’t gracefully transcend the barrier among
    web, mobile, and service applications. When wanting to access resources in a mobile
    phone app, the app would have the user log in to the app in a mobile browser and
    then copy access tokens to the app. Other criticisms of OAuth 1.0 is that the
    process required that the authorization server be the same as the resource server,
    which doesn’t scale when you’re talking about service providers such as Twitter,
    Facebook, and Amazon.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 presents a simpler authorization process, and also provides different
    types of authorization (different flows) for different circumstances. Some would
    say, though, that it does so at the cost of security, as it doesn’t have the same
    demands for encrypting hash tokens and request strings.
  prefs: []
  type: TYPE_NORMAL
- en: Most developers won’t have to create an OAuth 2.0 server, and doing so is way
    beyond the scope of this book, much less this recipe. But it’s common for applications
    to incorporate an OAuth client (1.0 or 2.0) for one service or another, so I’m
    going to present different types of OAuth use. First, though, let’s discuss the
    differences between authorization and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization isn’t authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Authorization is saying, “I authorize this application to access my resources
    on your server.” Authentication is the process of authenticating whether you are,
    indeed, the person who owns this account and has control over these resources.
    An example would be if I want to comment on an article at a newspaper’s online
    site. It will likely ask me to log in via some service. If I pick my Facebook
    account to use as the login, the news site will most likely want some data from
    Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The news site is, first, authenticating me as a legitimate Facebook user, with
    an established Facebook account. In other words, I’m not just some random person
    coming in and commenting anonymously. Secondly, the news site wants something
    from me in exchange for the privilege of commenting: it’s going to want data about
    me. Perhaps it will ask for permission to post for me (if I post my comment to
    Facebook as well as the news site). This is both an authentication and an authorization
    request.'
  prefs: []
  type: TYPE_NORMAL
- en: If I’m not already logged in to Facebook, I’ll have to log in. Facebook is using
    my correct application of username and password to authenticate that, yes, I own
    the Facebook account in question. Once logged in, Facebook asks whether I agree
    to giving the newspaper site the authorization to access the resources it wants.
    If I agree (because I desperately want to comment on a particular story), Facebook
    gives the news site the authorization, and there’s now a persistent connection
    from the newspaper to my Facebook account (which you can see in your Facebook
    settings). I can make my comment, and make comments at other stories, until I
    log out or revoke the Facebook authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, none of this implies that Facebook or the news site are actually
    authenticating who I am. Authentication, in this case, is about establishing that
    I am the owner of the Facebook account. The only time *real* authentication enters
    the picture is in a social media context such as Twitter’s authenticated accounts
    for celebrities.
  prefs: []
  type: TYPE_NORMAL
- en: Our development task is made simpler by the fact that software to handle authorization
    is frequently the same software that authenticates the individual, so we’re not
    having to deal with two different JavaScript libraries/modules/systems. There
    are also several excellent OAuth (1.0 and 2.0) modules we can use in Node applications.
    One of the most popular is [Passport](http://www.passportjs.org), and there are
    extensions for various authorization services created specifically for the Passport
    system. However, there are also very simple OAuth clients that provide barebones
    authorization access for a variety of services, and some modules that are created
    specifically for one service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Passport.js is covered in [“OAuth 2 User Authentication with Passport.js”](#redirect-auth).
    You can also read more about Passport and its various *strategies* supporting
    different servers at its website.
  prefs: []
  type: TYPE_NORMAL
- en: Now, on to the technology.
  prefs: []
  type: TYPE_NORMAL
- en: Client Credentials Grant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are few web resources that nowadays provide an API you can access without
    having some kind of authorization credential. This means having to incorporate
    a round-trip directive to the end users—asking them to authorize access to their
    account at the service before the application can access data. The problem is
    that sometimes all you need is simple read-only access without update privileges,
    without a frontend login interface, and without having a specific user make an
    authorizing grant.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 accounts for this particular type of authorizing flow with the *Client
    Credentials Grant*. The diagram for this simplified authorization is shown in
    [Figure 21-2](#client_credentials_grant_img).
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 2102](assets/jsc3_2102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-2\. The Client Credentials Grant authorization flow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Twitter provides what it calls application-only authorization, which is based
    on OAuth 2.0’s Client Credentials Grant. We can use this type of authorization
    to access Twitter’s Search API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I used the Node module `oauth` to implement the authorization.
    It’s the most basic of the authorization modules, and supports both OAuth 1.0
    and OAuth 2.0 authorization flows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To use the Twitter authorization API, the client application has to register
    its application with Twitter. Twitter provides both a *consumer key* and a *consumer
    secret*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `oauth` module, a new OAuth2 object is created, passing in:'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumer secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API base URI (API URI minus the query string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value of null signals OAuth to use the default */oauth/authorize*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The access token path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null, because we’re not using any custom headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `oauth` module takes this data and forms a POST request to Twitter, passing
    along the consumer key and secret, as well as providing a *scope* for the request.
    Twitter’s documentation provides an example POST request for an access token (line
    breaks inserted for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The response includes the access token (again, line breaks for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The access token has to be used with any of the API requests. There are no further
    authorization steps, so the process is very simple. In addition, since the authorization
    is at the application level, it doesn’t require an individual’s authorization,
    making it less disruptive to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Twitter provides wonderful documentation. I recommend reading the [“Application-only
    authentication overview”](https://oreil.ly/Mikyl).
  prefs: []
  type: TYPE_NORMAL
- en: Read/write authorization with OAuth 1.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application-Only authentication is great for accessing read-only data, but what
    if you want to access a user’s specific data, or even make a change to their data?
    Then you’ll need the full OAuth authorization. In this section, we’ll again use
    Twitter for the demonstration because of its use of OAuth 1.0 authorization. In
    the next recipe, we’ll look at OAuth 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I refer to it as OAuth 1.0, but Twitter’s service is based on [OAuth Core 1.0
    Revision A](http://oauth.net/core/1.0a). However, it’s a lot easier just to say
    OAuth 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth 1.0 requires a digital signature. The steps to derive this digital signature,
    graphically represented in [Figure 21-3](#oauth_one_flow), and as outlined by
    Twitter, are:'
  prefs: []
  type: TYPE_NORMAL
- en: Collect the HTTP method and the base URI, minus any query string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the parameters, including the consumer key, request data, nonce, signature
    method, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a signature base string, which consists of the data we’ve gathered, formed
    into a string in a precise manner, and encoded just right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a signing key, which is a combination of consumer key and OAuth token
    secret, again combined in a precise manner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the signature base string and the signing key to an HMAC-SHA1 hashing algorithm,
    which returns a binary string that needs further encoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![jsc3 2103](assets/jsc3_2103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-3\. OAuth 1.0 authorization flow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have to follow this process for *every* request. Thankfully, we have modules
    and libraries that do all of this mind-numbing work for us. I don’t know about
    you, but if I had to do this, my interest in incorporating Twitter data and services
    into my application would quickly wane.
  prefs: []
  type: TYPE_NORMAL
- en: Our friend `oauth` provides the underlying OAuth 1.0 support, but we don’t have
    to code to it directly this time. Another module, `node-twitter-api`, has wrapped
    all of the OAuth pieces. All we need do is create a new `node-twitter-api` object,
    passing in our consumer key and secret, as well as the callback/redirect URL required
    by the resource services, as part of the authorization process. Processing the
    `request` object in that URL provides us the access token and secret we need for
    API access. Every time we make a request, we pass in the access token and secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `twitter-node-api` module is a thin wrapper around the REST API: to make
    a request, we extrapolate what the function is from the API. If we’re interested
    in posting a status update, the REST API endpoint is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `twitter-node-api` object instance function is `statuses()`, and the first
    parameter is the verb, `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The callback function arguments include any possible error, requested data (if
    any), and the raw response.
  prefs: []
  type: TYPE_NORMAL
- en: A complete example is shown in [Example 21-1](#complete_twitter_app_using_oauth).
    It uses Express as a server and provides a primitive web page for the user, and
    then uses another module.
  prefs: []
  type: TYPE_NORMAL
- en: Example 21-1\. Twitter app fully authorized via OAuth 1.0
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The routes of interest in the app are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: Page that triggers a redirect to Twitter for authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth`: The callback or redirect URL registered with the app, and passed in
    the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/post/status/`: Post a status to the Twitter account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/get/account/`: Get account information for the individual'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In each case, the appropriate `node-twitter-api` function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: Get a request token and request token secret, using `getRequestToken()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/`: Get the API access token and token secret, caching them locally,
    display menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/post/status/`: `status()` with *update* as first parameter, status, access
    token and secret, and callback function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/get/account/`: `account()` with *settings* as the first parameter, an empty
    object, since no data is needed for the request, and the access token, secret,
    and callback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Twitter authorization page that pops up is displayed in [Figure 21-4](#twitter_authorization_page),
    and the web page that displays account information for yours truly is displayed
    in [Figure 21-5](#twitter_account_data).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Though it is no longer actively maintained, you can read more about the `node-twitter-api`
    module at its [GitHub repository page](https://github.com/reneraab/node-twitter-api).
    Other libraries are more actively maintained and provide the same type of functionality,
    but I found `node-twitter-api` offers the simplest functional example for the
    purpose of demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 2104](assets/jsc3_2104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-4\. Twitter authorization page, redirected from the recipe app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![jsc3 2105](assets/jsc3_2105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-5\. Display of Twitter user account data in app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: OAuth 2 User Authentication with Passport.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to authenticate users in your application through a third-party service.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Passport.js library paired with the appropriate strategy for the authentication
    provider you’ve chosen. In this example, I’ll make use of the GitHub strategy,
    but the workflow will be identical for any OAuth 2 provider, including Facebook,
    Google, and Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: You can make use of the GitHub strategy, first by visiting GitHub’s website
    and [registering a new OAuth application](https://github.com/settings/applications/new).
    Once the application is registered, you can integrate the Passport.js OAuth code
    into the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, configure the Passport strategy, which will include the GitHub-provided
    client ID and client secret, along with the callback URL that you have specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To restore authentication state across HTTP requests, Passport needs to serialize
    and deserialize users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To preserve user logins across browser sessions, make use of the `express-session`
    middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then authenticate requests using `passport.authenticate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And reference the `user` object from requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth is an open standard for user authentication. It allows us to authenticate
    users through third-party applications. This can be useful when allowing users
    to easily create accounts and log in to your applications, as well as for authenticating
    to use data from a third-party source.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth requests follow a specific flow:'
  prefs: []
  type: TYPE_NORMAL
- en: Your application makes an authorization request to the third-party service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user approves that request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service redirects the user back to your application, along with an authorization
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application makes a request to the third-party service with the authorization
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service responds with an access token (and optionally a refresh token).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application makes a request to the service with the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service responds with the protected resource (in our case, the user account
    information).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Passport.js along with a Passport.js strategy for the OAuth provider simplifies
    this flow in an Express.js application. In this example, we’ll build a small Express
    application that authenticates with GitHub and persists user logins across sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have registered our application with the service provider, we can begin
    development by installing the appropriate dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To store our OAuth client ID, client secret, and session secret values, we
    will use a *.env* file. Alternately, you could use a JavaScript file (such as
    a *config.js* file). It is critical that we not check this file into public source
    control, and I recommend adding it to your *.gitignore* file. In *.env*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll set up our Express application with Passport.js. In *index.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can then build your view templates, which can access the user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *views/home.pug*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In *views/login.pug*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In *views/profile.pug*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can set up our routes in the *index.js* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This example was designed to closely match the [Express 4.x Facebook example](https://github.com/passport/express-4.x-facebook-example),
    which provides well-documented code for working with Express and Facebook authentication.
    You can view hundreds of additional [Passport.js strategies](http://www.passportjs.org).
  prefs: []
  type: TYPE_NORMAL
- en: Serving Up Formatted Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of serving up a web page or sending plain text, you want to return formatted
    data, such as XML, to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use Node module(s) to help format the data. For example, if you want to return
    XML, you can use a module to create the formatted data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create the appropriate header to go with the data, and return the data
    to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web servers frequently serve up static or server-side generated resources, but
    just as frequently, what’s returned to the browser is formatted data that’s then
    processed in the web page before display.
  prefs: []
  type: TYPE_NORMAL
- en: There are two key elements to generating and returning formatted data. The first
    is to make use of whatever Node library to simplify the generation of the data,
    and the second is to make sure that the header data sent with the data is appropriate
    for the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the solution, the `xmlbuilder` module is used to assist us in creating proper
    XML. This isn’t one of the modules installed with Node by default, so we have
    to install it using npm, the Node Package Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Then it’s a matter of creating a new XML document, a root element, and then
    each resource element, as demonstrated in the solution. It’s true, we could build
    the XML string ourselves, but that’s a pain. And it’s too easy to make mistakes
    that are then hard to discover. One of the best things about Node is the enormous
    number of modules available to do most anything we can think of. Not only do we
    not have to write the code ourselves, but most of the modules have been thoroughly
    tested and actively maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Once the formatted data is ready to return, create the header that goes with
    it. In the solution, because the document is XML, the header content type is set
    to `application/xml` before the data is returned as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Building a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to build a REST API using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use Express with the `app.get`, `app.post`, `app.put`, and `app.delete` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST stands for “Representational State Transfer,” and is the most common architectural
    approach for building APIs. REST allows us to interact with a remote data source
    over HTTP, using the standard HTTP methods of `GET`, `POST`, `PUT`, and `DELETE`.
    We can make use of the Express routing methods to accept these requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I’ll create several routes that serve as API endpoints.
    Each endpoint will respond to an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/todos`'
  prefs: []
  type: TYPE_NORMAL
- en: Will accept a `get` request for a list of todos as well as a `post` request
    for creating a new todo.
  prefs: []
  type: TYPE_NORMAL
- en: '`/todos/:todoId`'
  prefs: []
  type: TYPE_NORMAL
- en: Will accept a `get` request that will return a specific todo as well as a `put`
    request, which will allow the user to update the todo content or completed state,
    and a `delete` request, which will delete the specific todo.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these routes defined, we can develop a REST API that responds to these
    requests appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'From the terminal, you can use `curl` to test our responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Manually testing with `curl` can quickly become tedious. For API development,
    you may also want to make use of a REST client UI, such as [Insomnia](https://insomnia.rest)
    or [Postman](https://postman.com) (see [Figure 21-6](#rest_insomnia)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Insomnia REST client](assets/jsc3_2106.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-6\. A GET request in the Insomnia REST client
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the above example, I’m using an in-memory data store. When building an API,
    you will most likely want to connect to a database. To do so, you can reach for
    a library such as [Sequelize](https://oreil.ly/NuXyR) (for SQL databases), [Mongoose](https://oreil.ly/zP8Fr)
    (for MongoDB), or an online data store such as [Firebase](https://oreil.ly/iZSFB).
  prefs: []
  type: TYPE_NORMAL
- en: Building a GraphQL API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You would like to build a GraphQL API server application or add GraphQL endpoints
    to an existing Express application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the Apollo Server package to include GraphQL type definitions, GraphQL
    resolvers, and the GraphQL Playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Apollo Server provides access to the GraphQL Playground (see [Figure 21-7](#graphql_playground)),
    which allows us to easily interact with the API during development (and in production,
    if desired).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the GraphQL Playground](assets/jsc3_2107.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-7\. A GraphQL query in the GraphQL Playground
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The GraphQL Playground also provides automatically generated documentation for
    the API, based on the type definitions you’ve provided (see [Figure 21-8](#unique_id)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the generated GraphQL documentation](assets/jsc3_2108.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-8\. The generated documentation in GraphQL Playground
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL is an open source query language for APIs. It was developed with the
    goal of providing single endpoints for data, allowing applications to request
    the specific data that is needed. [Apollo Server](https://oreil.ly/toPLM) can
    be used as a standalone package or integrated as middleware for popular Node.js
    server application libraries, such as Express, Hapi, Fastify, and Koa.
  prefs: []
  type: TYPE_NORMAL
- en: 'In GraphQL, a type definition schema is a written representation of our data
    and interactions. By requiring a schema, GraphQL enforces a strict plan for our
    API. This is because your API can only return data and perform interactions that
    are defined within the schema. The fundamental component of GraphQL schemas are
    object types. GraphQL contains five built-in scalar types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'String: A string with UTF-8 character encoding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boolean: A true or false value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Int: A 32-bit integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Float: A floating-point value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ID: A unique identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the schema is written, we provide the API with a series of resolvers. These
    are functions that specify how the data should be returned in a query or changed
    within a data mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we’re using the `apollo-server-express` package, which
    should be installed alongside the `express` and `gql` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a CRUD application, we can define our GraphQL type definitions and
    the appropriate resolvers. The following example mimics the one found in [“Building
    a RESTful API”](#express-rest):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, I’m using an in-memory data store. When building an API,
    you will most likely want to connect to a database. To do so, you can reach for
    a library such as Sequelize (for SQL databases), Mongoose (for MongoDB), or an
    online data store such as Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: The defined queries return data directly from the API, while the mutations allow
    us to perform changes to the data, such as create a new item, update an item,
    or delete an item.
  prefs: []
  type: TYPE_NORMAL
