<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Writing User-Defined Functions and Classes in Modules"><div class="chapter" id="writing_user_defined_functions_and_classes_in_modu">
<h1><span class="label">Chapter 3. </span><span>Writing User-Defined Functions and Classes in Modules</span></h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45807804872752">
<h5>A Note for Early Release Readers</h5>

<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the 3rd chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <em>learnmodcppfinance@gmail.com</em>.</p>
</div></aside>

<p>In our code examples so far, we have placed all our code into one file with a top-down design, beginning with the `main` function where execution of the program begins. This is of course not practical for realistic production programming. Prior to C++20, the usual approach to writing user-defined (non-templated) functions and classes would first involve placing their declarations placed in header files (usually `.h`, `.hpp`, or `.hxx` extensions). An implementation file (typically `.cpp`, `.cxx`, or `.cc` extensions) would then load the declarations using the `#include` preprocessor command. Each implementation file would then be compiled into a <em>translation unit</em> (de facto standard extensions are `.o` for Clang and gcc, and `.obj` for Visual Studio).</p>

<p>C++20 introduced <em>modules</em> which, without going into excessive detail here, offer the advantages of reduced time required to compile and build a code base, elimination of problems that can arise with header files and preprocessor directives, and greater control over what is exported to other code files. One convenient result is it is no longer necessary to wrap declarations in include guard macros. In addition, the problem of header file leaking can also be avoided, as an imported module into another does not carry with it everything that it imports, unlike `#include` macros in one header file that get propagated into another. [[For more details, see Ranier Grimm, and Niall Cooling (https://blog.feabhas.com/2021/08/c20-modules-with-gcc11/)]]</p>

<p>Modules also allow placing both declarations and implementations in a single file, although it is also possible to separate them over multiple files with an interface and multiple implementation files. For this book, we will limit the discussion to the single file case [[at least for now]].</p>

<p>Single file modules can be used to implement functions and classes similar to C# and Java, without separate declarations. But keeping the separation even within one file still provides certain advantages, namely a clear separation of interface and implementation, and the potential to reduce or eliminate the recompilation of other code that consumes a module.</p>

<p>Default file extensions for single file modules at this stage seem to be converging around `.ixx` for Visual Studio, and `.cppm` on Clang, although using `.cpp` is also an option. [[Check Ranier Grimm’s warning about using cppm; he recommends using .cpp with Clang, or .ixx with Clang-Cl in MSVC]]. In this book, we will use the `.ixx` extension for module files.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>At the time of this writing, there are still various points with respect to standardization that are still pending. This could change by the time this book reaches publication.</p>
</div>

<p>In this chapter, we will firt show introductory first examples of using modules for both user-defined non-member functions and classes. This will a good segue into a deeper discussion on class design, including compiler-provided default special functions, user-defined constructors and destructors, and operator overloading. Move semantics, a language feature added in C++11, will also be introduced. For some readers this will be review, but the examples will be shown again within the context of C++20 modules.</p>

<section data-type="sect1" data-pdf-bookmark="Using Modules to Write User-Defined Functions"><div class="sect1" id="using_modules_to_write_user_defined_functions">
<h1><span>Using Modules to Write User-Defined Functions</span></h1>

<p>We will now build up the process of writing functions in modules, starting from a very simple example, and then introducing the details step-by-step.</p>

<section data-type="sect2" data-pdf-bookmark="A First Example  with Non-Member Functions"><div class="sect2" id="a_first_example_with_non_member_functions">
<h2><span>A First Example</span> <span> with Non-Member Functions</span></h2>

<p>Suppose we want to write a function that sums up the elements in a vector of integers:</p>

<div data-type="example">
<pre data-type="programlisting">
int vector_sum_of_ints()
{
	vector&lt;int&gt; v = { 1,2,3 };
	int sum = 0;
	for (int elem : v) sum += elem;
	return sum;
}</pre>
</div>

<p>This is placed in a module called `CppMod`, in a separate `.ixx` file, say `CppModule.ixx`. It will be easier to follow by just writing out the entire code in this file and then going through it section by section.</p>

<div data-type="example">
<pre data-type="programlisting">
module;	// The global fragment
#include &lt;vector&gt;
export module CppMod;	// The global fragment ends at this point, and 
					// the functionality of the module starts here.
using std::vector;
// Declare the function first, using the
// export keyword to make it accessible outside the module.
export int vector_sum_of_ints();
// Implementation of the function.  The export keyword
// is not necessary here as it is already included 
// in the declaration.
int vector_sum_of_ints()
{
	vector&lt;int&gt; v = { 1,2,3 };
	int sum = 0;
	for (int elem : v) sum += elem;
	return sum;
}</pre>
</div>

<p>The `module` statement on the first line determines where the <em>global fragment</em> of the module begins. This section is [[exclusively]] reserved for pre-processor commands, particularly for `#include` statements of header files in the Standard Library and elsewhere that are needed for the implementation.</p>

<p>Next, the `export module` statement indicates the end of the global fragment and defines the module itself. This will make it available for <em>import</em> into other modules and source code. What follows first is the declaration of the ` vector_sum_of_ints ` function, preceded by another use of the `export` keyword. What this does is indicate to the compiler that this function can be called externally from code outside the module. Functions that are not marked as `export` will only be callable from inside the module.</p>

<p>After this, we can then write the function implementation. Note that we do not need to put `export` here, as placing it with the function declaration is sufficient.</p>

<p>To see how we can use this module, we will import it into our usual `Main.cpp` file (not a module itself at this stage). This is accomplished using the `import` keyword before the `main` function. Then, from `main`, we will call ` vector_sum_of_ints `:</p>

<div data-type="example">
<pre data-type="programlisting">
#include &lt;iostream&gt;		// #include &lt;iostream&gt; as usual
using std::cout;
using std::endl;
import CppMod;		// Import the CppMod module
				// containing the vector_sum_of_ints function.
int main()
{
	cout &lt;&lt; vector_sum_of_ints() &lt;&lt; endl;
}</pre>
</div>

<p>Running this code, you can verify the result is 6.</p>

<p>Next, we can have a look at what happens if a non-export function, `add_stuff` is added to the module. Again, a very simple example, this will just double an integer value. If we call it from inside the exported function, then twice the sum of the vector results is returned:</p>

<div data-type="example">
<pre data-type="programlisting">
module;
#include &lt;vector&gt;
export module CppMod;
using std::vector;
export int vector_sum_of_ints();
int add_stuff (int n);
int vector_sum_of_ints()
{
	vector&lt;int&gt; v = { 1,2,3 };
	int sum = 0;
	for (int elem : v) sum += elem;
	sum = add_one(sum);
	return sum;
}
int add_stuff (int n)
{
	return n + n;
}</pre>
</div>

<p>Compiling and running the program again, the result is not surprisingly (drum roll please), 12. Attempting to call `add_stuff ` from the external `main` function, however, would result in a compiler error.</p>

<p>It is also possible to define a <em>variable</em> that is local to the module and not accessible outside. For example, we could declare and initialize a non-exported integer variable to 0, and then if it is reassigned, it will maintain its new value inside the module. For example, we can set it equal to `n` inside the `add_stuff ` function, and then add it again in the exported function where it retains its reassigned value of 6:</p>

<div data-type="example">
<pre data-type="programlisting">
module;
#include &lt;vector&gt;
export module CppMod;
using std::vector;
export int vector_sum_of_ints();
int add_one(int n);
int k = 0;
int vector_sum_of_ints()
{
	vector&lt;int&gt; v = { 1,2,3 };
	int sum = 0;
	for (int elem : v) sum += elem;
	sum = add_k(sum);
	return sum + k;		// k still = 6; returns 18
}
int add_stuff(int n)
{
	k = n;			// k = 6
	return k + n;		// 12
}</pre>
</div>

<p>The result now is 18, but that isn’t as important as the fact that `k` is local to the module and cannot be accessed externally. Similar to a non-exported function, an attempt to use `k` inside the `main` function will fail to compile. Conceptually, both non-exported functions and variables act like private members on a class, but with respect to the module and its non-member functions instead.</p>

<p>It is furthermore possible to make the separation of interface and implementation clearer by rearranging the function implementations in what is called the <em>private fragment</em> of a single-file module. This must be the final section in the module, and it is indicated with `module: private` separating the declarations above with the implementations below:</p>

<div data-type="example">
<pre data-type="programlisting">
module;
#include &lt;vector&gt;
export module CppMod;
using std::vector;
// Interface section is here:
export int vector_sum_of_ints();
int add_stuff(int n);
int k = 0;
// Implementations are placed in the private fragment:
module:private;
int vector_sum_of_ints()
{
	vector&lt;int&gt; v = { 1,2,3 };
	int sum = 0;
	for (int elem : v) sum += elem;
	sum = add_stuff(sum);
	return sum + k;		// k still = 6; returns 18
}
int add_stuff(int n)
{
	k = n;			// k = 6
	return k + n;		// 12
}</pre>
</div>

<p>Using a private fragment also purportedly will/can prevent external code using the module from recompiling when a change is made inside the module. There is still some ambiguity on this point that will hopefully be clarified within the next few months.</p>

<p>We will soon see how a module with a private fragment can be useful in a more realistic example.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Standard Library Header Units"><div class="sect2" id="standard_library_header_units">
<h2><span>Standard Library Header Units</span></h2>

<p>Proposals to the <a href="https://isocpp.org/std/the-committee"><span>ISO C++ Committee</span></a> for reorganizing the Standard Library into “<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2412r0.pdf"><span>a standard-module version</span></a>” [Stroustrup P2412r0] were also drafted and submitted for inclusion in C++20, but this effort has been deferred until the next release planned for 2023. In the interim, as a placeholder, <em>Standard Library header units</em> that guarantee <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1502r1.html"><span>“[e]xisting `#include`s of standard library headers transparently turn into module imports in C++20</span></a>” [ISO P1502R1] are now available. What this essentially means is preprocessor statements such as</p>

<div data-type="example">
<pre data-type="programlisting">
#include &lt;vector&gt;
#include &lt;algorithm&gt;</pre>
</div>

<p>can be replaced by importing their header equivalents:</p>

<div data-type="example">
<pre data-type="programlisting">
import &lt;vector&gt;;		// Note these require a semicolon
import &lt;algorithm&gt;;</pre>
</div>

<p>This applies to all C++ Standard Library declaration files; however, due to complications arising in headers inherited from C – eg, &lt;cassert&gt; and &lt;cmath&gt;, based on the legacy C headers &lt;assert.h&gt; and &lt;math.h&gt; respectively – these are not covered.</p>

<p>In the above example then, we can eliminate the global fragment and import the `vector` header file under the `export module` statement; viz,</p>

<div data-type="example">
<pre data-type="programlisting">
export module CppMod;
import &lt;vector&gt;;
using std::vector;</pre>
</div>

<p>If other header files outside of the Standard Library need to be `#include`d, as preprocessor directives, <em>these must</em> go into the global fragment of the module.</p>

<p>Beyond the convenience of importing Standard Library header units, they also have been shown to decrease build times and binary file bloat, although this is not always guaranteed.</p>

<p>Examples can be found in Stroustrup [P2412r0].</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Modules Prevent Leaking into Other Modules"><div class="sect2" id="modules_prevent_leaking_into_other_modules">
<h2><span>Modules Prevent Leaking into Other Modules</span></h2>

<p>A module will not “leak” imported modules within itself when imported into other models. That is, if a module `A` imports another module `B`,</p>

<div data-type="example">
<pre data-type="programlisting">
// Define module A that imports module B:
export module A;
import B;</pre>
</div>

<p>then if `A` is imported into another module `C`, or into a `Main.cpp` file, `B` will not be implicitly imported as well unless it also is explicitly imported as well:</p>

<div data-type="example">
<pre data-type="programlisting">
// Define module C that imports module A:
export module C;
import A;
import B;		// Not implicitly imported with module A.
			// Must be explicitly imported if functions
			// in B are also to be used inside module C</pre>
</div>

<p>This is in contrast with `#include`d header files that will leak. For example, a header file `MyHeader.h` includes a user-defined `YourHeader.h` and the STL &lt;vector&gt; header:</p>

<div data-type="example">
<pre data-type="programlisting">
// MyHeader.h
#include “YourHeader.h”
#include &lt;vector&gt;</pre>
</div>

<p>If `MyHeader.h` is `#include`d in `Main.cpp`, then it will also carry functions in “YourHeader.h” and the `std::vector` class will also be present in `Main.cpp`:</p>

<p>// Main.cpp</p>

<div data-type="example">
<pre data-type="programlisting">
#include “MyHeader.h”
int main()
{
	// This will compile:
	auto y = my_header_fcn(…);
	// But so will these lines:
	auto z = your_header_fcn(…);
	std::vector &lt;double&gt; v;
}</pre>
</div>

<p>With preprocessor `#include` statements, the content contained in `YourHeader.h` and `std::vector` are “leaked” into the `main` function. In realistic situations where many more header files might be involved, losing track of what is included and what is not can potentially lead to unexpected behavior or errors at runtime. In addition, this can also lead to longer build times. With modules, the programmer has greater control over what is imported, and build times can be substantially lower.</p>

<p>More details are available in <a href="https://www.modernescpp.com/index.php/cpp20-modules"><span>Ranier Grimm’s very informative ModernesCpp blog site</span></a>.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="A  Black-Scholes Module Example"><div class="sect2" id="a_black_scholes_module_example">
<h2><span>A</span> <span> Black-Scholes Module Example</span></h2>

<p>For something closer to a realistic financial example, the Black-Scholes model for pricing a European equity option can be written inside a module. Before coding up the model, though, we will need a reliable way to indicate the payoff type, call or put. For this, a module called `Enums` will contain an exported enum class `PayoffType`:</p>

<p>For the Black-Scholes functions, the mathematical formulation shown in James, Option Theory will be used.</p>
<img alt="" src="Images/3.1.png" width="566" height="138"/>
<section data-type="sect3" data-pdf-bookmark="A Module Containing Enum Definitions"><div class="sect3" id="a_module_containing_enum_definitions">
<h3><span>A Module Containing Enum Definitions</span></h3>

<p>First, so as to prevent bogus input values of ɸ, an enum class is used to represent the payoff type, and it resides in its own module and separate file, say `Enums.ixx` so that it can be reused elsewhere.</p>

<div data-type="example">
<pre data-type="programlisting">
// File Enums.ixx
export module Enums;
export enum class PayoffType
{
	CALL,
	PUT
};</pre>
</div>

<p>In practice, other enum classes representing bond types, futures contract identifiers, currency codes etc could be appended to this module and then imported into other pricing and risk modules as needed.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="The Black-Scholes Formula Module"><div class="sect3" id="the_black_scholes_formula_module">
<h3><span>The Black-Scholes Formula Module</span></h3>

<p>The model requires a natural log function, and a way to compute the cumulative distribution function for a standard normal distribution. We are in luck here, because the CDF can be written as</p>
<img alt="" src="Images/3.2.png" width="262" height="150"/>
<p>where erf is the <a href="https://en.wikipedia.org/wiki/Error_function"><span>error function</span></a>, and it is available in `&lt;cmath&gt;`, as is the natural log function `log`. However, because this header does not have a header unit guaranteed by the C++20 Standard [[discussed above]], it needs to be `#include`d in the global fragment of the module:</p>

<div data-type="example">
<pre data-type="programlisting">
module;
#include &lt;cmath&gt;	// cstuff headers (derived from stuff.h) 
				// should be #include(d) in the global fragment</pre>
</div>

<p>An `export` statement follows next and defines the name of the module, say `BlackScholesFcns`. For convenience, the required `&lt;cmath&gt;` function `using` aliases go next</p>

<div data-type="example">
<pre data-type="programlisting">
export module BlackScholesFcns;
// &lt;cmath&gt; functions used below:
using std::log;
using std::erf;</pre>
</div>

<p>The formula also uses <img alt="" src="Images/1.4.png" width="35" height="32"/>, and this is now available as a constant alias in C++20. It also needs to determine the maximum between the option payoff and zero at expiration. For these, the `sqrt2` constant in `&lt;numbers&gt;`, and the `std::max` function in `&lt;algorithms&gt;` are available. Because `&lt;numbers&gt;` and `&lt;algorithms&gt;` are available as header units, they can be `import`ed rather than `#include`d:</p>

<div data-type="example">
<pre data-type="programlisting">
// Standard Library header units, and using aliases
import &lt;numbers&gt;;
using std::numbers::sqrt2;
import &lt;algorithm&gt;;
using std::max;</pre>
</div>
</div></section>

<section data-type="sect3" data-pdf-bookmark="`export import` "><div class="sect3" id="_export_import">
<h3><span>`export import` </span></h3>

<p>The `BlackScholesFcns` module will need to `import` the `Enums` module in order to indicate whether an option is a call or a put. But as described earlier, a benefit of using a module is it will not leak an imported module into another location. This means if `BlackScholesFcns` is imported into `Main.cpp`, the programmer will need to know to also `import` the `Enums` module. This is not a desirable approach, as it would require inspecting the source code of a module for others it imports before it could be consumed elsewhere.</p>

<p>Fortunately, the `export import` command is available. It will first `import` the `Enums` module into `BlackScholesFcns`, and then `export` it wherever the latter is consumed.</p>

<div data-type="example">
<pre data-type="programlisting">
export import Enums;</pre>
</div>

<p>This way, when `BlackScholesFcns` is imported into another module or file, it will not be necessary to hunt through the source code in `BlackScholesFcns` for the imported `Enums`, and then re-import it into the new target. In addition, and in general, the only imported modules that can be carried through are those marked with `export import`. This way, unexpected behavior due to an unintentionally leaked module can be avoided.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The `&lt;cmath&gt;` header will leak into the target where `BlackScholesFcns` is imported due to the `#include` statement. This should be rectified with the standard-module version of the Standard Library currently slated for C++23.</p>
</div>

<p>The calculations are naturally divided up into an exported Black-Scholes function, and two private functions that compute the <em>d</em>1 and <em>d</em>2 values, and the Standard Normal CDF. The declarations are:</p>

<div data-type="example">
<pre data-type="programlisting">
export double black_scholes_price(double strike, double spot, double rate,
	double sigma, double year_frac, PayoffType pot);
// Internal functions and variables
void dee_fcns(double strike, double rate, double spot,
	double sigma, double year_frac);
double norm_cdf(double x);</pre>
</div>

<p>The salient point here is module users only need to be concerned with the `black_scholes_price` function. The responsibility for calling other two is delegated to the exported function.</p>

<p>Because the <em>d</em>1 and <em>d</em>2 values are internal to the model, they are declared and initialized, but also not exported. This makes them accessible to the functions in the module but not to the outside world, much like a private member function on a class.</p>

<div data-type="example">
<pre data-type="programlisting">
// Internal module variables
double d1 = 0.0, d2 = 0.0;		// d1 and d2 values in Black-Scholes</pre>
</div>

<p>The function implementations go last, with the exported `black_scholes_price` function first, followed by the two helper functions in the private fragment. Note that `dee_fcns` is a `void` function. Rather than have two separate functions to calculate the <em>d</em>1 and <em>d</em>2 values, this can be done in one function by setting the results on the `d1` and `d2` variables that are common to the module, but hidden from its users.</p>

<div data-type="example">
<pre data-type="programlisting">
double black_scholes_price(double strike, double spot, double rate,
	double sigma, double year_frac, PayoffType pot)
{
	double opt_price = 0.0;
	// phi, as in the James book: 
	double phi = (pot == PayoffType::CALL) ? 1.0 : -1.0;
	if (year_frac &gt; 0.0)
	{		
		dee_fcns(strike, rate, spot, sigma, year_frac);
		double n_dee_one = norm_cdf(phi * d1);		// N(d1)
		double n_dee_two = norm_cdf(phi * d2); 	// N(d2)
		double disc_fctr = exp(-rate * year_frac);
		opt_price = phi * (spot * n_dee_one - disc_fctr * strike * n_dee_two);
	}
	else
	{
		opt_price = max(phi * (spot - strike), 0.0);
	}
	return opt_price;
}
module : private;
void dee_fcns(double strike, double rate, double spot,
	double sigma, double year_frac)
{
	double numer = log(spot / strike) + rate * year_frac
		+ 0.5 * year_frac * sigma * sigma;
	double sigma_sqrt = sigma * sqrt(year_frac);
	d1 = numer / sigma_sqrt;
	d2 = d1 - sigma_sqrt;
}
double norm_cdf(double x)
{
	return (1.0 + erf(x / sqrt2)) / 2.0;
}</pre>
</div>

<p>In the `Main.cpp` file, put</p>

<div data-type="example">
<pre data-type="programlisting">
import BlackScholesFcns;</pre>
</div>

<p>to import the model, and then call the exported function; eg, an in-the-money put with about three months until expiration. Note that the payoff enum type can be assigned because the `Enums` module was exported from `BlackScholesFcns` with the `export import` command.</p>

<div data-type="example">
<pre data-type="programlisting">
	strike = 200.0;
	porc = PayoffType::PUT;
	spot = 185.0;
	rate = 0.05;
	sigma = 0.25;
	year_frac = 0.25;
	cout &lt;&lt; "Put Option price = "
		&lt;&lt; black_scholes_price(strike, spot, rate, sigma, year_frac, porc )
		&lt;&lt; endl;</pre>
</div>

<p>This gives a price of 17.0649.</p>

<p>As can (hopefully) be seen, in addition to their other benefits, modules can be quite useful for implementing financial models where a lot of internal calculations are required but not necessary for the consumer to be concerned with. This way, the intermediate values can be encapsulated similar to a private variable on a class rather than passed around between functions and being exposed to unexpected modification, without the overhead of creating an object. For models more complex than Black-Scholes – and many of course exist – this means fewer moving parts accessible to the outside world, and hence fewer things to go wrong.</p>

<p>This is not to say it would be wrong to use a class to implement a financial model, but the decision to use a module of non-member functions rather than a class will come down to a design decision. There may be cases where it might be preferable to have a set of models conform to a contract set on an abstract base class, as we will discuss in the next chapter., so it really comes down to weighing the pros and cons of each while considering the requirements set in the design phase.</p>

<p>As for writing classes, the modern approach also involves using modules. This is the topic of the next section.</p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="User-Defined Class Implementation in Modules"><div class="sect1" id="user_defined_class_implementation_in_modules">
<h1><span>User-Defined Class Implementation in Modules</span></h1>

<p>The traditional way to write a (non-templated) class in C++ has also been to write the declarations in a header file, and the implementations in a separate file. For a class, this could also be beneficial in terms of code maintenance, as the declarations alone – provided the member function and variable naming was informative – essentially presented an outline up front about what the class did without the “clutter” from all the function implementations.</p>

<p>Moving to modules, again the declarations and implementations can now be placed in a single file, with the same best practice of keeping the class declaration separate from the implementation. This way, compile times can be reduced, plus the outline of the class once found in a header file is preserved inside a module.</p>

<p>With the exception of a new module name to hold a class called `BlackScholes`,</p>

<div data-type="example">
<pre data-type="programlisting">
export module BlackScholesClass;</pre>
</div>

<p>the same preliminary `import`, `export`, and `export import` statements, as in the non-member function version, remain the same. Things then change with writing the class declaration rather than those for individual functions. Note the entire class declaration is placed inside the scope of the `export class` statement.</p>

<div data-type="example">
<pre data-type="programlisting">
export class BlackScholes
{
public:
	double black_scholes_price(double strike, double spot, double rate,
		double sigma, double year_frac, PayoffType pot);
private:
	void dee_fcns_(double strike, double rate, double spot,
		double sigma, double year_frac);
	double norm_cdf_(double x);
	double d1_ = 0.0, d2_ = 0.0;
};</pre>
</div>

<p>The member functions are the same as before, but scoped with the class name:</p>

<div data-type="example">
<pre data-type="programlisting">
double BlackScholes::black_scholes_price(double strike, double spot, double rate,
	double sigma, double year_frac, PayoffType pot)
{
	double opt_price = 0.0;
	// phi, as in the James book: 
	double phi = (pot == PayoffType::CALL) ? 1.0 : -1.0;
	if (year_frac &gt; 0.0) . . . 
	return opt_price;
}
etc. . .</pre>
</div>

<p>As the class declaration is marked `export`, the implementations are implicitly exported, so there is no need to `export` the public `black_scholes_price` function.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Using Namespaces with Modules"><div class="sect1" id="using_namespaces_with_modules">
<h1><span>Using Namespaces with Modules</span></h1>

<p>Namespaces have often been employed to prevent name clashes between functions with the same name and signature, but from different source files or libraries. They can also prevent similar compiler errors from two different modules.</p>

<p>Suppose there are two modules, `ThisModule` and `ThatModule`, each containing a `maximum` function that returns the maximum value of two real numbers.</p>

<div data-type="example">
<pre data-type="programlisting">
export module ThisModule;
export double maximum(double x, double y)
{
	double max_val = x &gt; y ? x : y;
	return max_val;
}
export module ThatModule;
export double maximum(double x, double y)
{
	double max_val = 2*x &gt; 2*y ? x : y;
	return max_val;
}</pre>
</div>

<p>If both modules are imported into another translation unit (eg Main.cpp) and a call is made to the `maximum` function, the compiler will not be able to determine which version of the function is intended, resulting in a compiler error.</p>

<div data-type="example">
<pre data-type="programlisting">
// In some other location:
import ThisModule;
import ThatModule;
//. . .
double compare_max(double x, double y)
{
	return maximum(x, y);	// Compiler error!
} </pre>
</div>

<p>By wrapping the `maximum` function in a distinct namespace and indicating the namespace scope when called outside the module, the compiler error is avoided.</p>

<div data-type="example">
<pre data-type="programlisting">
export module ThisModule;
export namespace this_nsp
{
	export double maximum(double x, double y)
	{
		double max_val = x &gt; y ? x : y;
		return max_val;
	}
}
export module ThatModule;
export namespace that_nsp
{
	export double maximum(double x, double y)
	{
		double max_val = 2*x &gt; 2*y ? x : y;
		return max_val;
	}
}</pre>
</div>

<p>Now, scope the function call with one of the namespaces, just as we do for functions in classes in the `std` Standard Library namespace, and the code will compile:</p>

<div data-type="example">
<pre data-type="programlisting">
import ThisModule;
import ThatModule;
//. . .
double compare_max(double x, double y)
{
	return this_nsp::maximum(x, y);	// Will now compile
}</pre>
</div>

<p>An alternative would be to use a `using` alias for one of the namespaces:</p>

<div data-type="example">
<pre data-type="programlisting">
import ThisModule;
import ThatModule;
using that_nsp::maximum
// …
double compare_max(double x, double y)
{
	return this_nsp::maximum(x, y);	// Will also compile
}</pre>
</div>

<p>Note that if in `Main.cpp`, the entirety of each of these namespaces is loaded into the global namespace with `using namespace` statements, and there is no scoping of the `maximum` function, the same problem will ensue, as shown here:</p>

<div data-type="example">
<pre data-type="programlisting">
import ThisModule;
import ThatModule;
using namespace this_nsp;
using namespace that_nsp;
// . . .
double compare_max(double x, double y)
{
	return maximum(x, y);	// Compiler error!
}</pre>
</div>

<p>As a corollary, you can now see why global use of</p>

<div data-type="example">
<pre data-type="programlisting">
`using namespace::std;`</pre>
</div>

<p>is also not regarded as good practice. With so many classes and functions in the Standard Library, it is entirely possible that someone might use a common name as a user-defined class or function elsewhere, causing a name clash that leads to a compiler error.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Many of the newer features in C++, beginning with C++11, have their roots in the Boost Libraries. For example, smart pointers `unique_ptr` and `shared_ptr` use the same names in Boost as well as in the Standard Library. As the Boost libraries are in wide use, opening up both the entire `std` and `boost` namespaces globally could create headaches for code maintenance and build teams</p>

<p>Both smart pointers in particular, and the Boost libraries more generally, will be covered in later chapters of this book.</p>
</div>

<p>Our discussion of namespaces here is related more specifically to modules, but for more information about best practices using namespaces in C++, Sutter and Alexandrescu, Coding Style, chapter X remains an excellent resource.</p>

<p>As a general takeaway, classes and functions that belong to namespaces should either be scoped explicitly; eg,</p>

<div data-type="example">
<pre data-type="programlisting">
import &lt;vector&gt;;
import ThisModule;
//. . .
std::vector&lt;double&gt; v;
return this_nsp::maximum(x, y);</pre>
</div>

<p>or contained in using aliases; eg,</p>

<div data-type="example">
<pre data-type="programlisting">
import &lt;vector&gt;;
using std::vector;
import ThisModule;
using this_nsp::maximum; </pre>
</div>

<p>rather than exposing entire namespaces globally.</p>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="summary_idN6MDDx">
<h1><span>Summary</span></h1>

<p>TBD…</p>

<p>Some references:</p>

<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1502r1.html"><span>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1502r1.html</span> </a></p>

<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1453r0.html"><span>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1453r0.html</span> </a></p>

<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0581r1.pdf"><span>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0581r1.pdf</span> </a></p>

<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2412r0.pdf"><span>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2412r0.pdf</span> </a></p>

<p><a href="https://devblogs.microsoft.com/cppblog/a-tour-of-cpp-modules-in-visual-studio/"><span>https://devblogs.microsoft.com/cppblog/a-tour-of-cpp-modules-in-visual-studio/</span> </a></p>

<p><a href="https://github.com/microsoft/STL/issues/60"><span>https://github.com/microsoft/STL/issues/60</span> </a></p>

<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0955r0.pdf"><span>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0955r0.pdf</span> </a></p>
</div></section>
</div></section></div></body></html>