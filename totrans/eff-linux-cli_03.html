<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introducing the Shell"><div class="chapter" id="ch_shell">
<h1><span class="label">Chapter 2. </span>Introducing the Shell</h1>


<p><a data-type="indexterm" data-primary="shell" id="shell"/>
So, you can run commands at a prompt<a data-type="indexterm" data-primary="prompt" id="idm46586657040368"/>.<a data-type="indexterm" data-primary="shell" data-secondary="prompt" id="idm46586657039568"/><a data-type="indexterm" data-primary="running commands" data-secondary="shell prompt" id="idm46586657038592"/> But what <em>is</em> that prompt? Where
does it come from, how are your commands run, and why does it matter?</p>

<p>That little prompt is produced by a program called a <em>shell</em>. It’s a
user interface that sits between you and the Linux operating system.
Linux supplies several shells, and the most common (and the standard
for this book) is called <code>bash</code><a data-type="indexterm" data-primary="bash" data-secondary="about the shell" id="idm46586657035616"/>. (See <a data-type="xref" href="app02.xhtml#appendix_shells">Appendix B</a> for notes about
other shells.)</p>

<p><code>bash</code> and other shells do much more than simply run commands. For
example, when a command includes a wildcard<a data-type="indexterm" data-primary="wildcards" data-seealso="pattern matching" id="idm46586657032832"/> (<code>*</code>) to refer to multiple
files at once:</p>

<pre data-type="programlisting">$ <strong>ls *.py</strong>
data.py    main.py    user_interface.py</pre>

<p>the wildcard is handled entirely by the shell, not by the program
<code>ls</code>. The shell evaluates the expression <code>*.py</code> and invisibly
replaces it with a list of matching filenames <em>before</em> <code>ls</code> runs. In
other words, <code>ls</code> <em>never sees the wildcard</em>. From the perspective of
<code>ls</code>, you typed the following command:</p>

<pre data-type="programlisting">$ <strong>ls data.py main.py user_interface.py</strong></pre>

<p>The shell also handles the pipes you saw in <a data-type="xref" href="ch01.xhtml#ch_combining_commands">Chapter 1</a>.
It redirects<a data-type="indexterm" data-primary="redirection" id="idm46586657023904"/> stdin and stdout transparently<a data-type="indexterm" data-primary="pipes" data-secondary="transparency" id="idm46586657023024"/> so the programs involved
have no idea they are communicating with each other.</p>

<p>Every time a command runs, some steps are the responsibility<a data-type="indexterm" data-primary="shell" data-secondary="programs versus" id="idm46586657021568"/> of the
invoked program, such as <code>ls</code>, and some are the responsibility of the
shell. Expert users understand which is which. That’s one reason they
can create long, complex commands off the top of their head and run
them successfully. They <em>already know what the command will do</em> before
they press Enter, in part because they understand the separation
between the shell and the programs it invokes.</p>

<p>In this chapter, we’ll launch your understanding of the Linux shell.
I’ll take the same minimalist approach I used for commands and
pipes in <a data-type="xref" href="ch01.xhtml#ch_combining_commands">Chapter 1</a>. Rather than cover dozens of shell
features, I’ll hand you just enough information to carry you to the
next step of your learning journey:</p>

<ul>
<li>
<p>Pattern matching for filenames</p>
</li>
<li>
<p>Variables to store values</p>
</li>
<li>
<p>Redirection of input and output</p>
</li>
<li>
<p>Quoting and escaping to disable certain shell features</p>
</li>
<li>
<p>The search path for locating programs to run</p>
</li>
<li>
<p>Saving changes to your shell environment</p>
</li>
</ul>






<section data-type="sect1" data-pdf-bookmark="Shell Vocabulary"><div class="sect1" id="idm46586657011712">
<h1>Shell Vocabulary</h1>

<p><a data-type="indexterm" data-primary="shell" data-secondary="meaning of term" id="idm46586657010512"/>
The word <em>shell</em> has two meanings. Sometimes it means the <em>concept</em> of
the Linux shell in general, as in “The shell is a powerful tool” or
“<code>bash</code> is a shell.”
Other times it means a specific <em>instance</em><a data-type="indexterm" data-primary="instance of a shell" id="idm46586657007520"/> of a shell
running on a given Linux computer, awaiting your next command.</p>

<p>In this book, the meaning of <em>shell</em> should be clear from the
context most of the time. When necessary, I’ll refer to the second meaning as a
<em>shell instance</em><a data-type="indexterm" data-primary="shell" data-secondary="instance" id="idm46586657005280"/>, a <em>running shell</em>,<a data-type="indexterm" data-primary="running shell" id="idm46586657003760"/> or your
<em>current shell</em>.<a data-type="indexterm" data-primary="current shell" id="idm46586657002480"/></p>

<p>Some shell instances, but not all, present a prompt so you can interact
with them. I’ll use the term
<em>interactive shell<a data-type="indexterm" data-primary="interactive shell" id="idm46586657001088"/></em><a data-type="indexterm" data-primary="shell" data-secondary="interactive" id="idm46586652413504"/> to refer to these instances.
Other shell instances are noninteractive—they run a sequence of commands and exit.<a data-type="indexterm" data-primary="noninteractive shell" id="idm46586652412304"/><a data-type="indexterm" data-primary="shell" data-secondary="noninteractive" id="idm46586652411632"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Pattern Matching for Filenames"><div class="sect1" id="idm46586652410432">
<h1>Pattern Matching for Filenames</h1>

<p><a data-type="indexterm" data-primary="filenames" data-secondary="pattern matching" id="filenamematch"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="filenames" id="filenamematch2"/>
In <a data-type="xref" href="ch01.xhtml#ch_combining_commands">Chapter 1</a>, you worked with several commands that
accept filenames as arguments, such as <code>cut</code>, <code>sort</code>, and
<code>grep</code>. These commands (and many others) accept multiple filenames as
arguments. For example, you can search for the word <em>Linux</em> in one hundred
files at once, named <em>chapter1</em> through <em>chapter100</em>:</p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>grep Linux chapter1 chapter2 chapter3 chapter4 chapter5</strong> <em>...and so on...</em></pre>

<p>Listing multiple files by name is a tedious time-waster, so the shell
provides special characters as a shorthand to refer to files or
directories with similar names. Many folks call these characters
wildcards, but the more general concept is called <em>pattern matching</em><a data-type="indexterm" data-primary="pattern matching" id="idm46586652399712"/>
or <em>globbing</em>.<a data-type="indexterm" data-primary="globbing" data-seealso="pattern matching" id="idm46586652398464"/> Pattern matching is one of the two most common
techniques for speed that Linux users learn. (The other is pressing
the up arrow key<a data-type="indexterm" data-primary="up arrow key" id="idm46586652397184"/> to recall the shell’s previous command<a data-type="indexterm" data-primary="previous command" id="idm46586652396320"/>, which I describe
in <a data-type="xref" href="ch03.xhtml#ch_history">Chapter 3</a>.)</p>

<p>Most Linux users are familiar with the
star or asterisk<a data-type="indexterm" data-primary="* (asterisk)" data-secondary="filename pattern matching" id="idm46586652394336"/><a data-type="indexterm" data-primary="asterisk (*)" data-secondary="filename pattern matching" id="idm46586652393392"/> character (<code>*</code>),
which matches any sequence of zero or
more characters (except for a leading dot)<sup><a data-type="noteref" id="idm46586652391888-marker" href="ch02.xhtml#idm46586652391888">1</a></sup> in file or directory paths:</p>

<pre data-type="programlisting">$ <strong>grep Linux chapter* </strong></pre>

<p>Behind the scenes, the shell (not <code>grep</code>!) expands the pattern
<code>chapter*</code> into a list of 100 matching filenames. Then the shell runs
<code>grep</code>.</p>

<p>Many users have also seen the question mark
(<code>?</code>)<a data-type="indexterm" data-primary="? (question mark) for file pattern matching" id="idm46586652384400"/><a data-type="indexterm" data-primary="question mark (?) for file pattern matching" id="idm46586652383568"/>
special character, which matches any single character
(except a leading dot). For
example, you could search for the word <em>Linux</em> in chapters 1 through 9
only, by providing a single question mark to make the shell match
single digits:</p>

<pre data-type="programlisting">$ <strong>grep Linux chapter?</strong></pre>

<p>or in chapters 10 through 99, with two question marks to match two
digits:</p>

<pre data-type="programlisting">$ <strong>grep Linux chapter??</strong></pre>

<p>Fewer users are familiar with square brackets (<code>[]</code>),<a data-type="indexterm" data-primary="[] (square brackets)" data-secondary="filename pattern matching" id="idm46586652378816"/><a data-type="indexterm" data-primary="square brackets ([])" data-secondary="filename pattern matching" id="idm46586652377744"/> which request
the shell to match a single character from a set. For example, you
could search only the first five chapters:</p>

<pre data-type="programlisting">$ <strong>grep Linux chapter[12345]</strong></pre>

<p>Equivalently, you could supply a range of characters with a dash:<a data-type="indexterm" data-primary="- (dash)" data-secondary="filename pattern matching" id="idm46586652375152"/><a data-type="indexterm" data-primary="dash (-)" data-secondary="filename pattern matching" id="idm46586652374032"/><a data-type="indexterm" data-primary="range of" data-secondary="characters" data-tertiary="filename pattern matching" id="idm46586652373072"/></p>

<pre data-type="programlisting">$ <strong>grep Linux chapter[1-5]</strong></pre>

<p>You could also search even-numbered chapters, combining the asterisk and
the square brackets to make the shell match filenames ending in an
even digit:</p>

<pre data-type="programlisting">$ <strong>grep Linux chapter*[02468]</strong></pre>

<p>Any characters, not just digits, may appear within the square brackets
for matching. For example, filenames that begin with a capital letter,
contain an underscore, and end with an <code>@</code> symbol would be matched by
the shell in this command:</p>
<pre data-type="programlisting">$ <strong>ls [A-Z]*_*@</strong></pre>
<div data-type="tip"><h1>Terminology: Evaluating Expressions and Expanding Patterns</h1>
<p>Strings that you enter on the command line, such as <code>chapter*</code> or
<code>Efficient Linux</code>, are called <em>expressions<a data-type="indexterm" data-primary="expressions" id="idm46586652509008"/></em>. An entire command
like <code>ls -l chapter*</code> is an expression too.</p>

<p>When the shell interprets and handles special characters in an
expression, such as asterisks and pipe symbols, we say that the shell
<em>evaluates</em><a data-type="indexterm" data-primary="evaluating expressions" id="idm46586652506864"/><a data-type="indexterm" data-primary="expressions" data-secondary="evaluating" id="idm46586652506160"/> the expression.</p>

<p>Pattern matching is one kind of evaluation. When the shell evaluates an
expression that contains pattern-matching symbols, such as <code>chapter*</code>,
and replaces it with filenames that match the pattern, we say that the
shell <em>expands</em> <a data-type="indexterm" data-primary="expanding a pattern" id="idm46586652503600"/> the pattern.</p>
</div>

<p>Patterns are valid almost anywhere that you’d supply file or directory
paths on the command line. For example, you can list all files in the
directory <em>/etc</em> with names ending in <em>.conf</em> using a pattern:</p>

<pre data-type="programlisting">$ <strong>ls -1 /etc/*.conf</strong>
/etc/adduser.conf
/etc/appstream.conf
⋮
/etc/wodim.conf</pre>

<p>Be careful using a pattern with a command that accepts just one file
or directory argument, such as <code>cd</code>. You might not get the behavior
you expect:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
Pictures   Poems    Politics
$ <strong>cd P* </strong>                                  <em>Three directories will match</em>
bash: cd: too many arguments</pre>

<p>If a pattern doesn’t match any files,<a data-type="indexterm" data-primary="filenames" data-secondary="pattern matching" data-tertiary="no matches" id="idm46586652496480"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="filenames" data-tertiary="no matches" id="idm46586652495232"/> the shell leaves it unchanged to
be passed literally as a command argument. In the following command,
the pattern <code>*.doc</code> matches nothing in the current directory, so <code>ls</code>
looks for a filename literally named <code>*.doc</code> and fails:</p>
<pre data-type="programlisting">$ <strong>ls *.doc</strong>
/bin/ls: cannot access '*.doc': No such file or directory</pre>

<p>When working with file patterns, two points are vitally important to
remember.  The first, as I’ve already emphasized, is that the shell,
not the invoked program, performs the pattern matching.<a data-type="indexterm" data-primary="shell" data-secondary="pattern-matching responsibility" id="idm46586652490560"/> I know I keep
repeating this, but I’m frequently surprised by how many Linux users
don’t know it and develop superstitions about why certain commands
succeed or fail.</p>

<p>The second important point is that shell pattern matching applies only
to file and directory paths.<a data-type="indexterm" data-primary="filenames" data-secondary="pattern matching" data-tertiary="limited to filenames" id="idm46586652488352"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="filenames" data-tertiary="limited to filenames" id="idm46586652487104"/> It doesn’t work for usernames, hostnames,
and other types of arguments that certain commands accept. You also
cannot type (say) <code>s?rt</code> at the 
<span class="keep-together">beginning</span> of the command line and
expect the shell to run the <code>sort</code> program. (Some Linux commands such
as <code>grep</code>, <code>sed</code>, and <code>awk</code> perform their own brands of
pattern matching, which we’ll explore in <a data-type="xref" href="ch05.xhtml#ch_toolbox">Chapter 5</a>.)</p>
<div data-type="note" epub:type="note"><h1>Filename Pattern Matching and Your Own Programs</h1>
<p>All programs that accept filenames as arguments automatically “work”
with pattern matching,<a data-type="indexterm" data-primary="filenames" data-secondary="pattern matching" data-tertiary="your own programs" id="idm46586652480576"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="filenames" data-tertiary="your own programs" id="idm46586652479328"/> because the shell evaluates the patterns before
the program runs. This is true even for programs and scripts you write
yourself. For example, if you wrote a program <code>english2swedish</code> that
translated files from English to Swedish and accepted multiple
filenames on the command line, you could instantly run it with
pattern matching:<a data-type="indexterm" data-startref="filenamematch" id="idm46586652477344"/><a data-type="indexterm" data-startref="filenamematch2" id="idm46586652476640"/></p>

<pre data-type="programlisting">$ <strong>english2swedish *.txt</strong></pre>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Evaluating Variables"><div class="sect1" id="section_variables">
<h1>Evaluating Variables</h1>

<p><a data-type="indexterm" data-primary="variables" data-secondary="shell variables" id="idm46586652473008"/><a data-type="indexterm" data-primary="shell" data-secondary="variables" data-seealso="variables" id="idm46586652472032"/>
A running shell can define variables and store values in them. A shell
variable is a lot like a variable in algebra—it has a name and a
value. An example is the shell variable <code>HOME</code>.<a data-type="indexterm" data-primary="home directory" data-secondary="HOME variable" id="idm46586652470112"/><a data-type="indexterm" data-primary="directory" data-secondary="home directory" data-tertiary="HOME variable" id="idm46586652469104"/><a data-type="indexterm" data-primary="variables" data-secondary="HOME" id="idm46586652467888"/> Its value is the path
to your Linux home directory, such as <em>/home/smith</em>. Another example
is <code>USER</code>,<a data-type="indexterm" data-primary="USER variable" id="idm46586652465904"/><a data-type="indexterm" data-primary="variables" data-secondary="USER" id="idm46586653294624"/> whose value is your Linux username, which I’ll assume is
<code>smith</code> throughout this book.</p>

<p>To print the values of <code>HOME</code> and <code>USER</code> on stdout, run the command <code>printenv</code>:<a data-type="indexterm" data-primary="printenv command" id="idm46586653291456"/><a data-type="indexterm" data-primary="variables" data-secondary="printing the value" id="idm46586653290720"/></p>

<pre data-type="programlisting">$ <strong>printenv HOME</strong>
/home/smith
$ <strong>printenv USER</strong>
smith</pre>

<p>When the shell evaluates a variable, it replaces the variable name
with its value. Simply place a dollar sign<a data-type="indexterm" data-primary="$ (dollar sign)" data-secondary="variable evaluation" id="idm46586653287648"/><a data-type="indexterm" data-primary="dollar sign ($)" data-secondary="variable evaluation" id="idm46586653286672"/> in front of the name to
evaluate the variable. For example, <code>$HOME</code> evaluates to the string
<code>/home/smith</code>.</p>

<p>The easiest way to watch the shell evaluate a command line is to run
the <code>echo</code><a data-type="indexterm" data-primary="echo command" id="idm46586653283936"/><a data-type="indexterm" data-primary="builtins" data-secondary="echo" id="idm46586653283232"/> command, which simply prints its arguments (after the shell
is finished evaluating them):</p>

<pre data-type="programlisting">$ <strong>echo My name is $USER and my files are in $HOME</strong>    <em>Evaluating variables</em>
My name is smith and my files are in /home/smith
$ <strong>echo ch*ter9</strong>                                       <em>Evaluating a pattern</em>
chapter9</pre>








<section data-type="sect2" data-pdf-bookmark="Where Variables Come From"><div class="sect2" id="idm46586653279456">
<h2>Where Variables Come From</h2>

<p>Variables like <code>USER</code> and <code>HOME</code> are predefined<a data-type="indexterm" data-primary="variables" data-secondary="predefined" id="idm46586653276784"/> by the shell. Their values are
set automatically when you log in. (More on this process later.)
Traditionally, such predefined variables have uppercase names.</p>

<p>You also may define<a data-type="indexterm" data-primary="variables" data-secondary="defining" id="idm46586653275264"/> or modify<a data-type="indexterm" data-primary="variables" data-secondary="modifying" id="idm46586653274128"/> a variable anytime by assigning<a data-type="indexterm" data-primary="variables" data-secondary="assigning a value" id="idm46586653272976"/><a data-type="indexterm" data-primary="assigning a value to a variable" id="idm46586653272032"/> it a
value using this syntax:</p>

<pre data-type="programlisting"><em>name</em>=<em>value</em></pre>

<p>For example, if you work frequently in the directory
<em>/home/smith/Projects</em>, you could assign its name to a variable:</p>

<pre data-type="programlisting">$ <strong>work=$HOME/Projects</strong></pre>

<p>and use it as a handy shortcut with <code>cd</code>:</p>

<pre data-type="programlisting">$ <strong>cd $work</strong>
$ <strong>pwd</strong>
/home/smith/Projects</pre>

<p>You may supply <code>$work</code> to any command that expects a directory:</p>

<pre data-type="programlisting">$ <strong>cp myfile $work</strong>
$ <strong>ls $work</strong>
myfile</pre>

<p>When defining a variable, no spaces<a data-type="indexterm" data-primary="variables" data-secondary="defining" data-tertiary="whitespace around equals sign" id="idm46586653262464"/><a data-type="indexterm" data-primary="whitespace" data-secondary="variables defined without" id="idm46586653261152"/> are permitted around the equals
sign. If you forget, the shell will assume (wrongly) that the first
word on the command line is a program to run, and the equals sign and
value are its arguments, and you’ll see an error message:</p>

<pre data-type="programlisting">$ <strong>work = $HOME/Projects</strong>               <em>The shell assumes "work" is a command</em>
work: command not found</pre>

<p>A user-defined variable like <code>work</code> is just as legitimate and usable
as a system-defined variable like <code>HOME</code>. The only practical
difference is that some Linux programs change their behavior
internally based on the values of <code>HOME</code>, <code>USER</code>, and other
system-defined variables. For example, a Linux program with a
graphical interface might retrieve your username from the shell and
display it. Such programs don’t pay attention to an invented variable
like <code>work</code> because they weren’t programmed to do so.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Variables and Superstition"><div class="sect2" id="idm46586653278800">
<h2>Variables and Superstition</h2>

<p>When you print the value of a variable with <code>echo</code>:</p>

<pre data-type="programlisting">$ <strong>echo $HOME</strong>
/home/smith</pre>

<p>you might think that the <code>echo</code> command examines the <code>HOME</code> variable
and prints its value. That is <em>not</em> the case. <code>echo</code> knows nothing
about variables.<a data-type="indexterm" data-primary="echo command" data-secondary="variable evaluation" id="idm46586653249872"/> It just prints whatever arguments you hand it.
What’s really happening is that the shell evaluates <code>$HOME</code> before
running <code>echo</code>. From <code>echo</code>’s perspective, you typed:</p>

<pre data-type="programlisting">$ <strong>echo /home/smith</strong></pre>

<p>This behavior is extremely important to understand, especially as we
delve into more complicated commands. The shell evaluates the
variables in a command—as well as patterns and other shell
constructs—before executing the command.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Patterns Versus Variables"><div class="sect2" id="idm46586653245904">
<h2>Patterns Versus Variables</h2>

<p><a data-type="indexterm" data-primary="variables" data-secondary="filename pattern matching versus" id="idm46586653244336"/>
<a data-type="indexterm" data-primary="filenames" data-secondary="pattern matching" data-tertiary="variable evaluation versus" id="idm46586653243104"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="filenames" data-tertiary="variable evaluation versus" id="idm46586653241840"/>
Let’s test your understanding of pattern and variable
evaluation. Suppose you’re in a directory with two subdirectories,
<em>mammals</em> and <em>reptiles</em>, and oddly, the <em>mammals</em> subdirectory contains
files named <em>lizard.txt</em> and <em>snake.txt</em>:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
mammals   reptiles
$ <strong>ls mammals</strong>
lizard.txt  snake.txt</pre>

<p>In the real world, lizards and snakes are not mammals, so the two
files should be moved to the <em>reptiles</em> subdirectory. Here are two
proposed ways to do it. One works, and one does not:</p>

<pre data-type="programlisting" data-code-language="bash"><code>mv</code><code> </code><code>mammals/*.txt</code><code> </code><code>reptiles</code><code>                     </code><em><code>Method</code><code> </code><code class="m">1</code></em><code>

</code><code class="nv">FILES</code><code class="o">=</code><code class="s2">"lizard.txt snake.txt"</code><code>
</code><code>mv</code><code> </code><code>mammals/</code><code class="nv">$FILES</code><code> </code><code>reptiles</code><code>                    </code><em><code>Method</code><code> </code><code class="m">2</code></em></pre>

<p>Method 1 works because patterns match an entire file path. See how the
directory name <em>mammals</em> is part of both matches for <code>mammals/*.txt</code>:</p>

<pre data-type="programlisting">$ <strong>echo mammals/*.txt</strong>
mammals/lizard.txt mammals/snake.txt</pre>

<p>So, method 1 operates as if you’d typed the following correct command:</p>

<pre data-type="programlisting">$ <strong>mv mammals/lizard.txt mammals/snake.txt reptiles</strong></pre>

<p>Method 2 uses variables, which evaluate to their literal value
only. They have no special handling for file paths:</p>

<pre data-type="programlisting">$ <strong>echo mammals/$FILES</strong>
mammals/lizard.txt snake.txt</pre>

<p>So, method 2 operates as if you’d typed the following problematic command:</p>

<pre data-type="programlisting">$ <strong>mv mammals/lizard.txt snake.txt reptiles</strong></pre>

<p>This command looks for the file <em>snake.txt</em> in the current directory,
not in the <em>mammals</em> subdirectory, and fails:</p>

<pre data-type="programlisting">$ <strong>mv mammals/$FILES reptiles</strong>
/bin/mv: cannot stat 'snake.txt': No such file or directory</pre>

<p>To make a variable work in this situation, use a <code>for</code> loop<a data-type="indexterm" data-primary="for loop" data-secondary="bash" id="idm46586652865248"/><a data-type="indexterm" data-primary="builtins" data-secondary="for" id="idm46586652548544"/><a data-type="indexterm" data-primary="loops" data-secondary="bash" data-tertiary="for loop" id="idm46586651806032"/> that prepends
the directory name <em>mammals</em> to each filename:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">FILES</code><code class="o">=</code><code class="s2">"lizard.txt snake.txt"</code>
<code class="k">for</code> f <code class="k">in</code> <code class="nv">$FILES</code><code class="p">;</code> <code class="k">do</code>
  mv mammals/<code class="nv">$f</code> reptiles
<code class="k">done</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Shortening Commands with Aliases"><div class="sect1" id="idm46586656223856">
<h1>Shortening Commands with Aliases</h1>

<p><a data-type="indexterm" data-primary="aliases" id="idm46586656136128"/><a data-type="indexterm" data-primary="shell" data-secondary="aliases" id="idm46586656323920"/>
A variable is a name that stands in for a value. The shell also has
names that stand in for commands. They’re called <em>aliases</em>. Define an
alias by inventing a name and following it with a equals sign and a
command:<a data-type="indexterm" data-primary="alias command" id="idm46586654689616"/></p>

<pre data-type="programlisting">$ <strong>alias g=grep</strong>                 <em>A command with no arguments</em>
$ <strong>alias ll="ls -l"</strong>             <em>A command with arguments: quotes are required</em></pre>

<p>Run an alias by typing its name as a command. When aliases are shorter
than the commands they invoke, you save typing time:</p>

<pre data-type="programlisting">$ <strong>ll</strong>                                            <em>Runs "ls -l"</em>
-rw-r--r-- 1 smith smith 325 Jul  3 17:44 animals.txt
$ <strong>g Nutshell animals.txt</strong>                        <em>Runs "grep Nutshell animals.txt"</em>
horse   Linux in a Nutshell     2009    Siever, Ellen
donkey  Cisco IOS in a Nutshell 2005    Boney, James</pre>
<div data-type="tip"><h6>Tip</h6>
<p>Always define an alias on its own line, not as part of a combined
command.<a data-type="indexterm" data-primary="aliases" data-secondary="defining in combined commands" id="idm46586653351840"/> (See <code>man bash</code> for the technical details.)</p>
</div>

<p>You can define an alias that has the same name as an existing command,
effectively replacing that command in your shell. This practice is
called <em>shadowing<a data-type="indexterm" data-primary="shadowing" id="idm46586644041616"/></em><a data-type="indexterm" data-primary="aliases" data-secondary="shadowing a command" id="idm46586643685136"/> the command. Suppose you like the <code>less</code> command
for reading files, but you want it to clear the screen before
displaying each page. This feature is enabled with the <code>-c</code><a data-type="indexterm" data-primary="less command" data-secondary="clearing the screen (-c option)" id="idm46586652983472"/> option, so
define an alias called “less” that runs <code>less -c</code>:<sup><a data-type="noteref" id="idm46586653823824-marker" href="ch02.xhtml#idm46586653823824">2</a></sup></p>

<pre data-type="programlisting">$ <strong>alias less="less -c"</strong></pre>

<p>Aliases take precedence<a data-type="indexterm" data-primary="aliases" data-secondary="precedence" id="idm46586653403040"/><a data-type="indexterm" data-primary="precedence" data-secondary="aliases" id="idm46586643544208"/> over commands of the same name, so you have
now shadowed the <code>less</code> command in the current shell. I’ll explain
what <em>precedence</em> means in <a data-type="xref" href="#search_path_aliases">“Search Path and Aliases”</a>.</p>

<p>To list a shell’s aliases and their values, run <code>alias</code> with no
arguments:<a data-type="indexterm" data-primary="aliases" data-secondary="listing" id="idm46586656754448"/></p>

<pre data-type="programlisting">$ <strong>alias</strong>
alias g='grep'
alias ll='ls -l'</pre>

<p>To see the value of a single alias, run <code>alias</code> followed by its name:</p>

<pre data-type="programlisting">$ <strong>alias g</strong>
alias g='grep'</pre>

<p>To delete an alias from a shell, run <code>unalias</code>:<a data-type="indexterm" data-primary="aliases" data-secondary="deleting" id="idm46586653726368"/><a data-type="indexterm" data-primary="unalias command" id="idm46586654632960"/></p>

<pre data-type="programlisting">$ <strong>unalias g</strong></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Redirecting Input and Output"><div class="sect1" id="idm46586652684176">
<h1>Redirecting Input and Output</h1>

<p><a data-type="indexterm" data-primary="redirection" id="redirect"/>
The shell controls the input and output of the commands it runs.
You’ve already seen one example: pipes, which direct the stdout of
one command to the stdin of another. The pipe syntax,
<code>|</code>,<a data-type="indexterm" data-primary="| (vertical bar)" data-secondary="pipe symbol" id="idm46586651324192"/><a data-type="indexterm" data-primary="vertical bar (|)" data-secondary="pipe symbol" id="idm46586653317952"/>
is a feature of the shell.<a data-type="indexterm" data-primary="pipes" data-secondary="shell feature" id="idm46586654676336"/></p>

<p>Another shell feature is redirecting stdout to a file.<a data-type="indexterm" data-primary="stdout" data-secondary="redirection" id="idm46586643507520"/> For example, if
you use <code>grep</code> to print matching lines from the <em>animals.txt</em> file
from <a data-type="xref" href="ch01.xhtml#example_animals.txt">Example 1-1</a>, the command writes to stdout by
default:</p>

<pre data-type="programlisting">$ <strong>grep Perl animals.txt</strong>
alpaca	Intermediate Perl	2012	Schwartz, Randal</pre>

<p>You can send that output to a file instead, using a shell feature
called <em>output redirection</em>.<a data-type="indexterm" data-primary="output redirection" data-seealso="redirection" id="idm46586643919664"/>
Simply add the symbol
<code>&gt;</code><a data-type="indexterm" data-primary="&gt; (greater than)" data-secondary="redirecting stdout" id="rdstdout"/><a data-type="indexterm" data-primary="greater than (&gt;)" data-secondary="redirecting stdout" id="rdstdout2"/>
followed by the name of a file to receive the output:</p>

<pre data-type="programlisting">$ <strong>grep Perl animals.txt &gt; outfile</strong>                      <em>(displays no output)</em>
$ <strong>cat outfile</strong>
alpaca	Intermediate Perl	2012	Schwartz, Randal</pre>

<p>You have just redirected stdout to the file <em>outfile</em> instead of the
display. If the file <em>outfile</em> doesn’t exist, it’s created. If it does
exist, redirection overwrites its contents. If you’d rather
append to the output file rather than overwrite it, use the symbol
<code>&gt;&gt;</code><a data-type="indexterm" data-primary="&gt;&gt; to redirect and append stdout" id="idm46586652014688"/> instead:</p>

<pre data-type="programlisting">$ <strong>grep Perl animals.txt &gt; outfile</strong>              <em>Create or overwrite outfile</em>
$ <strong>echo There was just one match &gt;&gt; outfile</strong>     <em>Append to outfile</em>
$ <strong>cat outfile</strong>
alpaca	Intermediate Perl	2012	Schwartz, Randal
There was just one match</pre>

<p>Output redirection has a partner, <em>input redirection</em>,<a data-type="indexterm" data-primary="input redirection" data-seealso="redirection" id="idm46586642619840"/><a data-type="indexterm" data-primary="stdin" data-secondary="redirection" id="idm46586642618944"/> that redirects
stdin to come from a file instead of the keyboard. Use the symbol <code>&lt;</code><a data-type="indexterm" data-primary="&lt; (less than)" data-secondary="redirecting stdin" id="idm46586642617616"/><a data-type="indexterm" data-primary="less than (&lt;)" data-secondary="redirecting stdin" id="idm46586642598704"/>
followed by a filename to redirect stdin.</p>

<p>Many Linux commands that accept filenames as arguments, and read from those
files, also read from stdin when run with no arguments. An example is <code>wc</code> for
counting lines, words, and characters in a file:</p>

<pre data-type="programlisting">$ <strong>wc animals.txt</strong>                            <em>Reading from a named file</em>
  7  51 325 animals.txt
$ <strong>wc &lt; animals.txt</strong>                          <em>Reading from redirected stdin</em>
  7  51 325</pre>
<aside data-type="sidebar" epub:type="sidebar" class="pagebreak-after"><div class="sidebar" id="idm46586642594352">
<h5>Standard Error (stderr) and Redirection</h5>
<p>In your day-to-day Linux use, you may notice that some output cannot
be redirected by <code>&gt;</code>, such as certain error messages. For example, ask
<code>cp</code> to copy a file that doesn’t exist, and it produces this error
message:<a data-type="indexterm" data-primary="output redirection" data-secondary="error messages" id="idm46586642591552"/></p>

<pre data-type="programlisting">$ <strong>cp nonexistent.txt file.txt</strong>
cp: cannot stat 'nonexistent.txt': No such file or directory</pre>

<p>If you redirect the output (stdout) of this <code>cp</code> command to a file,
<em>errors</em>, the message still appears on-screen:</p>

<pre data-type="programlisting">$ <strong>cp nonexistent.txt file.txt &gt; errors</strong>
cp: cannot stat 'nonexistent.txt': No such file or directory</pre>

<p>and the file <em>errors</em> is empty:</p>

<pre data-type="programlisting">$ <strong>cat errors</strong>                                      <em>(produces no output)</em></pre>

<p>Why does this happen? Linux commands can produce more than one stream
of output. In addition to stdout, there is also stderr<a data-type="indexterm" data-primary="stderr" id="idm46586642568496"/> (pronounced
“standard error”<a data-type="indexterm" data-primary="standard error" data-see="stderr" id="idm46586642567760"/><a data-type="indexterm" data-primary="stderr" data-secondary="redirection" id="idm46586642566912"/> or “standard err”), a second stream of output that is
traditionally reserved for error messages. The streams stderr and
stdout look identical on the display, but internally they are separate.
You can redirect stderr with the symbol <code>2&gt;</code><a data-type="indexterm" data-primary="2&gt; to redirect stderr" id="idm46586642565680"/> followed by a filename:</p>

<pre data-type="programlisting">$ <strong>cp nonexistent.txt file.txt 2&gt; errors</strong>
$ <strong>cat errors</strong>
cp: cannot stat 'nonexistent.txt': No such file or directory</pre>

<p>and append stderr to a file with <code>2&gt;&gt;</code><a data-type="indexterm" data-primary="2&gt;&gt; to redirect and append stderr" id="idm46586642562912"/> followed by a filename:</p>

<pre data-type="programlisting">$ <strong>cp nonexistent.txt file.txt 2&gt; errors</strong>
$ <strong>cp another.txt file.txt 2&gt;&gt; errors</strong>
$ <strong>cat errors</strong>
cp: cannot stat 'nonexistent.txt': No such file or directory
cp: cannot stat 'another.txt': No such file or directory</pre>

<p>To redirect both stdout and stderr to the same file, use <code>&amp;&gt;</code><a data-type="indexterm" data-primary="&amp;&gt; to redirect stdout and stderr" id="idm46586642559632"/><a data-type="indexterm" data-primary="ampersand (&amp;)" data-secondary="&amp;&gt; to redirect stdout and stderr" id="idm46586642559024"/> followed
by a filename:<a data-type="indexterm" data-startref="redirect" id="idm46586642558048"/><a data-type="indexterm" data-startref="rdstdout" id="idm46586642557440"/><a data-type="indexterm" data-startref="rdstdout2" id="idm46586642556832"/></p>

<pre data-type="programlisting">$ <strong>echo This file exists &gt; goodfile.txt</strong>               <em>Create a file</em>
$ <strong>cat goodfile.txt nonexistent.txt &amp;&gt; all.output</strong>
$ <strong>cat all.output</strong>
This file exists
cat: nonexistent.txt: No such file or directory</pre>
</div></aside>

<p>It’s <em>very important</em> to understand how these two <code>wc</code> commands differ in
behavior:</p>

<ul>
<li>
<p>In the first command, <code>wc</code> receives the filename <em>animals.txt</em> as an
argument, so <code>wc</code> is aware that the file exists. <code>wc</code> deliberately
opens the file on disk and reads its contents.</p>
</li>
<li>
<p>In the second command, <code>wc</code> is invoked with no arguments, so it
reads from stdin, which is usually the keyboard. The shell, however,
sneakily redirects stdin to come from <em>animals.txt</em> instead.
<code>wc</code> has no idea that the file <em>animals.txt</em> exists.</p>
</li>
</ul>

<p>The shell can redirect input and output in the same command:</p>

<pre data-type="programlisting">$ <strong>wc &lt; animals.txt &gt; count</strong>
$ <strong>cat count</strong>
  7  51 325</pre>

<p>and can even use pipes at the same time. Here, <code>grep</code> reads from
redirected stdin and pipes the results to <code>wc</code>, which writes to
redirected stdout, producing the file <em>count</em>:</p>

<pre data-type="programlisting">$ <strong>grep Perl &lt; animals.txt | wc &gt; count</strong>
$ <strong>cat count</strong>
      1       6      47</pre>

<p>You’ll dive deeper into such combined commands in <a data-type="xref" href="ch08.xhtml#ch_one_liner">Chapter 8</a> and
see many other examples of redirection throughout the book.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Disabling Evaluation with Quotes and Escapes"><div class="sect1" id="idm46586651526128">
<h1>Disabling Evaluation with Quotes and Escapes</h1>

<p><a data-type="indexterm" data-primary="quoting" id="idm46586642540016"/><a data-type="indexterm" data-primary="escaping" id="idm46586642539408"/>
Normally the shell uses whitespace<a data-type="indexterm" data-primary="whitespace" data-secondary="separator" id="idm46586642538672"/><a data-type="indexterm" data-primary="separator" data-secondary="whitespace" id="idm46586642537824"/> as a separator between words. The
following command has four words—a program name followed by three
arguments:</p>

<pre data-type="programlisting">$ <strong>ls file1 file2 file3</strong></pre>

<p>Sometimes, however, you need the shell to treat whitespace as
significant,<a data-type="indexterm" data-primary="whitespace" data-secondary="significant" id="idm46586642535456"/> not as a separator. A common example is whitespace in a
filename such as <em>Efficient Linux Tips.txt</em>:</p>

<pre data-type="programlisting">$ <strong>ls -l</strong>
-rw-r--r-- 1 smith smith 36 Aug  9 22:12 Efficient Linux Tips.txt</pre>

<p>If you refer to such a filename on the command line, your command may
fail because the shell treats the space characters as separators:</p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>cat Efficient Linux Tips.txt</strong>
cat: Efficient: No such file or directory
cat: Linux: No such file or directory
cat: Tips.txt: No such file or directory</pre>

<p>To force the shell to treat spaces as part of a filename, you
have three options—single quotes, double quotes, and backslashes:</p>

<pre data-type="programlisting">$ <strong>cat 'Efficient Linux Tips.txt'</strong>
$ <strong>cat "Efficient Linux Tips.txt"</strong>
$ <strong>cat Efficient\ Linux\ Tips.txt</strong></pre>

<p>Single quotes<a data-type="indexterm" data-primary="single quotes" id="idm46586642529040"/> tell the shell to treat every character in a string
literally, even if the character ordinarily has special meaning to
the shell, such as spaces and dollar signs:</p>

<pre data-type="programlisting">$ <strong>echo '$HOME'</strong>
$HOME</pre>

<p>Double quotes<a data-type="indexterm" data-primary="double quotes" id="idm46586642526912"/> tell the shell to treat all characters literally except
for certain dollar signs and a few others you’ll learn later:</p>

<pre data-type="programlisting">$ <strong>echo "Notice that $HOME is evaluated"</strong>                  <em>Double quotes</em>
Notice that /home/smith is evaluated
$ <strong>echo 'Notice that $HOME is not'</strong>                        <em>Single quotes</em>
Notice that $HOME is not</pre>

<p>A backslash,<a data-type="indexterm" data-primary="backslash (\)" data-secondary="shell escape character" id="idm46586642523632"/><a data-type="indexterm" data-primary="\ (backslash)" data-secondary="shell escape character" id="idm46586642522784"/><a data-type="indexterm" data-primary="slash, backward" data-see="backslash (\)" id="idm46586642521936"/>
also called the <em>escape character</em>,<a data-type="indexterm" data-primary="escape character" id="idm46586642520576"/> tells the shell to
treat the next character literally. The following command includes an
escaped dollar sign:</p>

<pre data-type="programlisting">$ <strong>echo \$HOME</strong>
$HOME</pre>

<p>Backslashes act as escape characters even within double quotes:<a data-type="indexterm" data-primary="double quotes" data-secondary="backslash evaluation" id="idm46586642518320"/></p>

<pre data-type="programlisting">$ <strong>echo "The value of \$HOME is $HOME"</strong>
The value of $HOME is /home/smith</pre>

<p>but not within single quotes:<a data-type="indexterm" data-primary="single quotes" data-secondary="backslash evaluation" id="idm46586642516080"/></p>

<pre data-type="programlisting">$ <strong>echo 'The value of \$HOME is $HOME'</strong>
The value of \$HOME is $HOME</pre>

<p>Use the backslash to escape a double quote character within double quotes:</p>

<pre data-type="programlisting">$ <strong>echo "This message is \"sort of\" interesting"</strong>
This message is "sort of" interesting</pre>

<p>A backslash at the end of a line<a data-type="indexterm" data-primary="\ (backslash)" data-secondary="line continuation" id="idm46586642512448"/><a data-type="indexterm" data-primary="backslash (\)" data-secondary="line continuation" id="idm46586642511600"/> disables the special nature of the
invisible newline character,<a data-type="indexterm" data-primary="newline character" data-secondary="escaping" id="idm46586642510624"/> allowing shell commands to span multiple
lines:</p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>echo "This is a very long message that needs to extend \
onto multiple lines"</strong>
This is a very long message that needs to extend onto multiple lines</pre>

<p>Final backslashes are great for making pipelines more readable,
like this one from <a data-type="xref" href="ch01.xhtml#section_uniq">“Command #6: uniq”</a>:</p>

<pre data-type="programlisting">$ <strong>cut -f1 grades \
  | sort \
  | uniq -c \
  | sort -nr \
  | head -n1 \
  | cut -c9</strong></pre>

<p>When used this way, the backslash is sometimes called a
<em>line continuation character<a data-type="indexterm" data-primary="line continuation character" id="idm46586642505760"/></em>.</p>

<p>A leading backslash before an alias escapes the alias,<a data-type="indexterm" data-primary="aliases" data-secondary="escaping" id="idm46586642504640"/><a data-type="indexterm" data-primary="escaping" data-secondary="aliases" id="idm46586642503792"/> causing the shell
to look for a command of the same name, ignoring any shadowing:<a data-type="indexterm" data-primary="shadowing" id="idm46586642502816"/><a data-type="indexterm" data-primary="aliases" data-secondary="shadowing a command" id="idm46586642502208"/></p>

<pre data-type="programlisting">$ <strong>alias less="less -c"</strong>        <em>Define an alias</em>
$ <strong>less myfile</strong>                 <em>Run the alias, which invokes less -c</em>
$ <strong>\less myfile</strong>                <em>Run the standard less command, not the alias</em></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Locating Programs to Be Run"><div class="sect1" id="section_path">
<h1>Locating Programs to Be Run</h1>

<p><a data-type="indexterm" data-primary="locating" data-secondary="programs" id="idm46586642496000"/>
When the shell first encounters a simple command, such as <code>ls *.py</code>,
it’s just a string of meaningless characters. Quick as a flash,
the shell splits the string into two words, “ls” and “*.py”. In this
case, the first word is the name of a program on disk, and the shell must
locate the program to run it.</p>

<p>The program <code>ls</code>, it turns out, is an executable file in the directory
<em>/bin</em>. You can verify its location with this command:</p>

<pre data-type="programlisting">$ <strong>ls -l /bin/ls</strong>
-rwxr-xr-x 1 root root 133792 Jan 18  2018 /bin/ls</pre>

<p>or you can change directories with <code>cd /bin</code> and run this lovely,
cryptic-looking 
<span class="keep-together">command:</span></p>

<pre data-type="programlisting">$ <strong>ls ls</strong>
ls</pre>

<p>which uses the command <code>ls</code> to list the executable file <em>ls</em>.</p>

<p>How does the shell locate <code>ls</code> in the <em>/bin</em> directory? Behind
the scenes, the shell consults a prearranged list of directories that
it holds in memory, called a <em>search path<a data-type="indexterm" data-primary="search path" id="idm46586642486096"/></em>.<a data-type="indexterm" data-primary="shell" data-secondary="search path" id="idm46586642485232"/><a data-type="indexterm" data-primary="path" data-secondary="search" id="idm46586642484288"/> The list is stored as the
value of the shell variable <code>PATH</code>:<a data-type="indexterm" data-primary="PATH variable" id="idm46586642482768"/><a data-type="indexterm" data-primary="variables" data-secondary="PATH" id="idm46586642482032"/><a data-type="indexterm" data-primary="search path" data-secondary="PATH variable" id="idm46586642481088"/></p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>echo $PATH</strong>
/home/smith/bin:/usr/local/bin:/usr/bin:/bin:/usr/games:/usr/lib/java/bin</pre>

<p>Directories in a search path are separated by colons (<code>:</code>).<a data-type="indexterm" data-primary=": (colon)" data-secondary="PATH separator" id="idm46586642477808"/><a data-type="indexterm" data-primary="colon (:)" data-secondary="PATH separator" id="idm46586642476800"/><a data-type="indexterm" data-primary="separator" data-secondary="colon" data-tertiary="PATH" id="idm46586642475856"/>
For a
clearer view, convert the colons to newline characters by piping the
output to the <code>tr</code><a data-type="indexterm" data-primary="tr command" data-secondary="examples" id="idm46586642474144"/> command, which translates one character into
another<a data-type="indexterm" data-primary="translating characters" data-seealso="tr command" id="idm46586642472976"/><a data-type="indexterm" data-primary="newline character" data-secondary="syntax (\n)" id="idm46586642472032"/><a data-type="indexterm" data-primary="newline character" data-secondary="translating with tr" id="idm46586642471088"/> (more details in <a data-type="xref" href="ch05.xhtml#ch_toolbox">Chapter 5</a>):</p>

<pre data-type="programlisting">$ <strong>echo $PATH | tr : "\n"</strong>
/home/smith/bin
/usr/local/bin
/usr/bin
/bin
/usr/games
/usr/lib/java/bin</pre>

<p>The shell consults directories in your search path from first to last
when locating a program like <code>ls</code>. “Does <em>/home/smith/bin/ls</em> exist?
No. Does <em>/usr/local/bin/ls</em> exist?  Nope. How about <em>/usr/bin/ls</em>? No
again! Maybe <em>/bin/ls</em>? Yes, there it is!  I’ll run <em>/bin/ls</em>.” This
search happens too quickly to notice.<sup><a data-type="noteref" id="idm46586642464768-marker" href="ch02.xhtml#idm46586642464768">3</a></sup></p>

<p>To locate a program in your search path, use the <code>which</code><a data-type="indexterm" data-primary="which command" id="idm46586642461584"/><a data-type="indexterm" data-primary="locating" data-secondary="programs" data-tertiary="which command" id="idm46586642460880"/> command:</p>

<pre data-type="programlisting">$ <strong>which cp</strong>
/bin/cp
$ <strong>which which</strong>
/usr/bin/which</pre>

<p>or the more powerful (and verbose) <code>type</code><a data-type="indexterm" data-primary="type command" id="idm46586642457216"/><a data-type="indexterm" data-primary="locating" data-secondary="programs" data-tertiary="type command" id="idm46586642456512"/> command, a shell builtin<a data-type="indexterm" data-primary="builtins" data-secondary="type" id="idm46586642455168"/>
that also locates aliases, functions, and shell
builtins:<sup><a data-type="noteref" id="idm46586642454096-marker" href="ch02.xhtml#idm46586642454096">4</a></sup></p>

<pre data-type="programlisting">$ <strong>type cp</strong>
cp is hashed (/bin/cp)
$ <strong>type ll</strong>
ll is aliased to ‘/bin/ls -l’
$ <strong>type type</strong>
type is a shell builtin</pre>

<p>Your search path may contain the same-named command in different
directories, such as <em>/usr/bin/less</em> and <em>/bin/less</em>. The shell runs
whichever command appears in the earlier directory in the path. By
leveraging this behavior, you can override a Linux command<a data-type="indexterm" data-primary="overriding a command" id="idm46586642449408"/><a data-type="indexterm" data-primary="command" data-secondary="overriding via path" id="idm46586642448704"/> by placing
a same-named command in an earlier directory in your search path, such
as your personal <em>$HOME/bin</em> directory.</p>
<div data-type="note" epub:type="note" class="pagebreak-after" id="search_path_aliases"><h1>Search Path and Aliases</h1>
<p>When the shell searches for a command by name, it checks if that name
is an alias before checking the search path.<a data-type="indexterm" data-primary="aliases" data-secondary="overriding search path" id="idm46586642445136"/><a data-type="indexterm" data-primary="search path" data-secondary="overriding with aliases" id="idm46586642444160"/> That’s why an alias can
shadow<a data-type="indexterm" data-primary="aliases" data-secondary="shadowing a command" id="idm46586642443088"/><a data-type="indexterm" data-primary="shadowing" id="idm46586642442144"/> (take precedence<a data-type="indexterm" data-primary="precedence" id="idm46586642441344"/> over) a command of the same name.</p>
</div>

<p>The search path is a great example of taking something mysterious
about Linux and showing it has an ordinary explanation. The shell
doesn’t pull commands out of thin air or locate them by magic. It
methodically examines directories in a list until it finds the
requested executable file.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Environments and Initialization Files, the Short Version"><div class="sect1" id="section_environments1">
<h1>Environments and Initialization Files, the Short Version</h1>

<p><a data-type="indexterm" data-primary="bash" data-secondary="configuration files" id="idm46586642438544"/><a data-type="indexterm" data-primary="configuration files" data-secondary="bash" id="idm46586642437568"/>
A running shell holds a bunch of important information in variables:
the search path, the current directory, your preferred text editor,
your customized shell prompt, and more. The variables of a running
shell are collectively called the shell’s <em>environment</em>.<a data-type="indexterm" data-primary="environment" data-secondary="shell" id="idm46586642436112"/><a data-type="indexterm" data-primary="shell" data-secondary="environment" id="idm46586642435104"/> When the
shell exits, its environment is destroyed.</p>

<p>It would be extremely tedious to define every shell’s environment by
hand. The solution is to define the environment once, in shell scripts
called <em>startup files<a data-type="indexterm" data-primary="startup files" id="idm46586642433072"/></em><a data-type="indexterm" data-primary="bash" data-secondary="configuration files" data-tertiary="startup files" id="idm46586642432336"/><a data-type="indexterm" data-primary="configuration files" data-secondary="bash" data-tertiary="startup files" id="idm46586642431152"/> and <em>initialization files<a data-type="indexterm" data-primary="initialization files" id="idm46586642429616"/></em>,<a data-type="indexterm" data-primary="bash" data-secondary="initialization files" id="idm46586642428880"/> and have every
shell execute these scripts on startup. The effect is that
certain information appears to be “global” or “known” to all of your
running shells.<a data-type="indexterm" data-primary="global-like behavior of environment variables" id="idm46586642427904"/><a data-type="indexterm" data-primary="environment variables" data-secondary="not global" id="idm46586642427232"/></p>

<p>I’ll dive into the gory details in <a data-type="xref" href="ch06.xhtml#section_bash_configs">“Configuring Your Environment”</a>. For now, I’ll
teach you about one initialization file so you can get through the next few
chapters. It’s located in your home directory and named <em>.bashrc</em><a data-type="indexterm" data-primary=".bashrc file" data-primary-sortas="bashrc" id="idm46586642424848"/>
(pronounced “dot bash R C”). Because its name begins with a dot, <code>ls</code>
doesn’t list it by default:</p>

<pre data-type="programlisting">$ <strong>ls $HOME</strong>
apple   banana   carrot
$ <strong>ls -a $HOME</strong>
.bashrc   apple   banana    carrot</pre>

<p>If <em>$HOME/.bashrc</em> doesn’t exist, create it with a text editor. Commands
you place in this file will execute automatically when a shell
starts up,<sup><a data-type="noteref" id="idm46586642420864-marker" href="ch02.xhtml#idm46586642420864">5</a></sup> so it’s a great place to define variables for
the shell’s environment, and other things important to the shell, such
as aliases. Here is a sample <em>.bashrc</em> file.  Lines beginning with
<code>#</code> are comments:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># Set the search path</code>
<code class="nv">PATH</code><code class="o">=</code><code class="nv">$HOME</code>/bin:/usr/local/bin:/usr/bin:/bin
<code class="c1"># Set the shell prompt</code>
<code class="nv">PS1</code><code class="o">=</code><code class="s1">'$ '</code>
<code class="c1"># Set your preferred text editor</code>
<code class="nv">EDITOR</code><code class="o">=</code>emacs
<code class="c1"># Start in my work directory</code>
<code class="nb">cd</code> <code class="nv">$HOME</code>/Work/Projects
<code class="c1"># Define an alias</code>
<code class="nb">alias</code> <code class="nv">g</code><code class="o">=</code>grep
<code class="c1"># Offer a hearty greeting</code>
<code class="nb">echo</code> <code class="s2">"Welcome to Linux, friend!"</code></pre>

<p>Any changes you make to <em>$HOME/.bashrc</em> do not affect any running shells,
only future shells. You can force a running shell to reread and execute
<em>$HOME/.bashrc</em> with either of the following commands:<a data-type="indexterm" data-primary="source command" id="idm46586642411888"/><a data-type="indexterm" data-primary=". (dot)" data-secondary="source command" id="idm46586642411280"/><a data-type="indexterm" data-primary="dot (.)" data-secondary="source command" id="idm46586642394976"/></p>

<pre data-type="programlisting">$ <strong>source $HOME/.bashrc</strong>                 <em>Uses the builtin "source" command</em>
$ <strong>. $HOME/.bashrc</strong>                      <em>Uses a dot</em></pre>

<p>This process is known as <em>sourcing</em><a data-type="indexterm" data-primary="source command" data-secondary="sourcing a file" id="idm46586642390992"/> the initialization file. If someone tells
you to “source your dot-bash-R-C file,” they mean run one of the
preceding commands.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>In real life, do not put all of your shell configuration in
<em>$HOME/.bashrc</em>.  Once you’ve read the details in
<a data-type="xref" href="ch06.xhtml#section_bash_configs">“Configuring Your Environment”</a>, examine your <em>$HOME/.bashrc</em> and move commands
to their proper files as needed.</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586642439744">
<h1>Summary</h1>

<p>I’ve covered only a tiny number of <code>bash</code> features and their most basic
uses. You’ll see many more in the chapters that follow, particularly
in <a data-type="xref" href="ch06.xhtml#ch_parent_child">Chapter 6</a>. For right now, your most important job is to
understand the following concepts:</p>

<ul>
<li>
<p>The shell exists and has important responsibilities.</p>
</li>
<li>
<p>The shell evaluates the command line before running any commands. <a data-type="indexterm" data-primary="evaluating expressions" id="idm46586642382160"/><a data-type="indexterm" data-primary="expressions" data-secondary="evaluating" id="idm46586642381456"/></p>
</li>
<li>
<p>Commands can redirect stdin, stdout, and stderr. <a data-type="indexterm" data-primary="redirection" data-secondary="shell overview" id="idm46586642379680"/></p>
</li>
<li>
<p>Quoting and escaping prevent special shell characters from being evaluated. <a data-type="indexterm" data-primary="quoting" id="idm46586642349120"/><a data-type="indexterm" data-primary="escaping" id="idm46586642348512"/></p>
</li>
<li>
<p>The shell locates programs using a search path<a data-type="indexterm" data-primary="search path" id="idm46586642347136"/> of directories.</p>
</li>
<li>
<p>You can change a shell’s default behavior by adding commands
to the file <em>$HOME/.bashrc</em>.</p>
</li>
</ul>

<p>The better you understand the division between the shell and the
programs it invokes, the more that the command line will make sense,
and the better you can predict what will happen before you press
Enter to run a command.<a data-type="indexterm" data-startref="shell" id="idm46586642344448"/></p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586652391888"><sup><a href="ch02.xhtml#idm46586652391888-marker">1</a></sup> That’s why the command <code>ls *</code><a data-type="indexterm" data-primary="filenames" data-secondary="pattern matching" data-tertiary="dot file behavior" id="idm46586652390944"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="filenames" data-tertiary="dot file behavior" id="idm46586652389696"/> doesn’t list filenames beginning with a dot, a.k.a. dot files.</p><p data-type="footnote" id="idm46586653823824"><sup><a href="ch02.xhtml#idm46586653823824-marker">2</a></sup> <code>bash</code> prevents infinite recursion<a data-type="indexterm" data-primary="aliases" data-secondary="recursion, preventing" id="idm46586656585712"/> by not expanding the second <code>less</code> as an alias.</p><p data-type="footnote" id="idm46586642464768"><sup><a href="ch02.xhtml#idm46586642464768-marker">3</a></sup> Some shells memorize (cache)<a data-type="indexterm" data-primary="search path" data-secondary="caching" id="idm46586642464208"/><a data-type="indexterm" data-primary="caching" data-secondary="program locations" id="idm46586642463232"/> the paths to programs as they’re located, cutting down on future searches.</p><p data-type="footnote" id="idm46586642454096"><sup><a href="ch02.xhtml#idm46586642454096-marker">4</a></sup> Notice that the command <code>type which</code> produces output, but the command <code>which type</code> does not.</p><p data-type="footnote" id="idm46586642420864"><sup><a href="ch02.xhtml#idm46586642420864-marker">5</a></sup> This statement is oversimplified; more details are in <a data-type="xref" href="ch06.xhtml#table_config">Table 6-1</a>.</p></div></div></section></div></body></html>