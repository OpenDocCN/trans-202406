- en: Chapter 11\. Creating and Managing Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux supports a lot of filesystems, more than any other operating system. Filesystems
    are essential to computing and do an astounding amount of work. A computer filesystem
    stores, organizes, and protects our data, and is under continual stress from being
    constantly in use. As Linux users we are fortunate to have many first-rate filesystems
    to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will learn about the command-line tools for creating and
    managing the following general-purpose filesystems, which are fully supported
    on Linux and well maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: Ext4, the Extended Filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XFS, the X File System; the X stands only for X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Btrfs, the b-tree filesystem, pronounced Butter FS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FAT16/32, File Allocation Table 16- and 32-bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: exFAT, Extended FAT, Microsoft’s newest 64-bit filesytem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not included in this chapter are Microsoft’s NTFS or Apple’s HFS/HFS+/APFS.
    Linux has good support for Microsoft’s NTFS, both read and write. To try it, look
    for *ntfs-3g* (NTFS third generation) packages.
  prefs: []
  type: TYPE_NORMAL
- en: Support for Apple’s HFS/HFS+/APFS is unreliable. To give it a test drive, look
    for packages with *hfs* or *apfs* in the names, and make sure the description
    specifies they are for Apple filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: There are many special-purpose filesystems, such as UBIFS and JFFS2 for CompactFlash
    devices; the compressed filesystem SquashFS, HDFS, CephFS, and GlusterFS for distributed
    computing; NFS for network file sharing; and many more. These could easily fill
    a large book by themselves and are not included here. They are freely available
    to try out and learn.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can use any storage device, such as a hard disk, USB flash drive,
    or SD card, it must be partitioned and formatted with a filesystem. Every filesystem
    must have its own disk partition. A partition can cover an entire disk, or a disk
    can be divided into multiple partitions. Each partition is like an independent
    disk, and each partition can have a different filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: A filesystem must be mounted, or attached, to the running filesystem before
    it is accessible. A filesystem needs a *mountpoint*, which is a directory created
    for that filesystem. This directory can be anywhere, though the traditional locations
    are */mnt* and */media*.
  prefs: []
  type: TYPE_NORMAL
- en: You may mount only one filesystem per mountpoint. If you mount a second filesystem,
    it overwrites the first filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: A filesystem can be set up to mount automatically at system startup, dynamically
    when you attach removable media, manually from the command line, or by clicking
    a button on your desktop or in your file manager. Most Linux distributions take
    good care of handling removable media. Plug in your USB device or optical disk,
    and Linux takes care of setting up the mountpoint and automounting it, or setting
    it up for you to mount it with the click of a button ([Figure 11-1](#fig-filesystem-icons-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Removable media buttons on XFCE desktop](Images/lcb2_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. Removable media buttons on Xfce desktop
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Ext4, XFS, Btrfs, and exFAT are *64-bit* filesystems. This means they support
    a 64-bit block addressing space, which enables much larger file and filesystem
    sizes than 32- and 16-bit filesystems. 64-bit computing has been around at least
    since the 1970s on supercomputers, then later on high-end business machines like
    IBM Power and Sun Microsystems UltraSPARC.
  prefs: []
  type: TYPE_NORMAL
- en: My first Windows 3.1/DOS PC, back in the mid-1990s, was a 16-bit system. Windows
    95 boasted of being the first 32-bit consumer operating system. The first 64-bit
    filesystems for x86 PCs started appearing in Linux around 2001\. See [Ext4 High
    Level Design](https://oreil.ly/kufyJ) in the Linux kernel documentation to see
    nice tables that lay this all out for us, comparing 32- and 64-bit filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: 64-bit filesystems are backward compatible with 32-bit applications. After all
    these years it is unlikely you will run into 32-bit apps, though if you do they
    will run on your modern Linux, provided that it supplies the necessary packages
    to set up a 32-bit environment.
  prefs: []
  type: TYPE_NORMAL
- en: Ext4 and XFS are *journaling* filesystems, and Btrfs is a *copy-on-write* (CoW)
    filesystem. Journaling and CoW keep your filesystems in consistent states even
    after a power failure or system crash. Filesystems are complex and busy, and an
    interruption affects more than just the files you are working on. Interruptions
    result in large numbers of files with incompleted tasks, and in the olden days
    this meant possibly losing your whole filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '*Ext4* is the most widely used filesystem on Linux and is the default on the
    majority of Linux distributions. It’s not exciting. It’s well tested, well supported,
    and does its job without drama. The Ext4 journal records changes until they are
    written to disk, providing protection from data loss in the event of an interruption.
    Ext4 filesystems can be resized, both larger and smaller.'
  prefs: []
  type: TYPE_NORMAL
- en: '*XFS* was originally a high-performance Unix 64-bit filesystem, ported to Linux
    in 2001\. XFS is a fast, efficient, reliable journaling filesystem suitable for
    systems from small personal machines and to multidisk datacenter setups. XFS can
    be resized larger, but not smaller.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Btrfs* is an advanced copy-on-write (CoW) filesystem that includes a batch
    of features not present in the other filesystems in this chapter, including snapshots;
    RAID 0, 1, and 10; and subvolumes. Subvolumes are wonderfully flexible, as they
    enable creating multiple filesystem roots on a single partition. CoW is a cool
    way of creating snapshots in a space-efficient way, where each snapshot contains
    only the changes from the previous snapshot. When you run into problems, you can
    roll back to an older known good snapshot. Btrfs resizes smaller and larger.'
  prefs: []
  type: TYPE_NORMAL
- en: '*FAT16/32* are the elderly Microsoft 16- and 32-bit filesystems. FAT32 is the
    most universal filesystem, supported by Microsoft Windows, Apple’s macOS, Linux,
    Unix, and DOS operating systems. Use FAT32 for easiest file sharing on portable
    media. It has one limitation that is a showstopper for some uses, and that is
    a maximum file size of 4 GB (on media with 4K blocks).'
  prefs: []
  type: TYPE_NORMAL
- en: '*exFAT* is the newest Microsoft 64-bit filesystem, a nice upgrade from FAT32.
    exFAT is a fast, lightweight filesystem for USB sticks and SD media, and supports
    much larger file and volume sizes than FAT32\. Wikipedia cites a 16 EiB maximum
    file size and 128 PiB maximum volume size. It does not have a journal or CoW.'
  prefs: []
  type: TYPE_NORMAL
- en: exFAT is troublesome for Linux users because it is a patented proprietary filesystem,
    which was not available to Linux as a native filesystem until 2020\. You need
    to worry about Linux compatibility only if you want to read and copy USB flash
    drives or SDXC cards formatted with exFAT to your Linux computer. For example,
    you want to use exFAT-formatted SDXC cards with your digital camera, or audio
    recording device.
  prefs: []
  type: TYPE_NORMAL
- en: To use exFAT with Linux you have two options. One is to use the *exfatprogs*,
    or *exfat-fuse* and *exfat-utils* packages, which are available on most distributions.
    exFAT FUSE was developed and is maintained outside of the US, making it immune
    to US patent laws. exFAT FUSE takes advantage of Filesystem in Userspace (FUSE),
    which enables unprivileged users to run filesystems in userspace. It is not as
    efficient as a filesystem properly integrated into the kernel, but it works, and
    you can read and write exFAT files. Some hardy souls try to use exFAT FUSE in
    shared partitions to share files with Windows and macOS. In theory this should
    work, though there are sometimes glitches related to how well a particular Windows
    or macOS release implements exFAT.
  prefs: []
  type: TYPE_NORMAL
- en: The other option is to wait a little while for native support. Microsoft released
    exFAT in 2006 and licensed it primarily to companies that make embedded systems
    and embedded media. But times change. Microsoft has become an open source contributor,
    and a member of the [Open Invention Network (OIN)](https://oreil.ly/AJepb). Microsoft
    released the exFAT specification in 2019\. Releasing the specification sidestepped
    licensing hassles with the existing exFAT code, and Linux kernel developers wasted
    no time writing new code. Native support for exFAT with this shiny new code is
    in Linux kernel 5.7\. This should find its way into your favorite distro soon;
    run *uname -r* to see your kernel version.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1 Listing Supported Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know what filesystems are installed on your Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Read */proc/filesystems* to see a list of installed filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See all those *nodev* entries? Those are all virtual filesystems that exist
    only in memory and are not attached to a physical device like */dev/sda1*. Systemd
    manages all of these virtual filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: The other filesystems, Ext4, XFS, and so on, are the filesystems we use on our
    storage devices to store, organize, and protect our data.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“sysfs, the filesystem for exporting kernel objects”](https://oreil.ly/QCMN7)
    is written for developers, but it has useful information for Linux users and admins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.2 Identifying Your Existing Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You do not know what filesystems are already on your system, or on a removable
    storage disk, and you need to know how to list them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *lsblk* command. You can list just the device names and filesystems
    with the *NAME* and *FSTYPE* options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Query a single disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a single partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is my favorite *lsblk* incantation. It shows all device names, filesystem
    types, filesystem sizes, percentage used, labels, and mountpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run *lsblk --help* to see a list of columns. There is quite a bit of useful
    information, such as PATH, LABEL, UUID, HOTPLUG, MODEL, SERIAL, and SIZE.
  prefs: []
  type: TYPE_NORMAL
- en: On some distros you may need root permissions to see the filesystem types, UUIDs,
    and labels.
  prefs: []
  type: TYPE_NORMAL
- en: '*lsblk* always prints *vfat* for both FAT16 and FAT32 filesystems. Use GParted
    or *parted* to see whether a filesystem is FAT16 or FAT32.'
  prefs: []
  type: TYPE_NORMAL
- en: '*vfat* is Virtual FAT, the kernel’s filesystem driver for FAT16 and FAT32.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Linux Kernel SCSI Interfaces Guide](https://oreil.ly/beFOx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Major and minor numbers for block and character devices](https://oreil.ly/NW2S7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 lsblk*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.xhtml#cha-partitioning-parted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.xhtml#cha-partitioning-gparted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.3 Resizing Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to enlarge or reduce the size of your filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every filesystem has its own commands for resizing. See Recipes [8.8](ch08.xhtml#rec-resize-partition-fs),
    [8.9](ch08.xhtml#rec-shrink-partition), and [9.7](ch09.xhtml#rec-resize-partitions-gparted)
    to learn about resizing filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The filesystem’s partition must also be resized to match. GParted does this
    in a single operation (see [Recipe 9.7](ch09.xhtml#rec-resize-partitions-gparted)).
  prefs: []
  type: TYPE_NORMAL
- en: Recipes [8.8](ch08.xhtml#rec-resize-partition-fs) and [8.9](ch08.xhtml#rec-shrink-partition)
    use *parted* and filesystem utilities to resize a filesystem and its partition
    in two steps.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 8.8](ch08.xhtml#rec-resize-partition-fs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 8.9](ch08.xhtml#rec-shrink-partition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 9.7](ch09.xhtml#rec-resize-partitions-gparted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 resize2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 xfs_growfs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 btrfs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 fsck.vfat*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.4 Deleting Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to delete a filesystem and its underlying partition.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete the filesystem and its partition, use *parted*. In this example,
    */dev/sdb1* is deleted. Verify which partition and filesystem you are going to
    delete, then make sure the filesystem is unmounted. In the example, the mountpoint
    is */media/duchess/stuff*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use *parted* to delete the partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer a graphical tool, use GParted ([Chapter 9](ch09.xhtml#cha-partitioning-gparted)).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes, the command is *umount*, not *unmount*. *umount* dates from the ancient
    Unix era, when identifiers had a limit of six characters.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting all the files in a partition does not delete the filesystem. The filesystem
    structure remains in place.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 dd*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.5 Using a New Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You just created a nice new filesystem, and you need to mount it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating your new filesystem, you must create a mountpoint, and optionally
    configure automatic mounting. As discussed in the introduction to this chapter,
    a new filesystem must be mounted, or attached, to the running filesystem to be
    usable.
  prefs: []
  type: TYPE_NORMAL
- en: Ext4, XFS, and Btrfs all have access controls. If you want the files on these
    filesystems available to anyone other than the root user, you must adjust ownership
    and permissions. FAT16/32 and exFAT do not have access controls and are wide open
    to anyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by mounting your new filesystem. Create a mountpoint, which is a directory,
    and then mount the filesystem, like this example for Mad Max:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example sets the ownership of the new filesystem to Mad Max,
    read-write-execute, with read-only permissions for group and world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now Mad Max can access the new filesystem. This mount only lasts until the next
    system restart; see [Recipe 11.6](#rec-automatic-fs-mount) to learn how to configure
    automatic filesystem mounts.
  prefs: []
  type: TYPE_NORMAL
- en: Only One Filesystem per Mountpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every filesystem needs its own unique mountpoint; you cannot put multiple filesystems
    on a single mountpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Chapter 6](ch06.xhtml#cha-files-directories) for detailed recipes on managing
    ownership and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional directories that contain mountpoints are */mnt* and */media*.
    */mnt* is traditionally for static mounts (configured in */etc/fstab*), and */media*
    is for automounting removable media. You may create your mountpoints wherever
    you want. The advantage of using the traditional directories is having your mountpoints
    in a limited number of predictable locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'A shared directory with mountpoints for multiple users could look like this,
    with a directory for each user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then every filesystem needs its own mountpoint in the user subdirectories.
    For example, Mad Max has two filesystems mounted at *madmax1* and *madmax2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The mountpoints can have any names you want. For example, Mad Max’s mountpoints
    could be *fs1* and *fs2*, or *fred* and *ethel*, or *max1* and *max2*, whatever
    helps you remember what they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the *stat* command to see the permissions on a filesystem, like this example
    for Mad Max’s new filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'List all filesystem mounts with *mount*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the *mountpoint* command to learn if a directory is a mountpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 1 chown*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 chmod*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 1 stat*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.6 Creating Automatic Filesystem Mounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have added a new filesystem, and you want it to automatically mount at system
    startup.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is what your */etc/fstab* file is for. The following example is added
    to the existing */etc/fstab* file to create a static mount for the filesystem
    in [Recipe 11.5](#rec-filesystem-temp-mount), and it will be automatically mounted
    at startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the *findmnt* command to test your new configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The warning “recommended root FS passno is 1 (current is 0)” is not significant.
    If that is the only warning, and there are no errors, reboot to test, or run the
    following command to mount your new */etc/fstab* entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is what the six *fstab* columns are for:'
  prefs: []
  type: TYPE_NORMAL
- en: device
  prefs: []
  type: TYPE_NORMAL
- en: The UUID or filesystem LABEL. Don’t use */dev* names because they are not unique,
    and sometimes they change. Run *lsblk -o UUID,LABEL* to list UUIDs and filesystem
    labels to use in the *device:* column.
  prefs: []
  type: TYPE_NORMAL
- en: mountpoint
  prefs: []
  type: TYPE_NORMAL
- en: The directory you created for the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: type
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem type, for example, *xfs*, *ext4*, or *btrfs*. You may use *auto*
    for the filesystem type, and the kernel will automatically detect the filesystem
    type.
  prefs: []
  type: TYPE_NORMAL
- en: options
  prefs: []
  type: TYPE_NORMAL
- en: Your mount options in a comma-delimited list (see below for a list).
  prefs: []
  type: TYPE_NORMAL
- en: dump
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the *dump* command for backups, this tells *dump* the backup
    interval, in days. So, 1 means every day, 2 means every other day, 3 is every
    third day, and so on. Most likely you are not using *dump* and should enter 0.
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: This tells the filesystem checker which filesystem to check first at bootup,
    if it ever needs to. Make your root filesystem 1, any other Linux filesystems
    2, and non-Linux filesystems 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following *options* define permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: defaults
  prefs: []
  type: TYPE_NORMAL
- en: The default options are *rw*, *suid*, *dev*, *exec*, *auto*, *nouser*, and *async*.
    The *defaults* values are overridden by appending additional options, for example
    *defaults,user* gives the user permission to mount and unmount the filesystem.
    You may append as many options as you like, or omit *defaults* and list only the
    options you want.
  prefs: []
  type: TYPE_NORMAL
- en: rw
  prefs: []
  type: TYPE_NORMAL
- en: Read/write.
  prefs: []
  type: TYPE_NORMAL
- en: ro
  prefs: []
  type: TYPE_NORMAL
- en: Read-only.
  prefs: []
  type: TYPE_NORMAL
- en: suid
  prefs: []
  type: TYPE_NORMAL
- en: Allow setuid and setgid bits to operate.
  prefs: []
  type: TYPE_NORMAL
- en: dev
  prefs: []
  type: TYPE_NORMAL
- en: Interpret block and character devices.
  prefs: []
  type: TYPE_NORMAL
- en: exec
  prefs: []
  type: TYPE_NORMAL
- en: Allow binaries to run.
  prefs: []
  type: TYPE_NORMAL
- en: auto
  prefs: []
  type: TYPE_NORMAL
- en: Indicates which filesystems should start at boot.
  prefs: []
  type: TYPE_NORMAL
- en: nouser
  prefs: []
  type: TYPE_NORMAL
- en: Nonroot users cannot mount or unmount the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: async
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous I/O, which is standard for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: user
  prefs: []
  type: TYPE_NORMAL
- en: Nonroot users can mount and unmount the device, if they mounted it.
  prefs: []
  type: TYPE_NORMAL
- en: users
  prefs: []
  type: TYPE_NORMAL
- en: Any user can mount and unmount the device.
  prefs: []
  type: TYPE_NORMAL
- en: noauto
  prefs: []
  type: TYPE_NORMAL
- en: Do not automatically mount at boot.
  prefs: []
  type: TYPE_NORMAL
- en: ro
  prefs: []
  type: TYPE_NORMAL
- en: Mount the filesystem read-only.
  prefs: []
  type: TYPE_NORMAL
- en: noatime
  prefs: []
  type: TYPE_NORMAL
- en: Do not update the “time accessed” file attribute. *noatime* was used in times
    past to speed up performance. If you are on a modern computer, it probably won’t
    make much difference.
  prefs: []
  type: TYPE_NORMAL
- en: gid
  prefs: []
  type: TYPE_NORMAL
- en: Limit access to a group (from */etc/group*); for example, *gid=group1*.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 mount*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 5 fstab*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[systemd](https://systemd.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.7 Creating Ext4 Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a new Ext4 filesystem on an internal or external storage
    disk.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start with a partition of the size you want for your filesystem. Then use the
    *mkfs.ext4* command to create the new Ext4 filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example overwrites an existing XFS filesystem with a new Ext4
    filesystem. When you overwrite an existing filesystem, it must first be unmounted.
    In this example, the filesystem on */dev/sdb1* is mounted at */media/duchess/stuff*,
    which you can see with the *df* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You may need root permissions to unmount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the new Ext4 filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You could also create a new partition and put your new filesystem on it; see
    the examples for creating new partitions in Recipes [8.4](ch08.xhtml#rec-create-gpt)
    and [9.4](ch09.xhtml#rec-new-partition-gparted).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overwriting a filesystem destroys all the data on it.
  prefs: []
  type: TYPE_NORMAL
- en: The *-L* option is for creating a volume label. This can be anything you want,
    up to 16 characters (FAT32 is limited to 11 characters). It is not required, though
    filesystem labels are useful, and for some operations, such as in */etc/fstab*,
    can be used in place of the long UUID.
  prefs: []
  type: TYPE_NORMAL
- en: The *-n* option does a dry run, so you see what will happen without actually
    creating the new filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '*mke2fs* has numerous options, but you will likely use just a few of them:
    device name, volume label, dry-run, and creating an external journal. Its defaults
    are set in */etc/mke2fs.conf*, and I suggest not changing them without thorough
    study of the available settings.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 mke2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 8.4](ch08.xhtml#rec-create-gpt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 11.5](#rec-filesystem-temp-mount)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.8 Configuring the Ext4 Journal Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know that the default journal mode for ext4 is *data=ordered*, which does
    not journal data, but only metadata. It is a good balance of safety and speed,
    but you want to set it to *data=journal*, which is the safest.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *tune2fs* command. First check your existing journal mode with *dmesg*.
    The filesystem must be mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That confirms */dev/sdb1* is formatted as Ext4 and has the default *data=ordered*
    journal mode. Now change it to *data=journal* mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Unmount and remount, and check again with *dmesg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see multiple lines with conflicting information, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Reboot, and then you should see only the “mounted filesystem with journalled
    data mode” line.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The journal mode command options are named differently, depending on what documentation
    you are reading. In *man 8 tune2fs*, the following options are listed:'
  prefs: []
  type: TYPE_NORMAL
- en: journal_data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: journal_data_ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: journal_data_writeback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the kernel documentation, and a whole lot of how-tos, these are the options:'
  prefs: []
  type: TYPE_NORMAL
- en: data=journal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data=ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data=writeback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *data=* options are meant to be passed to the kernel at boot either in your
    bootloader configuration, or in */etc/fstab*. I favor using *tune2fs* because
    it is fast and easy, and works on all Ext4 filesystems regardless of their mount
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the journal modes in order of data safety:'
  prefs: []
  type: TYPE_NORMAL
- en: data=journal
  prefs: []
  type: TYPE_NORMAL
- en: Provides the most protection for your data. All data and metadata are first
    written to the journal, and then written to the filesystem. In the event of a
    failure, this gives you the best chance of recovering your data. This is also
    the most resource intensive, as your changes are written twice.
  prefs: []
  type: TYPE_NORMAL
- en: data=ordered
  prefs: []
  type: TYPE_NORMAL
- en: This does not write your data to the journal. Data is first written to the filesystem,
    and then metadata is written to the journal. The metadata is logically grouped
    in order and held in a single transaction. When the metadata is written to disk,
    its associated data blocks are written first.
  prefs: []
  type: TYPE_NORMAL
- en: data=writeback
  prefs: []
  type: TYPE_NORMAL
- en: This is the fastest and the least safe. Data is first written to the filesystem,
    and then metadata is written to the journal. Data ordering is not preserved. I
    don’t think the small performance gain is worth the extra risk.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 tune2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kernel documentation for the Ext4 filesystem](https://oreil.ly/Y4ajq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.9 Finding Which Journal Your Ext4 Filesystem Is Attached To
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have several Ext4 filesystems, some with internal journals and some with
    external journals, and you want to know which journals they are using.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Meet a new command, *dumpe2fs*. This is a part of the *e2fsprogs* suite of
    ext2/3/4 utilities. Query your Ext4 filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The *Journal UUID* belongs to the journal. Run *lsblk* to verify details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And there it is. An Ext4 filesystem using an internal journal looks like this,
    without the Journal UUID line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is always a way to find out where things are in Linux. The *dumpe2fs*
    command shows a lot of useful information about your Ext4 filesystems, including
    UUIDs, filesystem creation time, block count, free blocks, journal size, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 dumpe2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.10 Improving Performance with an External Journal for Ext4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have heard that placing the Ext4 journal on a different disk than the filesystem
    improves performance, and you want to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An external journal improves performance when your journal mode is *data=journal*.
    (See the Discussion for more information on journal modes.) You may create a new
    Ext4 filesystem and external journal, or convert an existing filesystem to use
    an external journal.
  prefs: []
  type: TYPE_NORMAL
- en: The two disks must be on the same machine and have similar read and write speeds.
    If the journal disk is slower than the filesystem disk, you will not see much,
    if any, of a performance gain. You could use two similar solid-state disks (SSDs),
    two similar hard disk drives (HDDs), or use a small SSD for the journal and a
    large HDD for the filesystem, because SSDs are much faster than HDDs.
  prefs: []
  type: TYPE_NORMAL
- en: Locating the Ext4 journal on a separate disk takes several steps. In the following
    example, we will create two new partitions, one for the journal and one for the
    new Ext4 filesystem. Then create the journal, then the filesystem, and attach
    it to the journal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first partition is for the journal on */dev/sdb5*, 200 GB in size, and
    the second partition is for the Ext4 filesystem on */dev/sda1*, 500 GB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The external journal and the filesystem must have the same block size, which
    is specified in the following example with *-b 4096*. If you don’t know the block
    size, find it with *tune2fs*. The following commands are run in the Bash shell,
    and not in the *parted* shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the journal, which can take a few minutes, and then the new filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You’re finished and can use your new filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can attach an external journal to an existing filesystem with the *tune2fs*
    command. First clear the journal on the existing filesystem, then link the filesystem
    to the external journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Ext4 journal provides extra protection for your data, in the event of a
    disk or system failure, by tracking changes that are not yet written to disk.
    Even if it loses your most recent changes, it protects the filesystem from being
    corrupted, so you lose just a little bit instead of the whole works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving the journal to a separate disk on the same machine provides a noticeable
    performance boost when the journal mode is *data=journal*. Ext4 has three journaling
    modes: *journal*, *ordered*, and *writeback*. The default is *ordered*. See [Recipe
    11.8](#rec-journal-mode) to learn about these modes and how to select the one
    you want to use.'
  prefs: []
  type: TYPE_NORMAL
- en: The caret, *^*, disables a feature. In the example in the recipe, it clears
    the existing internal journal.
  prefs: []
  type: TYPE_NORMAL
- en: Ext4 journals cannot be shared, and can be used by only one filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 mke2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 tune2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.xhtml#cha-partitioning-parted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.xhtml#cha-partitioning-gparted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.11 Freeing Space from Reserved Blocks on Ext4 Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most Linux distributions reserve 5% of Ext4 filesystems for the root user and
    system services. On large modern hard disks that is a lot of space, and you want
    to free some of that space.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *tune2fs* command to adjust the size of the free space on an Ext4 filesystem.
    You may configure it by percentage, like this example that reduces it to 1%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That is still about 3 gigabytes, with 4K blocks (820,474 x 4,096 = 3,360,661,504
    bytes). Find your block size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set a fractional percentage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'That is roughly 800 MB. Or, specify a number of blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '250,000 4K blocks is about a gigabyte. Check your work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you run out of disk space, you can still log in as root and free up space,
    which you could not do if that 5% was not held in reserve. However, that 5% is
    a holdover from the days of megabyte hard disks. Hard disks are so large now,
    you don’t need all that reserved space. For example, 5% of a 1 TB disk is about
    50 GB. Only a few hundred megabytes of reserved space is necessary. I set mine
    to a gigabyte. It’s easy to remember and provides more than enough room.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the *dumpe2fs* command to check out the reserved blocks settings in your
    Ext4 filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 dumpe2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 tune2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.12 Creating a New XFS Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You like XFS, and want to create a new XFS filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need the *xfsprogs* package installed on your system and a partition for
    the new filesystem. Then create your new XFS filesystem with *mkfs.xfs*. The following
    example, on Ubuntu, demonstrates all these steps. The example new partition is
    */dev/sda1*, and the new filesystem gets an *xfstest* label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Check your work with *lsblk*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Mount your new filesystem, adjust ownership and permissions, and it’s ready
    to use. The following example mounts it on */mnt/xfstest*, sets ownership to Duchess,
    read-write for Duchess and read only for everyone else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command output from creating a new XFS filesystem contains a few helpful
    items, like the block size, number of blocks, and sector size.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 mkfs.xfs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.13 Resizing an XFS Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to resize an XFS filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can only increase the size of an XFS filesystem. If you need it to be smaller,
    you must copy your data to a safe location, create a smaller partition, format
    it as XFS, then restore your data.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the size is less work. You need free space at the end of the partition
    that your XFS filesystem is on. In the following examples, the new endpoint for
    the partition is 2700 GB, and the filesystem is mounted at */media/duchess/xfs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch *parted*. Print the partition information to verify the correct partition
    and endpoint, increase the partition size, then quit *parted*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, expand the filesystem to match the new partition size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You’re done! Enjoy your new larger filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You also have the option to unmount the filesystem and resize it offline. This
    is a little safer.
  prefs: []
  type: TYPE_NORMAL
- en: Using GParted to resize a filesystem is fast and easy; see [Recipe 9.7](ch09.xhtml#rec-resize-partitions-gparted).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 8.8](ch08.xhtml#rec-resize-partition-fs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Recipe 9.7](ch09.xhtml#rec-resize-partitions-gparted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.14 Creating an exFAT Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your digital camera flash drive is formatted with the exFAT filesystem, or you
    have other flash storage devices that use exFAT, and you want to read, write,
    and edit the files from these devices on your Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two possible solutions: one is to use the exFAT implementation that
    runs on Filesystem in Userspace (FUSE). The other solution is to use the native
    implementation that runs in the Linux kernel, rather than userspace. In this recipe
    we will use exFAT FUSE because at the time this was written the native implementation
    had not yet made it into most distribution releases. Look for kernel version 5.7,
    and check your distribution release notes and news. (Run the *uname -r* command
    to see your kernel version.)'
  prefs: []
  type: TYPE_NORMAL
- en: The exFAT package names vary. *exfat-fuse* and *exfat-utils* are the older packages.
    *exfatprogs* is the newest implementation, replacing both *exfat-fuse* and *exfat-utils*.
    Whatever you have, go ahead and install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to create a new exFAT filesystem is the same for both. The following
    example formats */dev/sdc1* as exFAT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'exFAT is designed to be simple, so there are not a lot of options. You can
    give it a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify your changes with *lsblk*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You do not need a special exFAT partition to read exFAT files on other devices,
    but only exFAT installed on your Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer a graphical partitioning tool, GParted does not support exFAT,
    due to legal concerns. GNOME Disks, called Disks in most GNOME implementations,
    does support exFAT. You do not have to install GNOME to get Disks; look for the
    *gnome-disk-utility* package.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft released the exFAT specification in 2019\. Samsung wrote *exfatprogs*
    and released it in early 2020\. By the time you read this, the latest releases
    of Fedora, Ubuntu, and openSUSE Tumbleweed should have native exFAT support.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 exfat*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 exfatlabel*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.15 Creating FAT16 and FAT32 Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know how to create FAT16 and FAT32 filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need the *dosfstools* package, which is installed by default on most Linuxes.
    The following examples demonstrate creating a new 500 MB partition with *parted*,
    then formatting the partition with FAT32.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the new partition, and note how to change the measurement units to MB,
    and how to use *mkpart* interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The *partition* name is optional; in the example it is left empty. Now create
    a nice new FAT32 filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify with *lsblk*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want a FAT16 filesystem, use *-F 16*.
  prefs: []
  type: TYPE_NORMAL
- en: FAT16 files and filesystems max out at 4 GB.
  prefs: []
  type: TYPE_NORMAL
- en: FAT32 supports a maximum file size of 4 GB, and a maximum partition size of
    16 TB, using 4 KB sectors and 64 KB clusters.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.xhtml#cha-partitioning-parted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.xhtml#cha-partitioning-gparted)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 mkfs.fat*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.16 Creating a Btrfs Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Btrfs sounds cool, and you want to try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is cool, and it is also complex. SUSE Linux Enterprise Server (SLES) and
    openSUSE are the best Linux distributions to try Btrfs on. SLES and openSUSE are
    the biggest Btrfs supporters and developers, and they created the excellent Snapper
    tool for managing Btrfs snapshots. They also provide the most thorough documentation.
    The default partitioning on an openSUSE/SLES sets up Btrfs subvolumes and automatic
    snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Start by downloading the latest openSUSE Tumbleweed. Launch the installer, and
    when you get to the Suggested Partitioning screen, take a look at the installer’s
    first proposal ([Figure 11-2](#fig-btrfs-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![openSUSE first partitioning proposal](Images/lcb2_1102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. openSUSE first partitioning proposal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click Guided Setup to modify this proposal. Skip past the “Enable logical volume
    management (LVM) / Enable disk encryption” screen, and stop at the Filesystem
    Options screen. Select “Propose Separate Home Partition,” and format it as Btrfs.
    Check both boxes for “Propose Separate Swap Partition,” then click Next ([Figure 11-3](#fig-btrfs-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Create home partition](Images/lcb2_1103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3\. Create a home partition
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This returns you to the Suggested Partitioning screen. If you wish to adjust
    partition sizes, click Expert Partitioner → Start with Current Proposal ([Figure 11-4](#fig-btrfs-4)).
    Otherwise click Next and continue with the installation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom partitioning, using current proposal](Images/lcb2_1104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-4\. Custom partitioning, using current proposal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you are finished, you will have a ready-to-use Btrfs Linux system, already
    set up with good defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up Btrfs manually is a bit of a chore, though as you learn about it
    you might want to try setting it up manually. I like to learn new things by starting
    with a working implementation. It is not possible, at least for me, to provide
    a useful Btrfs how-to in a few recipes. Btrfs is so flexible and so capable, it
    needs its own book. Which it has, thanks to the good SUSE people. Consult the
    Startup Guide for installation, and the “System Recovery and Snapshot Management
    with Snapper” section in the [openSUSE documentation](https://oreil.ly/1Vi9L).
    Snapper + Btrfs is a great combination for Btrfs management and fast failure recovery.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The openSUSE Startup and Reference Guides](https://oreil.ly/1Vi9L)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Deployment and Administration guides in the [SLES Product Manuals](https://oreil.ly/fX5G9)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
