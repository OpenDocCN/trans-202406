<html><head></head><body><section data-pdf-bookmark="Chapter 3. The Type System" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch03">&#13;
<h1><span class="label">Chapter 3. </span>The Type System</h1>&#13;
&#13;
&#13;
<p><a data-primary="type system" data-type="indexterm" id="id519"/>In the previous chapter you learned about the basic building blocks that allow you to make your JavaScript code more expressive. But if you are experienced in JavaScript, you understand that TypeScript’s fundamental types and annotations cover only a small set of its inherent flexibility.</p>&#13;
&#13;
<p>TypeScript is supposed to make intentions in JavaScript clearer, and it wants to do so without sacrificing this flexibility, especially since it allowed developers to design fantastic APIs used and loved by millions. Think of TypeScript more as a way to formalize JavaScript, rather than restrict it. Enter TypeScript’s type system.</p>&#13;
&#13;
<p>In this chapter, you will develop a mental model for how to think about types. You will learn how to define sets of values as widely or as narrowly as you need, and how to change their scope throughout your control flow. You will also learn how to leverage a structural type system and when to break with the rules.</p>&#13;
&#13;
<p>This chapter marks the line between TypeScript foundations and advanced type techniques. But whether you are an experienced TypeScript developer or just starting out, this mental model will be the baseline for everything to come.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.1 Modeling Data with Union and Intersection Types" data-type="sect1"><div class="sect1" id="ch03_item_modelling_data">&#13;
<h1>3.1 Modeling Data with Union and Intersection Types</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id43">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="data modeling" data-type="indexterm" id="ix_0103-asciidoc0"/><a data-primary="type system" data-secondary="data modeling with union and intersection types" data-type="indexterm" id="ix_0103-asciidoc1"/><a data-primary="union types" data-secondary="data modeling with" data-type="indexterm" id="ix_0103-asciidoc2"/>You have an elaborate data model you want to describe in TypeScript.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id520">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use union and intersection types to model your data. Use literal types to define &#13;
<span class="keep-together">specific variants.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id44">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Suppose you are creating a data model for a toy shop. Each item in this toy shop has some basic properties: name, quantity, and the recommended minimum age. Additional properties are relevant only for each particular type of toy, which requires you to create several derivations:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">BoardGame</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">price</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">quantity</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">minimumAge</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">players</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Puzzle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">price</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">quantity</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">minimumAge</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">pieces</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Doll</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">price</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">quantity</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">minimumAge</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">material</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>For the functions you create, you need a type that is representative of all toys, a supertype that contains just the basic properties common to all toys:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ToyBase</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">price</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">quantity</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">minimumAge</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printToy</code><code class="p">(</code><code class="nx">toy</code><code class="o">:</code> <code class="nx">ToyBase</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="cm">/* ... */</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">doll</code><code class="o">:</code> <code class="nx">Doll</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Mickey Mouse"</code><code class="p">,</code>&#13;
  <code class="nx">price</code><code class="o">:</code> <code class="mf">9.99</code><code class="p">,</code>&#13;
  <code class="nx">quantity</code><code class="o">:</code> <code class="mi">10000</code><code class="p">,</code>&#13;
  <code class="nx">minimumAge</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">material</code><code class="o">:</code> <code class="s2">"plush"</code><code class="p">,</code>&#13;
&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">printToy</code><code class="p">(</code><code class="nx">doll</code><code class="p">);</code> <code class="c1">// works</code></pre>&#13;
&#13;
<p>This works, as you can print all dolls, board games, or puzzles with that function, but there’s one caveat: you lose the information of the original toy within <code>printToy</code>. You can print only common properties, not specific ones.</p>&#13;
&#13;
<p><a data-primary="union types" data-secondary="defined" data-type="indexterm" id="id521"/>For a type representing all possible toys, you can create a <em>union type</em>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Union Toy</code>&#13;
<code class="kr">type</code> <code class="nx">Toy</code> <code class="o">=</code> <code class="nx">Doll</code> <code class="o">|</code> <code class="nx">BoardGame</code> <code class="o">|</code> <code class="nx">Puzzle</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printToy</code><code class="p">(</code><code class="nx">toy</code><code class="o">:</code> <code class="nx">Toy</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="cm">/* ... */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A good way to think of a type is as a set of compatible values. For each value, either annotated or not, TypeScript checks if this value is compatible with a certain type. For objects, this also includes values with more properties than defined in their type. Through inference, values with more properties are assigned a subtype in the structural type system. And values of subtypes are also part of the supertype set.</p>&#13;
&#13;
<p>A union type is a union of sets. The number of compatible values gets broader, and there is also some overlap between types. For example, an object that has both &#13;
<span class="keep-together"><code>material</code></span> and <code>players</code> can be compatible with both <code>Doll</code> and <code>BoardGame</code>. This is a detail to look out for, and you can see a method to work with that detail in <a data-type="xref" href="#ch03_item_discriminated_unions">Recipe 3.2</a>.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-union">Figure 3-1</a> illustrates the concept of a union type in the form of a Venn diagram. Set theory analogies work well here, too.</p>&#13;
&#13;
<figure><div class="figure" id="img-union">&#13;
<img alt="tscb 0301" src="assets/tscb_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>Visualization of a union type; each type represents a set of compatible values, and a union type represents the union sets</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">You can create union types everywhere, and with primitive types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">takesNumberOrString</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="cm">/* ... */</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">takesNumberOrString</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code> <code class="c1">// ok</code>&#13;
<code class="nx">takesNumberOrString</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">);</code> <code class="c1">// ok</code></pre>&#13;
&#13;
<p>This allows you to widen the set of values as much as you like.</p>&#13;
&#13;
<p><a data-primary="intersection types" data-secondary="data modeling with" data-type="indexterm" id="ix_0103-asciidoc3"/>What you also see in the toy shop example is some redundancy: the <code>ToyBase</code> properties are repeated. It would be much nicer if we could use <code>ToyBase</code> as the basis of each union part. And we can, using intersection types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ToyBase</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">price</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">quantity</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">minimumAge</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// Intersection of ToyBase and { players: number }</code>&#13;
<code class="kr">type</code> <code class="nx">BoardGame</code> <code class="o">=</code> <code class="nx">ToyBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">players</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// Intersection of ToyBase and { pieces: number }</code>&#13;
<code class="kr">type</code> <code class="nx">Puzzle</code> <code class="o">=</code> <code class="nx">ToyBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">pieces</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// Intersection of ToyBase and { material: string }</code>&#13;
<code class="kr">type</code> <code class="nx">Doll</code> <code class="o">=</code> <code class="nx">ToyBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">material</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p><a data-primary="intersection types" data-secondary="defined" data-type="indexterm" id="id522"/>Just like union types, <em>intersection types</em> resemble their counterparts from set theory. They tell TypeScript that compatible values need to be of type <code>A</code> <em>and</em> type <code>B</code>. The type now accepts a narrower set of values, one that includes all properties from both types, including their subtypes. <a data-type="xref" href="#img-intersection">Figure 3-2</a> shows a visualization of an intersection type.</p>&#13;
&#13;
<p>Intersection types also work on primitive types, but they are of no good use. An intersection of <code>string &amp; number</code> results in <code>never</code>, as no value satisfies both <code>string</code> and <code>number</code> properties.</p>&#13;
&#13;
<figure><div class="figure" id="img-intersection">&#13;
<img alt="tscb 0302" src="assets/tscb_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>Visualization of an intersection type of two types; the set of possible values gets narrower</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Instead of type aliases and intersection types you can also define your models with interfaces. In <a data-type="xref" href="ch02.html#ch02_item_interfaces_vs_types">Recipe 2.5</a> we talk about the differences between them, and there are a few you need to look out for. So a <code>type BoardGame = ToyBase &amp; { /* ... */ }</code> can easily be described as <code>interface BoardGame extends ToyBase { /* ... */ }</code>. However, you can’t define an interface that is a union type. You can define a union of interfaces, though.<a data-startref="ix_0103-asciidoc3" data-type="indexterm" id="id523"/></p>&#13;
</div>&#13;
&#13;
<p>These are already great ways to model data within TypeScript, but we can do a little more. In <a data-primary="literal types" data-seealso="string template literal types" data-type="indexterm" id="id524"/>TypeScript, literal values can be represented as a literal type. We can define a type that is just, for example, the number 1, and the only compatible value is <code>1</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">One</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">one</code><code class="o">:</code> <code class="nx">One</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="c1">// nothing else can be assigned.</code></pre>&#13;
&#13;
<p>This is called a <em>literal type</em>, and while it doesn’t seem to be quite useful alone, it is of great use when you combine multiple literal types to a union. For the <code>Doll</code> type, for example, we can explicitly set allowed values for <code>material</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Doll</code> <code class="o">=</code> <code class="nx">ToyBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">material</code><code class="o">:</code> <code class="s2">"plush"</code> <code class="o">|</code> <code class="s2">"plastic"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">checkDoll</code><code class="p">(</code><code class="nx">doll</code><code class="o">:</code> <code class="nx">Doll</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">doll</code><code class="p">.</code><code class="nx">material</code> <code class="o">===</code> <code class="s2">"plush"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// do something with plush</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="c1">// doll.material is "plastic", there are no other options</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This makes assigning any value other than <code>"plush"</code> or <code>"plastic"</code> impossible and makes our code much more robust.</p>&#13;
&#13;
<p>With union types, intersection types, and literal types, it becomes much easier to define even elaborate models.<a data-startref="ix_0103-asciidoc2" data-type="indexterm" id="id525"/><a data-startref="ix_0103-asciidoc1" data-type="indexterm" id="id526"/><a data-startref="ix_0103-asciidoc0" data-type="indexterm" id="id527"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.2 Explicitly Defining Models with &#10;Discriminated Union Types" data-type="sect1"><div class="sect1" id="ch03_item_discriminated_unions">&#13;
<h1>3.2 Explicitly Defining Models with &#13;
<span class="keep-together">Discriminated Union Types</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id45">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="discriminated union types" data-type="indexterm" id="ix_0203-asciidoc0"/><a data-primary="type system" data-secondary="explicitly defining models with discriminated union types" data-type="indexterm" id="ix_0203-asciidoc1"/><a data-primary="union types" data-secondary="explicitly defining models with discriminated union types" data-type="indexterm" id="ix_0203-asciidoc2"/>Parts of your modeled union type have a huge overlap in their properties, so it becomes cumbersome to distinguish them in control flow.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id528">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Add a <code>kind</code> property to each union part with a string literal type, and check for its contents.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id46">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Let’s look at a data model similar to what we created in <a data-type="xref" href="#ch03_item_modelling_data">Recipe 3.1</a>. This time, we want to define various shapes for a graphics software:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Square</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Triangle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Circle</code> <code class="o">|</code> <code class="nx">Triangle</code> <code class="o">|</code> <code class="nx">Square</code><code class="p">;</code></pre>&#13;
&#13;
<p>There are some similarities between the types but there is also still enough information to differentiate between them in an <code>area</code> function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">area</code><code class="p">(</code><code class="nx">shape</code><code class="o">:</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="s2">"radius"</code> <code class="k">in</code> <code class="nx">shape</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// shape is Circle</code>&#13;
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="s2">"y"</code> <code class="k">in</code> <code class="nx">shape</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// shape is Triangle</code>&#13;
    <code class="k">return</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">y</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="c1">// shape is Square</code>&#13;
    <code class="k">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This works, but it comes with a few caveats. While <code>Circle</code> is the only type with a <code>radius</code> property, <code>Triangle</code> and <code>Square</code> share the <code>x</code> property. Since <code>Square</code> consists only of the <code>x</code> property, this makes <code>Triangle</code> a subtype of <code>Square</code>.</p>&#13;
&#13;
<p>Given how we defined the control flow to check for the distinguishing subtype property <code>y</code> first, this is not an issue, but it’s just too easy to check for <code>x</code> alone and create a branch in the control flow that computes the area for both <code>Triangle</code> and <code>Square</code> in the same manner, which is just wrong.</p>&#13;
&#13;
<p>It is also hard to extend <code>Shape</code>. If we look at the required properties for a rectangle, we see that it contains the same properties as <code>Triangle</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Rectangle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Circle</code> <code class="o">|</code> <code class="nx">Triangle</code> <code class="o">|</code> <code class="nx">Square</code> <code class="o">|</code> <code class="nx">Rectangle</code><code class="p">;</code></pre>&#13;
&#13;
<p>There is no clear way to differentiate between each part of a union. To make sure each part of a union is distinguishable, we need to extend our models with an identifying property that makes absolutely clear what we are dealing with.</p>&#13;
&#13;
<p>This can happen through the addition of a <code>kind</code> property. This property takes a string literal type identifying the part of the model.</p>&#13;
&#13;
<p>As seen in <a data-type="xref" href="#ch03_item_modelling_data">Recipe 3.1</a>, TypeScript allows you to subset primitive types like <code>string</code>, <code>number</code>, <code>bigint</code>, and <code>boolean</code> to concrete values. Which means that every value is also a type, a set that consists of exactly one compatible value.</p>&#13;
&#13;
<p>So for our model to be clearly defined, we add a <code>kind</code> property to each model part and set it to an exact literal type identifying this part:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Square</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"square"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Triangle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"triangle"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Circle</code> <code class="o">|</code> <code class="nx">Triangle</code> <code class="o">|</code> <code class="nx">Square</code><code class="p">;</code></pre>&#13;
&#13;
<p>Note that we don’t set <code>kind</code> to <code>string</code> but to the <em>exact</em> literal type <code>"circle"</code> (or <code>"square"</code> and <code>"triangle"</code>, respectively). This is a type, not a value, but the only compatible value is the literal string.</p>&#13;
&#13;
<p>Adding the <code>kind</code> property with string literal types ensures there can’t be any overlap between parts of the union, as the literal types are not compatible with one another. This technique is called <em>discriminated union types</em> and effectively tears away each set that’s part of the union type <code>Shape</code>, pointing to an exact set.</p>&#13;
&#13;
<p>This is fantastic for the <code>area</code> function, as we can effectively distinguish, for example, in a <code>switch</code> statement:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">area</code><code class="p">(</code><code class="nx">shape</code><code class="o">:</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">kind</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s2">"circle"</code><code class="o">:</code> <code class="c1">// shape is Circle</code>&#13;
      <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"triangle"</code><code class="o">:</code> <code class="c1">// shape is Triangle</code>&#13;
      <code class="k">return</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">y</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"square"</code><code class="o">:</code> <code class="c1">// shape is Square</code>&#13;
      <code class="k">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
    <code class="k">default</code><code class="o">:</code>&#13;
      <code class="k">throw</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"not possible"</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Not only does it become absolutely clear what we are dealing with, but it is also very future proof to upcoming changes, as we will see in <a data-type="xref" href="#ch03_item_assert_never">Recipe 3.3</a>.<a data-startref="ix_0203-asciidoc2" data-type="indexterm" id="id529"/><a data-startref="ix_0203-asciidoc1" data-type="indexterm" id="id530"/><a data-startref="ix_0203-asciidoc0" data-type="indexterm" id="id531"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.3 Exhaustiveness Checking with the &#10;Assert never Technique" data-type="sect1"><div class="sect1" id="ch03_item_assert_never">&#13;
<h1>3.3 Exhaustiveness Checking with the &#13;
<span class="keep-together">Assert never Technique</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id47">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="assertNever function" data-type="indexterm" id="ix_0303-asciidoc0"/><a data-primary="discriminated union types" data-secondary="exhaustiveness checking with assertNever" data-type="indexterm" id="ix_0303-asciidoc1"/><a data-primary="exhaustiveness checking" data-type="indexterm" id="ix_0303-asciidoc2"/><a data-primary="type system" data-secondary="exhaustiveness checking with assertNever" data-type="indexterm" id="ix_0303-asciidoc3"/>Your discriminated union types change over time, adding new parts to the union. It becomes difficult to track all occurrences in your code where you need to adapt to these changes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id532">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create exhaustiveness checks where you assert that all remaining cases can never happen with an <code>assertNever</code> function.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id48">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Let’s look at the full example from <a data-type="xref" href="#ch03_item_discriminated_unions">Recipe 3.2</a>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Square</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"square"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Triangle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"triangle"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Circle</code> <code class="o">|</code> <code class="nx">Triangle</code> <code class="o">|</code> <code class="nx">Square</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">area</code><code class="p">(</code><code class="nx">shape</code><code class="o">:</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">kind</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s2">"circle"</code><code class="o">:</code> <code class="c1">// shape is Circle</code>&#13;
      <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"triangle"</code><code class="o">:</code> <code class="c1">// shape is Triangle</code>&#13;
      <code class="k">return</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">y</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"square"</code><code class="o">:</code> <code class="c1">// shape is Square</code>&#13;
      <code class="k">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
    <code class="k">default</code><code class="o">:</code>&#13;
      <code class="k">throw</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"not possible"</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Using discriminated unions, we can distinguish between each part of a union. The <code>area</code> function uses a switch-case statement to handle each case separately. Thanks to string literal types for the <code>kind</code> property, there can be no overlap between types.</p>&#13;
&#13;
<p>Once all options are exhausted, in the default case we throw an error, indicating that we reached an invalid situation that should never occur. If our types are right throughout the codebase, this error should never be thrown.</p>&#13;
&#13;
<p>Even the type system tells us that the default case is an impossible scenario. If we add <code>shape</code> in the default case and hover over it, TypeScript tells us that <code>shape</code> is of type <code>never</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">area</code><code class="p">(</code><code class="nx">shape</code><code class="o">:</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">kind</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s2">"circle"</code><code class="o">:</code> <code class="c1">// shape is Circle</code>&#13;
      <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"triangle"</code><code class="o">:</code> <code class="c1">// shape is Triangle</code>&#13;
      <code class="k">return</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">y</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"square"</code><code class="o">:</code> <code class="c1">// shape is Square</code>&#13;
      <code class="k">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
    <code class="k">default</code><code class="o">:</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s2">"Shape not defined:"</code><code class="p">,</code> <code class="nx">shape</code><code class="p">);</code> <code class="c1">// shape is never</code>&#13;
      <code class="k">throw</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"not possible"</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-primary="bottom types" data-type="indexterm" id="id533"/><a data-primary="never type" data-secondary="and assert never technique" data-secondary-sortas="assert" data-type="indexterm" id="id534"/><code>never</code> is an interesting type. It’s TypeScript <em>bottom type</em>, meaning that it’s at the very end of the type hierarchy. Where <code>any</code> and <code>unknown</code> include every possible value, no value is compatible to <code>never</code>. It’s the empty set, which explains the name. If one of your values happens to be of type <code>never</code>, you are in a situation that should <em>never</em> &#13;
<span class="keep-together">happen.</span></p>&#13;
&#13;
<p>The type of <code>shape</code> in the default cases changes immediately if we extend the type <code>Shape</code> with, for example, a <code>Rectangle</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Rectangle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"rectangle"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Circle</code> <code class="o">|</code> <code class="nx">Triangle</code> <code class="o">|</code> <code class="nx">Square</code> <code class="o">|</code> <code class="nx">Rectangle</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">area</code><code class="p">(</code><code class="nx">shape</code><code class="o">:</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">kind</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s2">"circle"</code><code class="o">:</code> <code class="c1">// shape is Circle</code>&#13;
      <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"triangle"</code><code class="o">:</code> <code class="c1">// shape is Triangle</code>&#13;
      <code class="k">return</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">y</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"square"</code><code class="o">:</code> <code class="c1">// shape is Square</code>&#13;
      <code class="k">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
    <code class="k">default</code><code class="o">:</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s2">"Shape not defined:"</code><code class="p">,</code> <code class="nx">shape</code><code class="p">);</code> <code class="c1">// shape is Rectangle</code>&#13;
      <code class="k">throw</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"not possible"</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is control flow analysis at its best: TypeScript knows at exactly every point in time which types your values have. In the <code>default</code> branch, <code>shape</code> is of type &#13;
<span class="keep-together"><code>Rectangle</code></span>, but we are expected to deal with rectangles. Wouldn’t it be great if TypeScript could tell us that we missed taking care of a potential type? With the change, we now run into it every time we calculate the shape of a rectangle. The default case was meant to handle (from the perspective of the type system) impossible situations; we’d like to keep it that way.</p>&#13;
&#13;
<p>This is already bad in one situation, and it gets worse if you use the exhaustiveness checking pattern multiple times in your codebase. You can’t tell for sure that you didn’t miss one spot where your software will ultimately crash.</p>&#13;
&#13;
<p>One technique to ensure that you handled all possible cases is to create a helper function that asserts that all options are exhausted. It should ensure that the only values possible are no values:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">assertNever</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kr">never</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s2">"Unknown value"</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code>&#13;
  <code class="k">throw</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Not possible"</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Usually, you see <code>never</code> as an indicator that you are in an impossible situation. Here, we use it as an explicit type annotation for a function signature. You might ask: which values are we supposed to pass? And the answer is: none! In the best case, this function will never get called.</p>&#13;
&#13;
<p>However, if we substitute the original default case from our example with <code>as⁠se⁠rt​Ne⁠ve⁠r</code>, we can use the type system to ensure that all possible values are compatible, even if there are no values:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">area</code><code class="p">(</code><code class="nx">shape</code><code class="o">:</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">kind</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s2">"circle"</code><code class="o">:</code> <code class="c1">// shape is Circle</code>&#13;
      <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"triangle"</code><code class="o">:</code> <code class="c1">// shape is Triangle</code>&#13;
      <code class="k">return</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">y</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"square"</code><code class="o">:</code> <code class="c1">// shape is Square</code>&#13;
      <code class="k">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
    <code class="k">default</code><code class="o">:</code> <code class="c1">// shape is Rectangle</code>&#13;
      <code class="nx">assertNever</code><code class="p">(</code><code class="nx">shape</code><code class="p">);</code>&#13;
<code class="c1">//    ^-- Error: Argument of type 'Rectangle' is not</code>&#13;
<code class="c1">//        assignable to parameter of type 'never'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Great! We now get red squiggly lines whenever we forget to exhaust all options. TypeScript won’t compile this code without an error, and it’s easy to spot all occurrences in our codebase where we need to add the <code>Rectangle</code> case:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">area</code><code class="p">(</code><code class="nx">shape</code><code class="o">:</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">kind</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s2">"circle"</code><code class="o">:</code> <code class="c1">// shape is Circle</code>&#13;
      <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"triangle"</code><code class="o">:</code> <code class="c1">// shape is Triangle</code>&#13;
      <code class="k">return</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">y</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"square"</code><code class="o">:</code> <code class="c1">// shape is Square</code>&#13;
      <code class="k">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"rectangle"</code><code class="o">:</code>&#13;
      <code class="k">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>&#13;
    <code class="k">default</code><code class="o">:</code> <code class="c1">// shape is never</code>&#13;
      <code class="nx">assertNever</code><code class="p">(</code><code class="nx">shape</code><code class="p">);</code> <code class="c1">// shape can be passed to assertNever!</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Even though <code>never</code> has no compatible values and is used to indicate—for the type system—an impossible situation, we can use the type as type annotation to make sure we don’t forget about <em>possible</em> situations. Seeing types as sets of compatible values that can get broader or narrower based on control flow leads us to techniques like <code>assertNever</code>, a very helpful little function that can strengthen our codebase’s quality.<a data-startref="ix_0303-asciidoc3" data-type="indexterm" id="id535"/><a data-startref="ix_0303-asciidoc2" data-type="indexterm" id="id536"/><a data-startref="ix_0303-asciidoc1" data-type="indexterm" id="id537"/><a data-startref="ix_0303-asciidoc0" data-type="indexterm" id="id538"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.4 Pinning Types with Const Context" data-type="sect1"><div class="sect1" id="ch03_item_const_context">&#13;
<h1>3.4 Pinning Types with Const Context</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id49">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="pinning types, const context for" data-type="indexterm" id="ix_0403-asciidoc0"/><a data-primary="type system" data-secondary="pinning types with const context" data-type="indexterm" id="ix_0403-asciidoc1"/>You can’t assign object literals to your carefully modeled discriminated union types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id539">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Pin the type of your literals using type assertions and <em>const context</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id50">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="literal types" data-type="indexterm" id="id540"/>In TypeScript, it’s possible to use each value as its own type. These are called literal types and allow you to subset bigger sets to just a couple of valid values.</p>&#13;
&#13;
<p>Literal types in TypeScript are not only a nice trick to point to specific values but are also an essential part of how the type system works. This becomes obvious when you assign values of primitive types to different bindings via <code>let</code> or <code>const</code>.</p>&#13;
&#13;
<p>If we assign the same value twice, once via <code>let</code> and once via <code>const</code>, TypeScript infers two different types. With the <code>let</code> binding, TypeScript will infer the broader primitive type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Stefan"</code><code class="p">;</code> <code class="c1">// name is string</code></pre>&#13;
&#13;
<p>With a <code>const</code> binding, TypeScript will infer the exact literal type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Stefan"</code><code class="p">;</code> <code class="c1">// name is "Stefan"</code></pre>&#13;
&#13;
<p>Object types behave slightly differently. <code>let</code> bindings still infer the broader set:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// person is { name: string }</code>&#13;
<code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code> <code class="p">};</code></pre>&#13;
&#13;
<p>But so do <code>const</code> bindings:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// person is { name: string }</code>&#13;
<code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code> <code class="p">};</code></pre>&#13;
&#13;
<p>The reasoning behind this is in JavaScript, while the binding itself is <em>constant</em>, which means I can’t reassign <code>person</code>, the values of an object’s property can change:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// person is { name: string }</code>&#13;
<code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code> <code class="p">};</code>&#13;
&#13;
<code class="nx">person</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s2">"Not Stefan"</code><code class="p">;</code> <code class="c1">// works!</code></pre>&#13;
&#13;
<p>This behavior is correct in the sense that it mirrors the behavior of JavaScript, but it can cause problems when we are very exact with our data models.</p>&#13;
&#13;
<p>In the previous recipes we modeled data using union and intersection types. We used <em>discriminated union types</em> to distinguish between types that are too similar.</p>&#13;
&#13;
<p>The problem is that when we use literals for data, TypeScript will usually infer the broader set, which makes the values incompatible to the types defined. This produces a very lengthy error message:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Square</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"square"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Triangle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"triangle"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Circle</code> <code class="o">|</code> <code class="nx">Triangle</code> <code class="o">|</code> <code class="nx">Square</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">area</code><code class="p">(</code><code class="nx">shape</code><code class="o">:</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="cm">/* ... */</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">area</code><code class="p">(</code><code class="nx">circle</code><code class="p">);</code>&#13;
<code class="c1">//   ^-- Argument of type '{ radius: number; kind: string; '</code>&#13;
<code class="c1">//       is not assignable to parameter of type 'Shape'.</code>&#13;
<code class="c1">//       Type '{ radius: number; kind: string; }' is not</code>&#13;
<code class="c1">//       assignable to type 'Circle'.</code>&#13;
<code class="c1">//       Types of property 'kind' are incompatible.</code>&#13;
<code class="c1">//       Type 'string' is not assignable to type '"circle"'.</code></pre>&#13;
&#13;
<p>There are several ways to solve this problem. First, we can use explicit annotations to ensure the type. As described in <a data-type="xref" href="ch02.html#ch02_item_annotation">Recipe 2.1</a>, each annotation is a type-check, which means the value on the righthand side is checked for compatibility. Since there is no inference, Typescript will look at the exact values to decide whether an object literal is compatible:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Exact type</code>&#13;
<code class="kr">const</code> <code class="nx">circle</code><code class="o">:</code> <code class="nx">Circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">area</code><code class="p">(</code><code class="nx">circle</code><code class="p">);</code> <code class="c1">// Works!</code>&#13;
&#13;
<code class="c1">// Broader set</code>&#13;
<code class="kr">const</code> <code class="nx">circle</code><code class="o">:</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">area</code><code class="p">(</code><code class="nx">circle</code><code class="p">);</code> <code class="c1">// Also works!</code></pre>&#13;
&#13;
<p>Instead of type annotations, we can also do type assertions at the end of the &#13;
<span class="keep-together">assignment:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Type assertion</code>&#13;
<code class="kr">const</code> <code class="nx">circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code><code class="p">,</code>&#13;
<code class="p">}</code> <code class="kr">as</code> <code class="nx">Circle</code><code class="p">;</code>&#13;
&#13;
<code class="nx">area</code><code class="p">(</code><code class="nx">circle</code><code class="p">);</code> <code class="c1">// Works!</code></pre>&#13;
&#13;
<p>Sometimes, however, annotations can limit us. This is true especially when we have to work with literals that contain more information and are used in different places with different semantics.</p>&#13;
&#13;
<p>From the moment we annotate or assert as <code>Circle</code>, the binding will always be a circle, no matter which values <code>circle</code> actually carries.</p>&#13;
&#13;
<p>But we can be much more fine-grained with assertions. Instead of asserting that the entire object is of a certain type, we can assert single properties to be of a certain type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code> <code class="kr">as</code> <code class="s2">"circle"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">area</code><code class="p">(</code><code class="nx">circle</code><code class="p">);</code> <code class="c1">// Works!</code></pre>&#13;
&#13;
<p><a data-primary="const context" data-secondary="literals and" data-type="indexterm" id="id541"/>Another way to assert as exact values is to use <em>const context</em> with an <code>as const</code> type assertion; TypeScript locks the value in as literal type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">area</code><code class="p">(</code><code class="nx">circle</code><code class="p">);</code> <code class="c1">// Works!</code></pre>&#13;
&#13;
<p>If we apply <em>const context</em> to the entire object, we also make sure that the values are read-only and won’t be changed:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">circle</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">radius</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"circle"</code><code class="p">,</code>&#13;
<code class="p">}</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>&#13;
&#13;
<code class="nx">area2</code><code class="p">(</code><code class="nx">circle</code><code class="p">);</code> <code class="c1">// Works!</code>&#13;
&#13;
<code class="nx">circle</code><code class="p">.</code><code class="nx">kind</code> <code class="o">=</code> <code class="s2">"rectangle"</code><code class="p">;</code>&#13;
<code class="c1">//     ^-- Cannot assign to 'kind' because</code>&#13;
<code class="c1">//         it is a read-only property.</code></pre>&#13;
&#13;
<p><em>Const context</em> type assertions are a very handy tool if we want to pin values to their exact literal type and keep them that way. If there are a lot of object literals in your code base that are not supposed to change but need to be consumed in various occasions, <em>const context</em> can help!<a data-startref="ix_0403-asciidoc1" data-type="indexterm" id="id542"/><a data-startref="ix_0403-asciidoc0" data-type="indexterm" id="id543"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.5 Narrowing Types with Type Predicates" data-type="sect1"><div class="sect1" id="ch03_item_type_predicates">&#13;
<h1>3.5 Narrowing Types with Type Predicates</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id51">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="predicates" data-type="indexterm" id="ix_0503-asciidoc0"/><a data-primary="type system" data-secondary="predicates" data-type="indexterm" id="ix_0503-asciidoc1"/><a data-primary="types" data-secondary="narrowing with predicates" data-type="indexterm" id="ix_0503-asciidoc2"/>Based on certain conditions, you can assert that a value is of a narrower type than originally assigned, but TypeScript can’t narrow it for you.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id544">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Add type predicates to a helper function’s signature to indicate the impact of a Boolean condition for the type system.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id52">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>With literal types and union types, TypeScript allows you to define very specific sets of values. For example, we can define a die with six sides easily:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Dice</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> <code class="o">|</code> <code class="mi">3</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code> <code class="o">|</code> <code class="mi">6</code><code class="p">;</code></pre>&#13;
&#13;
<p>While this notation is expressive, and the type system can tell you exactly which values are valid, it requires some work to get to this type.</p>&#13;
&#13;
<p>Let’s imagine we have some kind of game where users are allowed to input any number. If it’s a valid number of dots, we are doing certain actions.</p>&#13;
&#13;
<p>We write a conditional check to see if the input number is part of a set of values:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">rollDice</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">].</code><code class="nx">includes</code><code class="p">(</code><code class="nx">input</code><code class="p">))</code> <code class="p">{</code>&#13;
    <code class="c1">// `input` is still `number`, even though we know it</code>&#13;
    <code class="c1">// should be Dice</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The problem is that even though we do a check to make sure the set of values is known, TypeScript still handles <code>input</code> as <code>number</code>. There is no way for the type system to make the connection between your check and the change in the type system.</p>&#13;
&#13;
<p>But you can help the type system. First, extract your check into its own helper &#13;
<span class="keep-together">function:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">isDice</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">].</code><code class="nx">includes</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that this check returns a <code>boolean</code>. Either this condition is true or it’s false. For functions that return a Boolean value, we can change the return type of the function signature to a type predicate.</p>&#13;
&#13;
<p>We tell TypeScript that if this function returns true, we know more about the value that has been passed to the function. In our case, <code>value</code> is of type <code>Dice</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">isDice</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">value</code> <code class="nx">is</code> <code class="nx">Dice</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">].</code><code class="nx">includes</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With that, TypeScript gets a hint of what the actual types of your values are, allowing you to do more fine-grained operations on your values:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">rollDice</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">isDice</code><code class="p">(</code><code class="nx">input</code><code class="p">))</code> <code class="p">{</code>&#13;
    <code class="c1">// Great! `input` is now `Dice`</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="c1">// input is still `number`</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>TypeScript is restrictive and doesn’t allow any assertion with type predicates. It needs to be a type that is narrower than the original type. For example, getting a <code>string</code> input and asserting a subset of <code>number</code> as output will error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Dice</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> <code class="o">|</code> <code class="mi">3</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code> <code class="o">|</code> <code class="mi">6</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">isDice</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">value</code> <code class="nx">is</code> <code class="nx">Dice</code> <code class="p">{</code>&#13;
<code class="c1">// Error: A type predicate's type must be assignable to</code>&#13;
<code class="c1">// its parameter's type. Type 'number' is not assignable to type 'string'.</code>&#13;
  <code class="k">return</code> <code class="p">[</code><code class="s2">"1"</code><code class="p">,</code> <code class="s2">"2"</code><code class="p">,</code> <code class="s2">"3"</code><code class="p">,</code> <code class="s2">"4"</code><code class="p">,</code> <code class="s2">"5"</code><code class="p">,</code> <code class="s2">"6"</code><code class="p">].</code><code class="nx">includes</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This fail-safe mechanism gives you some guarantee on the type level, but there is a caveat: it won’t check if your conditions make sense. The original check in <code>isDice</code> ensures that the value passed is included in an array of valid numbers.</p>&#13;
&#13;
<p>The values in this array are your choice. If you include a wrong number, TypeScript will still think <code>value</code> is a valid <code>Dice</code>, even though your check does not line up:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Correct on a type-level</code>&#13;
<code class="c1">// incorrect set of values on a value-level</code>&#13;
<code class="kd">function</code> <code class="nx">isDice</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">value</code> <code class="nx">is</code> <code class="nx">Dice</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">].</code><code class="nx">includes</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is easy to trip over. The condition in <a data-type="xref" href="#ex-wrong-check">Example 3-1</a> is true for integer numbers but wrong if you pass a floating point number. For example, <code>3.1415</code> would be a valid <code>Dice</code> dot count!</p>&#13;
<div data-type="example" id="ex-wrong-check">&#13;
<h5><span class="label">Example 3-1. </span>Incorrect logic for <code>isDice</code> for floating point numbers</h5>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Correct on a type-level, incorrect logic</code>&#13;
<code class="kd">function</code> <code class="nx">isDice</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">value</code> <code class="nx">is</code> <code class="nx">Dice</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">value</code> <code class="o">&gt;=</code> <code class="mi">1</code> <code class="o">&amp;&amp;</code> <code class="nx">value</code> <code class="o">&lt;=</code> <code class="mi">6</code><code class="p">;</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Actually, any condition works for TypeScript. Return <code>true</code> and TypeScript will think <code>value</code> is <code>Dice</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">isDice</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">value</code> <code class="nx">is</code> <code class="nx">Dice</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>TypeScript puts type assertions in your hand. It is your duty to make sure those assertions are valid and sound. If you rely heavily on type assertions via type predicates, make sure that you test accordingly.<a data-startref="ix_0503-asciidoc2" data-type="indexterm" id="id545"/><a data-startref="ix_0503-asciidoc1" data-type="indexterm" id="id546"/><a data-startref="ix_0503-asciidoc0" data-type="indexterm" id="id547"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.6 Understanding void" data-type="sect1"><div class="sect1" id="ch03_substituting_void">&#13;
<h1>3.6 Understanding void</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id210">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="void as substitutable type for" data-type="indexterm" id="ix_0603-asciidoc0"/><a data-primary="type system" data-secondary="void" data-type="indexterm" id="ix_0603-asciidoc1"/><a data-primary="void" data-secondary="TypeScript" data-type="indexterm" id="ix_0603-asciidoc2"/>You know <code>void</code> as a concept from other programming languages, but in TypeScript it can behave a little bit differently.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id548">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Embrace <code>void</code> as a substitutable type for callbacks.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id53">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>You might know <code>void</code> from programming languages like Java or C#, where it indicates the absence of a return value. <code>void</code> also exists in TypeScript, and at first glance it does the same thing: if your functions or methods aren’t returning something, the return type is <code>void</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id549">&#13;
<h1>void in JavaScript</h1>&#13;
<p><a data-primary="JavaScript" data-secondary="void" data-type="indexterm" id="id550"/><a data-primary="void" data-secondary="JavaScript" data-type="indexterm" id="id551"/><code>void</code> also exists as an operator in JavaScript and has a very special behavior. It evaluates the expression next to it but guarantees to return <code>undefined</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">2</code><code class="p">;</code> <code class="c1">// i === undefined</code></pre>&#13;
&#13;
<p>What are the use cases for <code>void</code>? First, in ECMAScript 3, you could override &#13;
<span class="keep-together"><code>undefined</code></span> and give it an actual value. <code>void</code> always returned the <em>real</em> undefined.</p>&#13;
&#13;
<p>Second, it’s a nice way to call immediately invoked functions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// executes immediately.</code>&#13;
<code class="k">void</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Hey'</code><code class="p">);</code>&#13;
<code class="p">}();</code></pre>&#13;
&#13;
<p>All without polluting the global namespace:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="k">void</code> <code class="kd">function</code> <code class="nx">aRecursion</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code><code class="p">(</code><code class="nx">i</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="o">--</code><code class="p">);</code>&#13;
    <code class="nx">aRecursion</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}(</code><code class="mi">3</code><code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">aRecursion</code><code class="p">);</code> <code class="c1">// undefined</code></pre>&#13;
&#13;
<p>Since <code>void</code> always returns <code>undefined</code> and <code>void</code> always evaluates the expression next to it, you have a very terse way of returning from a function without returning a value but still calling a callback, for example:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// returning something else than undefined would crash the app</code>&#13;
<code class="kd">function</code> <code class="nx">middleware</code><code class="p">(</code><code class="nx">nextCallback</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code><code class="p">(</code><code class="nx">conditionApplies</code><code class="p">())</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">void</code> <code class="nx">nextCallback</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Which brings me to the most important use case of <code>void</code>: it’s a security gate for your app. When your function is always supposed to return <code>undefined</code>, you can make sure that this is always the case:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">button</code><code class="p">.</code><code class="nx">onclick</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code> <code class="nx">doSomething</code><code class="p">();</code></pre>&#13;
</div></aside>&#13;
&#13;
<p><a data-primary="undefined, void as subtype of" data-type="indexterm" id="id552"/>At second glance, however, the behavior of <code>void</code> is a bit more nuanced, and so is its position in the type system.  <code>void</code> in TypeScript is a subtype of <code>undefined</code>. Functions in JavaScript always return something. Either a function explicitly returns a value, or it implicitly returns <code>undefined</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">iHaveNoReturnValue</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">check</code> <code class="o">=</code> <code class="nx">iHaveNoReturnValue</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>&#13;
<code class="c1">// check is undefined</code></pre>&#13;
&#13;
<p>If we created a type for <code>iHaveNoReturnValue</code>, it would show a function type with <code>void</code> as return type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">iHaveNoReturnValue</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Fn</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">iHaveNoReturnValue</code><code class="p">;</code>&#13;
<code class="c1">// type Fn = (i: any) =&gt; void</code></pre>&#13;
&#13;
<p><code>void</code> as type can also be used for parameters and all other declarations. The only value that can be passed is <code>undefined</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">iTakeNoParameters</code><code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code> <code class="p">}</code>&#13;
&#13;
<code class="nx">iTakeNoParameters</code><code class="p">();</code> <code class="c1">// works</code>&#13;
<code class="nx">iTakeNoParameters</code><code class="p">(</code><code class="kc">undefined</code><code class="p">);</code> <code class="c1">// works</code>&#13;
<code class="nx">iTakeNoParameters</code><code class="p">(</code><code class="k">void</code> <code class="mi">2</code><code class="p">);</code> <code class="c1">// works</code></pre>&#13;
&#13;
<p><code>void</code> and <code>undefined</code> are pretty much the same. There’s one significant difference though: <code>void</code> as a return type can be substituted with different types, to allow for advanced callback patterns. Let’s create a <code>fetch</code> function, for example. Its task is to get a set of numbers and pass the results to a callback function, provided as a parameter:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">fetchResults</code><code class="p">(</code>&#13;
  <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">statusCode</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">results</code><code class="o">:</code> <code class="kt">number</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// get results from somewhere ...</code>&#13;
  <code class="nx">callback</code><code class="p">(</code><code class="mi">200</code><code class="p">,</code> <code class="nx">results</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The callback function has two parameters in its signature—a status code and the results—and the return type is <code>void</code>. We can call <code>fetchResults</code> with callback functions that match the exact type of <code>callback</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">normalHandler</code><code class="p">(</code><code class="nx">statusCode</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">results</code><code class="o">:</code> <code class="kt">number</code><code class="p">[])</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">// do something with both parameters</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">fetchResults</code><code class="p">(</code><code class="nx">normalHandler</code><code class="p">);</code></pre>&#13;
&#13;
<p>But if a function type specifies return type <code>void</code>, functions with a different, more specific return type are also accepted:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">handler</code><code class="p">(</code><code class="nx">statusCode</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
  <code class="c1">// evaluate the status code ...</code>&#13;
  <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">fetchResults</code><code class="p">(</code><code class="nx">handler</code><code class="p">);</code> <code class="c1">// compiles, no problem!</code></pre>&#13;
&#13;
<p>The function signatures don’t match exactly, but the code still compiles. First, it’s OK to provide functions with a shorter argument list in their signature. JavaScript can call functions with excess parameters, and if they aren’t specified in the function, they’re simply ignored. No need to carry more parameters than you actually need.</p>&#13;
&#13;
<p>Second, the return type is <code>boolean</code>, but TypeScript will still pass this function along. This is useful when declaring a <code>void</code> return type. The original caller <code>fetchResults</code> does not expect a return value when calling the callback. So for the type system, the return value of <code>callback</code> is still <code>undefined</code>, even though it could be something else.</p>&#13;
&#13;
<p>As long as the type system won’t allow you to work with the return value, your code should be safe:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">fetchResults</code><code class="p">(</code>&#13;
  <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">statusCode</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">results</code><code class="o">:</code> <code class="kt">number</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// get results from somewhere ...</code>&#13;
  <code class="kr">const</code> <code class="nx">didItWork</code> <code class="o">=</code> <code class="nx">callback</code><code class="p">(</code><code class="mi">200</code><code class="p">,</code> <code class="nx">results</code><code class="p">);</code>&#13;
  <code class="c1">// didItWork is `undefined` in the type system,</code>&#13;
  <code class="c1">// even though it would be a boolean with `handler`.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That’s why we can pass callbacks with any return type. Even if the callback returns something, this value isn’t used and goes into the void.</p>&#13;
&#13;
<p>The power lies within the calling function, which knows best what to expect from the callback function. And if the calling function doesn’t require a return value at all from the callback, anything goes!</p>&#13;
&#13;
<p><a data-primary="substitutability" data-type="indexterm" id="id553"/>TypeScript calls this feature <em>substitutability</em>: the ability to substitute one thing for another, wherever it makes sense. This might seem odd at first. But especially when you work with libraries that you didn’t author, you will find this feature to be very valuable.<a data-startref="ix_0603-asciidoc2" data-type="indexterm" id="id554"/><a data-startref="ix_0603-asciidoc1" data-type="indexterm" id="id555"/><a data-startref="ix_0603-asciidoc0" data-type="indexterm" id="id556"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.7 Dealing with Error Types in catch Clauses" data-type="sect1"><div class="sect1" id="ch03_item_error_types">&#13;
<h1>3.7 Dealing with Error Types in catch Clauses</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id54">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="catch clauses" data-secondary="error types in" data-type="indexterm" id="ix_0703-asciidoc0"/><a data-primary="error types, in catch clauses" data-type="indexterm" id="ix_0703-asciidoc1"/><a data-primary="try-catch blocks" data-type="indexterm" id="ix_0703-asciidoc2"/><a data-primary="type system" data-secondary="error types in catch clauses" data-type="indexterm" id="ix_0703-asciidoc3"/>You can’t annotate explicit error types in <code>try-catch</code> blocks.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id557">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Annotate with <code>any</code> or <code>unknown</code> and use type predicates (see <a data-type="xref" href="#ch03_item_type_predicates">Recipe 3.5</a> to narrow to specific error types).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id558">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>When you are coming from languages like Java, C++, or C#, you are used to doing your error handling by throwing exceptions and subsequently catching them in a cascade of <code>catch</code> clauses. There are arguably better ways to do error handling, but this one has been around for ages and, given history and influences, has found its way into JavaScript.<sup><a data-type="noteref" href="ch03.html#id559" id="id559-marker">1</a></sup></p>&#13;
&#13;
<p>“Throwing” errors and “catching” them is a valid way to handle errors in JavaScript and TypeScript, but there is a big difference when it comes to specifying your <code>catch</code> clauses. When you try to catch a specific error type, TypeScript will error.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-axios-error">Example 3-2</a> uses the popular data-fetching library <a href="https://axios-http.com">Axios</a> to show the problem.</p>&#13;
<div data-type="example" id="ex-axios-error">&#13;
<h5><span class="label">Example 3-2. </span>Catching explicit error types does not work</h5>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="k">try</code> <code class="p">{</code>&#13;
  <code class="c1">// something with the popular fetching library Axios, for example</code>&#13;
<code class="p">}</code> <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="o">:</code> <code class="nx">AxiosError</code><code class="p">)</code> <code class="p">{</code>&#13;
<code class="c1">//         ^^^^^^^^^^ Error 1196: Catch clause variable</code>&#13;
<code class="c1">//                    type annotation must be 'any' or</code>&#13;
<code class="c1">//                    'unknown' if specified.</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>There are a few reasons for this:</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Any type can be thrown" data-type="sect3"><div class="sect3" id="id560">&#13;
<h3>Any type can be thrown</h3>&#13;
&#13;
<p>In JavaScript, you are allowed to throw every expression. Of course, you can throw “exceptions” (or errors, as we call them in JavaScript), but it’s also possible to throw any other value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="k">throw</code> <code class="s2">"What a weird error"</code><code class="p">;</code> <code class="c1">// OK</code>&#13;
<code class="k">throw</code> <code class="mi">404</code><code class="p">;</code> <code class="c1">// OK</code>&#13;
<code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"What a weird error"</code><code class="p">);</code> <code class="c1">// OK</code></pre>&#13;
&#13;
<p>Since any valid value can be thrown, the possible values to catch are already broader than your usual subtype of <code>Error</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="There is only one catch clause in JavaScript" data-type="sect3"><div class="sect3" id="id211">&#13;
<h3>There is only one catch clause in JavaScript</h3>&#13;
&#13;
<p><a data-primary="catch clauses" data-secondary="in JavaScript" data-type="indexterm" id="id561"/><a data-primary="JavaScript" data-secondary="catch clauses in" data-type="indexterm" id="id562"/>JavaScript has only one <code>catch</code> clause per <code>try</code> statement. In the past there have been <a href="https://oreil.ly/NMn8O">proposals for multiple <code>catch</code> clauses</a> and even conditional expressions, but due to the lack of interest in JavaScript in the early 2000s, they never manifested.</p>&#13;
&#13;
<p>Instead, you should use this one <code>catch</code> clause and do <code>instanceof</code> and <code>typeof</code> checks, as proposed on <a href="https://oreil.ly/ipzoR">MDN</a>.</p>&#13;
&#13;
<p>This example is also the only correct way to narrow types for <code>catch</code> clauses in &#13;
<span class="keep-together">TypeScript:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="k">try</code> <code class="p">{</code>&#13;
  <code class="nx">myroutine</code><code class="p">();</code> <code class="c1">// There's a couple of errors thrown here</code>&#13;
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">e</code> <code class="k">instanceof</code> <code class="nx">TypeError</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// A TypeError</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">e</code> <code class="k">instanceof</code> <code class="nx">RangeError</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// Handle the RangeError</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">e</code> <code class="k">instanceof</code> <code class="nx">EvalError</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// you guessed it: EvalError</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">e</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// The error is a string</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">axios</code><code class="p">.</code><code class="nx">isAxiosError</code><code class="p">(</code><code class="nx">e</code><code class="p">))</code> <code class="p">{</code>&#13;
    <code class="c1">// axios does an error check for us!</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="c1">// everything else</code>&#13;
    <code class="nx">logMyErrors</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Since all possible values can be thrown, and we only have one <code>catch</code> clause per <code>try</code> statement to handle them, the type range of <code>e</code> is exceptionally broad.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Any exception can happen" data-type="sect3"><div class="sect3" id="id55">&#13;
<h3>Any exception can happen</h3>&#13;
&#13;
<p>Since you know about every error that can happen, wouldn’t a proper union type with all possible “throwables” work just as well? In theory, yes. In practice, there is no way to tell which types the exception will have.</p>&#13;
&#13;
<p>Next to all your user-defined exceptions and errors, the system might throw errors when something is wrong with the memory when it encountered a type mismatch or one of your functions has been undefined. A simple function call could exceed your call stack and cause the infamous stack overflow.</p>&#13;
&#13;
<p><a data-primary="any type" data-secondary="exceptions and" data-type="indexterm" id="id563"/><a data-primary="unknown type" data-secondary="exceptions and" data-type="indexterm" id="id564"/>The broad set of possible values, the single <code>catch</code> clause, and the uncertainty of errors that happen allow only two types for <code>e</code>: <code>any</code> and <code>unknown</code>.</p>&#13;
&#13;
<p>All reasons apply if you reject a <code>Promise</code>. The only thing TypeScript allows you to specify is the type of a fulfilled <code>Promise</code>. A rejection can happen on your behalf or through a system error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">somePromise</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>&#13;
  <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">fulfil</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">someConditionIsValid</code><code class="p">())</code> <code class="p">{</code>&#13;
      <code class="nx">fulfil</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
      <code class="nx">reject</code><code class="p">(</code><code class="s2">"Oh no!"</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">});</code>&#13;
&#13;
<code class="nx">somePromise</code><code class="p">()</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">val</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">val</code><code class="p">))</code> <code class="c1">// val is number</code>&#13;
  <code class="p">.</code><code class="k">catch</code><code class="p">((</code><code class="nx">e</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">e</code><code class="p">));</code> <code class="c1">// can be anything, really;</code></pre>&#13;
&#13;
<p>It becomes clearer if you call the same <code>Promise</code> in an <code>async</code>/<code>await</code> flow:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="k">try</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">z</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">somePromise</code><code class="p">();</code> <code class="c1">// z is number</code>&#13;
<code class="p">}</code> <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// same thing, e can be anything!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you want to define your own errors and catch accordingly, you can either write error classes and do instance of checks or create helper functions that check for certain properties and tell the correct type via type predicates. Axios is again a good example for that:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">isAxiosError</code><code class="p">(</code><code class="nx">payload</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="nx">payload</code> <code class="nx">is</code> <code class="nx">AxiosError</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">payload</code> <code class="o">!==</code> <code class="kc">null</code>&#13;
    <code class="o">&amp;&amp;</code> <code class="k">typeof</code> <code class="nx">payload</code> <code class="o">===</code> <code class="s1">'object'</code>&#13;
    <code class="o">&amp;&amp;</code> <code class="nx">payload</code><code class="p">.</code><code class="nx">isAxiosError</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Error handling in JavaScript and TypeScript can be a “false friend” if you come from other programming languages with similar features. Be aware of the differences and trust the TypeScript team and type-checker to give you the correct control flow to make sure your errors are handled effectively.<a data-startref="ix_0703-asciidoc3" data-type="indexterm" id="id565"/><a data-startref="ix_0703-asciidoc2" data-type="indexterm" id="id566"/><a data-startref="ix_0703-asciidoc1" data-type="indexterm" id="id567"/><a data-startref="ix_0703-asciidoc0" data-type="indexterm" id="id568"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.8 Creating Exclusive Or Models with Optional never" data-type="sect1"><div class="sect1" id="ch03_item_optional_never">&#13;
<h1>3.8 Creating Exclusive Or Models with Optional never</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id212">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="APIs" data-secondary="creating exclusive or (XOR) models with optional never" data-type="indexterm" id="ix_0803-asciidoc0"/><a data-primary="never type" data-secondary="creating exclusive or (XOR) models" data-type="indexterm" id="ix_0803-asciidoc1a"/><a data-primary="optional never technique" data-secondary="creating exclusive or (XOR) models" data-type="indexterm" id="ix_0803-asciidoc1"/><a data-primary="type system" data-secondary="creating exclusive or models with optional never" data-type="indexterm" id="ix_0803-asciidoc2"/>Your model requires you to have mutually exclusive parts of a union, but your API can’t rely on the <code>kind</code> property to differentiate.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id569">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <em>optional never</em> technique to exclude certain properties.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id56">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>You want to write a function that handles the result of a select operation in your application. This select operation gives you the list of possible options as well as the list of selected options. This function can deal with calls from a select operation that produces only a single value as well as from a select operation that results in multiple values.</p>&#13;
&#13;
<p>Since you need to adapt to an existing API, your function should be able to handle both and decide for the single and multiple cases within the function.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Of course there are better ways to model APIs, and we can talk endlessly about that. But sometimes you have to deal with existing APIs that are not that great to begin with. TypeScript gives you techniques and methods to correctly type your data in scenarios like this.</p>&#13;
</div>&#13;
&#13;
<p>Your model mirrors that API, as you can pass either a single <code>value</code> or multiple &#13;
<span class="keep-together"><code>values</code>:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SelectBase</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">options</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">SingleSelect</code> <code class="o">=</code> <code class="nx">SelectBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">MultipleSelect</code> <code class="o">=</code> <code class="nx">SelectBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">values</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">SelectProperties</code> <code class="o">=</code> <code class="nx">SingleSelect</code> <code class="o">|</code> <code class="nx">MultipleSelect</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">selectCallback</code><code class="p">(</code><code class="nx">params</code><code class="o">:</code> <code class="nx">SelectProperties</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="s2">"value"</code> <code class="k">in</code> <code class="nx">params</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// handle single cases</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="s2">"values"</code> <code class="k">in</code> <code class="nx">params</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// handle multiple cases</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">selectCallback</code><code class="p">({</code>&#13;
  <code class="nx">options</code><code class="o">:</code> <code class="p">[</code><code class="s2">"dracula"</code><code class="p">,</code> <code class="s2">"monokai"</code><code class="p">,</code> <code class="s2">"vscode"</code><code class="p">],</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="s2">"dracula"</code><code class="p">,</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">selectCallback</code><code class="p">({</code>&#13;
  <code class="nx">options</code><code class="o">:</code> <code class="p">[</code><code class="s2">"dracula"</code><code class="p">,</code> <code class="s2">"monokai"</code><code class="p">,</code> <code class="s2">"vscode"</code><code class="p">],</code>&#13;
  <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="s2">"dracula"</code><code class="p">,</code> <code class="s2">"vscode"</code><code class="p">],</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>This works as intended, but remember the structural type system features of TypeScript. Defining <code>SingleSelect</code> as a type allows also for values of all subtypes, which means that objects that have both the <code>value</code> property and the <code>values</code> property are also compatible to <code>SingleSelect</code>. The same goes for <code>MultipleSelect</code>. Nothing keeps you from using the <code>selectCallback</code> function with an object that contains both:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">selectCallback</code><code class="p">({</code>&#13;
  <code class="nx">options</code><code class="o">:</code> <code class="p">[</code><code class="s2">"dracula"</code><code class="p">,</code> <code class="s2">"monokai"</code><code class="p">,</code> <code class="s2">"vscode"</code><code class="p">],</code>&#13;
  <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="s2">"dracula"</code><code class="p">,</code> <code class="s2">"vscode"</code><code class="p">],</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="s2">"dracula"</code><code class="p">,</code>&#13;
<code class="p">});</code> <code class="c1">// still works! Which one to choose?</code></pre>&#13;
&#13;
<p>The value you pass here is valid, but it doesn’t make sense in your application. You couldn’t decide whether this is a multiple select operation or a single select operation.</p>&#13;
&#13;
<p>In cases like this we again need to separate the two sets of values just enough so our model becomes clearer. <a data-primary="never type" data-secondary="optional never technique and" data-type="indexterm" id="id570"/>We can do this by using the optional <code>never</code> technique.<sup><a data-type="noteref" href="ch03.html#id571" id="id571-marker">2</a></sup> It involves taking the properties that are exclusive to each branch of a union and adding them as optional properties of type <code>never</code> to the other branches:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SelectBase</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">options</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">SingleSelect</code> <code class="o">=</code> <code class="nx">SelectBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">values</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">MultipleSelect</code> <code class="o">=</code> <code class="nx">SelectBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">value</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
  <code class="nx">values</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>You tell TypeScript that this property is optional in this branch, and when it’s set, there is no compatible value for it. With that, all objects that contain both properties are invalid to <code>SelectProperties</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">selectCallback</code><code class="p">({</code>&#13;
  <code class="nx">options</code><code class="o">:</code> <code class="p">[</code><code class="s2">"dracula"</code><code class="p">,</code> <code class="s2">"monokai"</code><code class="p">,</code> <code class="s2">"vscode"</code><code class="p">],</code>&#13;
  <code class="nx">values</code><code class="o">:</code> <code class="p">[</code><code class="s2">"dracula"</code><code class="p">,</code> <code class="s2">"vscode"</code><code class="p">],</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="s2">"dracula"</code><code class="p">,</code>&#13;
<code class="p">});</code>&#13;
<code class="c1">// ^ Argument of type '{ options: string[]; values: string[]; value: string; }'</code>&#13;
<code class="c1">//   is not assignable to parameter of type 'SelectProperties'.</code></pre>&#13;
&#13;
<p>The union types are separated again, without the inclusion of a <code>kind</code> property. This works great for models where the discriminating properties are just a few. If your model has too many distinct properties, and you can afford to add a <code>kind</code> property, use <em>discriminated union types</em> as shown in <a data-type="xref" href="#ch03_item_discriminated_unions">Recipe 3.2</a>.<a data-startref="ix_0803-asciidoc2" data-type="indexterm" id="id572"/><a data-startref="ix_0803-asciidoc1" data-type="indexterm" id="id573"/><a data-startref="ix_0803-asciidoc1a" data-type="indexterm" id="id574"/><a data-startref="ix_0803-asciidoc0" data-type="indexterm" id="id575"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.9 Effectively Using Type Assertions" data-type="sect1"><div class="sect1" id="ch03_item_assertions">&#13;
<h1>3.9 Effectively Using Type Assertions</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id57">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="as keyword, type assertions and" data-type="indexterm" id="ix_1003-asciidoc0"/><a data-primary="type assertions" data-secondary="effective use of" data-type="indexterm" id="ix_1003-asciidoc2"/><a data-primary="type system" data-secondary="type assertions" data-type="indexterm" id="ix_1003-asciidoc3"/><a data-primary="types" data-secondary="narrowing with type assertions" data-type="indexterm" id="ix_1003-asciidoc4"/>Your code produces the correct results, but the types are way too wide. You know &#13;
<span class="keep-together">better!</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id576">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use type assertions to narrow to a smaller set using the <code>as</code> keyword, indicating an unsafe operation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id58">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Think of rolling a die and producing a number between one and six. The JavaScript function is one line, using the Math library. You want to work with a narrowed type, a union of six literal number types indicating the results. However, your operation produces a <code>number</code>, and <code>number</code> is a type too wide for your results:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Dice</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> <code class="o">|</code> <code class="mi">3</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code> <code class="o">|</code> <code class="mi">6</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">rollDice</code><code class="p">()</code><code class="o">:</code> <code class="nx">Dice</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">num</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">6</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>&#13;
  <code class="k">return</code> <code class="nx">num</code><code class="p">;</code>&#13;
<code class="c1">//^ Type 'number' is not assignable to type 'Dice'.(2322)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Since <code>number</code> allows for more values than <code>Dice</code>, TypeScript won’t allow you to narrow the type just by annotating the function signature. This works only if the type is wider, a supertype:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// All dice are numbers</code>&#13;
<code class="kd">function</code> <code class="nx">asNumber</code><code class="p">(</code><code class="nx">dice</code><code class="o">:</code> <code class="nx">Dice</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">dice</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Instead, just like with type predicates from <a data-type="xref" href="#ch03_item_type_predicates">Recipe 3.5</a>, we can tell TypeScript that we know better, by asserting that the type is narrower than expected:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Dice</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> <code class="o">|</code> <code class="mi">3</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code> <code class="o">|</code> <code class="mi">6</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">rollDice</code><code class="p">()</code><code class="o">:</code> <code class="nx">Dice</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">num</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">6</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>&#13;
  <code class="k">return</code> <code class="nx">num</code> <code class="kr">as</code> <code class="nx">Dice</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Just like type predicates, type assertions work only within the supertypes and subtypes of an assumed type. We can either set the value to a wider supertype or change it to a narrower subtype. TypeScript won’t allow us to switch sets:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">asString</code><code class="p">(</code><code class="nx">num</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">num</code> <code class="kr">as</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="c1">//       ^- Conversion of type 'number' to type 'string' may</code>&#13;
<code class="c1">//          be a mistake because neither type sufficiently</code>&#13;
<code class="c1">//          overlaps with the other.</code>&#13;
<code class="c1">//          If this was intentional, convert the expression to 'unknown' first.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Using the <code>as Dice</code> syntax is quite handy. It indicates a type change that we as developers are responsible for. This means that if something turns out wrong, we can easily scan our code for the <code>as</code> keyword and find possible culprits.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><a data-primary="type assertions" data-secondary="type casts versus" data-type="indexterm" id="id577"/>In everyday language, people tend to call type assertions <em>type casts</em>. This arguably comes from similarity to actual, explicit type casts in C, Java, and the like. However, a type assertion is very different from a type cast. A type cast not only changes the set of compatible values but also changes the memory layout and even the values themselves. Casting a floating point number to an integer will cut off the mantissa. A type assertion in TypeScript, on the other hand, changes only the set of compatible values. The value stays the same. It’s called a <em>type assertion</em> because you assert that the type is something either narrower or wider, giving more hints to the type system. So if you are in a discussion on changing types, call them assertions, not casts.</p>&#13;
</div>&#13;
&#13;
<p>Assertions are also often used when you assemble the properties of an object. You know that the shape is going to be of, for example, <code>Person</code>, but you need to set the properties first:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">createDemoPerson</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{}</code> <code class="kr">as</code> <code class="nx">Person</code><code class="p">;</code>&#13;
  <code class="nx">person</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="nx">person</code><code class="p">.</code><code class="nx">age</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">95</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="nx">person</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A type assertion tells TypeScript that the empty object is supposed to be <code>Person</code> at the end. Subsequently, TypeScript allows you to set properties. It’s also an <em>unsafe</em> operation, because you might forget that you set a property and TypeScript would not complain. Even worse, <code>Person</code> might change and get more properties, and you would get no indication at all that you are missing properties:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">profession</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">createDemoPerson</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{}</code> <code class="kr">as</code> <code class="nx">Person</code><code class="p">;</code>&#13;
  <code class="nx">person</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="nx">person</code><code class="p">.</code><code class="nx">age</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">95</code><code class="p">);</code>&#13;
  <code class="c1">// Where's Profession?</code>&#13;
  <code class="k">return</code> <code class="nx">person</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In situations like this, it’s better to opt for a <em>safe</em> object creation. Nothing keeps you from annotating and making sure that you set all the required properties with the assignment:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">createDemoPerson</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">person</code><code class="o">: </code><code class="kr">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">name</code><code class="p">,</code>&#13;
    <code class="nx">age</code><code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">95</code><code class="p">),</code>&#13;
  <code class="p">};</code>&#13;
  <code class="k">return</code> <code class="nx">person</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>While type annotations are safer than type assertions, in situations like <code>rollDice</code> there is no better choice. In other TypeScript scenarios you do have a choice but might want to prefer type assertions, even if you could annotate.</p>&#13;
&#13;
<p>When we use the <code>fetch</code> API, for example, getting JSON data from a backend, we can call <code>fetch</code> and assign the results to an annotated type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">ppl</code><code class="o">: </code><code class="kr">Person</code><code class="p">[]</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/people"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code></pre>&#13;
&#13;
<p><code>res.json()</code> results in <code>any</code>, and everything that is <code>any</code> can be changed to any other type through a type annotation. There is no guarantee that the results are actually <code>Person[]</code>. We can write the same line differently, by asserting that the result is a &#13;
<span class="keep-together"><code>Person[]</code>,</span> narrowing <code>any</code> to something more specific:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">ppl</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/people"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code> <code class="kr">as</code> <code class="nx">Person</code><code class="p">[];</code></pre>&#13;
&#13;
<p>For the type system, this is the same thing, but we can easily scan situations where there might be problems. What if the model in <code>"/api/people"</code> changes? It’s harder to spot errors if we are just looking for annotations. An assertion here is an indicator of an <em>unsafe</em> operation.</p>&#13;
&#13;
<p>What really helps is to think of creating a set of models that works within your application boundaries. The moment you rely on something from the outside, like APIs, or the correct calculation of a number, type assertions can indicate that you’ve crossed the boundary.</p>&#13;
&#13;
<p>Just like using type predicates (see <a data-type="xref" href="#ch03_item_type_predicates">Recipe 3.5</a>), type assertions put the responsibility of a correct type in your hands. Use them wisely.<a data-startref="ix_1003-asciidoc4" data-type="indexterm" id="id578"/><a data-startref="ix_1003-asciidoc3" data-type="indexterm" id="id579"/><a data-startref="ix_1003-asciidoc2" data-type="indexterm" id="id580"/><a data-startref="ix_1003-asciidoc0" data-type="indexterm" id="id581"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.10 Using Index Signatures" data-type="sect1"><div class="sect1" id="ch03_index_signatures">&#13;
<h1>3.10 Using Index Signatures</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id59">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="index signatures" data-type="indexterm" id="ix_0903-asciidoc0"/><a data-primary="keys, defining open set with index signatures" data-type="indexterm" id="ix_0903-asciidoc1"/><a data-primary="type system" data-secondary="index signatures" data-type="indexterm" id="ix_0903-asciidoc2"/>You want to work with objects where you know the type of the values, but you don’t know all the property names up front.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id582">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use index signatures to define an open set of keys but with defined value types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id60">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>There is a style in web APIs where you get collections in the form of a JavaScript object, where the property name is roughly equivalent to a unique identifier and the values have the same shape. This style is great if you are mostly concerned about <em>keys</em>, as a simple <code>Object.keys</code> call gives you all relevant IDs, allowing you to quickly filter and index the values you are looking for.</p>&#13;
&#13;
<p>Let’s think of a performance review across all your websites, where you gather relevant performance metrics and group them by the domain’s name:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">timings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="s2">"fettblog.eu"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">ttfb</code><code class="o">:</code> <code class="mi">300</code><code class="p">,</code>&#13;
    <code class="nx">fcp</code><code class="o">:</code> <code class="mi">1000</code><code class="p">,</code>&#13;
    <code class="nx">si</code><code class="o">:</code> <code class="mi">1200</code><code class="p">,</code>&#13;
    <code class="nx">lcp</code><code class="o">:</code> <code class="mi">1500</code><code class="p">,</code>&#13;
    <code class="nx">tti</code><code class="o">:</code> <code class="mi">1100</code><code class="p">,</code>&#13;
    <code class="nx">tbt</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
  <code class="s2">"typescript-book.com"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">ttfb</code><code class="o">:</code> <code class="mi">400</code><code class="p">,</code>&#13;
    <code class="nx">fcp</code><code class="o">:</code> <code class="mi">1100</code><code class="p">,</code>&#13;
    <code class="nx">si</code><code class="o">:</code> <code class="mi">1100</code><code class="p">,</code>&#13;
    <code class="nx">lcp</code><code class="o">:</code> <code class="mi">2200</code><code class="p">,</code>&#13;
    <code class="nx">tti</code><code class="o">:</code> <code class="mi">1100</code><code class="p">,</code>&#13;
    <code class="nx">tbt</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>If we want to find the domain with the lowest timing for a given metric, we can create a function where we loop over all keys, index each metrics entry, and compare:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">findLowestTiming</code><code class="p">(</code><code class="nx">collection</code><code class="p">,</code> <code class="nx">metric</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">domain</code><code class="o">:</code> <code class="s2">""</code><code class="p">,</code>&#13;
    <code class="nx">value</code><code class="o">:</code> <code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_VALUE</code><code class="p">,</code>&#13;
  <code class="p">};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">domain</code> <code class="k">in</code> <code class="nx">collection</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">timing</code> <code class="o">=</code> <code class="nx">collection</code><code class="p">[</code><code class="nx">domain</code><code class="p">];</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">timing</code><code class="p">[</code><code class="nx">metric</code><code class="p">]</code> <code class="o">&lt;</code> <code class="nx">result</code><code class="p">.</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">result</code><code class="p">.</code><code class="nx">domain</code> <code class="o">=</code> <code class="nx">domain</code><code class="p">;</code>&#13;
      <code class="nx">result</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">timing</code><code class="p">[</code><code class="nx">metric</code><code class="p">];</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">result</code><code class="p">.</code><code class="nx">domain</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As we are good programmers, we want to type our function accordingly so that we make sure we don’t pass any data that doesn’t match our idea of a metric collection. Typing the value for the metrics on the righthand side is pretty straightforward:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Metrics</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">// Time to first byte</code>&#13;
  <code class="nx">ttfb</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="c1">// First contentful paint</code>&#13;
  <code class="nx">fcp</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="c1">// Speed Index</code>&#13;
  <code class="nx">si</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="c1">// Largest contentful paint</code>&#13;
  <code class="nx">lcp</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="c1">// Time to interactive</code>&#13;
  <code class="nx">tti</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="c1">// Total blocking time</code>&#13;
  <code class="nx">tbt</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Defining a shape that has a yet-to-be-defined set of keys is trickier, but TypeScript has a tool for that: index signatures. We can tell TypeScript that we don’t know which property names there are, but we know they will be of type <code>string</code> and they will point to <code>Metrics</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">MetricCollection</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">domain</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">Timings</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>And that’s all we need to type <code>findLowestTiming</code>. We annotate <code>collection</code> with <code>Me⁠tric​Co⁠ll⁠ec⁠ti⁠on</code> and make sure we only pass keys of <code>Metrics</code> for the second parameter:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">findLowestTiming</code><code class="p">(</code>&#13;
  <code class="nx">collection</code><code class="o">:</code> <code class="nx">MetricCollection</code><code class="p">,</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="kr">keyof</code> <code class="nx">Metrics</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">domain</code><code class="o">:</code> <code class="s2">""</code><code class="p">,</code>&#13;
    <code class="nx">value</code><code class="o">:</code> <code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_VALUE</code><code class="p">,</code>&#13;
  <code class="p">};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">domain</code> <code class="k">in</code> <code class="nx">collection</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">timing</code> <code class="o">=</code> <code class="nx">collection</code><code class="p">[</code><code class="nx">domain</code><code class="p">];</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">timing</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">&lt;</code> <code class="nx">result</code><code class="p">.</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">result</code><code class="p">.</code><code class="nx">domain</code> <code class="o">=</code> <code class="nx">domain</code><code class="p">;</code>&#13;
      <code class="nx">result</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">timing</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">result</code><code class="p">.</code><code class="nx">domain</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is great, but there are some caveats. TypeScript allows you to read properties of any string, but it does not do any checks if the property is actually available, so be aware:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">emptySet</code><code class="o">:</code> <code class="nx">MetricCollection</code> <code class="o">=</code> <code class="p">{};</code>&#13;
<code class="kd">let</code> <code class="nx">timing</code> <code class="o">=</code> <code class="nx">emptySet</code><code class="p">[</code><code class="s2">"typescript-cookbook.com"</code><code class="p">].</code><code class="nx">fcp</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code> <code class="c1">// No type errors!</code></pre>&#13;
&#13;
<p>Changing your index signature type to be either <code>Metrics</code> or <code>undefined</code> is a more realistic representation. It says you can index with all possible strings, but there might be no value; this results in a couple more safeguards but is ultimately the right choice:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">MetricCollection</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">domain</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">Metrics</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">findLowestTiming</code><code class="p">(</code>&#13;
  <code class="nx">collection</code><code class="o">:</code> <code class="nx">MetricCollection</code><code class="p">,</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="kr">keyof</code> <code class="nx">Metrics</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">domain</code><code class="o">:</code> <code class="s2">""</code><code class="p">,</code>&#13;
    <code class="nx">value</code><code class="o">:</code> <code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_VALUE</code><code class="p">,</code>&#13;
  <code class="p">};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">domain</code> <code class="k">in</code> <code class="nx">collection</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">timing</code> <code class="o">=</code> <code class="nx">collection</code><code class="p">[</code><code class="nx">domain</code><code class="p">];</code> <code class="c1">// Metrics | undefined</code>&#13;
    <code class="c1">// extra check for undefined values</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">timing</code> <code class="o">&amp;&amp;</code> <code class="nx">timing</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">&lt;</code> <code class="nx">result</code><code class="p">.</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">result</code><code class="p">.</code><code class="nx">domain</code> <code class="o">=</code> <code class="nx">domain</code><code class="p">;</code>&#13;
      <code class="nx">result</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">timing</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">result</code><code class="p">.</code><code class="nx">domain</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">emptySet</code><code class="o">:</code> <code class="nx">MetricCollection</code> <code class="o">=</code> <code class="p">{};</code>&#13;
<code class="c1">// access with optional chaining and nullish coalescing</code>&#13;
<code class="kd">let</code> <code class="nx">timing</code> <code class="o">=</code> <code class="p">(</code><code class="nx">emptySet</code><code class="p">[</code><code class="s2">"typescript-cookbook.com"</code><code class="p">]</code><code class="o">?</code><code class="p">.</code><code class="nx">fcp</code> <code class="o">??</code> <code class="mi">0</code><code class="p">)</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code></pre>&#13;
&#13;
<p>The value being either <code>Metrics</code> or <code>undefined</code> is not exactly like a missing property, but it’s close enough and good enough for this use case. You can read about the nuance between missing properties and undefined values in <a data-type="xref" href="#ch03_item_missing_vs_undefined">Recipe 3.11</a>. <a data-primary="mapped types" data-secondary="index signatures and" data-type="indexterm" id="id583"/>To set the property keys as optional, you tell TypeScript that <code>domain</code> is not the entire set of <code>string</code> but a subset of <code>string</code> with a so-called <em>mapped type</em>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">MetricCollection</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">domain</code> <code class="k">in</code> <code class="kt">string</code><code class="p">]</code><code class="o">?:</code> <code class="nx">Metrics</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>You can define index signatures for everything that is a valid property key: <code>string</code>, <code>number</code>, or <code>symbol</code>, and with <em>mapped types</em> also everything that is a subset of those. For example, you can define a type to index only valid faces of a die:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Throws</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">x</code> <code class="k">in</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> <code class="o">|</code> <code class="mi">3</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code> <code class="o">|</code> <code class="mi">6</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>You can also add properties to your type. Take this <code>ElementCollection</code>, for example, which allows you to index items via a number but also has additional properties for <code>get</code> and <code>filter</code> functions as well as a <code>length</code> property:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ElementCollection</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">y</code><code class="o">:</code> <code class="kt">number</code><code class="p">]</code><code class="o">:</code> <code class="nx">HTMLElement</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">get</code><code class="p">(</code><code class="nx">index</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">HTMLElement</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">length</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">filter</code><code class="p">(</code><code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">element</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">boolean</code><code class="p">)</code><code class="o">:</code> <code class="nx">ElementCollection</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>If you combine your index signatures with other properties, you need to make sure that the broader set of your index signature includes the types from the specific properties. In the previous example there is no overlap between the number index &#13;
<span class="keep-together">signature</span> and the string keys of your other properties, but if you define an index signature of strings that maps to <code>string</code> and want to have a <code>count</code> property of type <code>number</code> next to it, TypeScript will error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">StringDictionary</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">index</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">count</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="c1">// Error: Property 'count' of type 'number' is not assignable</code>&#13;
  <code class="c1">// to 'string' index type 'string'.(2411)</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>And it makes sense: if all string keys point to a string, why would <code>count</code> point to something else? There’s ambiguity, and TypeScript won’t allow this. You would have to widen the type of your index signature to make sure that the smaller set is part of the bigger set:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">StringOrNumberDictionary</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">index</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">count</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code> <code class="c1">// works</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now <code>count</code> subsets both the type from the index signature and the type of the property’s value.</p>&#13;
&#13;
<p>Index signatures and mapped types are powerful tools that allow you to work with web APIs as well as data structures that allow for flexible access to elements. Something that we know and love from JavaScript is now securely typed in TypeScript.<a data-startref="ix_0903-asciidoc2" data-type="indexterm" id="id584"/><a data-startref="ix_0903-asciidoc1" data-type="indexterm" id="id585"/><a data-startref="ix_0903-asciidoc0" data-type="indexterm" id="id586"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.11 Distinguishing Missing Properties &#10;and Undefined Values" data-type="sect1"><div class="sect1" id="ch03_item_missing_vs_undefined">&#13;
<h1>3.11 Distinguishing Missing Properties &#13;
<span class="keep-together">and Undefined Values</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id61">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="exactOptionalPropertyTypes" data-type="indexterm" id="ix_1403-asciidoc0"/><a data-primary="missing properties, undefined values versus" data-type="indexterm" id="ix_1403-asciidoc1"/><a data-primary="properties" data-secondary="distinguishing missing properties and undefined values" data-type="indexterm" id="ix_1403-asciidoc2"/><a data-primary="type system" data-secondary="distinguishing missing properties and undefined values" data-type="indexterm" id="ix_1403-asciidoc3"/><a data-primary="undefined values, missing properties versus" data-type="indexterm" id="ix_1403-asciidoc4"/><a data-primary="values, undefined" data-type="indexterm" id="ix_1403-asciidoc5"/>Missing properties and undefined values are not the same! You will run into situations where this difference matters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id587">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Activate <code>exactOptionalPropertyTypes</code> in <em>tsconfig</em> to enable stricter handling of optional properties.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id62">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Our software has user settings where we can define the user’s language and their preferred color overrides. It’s an additional theme, which means that the basic colors are already set in a <code>"default"</code> style. This means that the user setting for <code>theme</code> is optional: either it is available or it isn’t. We use TypeScript’s optional properties &#13;
<span class="keep-together">for that:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Settings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">language</code><code class="o">:</code> <code class="s2">"en"</code> <code class="o">|</code> <code class="s2">"de"</code> <code class="o">|</code> <code class="s2">"fr"</code><code class="p">;</code>&#13;
  <code class="nx">theme</code><code class="o">?:</code> <code class="s2">"dracula"</code> <code class="o">|</code> <code class="s2">"monokai"</code> <code class="o">|</code> <code class="s2">"github"</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>With <code>strictNullChecks</code> active, accessing <code>theme</code> somewhere in your code widens the number of possible values. You have not only the three theme overrides but also the possibility of <code>undefined</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">applySettings</code><code class="p">(</code><code class="nx">settings</code><code class="o">:</code> <code class="nx">Settings</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// theme is "dracula" | "monokai" | "github" | undefined</code>&#13;
  <code class="kr">const</code> <code class="nx">theme</code> <code class="o">=</code> <code class="nx">settings</code><code class="p">.</code><code class="nx">theme</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is great behavior, as you really want to make sure that this property is set; otherwise, it could result in runtime errors. TypeScript adding <code>undefined</code> to the list of possible values of optional properties is good, but it doesn’t entirely mirror the behavior of JavaScript. <em>Optional properties</em> means that this key is missing from the object, which is subtle but important. For example, a missing key would return <code>false</code> in property checks:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">getTheme</code><code class="p">(</code><code class="nx">settings</code><code class="o">:</code> <code class="nx">Settings</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="s1">'theme'</code> <code class="k">in</code> <code class="nx">settings</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// only true if the property is set!</code>&#13;
    <code class="k">return</code> <code class="nx">settings</code><code class="p">.</code><code class="nx">theme</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="s1">'default'</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">settings</code><code class="o">:</code> <code class="nx">Settings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">language</code><code class="o">:</code> <code class="s2">"de"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">settingsUndefinedTheme</code><code class="o">:</code> <code class="nx">Settings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">language</code><code class="o">:</code> <code class="s2">"de"</code><code class="p">,</code>&#13;
  <code class="nx">theme</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">getTheme</code><code class="p">(</code><code class="nx">settings</code><code class="p">))</code> <code class="c1">// "default"</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">getTheme</code><code class="p">(</code><code class="nx">settingsUndefinedTheme</code><code class="p">))</code> <code class="c1">// undefined</code></pre>&#13;
&#13;
<p>Here, we get entirely different results even though the two settings objects seem similar. What’s worse is that an <code>undefined</code> theme is a value we don’t consider valid. TypeScript doesn’t lie to us, though, as it’s fully aware that an <code>in</code> check only tells us if the property is available. The possible return values of <code>getTheme</code> include <code>undefined</code> &#13;
<span class="keep-together">as well:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Fn</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">getTheme</code><code class="p">;</code>&#13;
<code class="c1">// type Fn = (settings: Settings)</code>&#13;
<code class="c1">//   =&gt; "dracula" | "monokai" | "github" | "default" | undefined</code></pre>&#13;
&#13;
<p><a data-primary="nullish coalescing" data-type="indexterm" id="id588"/>And there are arguably better checks to see if the correct values are here. With <em>nullish coalescing</em> the preceding code becomes:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">getTheme</code><code class="p">(</code><code class="nx">settings</code><code class="o">:</code> <code class="nx">Settings</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">settings</code><code class="p">.</code><code class="nx">theme</code> <code class="o">??</code> <code class="s2">"default"</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Fn</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">getTheme</code><code class="p">;</code>&#13;
<code class="c1">// type Fn = (settings: Settings)</code>&#13;
<code class="c1">//   =&gt; "dracula" | "monokai" | "github" | "default"</code></pre>&#13;
&#13;
<p>Still, <code>in</code> checks are valid and used by developers, and the way TypeScript interprets optional properties can cause ambiguity. Reading <code>undefined</code> from an optional property is correct, but setting optional properties to <code>undefined</code> isn’t. By switching on <code>exactOptionalPropertyTypes</code>, TypeScript changes this behavior:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// exactOptionalPropertyTypes is true</code>&#13;
<code class="kr">const</code> <code class="nx">settingsUndefinedTheme</code><code class="o">:</code> <code class="nx">Settings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">language</code><code class="o">:</code> <code class="s2">"de"</code><code class="p">,</code>&#13;
  <code class="nx">theme</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// Error: Type '{ language: "de"; theme: undefined; }' is</code>&#13;
<code class="c1">// not assignable to type 'Settings' with 'exactOptionalPropertyTypes: true'.</code>&#13;
<code class="c1">// Consider adding 'undefined' to the types of the target's properties.</code>&#13;
<code class="c1">// Types of property 'theme' are incompatible.</code>&#13;
<code class="c1">// Type 'undefined' is not assignable to type</code>&#13;
<code class="c1">// '"dracula" | "monokai" | "github"'.(2375)</code></pre>&#13;
&#13;
<p><code>exactOptionalPropertyTypes</code> aligns TypeScript’s behavior even more to JavaScript. This flag is not within <code>strict</code> mode, however, so you need to set it yourself if you encounter problems like this.<a data-startref="ix_1403-asciidoc5" data-type="indexterm" id="id589"/><a data-startref="ix_1403-asciidoc4" data-type="indexterm" id="id590"/><a data-startref="ix_1403-asciidoc3" data-type="indexterm" id="id591"/><a data-startref="ix_1403-asciidoc2" data-type="indexterm" id="id592"/><a data-startref="ix_1403-asciidoc1" data-type="indexterm" id="id593"/><a data-startref="ix_1403-asciidoc0" data-type="indexterm" id="id594"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.12 Working with Enums" data-type="sect1"><div class="sect1" id="ch03_item_enums">&#13;
<h1>3.12 Working with Enums</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id63">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="constants, enums and" data-type="indexterm" id="ix_1103-asciidoc0"/><a data-primary="enums" data-secondary="working with" data-type="indexterm" id="ix_1103-asciidoc1"/><a data-primary="named constants, enums and" data-type="indexterm" id="ix_1103-asciidoc2"/><a data-primary="type system" data-secondary="enums" data-type="indexterm" id="ix_1103-asciidoc3"/>TypeScript enums are a nice abstraction, but they seem to behave very differently compared to the rest of the type system.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id595">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use them sparingly, prefer <code>const</code> enums, know their caveats, and maybe choose union types instead.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id64">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Enums in TypeScript allow a developer to define a set of named constants, which makes it easier to document intent or create a set of distinct cases.</p>&#13;
&#13;
<p>They’re defined using the <code>enum</code> keyword:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">enum</code> <code class="nx">Direction</code> <code class="p">{</code>&#13;
  <code class="nx">Up</code><code class="p">,</code>&#13;
  <code class="nx">Down</code><code class="p">,</code>&#13;
  <code class="nx">Left</code><code class="p">,</code>&#13;
  <code class="nx">Right</code><code class="p">,</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Like classes, they contribute to the value and type namespaces, which means you can use <code>Direction</code> when annotating types or in your JavaScript code as values:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// used as type</code>&#13;
<code class="kd">function</code> <code class="nx">move</code><code class="p">(</code><code class="nx">direction</code><code class="o">:</code> <code class="nx">Direction</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// used as value</code>&#13;
<code class="nx">move</code><code class="p">(</code><code class="nx">Direction</code><code class="p">.</code><code class="nx">Up</code><code class="p">);</code></pre>&#13;
&#13;
<p>They are a syntactic extension to JavaScript, which means they not only work on a type system level but also emit JavaScript code:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">var</code> <code class="nx">Direction</code><code class="p">;</code>&#13;
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">Direction</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">Direction</code><code class="p">[</code><code class="nx">Direction</code><code class="p">[</code><code class="s2">"Up"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Up"</code><code class="p">;</code>&#13;
    <code class="nx">Direction</code><code class="p">[</code><code class="nx">Direction</code><code class="p">[</code><code class="s2">"Down"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Down"</code><code class="p">;</code>&#13;
    <code class="nx">Direction</code><code class="p">[</code><code class="nx">Direction</code><code class="p">[</code><code class="s2">"Left"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Left"</code><code class="p">;</code>&#13;
    <code class="nx">Direction</code><code class="p">[</code><code class="nx">Direction</code><code class="p">[</code><code class="s2">"Right"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">3</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Right"</code><code class="p">;</code>&#13;
<code class="p">})(</code><code class="nx">Direction</code> <code class="o">||</code> <code class="p">(</code><code class="nx">Direction</code> <code class="o">=</code> <code class="p">{}));</code></pre>&#13;
&#13;
<p>When you define your enum as a <code>const enum</code>, TypeScript tries to substitute the usage with the actual values, getting rid of the emitted code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="kr">enum</code> <code class="nx">Direction</code> <code class="p">{</code>&#13;
  <code class="nx">Up</code><code class="p">,</code>&#13;
  <code class="nx">Down</code><code class="p">,</code>&#13;
  <code class="nx">Left</code><code class="p">,</code>&#13;
  <code class="nx">Right</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// When having a const enum, TypeScript</code>&#13;
<code class="c1">// transpiles move(Direction.Up) to this:</code>&#13;
<code class="nx">move</code><code class="p">(</code><code class="mi">0</code> <code class="cm">/* Direction.Up */</code><code class="p">);</code></pre>&#13;
&#13;
<p>TypeScript supports both string and numeric enums, and both variants behave &#13;
<span class="keep-together">very differently.</span></p>&#13;
&#13;
<p>TypeScript enums are by default numeric, which means that every variant of that enum has a numeric value assigned, starting at 0. The starting point and actual values of enum variants can be a default or user defined:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Default</code>&#13;
<code class="kr">enum</code> <code class="nx">Direction</code> <code class="p">{</code>&#13;
  <code class="nx">Up</code><code class="p">,</code> <code class="c1">// 0</code>&#13;
  <code class="nx">Down</code><code class="p">,</code> <code class="c1">// 1</code>&#13;
  <code class="nx">Left</code><code class="p">,</code> <code class="c1">// 2</code>&#13;
  <code class="nx">Right</code><code class="p">,</code> <code class="c1">// 3</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">enum</code> <code class="nx">Direction</code> <code class="p">{</code>&#13;
  <code class="nx">Up</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>    <code class="c1">// 1</code>&#13;
  <code class="nx">Down</code><code class="p">,</code>      <code class="c1">// 2</code>&#13;
  <code class="nx">Left</code><code class="p">,</code>      <code class="c1">// 3</code>&#13;
  <code class="nx">Right</code> <code class="o">=</code> <code class="mi">5</code><code class="p">,</code> <code class="c1">// 5</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>In a way, numeric enums define the same set as a union type of numbers:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Direction</code> <code class="o">=</code> <code class="mi">0</code> <code class="o">|</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> <code class="o">|</code> <code class="mi">3</code><code class="p">;</code></pre>&#13;
&#13;
<p>But there are significant differences. Where a union type of numbers allows only a strictly defined set of values, a numeric enum allows for every value to be assigned:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">move</code><code class="p">(</code><code class="nx">direction</code><code class="o">:</code> <code class="nx">Direction</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
&#13;
<code class="nx">move</code><code class="p">(</code><code class="mi">30</code><code class="p">);</code><code class="c1">// This is  ok!</code></pre>&#13;
&#13;
<p>The reason is that there is a use case of implementing flags with numeric enums:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Possible traits of a person, can be multiple</code>&#13;
<code class="kr">enum</code> <code class="nx">Traits</code> <code class="p">{</code>&#13;
  <code class="nx">None</code><code class="p">,</code>              <code class="c1">// 0000</code>&#13;
  <code class="nx">Friendly</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>      <code class="c1">// 0001 or 1 &lt;&lt; 0</code>&#13;
  <code class="nx">Mean</code>     <code class="o">=</code> <code class="mi">1</code> <code class="o">&lt;&lt;</code> <code class="mi">1</code><code class="p">,</code> <code class="c1">// 0010</code>&#13;
  <code class="nx">Funny</code>    <code class="o">=</code> <code class="mi">1</code> <code class="o">&lt;&lt;</code> <code class="mi">2</code><code class="p">,</code> <code class="c1">// 0100</code>&#13;
  <code class="nx">Boring</code>   <code class="o">=</code> <code class="mi">1</code> <code class="o">&lt;&lt;</code> <code class="mi">3</code><code class="p">,</code> <code class="c1">// 1000</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// (0010 | 0100) === 0110</code>&#13;
<code class="kd">let</code> <code class="nx">aPersonsTraits</code> <code class="o">=</code> <code class="nx">Traits</code><code class="p">.</code><code class="nx">Mean</code> <code class="o">|</code> <code class="nx">Traits</code><code class="p">.</code><code class="nx">Funny</code><code class="p">;</code>&#13;
&#13;
<code class="k">if</code> <code class="p">((</code><code class="nx">aPersonsTraits</code> <code class="o">&amp;</code> <code class="nx">Traits</code><code class="p">.</code><code class="nx">Mean</code><code class="p">)</code> <code class="o">===</code> <code class="nx">Traits</code><code class="p">.</code><code class="nx">Mean</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// Person is mean, amongst other things</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Enums provide syntactic sugar for this scenario. To make it easier for the compiler to see which values are allowed, TypeScript expands compatible values for numeric enums to the entire set of <code>number</code>.</p>&#13;
&#13;
<p>Enum variants can also be initialized with strings instead of numbers, effectively creating a string enum. If you choose to write a string enum, you have to define each variant, as strings can’t be incremented:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">enum</code> <code class="nx">Status</code> <code class="p">{</code>&#13;
  <code class="nx">Admin</code> <code class="o">=</code> <code class="s2">"Admin"</code><code class="p">,</code>&#13;
  <code class="nx">User</code> <code class="o">=</code> <code class="s2">"User"</code><code class="p">,</code>&#13;
  <code class="nx">Moderator</code> <code class="o">=</code> <code class="s2">"Moderator"</code><code class="p">,</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>String enums are more restrictive than numeric enums. They only allow you to pass actual variants of the enum rather than the entire set of strings. However, they don’t allow you to pass the string equivalent:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">closeThread</code><code class="p">(</code><code class="nx">threadId</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">status</code><code class="o">:</code> <code class="nx">Status</code><code class="p">)</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">closeThread</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="s2">"Admin"</code><code class="p">);</code>&#13;
<code class="c1">//              ^-- Argument of type '"Admin"' is not assignable to</code>&#13;
<code class="c1">//                  parameter of type 'Status'</code>&#13;
&#13;
&#13;
<code class="nx">closeThread</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="nx">Status</code><code class="p">.</code><code class="nx">Admin</code><code class="p">);</code> <code class="c1">// This works</code></pre>&#13;
&#13;
<p><a data-primary="nominal types" data-secondary="enums as" data-type="indexterm" id="id596"/>Unlike every other type in TypeScript, string enums are <em>nominal</em> types. This also means two enums with the same set of values are not compatible with each other:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">enum</code> <code class="nx">Roles</code> <code class="p">{</code>&#13;
  <code class="nx">Admin</code> <code class="o">=</code> <code class="s2">"Admin"</code><code class="p">,</code>&#13;
  <code class="nx">User</code> <code class="o">=</code> <code class="s2">"User"</code><code class="p">,</code>&#13;
  <code class="nx">Moderator</code> <code class="o">=</code> <code class="s2">"Moderator"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">closeThread</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="nx">Roles</code><code class="p">.</code><code class="nx">Admin</code><code class="p">);</code>&#13;
<code class="c1">//              ^-- Argument of type 'Roles.Admin' is not</code>&#13;
<code class="c1">//                  assignable to parameter of type 'Status'</code></pre>&#13;
&#13;
<p>This can be a source of confusion and frustration, especially when values come from another source that doesn’t have knowledge of your enums but does have the correct string values.</p>&#13;
&#13;
<p>Use enums wisely and know their caveats. Enums are great for feature flags and a set of named constants where you intentionally want people to use the data structure instead of just values.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Since TypeScript 5.0, the interpretation of number enums has become much stricter; now they behave, like string enums, as nominal types and don’t include the entire set of numbers as values. You still might find codebases that rely on the unique features of pre-5.0 number enums, so be aware!</p>&#13;
</div>&#13;
&#13;
<p>Also try to prefer <code>const</code> enums wherever possible, as non-<code>const</code> enums can add size to your codebase that might be redundant. I have seen projects with more than two thousand flags in a non-<code>const</code> enum, resulting in huge tooling overhead, compile time overhead, and subsequently, runtime overhead.</p>&#13;
&#13;
<p><a data-primary="union types" data-secondary="as alternative to enums" data-type="indexterm" id="ix_1103-asciidoc4"/>Or, don’t use them at all. A simple union type works similarly and is much more aligned with the rest of the type system:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Status</code> <code class="o">=</code> <code class="s2">"Admin"</code> <code class="o">|</code> <code class="s2">"User"</code> <code class="o">|</code> <code class="s2">"Moderator"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">closeThread</code><code class="p">(</code><code class="nx">threadId</code><code class="o">:</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">status</code><code class="o">:</code> <code class="nx">Status</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">closeThread</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="s2">"Admin"</code><code class="p">);</code> <code class="c1">// All good</code></pre>&#13;
&#13;
<p>You get all the benefits from enums such as proper tooling and type safety without going the extra round and risking outputting code that you don’t want. It also becomes clearer what you need to pass and where to get the value from.</p>&#13;
&#13;
<p>If you want to write your code enum-style, with an object and a named identifier, a <code>const</code> object with a <code>Values</code> helper type might just give you the desired behavior and is <em>much</em> closer to JavaScript. The same technique is also applicable to string unions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Direction</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Up</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>&#13;
  <code class="nx">Down</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
  <code class="nx">Left</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">Right</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>&#13;
<code class="p">}</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Get to the const values of Direction</code>&#13;
<code class="kr">type</code> <code class="nx">Direction</code> <code class="o">=</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">Direction</code><code class="p">)[</code><code class="kr">keyof</code> <code class="k">typeof</code> <code class="nx">Direction</code><code class="p">];</code>&#13;
&#13;
<code class="c1">// (typeof Direction)[keyof typeof Direction] yields 0 | 1 | 2 | 3</code>&#13;
<code class="kd">function</code> <code class="nx">move</code><code class="p">(</code><code class="nx">direction</code><code class="o">:</code> <code class="nx">Direction</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">move</code><code class="p">(</code><code class="mi">30</code><code class="p">);</code> <code class="c1">// This breaks!</code>&#13;
&#13;
<code class="nx">move</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code> <code class="c1">//This works!</code>&#13;
&#13;
<code class="nx">move</code><code class="p">(</code><code class="nx">Direction</code><code class="p">.</code><code class="nx">Left</code><code class="p">);</code> <code class="c1">// This also works!</code></pre>&#13;
&#13;
<p>This line is particularly interesting:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// = 0 | 1 | 2 | 3</code>&#13;
<code class="kr">type</code> <code class="nx">Direction</code> <code class="o">=</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">Direction</code><code class="p">)[</code><code class="kr">keyof</code> <code class="k">typeof</code> <code class="nx">Direction</code><code class="p">];</code></pre>&#13;
&#13;
<p>A few things happen that are not that usual:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We declare a type with the same name as a value. This is possible because TypeScript has distinct value and type namespaces.</p>&#13;
</li>&#13;
<li>&#13;
<p>Using the <code>typeof</code> operator, we grab the type from <code>Direction</code>. As <code>Direction</code> is in <em>const context</em>, we get the literal type.</p>&#13;
</li>&#13;
<li>&#13;
<p>We index the type of <code>Direction</code> with its own keys, leaving us all the values on the righthand side of the object: <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>. In short: a union type of numbers.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Using union types leaves no surprises:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You <em>know</em> what code you end up with within the output.</p>&#13;
</li>&#13;
<li>&#13;
<p>You don’t end up with changed behavior because somebody decides to go from a string enum to a numeric enum.</p>&#13;
</li>&#13;
<li>&#13;
<p>You have type safety where you need it.</p>&#13;
</li>&#13;
<li>&#13;
<p>You give your colleagues and users the same conveniences as provided by enums.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>But to be fair, a simple string union type does just what you need: type safety, autocomplete, and predictable behavior<a data-startref="ix_1103-asciidoc4" data-type="indexterm" id="id597"/>.<a data-startref="ix_1103-asciidoc3" data-type="indexterm" id="id598"/><a data-startref="ix_1103-asciidoc2" data-type="indexterm" id="id599"/><a data-startref="ix_1103-asciidoc1" data-type="indexterm" id="id600"/><a data-startref="ix_1103-asciidoc0" data-type="indexterm" id="id601"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.13 Defining Nominal Types in a Structural Type System" data-type="sect1"><div class="sect1" id="ch03_item_nominal">&#13;
<h1>3.13 Defining Nominal Types in a Structural Type System</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id65">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="nominal types" data-secondary="defining in a structural type system" data-type="indexterm" id="ix_1203-asciidoc0"/><a data-primary="structural typing" data-type="indexterm" id="ix_1203-asciidoc1"/><a data-primary="type system" data-secondary="defining nominal types in a structural type system" data-type="indexterm" id="ix_1203-asciidoc2"/>Your application has several types that are aliases for the same primitive type but with entirely different semantics. Structural typing treats them the same, but it shouldn’t!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id602">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use wrapping classes or create an intersection of your primitive type with a literal object type and use this to differentiate two integers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id66">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>TypeScript’s type system is structural. This means that if two types have a similar shape, values of this type are compatible with each other:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Student</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">acceptsPerson</code><code class="p">(</code><code class="nx">person</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">student</code><code class="o">:</code> <code class="nx">Student</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Hannah"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">27</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">acceptsPerson</code><code class="p">(</code><code class="nx">student</code><code class="p">);</code> <code class="c1">// all ok</code></pre>&#13;
&#13;
<p>JavaScript relies heavily on object literals, and TypeScript tries to infer the type or <em>shape</em> of those literals. A structural type system makes a lot of sense in this scenario, as values can come from anywhere and need to be compatible with interface and type definitions.</p>&#13;
&#13;
<p>However, there are situations where you need to be more definitive with your types. For object types, we learned about techniques like <em>discriminated unions</em> with the <code>kind</code> property in <a data-type="xref" href="#ch03_item_discriminated_unions">Recipe 3.2</a>, or <em>exclusive or</em> with “optional <code>never</code>" in <a data-type="xref" href="#ch03_item_optional_never">Recipe 3.8</a>. <code>string</code> enums are also nominal, as we see in <a data-type="xref" href="#ch03_item_enums">Recipe 3.12</a>.</p>&#13;
&#13;
<p>Those measurements are good enough for object types and enums, but they don’t solve the problem if you have two independent types that use the same set of values as primitive types. What if your eight-digit account number and your balance all point to the <code>number</code> type and you mix them up? Getting an eight-figure number on your balance sheet is a nice surprise, but it’s likely not correct.</p>&#13;
&#13;
<p>Or perhaps you need to validate user input strings and want to make sure that you carry around only the validated user input in your program, not falling back to the original, probably unsafe, string.</p>&#13;
&#13;
<p>TypeScript allows you to mimic nominal types within the type system to get more security. The trick is also to separate the sets of possible values with distinct properties just enough to ensure the same values don’t fall into the same set.</p>&#13;
&#13;
<p>One way to achieve this would be wrapping classes. Instead of working with the values directly, we wrap each value in a class. With a <code>private kind</code> property we make sure they don’t overlap:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Balance</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="nx">kind</code> <code class="o">=</code> <code class="s2">"balance"</code><code class="p">;</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">AccountNumber</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="nx">kind</code> <code class="o">=</code> <code class="s2">"account"</code><code class="p">;</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What’s interesting here is that since we use <code>private</code> properties, TypeScript will differentiate between the two classes. Right now, both <code>kind</code> properties are of type <code>string</code>. Even though they feature a different value, they can be changed internally. But classes work differently. If <code>private</code> or <code>protected</code> members are present, TypeScript considers two types compatible if they originate from the same declaration. Otherwise, they aren’t considered compatible.</p>&#13;
&#13;
<p>This allows us to refine this pattern with a more general approach. Instead of defining a <code>kind</code> member and setting it to a value, we define a <code>_nominal</code> member in each class declaration that is of type <code>void</code>. This separates both classes just enough but keeps us from using <code>_nominal</code> in just any way. <code>void</code> only allows us to set <code>_nominal</code> to &#13;
<span class="keep-together"><code>undefined</code>,</span> and <code>undefined</code> is a falsy, and thus highly useless:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Balance</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="nx">_nominal</code><code class="o">:</code> <code class="k">void</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">AccountNumber</code> <code class="p">{</code>&#13;
  <code class="kr">private</code> <code class="nx">_nominal</code><code class="o">:</code> <code class="k">void</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">value</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">account</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">AccountNumber</code><code class="p">(</code><code class="mi">12345678</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">balance</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Balance</code><code class="p">(</code><code class="mi">10000</code><code class="p">);</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">acceptBalance</code><code class="p">(</code><code class="nx">balance</code><code class="o">:</code> <code class="nx">Balance</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">acceptBalance</code><code class="p">(</code><code class="nx">balance</code><code class="p">);</code> <code class="c1">// ok</code>&#13;
<code class="nx">acceptBalance</code><code class="p">(</code><code class="nx">account</code><code class="p">);</code>&#13;
<code class="c1">// ^ Argument of type 'AccountNumber' is not</code>&#13;
<code class="c1">//   assignable to parameter of type 'Balance'.</code>&#13;
<code class="c1">//   Types have separate declarations of a</code>&#13;
<code class="c1">//    private property '_nominal'.(2345)</code></pre>&#13;
&#13;
<p>We can now differentiate between two types that would have the same set of values. The only downside to this approach is that we wrap the original type, which means that every time we want to work with the original value, we need to unwrap it.</p>&#13;
&#13;
<p>A different way to mimic nominal types is to intersect the primitive type with a &#13;
<span class="keep-together">branded</span> object type with a <code>kind</code> property. This way, we retain all the operations from the original type, but we need to require type assertions to tell TypeScript that we want to use those types differently.</p>&#13;
&#13;
<p>As we learned in <a data-type="xref" href="#ch03_item_assertions">Recipe 3.9</a>, we can safely assert another type if it is a subtype or supertype of the original:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Credits</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">_kind</code><code class="o">:</code> <code class="s2">"credits"</code> <code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">AccountNumber</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">_kind</code><code class="o">:</code> <code class="s2">"accountNumber"</code> <code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">account</code> <code class="o">=</code> <code class="mi">12345678</code> <code class="kr">as</code> <code class="nx">AccountNumber</code><code class="p">;</code>&#13;
<code class="kd">let</code> <code class="nx">balance</code> <code class="o">=</code> <code class="mi">10000</code> <code class="kr">as</code> <code class="nx">Credits</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">amount</code> <code class="o">=</code> <code class="mi">3000</code> <code class="kr">as</code> <code class="nx">Credits</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">increase</code><code class="p">(</code><code class="nx">balance</code><code class="o">:</code> <code class="nx">Credits</code><code class="p">,</code> <code class="nx">amount</code><code class="o">:</code> <code class="nx">Credits</code><code class="p">)</code><code class="o">:</code> <code class="nx">Credits</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code><code class="nx">balance</code> <code class="o">+</code> <code class="nx">amount</code><code class="p">)</code> <code class="kr">as</code> <code class="nx">Credits</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">balance</code> <code class="o">=</code> <code class="nx">increase</code><code class="p">(</code><code class="nx">balance</code><code class="p">,</code> <code class="nx">amount</code><code class="p">);</code>&#13;
<code class="nx">balance</code> <code class="o">=</code> <code class="nx">increase</code><code class="p">(</code><code class="nx">balance</code><code class="p">,</code> <code class="nx">account</code><code class="p">);</code>&#13;
<code class="c1">// ^ Argument of type 'AccountNumber' is not</code>&#13;
<code class="c1">//   assignable to parameter of type 'Credits'.</code>&#13;
<code class="c1">//   Type 'AccountNumber' is not assignable to type '{ _kind: "credits"; }'.</code>&#13;
<code class="c1">//   Types of property '_kind' are incompatible.</code>&#13;
<code class="c1">//   Type '"accountNumber"' is not assignable to type '"credits"'.(2345)</code></pre>&#13;
&#13;
<p>Also note that the addition of <code>balance</code> and <code>amount</code> still works as originally intended but produces a number again. This is why we need to add another assertion:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">balance</code> <code class="o">+</code> <code class="nx">amount</code><code class="p">;</code> <code class="c1">// result is number</code>&#13;
<code class="kr">const</code> <code class="nx">credits</code> <code class="o">=</code> <code class="p">(</code><code class="nx">balance</code> <code class="o">+</code> <code class="nx">amount</code><code class="p">)</code> <code class="kr">as</code> <code class="nx">Credits</code><code class="p">;</code> <code class="c1">// credits is Credits</code></pre>&#13;
&#13;
<p>Both approaches have their advantages and disadvantages, and whether you prefer one or the other mostly depends on your scenario. Both approaches are workarounds and techniques developed by the community based on their understanding of the type system’s behavior.</p>&#13;
&#13;
<p>There are discussions on the <a href="https://oreil.ly/XxmUV">TypeScript issue tracker on GitHub</a> about opening the type system for nomimal types, and the possibility is constantly under investigation. One idea is to use the <code>unique</code> keyword from Symbols to differentiate:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Hypothetical code, this does not work!</code>&#13;
<code class="kr">type</code> <code class="nx">Balance</code> <code class="o">=</code> <code class="nx">unique</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="kr">type</code> <code class="nx">AccountNumber</code> <code class="o">=</code> <code class="nx">unique</code> <code class="kt">number</code><code class="p">;</code></pre>&#13;
&#13;
<p>As time of writing, this idea—and many others—remains a future possibility.<a data-startref="ix_1203-asciidoc2" data-type="indexterm" id="id603"/><a data-startref="ix_1203-asciidoc1" data-type="indexterm" id="id604"/><a data-startref="ix_1203-asciidoc0" data-type="indexterm" id="id605"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="3.14 Enabling Loose Autocomplete for String Subsets" data-type="sect1"><div class="sect1" id="ch03_item_loose_autocomplete">&#13;
<h1>3.14 Enabling Loose Autocomplete for String Subsets</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id67">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="APIs" data-secondary="enabling loose autocomplete for string subsets" data-type="indexterm" id="ix_1303-asciidoc0"/><a data-primary="autocomplete" data-type="indexterm" id="ix_1303-asciidoc1"/><a data-primary="string literals" data-type="indexterm" id="ix_1303-asciidoc2"/><a data-primary="type system" data-secondary="enabling loose autocomplete for string subsets" data-type="indexterm" id="ix_1303-asciidoc3"/>Your API allows for any string to be passed, but you still want to show a couple of string values for autocomplete.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id68">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="string &amp; {}" data-type="indexterm" id="ix_1303-asciidoc4"/>Add <code>string &amp; {}</code> to your union type of string literals.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id69">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Let’s say you define an API for access to a content management system. There are predefined content types like <code>post</code>, <code>page</code>, and <code>asset</code>, but developers can define their own.</p>&#13;
&#13;
<p>You create a <code>retrieve</code> function with a single parameter, the content type, that allows entries to be loaded:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Entry</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="c1">// tbd.</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">retrieve</code><code class="p">(</code><code class="nx">contentType</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Entry</code><code class="p">[]</code> <code class="p">{</code>&#13;
    <code class="c1">// tbd.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This works well enough, but you want to give your users a hint on the default options for content type. A possibility is to create a helper type that lists all predefined content types as string literals in a union with <code>string</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ContentType</code> <code class="o">=</code> <code class="s2">"post"</code> <code class="o">|</code> <code class="s2">"page"</code> <code class="o">|</code> <code class="s2">"asset"</code> <code class="o">|</code> <code class="kt">string</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">retrieve</code><code class="p">(</code><code class="nx">content</code><code class="o">:</code> <code class="nx">ContentType</code><code class="p">)</code><code class="o">:</code> <code class="nx">Entry</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="c1">// tbd</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This describes your situation very well but comes with a downside: <code>post</code>, <code>page</code>, and  <code>asset</code> are subtypes of <code>string</code>, so putting them in a union <em>with</em> <code>string</code> effectively swallows the detailed information into the broader set.</p>&#13;
&#13;
<p>This means you don’t get statement completion hints via your editor, as you can see in <a data-type="xref" href="#img-no-complete">Figure 3-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-no-complete">&#13;
<img alt="tscb 0303" src="assets/tscb_0303.png"/>&#13;
<h6><span class="label">Figure 3-3. </span>TypeScript widens <code>ContentType</code> to the entire set of <code>string</code>, thus swallowing autocomplete information</h6>&#13;
</div></figure>&#13;
&#13;
<p>To retain autocomplete information and preserve the literal types, we need to intersect <code>string</code> with the empty object type <code>{}</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ContentType</code> <code class="o">=</code> <code class="s2">"post"</code> <code class="o">|</code> <code class="s2">"page"</code> <code class="o">|</code> <code class="s2">"asset"</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">&amp;</code> <code class="p">{};</code></pre>&#13;
&#13;
<p>The effect of this change is more subtle. It doesn’t alter the number of compatible values to <code>ContentType</code>, but it will set TypeScript into a mode that prevents subtype reduction and preserves the literal types.</p>&#13;
&#13;
<p>You can see the effect in <a data-type="xref" href="#img-yes-complete">Figure 3-4</a>, where <code>ContentType</code> is not reduced to <code>string</code>, and therefore all literal values are available for statement completion in the text editor.</p>&#13;
&#13;
<figure><div class="figure" id="img-yes-complete">&#13;
<img alt="tscb 0304" src="assets/tscb_0304.png"/>&#13;
<h6><span class="label">Figure 3-4. </span>Intersecting <code>string</code> with the empty object retains statement completion hints</h6>&#13;
</div></figure>&#13;
&#13;
<p>Still, every string is a valid <code>ContentType</code>; it just changes the developer experience of your API and gives hints where needed.</p>&#13;
&#13;
<p>This technique is used by popular libraries like <a href="https://oreil.ly/lwtC5">CSSType</a> or the <a href="https://oreil.ly/epbLV">Definitely Typed type definitions for React</a><a data-startref="ix_1303-asciidoc4" data-type="indexterm" id="id606"/>.<a data-startref="ix_1303-asciidoc3" data-type="indexterm" id="id607"/><a data-startref="ix_1303-asciidoc2" data-type="indexterm" id="id608"/><a data-startref="ix_1303-asciidoc1" data-type="indexterm" id="id609"/><a data-startref="ix_1303-asciidoc0" data-type="indexterm" id="id610"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id559"><sup><a href="ch03.html#id559-marker">1</a></sup> For example, the Rust Programming Language has been lauded for its error handling.</p><p data-type="footnote" id="id571"><sup><a href="ch03.html#id571-marker">2</a></sup> Shout-out to Dan Vanderkam who was first to call this technique “optional never” on his fantastic <a href="https://effectivetypescript.com"><em>Effective TypeScript</em> blog</a>.</p></div></div></section></body></html>