- en: Chapter 7\. Argo CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about Tekton and other engines such as
    GitHub Actions to implement the continuous integration (CI) part of a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although CI is important because it’s where you build the application and check
    that nothing has been broken (running unit tests, component tests, etc.), there
    is still a missing part: how to deploy this application to an environment (a Kubernetes
    cluster) using the GitOps methodology and not creating a script running `kubectl`/`helm`
    commands.'
  prefs: []
  type: TYPE_NORMAL
- en: As Daniel Bryant puts it, “If you weren’t using SSH in the past to deploy your
    application in production, don’t use `kubectl` to do it in Kubernetes.”
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll introduce you to Argo CD, a declarative, GitOps continuous
    delivery (CD) tool for Kubernetes. In the first part of the section, we’ll see
    the deployment of an application using Argo CD (Recipes [7.1](#recipe_7_1) and
    [7.2](#recipe_7_2)).
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD not only supports the deployment of plain Kubernetes manifests, but
    also the deployment of Kustomize projects ([Recipe 7.3](#recipe_7_3)) and Helm
    projects ([Recipe 7.4](#recipe_7_4)).
  prefs: []
  type: TYPE_NORMAL
- en: A typical operation done in Kubernetes is a rolling update to a new version
    of the container, and Argo CD integrates with another tool to make this process
    smooth ([Recipe 7.5](#recipe_7_5)).
  prefs: []
  type: TYPE_NORMAL
- en: Delivering complex applications might require some orchestration on when and
    how the application must be deployed and released (Recipes [7.7](#recipe_7_7)
    and [7.8](#recipe_7_8)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll see how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Install and deploy the first application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use automatic deployment and self-healing applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute a rolling update when a new container is released.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give an order on the execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are using the `https://github.com/gitops-cookbook/gitops-cookbook-sc.git`
    GitHub repository as source directory. To run it successfully in this chapter,
    you should fork it and use it in the YAML files provided in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Deploy an Application Using Argo CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want Argo CD to deploy an application defined in a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an `Application` resource to set up Argo CD to deploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Argo CD, create the `argocd` namespace and apply the Argo CD installation
    manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s make Argo CD deploy a simple web application showing a box with a configured
    color. The application is composed of three Kubernetes manifest files, including
    a `Namespace`, a `Deployment`, and a `Service` definition.
  prefs: []
  type: TYPE_NORMAL
- en: The files are located in the [ch07/bgd](https://oreil.ly/DAH50) folder of the
    book’s repository.
  prefs: []
  type: TYPE_NORMAL
- en: All these files are known as an `Application` in Argo CD. Therefore, you must
    define it as such to apply these manifests in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the Argo CD `Application` resource file used for deploying the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Namespace where Argo CD is installed
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Target cluster and namespace
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the application in Argo CD’s default project
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The manifest repo where the YAML resides
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_argo_cd_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The path to look for manifests
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_argo_cd_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Branch to checkout
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal window, run the following command to register the Argo CD application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the application is registered as an Argo CD application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the status using either `argocd` or the UI; run the following
    command to list applications using the CLI too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output is something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The important field here is `STATUS`. It’s `OutOfSync`, which means the application
    is registered, and there is a drift between the current status (in this case,
    no application deployed) and the content in the Git repository (the application
    deployment files).
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll notice that no pods are running if you get all the pods from the `bgd`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Argo CD doesn’t synchronize the application automatically by default. It just
    shows a divergence, and the user is free to fix it by triggering a synchronized
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the CLI, you synchronize the application by running the following command
    in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And the ouput of the command shows all the important information regarding
    the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can synchronize the application from the UI as well, by clicking the `SYNC`
    button as shown in [Figure 7-1](#fig-711).
  prefs: []
  type: TYPE_NORMAL
- en: '![Sync button to synchronize the application](assets/gocb_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Argo CD web console
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you get all the pods from the `bgd` namespace, you’ll notice one pod running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And the same for the Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Exposed port is 32761
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you’ll need to access the deployed service to validate
    that it’s deployed. There are several ways to access services deployed to Minikube;
    for the following chapters, we use the Minikube IP and the exposed port of the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in a terminal window to get the Minikube IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Open a browser window, set the previous IP followed by the exposed port (in
    this example `192.168.59.100:32761`), and access the service to validate that
    the color of the circles in the box is blue, as shown in [Figure 7-2](#fig-712).
  prefs: []
  type: TYPE_NORMAL
- en: '![Blue box application](assets/gocb_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Deployed application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it’s time to update the application deployment files. This time we will
    change the value of an environment variable defined in the *bgd-deployment.yaml*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open *ch07/bgd/bgd-deployment.yaml* in your file editor and change the `COLOR`
    environment variable value from `blue` to `green`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In a terminal run the following commands to commit and push the file so the
    change is available for Argo CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the change pushed, check the status of the application again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the application status is `Sync`. This happens because Argo CD uses
    a polling approach to detect divergences between what’s deployed and what’s defined
    in Git. After some time (by default, it’s 3 minutes), the application status will
    be `OutOfSync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To synchronize the changes, run the `sync` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After some seconds, access the service and validate that the circles are green,
    as shown in [Figure 7-3](#fig-713).
  prefs: []
  type: TYPE_NORMAL
- en: '![Green box application](assets/gocb_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. Deployed application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To remove the application, use the CLI tool or the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, revert the changes done in the Git repository to get the initial version
    of the application and push them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 7.2 Automatic Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want Argo CD to automatically update resources when there are changes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `syncPolicy` section with an `automated` policy.
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD can automatically synchronize an application when it detects differences
    between the manifests in Git and the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: A benefit of automatic sync is that there is no need to log in to the Argo CD
    API, with the security implications that involves (managing secrets, network,
    etc.), and the use of the `argocd` tool. Instead, when a manifest is changed and
    pushed to the Git repository with the changes to the tracking Git repo, the manifests
    are automatically applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the previous Argo CD manifest file (`Application`), adding the
    `sync​Po⁠licy` section, so changes are deployed automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Starts the synchronization policy configuration section
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD automatically syncs the repo
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can apply the `Application` file into a running cluster by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, Argo CD deploys the application without executing any other command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `kubectl` command or check in the Argo CD UI to validate that the deployment
    is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Access the service and validate that the circles are blue, as shown in [Figure 7-4](#fig-721).
  prefs: []
  type: TYPE_NORMAL
- en: '![Blue box application](assets/gocb_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Deployed application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To remove the application, use the CLI tool or the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Argo CD deploys applications automatically, it uses some default conservative
    strategies for safety reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Two of these are the pruning of deleted resources and the self-healing of the
    application in case a change was made in the Kubernetes cluster directly instead
    of through Git.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Argo CD will not delete (prune) any resource when it detects that
    it is no longer available in Git, and it will be in an `OutOfSync` status. If
    you want Argo CD to delete these resources, you can do it in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is by manually invoking a sync with the `-prune` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is letting Argo CD delete pruned resources automatically by
    setting the `prune` attribute to `true` in the `automated` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Enables automatic pruning
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept affecting how the application is automatically updated
    is self-healing.
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD is configured not to correct any drift made manually in the cluster.
    For example, Argo CD will let the execution of a `kubectl patch` directly in the
    cluster change any configuration parameter of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: The color of the circle is set as an environment variable (`COLOR`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s change the `COLOR` environment variable to `green` using the `kubectl
    patch` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the rollout to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you refresh the browser, you should see green circles now, as shown in [Figure 7-5](#fig-722).
  prefs: []
  type: TYPE_NORMAL
- en: '![Green box application](assets/gocb_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. Deployed application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Looking over the Argo CD sync status, you’ll see that it’s `OutOfSync` as the
    application and the definition in the Git repository (`COLOR: blue`) diverges.'
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD will not roll back to correct this drift as the `selfHeal` property
    default is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s remove the application and deploy a new one, but set `selfHeal` to `true`
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s enable the `selfHealing` property, and repeat the experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`selfHeal` set to `true` to correct any drift'
  prefs: []
  type: TYPE_NORMAL
- en: 'And in the terminal apply the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the previous steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the browser to check that the circles are blue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reexecute the `kubectl -n bgd patch deploy/bgd ...` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the browser and check that the circles are still blue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Argo CD corrects the drift introduced by the `patch` command, synchronizing
    the application to the correct state defined in the Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the application, use the CLI tool or the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Argo CD Automated Sync Policy](https://oreil.ly/mw4b2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Argo CD Sync Options](https://oreil.ly/wIleG)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.3 Kustomize Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use Argo CD to deploy Kustomize manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Argo CD supports several different ways in which Kubernetes manifests can be
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ksonnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jsonnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also extend the supported ways to custom ones, but this is out of the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Argo CD detects a Kustomize project if there are any of the following files:
    *kustomization.yaml*, *kustomization.yml*, or *Kustomization*.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s deploy the same BGD application, but in this case, deployed as Kustomize
    manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we’ll set `kustomize` to override the `COLOR` environment variable
    to yellow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kustomize file defined in the repository looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Directory with standard deployment files (blue circles)
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Specific file for creating a namespace
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Patches standard deployment files
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Patches the deployment file
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_argo_cd_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Overrides the environment variable value to `yellow`
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You don’t need to create this file as it’s already stored in the Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `Application` file to deploy the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can apply the `Application` file to a running cluster by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Access the service and you’ll notice the circles are yellow instead of blue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the application, use the CLI tool or the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can explicitly specify which tool to use, overriding the default algorithm
    used by Argo CD in the `Application` file. For example, we can use a plain directory
    strategy regarding the presence of the *kustomization.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Overrides always use a plain directory strategy
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible strategies are: `directory`, `chart`, `helm`, `kustomize`, `path`,
    and `plugin`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Everything we’ve seen about Kustomize is valid when using Argo CD.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.xhtml#ch_Kustomize)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[argo-cd/application-crd.yaml on GitHub](https://oreil.ly/EIxY1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Argo CD Tool Detection](https://oreil.ly/DJbiU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4 Helm Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use Argo CD to deploy Helm manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Argo CD supports installing Helm Charts to the cluster when it detects a Helm
    project in the deployment directory (when the *Chart.yaml* file is present).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s deploy the same BGD application, but in this case, deployed as a Helm
    manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout of the project is a simple Helm layout already created in the GitHub
    repository you’ve cloned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a *bgdh/bgdh-app.yaml* file to define the Argo CD application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can apply the `Application` file into a running cluster by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Validate the pod is running in the `bgdh` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove the application, use the CLI tool or the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Argo CD populates build environment variables to Helm manifests (actually also
    Kustomize, Jsonnet, and custom tools support too).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following variables are set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARGOCD_APP_NAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARGOCD_APP_NAMESPACE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARGOCD_APP_REVISION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARGOCD_APP_SOURCE_PATH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARGOCD_APP_SOURCE_REPO_URL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARGOCD_APP_SOURCE_TARGET_REVISION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KUBE_VERSION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KUBE_API_VERSIONS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following snippet, you can see the usage of the application name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Specific Helm section
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Extra parameters to set, same as setting them in *values.yaml*, but high preference
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the parameter
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the parameter, in this case from a Build Env var
  prefs: []
  type: TYPE_NORMAL
- en: 'Argo CD can use a different *values.yaml* file or set parameter values to override
    the ones defined in *values.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that values files must be in the same Git repository as the Helm Chart.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Argo CD supports Helm hooks too.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.xhtml#ch_Helm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*argo-cd/application-crd.yaml* on GitHub](https://oreil.ly/EIxY1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5 Image Updater
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want Argo CD to automatically deploy a container image when it’s published.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use [Argo CD Image Updater](https://oreil.ly/kztMq) to detect a change on the
    container registry and update the deployment files.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most repetitive tasks during development is deploying a new version
    of a container image.
  prefs: []
  type: TYPE_NORMAL
- en: With a pure Argo CD solution, after the container image is published to a container
    registry, we need to update the Kubernetes/Kustomize/Helm manifest files pointing
    to the new container image and push the result to the Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process implies:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repo
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the YAML files and update them accordingly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit and Push the changes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These boilerplate tasks should be defined for each repository during the continuous
    integration phase. Although this approach works, it could be automated so the
    cluster could detect a new image pushed to the container registry and update the
    current deployment file pointing to the newer version.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what Argo CD Image Updater (*ArgoCD IU*) does. It’s a Kubernetes
    controller monitoring for a new container version and updating the manifests defined
    in the Argo CD `Application` file.
  prefs: []
  type: TYPE_NORMAL
- en: The Argo CD IU lifecycle and its relationship with Argo CD are shown in [Figure 7-6](#fig-751).
  prefs: []
  type: TYPE_NORMAL
- en: '![Lifecycle of Argo CD and Argo CD Image Updater](assets/gocb_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. Argo CD Image Updater lifecycle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At this time, Argo CD IU only updates manifests of Kustomize or Helm. In the
    case of Helm, it needs to support specifying the image’s tag using a parameter
    (`image.tag`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install the controller in the same namespace as Argo CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Validate the installation process, checking that the pod status of the controller
    is `Running`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Before using Argo CD IU, we create a Kubernetes Secret representing the Git
    credentials, so the updated manifests can be pushed to the repository. The secret
    must be at the Argo CD namespace and, in this case, we name it `git-creds`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s annotate the `Application` manifest with some special annotations
    so the controller can start monitoring the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: image-list
  prefs: []
  type: TYPE_NORMAL
- en: Specify one or more images (comma-separated-value) considered for updates.
  prefs: []
  type: TYPE_NORMAL
- en: write-back-method
  prefs: []
  type: TYPE_NORMAL
- en: Methods to propagate new versions. There are `git` and `argocd` methods implemented
    to update to a newer image. The Git method commits the change to the Git repository.
    Argo CD uses the Kubernetes/ArgoCD API to update the resource.
  prefs: []
  type: TYPE_NORMAL
- en: There are more configuration options, but the previous ones are the most important
    to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an Argo CD `Application` manifest annotated with Argo CD IU annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds annotations section
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the monitored image name
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Configures to use Git as `write-back-method`, setting the location of the credentials
    (`<namespace>/<secretname>`)
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the branch to push changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now apply the manifest to deploy the application’s first version and enable
    Argo CD IU to update the repository when a new image is pushed to the container
    registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: At this point, version 1.0.0 is up and running in the `bgdk` namespace, and
    you may access it as we’ve done before. Let’s generate a new container version
    to validate that the new image is in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the process, we’ll tag the container with version `1.1.0` as it
    was a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Quay repository created at the beginning of this chapter, go to the
    tags section, push the gear icon, and select `Add New Tag` to create a new container,
    as shown in [Figure 7-7](#fig-752).
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new Tag in Quay](assets/gocb_0707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. Tag container
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Set the tag to `1.1.0` value as shown in the figure [Figure 7-8](#fig-753).
  prefs: []
  type: TYPE_NORMAL
- en: '![Sets the new tag](assets/gocb_0708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. Tag container
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After this step, you should have a new container created as shown in [Figure 7-9](#fig-754).
  prefs: []
  type: TYPE_NORMAL
- en: Wait for around two minutes until the change is detected and the controller
    triggers the repo update.
  prefs: []
  type: TYPE_NORMAL
- en: '![A new container is placed in Quay repo](assets/gocb_0709.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-9\. Final result
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To validate the triggering process check the logs of the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Detects the change and updates the image
  prefs: []
  type: TYPE_NORMAL
- en: After that, if you inspect the repository, you’ll see a new Kustomize file named
    `.argocd-source-bgdk-app.yaml`, updating the image value to the new container,
    as shown in [Figure 7-10](#fig-755).
  prefs: []
  type: TYPE_NORMAL
- en: '![New Kustomize file updating to the new container](assets/gocb_0710.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-10\. New Kustomize file updating to the new container
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now Argo CD can detect the change and update the cluster properly with the new
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the application, use the CLI tool or the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An update strategy defines how Argo CD IU will find new versions. With no change,
    Argo CD IU uses a semantic version to detect the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: 'An optional version constraint field may be added to restrict which versions
    are allowed to be automatically updated. To only update patch versions, we can
    change the `image-list` annotation as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Argo CD Image Updater can update to the image that has the most recent build
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Restricts the tags considered for the update
  prefs: []
  type: TYPE_NORMAL
- en: 'The digest update strategy will use image digests to update your applications’
    image tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: So far, the container was stored in a public registry. If the repository is
    private, Argo CD Image Updater needs read access to the repo to detect any change.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, create a new secret representing the container registry credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Argo CD Image Updater uses a `ConfigMap` as a configuration source, which is
    the place to register the private container registry. Create a new `ConfigMap`
    manifest setting the supported registries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the Argo CD IU `ConfigMap`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Place to register all registries
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A name to identify it
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: URL of the service
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_argo_cd_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The prefix used in the container images
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_argo_cd_CO12-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the credentials from the `quayio` secret stored at `argocd` namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'Argo CD Image Updater commits the update with a default message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update the default commit message to one that fits your requirements.
    Configure the `git.commit-message-template` key in ArgoCD IU `argocd-image-updater-config`
    `ConfigMap` with the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD IU `ConfigMap`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Commit user
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Commmit email
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Golang `text/template` content
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_argo_cd_CO13-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the application
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_argo_cd_CO13-6)'
  prefs: []
  type: TYPE_NORMAL
- en: List of changes performed by the update
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_argo_cd_CO13-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Image name
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_argo_cd_CO13-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Previous container tag
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_argo_cd_CO13-9)'
  prefs: []
  type: TYPE_NORMAL
- en: New container tag
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember to restart the Argo CD UI controller when the `ConfigMap` is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Argo CD Image Updater](https://oreil.ly/kztMq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.6 Deploy from a Private Git Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want Argo CD to deploy manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Argo CD CLI/UI or YAML files to register the repositories’ credential information
    (username/password/token/key).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Argo CD, you have two ways to register a Git repository with its credentials.
    One way is using the Argo CD CLI/Argo CD UI tooling. To register a private repository
    in Argo CD, set the username and password by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we can use the Argo CD UI to register it too. Open Argo CD UI
    in a browser, and click the Settings/Repositories button (the one with gears)
    as shown in [Figure 7-11](#fig-761).
  prefs: []
  type: TYPE_NORMAL
- en: '![Selection of Repositories section](assets/gocb_0711.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-11\. Settings menu
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Then click the “Connect Repo using HTTPS” button and fill the form with the
    required data as shown in [Figure 7-12](#fig-762).
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration of the repository with HTTPS credentials](assets/gocb_0712.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-12\. Configuration of repository
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, click the Connect button to test that it’s possible to establish a
    connection and add the repository into Argo CD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way is to create a Kubernetes Secret manifest file with that repository
    and credentials information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a secret in the Argo CD namespace
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets secret type as `repository`
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: URL of the repository to register
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO14-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Password to access
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_argo_cd_CO14-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Username to access
  prefs: []
  type: TYPE_NORMAL
- en: If you apply this file, it will have the same effect as the manual approach.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, every time we define a `repoURL` value in the `Application` resource
    with a repository URL registered for authentication, Argo CD will use the registered
    credentials to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to setting credentials such as username and password for accessing
    a private Git repo, Argo CD also supports other methods such as tokens, TLS client
    certificates, SSH private keys, or GitHub App credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see some examples using Argo CD CLI or Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure a TLS client certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For SSH, you just need to set the location of the SSH private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Or using a Kubernetes Secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the content of the SSH private key
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the GitHub App method, you need to set the App ID, the App
    Installation ID, and the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Or using the declarative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets GitHub App parameters
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Only valid if GitHub App Enterprise is used
  prefs: []
  type: TYPE_NORMAL
- en: For the access token, use the account name as the username and the token in
    the password field.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing which strategy to use will depend on your experience managing Kubernetes
    Secrets. Remember that a Secret in Kubernetes is not encrypted but encoded in
    Base64, so it is not secured by default.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend using only the declarative approach when you’ve got a good strategy
    for securing the secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We’ve not discussed the Sealed Secrets project yet (we’ll do so in the following
    chapter), but when using Sealed Secrets, the labels will be removed to avoid the
    `SealedSecret` object having a `template` section that encodes all the fields
    you want the controller to put in the unsealed Secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 7.7 Order Kubernetes Manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use Argo CD to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use *sync waves* and *resource hooks* to modify the default order of applying
    manifests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Argo CD applies the Kubernetes manifests (plain, Helm, Kustomize) in a particular
    order using the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: By kind
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: NetworkPolicy
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limit Range
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ServiceAccount
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Secret
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ConfigMap
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: StorageClass
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: PersistentVolumes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ClusterRole
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Role
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DaemonSet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pod
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ReplicaSet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: StatefulSet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Job
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ingress
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same kind, then by name (alphabetical order)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Argo CD has three phases when applying resources: the first phase is executed
    before applying the manifests (`PreSync`), the second phase is when the manifests
    are applied (`Sync`), and the third phase is executed after all manifests are
    applied and synchronized (`PostSync`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-13](#fig-771) summarizes these phases.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relationship between phases and sync waves](assets/gocb_0713.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-13\. Hooks and sync waves
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Resource hooks are scripts executed at a given phase, or if the Sync phase failed,
    you could run some rollback operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-1](#table0701) lists the available resource hooks.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Resource hooks
  prefs: []
  type: TYPE_NORMAL
- en: '| Hook | Description | Use case |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`PreSync`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Executes prior to the application of the manifests | Database migrations
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sync`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Executes at the same time as manifests | Complex rolling update strategies
    like canary releases or dark launches |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`PostSync`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Executes after all `Sync` hooks have completed and were successful (healthy)
    | Run tests to validate deployment was correctly done |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`SyncFail`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Executes when the sync operation fails | Rollback operations in case of failure
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`Skip`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Skip the application of the manifest | When manual steps are required to
    deploy the application (i.e., releasing public traffic to new version) |'
  prefs: []
  type: TYPE_TB
- en: 'Hooks are defined as an annotation named `argocd.argoproj.io/hook` to a Kubernetes
    resource. In the following snippet, a `PostSync` manifest is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Job’s name
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets when the manifest is applied
  prefs: []
  type: TYPE_NORMAL
- en: A *sync wave* is a way to order how Argo CD applies the manifests stored in
    Git.
  prefs: []
  type: TYPE_NORMAL
- en: All manifests have zero waves by default, and the lower values go first. Use
    the `argocd.argoproj.io/sync-wave` annotation to set the wave number to a resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want to deploy a database first and then create the
    database schema; for this case, you should set a `sync-wave` lower in the database
    deployment file than in the job for creating the database schema, as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL deployment
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sync wave for PostgreSQL deployment is 0
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO18-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the Job
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO18-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Job executed when PostgreSQL is healthy
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When Argo CD starts applying the manifests, it orders the resources in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Phase
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wave (lower precedence first)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kind
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s deploy a more significant application with deployment files, sync waves,
    and hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The sample application deployed is a TODO application connected with a database
    (PostgreSQL) to store TODOs. To deploy the application, some particular order
    needs to be applied; for example, the database server must be running before creating
    the database schema. Also, when the whole application is deployed, we insert some
    default TODOs into the database to run a post-sync manifest.
  prefs: []
  type: TYPE_NORMAL
- en: The overall process is shown in [Figure 7-14](#fig-772).
  prefs: []
  type: TYPE_NORMAL
- en: '![Todo Application with the order manifests are executed](assets/gocb_0714.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-14\. Todo app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create an `Application` resource pointing out to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the terminal, apply the resource, and Argo CD will deploy all applications
    in the specified order.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*gitops-engine/sync_tasks.go* on GitHub](https://oreil.ly/NDWru)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.8 Define Synchronization Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want Argo CD to block or allow application synchronization depending on
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Argo CD has the *sync windows* concept to configure time windows where application
    synchronizations (applying new resources that have been pushed to the repository)
    will either be blocked or allowed.
  prefs: []
  type: TYPE_NORMAL
- en: To define a sync window, create an `AppProject` manifest setting the `kind`
    (either `allow` or `deny`), a `schedule` in cron format to define the initial
    time, a `duration` of the window, and which resources the sync window is applied
    to (`Application`, namespaces, or clusters).
  prefs: []
  type: TYPE_NORMAL
- en: The `AppProject` resource is responsible for defining these windows where synchronizations
    are permitted/blocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file to permit synchronizations only from 22:00 to 23:00 (just
    one hour) and for Argo CD `Applications` whose names end in `-prod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List of windows
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Allow syncs
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO19-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Only at 22:00
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO19-4)'
  prefs: []
  type: TYPE_NORMAL
- en: For 1 hour (23:00)
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_argo_cd_CO19-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the applications that affect this window
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_argo_cd_CO19-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression matching any application whose name ends with `-prod`
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cannot perform a sync of the application (neither automatic nor manual) when
    it’s not the time configured in the time window defined in the `AppProject` manifest.
    However, we can configure a window to allow manual syncs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the CLI tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, manual sync can be set in the YAML file. In the following example, we’re
    setting manual synchronization for the `namespace` default, denying synchronizations
    at 22:00 for one hour and allowing synchronizations in `prod-cluster` at 23:00
    for one hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_argo_cd_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Block synchronizations
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_argo_cd_CO20-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Enable manual sync to `default` namespace
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_argo_cd_CO20-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Configure namespaces to block
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_argo_cd_CO20-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Configure clusters to allow syncs at 23:00
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect the current windows from the UI by going to the Settings → Projects
    → default → windows tab or by using the `argocd` CLI tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
