- en: Chapter 5\. Working with Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to build a Docker image and the very
    basic steps required for running the resulting image within a container. In this
    chapter, we’ll first take a look at the history of container technology and then
    dive deeper into running containers and exploring the Docker commands that control
    the overall configuration, resources, and privileges that your container receives.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Containers?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be familiar with virtualization systems like VMware or KVM that allow
    you to run a complete Linux kernel and operating system on top of a virtualized
    layer, commonly known as a *hypervisor*. This approach provides very strong isolation
    between workloads because each VM hosts its own operating system kernel that sits
    in a separate memory space on top of a hardware virtualization layer.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are fundamentally different since they all share a single kernel,
    and isolation between workloads is implemented entirely within that one kernel.
    This is called *operating system virtualization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`libcontainer` README](https://github.com/opencontainers/runc/blob/main/libcontainer/README.md)
    provides a good, short definition of a container:'
  prefs: []
  type: TYPE_NORMAL
- en: A container is a self-contained execution environment that shares the kernel
    of the host system and is (optionally) isolated from other containers in the system.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One of the major advantages of containers is resource efficiency, because you
    don’t need a whole operating system instance for each isolated workload. Since
    you are sharing a kernel, there is one fewer layer of indirection between the
    isolated task and the real hardware underneath. When a process is running inside
    a container, there is only a little bit of code that sits inside the kernel managing
    the container. Contrast this with a VM, where a second layer would be running.
    In a VM, calls by the process to the hardware or hypervisor would require bouncing
    in and out of privileged mode on the processor twice, thereby noticeably slowing
    down many calls.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[libcontainer](https://github.com/opencontainers/runc/tree/main/libcontainer)
    is a Go library that is designed to provide a standard interface for managing
    Linux containers from applications.'
  prefs: []
  type: TYPE_NORMAL
- en: But the container approach does mean that you can only run processes that are
    compatible with the underlying kernel. For example, unlike hardware virtualization
    provided by technologies like VMware or KVM, Windows applications cannot run natively
    inside a Linux container on a Linux host. Windows applications can, however, run
    inside Windows containers on a Windows host. So containers are best thought of
    as an OS-specific technology where you can run any of your favorite applications
    or daemons that are compatible with the container server’s kernel. When thinking
    of containers, you should try very hard to throw out what you might already know
    about VMs and instead conceptualize a container as a wrapper around a normal process
    that runs on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to being able to run containers inside VMs, it is completely feasible
    to run a VM inside a container. If you do this, then it is indeed possible to
    run a Windows application inside a Windows VM that is running inside a Linux container.
  prefs: []
  type: TYPE_NORMAL
- en: History of Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often the case that a revolutionary technology is an older technology
    that has finally arrived in the spotlight. Technology goes in waves, and some
    of the ideas from the 1960s are back in vogue. Similarly, Docker is a newer technology,
    and it has an ease of use that has made it an instant hit, but it doesn’t exist
    in a vacuum. Much of what underpins Docker comes from work done over the last
    30 years in a few different areas. We can easily trace the conceptual evolution
    of containers from a simple system call that was added to the Unix kernel in the
    late 1970s to the modern container tooling that powers many huge internet firms,
    like Google, Twitter, and Meta. It’s worth taking some time for a quick tour through
    how the technology evolved and led to the creation of Docker, because understanding
    this helps you place it within the context of other things that you might be familiar
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers are not a new idea. They are a way to isolate and encapsulate a
    part of the running system. The oldest technology in this area includes the very
    first batch processing systems. When using these early computers, the system would
    only run one program at a time, switching to run another program once the previous
    program had finished or a predefined time span had elapsed. With this design there
    was enforced isolation: you could make sure your program didn’t step on anyone
    else’s program because it was only possible to run one thing at a time. Although
    modern computers still switch tasks constantly, it is incredibly fast and completely
    unnoticeable to most users.'
  prefs: []
  type: TYPE_NORMAL
- en: We would argue that the seeds for today’s containers were planted in 1979 with
    the addition of the `chroot` system call to Version 7 Unix. `chroot` restricts
    a process’s view of the underlying filesystem to a single subtree. The `chroot`
    system call is commonly used to protect the operating system from untrusted server
    processes like FTP, BIND, and Sendmail, which are publicly exposed and susceptible
    to compromise.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1980s and 1990s, various Unix variants were created with mandatory access
    controls for security reasons.^([1](ch05.html#idm46803149032576)) This meant you
    had tightly controlled domains running on the same Unix kernel. Processes in each
    domain had an extremely limited view of the system that precluded them from interacting
    across domains. A popular commercial version of Unix that implemented this idea
    was the Sidewinder firewall built on top of BSDI Unix, but this was not possible
    with most mainstream Unix implementations.
  prefs: []
  type: TYPE_NORMAL
- en: That changed in 2000 when FreeBSD 4.0 was released with a new command, called
    `jail`, which was designed to allow shared-environment hosting providers to easily
    and securely create a separation between their processes and those that belonged
    to each of their customers. FreeBSD `jail` expanded `chroot`’s capabilities and
    also restricted everything a process could do with the underlying system and other
    jailed processes.
  prefs: []
  type: TYPE_NORMAL
- en: In 2004, Sun released an early build of Solaris 10, which included Solaris containers,
    which later evolved into Solaris Zones. This was the first major commercial implementation
    of container technology and is still used today to support many commercial container
    implementations. In 2005, OpenVZ for Linux was released by the company Virtuozzo,
    followed in 2007 by HP’s Secure Resource Partitions for HP-UX, which was later
    renamed HP-UX Containers.
  prefs: []
  type: TYPE_NORMAL
- en: Companies like Google, which had to deal with scaling applications for broad
    internet consumption and/or hosting untrusted user code, started pushing container
    technology in the early 2000s to facilitate reliably and securely distributing
    their applications across global data centers. A few companies maintained their
    own patched Linux kernels with container support for internal use, but as the
    need for these features became more evident within the Linux community, Google
    contributed some of its work supporting containers into the mainline Linux kernel,
    and in 2008, Linux Containers (LXC) were released in version 2.6.24 of the Linux
    kernel. The phenomenal growth of Linux Containers across the community did not
    truly start to grow until 2013, with the inclusion of user namespaces in version
    3.8 of the Linux kernel and the release of Docker one month later.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, containers are used almost everywhere. Docker and OCI images provide
    the packaging format for a significant and growing amount of software that is
    delivered into production environments, and provide the basis for many production
    systems, including, but not limited to, Kubernetes and most “serverless” cloud
    technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So-called serverless technologies are not actually serverless; they simply rely
    on other people’s servers to get work done so that the application owner does
    not have to worry about managing the hardware and operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we’ve started containers using the handy `docker container run` command.
    But `docker container run` is really a convenience command that wraps two separate
    steps into one. The first thing it does is create a container from the underlying
    image. We can accomplish this separately using the `docker container create` command.
    The second thing `docker container run` does is execute the container, which we
    can also do separately with the `docker container start` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `docker container create` and `docker container start` commands both contain
    all the options that pertain to how a container is initially set up. In [Chapter 4](ch04.html#docker_images),
    we demonstrated that with the `docker container run` command you could map network
    ports in the underlying container to the host using the `-p/--publish` argument,
    and that `-e/--env` could be used to pass environment variables into the container.
  prefs: []
  type: TYPE_NORMAL
- en: This only just begins to touch on the array of things that you can configure
    when you first create a container. So let’s take a look at some of the options
    that `docker` supports.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by exploring some of the ways we can tell Docker to configure our
    container when we create it.
  prefs: []
  type: TYPE_NORMAL
- en: Container name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you create a container, it is built from the underlying image, but various
    command-line arguments can affect the final settings. Settings specified in the
    *Dockerfile* are always used as defaults, but you can override many of them at
    creation time.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, [Docker randomly names your container](https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go)
    by combining an adjective with the name of a famous person. This results in names
    like *ecstatic-babbage* and *serene-albattani*. If you want to give your container
    a specific name, you can use the `--name` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After creating this container, you can then start it by using the `docker container
    start awesome-service`. It will automatically exit after 120 seconds, but you
    can stop it before then by running `docker container stop awesome-service`. We
    will dive a bit more into each of these commands a little later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can only have one container with any given name on a Docker host. If you
    run the preceding command twice in a row, you will get an error. You must either
    delete the previous container using `docker container rm` or change the name of
    the new container.
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 4](ch04.html#docker_images), labels are key/value pairs
    that can be applied to Docker images and containers as metadata. When new Linux
    containers are created, they automatically inherit all the labels from their parent
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to add new labels to the containers so that you can apply
    metadata that might be specific to that single container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then search for and filter containers based on this metadata, using
    commands like `docker container ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `docker container inspect` command to see all the labels that
    a container has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This container runs the command `sleep 1000`, so after 1,000 seconds it will
    stop running.
  prefs: []
  type: TYPE_NORMAL
- en: Hostname
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, when you start a container, Docker copies certain system files
    on the host, including */etc/hostname*, into the container’s configuration directory
    on the host,^([2](ch05.html#idm46803148782320)) and then uses a bind mount to
    link that copy of the file into the container. We can launch a default container
    with no special configuration, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command uses the `docker container run` command, which runs `docker container
    create` and `docker container start` in the background. Since we want to be able
    to interact with the container that we are going to create for demonstration purposes,
    we pass in a few useful arguments. The `--rm` argument tells Docker to delete
    the container when it exits, the `-t` argument tells Docker to allocate a pseudo-TTY,
    and the `-i` argument tells Docker that this is going to be an interactive session
    and that we want to keep STDIN open. If there is no `ENTRYPOINT` defined in the
    image, then the final argument in the command is the executable and command-line
    arguments that we want to run within the container, which in this case is the
    ever-useful `/bin/bash`. If there is an `ENTRYPOINT` defined in the image, then
    the final argument is passed to the `ENTRYPOINT` process as a list of command-line
    arguments to that command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might have noticed that the preceding paragraph talks about `-i` and `-t`,
    but the command is using the argument `-ti`. There is a lot of Unix history that
    explains why this is, but a [quick overview](https://nullprogram.com/blog/2020/08/01)
    can be found online if you are curious.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now run the `mount` command from within the resulting container, we’ll
    see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you see any examples with a prompt that looks something like *root@hashID*,
    it means that you are running a command within the container instead of on the
    local host.
  prefs: []
  type: TYPE_NORMAL
- en: There are occasions when a container will have been configured with a different
    hostname instead (e.g., using `--name` on the CLI), but in the default case, it’s
    the container ID hash.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to change the user that is used inside the container with
    `--user`, but by default, it will be *root*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few bind mounts in a container, but in this case, we are
    interested in this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While the device number will be different for each container, the part we care
    about is that the mount point is */etc/hostname*. This links the container’s */etc/hostname*
    to the hostname file that Docker has prepared for the container, which by default
    contains the container’s ID and is not fully qualified with a domain name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check this in the container by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t forget to `exit` the container shell to return to the local host when
    finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the hostname specifically, we can use the `--hostname` argument to pass
    in a more specific value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, from within the container, we’ll see that the fully qualified hostname
    is defined as requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Domain Name Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like */etc/hostname*, the *resolv.conf* file that configures Domain Name
    Service (DNS) resolution is managed via a bind mount between the host and container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Details about the *resolve.conf* file can be found [online](https://sslhow.com/understanding-etc-resolv-conf-file-in-linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, this is an exact copy of the Docker host’s *resolv.conf* file.
    If you didn’t want this, you could use a combination of the `--dns` and `--dns-search`
    arguments to override this behavior in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to leave the search domain completely unset, then use `--dns-search=.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the container, you would still see a bind mount, but the file contents
    would no longer reflect the host’s *resolv.conf*; instead, it would now look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: MAC address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important piece of information that you can configure is the media access
    control (MAC) address for the container.
  prefs: []
  type: TYPE_NORMAL
- en: Without any configuration, a container will receive a calculated MAC address
    that starts with the *02:42:ac:11* prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to specifically set this to a value, you can do so by running something
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Normally, you will not need to do that. But sometimes you want to reserve a
    particular set of MAC addresses for your containers to avoid conflicting with
    other virtualization layers that use the same private block as Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be very careful when customizing the MAC address settings. It is possible to
    cause ARP contention on your network if two systems advertise the same MAC address.
    If you have a strong need to do this, try to keep your locally administered address
    ranges within some of the official ranges, like *x2-xx-xx-xx-xx-xx*, *x6-xx-xx-xx-xx-xx*,
    *xA-xx-xx-xx-xx-xx*, and *xE-xx-xx-xx-xx-xx* (with *x* being any valid hexadecimal
    character).
  prefs: []
  type: TYPE_NORMAL
- en: Storage Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when the default disk space allocated to a container, or the
    container’s ephemeral nature, is not appropriate for the job at hand, so you’ll
    need storage that can persist between container deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Mounting storage from the Docker host is not generally advisable because it
    ties your container to a particular Docker host for its persistent state. But
    for cases like temporary cache files or other semi-ephemeral states, it can make
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'For times like this, you can leverage the `--mount/-v` command to mount directories
    and individual files from the host server into the container. It is important
    that you use fully qualified paths in the `--mount/-v` argument. The following
    example mounts */mnt/session_data* to */data* within the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For bind mounts specifically, you can use the `-v` argument to shorten the command.
    When using the `-v` argument, you will notice here that the source and target
    files/directories are separated by a colon(:).
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that volumes are mounted read-write by default.
    You can easily make `docker` mount the file or directory read-only by adding `,readonly`
    to end the of the `--mount` arguments, or by adding `:ro` to the end of the `-v`
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Neither the host mount point nor the mount point in the container needs to preexist
    for this command to work properly. If the host mount point does not exist already,
    then it will be created as a directory. This could cause you some issues if you
    were trying to point to a file instead of a directory.
  prefs: []
  type: TYPE_NORMAL
- en: In the mount options, you can see that the filesystem was mounted read-write
    on */data* as expected.
  prefs: []
  type: TYPE_NORMAL
- en: If the container application is designed to write into */data*, then this data
    will be visible on the host filesystem in */mnt/session_data* and will remain
    available when this container stops and a new container starts with the same volume
    mounted.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to tell Docker that the root volume of your container should
    be mounted read-only so that processes within the container cannot write anything
    to the root filesystem. This prevents things like logfiles, which a developer
    may be unaware of, from filling up the container’s allocated disk in production.
    When it’s used in conjunction with a mounted volume, you can ensure that data
    is written only into expected locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we could accomplish this simply by adding `--read-only=true`
    to the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you look closely at the mount options for the root directory, you’ll notice
    that they are mounted with the `ro` option, which makes it read-only. However,
    the */session_data* mount is still mounted with the `rw` option so that our application
    can successfully write to the one volume to which it’s designed to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is necessary to make a directory like */tmp* writable, even when
    the rest of the container is read-only. For this use case, you can use the `--mount
    type=tmpfs` argument with `docker container run` so that you can mount a *tmpfs*
    filesystem into the container. The *tmpfs* filesystems are completely in-memory.
    They will be very fast, but they are also ephemeral and will utilize additional
    system memory. Any data in these *tmpfs* directories will be lost when the container
    is stopped. The following example shows a container being launched with a 256
    MB *tmpfs* filesystem mounted at */tmp*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Containers should be designed to be stateless whenever possible. Managing storage
    creates undesirable dependencies and can easily make deployment scenarios much
    more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Resource Quotas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When people discuss the types of problems they must often cope with when working
    in the cloud, the “noisy neighbor” is often near the top of the list. The basic
    problem this term refers to is that other applications running on the same physical
    system as yours can have a noticeable impact on your performance and resource
    availability.
  prefs: []
  type: TYPE_NORMAL
- en: VMs have the advantage that you can easily and very tightly control how much
    memory and CPU, among other resources, are allocated to the VM. When using Docker,
    you must instead leverage the cgroup functionality in the Linux kernel to control
    the resources that are available to a Linux container. The `docker container create`
    and `docker container run` commands directly support configuring CPU, memory,
    swap, and storage I/O restrictions when you create a container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Constraints are normally applied at the time of container creation. If you need
    to change them, you can use the `docker container update` command or deploy a
    new container with the adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important caveat here. While Docker supports various resource limits,
    you must have these capabilities enabled in your kernel for Docker to take advantage
    of them. You might need to add these as command-line parameters to your kernel
    on startup. To figure out if your kernel supports these limits, run `docker system
    info`. If you are missing any support, you will get warning messages at the bottom,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The details regarding getting cgroup support configured for your kernel are
    distribution specific, so you should consult the [Docker documentation](https://oreil.ly/Z70ZO)^([3](ch05.html#idm46803147988272))
    if you need help configuring things.
  prefs: []
  type: TYPE_NORMAL
- en: CPU shares
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker has several ways to limit CPU usage by applications in containers. The
    original method, still commonly used, is the concept of *CPU shares*. We’ll present
    other options as well.
  prefs: []
  type: TYPE_NORMAL
- en: The computing power of all the CPU cores in a system is considered to be the
    full pool of shares. Docker assigns the number 1,024 to represent the full pool.
    By configuring a container’s CPU shares, you can dictate how much time the container
    gets to use the CPU. If you want the container to be able to use at most half
    of the computing power of the system, then you would allocate it 512 shares. These
    are not exclusive shares, meaning that assigning all 1,024 shares to a container
    does not prevent all other containers from running. Rather, it’s a hint to the
    scheduler about how long each container should be able to run each time it’s scheduled.
    If we have one container that is allocated 1,024 shares (the default) and two
    that are allocated 512, they will all get scheduled the same number of times.
    But if the normal amount of CPU time for each process is 100 microseconds, the
    containers with 512 shares will run for 50 microseconds each time, whereas the
    container with 1,024 shares will run for 100 microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore a little bit how this works in practice. For the following examples,
    we’ll use a new Docker image that contains the [`stress` command](https://linux.die.net/man/1/stress)
    for pushing a system to its limits.
  prefs: []
  type: TYPE_NORMAL
- en: When we run `stress` without any cgroup constraints, it will use as many resources
    as we tell it to. The following command creates a load average of around five
    by creating two CPU-bound processes, one I/O-bound process, and two memory allocation
    processes. For all of the following examples, we are running on a system with
    two CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in the following command, everything following the container image
    name is related to the `stress` command, not the `docker` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This should be a reasonable command to run on any modern computer system, but
    be aware that it is going to stress the host system. So don’t do this in a location
    that can’t take the additional load, or even a possible failure, due to resource
    starvation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `top` or `htop` command on the Docker host, near the end of
    the two-minute run, you can see how the system is affected by the load created
    by the `stress` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Docker Desktop users on non-Linux systems may discover that Docker has made
    the VM filesystem read-only, and it does not contain many useful tools for monitoring
    the VM. For these demos where you want to be able to monitor the resource usage
    of various processes, you can work around this by doing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that the preceding `htop` command will give you an error unless `stress`
    is actively running when you launch `htop`, since no processes will be returned
    by the `pgrep` command.
  prefs: []
  type: TYPE_NORMAL
- en: You will also want to exit and rerun `htop` each time you run a new `stress`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the same `stress` command again, with only half the amount
    of available CPU time, you can do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `--cpu-shares 512` is the flag that does the magic, allocating 512 CPU shares
    to this container. The effect of this argument might not be noticeable on a system
    that is not very busy. That’s because the container will continue to be scheduled
    for the same time-slice length whenever it has work to do unless the system is
    constrained for resources. So in our case, the results of a `top` command on the
    host system will likely look the same, unless you run a few more containers to
    give the CPU something else to do.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike VMs, Docker’s cgroup-based constraints on CPU shares can have unexpected
    consequences. They are not hard limits; they are relative limits, similar to the
    `nice` command. An example is a container that is constrained to half the CPU
    shares but is on a system that is not very busy. Since the CPU is not busy, the
    limit on the CPU shares would have only a limited effect because there is no competition
    in the scheduler pool. When a second container that uses a lot of CPU is deployed
    to the same system, suddenly the effect of the constraint on the first container
    will be noticeable. Consider this carefully when constraining containers and allocating
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: CPU pinning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to pin a container to one or more CPU cores. This means
    that work for this container will be scheduled only on the cores that have been
    assigned to this container. That is useful if you want to hard-shard CPUs between
    applications or if you have applications that need to be pinned to a particular
    CPU for things like cache efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we are running a stress container pinned to the first
    of two CPUs, with 512 CPU shares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `--cpuset-cpus` argument is zero-indexed, so your first CPU core is 0\.
    If you tell Docker to use a CPU core that does not exist on the host system, you
    will get a `Cannot start container` error. On a two-CPU example host, you could
    test this by using `--cpuset-cpus=0-2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run `top` again, you should notice that the percentage of CPU time spent
    in user space (`us`) is lower than it previously was, since we have restricted
    two CPU-bound processes to a single CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you use CPU pinning, additional CPU sharing restrictions on the container
    only take into account other containers running on the same set of cores.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CPU Completely Fair Scheduler (CFS) within the Linux kernel, you can
    alter the CPU quota for a given container by setting the `--cpu-quota` flag to
    a valid value when launching the container with `docker container run`.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying CPU quotas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While CPU shares were the original mechanism in Docker for managing CPU limits,
    Docker has evolved a great deal since, and one of the ways that it now makes users’
    lives easier is by greatly simplifying how CPU quotas can be set. Instead of trying
    to set correct CPU shares and quotas yourself, you can now simply tell Docker
    how much CPU you would like to be available to your container, and it will do
    the math required to set the underlying cgroups correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--cpus` command can be set to a floating-point number between 0.01 and
    the number of CPU cores on the Docker server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to set the value too high, you’ll get an error message from Docker
    (not the `stress` application) that will give you the correct range of CPU cores
    that you have to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker container update` command can be used to dynamically adjust the
    resource limits of one or more containers. You could adjust the CPU allocation
    on two containers simultaneously, for example, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Docker sees CPUs the same way that Linux sees them. Hyper-threading and cores
    are interpreted by Linux and exposed via the special file */proc/cpuinfo*. When
    you use the `--cpus` command in Docker, you are referring to how many of the entries
    in this file you want the container to have access to, whether they refer to a
    standard core or a hyper-threaded core.
  prefs: []
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can control how much memory a container can access in a manner similar to
    constraining the CPU. There is, however, one fundamental difference: while constraining
    the CPU only impacts the application’s priority for CPU time, the memory limit
    is a *hard* limit. Even on an unconstrained system with 96 GB of free memory,
    if we tell a container that it may have access only to 24 GB, then it will only
    ever get to use 24 GB regardless of the free memory on the system. Because of
    the way the virtual memory system works on Linux, it’s possible to allocate more
    memory to a container than the system has actual RAM. In this case, the container
    will resort to using swap, just like a normal Linux process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start a container with a memory constraint by passing the `--memory`
    option to the `docker container run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you use the `--memory` option alone, you are setting both the amount of
    RAM and the amount of swap that the container will have access to. So by using
    `--memory 512m` here, we’ve constrained the container to 512 MB of RAM and 512
    MB of additional swap space. Docker supports `b`, `k`, `m`, or `g`, representing
    bytes, kilobytes, megabytes, or gigabytes, respectively. If your system somehow
    runs Linux and Docker and has multiple terabytes of memory, then unfortunately
    you’re going to have to specify it in gigabytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to set the swap separately or disable it altogether, you
    need to also use the `--memory-swap` option. This defines the total amount of
    memory and swap available to the container. If we rerun our previous command,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: then we’re telling the kernel that this container can have access to 512 MB
    of memory and 256 MB of additional swap space. Setting the `--memory-swap` option
    to `-1` will allow the container to use as much swap as is available on the underlying
    system and if `--memory-swap` and `--memory` are set to the same positive value,
    then the container will not have any access to swap.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Again, unlike CPU shares, memory is a hard limit! This is good because the constraint
    doesn’t suddenly have a noticeable effect on the container when another container
    is deployed to the system. But it means you need to be careful that the limit
    closely matches your container’s needs because there is no wiggle room. An out-of-memory
    container causes the kernel to behave just like it would if the system were out
    of memory. It will try to find a process to kill so that it can free up space.
    This is a common failure case where containers have their memory limits set too
    low. The telltale sign of this issue is a container exit code of 137 and kernel
    out-of-memory (OOM) messages in the Docker server’s `dmesg` output.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens if a container reaches its memory limit? Well, let’s give
    it a try by modifying one of our previous commands and lowering the memory significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'While all of our other runs of the `stress` container ended with a line like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'we see that this run quickly fails with a line similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is because the container tries to allocate more memory than it is allowed,
    and the Linux OOM killer is invoked and starts killing processes within the cgroup
    to reclaim memory. In this case, our container has a single-parent process that
    has spawned a few children processes, and when the OOM killer kills one of the
    children processes, the parent process cleans everything up and exits with an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Docker has features that allow you to tune and disable the Linux OOM killer
    by using the `--oom-kill-disable` and the `--oom-score-adj` arguments to `docker
    container run`, but they are not recommended for almost any use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you access your Docker server, you can see the kernel message related to
    this event by running `dmesg`. The output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This OOM event will also be recorded by Docker and viewable via `docker system
    events`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Block I/O
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many containers are just stateless applications and won’t need block I/O restrictions.
    But Docker also supports limiting block I/O in a few different ways via the cgroups
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The first way is applying some prioritization to a container’s use of block
    device I/O. You enable this by manipulating the default setting of the `blkio.weight`
    cgroup attribute. This attribute can have a value of 0 (disabled) or a number
    between 10 and 1,000, the default being 500\. This limit acts a bit like CPU shares,
    in that the system will divide all of the available I/O between every process
    within a cgroup slice by 1,000, with the assigned weights impacting how much available
    I/O is available to each process.
  prefs: []
  type: TYPE_NORMAL
- en: To set this weight on a container, you need to pass the `--blkio-weight` to
    your `docker container run` command with a valid value. You can also target a
    specific device using the `--blkio-weight-device` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with CPU shares, tuning the weights is hard to get right in practice, but
    we can make it vastly simpler by limiting the maximum number of bytes or operations
    per second that are available to a container via its cgroup. The following settings
    let us control that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test how these impact the performance of a container by running some
    of the following commands, which use the Linux I/O tester [`bonnie`](https://www.coker.com.au/bonnie):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: PowerShell users should be able to use the [`Measure-Command`](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-7.3)
    function to replace the Unix `time` command used in these examples.
  prefs: []
  type: TYPE_NORMAL
- en: In our experience, the `--device-read-iops` and `--device-write-iops` arguments
    are the most effective way to set block I/O limits and are the ones we recommend.
  prefs: []
  type: TYPE_NORMAL
- en: ulimits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before Linux cgroups, there was another way to place a limit on the resources
    available to a process: the application of user limits via the `ulimit` command.
    That mechanism is still available and still useful for all of the [use cases](https://www.linuxhowtos.org/Tips%20and%20Tricks/ulimit.htm)
    where it was traditionally used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a list of the types of system resources that you can
    usually constrain by setting soft and hard limits via the `ulimit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to configure the Docker daemon with the default user limits
    that you want to apply to every container. The following command tells the Docker
    daemon to start all containers with a soft limit of 50 open files and a hard limit
    of 150 open files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then override these ulimits on a specific container by passing in values
    using the `--ulimit` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There are some additional advanced commands that you can use when creating containers,
    but this covers many of the more common use cases. The [Docker client documentation](https://dockr.ly/2ME0ygi)
    lists all the available options and is updated with each Docker release.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we got into the details of containers and constraints, we created our
    container using the `docker container create` command. That container is just
    sitting there without doing anything. There is a configuration but no running
    process. When we’re ready to start the container, we can do so using the `docker
    container start` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that we needed to run a copy of Redis, a common key/value store.
    We won’t do anything with this Redis container, but it’s a lightweight, long-lived
    process and serves as an example of something we might do in a real environment.
    We could first create the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command is some output, the last line of which is the full
    hash that was generated for the container. We could use that long hash to start
    it, but if we failed to note it down, we could also list all the containers on
    the system, whether they are running or not, using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can confirm the identity of our container by filtering the output by the
    image that we used and examining the container’s creation time. We can then start
    the container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most Docker commands will work with the container name, the full hash, the short
    hash, or even just enough of the hash to make it unique. In the previous example,
    the full hash for the container is `092c5dc850446324e…a37299d35fc67a042`, but
    the short hash that is shown in most command output is `092c5dc85044`. This short
    hash consists of the first 12 characters of the full hash. In the previous example,
    running `docker container start 6b7` would have worked just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'That *should* have started the container, but with it running in the background
    we won’t necessarily know if something went wrong. To verify that it’s running,
    we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And, there it is: running as expected. We can tell because the status says
    `Up` and shows how long the container has been running.'
  prefs: []
  type: TYPE_NORMAL
- en: Auto-Restarting a Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, we want our containers to restart if they exit. Some containers
    are very short-lived and come and go quickly. But for production applications,
    for instance, you expect them to be up and running at all times after you’ve told
    them to run. If you are running a more complex system, a scheduler may do this
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the simple case, we can tell Docker to manage restarts on our behalf by
    passing the `--restart` argument to the `docker container run` command. It takes
    four values: `no`, `always`, `on-failure`, or `unless-stopped`. If `restart` is
    set to `no`, the container will never restart if it exits. If it is set to `always`,
    the container will restart whenever it exits, with no regard to the exit code.
    If `restart` is set to `on-failure`, whenever the container exits with a nonzero
    exit code, Docker will try to restart the container. If we set `restart` to `on-failure:3`,
    Docker will try and restart the container three times before giving up. `unless-stopped`
    is the most common choice and will restart the container unless it is intentionally
    stopped with something like `docker container stop`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in action by rerunning our last memory-constrained stress container
    without the `--rm` argument but with the `--restart` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we’ll see the output from the first run appear on the console
    before it dies. If we run a `docker container ls` immediately after the container
    dies, we’ll likely see that Docker has restarted the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It will continue to fail because we haven’t given it enough memory to function
    properly. After three attempts, Docker will give up, and we’ll see the container
    disappear from the output of `docker container ls`.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping a Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containers can be stopped and started at will. You might think that starting
    and stopping a container is analogous to pausing and resuming a normal process,
    but it’s not quite the same in reality. When stopped, the process is not paused;
    it exits. And when a container is stopped, it no longer shows up in the normal
    `docker container ls` output. On reboot, Docker will attempt to start all of the
    containers that were running at shutdown. If you need to prevent a container from
    doing any additional work, without actually stopping the process, then you can
    pause the Linux container with `docker container pause` and `unpause`, which will
    be discussed in more detail later. For now, go ahead and stop the Redis container
    that we started a little earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have stopped the container, nothing is in the running container
    list! We can start it back up with the container ID, but it would be inconvenient
    to have to remember that. So `docker container ls` has an additional option `(-a)`
    to show all containers, not just the running ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'That `STATUS` field now shows that our container exited with a status code
    of 0 (no errors). We can start it back up with the same configuration it had before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Voilà, our container is back up and running and configured just as it was before.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that containers exist as a blob of configuration in the Docker system
    even when they are not started. This means that as long as the container has not
    been deleted, you can restart it without needing to re-create it. Although memory
    and temporary file system (tmpfs) contents will have been lost, all of the container’s
    other filesystem contents and metadata, including environment variables and port
    bindings, are saved and will still be in place when you restart the container.
  prefs: []
  type: TYPE_NORMAL
- en: By now we’ve probably thumped on enough about the idea that containers are just
    a tree of processes that interact with the system in essentially the same way
    as any other process on the server. But it’s important to point it out here again
    because it means that we can send Unix signals to our process in the containers
    that they can then respond to. In the previous `docker container stop` example,
    we’re sending the container a `SIGTERM` signal and waiting for the container to
    exit gracefully. Containers follow the same process group signal propagation that
    any other process group would receive on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'A normal `docker container stop` sends a `SIGTERM` to the process. If you want
    to force a container to be killed if it hasn’t stopped after a certain amount
    of time, you can use the `-t` argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This tells Docker to initially send a `SIGTERM` signal as before, but if the
    container has not stopped within 25 seconds (the default is 10), it tells Docker
    to send a `SIGKILL` signal to forcefully kill it.
  prefs: []
  type: TYPE_NORMAL
- en: Although `stop` is the best way to shut down your containers, there are times
    when it doesn’t work and you’ll need to forcefully kill a container, just as you
    might have to do with any process outside of a container.
  prefs: []
  type: TYPE_NORMAL
- en: Killing a Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a process is misbehaving, `docker container stop` might not cut it. You
    might just want the container to exit immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these circumstances, you can use `docker container kill`. As you’d expect,
    it looks a lot like `docker container stop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A `docker container ls` command now shows that the container is no longer running,
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Just because it was killed rather than stopped does not mean you can’t start
    it again, though. You can just issue a `docker container start` like you would
    for a nicely stopped container. Sometimes you might want to send another signal
    to a container, one that is not `stop` or `kill`. Like the Linux `kill` command,
    `docker container kill` supports sending any Unix signal. Let’s say we wanted
    to send a `USR1` signal to our container to tell it to do something like reconnect
    a remote logging session. We could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If our container process was designed to do something with the `USR1` signal,
    it would now do it. Any standard Unix signal can be sent to a container using
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and Unpausing a Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few reasons why we might not want to completely stop our container.
    We might want to pause it, leave its resources allocated, and leave its entries
    in the process table. That could be because we’re taking a snapshot of its filesystem
    to create a new image or just because we need some CPU on the host for a while.
    If you are used to normal Unix process handling, you might wonder how this works
    since containerized processes are just processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pausing leverages the [cgroup freezer](https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt),
    which essentially just prevents your process from being scheduled until you unfreeze
    it. This will prevent the container from doing anything while maintaining its
    overall state, including memory contents. Unlike stopping a container, where the
    processes are made aware that they are stopping via the `SIGSTOP` signal, pausing
    a container doesn’t send any information to the container about its state change.
    That’s an important distinction. Several Docker commands use pausing and unpausing
    internally as well. Here is how we pause a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To pause and unpause containers in Windows, you must be using Hyper-V or WSL2
    as the underlying virtualization technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the list of running containers, we will now see that the Redis
    container status is listed as `(Paused)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to use the container in this paused state would fail. It’s present,
    but nothing is running. We can now resume the container by using the `docker container
    unpause` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It’s back to running, and `docker container ls` correctly reflects the new state.
    It shows `Up 55 seconds` now because Docker still considers the container to be
    running even when it is paused.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Up Containers and Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After running all these commands to build images, create containers, and run
    them, we have accumulated a lot of image layers and container folders on our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list all the containers on our system using the `docker container ls
    -a` command and then delete any of the containers in the list. We must stop all
    containers that are using an image before removing the image itself. Assuming
    we’ve done that, we can remove it as follows, using the `docker container rm`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is possible to remove a running container if you use the `-f` or `--force`
    flag with `docker container rm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then list all the images on our system using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then delete an image and all associated filesystem layers by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you try to delete an image that is in use by a container, you will get a
    `Conflict, cannot delete` error. You should stop and delete the container(s) first.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are times, especially during development cycles when it makes sense to
    completely purge all the images or containers from your system. The easiest way
    to do this is by running the `docker system prune` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To remove all unused images, instead of only dangling images, try `docker system
    prune -a`.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to craft more specific commands to accomplish similar goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete all of the containers on your Docker hosts, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And to delete all the images on your Docker host, this command will get the
    job done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `docker container ls` and `docker images` commands both support a `filter`
    argument that can make it easy to fine-tune your delete commands for certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove all containers that exited with a nonzero state, you can use this
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And to remove all untagged images, you can type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can read the [official Docker documentation](https://docs.docker.com/engine/reference/commandline/ps/#filtering)
    to explore the filtering options. At the moment, there are very few filters to
    choose from, but more will likely be added over time.
  prefs: []
  type: TYPE_NORMAL
- en: You can also make your own very creative filters by stringing together commands
    using pipes (|) and other similar techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In production systems that see a lot of deployments, you can sometimes end up
    with old containers or unused images lying around and filling up disk space. It
    can be useful to script the `docker system prune` command to run on a schedule
    (e.g., running under `cron` or via a `systemd` timer).
  prefs: []
  type: TYPE_NORMAL
- en: Windows Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now we have focused entirely on Docker commands for Linux containers,
    since this is the most common use case and works on all Docker platforms. However,
    since 2016, the Microsoft Windows platform has supported running Windows containers
    that include native Windows applications and can be managed with the usual set
    of Docker commands.
  prefs: []
  type: TYPE_NORMAL
- en: Windows containers are not the focus of this book, since they still only make
    up a small portion of production containers and aren’t 100% compatible with the
    rest of the Docker ecosystem because they require Windows-specific container images.
    However, they’re a growing and important part of the Docker world, so we’ll take
    a brief look at how they work. In fact, except for the actual contents of the
    containers, almost everything else works the same as Linux containers. In this
    section, we’ll run through a quick example of how you can run a Windows container
    on Windows 10+ with Hyper-V and Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For this to work, you must be using Docker Desktop on a compatible 64-bit edition
    of Windows 10 or later.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you’ll need to do is switch Docker from Linux containers to
    Windows containers. To do this, right-click on the Docker whale icon in your taskbar,
    select “Switch to Windows Containers…,” and then confirm the switch (Figures [5-1](#figure5-1)
    and [5-2](#figure5-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Switch to Windows containers](assets/dur3_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Switch to Windows containers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Switch to Windows containers confirmation](assets/dur3_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Switch to Windows containers confirmation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This process might take some time, although it usually happens almost immediately.
    Unfortunately, there is no notification that the switch has completed. If you
    right-click on the Docker icon again, you should now see “Switch to Linux Containers…”
    in place of the original option.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the first time you right-click on the Docker icon, it reads “Switch to Linux
    Containers…,” then you are already configured for Windows containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test a simple Windows container by opening up [PowerShell](https://oreil.ly/SiTXP)^([4](ch05.html#idm46803145899968))
    and trying to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This will download and launch a [base container for PowerShell](https://hub.docker.com/_/microsoft-powershell)
    and then use scripting to print `Hello World from Windows (True)` to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the output from the preceding command prints `Hello World from Windows (false)`,
    then you have not switched over to Windows Container mode, or you are running
    this command on a non-Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to build a Windows container image that accomplishes roughly the
    same task, you can create the following *Dockerfile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: When you build this *Dockerfile*, it will base the image on `mcr.microsoft.com/`
    `powershell`, create a small PowerShell script, and then configure the image to
    run that script when this image is used to launch a container.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may have noticed that we had to escape the backslash (`\`) with an additional
    backslash in the preceding *Dockerfile*’s `CMD` line. This is because Docker has
    its roots in Unix, and the backslash has a special meaning in Unix shells. So,
    even though we [changed the escape character](https://docs.docker.com/engine/reference/builder/#escape)
    for the *Dockerfile* to match what is used in PowerShell by default (which we
    set via [the `SHELL` directive](https://docs.docker.com/engine/reference/builder/#shell-form-entrypoint-example)),
    we still need to escape some backslashes to ensure that Docker does not misinterpret
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build this *Dockerfile* now, you’ll see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And now if you run the resulting image, you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft maintains good [documentation about Windows containers](https://oreil.ly/fYMHl)^([5](ch05.html#idm46803145707776))
    that also includes an [example of building a container that launches a .NET application](https://oreil.ly/WG2W2).^([6](ch05.html#idm46803145685248))
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: On the Windows platform, it is also useful to know that you can get improved
    isolation for your container by launching it inside a dedicated and very lightweight
    Hyper-V VM. You can do this very easily by simply adding the `--isolation=hyperv`
    option to your `docker container create` and `docker container run` commands.
    There is a small performance and resource penalty for this, but it significantly
    improves the isolation of your container. You can read more about this in the
    [documentation](https://learn.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container).
  prefs: []
  type: TYPE_NORMAL
- en: Even if you plan to mostly work with Windows containers, for the rest of the
    book you should switch back to Linux containers so that all the examples work
    as expected. When you are done reading and are ready to dive into building your
    containers, you can always switch back.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that you can re-enable Linux containers by right-clicking on the Docker
    icon and selecting “Switch to Linux Containers….”
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we’ll continue our exploration of what Docker brings to
    the table. For now, it’s probably worth doing a little experimentation on your
    own. We suggest exercising some of the container control commands we covered here
    so that you’re familiar with the command-line options and the overall syntax.
    Now would even be a great time to try to design and build a small image and then
    launch it as a new container. When you are ready to continue, head on to [Chapter 6](ch06.html#exploring_docker)!
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.html#idm46803149032576-marker)) SELinux is one current implementation.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.html#idm46803148782320-marker)) Typically under */var/lib/docker/containers*.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch05.html#idm46803147988272-marker)) Full URL: [*https://docs.docker.com/engine/install/linux-postinstall/#your-kernel-does-not-support-cgroup-swap-limit-capabilities*](https://docs.docker.com/engine/install/linux-postinstall/#your-kernel-does-not-support-cgroup-swap-limit-capabilities)'
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch05.html#idm46803145899968-marker)) Full URL: [*https://learn.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7.3&viewFallbackFrom=powershell-6*](https://learn.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7.3&viewFallbackFrom=powershell-6)'
  prefs: []
  type: TYPE_NORMAL
- en: '^([5](ch05.html#idm46803145707776-marker)) Full URL: [*https://learn.microsoft.com/en-us/virtualization/windowscontainers/about*](https://learn.microsoft.com/en-us/virtualization/windowscontainers/about)'
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch05.html#idm46803145685248-marker)) Full URL: [*https://learn.microsoft.com/en-us/virtualization/windowscontainers/quick-start/building-sample-app*](https://learn.microsoft.com/en-us/virtualization/windowscontainers/quick-start/building-sample-app)'
  prefs: []
  type: TYPE_NORMAL
