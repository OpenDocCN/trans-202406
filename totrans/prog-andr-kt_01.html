<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Kotlin Essentials" data-type="chapter" epub:type="chapter"><div class="chapter" id="kotlin_essentials">&#13;
<h1><span class="label">Chapter 1. </span>Kotlin Essentials</h1>&#13;
&#13;
&#13;
<p><a data-primary="Kotlin (basics)" data-type="indexterm" id="ix_ch01-asciidoc0"/>Kotlin was created by the JetBrains team from St. Petersburg, Russia.&#13;
JetBrains is perhaps best known for the IntelliJ Idea IDE, the&#13;
basis for Android Studio. Kotlin is now used in a wide variety of&#13;
environments across multiple operating systems. It has been nearly&#13;
five years since Google announced support for Kotlin on Android. According to the <a href="https://oreil.ly/PrfQm">Android Developers Blog</a>, as of&#13;
2021, over 1.2 million apps in the Google Play store use Kotlin, including 80% of the top one thousand apps.</p>&#13;
&#13;
<p>If you’ve picked up this book, we are assuming that you are already an&#13;
Android developer and that you are familiar with Java.</p>&#13;
&#13;
<p>Kotlin was designed to interoperate with Java. Even its name, taken&#13;
from an island near St. Petersburg, is a sly allusion to Java, an island in Indonesia. Though Kotlin supports other platforms&#13;
(iOS, WebAssembly, Kotlin/JS, etc.), a key to Kotlin’s broad use is its&#13;
support for the Java virtual machine (JVM). Since Kotlin can be compiled to Java bytecode, it can run anywhere that a JVM runs.</p>&#13;
&#13;
<p>Much of the discussion in this chapter will compare Kotlin to Java.&#13;
It’s important to understand, though, that Kotlin is not just&#13;
warmed-over Java with some added bells and whistles. Kotlin is a new&#13;
and different language with connections to Scala, Swift, and C# that&#13;
are nearly as strong as its connection with Java. It has its own&#13;
styles and its own idioms. While it is possible to think Java and&#13;
write Kotlin, thinking in idiomatic Kotlin will reveal the full power&#13;
of the language.</p>&#13;
&#13;
<p>We realize that there may be some Android developers who have been&#13;
working with Kotlin for some time, and who have never written any Java at&#13;
all. If this sounds like you, you may be able to skim this&#13;
chapter and its review of the Kotlin language. However, even if you are fairly&#13;
handy with the language, this may be a good chance to remind&#13;
yourself of some of the details.</p>&#13;
&#13;
<p>This chapter isn’t meant to be a full-fledged primer on Kotlin, so if&#13;
you are completely new to Kotlin, we recommend the excellent <em>Kotlin in Action</em>.<sup><a data-type="noteref" href="ch01.html#idm46669770421056" id="idm46669770421056-marker">1</a></sup>&#13;
Instead, this chapter is a review of some Kotlin basics:&#13;
the type system, variables, functions, and classes.  Even if you are&#13;
not a Kotlin language expert, it should provide enough of a foundation&#13;
for you to understand the rest of the book.</p>&#13;
&#13;
<p>As with all statically typed languages, Kotlin’s type system is the&#13;
meta language that Kotlin uses to describe itself.  Because it is an&#13;
essential aspect for discussing Kotlin, we’ll start by reviewing it.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Kotlin Type System" data-type="sect1"><div class="sect1" id="idm46669761442912">&#13;
<h1>The Kotlin Type System</h1>&#13;
&#13;
<p><a data-primary="type system" data-type="indexterm" id="ix_ch01-asciidoc1"/>Like Java, Kotlin is a statically typed language. The Kotlin compiler&#13;
knows the type of every entity that a program manipulates. It can&#13;
make deductions<sup><a data-type="noteref" href="ch01.html#idm46669761440208" id="idm46669761440208-marker">2</a></sup>&#13;
about those entities and, using those deductions,&#13;
identify errors that will occur when code contradicts them. Type&#13;
checking allows a compiler to catch and flag an entire large class of&#13;
programming errors.  This section highlights some of the&#13;
most interesting features of Kotlin’s type system, including the&#13;
<code>Unit</code> type, functional types, null safety, and &#13;
<span class="keep-together">generics.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Primitive Types" data-type="sect2"><div class="sect2" id="idm46669761437856">&#13;
<h2>Primitive Types</h2>&#13;
&#13;
<p><a data-primary="Kotlin (basics)" data-secondary="primitive types" data-type="indexterm" id="idm46669761463392"/><a data-primary="primitive types" data-type="indexterm" id="idm46669761462416"/><a data-primary="type system" data-secondary="primitive types" data-type="indexterm" id="idm46669761461744"/>The most obvious difference between Java’s and Kotlin’s type systems&#13;
is that Kotlin has no notion of a <em>primitive type</em>.</p>&#13;
&#13;
<p>Java has the types <code>int</code>, <code>float</code>, <code>boolean</code>, etc. These types are&#13;
peculiar in that they do not inherit from Java’s base type, <code>Object</code>.&#13;
For instance, the statement <code>int n = null;</code> is not legal Java. Neither&#13;
is <code>List&lt;int&gt; integers;</code>. In order to mitigate this inconsistency, each&#13;
Java primitive type has a <em>boxed type</em> equivalent. <code>Integer</code>, for instance, is the analog of <code>int</code>; <code>Boolean</code> of <code>boolean</code>; and so on. The&#13;
distinction between primitive and boxed types has nearly vanished&#13;
because, since Java 5, the Java compiler automatically converts between&#13;
the boxed and unboxed types. It is now legal to say &#13;
<span class="keep-together"><code>Integer i = 1</code>.</span></p>&#13;
&#13;
<p>Kotlin does not have primitive types cluttering up its type system.&#13;
Its single base type, <code>Any</code>, analogous to Java’s <code>Object</code>,&#13;
is the root of the entire Kotlin type hierarchy.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Kotlin’s internal representation of simple types is not connected to&#13;
its type system. The Kotlin compiler has sufficient information to&#13;
represent, for instance, a 32-bit integer with as much&#13;
efficiency as any other language. So, writing <code>val i: Int = 1</code> might&#13;
result in using a primitive type or a boxed type, depending on how the <code>i</code>&#13;
variable is used in the code. Whenever possible, the Kotlin compiler will&#13;
use primitive types.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Null Safety" data-type="sect2"><div class="sect2" id="idm46669766886688">&#13;
<h2>Null Safety</h2>&#13;
&#13;
<p><a data-primary="Kotlin (basics)" data-secondary="null safety" data-type="indexterm" id="ix_ch01-asciidoc2"/><a data-primary="null safety" data-type="indexterm" id="ix_ch01-asciidoc3"/><a data-primary="type system" data-secondary="null safety" data-type="indexterm" id="ix_ch01-asciidoc4"/>A second major difference between Java and Kotlin is that&#13;
<em>nullability</em> is part of Kotlin’s type system. A nullable type is&#13;
distinguished from its nonnullable analog by the question mark at&#13;
the end of its name; for example, <code>String</code> and <code>String?</code>, <code>Person</code> and&#13;
<code>Person?</code>. The Kotlin compiler will allow the assignment of <code>null</code> to a&#13;
nullable type: &#13;
<span class="keep-together"><code>var name: String? = null</code>.</span> It will not, however, permit&#13;
<code>var name: String = null</code> (because <code>String</code> is not a nullable type).</p>&#13;
&#13;
<p><code>Any</code> is the root of the Kotlin type system, just like <code>Object</code> in Java. However, there’s a significant difference: <code>Any</code>&#13;
is the base class for all nonnullable classes, while <code>Any?</code> is the base class for all nullable ones. This is the basis&#13;
of <em>null safety</em>. In other words, it may be useful to think of Kotlin’s type system as two identical&#13;
type trees: all nonnullable types are subtypes of <code>Any</code> and all nullable types are subtypes of <code>Any?</code>.</p>&#13;
&#13;
<p>Variables must be initialized. There is no&#13;
default value for a variable. This code, for instance,&#13;
will generate a compiler error:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">name</code><code class="p">:</code> <code class="n">String</code> <code class="c1">// error! Nonnullable types must be initialized!</code></pre>&#13;
&#13;
<p>As described earlier, the Kotlin compiler makes deductions using type&#13;
information. Often the compiler can figure out the type of an&#13;
identifier from information it already has. This process is called<a data-primary="type inference" data-type="indexterm" id="idm46669761516800"/> <em>type inference</em>. When the compiler can infer a type, there is no need for the developer to specify it. For instance, the assignment <code>var name = "Jerry"</code> is perfectly legal, despite the fact that the type of the variable <code>name</code> has not been specified.  The compiler can infer that the variable <code>name</code> must be a <code>String</code> because it is assigned the value <code>"Jerry"</code> (which is a <code>String</code>).</p>&#13;
&#13;
<p>Inferred types can be surprising, though. This code will generate a&#13;
compiler error:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">var</code> <code class="py">name</code> <code class="p">=</code> <code class="s">"Jerry"</code>&#13;
<code class="n">name</code> <code class="p">=</code> <code class="k">null</code></pre>&#13;
&#13;
<p>The compiler inferred the type <code>String</code> for the variable <code>name</code>,&#13;
not the type <code>String?</code>.  Because <code>String</code> is not a nullable type,&#13;
attempting to assign <code>null</code> to it is illegal.</p>&#13;
&#13;
<p>It is important to note that a <em>nullable</em> type is not the same as its&#13;
<em>nonnullable</em> counterpart.  As makes sense, a nullable type behaves as&#13;
the supertype of the related nonnullable type. This code, for instance, compiles with no problem because a <code>String</code> is a <code>String?</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">name</code> <code class="p">=</code> <code class="n">Jerry</code>&#13;
<code class="k">fun</code> <code class="nf">showNameLength</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">String</code><code class="p">?)</code> <code class="p">{</code> <code class="c1">// Function accepts a nullable parameter</code>&#13;
     <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">showNameLength</code><code class="p">(</code><code class="n">name</code><code class="p">)</code></pre>&#13;
&#13;
<p>On the other hand, the following code will not compile at all, because a <code>String?</code> is <em>not</em> a <code>String</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">name</code><code class="p">:</code> <code class="n">String</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
<code class="k">fun</code> <code class="nf">showNameLength</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// This function only accepts non-nulls</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="n">name</code><code class="p">.</code><code class="n">length</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">showNameLength</code><code class="p">(</code><code class="n">name</code><code class="p">)</code>               <code class="c1">// error! Won't compile because "name"</code>&#13;
                                   <code class="c1">// can be null</code></pre>&#13;
&#13;
<p>Simply changing the type of the parameter will not entirely fix the&#13;
problem:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">name</code><code class="p">:</code> <code class="n">String</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
<code class="k">fun</code> <code class="nf">showNameLength</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">String</code><code class="p">?)</code> <code class="p">{</code> <code class="c1">// This function now accepts nulls</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="n">name</code><code class="p">.</code><code class="n">length</code><code class="p">)</code>            <code class="c1">// error!</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">showNameLength</code><code class="p">(</code><code class="n">name</code><code class="p">)</code>                <code class="c1">// Compiles</code></pre>&#13;
&#13;
<p>This snippet fails with the error <code>Only safe (?.) or non-null asserted (!!.)&#13;
calls are allowed on a nullable receiver of type String?</code>.</p>&#13;
&#13;
<p>Kotlin requires that nullable variables be handled safely—in a way that cannot generate a null pointer exception.  In order&#13;
to make the code compile, it must correctly handle the case in which&#13;
<code>name</code> is <code>null</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">name</code><code class="p">:</code> <code class="n">String</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
<code class="k">fun</code> <code class="nf">showNameLength</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">String</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="k">if</code> <code class="p">(</code><code class="n">name</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code> <code class="m">0</code> <code class="k">else</code> <code class="n">name</code><code class="p">.</code><code class="n">length</code><code class="p">)</code>&#13;
    <code class="c1">// we will use an even nicer syntax shortly</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Kotlin has special operators, <code>?.</code> and <code>?:</code>, that simplify working&#13;
with nullable entities:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">name</code><code class="p">:</code> <code class="n">String</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
<code class="k">fun</code> <code class="nf">showNameLength</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">String</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="n">name</code><code class="o">?.</code><code class="n">length</code> <code class="o">?:</code> <code class="m">0</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the preceding example, when <code>name</code> is not <code>null</code>, the value of <code>name?.length</code> is the same as the value of <code>name.length</code>. When <code>name</code> is <code>null</code>, however, the value of <code>name?.length</code> is <code>null</code>. The expression does not throw a null pointer exception. Thus, the first operator in the previous example, the safe operator <code>?.</code>, is syntactically equivalent to:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">if</code> <code class="p">(</code><code class="n">name</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code> <code class="k">null</code> <code class="k">else</code> <code class="n">name</code><code class="p">.</code><code class="n">length</code></pre>&#13;
&#13;
<p>The second operator, the <em>elvis operator</em> <code>?:</code>, returns the left expression if it is non-null, or the right expression otherwise. Note that the expression on the right-hand side is evaluated only if the left expression is null.</p>&#13;
&#13;
<p>It is equivalent to:<a data-startref="ix_ch01-asciidoc4" data-type="indexterm" id="idm46669762028256"/><a data-startref="ix_ch01-asciidoc3" data-type="indexterm" id="idm46669762027520"/><a data-startref="ix_ch01-asciidoc2" data-type="indexterm" id="idm46669762026848"/></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">if</code> <code class="p">(</code><code class="n">name</code><code class="o">?.</code><code class="n">length</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code> <code class="m">0</code> <code class="k">else</code> <code class="n">name</code><code class="p">.</code><code class="n">length</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Unit Type" data-type="sect2"><div class="sect2" id="idm46669766885872">&#13;
<h2>The Unit Type</h2>&#13;
&#13;
<p><a data-primary="Kotlin (basics)" data-secondary="unit type" data-type="indexterm" id="idm46669761998560"/><a data-primary="type system" data-secondary="unit type" data-type="indexterm" id="idm46669761997360"/><a data-primary="unit type" data-type="indexterm" id="idm46669761996416"/>In Kotlin, <em>everything</em> has a value. Always. Once you understand this,&#13;
it is not difficult to imagine that even a method that doesn’t specifically return&#13;
anything has a default value. That default value is named <code>Unit</code>.&#13;
<code>Unit</code> is the name of exactly one object, the value things have if&#13;
they don’t have any other value. The type of the <a data-primary="Unit" data-type="indexterm" id="idm46669761994000"/><code>Unit</code> object is,&#13;
conveniently, named <code>Unit</code>.</p>&#13;
&#13;
<p>The whole concept of <code>Unit</code> can seem odd to Java developers who are&#13;
used to a distinction between expressions—things that have a value—and statements—things that don’t.</p>&#13;
&#13;
<p>Java’s conditional is a great example of the distinction between a&#13;
<em>statement</em> and an <em>expression</em> because it has one of each! In Java&#13;
you can say:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">if</code> <code class="o">(</code><code class="n">maybe</code><code class="o">)</code> <code class="n">doThis</code><code class="o">()</code> <code class="k">else</code> <code class="n">doThat</code><code class="o">();</code></pre>&#13;
&#13;
<p class="pagebreak-before">You cannot, however, say:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kt">int</code> <code class="n">n</code> <code class="o">=</code> <code class="k">if</code> <code class="o">(</code><code class="n">maybe</code><code class="o">)</code> <code class="n">doThis</code><code class="o">()</code> <code class="k">else</code> <code class="n">doThat</code><code class="o">();</code></pre>&#13;
&#13;
<p>Statements, like the <code>if</code> statement, do not return a value.  You cannot&#13;
assign the value of an <code>if</code> statement to a variable, because <code>if</code> statements don’t return anything.&#13;
The same is true for loop statements, case statements, and so on.</p>&#13;
&#13;
<p>Java’s <code>if</code> statement, however, has an analog, the<a data-primary="ternary expression" data-type="indexterm" id="idm46669761908864"/> <em>ternary expression</em>.&#13;
Since it is an expression, it returns a value and that value&#13;
can be assigned. This is legal Java (provided both <code>doThis</code> and&#13;
<code>doThat</code> return integers):</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kt">int</code> <code class="n">n</code> <code class="o">=</code> <code class="o">(</code><code class="n">maybe</code><code class="o">)</code> <code class="o">?</code> <code class="n">doThis</code><code class="o">()</code> <code class="o">:</code> <code class="n">doThat</code><code class="o">();</code></pre>&#13;
&#13;
<p>In Kotlin, there is no need for two conditionals because <code>if</code> is an expression and returns a value.&#13;
For example, this is perfectly legal:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">n</code> <code class="p">=</code> <code class="k">if</code> <code class="p">(</code><code class="n">maybe</code><code class="p">)</code> <code class="n">doThis</code><code class="p">()</code> <code class="k">else</code> <code class="n">doThat</code><code class="p">()</code></pre>&#13;
&#13;
<p>In Java, a method with <code>void</code> as the return type is like a statement. Actually, this is a&#13;
bit of a misnomer because <code>void</code> isn’t a type. It is a reserved word in the Java&#13;
language that indicates that the method does not return a value. When Java introduced generics, it&#13;
introduced the type <code>Void</code> to fill the void (intended!). The two&#13;
representations of “nothing,” the keyword and the type, however, are&#13;
confusing and inconsistent: a function whose return type is <code>Void</code>&#13;
must explicitly return <code>null</code>.</p>&#13;
&#13;
<p>Kotlin is much more consistent: all functions return a value and have a type. If the code for a function does not return a value explicitly, the function has the value <code>Unit</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Function Types" data-type="sect2"><div class="sect2" id="idm46669761999184">&#13;
<h2>Function Types</h2>&#13;
&#13;
<p><a data-primary="function types" data-type="indexterm" id="ix_ch01-asciidoc5"/><a data-primary="Kotlin (basics)" data-secondary="function types" data-type="indexterm" id="ix_ch01-asciidoc6"/><a data-primary="type system" data-secondary="function types" data-type="indexterm" id="ix_ch01-asciidoc7"/>Kotlin’s type system supports <em>function types</em>. For example, the following code defines a variable, <code>func</code>, whose value is a function, the lambda <code>{ x -&gt; x.pow(2.0) }</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">func</code><code class="p">:</code> <code class="p">(</code><code class="n">Double</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Double</code> <code class="p">=</code> <code class="p">{</code> <code class="n">x</code> <code class="p">-&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">pow</code><code class="p">(</code><code class="m">2.0</code><code class="p">)</code> <code class="p">}</code></pre>&#13;
&#13;
<p>Since <code>func</code> is a function that takes one <code>Double</code> type argument and returns a <code>Double</code>, it’s type is <code>(Double) -&gt;&#13;
Double</code>.</p>&#13;
&#13;
<p>In the previous example, we specified the type of <code>func</code> explicitly.&#13;
However, the Kotlin compiler can infer a lot about the type of the&#13;
variable <code>func</code> from the value assigned to it.  It knows the return&#13;
type because it knows the type of <code>pow</code>.  It doesn’t, however, have&#13;
enough information to guess the type of the parameter <code>x</code>.  If we&#13;
supply that, though, we can omit the type specifier for the variable:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">func</code> <code class="p">=</code> <code class="p">{</code> <code class="n">x</code><code class="p">:</code> <code class="n">Double</code> <code class="p">-&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">pow</code><code class="p">(</code><code class="m">2.0</code><code class="p">)}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Java’s type system cannot describe a function type—there is no way&#13;
to talk about functions outside the context of the classes that&#13;
contain them. In Java, to do something similar to the previous example, we would use the functional type <code>Function</code>, like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Function</code><code class="o">&lt;</code><code class="n">Double</code><code class="o">,</code> <code class="n">Double</code><code class="o">&gt;</code> <code class="n">func</code>&#13;
    <code class="o">=</code> <code class="n">x</code> <code class="o">-&gt;</code> <code class="n">Math</code><code class="o">.</code><code class="na">pow</code><code class="o">(</code><code class="n">x</code><code class="o">,</code> <code class="mf">2.0</code><code class="o">);</code>&#13;
&#13;
<code class="n">func</code><code class="o">.</code><code class="na">apply</code><code class="o">(</code><code class="mf">256.0</code><code class="o">);</code></pre>&#13;
&#13;
<p>The variable <code>func</code> has been assigned an anonymous instance of the&#13;
type <code>Function</code> whose method <code>apply</code> is the given lambda.</p>&#13;
</div>&#13;
&#13;
<p>Thanks to function types, functions can receive other functions as parameters or return them as values. We call these<a data-primary="higher-order functions" data-type="indexterm" id="idm46669761702992"/> <em>higher-order functions</em>.&#13;
Consider a template for a Kotlin type: <code>(A, B) -&gt; C</code>.  It describes a function&#13;
that takes two parameters, one of type <code>A</code> and one of type <code>B</code>&#13;
(whatever types those may be), and returns a value of type <code>C</code>. Because&#13;
Kotlin’s type language can describe functions, <code>A</code>, <code>B</code>, and <code>C</code> can all,&#13;
themselves, be functions.</p>&#13;
&#13;
<p>If that sounds rather meta, it’s because it is. Let’s make it more&#13;
concrete. For <code>A</code> in the template, let’s substitute <code>(Double, Double)</code> <code>-&gt;</code> <code>Int</code>. That’s a function that takes two <code>Double</code>s and returns an <code>Int</code>. For&#13;
<code>B</code>, let’s just substitute a <code>Double</code>.  So far, we have <code>((Double,&#13;
Double)</code> <code>-&gt;</code> <code>Int,</code> <code>Double)</code> <code>-&gt;</code> <code>C</code>.</p>&#13;
&#13;
<p>Finally, let’s say our new functional type returns a <code>(Double)</code> <code>-&gt;</code> <code>Int</code>,&#13;
a function that takes one parameter, a <code>Double</code>, and returns an <code>Int</code>. The following code shows the complete signature for our hypothetical function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">getCurve</code><code class="p">(</code>&#13;
    <code class="n">surface</code><code class="p">:</code> <code class="p">(</code><code class="n">Double</code><code class="p">,</code> <code class="n">Double</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Int</code><code class="p">,</code>&#13;
    <code class="n">x</code><code class="p">:</code> <code class="n">Double</code>&#13;
<code class="p">):</code> <code class="p">(</code><code class="n">Double</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Int</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="n">y</code> <code class="p">-&gt;</code> <code class="n">surface</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">)</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We have just described a function type that takes two arguments. The first is a function (<code>surface</code>) of two parameters, both <code>Double</code>s, that returns an <code>Int</code>. The second is a <code>Double</code> (<code>x</code>).&#13;
Our <code>getCurve</code> function returns a function that takes one parameter, a &#13;
<span class="keep-together"><code>Double</code></span> (<code>y</code>),&#13;
and returns an <code>Int</code>.</p>&#13;
&#13;
<p>The ability to pass functions as arguments into other functions is a pillar of functional languages.&#13;
Using higher-order functions, you can reduce code redundancy, while not having to create new&#13;
classes as you would in Java (subclassing <code>Runnable</code> or <code>Function</code> interfaces).&#13;
When used wisely, higher-order functions improve code<a data-startref="ix_ch01-asciidoc7" data-type="indexterm" id="idm46669761588208"/><a data-startref="ix_ch01-asciidoc6" data-type="indexterm" id="idm46669761587616"/><a data-startref="ix_ch01-asciidoc5" data-type="indexterm" id="idm46669761586944"/> &#13;
<span class="keep-together">readability.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generics" data-type="sect2"><div class="sect2" id="idm46669761835136">&#13;
<h2>Generics</h2>&#13;
&#13;
<p><a data-primary="generics" data-type="indexterm" id="idm46669761584176"/><a data-primary="Kotlin (basics)" data-secondary="generics" data-type="indexterm" id="idm46669761583472"/><a data-primary="type system" data-secondary="generics" data-type="indexterm" id="idm46669761582528"/>Like Java, Kotlin’s type system supports type variables.  For instance:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">simplePair</code><code class="p">(</code><code class="n">x</code><code class="p">:</code> <code class="n">T</code><code class="p">,</code> <code class="n">y</code><code class="p">:</code> <code class="n">T</code><code class="p">)</code> <code class="p">=</code> <code class="n">Pair</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">)</code></pre>&#13;
&#13;
<p>This function creates a Kotlin <code>Pair</code> object in which both of the&#13;
elements must be of the same type. Given this definition,&#13;
&#13;
<span class="keep-together"><code>simplePair("Hello", "Goodbye")</code></span> and <code>simplePair(4, 5)</code> are both&#13;
legal, but <code>simplePair("Hello", 5)</code> is not.</p>&#13;
&#13;
<p>The generic type denoted as <code>T</code> in the definition of <code>simplePair</code> is a type variable:&#13;
the values it can take are Kotlin types (in this example, <code>String</code> or&#13;
<code>Int</code>).  A function (or a class) that uses a type variable is said to be&#13;
<em>generic</em>.<a data-startref="ix_ch01-asciidoc1" data-type="indexterm" id="idm46669761558256"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Variables and Functions" data-type="sect1"><div class="sect1" id="idm46669761557520">&#13;
<h1>Variables and Functions</h1>&#13;
&#13;
<p><a data-primary="Kotlin (basics)" data-secondary="variables and functions" data-type="indexterm" id="ix_ch01-asciidoc8"/>Now that we have Kotlin’s type language to support us, we can start to&#13;
discuss the syntax of Kotlin itself.</p>&#13;
&#13;
<p>In Java the top-level syntactic entity is the class.  All variables&#13;
and methods are members of some class or other, and the class is the&#13;
main element in a homonymous file.</p>&#13;
&#13;
<p>Kotlin has no such limitations.  You can put your entire program in&#13;
one file, if you like (please don’t). You can also define variables&#13;
and functions outside any class.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Variables" data-type="sect2"><div class="sect2" id="idm46669760228464">&#13;
<h2>Variables</h2>&#13;
&#13;
<p><a data-primary="Kotlin (basics)" data-secondary="variables" data-type="indexterm" id="idm46669760227216"/>There are two ways to declare a variable: with the keywords <code>val</code> and&#13;
<code>var</code>. The keyword is required, is the first thing on the line, and&#13;
introduces the declaration:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">ronDeeLay</code> <code class="p">=</code> <code class="s">"the night time"</code></pre>&#13;
&#13;
<p>The keyword <code>val</code> creates a variable that is read-only: it cannot be&#13;
reassigned. Be careful, though! You might think <code>val</code> is like a Java variable&#13;
declared using the <code>final</code> &#13;
<span class="keep-together">keyword.</span>  Though similar, it is not the same!&#13;
Although it cannot be reassigned, a <code>val</code> definitely can change value!  A <code>val</code>&#13;
variable in Kotlin is more like a Java class’s field, which has a getter but no setter,&#13;
as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">surprising</code><code class="p">:</code> <code class="n">Double</code>&#13;
    <code class="k">get</code><code class="p">()</code> <code class="p">=</code> <code class="n">Math</code><code class="p">.</code><code class="n">random</code><code class="p">()</code></pre>&#13;
&#13;
<p>Every time <code>surprising</code> is accessed, it will return a different random value. This is an example of a property with&#13;
no <em>backing field</em>. We’ll cover properties later in this chapter.&#13;
On the other hand, if we had written <code>val rand = Random()</code>, then <code>rand</code> wouldn’t change in value and would be more like a <code>final</code> variable in Java.</p>&#13;
&#13;
<p>The second keyword, <code>var</code>, creates a familiar mutable variable: like a&#13;
little box that holds the last thing that was put into it.</p>&#13;
&#13;
<p>In the next section, we will move on to one of Kotlin’s features as a functional language: <em>lambdas</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambdas" data-type="sect2"><div class="sect2" id="idm46669760178560">&#13;
<h2>Lambdas</h2>&#13;
&#13;
<p><a data-primary="Kotlin (basics)" data-secondary="lambdas" data-type="indexterm" id="idm46669760176928"/><a data-primary="lambdas" data-type="indexterm" id="idm46669760175952"/>Kotlin supports function literals: lambdas.  In Kotlin, lambdas are always surrounded by curly braces.&#13;
Within the braces, the argument list is to the left of an arrow, <code>-&gt;</code>, and the expression that is the&#13;
value of executing the lambda is to the right, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="p">{</code> <code class="n">x</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">y</code><code class="p">:</code> <code class="n">Int</code> <code class="p">-&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="n">y</code> <code class="p">}</code></pre>&#13;
&#13;
<p>By convention, the returned value is the value of the last expression in&#13;
the body of the lambda.  For example, the function shown in the following code is of type&#13;
<code>(Int, Int) -&gt; String</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="p">{</code> <code class="n">x</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">y</code><code class="p">:</code> <code class="n">Int</code> <code class="p">-&gt;</code> <code class="n">x</code> <code class="p">*</code> <code class="n">y</code><code class="p">;</code> <code class="s">"down on the corner"</code> <code class="p">}</code></pre>&#13;
&#13;
<p>Kotlin has a very interesting feature that allows actually extending&#13;
the language. When the last argument to a function is another&#13;
function (the function is higher-order), you can move the lambda&#13;
expression passed as a parameter out of the parentheses that normally&#13;
delimit the actual parameter list, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// The last argument, "callback", is a function</code>&#13;
<code class="k">fun</code> <code class="nf">apiCall</code><code class="p">(</code><code class="n">param</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">callback</code><code class="p">:</code> <code class="p">()</code> <code class="p">-&gt;</code> <code class="n">Unit</code><code class="p">)</code></pre>&#13;
&#13;
<p class="pagebreak-before">This function would typically be used like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">apiCall</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="p">{</code> <code class="n">println</code><code class="p">(</code><code class="s">"I'm called back!"</code><code class="p">)})</code></pre>&#13;
&#13;
<p>But thanks to the language feature we mentioned, it can also be used like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">apiCall</code><code class="p">(</code><code class="m">1</code><code class="p">)</code> <code class="p">{</code>&#13;
   <code class="n">println</code><code class="p">(</code><code class="s">"I'm called back!"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is much nicer, isn’t it? Thanks to this feature, your code can be more readable. A more advanced&#13;
usage of this feature are <code>DSL</code>s.<sup><a data-type="noteref" href="ch01.html#idm46669760026992" id="idm46669760026992-marker">3</a></sup></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Extension Functions" data-type="sect2"><div class="sect2" id="idm46669760177904">&#13;
<h2>Extension Functions</h2>&#13;
&#13;
<p><a data-primary="extension functions" data-type="indexterm" id="ix_ch01-asciidoc9"/><a data-primary="Kotlin (basics)" data-secondary="extension functions" data-type="indexterm" id="ix_ch01-asciidoc10"/>When you need to add a new method to an existing class, and that class comes from a dependency whose source code you don’t own, what do you do?</p>&#13;
&#13;
<p>In Java, if the class isn’t <code>final</code>, you can subclass it. Sometimes this isn’t ideal, because there’s one more&#13;
type to manage, which adds complexity to the project. If the class is <code>final</code>, you can define a static method&#13;
inside some utility class of your own, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nc">FileUtils</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">getWordAtIndex</code><code class="o">(</code><code class="n">File</code> <code class="n">file</code><code class="o">,</code> <code class="kt">int</code> <code class="n">index</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="cm">/* Implementation hidden for brevity */</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>In the previous example, we defined a function to get a word in a text file, at a given index. On the use site, you’d write <code>String word =</code> &#13;
<span class="keep-together"><code>getWordAtIndex(file,</code></span> <code>3)</code>, assuming you make the static import of &#13;
<span class="keep-together"><code>FileUtils.getWordAtIndex</code>.</span>&#13;
That’s fine, we’ve been doing that for years in Java, and it works.</p>&#13;
&#13;
<p>In Kotlin, there’s one more thing you can do. You have the ability to define a new method on a class,&#13;
even though it isn’t a real member-function of that class. So you’re not really extending the class, but&#13;
on the use site it feels like you added a method to the class. How is this possible? By defining an&#13;
<em>extension function</em>, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// declared inside FileUtils.kt</code>&#13;
<code class="k">fun</code> <code class="nf">File</code><code class="p">.</code><code class="n">getWordAtIndex</code><code class="p">(</code><code class="n">index</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">String</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">context</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">readText</code><code class="p">()</code>  <code class="c1">// 'this' corresponds to the file</code>&#13;
    <code class="k">return</code> <code class="n">context</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="sc">' '</code><code class="p">).</code><code class="n">getOrElse</code><code class="p">(</code><code class="n">index</code><code class="p">)</code> <code class="p">{</code> <code class="s">""</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>From inside the declaration of the extension function, <code>this</code> refers to the receiving type instance (here, a <code>File</code>).&#13;
You only have access to public and internal attributes and methods, so <code>private</code> and <code>protected</code> fields are&#13;
inaccessible—you’ll understand why shortly.</p>&#13;
&#13;
<p>On the use site, you would write <code>val word = file.getWordAtIndex(3)</code>. As you can see, we invoke the <code>getWordAtIndex()</code>&#13;
function on a <code>File</code> instance, as if the <code>File</code> class had the <code>getWordAtIndex()</code> member-function. That makes the use&#13;
site more expressive and readable. We didn’t have to come up with a name for a new utility class: we can declare&#13;
extension functions directly at the root of a source file.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Let’s have a look at the decompiled version of <code>getWordAtIndex</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">FileUtilsKt</code> <code class="o">{</code>&#13;
    <code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">getWordAtIndex</code><code class="o">(</code>&#13;
            <code class="n">File</code> <code class="n">file</code><code class="o">,</code> <code class="kt">int</code> <code class="n">index</code>&#13;
    <code class="o">)</code> <code class="o">{</code>&#13;
        <code class="cm">/* Implementation hidden for brevity */</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>When compiled, the generated bytecode of our extension function is the equivalent of a static method which&#13;
takes a <code>File</code> as its first argument. The enclosing class, <code>FileUtilsKt</code>, is named after the name of the source&#13;
file (<em>FileUtils.kt</em>) with the “kt” suffix.</p>&#13;
&#13;
<p>That explains why we can’t access private fields in an extension function: we are just adding a static method&#13;
that takes the receiving type as a parameter.</p>&#13;
</div>&#13;
&#13;
<p>There’s more! For class attributes, you can declare<a data-primary="extension properties" data-type="indexterm" id="idm46669759840288"/> <em>extension properties</em>. The idea is exactly the&#13;
same—you’re not really extending a class, but you can make new attributes accessible using the dot notation, as&#13;
shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// The Rectangle class has width and height properties</code>&#13;
<code class="k">val</code> <code class="py">Rectangle</code><code class="p">.</code><code class="n">area</code><code class="p">:</code> <code class="n">Double</code>&#13;
    <code class="k">get</code><code class="p">()</code> <code class="p">=</code> <code class="n">width</code> <code class="p">*</code> <code class="n">height</code></pre>&#13;
&#13;
<p>Notice that this time we used <code>val</code> (instead of <code>fun</code>) to declare the extension property. You would use it like so:&#13;
<code>val area = rectangle.area</code>.</p>&#13;
&#13;
<p>Extension functions and extension properties allow you to extend classes’ capabilities, with a nice dot-notation&#13;
usage, while still preserving separation of concern. You’re not cluttering existing classes with specific code for&#13;
particular needs<a data-startref="ix_ch01-asciidoc10" data-type="indexterm" id="idm46669759798768"/><a data-startref="ix_ch01-asciidoc9" data-type="indexterm" id="idm46669759798096"/>.<a data-startref="ix_ch01-asciidoc8" data-type="indexterm" id="idm46669759797296"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Classes" data-type="sect1"><div class="sect1" id="idm46669759999200">&#13;
<h1>Classes</h1>&#13;
&#13;
<p><a data-primary="classes" data-type="indexterm" id="ix_ch01-asciidoc11"/><a data-primary="Kotlin (basics)" data-secondary="classes" data-type="indexterm" id="ix_ch01-asciidoc12"/>Classes in Kotlin, at first, look a lot like they do in Java: the&#13;
<code>class</code> keyword, followed by the block that defines the class. One of&#13;
Kotlin’s killer features, though, is the syntax for the constructor&#13;
and the ability to declare properties within it. The following code shows the definition of a simple <code>Point</code> class along with a couple of uses:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Point</code><code class="p">(</code><code class="k">val</code> <code class="py">x</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="k">var</code> <code class="py">y</code><code class="p">:</code> <code class="n">Int</code><code class="p">?</code> <code class="p">=</code> <code class="m">3</code><code class="p">)</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">demo</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">pt1</code> <code class="p">=</code> <code class="n">Point</code><code class="p">(</code><code class="m">4</code><code class="p">)</code>&#13;
    <code class="n">assertEquals</code><code class="p">(</code><code class="m">3</code><code class="p">,</code> <code class="n">pt1</code><code class="p">.</code><code class="n">y</code><code class="p">)</code>&#13;
    <code class="n">pt1</code><code class="p">.</code><code class="n">y</code> <code class="p">=</code> <code class="m">7</code>&#13;
    <code class="k">val</code> <code class="py">pt2</code> <code class="p">=</code> <code class="n">Point</code><code class="p">(</code><code class="m">7</code><code class="p">,</code> <code class="m">7</code><code class="p">)</code>&#13;
    <code class="n">assertEquals</code><code class="p">(</code><code class="n">pt2</code><code class="p">.</code><code class="n">y</code><code class="p">,</code> <code class="n">pt1</code><code class="p">.</code><code class="n">y</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Class Initialization" data-type="sect2"><div class="sect2" id="idm46669759760016">&#13;
<h2>Class Initialization</h2>&#13;
&#13;
<p><a data-primary="class initialization" data-type="indexterm" id="ix_ch01-asciidoc13"/><a data-primary="classes" data-secondary="class initialization" data-type="indexterm" id="ix_ch01-asciidoc14"/><a data-primary="Kotlin (basics)" data-secondary="class initialization" data-type="indexterm" id="ix_ch01-asciidoc15"/>Notice that in the preceding code, the constructor of <code>Point</code> is embedded in&#13;
the declaration of the class.  It is called the<a data-primary="primary constructor" data-type="indexterm" id="idm46669759661744"/> <em>primary constructor</em>.&#13;
<code>Point</code>’s primary constructor declares two&#13;
class properties, <code>x</code> and <code>y</code>, both of which are integers.  The first,&#13;
<code>x</code>, is read-only. The second, <code>y</code>, is mutable and nullable, and has a&#13;
default value of 3.</p>&#13;
&#13;
<p>Note that the <code>var</code> and <code>val</code> keywords are very significant!  The&#13;
declaration <code>class Point(x: Int, y: Int)</code> is <em>very</em> different from the&#13;
preceding declaration because it does not declare any member properties.&#13;
Without the keywords, identifiers <code>x</code> and <code>y</code> are simply arguments to&#13;
the constructor.  For example, the following code will generate an&#13;
error:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Point</code><code class="p">(</code><code class="n">x</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">y</code><code class="p">:</code> <code class="n">Int</code><code class="p">?)</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">demo</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">pt</code> <code class="p">=</code> <code class="n">Point</code><code class="p">(</code><code class="m">4</code><code class="p">)</code>&#13;
    <code class="n">pt</code><code class="p">.</code><code class="n">y</code> <code class="p">=</code> <code class="m">7</code> <code class="c1">// error!  Variable expected</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>Point</code> class in this example has only one constructor, the one&#13;
defined in its declaration.  Classes are not limited to this single constructor,&#13;
though. In Kotlin, you can also define both secondary constructors and&#13;
initialization blocks, as shown in the following definition of the <code>Segment</code>&#13;
class:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Segment</code><code class="p">(</code><code class="k">val</code> <code class="py">start</code><code class="p">:</code> <code class="n">Point</code><code class="p">,</code> <code class="k">val</code> <code class="py">end</code><code class="p">:</code> <code class="n">Point</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">length</code><code class="p">:</code> <code class="n">Double</code> <code class="p">=</code> <code class="n">sqrt</code><code class="p">(</code>&#13;
            <code class="p">(</code><code class="n">end</code><code class="p">.</code><code class="n">x</code> <code class="p">-</code> <code class="n">start</code><code class="p">.</code><code class="n">x</code><code class="p">).</code><code class="n">toDouble</code><code class="p">().</code><code class="n">pow</code><code class="p">(</code><code class="m">2.0</code><code class="p">)</code>&#13;
                    <code class="p">+</code> <code class="p">(</code><code class="n">end</code><code class="p">.</code><code class="n">y</code> <code class="p">-</code> <code class="n">start</code><code class="p">.</code><code class="n">y</code><code class="p">).</code><code class="n">toDouble</code><code class="p">().</code><code class="n">pow</code><code class="p">(</code><code class="m">2.0</code><code class="p">))</code>&#13;
&#13;
    <code class="n">init</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Point starting at $start with length $length"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">constructor</code><code class="p">(</code><code class="n">x1</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">y1</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">x2</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">y2</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">:</code>&#13;
            <code class="k">this</code><code class="p">(</code><code class="n">Point</code><code class="p">(</code><code class="n">x1</code><code class="p">,</code> <code class="n">y1</code><code class="p">),</code> <code class="n">Point</code><code class="p">(</code><code class="n">x2</code><code class="p">,</code> <code class="n">y2</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Secondary constructor"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>There are some other things that are of interest in this example.&#13;
First of all, note that a secondary constructor must delegate to the&#13;
primary constructor, the <code>: this(...)</code>, in its declaration. The&#13;
constructor may have a block of code, but it is required to delegate,&#13;
explicitly, to the primary constructor, first.</p>&#13;
&#13;
<p>Perhaps more interesting is the order of execution of the code in the&#13;
preceding declaration.  Suppose one were to create a new <code>Segment</code>, using&#13;
the secondary constructor.  In what order would the print statements&#13;
appear?</p>&#13;
&#13;
<p>Well!  Let’s try it and see:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">&gt;&gt;&gt; val <code class="nv">s</code> <code class="o">=</code> Segment<code class="o">(</code>1, 2, 3, 4<code class="o">)</code>&#13;
&#13;
Point starting at Point<code class="o">(</code><code class="nv">x</code><code class="o">=</code>1, <code class="nv">y</code><code class="o">=</code>2<code class="o">)</code> with length 2.8284271247461903&#13;
Secondary constructor</pre>&#13;
&#13;
<p>This is pretty interesting.  The <code>init</code> block is run before the code&#13;
block associated with secondary constructor! On the other hand, the&#13;
properties <code>length</code> and <code>start</code> have been initialized with their&#13;
constructor-supplied values. That means that the primary constructor&#13;
must have been run even before the <code>init</code> block.</p>&#13;
&#13;
<p>In fact, Kotlin guarantees this ordering: the primary constructor (if&#13;
there is one) is run first.  After it finishes, <code>init</code> blocks are run&#13;
in declaration order (top to bottom).  If the new instance is being&#13;
created using a secondary constructor, the code block associated with&#13;
that constructor is the last thing to run.<a data-startref="ix_ch01-asciidoc15" data-type="indexterm" id="idm46669759405728"/><a data-startref="ix_ch01-asciidoc14" data-type="indexterm" id="idm46669759405136"/><a data-startref="ix_ch01-asciidoc13" data-type="indexterm" id="idm46669759404464"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Properties" data-type="sect2"><div class="sect2" id="idm46669759759424">&#13;
<h2>Properties</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="properties" data-type="indexterm" id="idm46669766855280"/><a data-primary="Kotlin (basics)" data-secondary="properties" data-type="indexterm" id="idm46669766854144"/><a data-primary="properties" data-type="indexterm" id="idm46669766853200"/>Kotlin variables, declared using <code>val</code> or <code>var</code> in a constructor, or at&#13;
the top level of a class, actually define a <em>property</em>. A property, in&#13;
Kotlin, is like the combination of a Java field and its getter (if&#13;
the property is read-only, defined with <code>val</code>), or its getter and setter (if&#13;
defined with <code>var</code>).</p>&#13;
&#13;
<p>Kotlin supports customizing the accessor and mutator for a property&#13;
and has special syntax for doing so, as shown here in the definition of&#13;
the class <code>Rectangle</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Rectangle</code><code class="p">(</code><code class="k">val</code> <code class="py">l</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="k">val</code> <code class="py">w</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">area</code><code class="p">:</code> <code class="n">Int</code>&#13;
        <code class="k">get</code><code class="p">()</code> <code class="p">=</code> <code class="n">l</code> <code class="p">*</code> <code class="n">w</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The property <code>area</code> is <em>synthetic</em>: it is computed from the values&#13;
for the length and width.  Because it wouldn’t make sense to assign&#13;
to <code>area</code>, it is a <code>val</code>, read-only, and does not have a <code>set()</code> method.</p>&#13;
&#13;
<p>Use standard “dot” notation to access the value of a property:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">rect</code> <code class="p">=</code> <code class="n">Rectangle</code><code class="p">(</code><code class="m">3</code><code class="p">,</code> <code class="m">4</code><code class="p">)</code>&#13;
<code class="n">assertEquals</code><code class="p">(</code><code class="m">12</code><code class="p">,</code> <code class="n">rect</code><code class="p">.</code><code class="n">area</code><code class="p">)</code></pre>&#13;
&#13;
<p>In order to further explore custom property getters and setters,&#13;
consider a class that has a hash code that is used frequently&#13;
(perhaps instances are kept in a <code>Map</code>), and that is quite&#13;
expensive to calculate.  As a design decision, you decide to&#13;
cache the hash code, and to set it when the value of a class&#13;
property changes.  A first try might look something like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// This code doesn't work (we'll see why)</code>&#13;
<code class="k">class</code> <code class="nc">ExpensiveToHash</code><code class="p">(</code><code class="n">_summary</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">var</code> <code class="py">summary</code><code class="p">:</code> <code class="n">String</code> <code class="p">=</code> <code class="n">_summary</code>&#13;
        <code class="k">set</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">summary</code> <code class="p">=</code> <code class="n">value</code>    <code class="c1">// unbounded recursion!!</code>&#13;
            <code class="n">hashCode</code> <code class="p">=</code> <code class="n">computeHash</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
&#13;
    <code class="c1">//  other declarations here...</code>&#13;
    <code class="k">var</code> <code class="py">hashCode</code><code class="p">:</code> <code class="n">Long</code> <code class="p">=</code> <code class="n">computeHash</code><code class="p">()</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">fun</code> <code class="nf">computeHash</code><code class="p">():</code> <code class="n">Long</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The preceding code will fail because of unbounded recursion: the assignment to <code>summary</code> is a call to <code>summary.set()</code>! Attempting to set the value of the property&#13;
inside its own setter won’t work.&#13;
Kotlin uses the special identifier <code>field</code> to address this problem.&#13;
The following shows the corrected version of the code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">ExpensiveToHash</code><code class="p">(</code><code class="n">_summary</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">var</code> <code class="py">summary</code><code class="p">:</code> <code class="n">String</code> <code class="p">=</code> <code class="n">_summary</code>&#13;
        <code class="k">set</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">field</code> <code class="p">=</code> <code class="n">value</code>&#13;
            <code class="n">hashCode</code> <code class="p">=</code> <code class="n">computeHash</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
&#13;
    <code class="c1">//  other declarations here...</code>&#13;
    <code class="k">var</code> <code class="py">hashCode</code><code class="p">:</code> <code class="n">Long</code> <code class="p">=</code> <code class="n">computeHash</code><code class="p">()</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">fun</code> <code class="nf">computeHash</code><code class="p">():</code> <code class="n">Long</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The<a data-primary="identifier field" data-type="indexterm" id="idm46669759205424"/> identifier <code>field</code> has a special meaning only within the custom&#13;
getter and setter, where it refers to the <em>backing field</em> that&#13;
contains the property’s state.</p>&#13;
&#13;
<p>Notice, also, that the preceding code demonstrates the idiom for&#13;
initializing a property that has a custom getter/setter with a value&#13;
provided to the class constructor.  Defining properties in a&#13;
constructor parameter list is really handy shorthand.  If a few property&#13;
definitions in a constructor had custom getters and&#13;
setters, though, it could make the constructor really hard to read.</p>&#13;
&#13;
<p>When a property with a custom getter and setter must be initialized&#13;
from the constructor, the property is defined, along with its custom&#13;
getter and setter, in the body of the class.  The property is&#13;
initialized with a parameter from the constructor (in this case,&#13;
<code>_summary</code>).  This illustrates, again, the importance of the keywords&#13;
<code>val</code> and <code>var</code> in a constructor’s parameter list.  The parameter&#13;
<code>_summary</code> is just a parameter, not a class property, because it is&#13;
declared without either keyword.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="lateinit Properties" data-type="sect2"><div class="sect2" id="idm46669759403200">&#13;
<h2>lateinit Properties</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="lateinit properties" data-type="indexterm" id="ix_ch01-asciidoc16"/><a data-primary="Kotlin (basics)" data-secondary="lateinit properties" data-type="indexterm" id="ix_ch01-asciidoc17"/><a data-primary="lateinit properties" data-type="indexterm" id="ix_ch01-asciidoc18"/>There are times when a variable’s value is not available at the site&#13;
of its declaration.  An obvious example of this for Android&#13;
developers is a UI widget used in an <code>Activity</code> or <code>Fragment</code>.  It is not&#13;
until the<a data-primary="onCreate" data-type="indexterm" id="idm46669759117936"/> <code>onCreate</code> or<a data-primary="onCreateView" data-type="indexterm" id="idm46669759116656"/> <code>onCreateView</code> method runs that the variable,&#13;
used throughout the activity to refer to the widget, can be&#13;
initialized. The <code>button</code> in this example, for instance:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyFragment</code><code class="p">:</code> <code class="n">Fragment</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">var</code> <code class="py">button</code><code class="p">:</code> <code class="n">Button</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code> <code class="c1">// will provide actual value later</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The variable must be initialized.  A standard technique, since we&#13;
can’t know the value, yet, is to make the variable nullable and&#13;
initialize it with <code>null</code>.</p>&#13;
&#13;
<p>The first question you should ask yourself in this situation is&#13;
whether it is really necessary to define this variable at this&#13;
moment and at this location. Will the <code>button</code> reference really be&#13;
used in several methods or is it really only used in one or two&#13;
specific places? If the latter, you can eliminate the class global altogether.</p>&#13;
&#13;
<p>However, the problem with using a nullable type is that whenever you use &#13;
<span class="keep-together"><code>button</code> in your code,</span> you will have to check for nullability. For example: &#13;
<span class="keep-together"><code>button?.setOnClickListener { .. }</code>.</span> A couple of variables like this and you’ll end up with a lot of annoying question marks! This can look particularly cluttered if you are used to Java and its simple dot notation.</p>&#13;
&#13;
<p>Why, you might ask, does Kotlin prevent me from declaring the <code>button</code>&#13;
using a non-null type when you are <em>sure</em> that you will initialize it&#13;
before anything tries to access it? Isn’t there a way to relax the&#13;
compiler’s initialization rule just for this <code>button</code>?</p>&#13;
&#13;
<p>It’s possible. You can do exactly that using the <code>lateinit</code> modifier,&#13;
as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyFragment</code><code class="p">:</code> <code class="n">Fragment</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="n">lateinit</code> <code class="k">var</code> <code class="py">button</code><code class="p">:</code> <code class="n">Button</code> <code class="c1">// will initialize later</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because the variable is declared <code>lateinit</code>, Kotlin will let you&#13;
declare it without assigning it a value. The variable must be mutable,&#13;
a <code>var</code>, because, by definition, you will assign a value to it, later.&#13;
Great—problem solved, right?</p>&#13;
&#13;
<p>We, the authors, thought exactly that when we started using Kotlin. Now,&#13;
we lean toward using <code>lateinit</code> only when absolutely necessary,&#13;
and using nullable values instead. Why?</p>&#13;
&#13;
<p>When you use <code>lateinit</code>, you’re telling the compiler, “I don’t have a value to give you right now. But I’ll give you a value later, I promise.” If the Kotlin compiler could talk, it would answer, “Fine! You say you know what you’re doing. If something goes wrong, it’s on you.” By using the <code>lateinit</code> modifier, you disable Kotlin’s&#13;
null safety for your variable. If you forget to initialize the&#13;
variable or try to call some method on it before it’s initialized,&#13;
you’ll get an <code>UninitializedPropertyAccessException</code>, which is&#13;
essentially the same as getting a <code>NullPointerException</code> in Java.</p>&#13;
&#13;
<p><em>Every single time</em> we’ve used <code>lateinit</code> in our code, we’ve been burned&#13;
eventually. Our code might work in all of the cases we’d foreseen.&#13;
We’ve been certain that we didn’t miss anything… and we were wrong.</p>&#13;
&#13;
<p>When you declare a variable <code>lateinit</code> you’re making&#13;
assumptions that the compiler cannot prove.  When you or other&#13;
developers refactor the code afterward, your careful design might get&#13;
broken. Tests might catch the error.  Or not.<sup><a data-type="noteref" href="ch01.html#idm46669759047504" id="idm46669759047504-marker">4</a></sup> In our&#13;
experience, using <code>lateinit</code> always resulted in runtime crashes. How did&#13;
we fix that? By using a nullable type.</p>&#13;
&#13;
<p>When you use a nullable type instead of <code>lateinit</code>, the Kotlin&#13;
compiler will force you to check for nullability in your code, exactly&#13;
in the places that it might be null.  Adding a few question marks is&#13;
definitely worth the trade-off for more robust code.<a data-startref="ix_ch01-asciidoc18" data-type="indexterm" id="idm46669759043760"/><a data-startref="ix_ch01-asciidoc17" data-type="indexterm" id="idm46669759043056"/><a data-startref="ix_ch01-asciidoc16" data-type="indexterm" id="idm46669759016736"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lazy Properties" data-type="sect2"><div class="sect2" id="idm46669759123568">&#13;
<h2>Lazy Properties</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="lazy properties" data-type="indexterm" id="idm46669759014816"/><a data-primary="Kotlin (basics)" data-secondary="lazy properties" data-type="indexterm" id="idm46669759013840"/><a data-primary="lazy properties" data-type="indexterm" id="idm46669759012896"/>It’s a common pattern in software engineering to put off creating and&#13;
initializing an object until it is actually needed. This pattern is&#13;
known as<a data-primary="lazy initialization" data-type="indexterm" id="idm46669759011936"/> <em>lazy initialization</em>, and is especially common on Android,&#13;
since allocating a lot of objects during app startup can lead to&#13;
a longer startup time. <a data-type="xref" href="#java_mouse_id">Example 1-1</a> is a typical case of lazy&#13;
initialization in Java.</p>&#13;
<div data-type="example" id="java_mouse_id">&#13;
<h5><span class="label">Example 1-1. </span>Java lazy initialization</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nc">Lightweight</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">Heavyweight</code> <code class="n">heavy</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">Heavyweight</code> <code class="nf">getHeavy</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">heavy</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">heavy</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Heavyweight</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
        <code class="k">return</code> <code class="n">heavy</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre></div>&#13;
&#13;
<p>The  field <code>heavy</code> is initialized with a new instance of the&#13;
class <code>Heavyweight</code> (which is, presumably, expensive to create) only when&#13;
its value is first requested with a call, for example, to <code>lightweight.getHeavy()</code>.&#13;
Subsequent calls to <code>getHeavy()</code> will return the cached instance.</p>&#13;
&#13;
<p>In Kotlin, lazy initialization is a part of the language. By using&#13;
the directive <code>by lazy</code> and providing an initialization block, the&#13;
rest of the lazy instantiation is implicit, as shown in&#13;
<a data-type="xref" href="#kotlin_mouse_id">Example 1-2</a>.</p>&#13;
<div data-type="example" id="kotlin_mouse_id">&#13;
<h5><span class="label">Example 1-2. </span>Kotlin lazy initialization</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Lightweight</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">heavy</code> <code class="k">by</code> <code class="n">lazy</code> <code class="p">{</code> <code class="c1">// Initialization block</code>&#13;
        <code class="n">Heavyweight</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>We will explain this syntax in greater detail in the next section.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Notice that the code in <a data-type="xref" href="#java_mouse_id">Example 1-1</a> isn’t thread-safe.&#13;
Multiple threads calling <code>Lightweight</code>’s <code>getHeavy()</code> method simultaneously&#13;
might end up with different instances of <code>Heavyweight</code>.</p>&#13;
&#13;
<p>By default, the code in <a data-type="xref" href="#kotlin_mouse_id">Example 1-2</a> is thread-safe.  Calls to&#13;
&#13;
<span class="keep-together"><code>Lightweight::getHeavy()</code></span> will be synchronized so that only one thread at&#13;
a time is in the initialization block.</p>&#13;
&#13;
<p>Fine-grained control of concurrent access to a lazy initialization block&#13;
can be managed using <code>LazyThreadSafetyMode</code>.</p>&#13;
</div>&#13;
&#13;
<p>A Kotlin lazy value will not be initialized until a call is made at&#13;
runtime. The first time the property <code>heavy</code> is referenced, the initialization block will be run.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Delegates" data-type="sect2"><div class="sect2" id="idm46669758926608">&#13;
<h2>Delegates</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="delegates" data-type="indexterm" id="idm46669758925168"/><a data-primary="delegates" data-type="indexterm" id="idm46669758924192"/><a data-primary="Kotlin (basics)" data-secondary="delegates" data-type="indexterm" id="idm46669758923520"/>Lazy properties are an example of a more general Kotlin feature, called&#13;
<em>delegation</em>. A declaration uses the keyword <code>by</code> to define a&#13;
delegate that is responsible for getting and setting the value of the&#13;
property. In Java, one could accomplish something similar with, for example,&#13;
a setter that passed its argument on as a parameter to a call to a&#13;
method on some other object, the delegate.</p>&#13;
&#13;
<p>Because Kotlin’s lazy initialization feature is an excellent example of the&#13;
power of idiomatic Kotlin, let’s take a minute to unpack it.</p>&#13;
&#13;
<p>The first part of the declaration in <a data-type="xref" href="#kotlin_mouse_id">Example 1-2</a> reads <code>val&#13;
heavy</code>. This is, we know, the declaration of a read-only variable,&#13;
<code>heavy</code>.  Next comes the keyword <code>by</code>, which introduces a delegate.&#13;
The keyword <code>by</code> says that the next identifier in the declaration is&#13;
an expression that will evaluate to the object that will be&#13;
responsible for the value of <code>heavy</code>.</p>&#13;
&#13;
<p>The next thing in the declaration is the identifier <code>lazy</code>.  Kotlin is&#13;
expecting, an expression.  It turns out that <code>lazy</code> is just a&#13;
function!  It is a function that takes a single argument, a lambda,&#13;
and returns an object.  The object that it returns is a <code>Lazy&lt;T&gt;</code>&#13;
where <code>T</code> is the type returned by the lambda.</p>&#13;
&#13;
<p>The implementation of a <code>Lazy&lt;T&gt;</code> is quite simple:&#13;
the first time it is called it runs the lambda and caches its value.&#13;
On subsequent calls it returns the cached value.</p>&#13;
&#13;
<p>Lazy delegation is just one of many varieties of <em>property&#13;
delegation</em>. Using keyword <code>by</code>, you can also define <em>observable properties</em> (see the <a href="https://oreil.ly/6lTab">Kotlin documentation for delegated properties</a>). Lazy&#13;
delegation is, though, the most common property delegation used in&#13;
Android code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Companion Objects" data-type="sect2"><div class="sect2" id="idm46669758882496">&#13;
<h2>Companion Objects</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="companion objects" data-type="indexterm" id="idm46669758881184"/><a data-primary="companion objects" data-type="indexterm" id="idm46669758880208"/><a data-primary="Kotlin (basics)" data-secondary="companion objects" data-type="indexterm" id="idm46669758879536"/>Perhaps you are wondering what Kotlin did with static variables. Have&#13;
no fear; Kotlin uses <em>companion objects</em>. A companion object is a<a data-primary="singleton objects" data-type="indexterm" id="idm46669758877920"/> <em>singleton object</em> always related to a Kotlin class.  Although it isn’t required, most often the&#13;
definition of a companion object is placed at the bottom of the&#13;
related class, as shown here:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">TimeExtensions</code> <code class="p">{</code>&#13;
    <code class="c1">//  other code</code>&#13;
&#13;
    <code class="n">companion</code> <code class="k">object</code> <code class="err">{</code>&#13;
        <code class="n">const</code> <code class="k">val</code> <code class="py">TAG</code> <code class="p">=</code> <code class="s">"TIME_EXTENSIONS"</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Companion objects can have names, extend classes, and inherit interfaces.&#13;
In this example, <code>TimeExtension</code>’s companion object is named <code>StdTimeExtension</code>&#13;
and inherits the interface <code>Formatter</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">Formatter</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">yearMonthDate</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">TimeExtensions</code> <code class="p">{</code>&#13;
    <code class="c1">//  other code</code>&#13;
&#13;
    <code class="n">companion</code> <code class="k">object</code> <code class="nc">StdTimeExtension</code> <code class="p">:</code> <code class="n">Formatter</code> <code class="p">{</code>&#13;
        <code class="n">const</code> <code class="k">val</code> <code class="py">TAG</code> <code class="p">=</code> <code class="s">"TIME_EXTENSIONS"</code>&#13;
        <code class="k">override</code> <code class="k">val</code> <code class="py">yearMonthDate</code> <code class="p">=</code> <code class="s">"yyyy-MM-d"</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When referencing a member of a companion object from outside a class&#13;
that contains it, you must qualify the reference with the name of the&#13;
containing class:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">timeExtensionsTag</code> <code class="p">=</code> <code class="n">TimeExtensions</code><code class="p">.</code><code class="n">StdTimeExtension</code><code class="p">.</code><code class="n">TAG</code></pre>&#13;
&#13;
<p>A companion object is initialized when Kotlin loads the related&#13;
class.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Classes" data-type="sect2"><div class="sect2" id="idm46669758767072">&#13;
<h2>Data Classes</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="data classes" data-type="indexterm" id="idm46669758765728"/><a data-primary="data classes" data-type="indexterm" id="idm46669758764528"/><a data-primary="Kotlin (basics)" data-secondary="data classes" data-type="indexterm" id="idm46669758763856"/>There is a category of classes so common that, in Java, they&#13;
have a name: they are called<a data-primary="POJOs (plain old Java objects)" data-type="indexterm" id="idm46669758762672"/> <em>POJOs</em>, or plain old Java objects. The idea&#13;
is that they are simple representations of structured data.  They are a&#13;
collection of data members (fields), most of which have getters and&#13;
setters, and just a few other methods: <code>equals</code>, <code>hashCode</code>, and&#13;
<code>toString</code>. These kinds of classes are so common that Kotlin has made&#13;
them part of the language. They are called <em>data classes</em>.</p>&#13;
&#13;
<p>We can improve our definition of the <code>Point</code> class by making it a data class:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">Point</code><code class="p">(</code><code class="k">var</code> <code class="py">x</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="k">var</code> <code class="py">y</code><code class="p">:</code> <code class="n">Int</code><code class="p">?</code> <code class="p">=</code> <code class="m">3</code><code class="p">)</code></pre>&#13;
&#13;
<p>What’s the difference between this class, declared using the <code>data</code>&#13;
modifier, and the original, declared without it? Let’s try a simple experiment,&#13;
first using the original definition of <code>Point</code> (without the <code>data</code> modifier):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Point</code><code class="p">(</code><code class="k">var</code> <code class="py">x</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="k">var</code> <code class="py">y</code><code class="p">:</code> <code class="n">Int</code><code class="p">?</code> <code class="p">=</code> <code class="m">3</code><code class="p">)</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">p1</code> <code class="p">=</code> <code class="n">Point</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">p2</code> <code class="p">=</code> <code class="n">Point</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Points are equals: ${p1 == p2}"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output from this small program will be <code>"Points are equals: false"</code>.&#13;
The reason for this perhaps unexpected result is that Kotlin&#13;
compiles <code>p1 == p2</code> as <code>p1.equals(p2)</code>. Since our first definition of&#13;
the <code>Point</code> class did not override the <code>equals</code> method, this turns into&#13;
a call to the <code>equals</code> method in <code>Point</code>’s base class, <code>Any</code>.&#13;
<code>Any</code>’s implementation of <code>equals</code> returns <code>true</code> only when an object is compared to itself.</p>&#13;
&#13;
<p>If we try the same thing with the new definition of <code>Point</code> as a data&#13;
class, the program will print <code>"Points are equals: true"</code>.  The new&#13;
definition behaves as intended because a data class automatically&#13;
includes overrides for the methods<a data-primary="equals" data-type="indexterm" id="idm46669758616576"/> <code>equals</code>,<a data-primary="hashCode" data-type="indexterm" id="idm46669758615360"/> &#13;
<span class="keep-together"><code>hashCode</code>,</span> and<a data-primary="toString" data-type="indexterm" id="idm46669758613520"/> <code>toString</code>.&#13;
Each of these automatically generated methods depends on all of a class’s&#13;
properties.</p>&#13;
&#13;
<p>For example, the <code>data class</code> version of <code>Point</code> contains an <code>equals</code>&#13;
method that is equivalent to this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">override</code> <code class="k">fun</code> <code class="nf">equals</code><code class="p">(</code><code class="n">o</code><code class="p">:</code> <code class="n">Any</code><code class="p">?):</code> <code class="n">Boolean</code> <code class="p">{</code>&#13;
    <code class="c1">// If it's not a Point, return false</code>&#13;
    <code class="c1">// Note that null is not a Point</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="n">o</code> <code class="p">!</code><code class="k">is</code> <code class="n">Point</code><code class="p">)</code> <code class="k">return</code> <code class="k">false</code>&#13;
&#13;
    <code class="c1">// If it's a Point, x and y should be the same</code>&#13;
    <code class="k">return</code> <code class="n">x</code> <code class="p">==</code> <code class="n">o</code><code class="p">.</code><code class="n">x</code> <code class="p">&amp;&amp;</code> <code class="n">y</code> <code class="p">==</code> <code class="n">o</code><code class="p">.</code><code class="n">y</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In addition to providing default implementations of <code>equals</code> and&#13;
<code>hashCode</code>, a <code>data class</code> also provides the <code>copy</code> method.&#13;
Here’s an example of its use:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">Point</code><code class="p">(</code><code class="k">var</code> <code class="py">x</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="k">var</code> <code class="py">y</code><code class="p">:</code> <code class="n">Int</code><code class="p">?</code> <code class="p">=</code> <code class="m">3</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">p</code> <code class="p">=</code> <code class="n">Point</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>          <code class="c1">// x = 1, y = 3</code>&#13;
<code class="k">val</code> <code class="py">copy</code> <code class="p">=</code> <code class="n">p</code><code class="p">.</code><code class="n">copy</code><code class="p">(</code><code class="n">y</code> <code class="p">=</code> <code class="m">2</code><code class="p">)</code>  <code class="c1">// x = 1, y = 2</code></pre>&#13;
&#13;
<p>Kotlin’s data classes are a perfect convenience for a frequently used idiom.</p>&#13;
&#13;
<p>In the next section, we examine another special kind of class: <em>enum classes</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enum Classes" data-type="sect2"><div class="sect2" id="idm46669758766480">&#13;
<h2>Enum Classes</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="enum classes" data-type="indexterm" id="ix_ch01-asciidoc19"/><a data-primary="enum classes" data-type="indexterm" id="ix_ch01-asciidoc20"/><a data-primary="Kotlin (basics)" data-secondary="enum classes" data-type="indexterm" id="ix_ch01-asciidoc21"/>Remember when developers were being advised that enums were too&#13;
expensive for Android? Fortunately, no one is even suggesting that&#13;
anymore: use enum classes to your heart’s desire!</p>&#13;
&#13;
<p>Kotlin’s enum classes are very similar to Java’s enums.  They create a&#13;
class that cannot be subclassed and that has a fixed set of instances.&#13;
Also as in Java, enums cannot subclass other types but can implement&#13;
interfaces and can have constructors, properties, and methods.  Here&#13;
are a couple of simple examples:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">enum</code> <code class="k">class</code> <code class="nc">GymActivity</code> <code class="p">{</code>&#13;
    <code class="n">BARRE</code><code class="p">,</code> <code class="n">PILATES</code><code class="p">,</code> <code class="n">YOGA</code><code class="p">,</code> <code class="n">FLOOR</code><code class="p">,</code> <code class="n">SPIN</code><code class="p">,</code> <code class="n">WEIGHTS</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">enum</code> <code class="k">class</code> <code class="nc">LENGTH</code><code class="p">(</code><code class="k">val</code> <code class="py">value</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">TEN</code><code class="p">(</code><code class="m">10</code><code class="p">),</code> <code class="n">TWENTY</code><code class="p">(</code><code class="m">20</code><code class="p">),</code> <code class="n">THIRTY</code><code class="p">(</code><code class="m">30</code><code class="p">),</code> <code class="n">SIXTY</code><code class="p">(</code><code class="m">60</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">Enums work very well with Kotlin’s <code>when</code> expression.  For example:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">requiresEquipment</code><code class="p">(</code><code class="n">activity</code><code class="p">:</code> <code class="n">GymActivity</code><code class="p">)</code> <code class="p">=</code> <code class="k">when</code> <code class="p">(</code><code class="n">activity</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">GymActivity</code><code class="p">.</code><code class="n">BARRE</code> <code class="p">-&gt;</code> <code class="k">true</code>&#13;
    <code class="n">GymActivity</code><code class="p">.</code><code class="n">PILATES</code> <code class="p">-&gt;</code> <code class="k">true</code>&#13;
    <code class="n">GymActivity</code><code class="p">.</code><code class="n">YOGA</code> <code class="p">-&gt;</code> <code class="k">false</code>&#13;
    <code class="n">GymActivity</code><code class="p">.</code><code class="n">FLOOR</code> <code class="p">-&gt;</code> <code class="k">false</code>&#13;
    <code class="n">GymActivity</code><code class="p">.</code><code class="n">SPIN</code> <code class="p">-&gt;</code> <code class="k">true</code>&#13;
    <code class="n">GymActivity</code><code class="p">.</code><code class="n">WEIGHTS</code> <code class="p">-&gt;</code> <code class="k">true</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When the <code>when</code> expression is used to assign a variable, or as an expression body of a function as in the previous example, it must be <em>exhaustive</em>.  An exhaustive <code>when</code> expression is&#13;
one that covers every possible value of its argument (in this case,&#13;
&#13;
<span class="keep-together"><code>activity</code>).</span> A standard way of assuring that a <code>when</code> expression is&#13;
exhaustive is to include an <code>else</code> clause.  The <code>else</code> clause matches&#13;
any value of the argument that is not explicitly mentioned in its case list.</p>&#13;
&#13;
<p>In the preceding example, to be exhaustive, the <code>when</code> expression must&#13;
accommodate every possible value of the function parameter <code>activity</code>.&#13;
The parameter is of type <code>GymActivity</code> and, therefore, must be one of&#13;
that enum’s instances. Because an enum has a known set of instances,&#13;
Kotlin can determine that all of the possible values are covered as&#13;
explicitly listed cases and permit the omission of the <code>else</code> clause.</p>&#13;
&#13;
<p>Omitting the <code>else</code> clause like this has a really nice advantage: if&#13;
we add a new value to the <code>GymActivity</code> enum, our code suddenly won’t&#13;
compile.  The Kotlin compiler detects that the <code>when</code> expression is no&#13;
longer exhaustive.  Almost certainly, when you add a new case to an&#13;
enum, you want to be aware of all the places in your code that have to&#13;
adapt to the new value. An exhaustive <code>when</code> expression that does not&#13;
include an <code>else</code> case does exactly that.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>What happens if a <code>when</code> statement need not return a value (for&#13;
instance, a function in which the <code>when</code> statement’s value is not the&#13;
value of the function)?</p>&#13;
&#13;
<p>If the <code>when</code> statement is not used as an expression, the Kotlin compiler&#13;
doesn’t force it to be exhaustive. You will, however, get a lint warning&#13;
(a yellow flag, in Android Studio) that tells you that it is recommended&#13;
that a <code>when</code> expression on enum be exhaustive.</p>&#13;
</div>&#13;
&#13;
<p>There’s a trick that will force Kotlin to interpret any <code>when</code>&#13;
statement as an expression (and, therefore, to be exhaustive). The extension function defined in&#13;
<a data-type="xref" href="#exhaustive_property_id">Example 1-3</a> forces the <code>when</code> statement to return a&#13;
value, as we see in <a data-type="xref" href="#when_statement_exhaustive_id">Example 1-4</a>.  Because it must have a value,&#13;
Kotlin will insist that it be exhaustive.</p>&#13;
<div data-type="example" id="exhaustive_property_id">&#13;
<h5><span class="label">Example 1-3. </span>Forcing <code>when</code> to be exhaustive</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="err">&lt;</code><code class="py">T</code><code class="p">&gt;</code> <code class="n">T</code><code class="p">.</code><code class="n">exhaustive</code><code class="p">:</code> <code class="n">T</code>&#13;
    <code class="k">get</code><code class="p">()</code> <code class="p">=</code> <code class="k">this</code></pre></div>&#13;
<div data-type="example" id="when_statement_exhaustive_id">&#13;
<h5><span class="label">Example 1-4. </span>Checking for an exhaustive <code>when</code></h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">when</code> <code class="p">(</code><code class="n">activity</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">GymActivity</code><code class="p">.</code><code class="n">BARRE</code> <code class="p">-&gt;</code> <code class="k">true</code>&#13;
    <code class="n">GymActivity</code><code class="p">.</code><code class="n">PILATES</code> <code class="p">-&gt;</code> <code class="k">true</code>&#13;
<code class="p">}.</code><code class="n">exhaustive</code> <code class="c1">// error!  when expression is not exhaustive.</code></pre></div>&#13;
&#13;
<p>Enums are a way of creating a class that has a specified, static set of instances.  Kotlin provides an interesting&#13;
generalization of this capability, the <em>sealed class</em>.<a data-startref="ix_ch01-asciidoc21" data-type="indexterm" id="idm46669758240208"/><a data-startref="ix_ch01-asciidoc20" data-type="indexterm" id="idm46669758239712"/><a data-startref="ix_ch01-asciidoc19" data-type="indexterm" id="idm46669758239072"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sealed Classes" data-type="sect2"><div class="sect2" id="idm46669758472496">&#13;
<h2>Sealed Classes</h2>&#13;
&#13;
<p><a data-primary="classes" data-secondary="sealed classes" data-type="indexterm" id="idm46669758236832"/><a data-primary="Kotlin (basics)" data-secondary="sealed classes" data-type="indexterm" id="idm46669758235632"/><a data-primary="sealed classes" data-type="indexterm" id="idm46669758234688"/>Consider the following code.  It defines a single type, <code>Result</code>,&#13;
with exactly two subtypes. <code>Success</code> contains a value; <code>Failure</code> contains an <code>Exception</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">Result</code>&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">Success</code><code class="p">(</code><code class="k">val</code> <code class="py">data</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;)</code> <code class="p">:</code> <code class="n">Result</code>&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">Failure</code><code class="p">(</code><code class="k">val</code> <code class="py">error</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">?)</code> <code class="p">:</code> <code class="n">Result</code></pre>&#13;
&#13;
<p>Notice that there is no way to do this with an <code>enum</code>.  All of the values of an enum must be&#13;
instances of the same type.  Here, though, there are two distinct types that are subtypes of <code>Result</code>.</p>&#13;
&#13;
<p>We can create a new instance of either of the two types:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">getResult</code><code class="p">():</code> <code class="n">Result</code> <code class="p">=</code> <code class="k">try</code> <code class="p">{</code>&#13;
    <code class="n">Success</code><code class="p">(</code><code class="n">getDataOrExplode</code><code class="p">())</code>&#13;
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">Failure</code><code class="p">(</code><code class="n">e</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And, again, a <code>when</code> expression is a handy way to manage a <code>Result</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">processResult</code><code class="p">(</code><code class="n">result</code><code class="p">:</code> <code class="n">Result</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="k">when</code> <code class="p">(</code><code class="n">result</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">is</code> <code class="n">Success</code> <code class="p">-&gt;</code> <code class="n">result</code><code class="p">.</code><code class="n">data</code>&#13;
    <code class="k">is</code> <code class="n">Failure</code> <code class="p">-&gt;</code> <code class="n">listOf</code><code class="p">()</code>&#13;
    <code class="k">else</code> <code class="p">-&gt;</code> <code class="k">throw</code> <code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"unknown result type"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’ve had to add an <code>else</code> branch again, because the Kotlin compiler&#13;
doesn’t know that <code>Success</code> and <code>Failure</code> are the only <code>Result</code>&#13;
subclasses. Somewhere in your program, you might create another&#13;
subclass of result <code>Result</code> and add another possible case.  Hence the&#13;
<code>else</code> branch is required by the compiler.</p>&#13;
&#13;
<p>Sealed classes do for types what enums do for instances.  They allow&#13;
you to announce to the compiler that there is a fixed, known set of&#13;
subtypes (<code>Success</code> and <code>Failure</code> in this case) for a certain base type&#13;
(<code>Result</code>, here). To make this declaration, use the keyword <code>sealed</code>&#13;
in the declaration, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">sealed</code> <code class="k">class</code> <code class="nc">Result</code>&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">Success</code><code class="p">(</code><code class="k">val</code> <code class="py">data</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;)</code> <code class="p">:</code> <code class="n">Result</code><code class="p">()</code>&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">Failure</code><code class="p">(</code><code class="k">val</code> <code class="py">error</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">?)</code> <code class="p">:</code> <code class="n">Result</code><code class="p">()</code></pre>&#13;
&#13;
<p>Because <code>Result</code> is <em>sealed</em>, the Kotlin compiler knows that <code>Success</code> and <code>Failure</code> are the only&#13;
possible subclasses.  Once again, we can remove the <code>else</code> from a <code>when</code> &#13;
<span class="keep-together">expression:</span><a data-startref="ix_ch01-asciidoc12" data-type="indexterm" id="idm46669758000864"/><a data-startref="ix_ch01-asciidoc11" data-type="indexterm" id="idm46669758000160"/></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">processResult</code><code class="p">(</code><code class="n">result</code><code class="p">:</code> <code class="n">Result</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="k">when</code> <code class="p">(</code><code class="n">result</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">is</code> <code class="n">Success</code> <code class="p">-&gt;</code> <code class="n">result</code><code class="p">.</code><code class="n">data</code>&#13;
    <code class="k">is</code> <code class="n">Failure</code> <code class="p">-&gt;</code> <code class="n">listOf</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Visibility Modifiers" data-type="sect1"><div class="sect1" id="idm46669759796128">&#13;
<h1>Visibility Modifiers</h1>&#13;
&#13;
<p><a data-primary="Kotlin (basics)" data-secondary="visibility modifiers" data-type="indexterm" id="ix_ch01-asciidoc22"/><a data-primary="visibility modifiers" data-type="indexterm" id="ix_ch01-asciidoc23"/>In both Java and Kotlin, visibility modifiers determine the scope of a variable, class, or method. In Java, there are&#13;
three visibility modifiers:</p>&#13;
<dl>&#13;
<dt><code>private</code></dt>&#13;
<dd>&#13;
<p><a data-primary="private visibility modifiers" data-secondary="in Java" data-type="indexterm" id="idm46669757905520"/>References are only visible to the class that they are defined within, and from the outer class if defined in an inner class.</p>&#13;
</dd>&#13;
<dt><code>protected</code></dt>&#13;
<dd>&#13;
<p><a data-primary="protected visibility modifiers" data-secondary="in Java" data-type="indexterm" id="idm46669757903184"/>References are visible to the class that they are defined within, or any subclasses of that class. In&#13;
addition, they are also visible from classes in the same package.</p>&#13;
</dd>&#13;
<dt><code>public</code></dt>&#13;
<dd>&#13;
<p><a data-primary="public visibility modifiers" data-secondary="in Java" data-type="indexterm" id="idm46669757900656"/>References are visible anywhere.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Kotlin also has these three visibility modifiers. However, there are some subtle differences. While you can only use them with&#13;
class-member declarations in Java, you can use them with class-member <em>and</em> top-level declarations in Kotlin:</p>&#13;
<dl>&#13;
<dt><code>private</code></dt>&#13;
<dd>&#13;
<p><a data-primary="private visibility modifiers" data-secondary="in Kotlin" data-type="indexterm" id="idm46669757896672"/>The declaration’s visibility depends on where it is defined:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A class member declared as <code>private</code> is visible only in the <em>class</em> in which it is defined.</p>&#13;
</li>&#13;
<li>&#13;
<p>A top-level <code>private</code> declaration is visible only in the <em>file</em> in which it is defined.</p>&#13;
</li>&#13;
</ul>&#13;
</dd>&#13;
<dt><code>protected</code></dt>&#13;
<dd>&#13;
<p><a data-primary="protected visibility modifiers" data-secondary="in Kotlin" data-type="indexterm" id="idm46669757890032"/>Protected declarations are visible only in the class in which they are defined, and the subclasses thereof.</p>&#13;
</dd>&#13;
<dt><code>public</code></dt>&#13;
<dd>&#13;
<p><a data-primary="public visibility modifiers" data-secondary="in Kotlin" data-type="indexterm" id="idm46669757887568"/>References are visible anywhere, just like in Java.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In addition to these three different visibilities, Java has a fourth, <em>package-private</em>, making references only&#13;
visible from classes that are within the same package.&#13;
A declaration is package-private when it has no visibility modifiers. In other words, this is the default&#13;
visibility in Java.</p>&#13;
&#13;
<p>Kotlin has no such concept.<sup><a data-type="noteref" href="ch01.html#idm46669757884816" id="idm46669757884816-marker">5</a></sup> This might be surprising,&#13;
because Java developers often rely on package-private visibility to hide implementation details from other packages&#13;
within the same module. In Kotlin, packages aren’t used for visibility scoping at all—they’re just namespaces.&#13;
Therefore, the default visibility is different in Kotlin—it’s <em>public</em>.</p>&#13;
&#13;
<p>The fact that Kotlin doesn’t have package-private visibility has quite a significant impact on how we design and&#13;
structure our code. To guarantee a complete encapsulation of declarations (classes, methods, top-level fields, etc.),&#13;
you can have all these declarations as <code>private</code> within the same file.</p>&#13;
&#13;
<p>Sometimes it’s acceptable to have several closely related classes split into different files. However, those classes&#13;
won’t be able to access siblings from the same package unless they are <code>public</code> or <code>internal</code>. What’s <code>internal</code>?&#13;
It’s the fourth visibility modifier supported by Kotlin, which makes the reference visible anywhere within the containing&#13;
<em>module</em>.<sup><a data-type="noteref" href="ch01.html#idm46669757879232" id="idm46669757879232-marker">6</a></sup> From a module standpoint, <code>internal</code> is&#13;
identical to <code>public</code>. However, <code>internal</code> is interesting when this module is intended as a library—for example, it’s a&#13;
dependency for other modules. Indeed, <code>internal</code> declarations aren’t visible from modules that import your library.&#13;
Therefore, <code>internal</code> is useful to hide declarations from the outside world.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <code>internal</code> modifier isn’t meant for visibility scoping inside the module, which is what package-private does in Java.&#13;
This isn’t possible in Kotlin. It is possible to restrict visibility a little more heavy-handedly using the&#13;
<code>private</code> modifier.<a data-startref="ix_ch01-asciidoc23" data-type="indexterm" id="idm46669757874336"/><a data-startref="ix_ch01-asciidoc22" data-type="indexterm" id="idm46669757873600"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669757942368">&#13;
<h1>Summary</h1>&#13;
&#13;
<p><a data-type="xref" href="#table1_1">Table 1-1</a> highlights some of the key differences between Java and Kotlin.</p>&#13;
<table id="table1_1">&#13;
<caption><span class="label">Table 1-1. </span>Differences between Java and Kotlin features</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Feature</th>&#13;
<th>Java</th>&#13;
<th>Kotlin</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>File contents</p></td>&#13;
<td><p>A single file contains a single top-level class.</p></td>&#13;
<td><p>A single file can hold any number of classes, variables, or functions.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Variables</p></td>&#13;
<td><p>Use <code>final</code> to make a variable immutable; variables are mutable by default. Defined at the class level.</p></td>&#13;
<td><p>Use <code>val</code> to make a variable read-only, or <code>var</code> for read/write values. Defined at the class level, or may exist&#13;
independently outside of a class.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Type inferencing</p></td>&#13;
<td><p>Data types are required. <code>Date date = new Date();</code></p></td>&#13;
<td><p>Data types can be inferred, like <code>val date = Date()</code>, or explicitly defined, like <code>val date: Date = Date()</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Boxing and unboxing types</p></td>&#13;
<td><p>In Java, data primitives like <code>int</code> are recommended for more expensive operations, since they are less&#13;
expensive than boxed types like <code>Integer</code>. However, boxed types have lots of useful methods in Java’s wrapper classes.</p></td>&#13;
<td><p>Kotlin doesn’t have primitive types out of the box. Everything is an object. When compiled for the JVM, the&#13;
generated bytecode performs automatic unboxing, when possible.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Access modifiers</p></td>&#13;
<td><p>Public and protected classes, functions, and variables can be extended and overridden.</p></td>&#13;
<td><p>As a functional language, Kotlin encourages immutability whenever possible. Classes and functions are final by default.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Access modifiers in multi-module projects</p></td>&#13;
<td><p>Default access is package-private.</p></td>&#13;
<td><p>There is no package-private, and default access is public. New <code>internal</code> access provides visibility in the same module.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Functions</p></td>&#13;
<td><p>All functions are methods.</p></td>&#13;
<td><p>Kotlin has function types. Function data types look like, for example, <code>(param: String) -&gt; Boolean</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Nullability</p></td>&#13;
<td><p>Any non-primitive object can be null.</p></td>&#13;
<td><p>Only explicitly nullable references, declared with the <code>?</code> suffix on the type, can be set to null: <code>val date: Date? = new Date()</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Statics versus constants</p></td>&#13;
<td><p>The <code>static</code> keyword attaches a variable to a class definition, rather than an instance.</p></td>&#13;
<td><p>There is no <code>static</code> keyword. Use a private <code>const</code> or a <code>companion</code> object.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p class="pagebreak-before">Congratulations, you just finished a one-chapter covering Kotlin’s essentials.&#13;
Before we start talking about applying Kotlin to Android,&#13;
we need to discuss Kotlin’s built-in library: collections and data transformations.&#13;
Understanding the underlying functions of data transformations in&#13;
Kotlin will give you the necessary foundation needed to understand&#13;
Kotlin as a functional language.&#13;
<a data-startref="ix_ch01-asciidoc0" data-type="indexterm" id="idm46669757838240"/><a data-primary="CoroutineContext" data-see="context" data-type="indexterm" id="idm46669757837632"/><a data-primary="coroutines" data-secondary="structured concurrency with" data-see="structured concurrency with coroutines" data-type="indexterm" id="idm46669757836640"/><a data-primary="CSP" data-see="communicating sequential processes" data-type="indexterm" id="idm46669757835440"/><a data-primary="structured concurrency" data-secondary="coroutines and" data-see="structured concurrency with coroutines" data-type="indexterm" id="idm46669757834480"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669770421056"><sup><a href="ch01.html#idm46669770421056-marker">1</a></sup> Dmitry Jemerov and Svetlana Isakova. <em>Kotlin in Action</em>. Manning, 2017.</p><p data-type="footnote" id="idm46669761440208"><sup><a href="ch01.html#idm46669761440208-marker">2</a></sup> Kotlin officially calls this type inferencing, which uses a partial phase of the compiler (the frontend component) to do type checking of the written code while you write in the IDE. It’s a plug-in for IntelliJ! Fun fact: the entirety of IntelliJ and Kotlin is made of compiler plug-ins.</p><p data-type="footnote" id="idm46669760026992"><sup><a href="ch01.html#idm46669760026992-marker">3</a></sup> DSL stands for <em>domain-specific language</em>. An example of a DSL built in Kotlin is the Kotlin Gradle DSL.</p><p data-type="footnote" id="idm46669759047504"><sup><a href="ch01.html#idm46669759047504-marker">4</a></sup> You can check whether the <code>latenit</code> <code>button</code> property is initialized using <code>this::button.isInitialized</code>. Relying on developers to add this check in all the right places doesn’t solve the underlying issue.</p><p data-type="footnote" id="idm46669757884816"><sup><a href="ch01.html#idm46669757884816-marker">5</a></sup> At least, as of Kotlin 1.5.20. As we write these lines, Jetbrains is considering adding a package-private visibility modifier to the language.</p><p data-type="footnote" id="idm46669757879232"><sup><a href="ch01.html#idm46669757879232-marker">6</a></sup> A module is a set of Kotlin files compiled together.</p></div></div></section></body></html>