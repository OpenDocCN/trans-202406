- en: Chapter 9\. Intrusion Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 入侵检测
- en: In this chapter we will see how container intrusion detection operates with
    the new low-level eBPF interface, what forensics looks like for a container, and
    how to catch attackers who have evaded all other controls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到容器入侵检测如何利用新的低级eBPF接口运行，容器的取证是什么样子，以及如何捕捉已逃过所有其他控制的攻击者。
- en: Defense in depth means limiting the trust you place in each security control
    you deploy. No solution is infallible, but you can use intrusion detection systems
    (IDS) to detect unexpected activity in much the same way that motion sensors detect
    movement. Your adversary has already accessed your system and may even have viewed
    confidential information already, so an IDS reviews your system in real time for
    unexpected behavior and observes or blocks it. Alerts can trigger further defensive
    actions from an IDS, like dumping compromised memory or recording network activity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 深度防御意味着限制您在部署的每个安全控制上的信任。没有解决方案是绝对可靠的，但您可以使用入侵检测系统（IDS）以类似运动传感器检测运动的方式检测到意外活动。您的对手已经访问过您的系统，甚至可能已经查看了机密信息，因此IDS实时审查您的系统以检测意外行为，并观察或阻止它。IDS的警报可以触发进一步的防御措施，如转储受损内存或记录网络活动。
- en: Intrusion detection can inspect file, network, and kernel reads and writes to
    verify or block them with an allowlist or a denylist (as `seccomp-bpf` configuration
    does). If Captain Hashjack’s Hard Hat Hacking Collective has remote access to
    your servers, an IDS might be triggered by their use of malware with known behavioral
    signatures, scan of networks or files for further targets, or any other program
    access that deviates from the expected “stable” baseline the IDS has learned about
    the process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 入侵检测可以检查文件、网络和内核的读写操作，并使用允许列表或拒绝列表（如`seccomp-bpf`配置）验证或阻止它们。如果Hashjack船长的硬帽黑客集体能够远程访问您的服务器，IDS可能会被他们使用已知行为特征的恶意软件、扫描网络或文件以寻找更多目标，或者任何其他偏离IDS已学习到的进程预期“稳定”基线的程序访问触发。
- en: Some attackers’ campaigns are only discovered after the adversary has been on
    the system for weeks or months and finally inadvertently tripped the IDS detection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有些攻击者的攻击活动仅在对手在系统中数周或数月后最终无意中触发IDS检测时才被发现。
- en: Defaults
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认值
- en: 'Stable behavior is what we’d expect our container process to do normally, when
    running as intended, and not compromised. We can apply the same thing to any data
    we collect: access and audit logs, metrics and telemetry, and system calls and
    network activity.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定行为是我们期望容器进程在正常运行且未受到妥协时执行的操作。我们可以将同样的原则应用于我们收集的任何数据：访问和审计日志、度量和遥测，以及系统调用和网络活动。
- en: Intrusion detection to identify deviance from this behavior requires installation,
    maintenance, and monitoring. By default most systems do not have any intrusion
    detection unless configured to do so.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别与此行为偏离的入侵检测需要安装、维护和监控。默认情况下，大多数系统没有任何入侵检测，除非配置为执行此操作。
- en: Threat Model
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威胁模型
- en: 'Intrusion detection can detect threats to BCTL’s systems. If an attacker gets
    remote code execution (RCE) into a container they may be able to control the process,
    changing its behavior. Potentially nonstable behaviors that could indicate compromise
    might include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 入侵检测可以检测到对BCTL系统的威胁。如果攻击者成功远程执行代码（RCE）进入容器，他们可能能够控制进程，改变其行为。可能不稳定的行为可能表明存在妥协，例如：
- en: New or disallowed system calls (perhaps fork or exec system calls to create
    a shell like Bash or sh)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的或不允许的系统调用（例如创建类似Bash或sh的Shell的fork或exec系统调用）
- en: Any unexpected network, filesystem, file metadata, or device access
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何意外的网络、文件系统、文件元数据或设备访问
- en: Application usage and order
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的使用和顺序
- en: Unexplained processes or files
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未解释的进程或文件
- en: Changes to users or identity settings
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户或身份设置的更改
- en: System and kernel configuration events
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统和内核配置事件
- en: Any of a process’s properties and behaviors when interacting with the wider
    system may also be subject to scrutiny.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与更广泛系统交互时，进程的任何特性和行为也可能会受到审查。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Attack tools like [ccat](https://oreil.ly/pKyt0) and [dockerscan](https://oreil.ly/bchJw)
    can poison images in registries and install backdoors in container images that
    an attacker may use to gain entry to your pods at runtime. This sort of unexpected
    behavior should be noticed and alerted on by your IDS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击工具如[ccat](https://oreil.ly/pKyt0)和[dockerscan](https://oreil.ly/bchJw)可以在注册表中污染镜像并在容器镜像中安装后门，攻击者可能利用这些镜像在运行时进入您的Pod。此类意外行为应该被IDS注意和报警。
- en: Of course, you don’t want to be alerted to legitimate activity, so you authorize
    expected behavior. It’s either preconfigured with rules and signatures or learned
    while the process is under observation in a nonproduction environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不希望对合法活动发出警报，因此您授权预期行为。它可以预先配置规则和签名，也可以在非生产环境中观察过程中学习。
- en: These threats should be identified and configured to alert your IDS system.
    We’ll see how in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些威胁应该被识别并配置到您的IDS系统中以进行警报。本章将介绍如何实现这一点。
- en: Traditional IDS
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统IDS
- en: Before we get into cloud native IDS, let’s have a look at a few of the other
    intrustion detection applications that have been prominent over the years.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解云原生IDS之前，让我们回顾一下多年来突出的其他入侵检测应用程序。
- en: Traditional intrusion detection systems are classed as Network- or Host-based
    IDS (NIDS or HIDS), and some tools offer both. Historically these used signals
    from the host kernel or network adapter, and were not aware of the Linux namespaces
    that containers use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 传统入侵检测系统分为网络型（NIDS）或主机型（HIDS），一些工具提供两者兼具的功能。在历史上，它们使用主机内核或网络适配器的信号，并不了解容器使用的Linux命名空间。
- en: Linux has [`auditd`](https://oreil.ly/N5BSs) built in for system call events,
    but this doesn’t correlate activity nicely across nodes in a distributed system.
    It’s also considered heavyweight (it generates a great volume of logs) and can’t
    distinguish by namespace due to “complex and incomplete” ID tracking of namespaced
    processes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Linux自带[`auditd`](https://oreil.ly/N5BSs)来监控系统调用事件，但在分布式系统中无法很好地对跨节点的活动进行关联。它也被认为是资源密集型（生成大量日志），并且由于“复杂且不完整”的命名空间进程ID跟踪，无法区分命名空间。
- en: Tools like [Suricata](https://suricata.io), [Snort](https://www.snort.org),
    and [Zeek](https://zeek.org) inspect network traffic against a rule and scripting
    engine, and may be run on the same host or (as they tend to be resource intensive)
    on dedicated hardware attached to the network under observation. Encrypted or
    steganographic payloads may escape such NIDS undetected. To further guard against
    these slippery assailants, the old-but-effective [Tripwire](https://oreil.ly/3ewaE)
    tool watches files on the host for unauthorized changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 像[Suricata](https://suricata.io)、[Snort](https://www.snort.org)和[Zeek](https://zeek.org)这样的工具会使用规则和脚本引擎检查网络流量，并且可能在同一主机上运行，或者（因为它们往往资源密集）连接到观察网络的专用硬件上。加密或隐写术载荷可能会逃避此类NIDS的检测。为了进一步防范这些难缠的攻击者，古老但有效的[Tripwire](https://oreil.ly/3ewaE)工具会监控主机上文件的未经授权的更改。
- en: An IDS detects threats by either using preknown information about them or detecting
    deviance from an expected baseline. Information known in advance can be considered
    a “signature,” and signatures can relate to network traffic and scans, malware
    binaries, or memory. Any suspicious patterns in packets, “fingerprints” of application
    code or memory usage, and process activities are verified against an expected
    ruleset derived from the application’s “known good” behavior.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: IDS通过预先知道的信息或检测与预期基线的偏差来检测威胁。事先知道的信息可以被视为“签名”，签名可以涉及网络流量和扫描、恶意软件二进制文件或内存。对数据包中的可疑模式、“指纹”应用代码或内存使用情况以及进程活动进行验证，以与应用程序“已知良好”行为的预期规则集相匹配。
- en: Once a signature pattern is identified (for example, the SUNBURST traffic back
    to command and control servers), the IDS creates a relevant alert.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦识别出签名模式（例如，SUNBURST流量返回到命令和控制服务器），IDS就会创建相关的警报。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: FireEye released IDS configurations [to detect SUNBURST](https://oreil.ly/kgkNH).
    These configurations support various IDS tools including Snort, Yara, IOC, and
    ClamAV.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: FireEye发布了IDS配置以侦测[SUNBURST](https://oreil.ly/kgkNH)。这些配置支持包括Snort、Yara、IOC和ClamAV在内的各种IDS工具。
- en: Signatures are distributed and update files, so you must regularly update them
    to ensure new and recent threats are detected. A signature-based approach is usually
    less resource intensive and less prone to false positives, but it may not detect
    zero-days and novel attacks. Attackers have access to defensive tooling and can
    determine how to circumvent controls in their own test systems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 签名是分布和更新文件，因此您必须定期更新它们以确保检测到新的和最近的威胁。基于签名的方法通常资源消耗较少且误报率较低，但可能无法检测零日攻击和新型攻击。攻击者可以访问防御工具，并确定如何绕过其测试系统中的控制。
- en: Without predefined signatures to trip the IDS, anomalous behavior may be detected.
    This relies on a “known good state” of the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有预定义的签名来触发IDS，可能会检测到异常行为。这依赖于应用程序的“已知良好状态”。
- en: The derivation of a normal application behavior state defines “secure,” which
    puts the onus on defenders to ensure application correctness, rather than on the
    tool to enforce a generic ruleset.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正常应用行为状态的推导定义了“安全”，这使得防御者有责任确保应用程序的正确性，而不是依赖工具来执行通用规则集。
- en: This observational approach is more powerful than signatures as it can act autonomously
    against new threats. The price for this more general protection is greater resource
    utilization, which may impact the performance of the system being protected.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种观察性方法比签名更强大，因为它可以自主应对新的威胁。这种更通用的保护的代价是更大的资源利用，这可能会影响受保护系统的性能。
- en: Signature and anomaly detection can be fooled, circumvented, and potentially
    disabled by a skilled adversary, so never rely entirely upon one control.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 签名和异常检测可能会被熟练的对手欺骗、规避，并且有可能被禁用，因此永远不要完全依赖于一个控制。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[VirusTotal](https://oreil.ly/Zpw8C) is a library of malicious files. When
    a defender discovers an attack, they upload the files retrieved by forensics (for
    example, malware, implants, and C2 binaries or encrypted files), allowing researchers
    to correlate techniques across targets and helping defenders to understand their
    adversary, the attacks being used, and (with any luck) how they can best defend
    themselves. Antivirus vendors ensure their products have signatures for every
    malicious file on VirusTotal, and new submissions are scanned by existing virus
    detection engines for matches.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[VirusTotal](https://oreil.ly/Zpw8C)是一个恶意文件库。当防御者发现攻击时，他们会上传取证中检索到的文件（例如，恶意软件、植入物、C2二进制文件或加密文件），让研究人员能够在目标之间对技术进行关联，并帮助防御者了解他们的对手、正在使用的攻击以及（幸运的话）如何最好地保护自己。杀毒软件供应商确保他们的产品对VirusTotal上的每个恶意文件都有签名，并且新提交的文件会被现有的病毒检测引擎进行匹配扫描。'
- en: Attackers use these same tools to ensure their payloads will bypass antivirus
    and malware signature scanners. Red Teams have been retrospectively discovered
    leaking tooling and signatures onto VirusTotal once their attacking campaigns
    have been decloaked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者使用这些相同的工具确保他们的载荷能够绕过杀毒软件和恶意软件签名扫描器。红队在他们的攻击活动被揭示后有时会被发现将工具和签名泄露到VirusTotal上。
- en: eBPF-Based IDS
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于eBPF的IDS
- en: Running IDS for every packet or system call can incur overhead and slow down
    the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个数据包或系统调用运行IDS可能会带来开销并减慢系统速度。
- en: 'We introduced eBPF in [“eBPF”](ch05.xhtml#workload-networking-bpf) as a mechanism
    to safely and efficiently extend the Linux kernel. eBPF avoids some of these issues
    by being very fast indeed: it was designed for fast packet handling, and now kernel
    developers use it to observe runtime behavior for everything in the kernel. Because
    it runs inside the kernel as trusted code it is less restricted than other IDS
    and tracing technologies.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“eBPF”](ch05.xhtml#workload-networking-bpf)中介绍了eBPF作为一种安全有效地扩展Linux内核的机制。eBPF通过非常快的速度避免了一些问题：它被设计用于快速处理数据包，并且现在内核开发者使用它来观察内核中的所有运行时行为。因为它作为受信任的代码在内核中运行，所以它比其他IDS和追踪技术受限制较少。
- en: However, running in the kernel poses its own set of possible risks, and the
    eBPF subsystem and JIT compiler have had a number of breakouts, but these are
    considered less dangerous than slow, incomplete kernel developer tracing solutions
    or more fallible IDS.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在内核中运行会带来一系列可能的风险，eBPF子系统和JIT编译器已经发生过一些突破，但这些被认为比慢速、不完整的内核开发者追踪解决方案或更容易出错的IDS更不危险。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Jeff Dileo’s](https://oreil.ly/BPYwJ) [“Evil eBPF In-Depth Practical Abuses
    of an In-Kernel Bytecode Runtime”](https://oreil.ly/sllD3) is a good primer on
    BPF and its attacks, and [“Kernel Pwning with eBPF: A Love Story”](https://oreil.ly/KzOg0)
    by [Valentina Palmiotti](https://oreil.ly/NjjEf) is a walkthrough of the various
    components of eBPF.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jeff Dileo的](https://oreil.ly/BPYwJ)[“Evil eBPF In-Depth Practical Abuses
    of an In-Kernel Bytecode Runtime”](https://oreil.ly/sllD3)是关于BPF及其攻击的良好入门，[“Kernel
    Pwning with eBPF: A Love Story”](https://oreil.ly/KzOg0)由[Valentina Palmiotti](https://oreil.ly/NjjEf)是对eBPF各个组件的详细介绍。'
- en: Since eBPF’s powers have been extended and integrated more deeply into the kernel,
    a number of CNIs and security products now use eBPF for detection and networking
    including [Cilium](https://cilium.io), [Pixie](https://pixielabs.ai), and [Falco](https://falco.org)
    (which we detail in the following section).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于eBPF的功能已经得到扩展并更深入地集成到内核中，现在许多CNIs和安全产品都使用eBPF进行检测和网络，包括[Cilium](https://cilium.io)、[Pixie](https://pixielabs.ai)和[Falco](https://falco.org)（我们将在下一节详细介绍）。
- en: Warning
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As with all container software, bugs can lead to container breakout, as in [CVE-2021-31440](https://oreil.ly/82xbU),
    where an incorrect bounds calculation in the Linux kernel eBPF verifier allowed
    an exploitable verifier bypass.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有容器软件一样，漏洞可能导致容器的突破，例如 [CVE-2021-31440](https://oreil.ly/82xbU)，其中 Linux 内核
    eBPF 验证器中的错误边界计算允许可利用的验证器绕过。
- en: Let’s move on to some applications of eBPF in Kubernetes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论 eBPF 在 Kubernetes 中的一些应用。
- en: Kubernetes and Container Intrusion Detection
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 和容器入侵检测
- en: There are signature and anomaly detection systems available for Kubernetes workloads
    at runtime. Kubernetes and container IDS systems support namespaced workload,
    host, and network IDS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时为 Kubernetes 工作负载提供签名和异常检测系统。Kubernetes 和容器 IDS 系统支持命名空间工作负载、主机和网络 IDS。
- en: By splitting processes into namespaces, you can use more well-defined metadata
    to help an IDS make decisions. This more granular data can give greater insight
    into an attack, which is vital when the decision to kill a running container may
    affect your production workloads.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将进程分割为命名空间，您可以使用更多定义明确的元数据来帮助 IDS 做出决策。这种更精细化的数据可以在攻击时提供更大的洞察力，这在决定是否终止运行中的容器时至关重要，因为这可能会影响您的生产工作负载。
- en: 'This gives container IDS an advantage: the behavior it is monitoring is just
    a single container, not a whole machine. The definition of allowed behavior is
    much smaller in a single-purpose container, so the IDS has a far greater fidelity
    of policy to block unwanted behavior. With this in mind, let’s now have a look
    at a few container-specific IDS.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得容器 IDS 具有优势：它监视的行为仅限于单个容器，而不是整个机器。在单用途容器中，允许行为的定义要小得多，因此 IDS 在阻止不需要的行为时具有更高的策略准确性。考虑到这一点，现在让我们来看看几个特定于容器的
    IDS。
- en: Falco
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Falco
- en: Falco is an open source, cloud native IDS that can run in a container or on
    a host. Traditionally, Falco required a dedicated kernel module to run (with its
    code loaded into the kernel) so that it could interact with system calls. Since
    2019, Falco has also supported eBPF. The eBPF interface allows general-purpose
    code to be loaded by Falco, from userspace, into the kernel’s memory. This means
    less custom code, fewer kernel modules, and the ability to use the kernel monitoring
    and enforcement techniques through a well-known interface.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Falco 是一个开源的、云原生的 IDS，可以在容器中或主机上运行。传统上，Falco 需要一个专用的内核模块来运行（其代码加载到内核中），以便与系统调用交互。自
    2019 年以来，Falco 也支持 eBPF。eBPF 接口允许从用户空间加载通用代码到内核内存中的 Falco，这意味着更少的定制代码、更少的内核模块，并且通过一个知名接口使用内核监视和强制技术。
- en: When run in a container, it requires privileged access to the host or use of
    the `CAP_BPF` capability with host PID namespace access.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当在容器中运行时，它需要对主机具有特权访问或使用具有主机 PID 命名空间访问权限的 `CAP_BPF` 能力。
- en: 'In eBPF mode, when a process interacts with a file using a system call such
    as `open()`, the eBPF program is triggered, which can run arbitrary code in a
    kernel VM to make its decision. Depending on the inputs, the action will be accepted
    or blocked:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 eBPF 模式下，当进程使用诸如 `open()` 这样的系统调用与文件交互时，将触发 eBPF 程序，该程序可以在内核虚拟机中运行任意代码以做出决策。根据输入，将接受或阻止动作：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Falco is based on Sysdig, a system introspection tool. Sysdig Cloud offers workload
    and Kubernetes performance monitoring, and [Sysdig Secure](https://oreil.ly/S6q1e)
    is the commercial product built around Falco.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Falco 基于 Sysdig，这是一个系统内省工具。Sysdig Cloud 提供工作负载和 Kubernetes 性能监控，而 [Sysdig Secure](https://oreil.ly/S6q1e)
    是围绕 Falco 构建的商业产品。
- en: 'Falco comes with a collection of [community contributed and maintained rules](https://oreil.ly/T43NW),
    including dedicated rules to manage Kubernetes clusters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Falco 配备了一系列由社区贡献和维护的规则，包括专门用于管理 Kubernetes 集群的规则：[community contributed and
    maintained rules](https://oreil.ly/T43NW)。
- en: 'Unexpected inbound TCP connections:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外的入站 TCP 连接：
- en: Detects inbound TCP traffic to Kubernetes components from a port outside of
    an expected set
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测从预期集合之外的端口向 Kubernetes 组件的入站 TCP 流量
- en: 'Allowed inbound ports:'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的入站端口：
- en: '`6443` (`kube-apiserver` container)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6443`（`kube-apiserver` 容器）'
- en: '`10252` (`kube-controller` container)'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10252`（`kube-controller` 容器）'
- en: '`8443` (`kube-dashboard` container)'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`8443`（`kube-dashboard` 容器）'
- en: '`10053`, `10055`, `8081` (`kube-dns` container)'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10053`、`10055`、`8081`（`kube-dns` 容器）'
- en: '`10251` (`kube-scheduler` container)'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10251`（`kube-scheduler` 容器）'
- en: 'Unexpected spawned processes:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外生成的进程：
- en: Detects a process started in a Kubernetes cluster outside of an expected set
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测在 Kubernetes 集群中启动的进程超出预期集合
- en: 'Allowed processes:'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的进程：
- en: '`kube-apiserver` (for `kube-apiserver` container)'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-apiserver`（对 `kube-apiserver` 容器）'
- en: '`kube-controller-manager` (for `kube-controller` container)'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-controller-manager`（用于 `kube-controller` 容器）'
- en: '`/dashboard` (`kube-dashboard` container)'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dashboard` (`kube-dashboard` 容器)'
- en: '`/kube-dns` (`kube-dns` container)'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/kube-dns` (`kube-dns` 容器)'
- en: '`kube-scheduler` (`kube-scheduler` container)'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-scheduler` (`kube-scheduler` 容器)'
- en: 'Unexpected file access readonly:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外文件访问只读：
- en: Detects an attempt to access a file in readonly mode, other than those in an
    expected list of directories
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测尝试以只读模式访问文件，而不是预期目录列表中的文件
- en: 'Allowed file prefixes for readonly:'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读文件前缀允许：
- en: '`/public`'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/public`'
- en: These rules form a useful base set to extend with custom rules for your own
    cluster’s specific security needs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则形成了一个有用的基础集，可以根据您自己集群特定的安全需求扩展自定义规则。
- en: Warning
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'While it’s almost always better to consume community contributed rules, no
    software is free of bugs. For example, Darkbit found a [Falco rule bypass](https://oreil.ly/wgZy7)
    that exploited a loose regex rule to deploy a custom privileged agent container—`docker.io/my-org-name-that-ends-with-sysdig/agent`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然消费社区贡献的规则几乎总是更好的选择，但没有软件是没有 bug 的。例如，Darkbit 发现了一个[Falco 规则绕过](https://oreil.ly/wgZy7)，利用宽松的正则表达式规则部署了一个自定义特权代理容器—`docker.io/my-org-name-that-ends-with-sysdig/agent`：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Machine Learning Approaches to IDS
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDS 的机器学习方法
- en: Machine learning (ML) replays the same signals used in other IDS systems through
    a model, which then predicts whether the container is compromised.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习（ML）通过模型重播其他 IDS 系统中使用的相同信号，然后预测容器是否受到 compromise。
- en: 'There are many examples of machine learning IDS available:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的机器学习 IDS 示例：
- en: '[Aqua Security](https://oreil.ly/gfl98) uses ML-based behavioral profiling
    to analyze and react to behaviors in containers, the network, and hosts.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Aqua Security](https://oreil.ly/gfl98)使用基于 ML 的行为分析来分析和响应容器、网络和主机中的行为。'
- en: '[Prisma Cloud](https://oreil.ly/AoLCX)’s layer 3 inter-container firewall learns
    valid traffic flows between app components with ML.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Prisma Cloud](https://oreil.ly/AoLCX)的第三层容器间防火墙通过 ML 学习应用组件之间的有效流量。'
- en: '[Lacework](https://oreil.ly/6pooI) uses unsupervised machine learning for cross-cloud
    observability and response to runtime threats.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Lacework](https://oreil.ly/6pooI)使用无监督机器学习进行跨云可观察性和对运行时威胁的响应。'
- en: '[Accuknox](https://accuknox.com) uses unsupervised machine learning to detect
    instability and discern potential attacks, and “Identity as a Perimeter” for zero-trust
    network, application, and data protection.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Accuknox](https://accuknox.com)使用无监督机器学习来检测不稳定性并识别潜在攻击，并为零信任网络、应用程序和数据保护提供“身份作为边界”。'
- en: Container Forensics
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器取证
- en: Forensics is the art of reconstructing data from incomplete or historical sources.
    In Linux this involves capturing process, memory, and filesystem contents to interrogate
    them offline, find the source or impact of a breach, and inspect adversarial techniques.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 取证是从不完整或历史来源中重建数据的艺术。在 Linux 中，这涉及捕获进程、内存和文件系统内容以离线审问它们，找到入侵的源头或影响，并检查对抗性技术。
- en: More advanced systems gather more information, like network connection information
    they were already logging. In the event of a serious break, the entire cluster
    or account may be cut off from the network so that the attacker cannot continue
    their assault, and the entire system can be imaged and explored.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 更先进的系统收集更多信息，比如它们已经记录的网络连接信息。在发生严重破坏的情况下，整个集群或帐户可能会被切断与网络的连接，以防止攻击者继续攻击，并且整个系统可以被镜像化和探索。
- en: Tools like [kube-forensics](https://oreil.ly/s4xup) “create checkpoint snapshots
    of the state of running pods for later off-line analysis,” so malicious workloads
    can be dumped and killed, and the system returned to use. It runs a `forensics-controller-manager`
    with a `PodCheckpoint` custom resource definition (CRD) to effectively `docker
    inspect`, `docker diff`, and finally `docker export`. Notably, this does not capture
    the process’s memory, which may have implants or attacker tools that were not
    saved to disk or were deleted once the process started.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像[kube-forensics](https://oreil.ly/s4xup)这样的工具“创建运行中 pod 状态的检查点快照，以便进行离线分析”，因此恶意工作负载可以被转储和终止，系统可以恢复使用。它运行一个带有
    `PodCheckpoint` 自定义资源定义（CRD）的 `forensics-controller-manager`，以有效地执行 `docker inspect`，`docker
    diff`，最终 `docker export`。值得注意的是，这不会捕获进程的内存，可能存在未保存到磁盘或在进程启动后被删除的植入物或攻击者工具。
- en: 'To capture a process’ memory, you can use standard tools like GDB. Using these
    tools from inside a container is difficult as symbols may be required. From outside
    a container, dumping memory and searching it for interesting data is trivial,
    as this [simple Bash script](https://oreil.ly/6eDzc) mashing together [Trufflehog](https://oreil.ly/U2ibi)
    and GDB process dumping demonstrates:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获一个进程的内存，你可以使用像GDB这样的标准工具。在容器内使用这些工具是困难的，因为可能需要符号。从容器外部，转储内存并搜索其中的有趣数据是微不足道的，就像这个[简单的Bash脚本](https://oreil.ly/6eDzc)结合了[Trufflehog](https://oreil.ly/U2ibi)和GDB进程转储所演示的那样：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Put this script into *procdump.sh* and run it against a local shell:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个脚本放入*procdump.sh*中，并针对本地shell运行它：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will see any high entropy strings or suspected secrets that were loaded
    into the shell:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到加载到shell中的任何高熵字符串或可疑的秘密信息：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Warning
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: An attacker as root in a process namespace can dump the memory of any other
    process in the namespace. The root user in the host process namespace can dump
    any process memory on the node (including child namespaces).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进程命名空间中的root的攻击者可以转储命名空间中任何其他进程的内存。主机进程命名空间中的root用户可以在节点上转储任何进程的内存（包括子命名空间）。
- en: Avoid this type of attack in a cloud native application by retrieving secrets
    at time of use from a filesystem or key management system. If you can discard
    the Secrets from memory when not in use, you’ll be more resilient to this attack.
    You can also encrypt Secrets in memory, although the decryption keys suffer the
    same risk of being dumped and so should also be discarded when not in use.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在使用时从文件系统或密钥管理系统中检索秘密信息来避免云原生应用程序中的这种攻击类型。如果可以在不使用时丢弃内存中的秘密信息，那么您将更加抵御这种攻击。您还可以在内存中加密秘密信息，尽管解密密钥也面临被转储的风险，因此在不使用时也应该丢弃。
- en: Honeypots
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蜜罐
- en: '![captain](Images/haku_0000.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![船长](Images/haku_0000.png)'
- en: 'Although IDS can detect and prevent almost all abuses of your systems, we cannot
    emphasize enough that there is no such thing as a silver bullet. It should be
    assumed that rogue sea dogs like Captain Hashjack will still be able to bypass
    any careful security configuration. A complex system offers asymmetrical advantage
    for an attacker: a defender only has to make one mistake to get compromised.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然入侵检测系统（IDS）可以检测和防止几乎所有对系统的滥用，但我们无法强调没有什么是绝对有效的。应该假设像Hashjack船长这样的流氓海盗仍然能够绕过任何谨慎的安全配置。对于攻击者来说，复杂的系统提供了不对称的优势：防御者只需犯一个错误就会受到威胁。
- en: Attackers may still be able to escape from a container or traverse onto the
    host. Or, if they’re in a container governed by IDS and manipulates the expected
    behavior of the application (for example, by invoking the same application with
    different flags), they may be able to read sensitive data without triggering IDS
    alarms.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者仍然可能从容器中逃逸或遍历到主机上。或者，如果他们在受IDS监管的容器中操纵应用程序的预期行为（例如，通过以不同的标志调用相同的应用程序），他们可能能够读取敏感数据而不触发IDS警报。
- en: So the last line of defense is the humble honeypot, a simple server or file
    that legitimate applications never use. It innocuously nestles in a tempting or
    secured location and triggers an alert when an attacker accesses it. Honeypots
    might be triggered by a network scan, or HTTP requests that the system would never
    usually make.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最后的防线是简单的蜜罐，一个正常的应用程序从不使用的简单服务器或文件。它安静地躺在一个诱人或安全的位置，并在攻击者访问时触发警报。蜜罐可能会被网络扫描触发，或者系统通常不会发出的HTTP请求触发。
- en: '[Figure 9-1](#ids-honeypot-architecture) shows BCTL’s honeypot entrapping Dread
    Pirate Hashjack. A honeypot such as this one is as simple as using tools like
    [ElastAlert](https://oreil.ly/L1bSu) to monitor, audit, and access logs for pods
    that should never be accessed.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](#ids-honeypot-architecture)展示了BCTL的蜜罐陷阱困住了可怕的海盗Hashjack。这样的蜜罐就像使用类似[ElastAlert](https://oreil.ly/L1bSu)这样的工具来监视、审计和访问永远不应该被访问的pod的日志一样简单。'
- en: '![Catching an attacker in a Honeypot](Images/haku_0901.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![在蜜罐中捕捉攻击者](Images/haku_0901.png)'
- en: Figure 9-1\. Catching an attacker in a honeypot
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-1\. 在蜜罐中捕捉攻击者
- en: You are looking to catch an attacker operating inside the pod network. They
    may scan local IP ranges for open TCP and UDP ports. Remember that each Kubernetes
    workload must be identical, so we can’t run “custom” pods to deploy a single honeypot.
    Instead, deploy a dedicated DaemonSet so each node is defended by a honeypot pod.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你要捕捉在pod网络内操作的攻击者。他们可能扫描本地IP范围以查找开放的TCP和UDP端口。请记住，每个Kubernetes工作负载必须是相同的，所以我们不能运行“自定义”pod来部署单个蜜罐。相反，部署一个专用的DaemonSet，这样每个节点都会被一个蜜罐pod保护。
- en: If the attacker or internal actor has cluster DNS access, can read a pod’s environment
    variables, or has read access to the Kubernetes API, they can see the names of
    the Kubernetes services in the DNS and pod names. They may be looking for a specifically
    named target. You can name your honeypot service with an appealingly similar name
    (such as “myapp-data” or “myapp-support”) to entice an attacker. Deploying honeypots
    as a DaemonSet will ensure one is lying in wait on any node Captain Hashjack might
    plunder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者或内部操作者具有集群DNS访问权限，可以读取Pod的环境变量，或者具有对Kubernetes API的读取权限，则可以看到DNS中的Kubernetes服务名称和Pod名称。他们可能正在寻找一个特定命名的目标。您可以将您的蜜罐服务命名为一个具有吸引力的类似名称（例如“myapp-data”或“myapp-support”）以诱使攻击者。部署蜜罐作为一个DaemonSet将确保在任何节点上都有一个等待着，Captain
    Hashjack可能会劫掠。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Canary tokens](https://oreil.ly/1E7Eo) are honeypots for protocols like AWS
    and Slack keys, URLs, DNS records, QR codes, email addresses, documents, and binaries.
    They are “tiny tripwires” that you can drop in production systems and developer
    devices to detect compromise.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[Canary tokens](https://oreil.ly/1E7Eo)是用于AWS和Slack等协议的蜜罐，用于探测钥匙、URL、DNS记录、QR码、电子邮件地址、文档和二进制文件。它们是可以放置在生产系统和开发者设备中的“微型绊线”，以便检测被攻击。'
- en: Auditing
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计
- en: As discussed in [Chapter 8](ch08.xhtml#ch-policy), Kubernetes generates audit
    logs for every API request it receives, and IDS tools can ingest and monitor that
    stream of information for unexpected requests. This could include requests from
    outside known IP ranges or expected working hours, honeytoken credentials, or
    attempts to use unauthorized APIs (e.g., a default service account token attempting
    to get all Secrets in its namespace or a privileged namespace).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第8章](ch08.xhtml#ch-policy)讨论的，Kubernetes为其接收到的每个API请求生成审计日志，并且IDS工具可以摄取和监视该信息流以检测意外请求。这可能包括来自已知IP范围之外或预期工作时间之外的请求，蜜罐令牌凭证，或试图使用未授权API（例如，默认服务账户令牌试图获取其命名空间中的所有Secret或特权命名空间）。
- en: Audit log level and depth is configurable, but as CVE-2020-8563 for Kubernetes
    v1.19.2 (and CVE-2020-8564, CVE-2020-8565, CVE-2020-8566) shows, defaults were
    not historically tight enough. Some sensitive request payload information was
    persisted to logs that could have been read from outside the cluster and then
    used to attack it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志级别和深度是可配置的，但正如CVE-2020-8563针对Kubernetes v1.19.2（以及CVE-2020-8564、CVE-2020-8565、CVE-2020-8566）显示的那样，默认情况并不历史上紧密。一些敏感请求负载信息被持久化到日志中，可以从集群外部读取，然后用于攻击。
- en: 'Unintended data leakage into logs is being mitigated in [KEP 1753](https://oreil.ly/5iuMK):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 意外数据泄漏到日志中正在通过[KEP 1753](https://oreil.ly/5iuMK)得到缓解：
- en: This KEP proposes the introduction of a logging filter which could be applied
    to all Kubernetes system components logs to prevent various types of sensitive
    information from leaking via logs…Ensure that sensitive data cannot be trivially
    stored in logs. Prevent dangerous logging actions with improved code review policies.
    Redact sensitive information with logging filters. Together, these actions can
    help to prevent sensitive data from being exposed in the logs.
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本KEP提议引入一个日志过滤器，可以应用于所有Kubernetes系统组件的日志，以防止各种类型的敏感信息通过日志泄露……确保敏感数据不能轻易存储在日志中。通过改进的代码审查政策阻止危险的日志记录操作。使用日志过滤器对敏感信息进行遮蔽。这些措施共同有助于防止敏感数据在日志中暴露。
- en: It can be used with the `kubelet` flag `--experimental-logging-sanitization`
    in v1.20+.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在`kubelet`标志`--experimental-logging-sanitization`中在v1.20+版本中使用。
- en: Leaking Secrets into logs and audit streams is common in all technology organizations,
    and is another reason to avoid environment variables for sensitive information.
    Developers need introspection and useful output from running programs, but sanitizing
    debug during development is a rare practice. These debug strings invariably make
    their way into production, and so searching logs for Secrets is perhaps the only
    practical way to detect this.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将Secrets泄漏到日志和审计流中在所有技术组织中都很常见，这也是避免使用环境变量存储敏感信息的另一个原因。开发人员需要运行程序时的内省和有用输出，但在开发过程中进行调试时清理日志的做法却很少见。这些调试字符串最终不可避免地进入生产环境，因此搜索日志以检测Secrets也许是唯一实用的方法。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The bugs that gave momentum to the log sanitization focus include:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 引起日志清理关注的漏洞包括：
- en: CVE-2020-8563
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2020-8563
- en: Secret leaks in logs for vSphere Provider kube-controller-manager
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: vSphere Provider kube-controller-manager中的日志中泄漏的Secrets
- en: CVE-2020-8564
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2020-8564
- en: Docker config Secrets leaked when file is malformed and `logLevel` >= 4
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件格式不正确且`logLevel` >= 4时，Docker配置Secrets泄漏
- en: CVE-2020-8565
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2020-8565
- en: Incomplete fix for CVE-2019-11250 allows for token leak in logs when `logLevel`
    >= 9
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2019-11250 的不完全修复允许在 `logLevel` >= 9 时日志中泄露令牌
- en: CVE-2020-8566
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: CVE-2020-8566
- en: Ceph RBD adminSecrets exposed in logs when `logLevel` >= 4
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `logLevel` >= 4 时，Ceph RBD adminSecrets 在日志中暴露
- en: You can read the disclosure on the [Kubernetes Forums](https://oreil.ly/yBvQu).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Kubernetes 论坛](https://oreil.ly/yBvQu)上阅读披露内容。
- en: Detection Evasion
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测逃逸
- en: Bypassing Kubernetes audit logs was demonstrated by [Brad Geesaman](https://oreil.ly/KaOWm)
    and [Ian Coldwater](https://oreil.ly/KMK0u) at [RSA 2020](https://oreil.ly/LfzS0).
    As [Figure 9-2](#ids-oversized-logs) shows, the `etcd` datastore in the Kubernetes
    control plane is highly efficient and resillient, however it does not support
    large data sizes. That means request payloads in the audit logs that exceed 256
    KB will not get stored, enabling stealthy behavior with oversized log entries.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[Brad Geesaman](https://oreil.ly/KaOWm) 和 [Ian Coldwater](https://oreil.ly/KMK0u)
    在 [RSA 2020](https://oreil.ly/LfzS0) 展示了绕过 Kubernetes 审计日志的方法。正如[图 9-2](#ids-oversized-logs)所示，Kubernetes
    控制平面中的 `etcd` 数据存储非常高效和可靠，但不支持大数据大小。这意味着超过 256 KB 的请求负载在审计日志中将不会被存储，从而使超大日志条目可以实现隐蔽行为。'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An attacker with access to the API server can blackhole, redirect, or tamper
    with any audit logs that are stored locally. As a post-mortem exercise it’s useful
    to explore an attacker’s path, so shipping the API server’s audit logs directly
    to a remote webhook backend safeguards against this. Configure the API server
    to use the flag `--audit-webhook-config-file` to ship logs remotely, or use a
    managed service that configures this for you.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问 API 服务器的攻击者可以黑洞、重定向或篡改存储在本地的任何审计日志。作为事后检查的一部分，探索攻击者的路径非常有用，因此直接将 API 服务器的审计日志发送到远程
    Webhook 后端可以防范此类攻击。配置 API 服务器使用标志 `--audit-webhook-config-file` 将日志远程发送，或者使用一个为您配置好此项的托管服务。
- en: '![haku 0902](Images/haku_0902.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![haku 0902](Images/haku_0902.png)'
- en: Figure 9-2\. Oversize `etcd` logs ([RSA 2020](https://oreil.ly/LfzS0))
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. 超大 `etcd` 日志 ([RSA 2020](https://oreil.ly/LfzS0))
- en: Security Operations Centers
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全运营中心
- en: Larger organizations may have a Security Operations Center (SOC) that manages
    security information and events (SIEM).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的组织可能拥有负责管理安全信息和事件（SIEM）的安全运营中心（SOC）。
- en: Configuring enterprise applications for alerting on your audit and pod logs
    requires fine-tuning to avoid false positives and needless alerts. You can use
    a local cluster to build out automated tests and capture the audit log events,
    then use that data to configure your SIEM. Finally, rerun your automated tests
    to ensure alerts are raised correctly in production systems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 配置企业应用程序以便在您的审计和 pod 日志上设置警报需要进行精细调整，以避免误报和不必要的警报。您可以使用本地集群构建自动化测试，并捕获审计日志事件，然后使用该数据配置您的
    SIEM。最后，重新运行您的自动化测试以确保在生产系统中正确引发警报。
- en: You should run Red Team security tests against production systems to validate
    the Blue Team controls work as expected. This provides a real-world test for the
    attack trees and threat models that the system is configured upon.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对生产系统运行红队安全测试，以验证蓝队控制是否按预期工作。这为系统配置的攻击树和威胁模型提供了真实的测试。
- en: Conclusion
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Intrusion detection is the last line of defense for a cloud native system. eBPF
    approaches offer greater speed on modern kernels, and the performance overhead
    is slight. Sensitive or web-facing workloads should always be guarded by IDS as
    they have the greatest risk of compromise.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 入侵检测是云原生系统的最后防线。eBPF 方法在现代内核上速度更快，性能开销很小。敏感或面向 Web 的工作负载应始终由 IDS 保护，因为它们有最大的被妥协风险。
- en: 'With this we’re switching gears and will turn our attention to the weakest
    link and its natural habitat: organizations.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向最薄弱环节及其自然栖息地：组织。
