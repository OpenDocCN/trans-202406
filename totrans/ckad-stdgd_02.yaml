- en: Chapter 2\. Kubernetes in a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s helpful to get a quick rundown of what Kubernetes is and how it works if
    you are new to the space. Many tutorials and 101 courses are available on the
    web, but I would like to summarize the most important background information and
    concepts in this chapter. In the course of this book, we’ll reference cluster
    node components, so feel free to come back to this information at any time.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Kubernetes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand what Kubernetes is, first let’s define microservices and containers.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architectures call for developing and executing pieces of the application
    stack as individual services, and those services have to communicate with one
    another. If you decide to operate those services in containers, you will need
    to manage a lot of them while at the same time thinking about cross-cutting concerns
    like scalability, security, persistence, and load balancing.
  prefs: []
  type: TYPE_NORMAL
- en: Tools like [buildkit](https://github.com/moby/buildkit) and [Podman](https://podman.io/)
    package software artifacts into a container image. Container runtime engines like
    [Docker Engine](https://docs.docker.com/engine/) and [containerd](https://containerd.io/)
    use the image to run a container. This works great on developer machines for testing
    purposes or for ad-hoc executions, e.g., as part of a Continuous Integration pipeline.
    For more information on containers, refer to [Chapter 4](ch04.xhtml#containers).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is a container orchestration tool that helps with operating hundreds
    or even thousands of containers on physical machines, virtual machines, or in
    the cloud. Kubernetes can also fulfill those cross-cutting concerns mentioned
    earlier. The container runtime engine integrates with Kubernetes. Whenever a container
    creation is triggered, Kubernetes will delegate life cycle aspects to the container
    runtime engine.
  prefs: []
  type: TYPE_NORMAL
- en: The most essential primitive in a Kubernetes is a Pod. The Pod can run one or
    many containers while at the same time adding cross-cutting concerns like security
    requirements and resource consumption expectations. Have a look at [Chapter 5](ch05.xhtml#pods_namespaces)
    to learn about those aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous section touched on some features provided by Kubernetes. Here,
    we are going to dive a little deeper by explaining those features with more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative model
  prefs: []
  type: TYPE_NORMAL
- en: You do not have to write imperative code using a programming language to tell
    Kubernetes how to operate an application. All you need to do as an end user is
    to declare a desired state. The desired state can be defined using a YAML or JSON
    manifest that conforms to an API schema. Kubernetes then maintains the state and
    recovers it in case of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling
  prefs: []
  type: TYPE_NORMAL
- en: You will want to scale up resources when your application load increases, and
    scale down when traffic to your application decreases. This can be achieved in
    Kubernetes by manual or automated scaling. The most practical, optimized option
    is to let Kubernetes automatically scale resources needed by a containerized application.
  prefs: []
  type: TYPE_NORMAL
- en: Application management
  prefs: []
  type: TYPE_NORMAL
- en: Changes to applications, e.g., new features and bug fixes, are usually baked
    into a container image with a new tag. You can easily roll out those changes across
    all containers running them using Kubernetes’ convenient replication feature.
    If needed, Kubernetes also allows for rolling back to a previous application version
    in case of a blocking bug or if a security vulnerability is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent storage
  prefs: []
  type: TYPE_NORMAL
- en: Containers offer only a temporary filesystem. Upon restart of the container,
    all data written to the filesystem is lost. Depending on the nature of your application,
    you may need to persist data for longer, for example, if your application interacts
    with a database. Kubernetes offers the ability to mount storage required by application
    workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs: []
  type: TYPE_NORMAL
- en: To support a microservices architecture, the container orchestrator needs to
    allow for communication between containers, and from end users to containers from
    outside of the cluster. Kubernetes employs internal and external load balancing
    for routing network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: High-Level Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecturally, a Kubernetes cluster consists of control plane nodes and worker
    nodes, as shown in [Figure 2-1](#kubernetes-architecture). Each node runs on infrastructure
    provisioned on a physical or virtual machine, or in the cloud. The number of nodes
    you want to add to the cluster and their topology depends on the application resource
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0201](Images/ckd2_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Kubernetes cluster nodes and components
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Control plane nodes and worker nodes have specific responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Control plane node
  prefs: []
  type: TYPE_NORMAL
- en: This node exposes the Kubernetes API through the API server and manages the
    nodes that make up the cluster. It also responds to cluster events, for example,
    when the end user requested to scale up the number of Pods to distribute the load
    for an application. Production clusters employ a [highly available (HA) architecture](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/)
    that usually involves three or more control plane nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Worker node
  prefs: []
  type: TYPE_NORMAL
- en: The worker node executes workload in containers managed by Pods. Every worker
    node needs a container runtime engine installed on the host machine to be able
    to manage containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, we’ll talk about the essential components embedded
    in those nodes to fulfill their tasks. Add-ons like cluster DNS are not discussed
    explicitly here. See the [Kubernetes documentation](https://kubernetes.io/docs/concepts/overview/components/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Control Plane Node Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The control plane node requires a specific set of components to perform its
    job. The following list of components will give you an overview:'
  prefs: []
  type: TYPE_NORMAL
- en: API server
  prefs: []
  type: TYPE_NORMAL
- en: The API server exposes the API endpoints clients use to communicate with the
    Kubernetes cluster. For example, if you execute the tool `kubectl`, a command-line
    based Kubernetes client, you will make a RESTful API call to an endpoint exposed
    by the API server as part of its implementation. The API processing procedure
    inside of the API server will ensure aspects like authentication, authorization,
    and admission control. For more information on that topic, see [Chapter 17](ch17.xhtml#authentication_authorization_admission_control).
  prefs: []
  type: TYPE_NORMAL
- en: Scheduler
  prefs: []
  type: TYPE_NORMAL
- en: The scheduler is a background process that watches for new Kubernetes Pods with
    no assigned nodes and assigns them to a worker node for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Controller manager
  prefs: []
  type: TYPE_NORMAL
- en: The controller manager watches the state of your cluster and implements changes
    where needed. For example, if you make a configuration change to an existing object,
    the controller manager will try to bring the object into the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: Etcd
  prefs: []
  type: TYPE_NORMAL
- en: Cluster state data needs to be persisted over time so it can be reconstructed
    upon a node or even a full cluster restart. That’s the responsibility of [etcd](https://etcd.io/),
    an open source software Kubernetes integrates with. At its core, etcd is a key-value
    store used to persist all data related to the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Common Node Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes employs components that are leveraged by all nodes independent of
    their specialized responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubelet
  prefs: []
  type: TYPE_NORMAL
- en: The kubelet runs on every node in the cluster; however, it makes the most sense
    to exist on a worker node. The reason is that the control plane node usually doesn’t
    execute workload, and the worker node’s primary responsibility is to run workload.
    The kubelet is an agent that makes sure that the necessary containers are running
    in a Pod. You could say that the kubelet is the glue between Kubernetes and the
    container runtime engine and ensures that containers are running and healthy.
    We’ll have a touch point with the kubelet in [Chapter 14](ch14.xhtml#container_probes).
  prefs: []
  type: TYPE_NORMAL
- en: Kube proxy
  prefs: []
  type: TYPE_NORMAL
- en: The kube proxy is a network proxy that runs on each node in a cluster to maintain
    network rules and enable network communication. In part, this component is responsible
    for implementing the Service concept covered in [Chapter 21](ch21.xhtml#services).
  prefs: []
  type: TYPE_NORMAL
- en: Container runtime
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the container runtime is the software responsible for
    managing containers. Kubernetes can be configured to choose from a range of different
    container runtime engines. While you can install a container runtime engine on
    a control plane, it’s not necessary as the control plane node usually doesn’t
    handle workload. We’ll use a container runtime in [Chapter 4](ch04.xhtml#containers)
    to create a container image and run a container with the produced image.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter points out a couple of advantages of Kubernetes, which are summarized
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Portability
  prefs: []
  type: TYPE_NORMAL
- en: A container runtime engine can manage a container independent of its runtime
    environment. The container image bundles everything it needs to work, including
    the application’s binary or code, its dependencies, and its configuration. Kubernetes
    can run applications in a container in on-premise and cloud environments. As an
    administrator, you can choose the platform you think is most suitable to your
    needs without having to rewrite the application. Many cloud offerings provide
    product-specific, opt-in features. While using product-specific features helps
    with operational aspects, be aware that they will diminish your ability to switch
    easily between platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Resilience
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is designed as a declarative state machine. Controllers are reconciliation
    loops that watch the state of your cluster, then make or request changes where
    needed. The goal is to move the current cluster state closer to the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs: []
  type: TYPE_NORMAL
- en: Enterprises run applications at scale. Just imagine how many software components
    retailers like Amazon, Walmart, or Target need to operate to run their businesses.
    Kubernetes can scale the number of Pods based on demand or automatically according
    to resource consumption or historical trends.
  prefs: []
  type: TYPE_NORMAL
- en: API based
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes exposes its functionality through APIs. We learned that every client
    needs to interact with the API server to manage objects. It is easy to implement
    a new client that can make RESTful API calls to exposed endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Extensibility
  prefs: []
  type: TYPE_NORMAL
- en: The API aspect stretches even further. Sometimes, the core functionality of
    Kubernetes doesn’t fulfill your custom needs, but you can implement your own extensions
    to Kubernetes. With the help of specific extension points, the Kubernetes community
    can build custom functionality according to their requirements, e.g., monitoring
    or logging solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is software for managing containerized applications at scale. Every
    Kubernetes cluster consists of at least a single control plane node and a worker
    node. The control plane node is responsible for scheduling the workload and acts
    as the single entrypoint to manage its functionality. Worker nodes handle the
    workload assigned to them by the control plane node.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is a production-ready runtime environment for companies wanting to
    operate microservice architectures while also supporting nonfunctional requirements
    like scalability, security, load balancing, and extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explain how to interact with a Kubernetes cluster using
    the command-line tool `kubectl`. You will learn how run it to manage objects,
    an essential skill for acing the exam.
  prefs: []
  type: TYPE_NORMAL
