<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. The Output Framework"><div class="chapter" id="the_output_framework">
<h1><span class="label">Chapter 8. </span>The Output Framework</h1>
<p><a contenteditable="false" data-primary="output framework" data-type="indexterm" id="ch08.html0"/>In previous chapters, you learned how Falco collects events (its input) and how it processes them to allow you to receive important security notifications (its output). At the end of this processing pipeline, a key piece of Falco—the <em>output framework</em>—enables it to deliver those notifications (also called <em>alerts</em>) to the right place. We call it a framework because its modular design provides all you need to deliver notifications to any destination you wish. In this chapter, you will learn how the output framework works and how you can configure and extend it.</p>
<section data-type="sect1" data-pdf-bookmark="Falco’s Output Architecture"><div class="sect1" id="falcoapostrophes_output_architecture">
<h1>Falco’s Output Architecture</h1>
<p><a contenteditable="false" data-primary="output framework" data-secondary="Falco’s output architecture" data-type="indexterm" id="ch08.html1"/>The output framework is the last piece of the event-processing pipeline that we have been describing in this part of the book. Falco’s user-space program implements the core mechanism internally, but external tools can extend it. Its job is to deliver notifications to the correct destination on time. Whenever an upstream event (produced by a driver, a plugin, or any other input source supported by Falco) meets a rule’s condition, the rule engine asks the output framework to send a notification to a downstream consumer, which could be any other program or system in your environment (or simply you).</p>
<p>The process of delivering alerts involves two distinct stages, as pictured in <a data-type="xref" href="#the_two_stages_of_delivering_notificati">Figure 8-1</a>.</p>
<p><a contenteditable="false" data-primary="handlers" data-type="indexterm" id="idm45324225547248"/>In the first stage, a <em>handler</em> receives the event data and information about the event-triggered rule. It prepares the notification using the provided information and formats the textual representation according to the rule’s <code>output</code> key. Then, to prevent the output destination from blocking the processing pipeline (which runs in the main execution thread), the handler pushes the notification into a concurrent queue.<sup><a data-type="noteref" id="ch01fn8-marker" href="ch08.xhtml#ch01fn8">1</a></sup> The push operation is nonblocking, so the processing pipeline does not need to wait for the notification consumer to pull the notification; it can continue to do its job without interruption. Indeed, Falco needs to perform this stage as quickly as possible so that the processing pipeline can process the next event.</p>
<figure><div id="the_two_stages_of_delivering_notificati" class="figure">
<img src="Images/pcns_0801.png" alt="" width="600" height="480"/>
<h6><span class="label">Figure 8-1. </span>The two stages of delivering notifications in Falco</h6>
</div></figure>
<p><a contenteditable="false" data-primary="output worker" data-type="indexterm" id="idm45324225539904"/>At the other end of the queue, the <em>output worker</em> (which runs in a separate execution thread) is waiting to pop notifications from the queue. This is when the second stage begins. Once the output worker receives a notification, it immediately fans that notification out to all configured output channels. <a contenteditable="false" data-primary="output channels" data-secondary="defined" data-type="indexterm" id="idm45324225537760"/>An <em>output channel</em> (or simply an <em>output</em>) is a part of the output framework that allows Falco to forward alerts to a destination. Each output channel implements the actual logic to notify a particular class of alert consumers. For instance, some consumers want notifications written to a file, while others prefer them to be posted to a web endpoint (see <a data-type="xref" href="ch10.xhtml#configuring_and_running">Chapter 10</a>).</p>
<p>This two-stage approach allows the processing pipeline to run without interference from the output delivery process. However, things can still go wrong with delivery. In particular, when delivering a notification involves I/O operations, those may block the caller temporarily (for example, in the event of a network slowdown) or indefinitely (e.g., when there’s no space left on the disk). The queue in the middle of the two stages works well at absorbing temporary slowdowns—so well that you won’t even notice them (by default, Falco can accumulate pending notifications in the queue for up to two seconds). But when the recipient of a notification blocks for a long time (or indefinitely), there’s nothing that Falco can automatically do. As a last resort, it will try to inform you about what happened by logging to the <a href="https://oreil.ly/IbBik">standard error stream (<em>stderr</em>)</a>. When this happens, it is usually a symptom of a misconfiguration (for example, the path to the destination is wrong) or insufficient resources (no space left in the destination), which the user is asked to manually fix.</p>
<p>Once the notification delivery process completes, Falco’s user-space program has accomplished its purpose. It’s then up to the consumer to decide what to do with the alert.</p>
<p>The output framework accommodates many different use cases and can take care of many possible issues. It is also flexible enough to allow you to receive notifications in various ways and at different destinations. The rest of this chapter will give you details about all the available possibilities. We’ll also take a quick look at some other tools that allow you to further extend output processing before delivering the notifications to their final destination. (We’ll go deeper into this in <a data-type="xref" href="ch13.xhtml#writing_falco_rules">Chapter 13</a>.)<a contenteditable="false" data-primary="" data-startref="ch08.html1" data-type="indexterm" id="idm45324225530928"/></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Output Formatting"><div class="sect1" id="output_formatting-id000023">
<h1>Output Formatting</h1>
<p><a contenteditable="false" data-primary="output framework" data-secondary="formatting" data-type="indexterm" id="idm45324225527104"/>In the first stage of notification delivery, Falco applies formatting to the notification before forwarding it to the output channel. You can customize how Falco presents notifications to its consumers so that you can easily integrate them with your specific use case.</p>
<p>Two options in the Falco configuration file (<em>/etc/falco/falco.yaml</em>) control this operation. The first controls the formatting of the timestamp:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">time_format_iso_8601</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/></pre>
<p>If this option is <code>false</code> (the default value), Falco will display dates and times according to the <em>/etc/localtime</em> settings. If it’s <code>true</code> (the default value when Falco is running in a container), Falco will use the ISO 8601 standard for representing dates and times. Note that this option controls not only output notifications but also any other messages that Falco logs.</p>
<p>The second option is actually a set of options that enable JSON formatting for the notifications. By default, JSON formatting is disabled:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">json_output</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/></pre>
<p>With this setting, Falco formats the notification as a plain-text string (including the timestamp, the severity, and the message). If it’s set to <code>true</code>, Falco encloses the notification in a JSON-formatted string, including several fields. The following two options allow you to include or exclude some of those fields from the output:</p>
<dl>
<dt><code>json_include_output_property: true</code></dt>
<dd><p>If this option is enabled (the default), you will still find the plain-text representation of the notification in the <code>output</code> field of the JSON object. You can disable this option to save a few bytes if you don’t need it.</p></dd>
<dt><code>json_include_tags_property: true</code></dt>
<dd><p>If this option is enabled, you will find a <code>tags</code> field in the JSON object containing an array of tags specified in the matching rule. Rules with no tags defined will have an empty array (<code>tags:[]</code>) in the output. If you disable this option, you won’t get the <code>tags</code> field in the JSON object.</p></dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Despite its name, <code>json_output</code> is not an output channel. The <code>json_output</code> configuration controls the formatting applied to notifications in the first stage of processing—thus, it affects the content of the notifications that channels deliver. The next section describes the available output channels.</p>
</div>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Output Channels"><div class="sect1" id="output_channe">
<h1>Output Channels</h1>
<p><a contenteditable="false" data-primary="output channels" data-type="indexterm" id="ch08.html2"/><a contenteditable="false" data-primary="output framework" data-secondary="channels" data-type="indexterm" id="ch08.html3"/>Falco comes with six built-in output channels, listed in <a data-type="xref" href="#falcoapostrophes_built_in_output_channe">Table 8-1</a>. We will describe each of them in more detail in the following subsections. By default only two channels are enabled—<a href="https://oreil.ly/kBm4I">standard output</a> and syslog output—but Falco allows you to enable as many channels as you need simultaneously.</p>
<table class="border" id="falcoapostrophes_built_in_output_channe">
<caption><span class="label">Table 8-1. </span>Falco’s built-in output channels</caption>
<thead>
<tr>
<th>Channel</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Standard output</td>
<td>Sends notifications to Falco’s standard output (stdout)</td>
</tr>
<tr>
<td>Syslog output</td>
<td>Sends notifications to the system via syslog</td>
</tr>
<tr>
<td>File output</td>
<td>Writes notifications to a file</td>
</tr>
<tr>
<td>Program output</td>
<td>Pipes notifications to a program’s standard input</td>
</tr>
<tr>
<td>HTTP output</td>
<td>Posts notifications to a URL</td>
</tr>
<tr>
<td>gRPC output</td>
<td>Allows a client program to consume notifications via a gRPC API</td>
</tr>
</tbody>
</table>
<p>You configure these outputs in the Falco configuration file (<em>/etc/falco/falco.yaml</em>). Note that all the configuration snippets in this section are part of this file.</p>
<p>Each output channel has at least one option called <code>enabled</code>, which can be <code>true</code> or <code>false</code>. Other options may be available for specific outputs (you will discover them soon). Furthermore, there are some global options that can affect the functioning of all or some output channels. One such option (which you saw in the previous section) is <code>json_output</code>; when this is enabled, the alert messages will be JSON-formatted, regardless of the output channel used. The other global options that can affect the output channels’ behavior are listed in <a data-type="xref" href="#global_options_for_output_channels">Table 8-2</a>.</p>
<table class="border" id="global_options_for_output_channels">
<caption><span class="label">Table 8-2. </span>Global options for output channels</caption>
<thead>
<tr>
<th>Global option (with default)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class="keep-together">buffered_outputs:</span> false</code></td>
<td>This option enables or disables full buffering in output channels. When disabled, Falco immediately flushes the output buffer on every alert, which may generate higher CPU usage but is useful when piping outputs into another process or a script. Unless you encounter an issue with the default value, you usually won’t need to enable this option. Note that Falco’s <code>--unbuffered</code> command-line flag can override this option. <br/>Not all output channels observe this global option. Some output channels may implement specific buffering strategies that you cannot disable.</td>
</tr>
<tr>
<td><code><span class="keep-together">output_timeout:</span> 2000</code></td>
<td>The value of this option specifies the duration to wait (in milliseconds) before considering the delivery notification deadline exceeded.<br/>When the notification consumer blocks and the output channel cannot deliver an alert within the given deadline, Falco reports an error indicating which output is blocking the notifications. Such an error indicates a misconfiguration issue or I/O problem in the consumer that Falco cannot recover.</td>
</tr>
<tr>
<td><code>outputs:</code><br/><code>  rate: 1</code><br/><code>  max_burst: 1000</code></td>
<td>These options control the notification rate limiter so that output channels do not flood their destinations. The rate limiter implements a token bucket algorithm. To send a notification, the system must remove a token from the bucket. <code>rate</code> sets the number of tokens the system gains per second, and <code>max_burst</code> sets the maximum number of tokens in the bucket. <br/>With the defaults, Falco can send up to 1,000 notifications in a row; then it must wait for additional tokens to be added to the bucket, which happens at the rate of 1 token per second. In other words, once the bucket has been emptied, notifications are rate-limited to one per second.</td>
</tr>
</tbody>
</table>
<div data-type="tip"><h6>Tip</h6>
<p>Although not strictly related to the output mechanism, other Falco settings may affect what you will receive in the output. For example, the configuration <code>priority: <em>&lt;severity&gt;</em></code> controls the minimum rule priority level to load and run, and the command-line option <code>-t <em>&lt;tag&gt;</em></code> allows you to load only those rules with a specific tag. In those cases, clearly, you won’t get any output regarding rules that Falco does not load. In general, any rules-related option or configuration could indirectly affect the output.</p>
</div>
<p>Now that you’ve learned what the output channels are and what settings can change their behavior, let’s go through each in turn.</p>
<section data-type="sect2" data-pdf-bookmark="Standard Output"><div class="sect2" id="standard_output">
<h2>Standard Output</h2>
<p><a contenteditable="false" data-primary="output channels" data-secondary="standard output" data-type="indexterm" id="idm45324225421312"/><a contenteditable="false" data-primary="standard output channel" data-type="indexterm" id="idm45324225419936"/>Standard output (<code>stdout_output</code> in the configuration file, enabled by default) is Falco’s most straightforward output channel. When it is enabled, Falco will print a line to standard output for each alert. This allows you to see alert notifications when manually running Falco from a console or when looking at a container or Kubernetes Pod log. The only option specifically available for this output channel is <code>enabled</code> (which can be either <code>true</code> or <code>false</code>). However, it’s also affected by the global buffering option, <code>buffered_outputs</code>. When the outputs are buffered, the stdout stream will be fully buffered or line-buffered if the stream is an interactive device (such as a TTY).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Syslog Output"><div class="sect2" id="syslog_output">
<h2>Syslog Output</h2>
<p><a contenteditable="false" data-primary="output channels" data-secondary="syslog output" data-type="indexterm" id="idm45324225414768"/><a contenteditable="false" data-primary="syslog output channel" data-type="indexterm" id="idm45324225413168"/>The syslog output channel (<code>syslog_output</code> in the configuration file, also enabled by default) allows Falco to send a syslog message for each alert. As with standard output, the only option specifically available for this output channel is <code>enabled</code> (which can be either <code>true</code> or <code>false</code>). When enabled, Falco sends messages to syslog with a facility of <code>LOG_USER</code><sup><a data-type="noteref" id="ch01fn9-marker" href="ch08.xhtml#ch01fn9">2</a></sup> and a severity level equal to the priority value defined by the rule.</p>
<p>Depending on the syslog daemon you are using, you can read those messages using commands like <code>tail -f /var/log/syslog</code> or <code>journalctl -xe</code>. The actual message format depends on the syslog daemon, too.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="File Output"><div class="sect2" id="file_output">
<h2>File Output</h2>
<p><a contenteditable="false" data-primary="file output channel" data-type="indexterm" id="idm45324225404960"/><a contenteditable="false" data-primary="output channels" data-secondary="file output" data-type="indexterm" id="idm45324225403856"/>If you enable file output, Falco will write each alert to a file. The default configuration for this output channel is:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">file_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">keep_alive</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">filename</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">./events.txt</code><code class="w"/></pre>
<p>The <code>filename</code> option allows you to specify the destination file to which Falco will write. It will create the file if it does not yet exist and will not try to truncate or rotate the file if it exists already.</p>
<p>With <code>keep_alive</code> disabled (the default), Falco will open the file for appending, write the message, and then close the file for each alert. If <code>keep_alive</code> is set to <code>true</code>, Falco will only open the file once before the first alert and will keep it open for all subsequent alerts. Whether <code>keep_alive</code> is enabled or not, Falco closes and reopens the file when it receives a <code>SIGUSR1</code> signal. This feature is handy if you’d like to use a program to rotate the output file (for example, <code>logrotate</code>).</p>
<p>Finally, writing to a file is generally buffered unless you disable the global buffering option. Closing the file will flush the buffer.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Program Output"><div class="sect2" id="program_output">
<h2>Program Output</h2>
<p><a contenteditable="false" data-primary="output channels" data-secondary="program output" data-type="indexterm" id="idm45324225378624"/><a contenteditable="false" data-primary="program output channel" data-type="indexterm" id="idm45324225377248"/>The program output is very similar to the file output, but in this case Falco will write the content of each alert to the standard input of a program you specify in the configuration file. The default configuration for this output channel is:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">program_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">keep_alive</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">program</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"> </code>
<code class="w">    </code><code class="no">jq '{text: .output}' | curl -d @- -X POST https://hooks.slack.com/services...</code><code class="w"/></pre>
<p>The <code>program</code> field allows you to specify the program the alerts will be sent to. Falco runs the program via a shell, so you can specify a command pipeline if you wish to add any processing steps before delivering the messages to the program. This field’s default value shows a nice example of its usage: when executed, that one-liner posts the alert to a Slack webhook endpoint. (However, using Falcosidekick would be a better option; see <a data-type="xref" href="ch12.xhtml#consuming_falco_events">Chapter 12</a>.)</p>
<p>If <code>keep_alive</code> is set to <code>false</code>, Falco restarts the program and writes the content of the alert to its standard input each time it has a notification to deliver. If <code>keep_alive</code> is set to <code>true</code>, Falco starts the program once (right before sending the first alert) and keeps the program pipe open for delivering subsequent alerts.</p>
<p>Falco closes and reopens the program when it receives a <code>SIGUSR1</code> signal. However, the program runs in the same process group as Falco, so it gets all of the signals that Falco receives. It’s up to you to override the program signal handler if you need to.</p>
<p>Buffering is supported via the global option. When Falco closes the program, it also flushes the buffer.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="HTTP Output"><div class="sect2" id="http_output">
<h2>HTTP Output</h2>
<p><a contenteditable="false" data-primary="HTTP output channel" data-type="indexterm" id="idm45324225315200"/><a contenteditable="false" data-primary="output channels" data-secondary="HTTP output" data-type="indexterm" id="idm45324225314096"/>When you need to send alerts over an HTTP(S) connection, the best choice is to use the HTTP output. Its default configuration is straightforward:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">http_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">url</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">http://some.url</code><code class="w"/></pre>
<p>Once enabled, the only other configuration you need to specify is the <code>url</code> of your endpoint. Falco will make an HTTP POST request to the specified URL for each alert. Both unencrypted HTTP and secure HTTPS endpoints are supported. Buffering for this output channel is always enabled (even if you disable the global buffering option).</p>
<p>The HTTP output channel is preferred when you use Falcosidekick; it takes Falco’s alerts and forwards them in fan-out style to many different destinations (more than 50 are available at the time of writing). If you want Falco to forward alerts to Falcosidekick, apply this Falco configuration:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">json_output</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="nt">json_include_output_property</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="nt">http_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">url</code><code class="p">:</code><code class="w"> </code><code class="s">"http://localhost:2801/"</code><code class="w"/></pre>
<p>Note that this configuration assumes you already have Falcosidekick running and configured to listen to <code>localhost:2801</code>; change it accordingly if your setup is different. You can find details about configuring Falcosidekick in <a data-type="xref" href="ch12.xhtml#consuming_falco_events">Chapter 12</a> and in its <a href="https://oreil.ly/uUQBR">online documentation</a>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="gRPC Output"><div class="sect2" id="grpc_output">
<h2>gRPC Output</h2>
<p><a contenteditable="false" data-primary="gRPC output channel" data-type="indexterm" id="ch08.html4"/><a contenteditable="false" data-primary="output channels" data-secondary="gRPC output" data-type="indexterm" id="ch08.html5"/>The <a href="https://grpc.io">gRPC</a> output is the most sophisticated output channel. It allows greater control than the others over alert forwarding and full granularity in the information received. This output channel is for you if you’d like to send alerts to an external program connected via Falco’s gRCP API. Its default configuration is:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">grpc_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/></pre>
<p>As you can see, it’s disabled by default—and before you enable it, there’s something you should consider. Falco comes with a gRPC server that exposes the API. You will need to enable both the gRPC server and the gRPC output (we will show you how to do that in a moment). The API provides several gRPC services, only some of which are related to the gRPC output. One service allows you to pull all pending alerts. Another allows you to subscribe to a stream of alerts. Client programs can decide which implementations best fit their needs. In both cases, when the gRPC output is enabled, Falco uses an internal queue to temporarily store alerts until the client program consumes them. This means you should not enable the gRPC output if there’s no client program set up to consume the alerts; otherwise, the internal queue may grow indefinitely. The global buffering option does not affect this output channel.</p>
<p>With that in mind, to make this output channel work, the first thing you have to do is to enable the gRPC server. It supports two binding types: over a Unix socket and over the network with mandatory mutual TLS authentication.</p>
<p>Here’s how to enable the gRPC server over a Unix socket:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">grpc</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">bind_address</code><code class="p">:</code><code class="w"> </code><code class="s">"unix:///var/run/falco.sock"</code><code class="w"/>
<code class="w">  </code><code class="nt">threadiness</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">0</code><code class="w"/></pre>
<p>And here’s how to enable the gRPC server over the network with mandatory mutual TLS <span class="keep-together">authentication:</span></p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">grpc</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">bind_address</code><code class="p">:</code><code class="w"> </code><code class="s">"0.0.0.0:5060"</code><code class="w"/>
<code class="w">  </code><code class="nt">threadiness</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">0</code><code class="w"/>
<code class="w">  </code><code class="nt">private_key</code><code class="p">:</code><code class="w"> </code><code class="s">"/etc/falco/certs/server.key"</code><code class="w"/>
<code class="w">  </code><code class="nt">cert_chain</code><code class="p">:</code><code class="w"> </code><code class="s">"/etc/falco/certs/server.crt"</code><code class="w"/>
<code class="w">  </code><code class="nt">root_certs</code><code class="p">:</code><code class="w"> </code><code class="s">"/etc/falco/certs/ca.crt"</code><code class="w"/></pre>
<p>Both binding types offer the same gRPC functionalities, so you can choose the one that satisfies your needs. Once you have enabled the gRPC server, the next step is to enable the gRCP output:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">grpc_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/></pre>
<p>Finally, you will have to configure your client program to connect to the Falco gRPC API. How this is done depends on the program you are using. The Falcosecurity organization provides two programs that can connect to this output (see <a data-type="xref" href="ch02.xhtml#getting_started_with_falco">Chapter 2</a>): <a href="https://oreil.ly/FN9gE">falco-exporter</a>, which connects to the Falco gRPC API to export metrics consumable by Prometheus (more on this in <a data-type="xref" href="ch12.xhtml#consuming_falco_events">Chapter 12</a>), and the <a href="https://oreil.ly/4MHw1">event-generator</a>, which can optionally connect to the Falco gRPC API to test whether fake events are actually processed (helpful when developing integration tests). You can also implement your own program. The Falcosecurity organization provides SDKs that allow you to create gRPC client programs for Falco easily in several programming languages—for example, <a href="https://oreil.ly/HXPKL">client-go for Golang</a>, <a href="https://oreil.ly/XdgVp">client-rs for Rust</a>, and <a href="https://oreil.ly/A64Dh">client-py for Python</a>. You can find more information about developing with the Falco gRPC API in <a data-type="xref" href="ch14.xhtml#falco_development">Chapter 14</a>.</p>
<p>Last but not least, here is an extract from the proto-definition of the message that Falco sends via the gRCP API:</p>
<pre data-type="programlisting" data-code-language="protobuf"><code class="c1">// The `response` message is the representation of the output model.</code>
<code class="c1">// It contains all the elements that Falco emits in an output along </code>
<code class="c1">// with the definitions for priorities and source.</code>
<code class="kd">message</code><code class="w"> </code><code class="nc">response</code><code class="w"> </code><code class="p">{</code>
<code class="w">  </code><code class="n">google.protobuf.Timestamp</code><code class="w"> </code><code class="na">time</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code>
<code class="w">  </code><code class="n">falco.schema.priority</code><code class="w"> </code><code class="na">priority</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code>
<code class="w">  </code><code class="n">falco.schema.source</code><code class="w"> </code><code class="na">source_deprecated</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">3</code><code class="w"> </code><code class="p">[</code><code class="na">deprecated</code><code class="o">=</code><code class="kc">true</code><code class="p">];</code>
<code class="w">  </code><code class="kt">string</code><code class="w"> </code><code class="na">rule</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">4</code><code class="p">;</code>
<code class="w">  </code><code class="kt">string</code><code class="w"> </code><code class="na">output</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">5</code><code class="p">;</code>
<code class="w">  </code><code class="n">map</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">string</code><code class="p">&gt;</code><code class="w"> </code><code class="na">output_fields</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">6</code><code class="p">;</code>
<code class="w">  </code><code class="kt">string</code><code class="w"> </code><code class="na">hostname</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">7</code><code class="p">;</code>
<code class="w">  </code><code class="k">repeated</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="na">tags</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">8</code><code class="p">;</code>
<code class="w">  </code><code class="kt">string</code><code class="w"> </code><code class="na">source</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">9</code><code class="p">;</code>
<code class="p">}</code></pre>
<p>The <code>response</code> message includes the already formatted alert string (which you will find in the <code>output</code> field) as well as all the component pieces of information, split across various fields. The client program can assemble and process them in any way it needs, which is very useful if you want to build your own application on top of Falco.<a contenteditable="false" data-primary="" data-startref="ch08.html5" data-type="indexterm" id="idm45324224839888"/><a contenteditable="false" data-primary="" data-startref="ch08.html4" data-type="indexterm" id="idm45324224838576"/></p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Other Logging Options"><div class="sect2" id="other_logging_options">
<h2>Other Logging Options</h2>
<p>So far we’ve described the core part of the output framework. Now let’s look at a few options to help you in troubleshooting. Like most applications, Falco can output debugging information and errors. Those informative messages are about the functioning of Falco itself and are not its primary output.</p>
<p>Falco implements various logging messages internally. They can vary from one release to another. A common example of this logging is the initial information that Falco prints out when it starts. Another, less common case is when Falco informs you that it was not able to load the driver:</p>
<pre data-type="programlisting">Mon Dec 20 14:00:23 2021: Unable to load the driver.</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="logging, in Falco context" data-type="indexterm" id="idm45324224832784"/>The term <em>logging</em> does <em>not</em> refer to the process of outputting security notifications. The log messages discussed in this section are not security alerts. Logging options do not affect notification processing in any way. Also, since these log messages are not notifications, Falco does not output them through the output channels. Although you might see the usual notifications interleaved with log messages when running Falco in a terminal, keep in mind that they are different.</p>
</div>
<p>Falco outputs these messages via the <a href="https://oreil.ly/yatpB">standard error stream</a> and sends them to syslog. You can configure Falco to discard some messages based on their severity level. <a data-type="xref" href="#options_for_falcoapostrophes_internal_l">Table 8-3</a> lists the logging options you can configure in Falco’s configuration file (<em>/etc/falco/falco.yaml</em>).</p>
<table class="border" id="options_for_falcoapostrophes_internal_l">
<caption><span class="label">Table 8-3. </span>Options for Falco’s internal logging</caption>
<thead>
<tr>
<th>Logging option <span class="keep-together">(with default)</span></th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>log_stderr: true</code></td>
<td>If enabled, Falco sends log messages to the stderr.</td>
</tr>
<tr>
<td><code>log_syslog: true</code></td>
<td>If enabled, Falco sends log messages to syslog. Note that this option is not related to the syslog output and does not affect it.</td>
</tr>
<tr>
<td><code>log_level: info</code></td>
<td>This option defines the minimum log level to include in logs: <code>emergency</code>, <code>alert</code>, <code><span class="keep-together">critical</span></code>, <code>error</code>, <code>warning</code>, <code>notice</code>, <code>info</code>, or <code>debug</code>. Note that these values, although similar, are not rule priority levels.<a contenteditable="false" data-primary="" data-startref="ch08.html3" data-type="indexterm" id="idm45324224792128"/><a contenteditable="false" data-primary="" data-startref="ch08.html2" data-type="indexterm" id="idm45324224790752"/></td>
</tr>
</tbody>
</table>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000007">
<h1>Conclusion</h1>
<p>This chapter concludes <a data-type="xref" href="part02.xhtml#ii_the_architecture_of_falco">Part II</a> of this book. At this point, you should have a solid understanding of Falco’s architecture and its inner workings. Your familiarity with the processing pipeline’s data flow, ending with the output framework, will allow you to use Falco in a variety of ways. For example, you can view security notifications in your favorite dashboard or even create a response engine (a mechanism that takes action when a specific event occurs) on top of Falco. To discover more use cases, use your imagination—and continue reading this book.</p>
<p>The next level up is real-world use cases, so <a data-type="xref" href="part03.xhtml#iii_running_falco_in_production">Part III</a> is all about running Falco in production. As always, we will guide you through each step.<a contenteditable="false" data-primary="" data-startref="ch08.html0" data-type="indexterm" id="idm45324224785168"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn8"><sup><a href="ch08.xhtml#ch01fn8-marker">1</a></sup> A <em>concurrent queue</em> is a way of implementing a <a href="https://oreil.ly/NWtzd">queue data structure</a> that multiple running threads can safely access in parallel. The <em>pop</em> and <em>push</em> operations are typical actions that a queue supports (respectively, to enqueue and dequeue an item). Most implementations allow performing those operations in either blocking or nonblocking fashions.</p><p data-type="footnote" id="ch01fn9"><sup><a href="ch08.xhtml#ch01fn9-marker">2</a></sup> In the syslog protocol, the facility value determines the function of the process that created the message. <code>LOG_USER</code> is intended for messages generated by user-level applications.</p></div></div></section></div></body></html>