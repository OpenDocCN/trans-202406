<html><head></head><body><section data-pdf-bookmark="Chapter 3. Declarative Deployment" data-type="chapter" epub:type="chapter"><div class="chapter" id="DeclarativeDeployment">&#13;
<h1><span class="label">Chapter 3. </span>Declarative Deployment</h1>&#13;
&#13;
&#13;
<p>The<a data-primary="Declarative Deployment" data-type="indexterm" id="decdep03"/><a data-primary="updates" data-secondary="Declarative Deployment" data-type="indexterm" id="idm45902106063264"/> heart of the <em>Declarative Deployment</em> pattern is the<a data-primary="deployment" data-secondary="resource" data-type="indexterm" id="idm45902106061776"/> Kubernetes Deployment resource. This abstraction encapsulates the upgrade and<a data-primary="rollbacks" data-type="indexterm" id="idm45902106060640"/> rollback processes of a group of containers and makes its execution a repeatable and automated activity.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902106059584">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>We<a data-primary="problems" data-secondary="container groups, upgrade and rollback of" data-type="indexterm" id="idm45902106058288"/><a data-primary="containers" data-secondary="upgrade and rollback of container groups" data-type="indexterm" id="idm45902106057312"/> can provision isolated environments as namespaces in a self-service manner and place the applications in these environments with minimal human intervention through the<a data-primary="scheduler" data-secondary="Declarative Deployment" data-type="indexterm" id="idm45902106056208"/> scheduler. But with a growing number of microservices, continually updating and replacing them with newer versions becomes an increasing burden too.</p>&#13;
&#13;
<p>Upgrading a service to a next version involves activities such as starting the new version of the<a data-primary="Pods" data-secondary="upgrades and rollbacks" data-type="indexterm" id="idm45902106054640"/> Pod, stopping the old version of a Pod gracefully, waiting and verifying that it has launched successfully, and sometimes rolling it all back to the previous version in the case of failure. These activities are performed either by allowing some downtime but not running concurrent service versions, or with no downtime but increased resource usage due to both versions of the service running during the update process. Performing these steps manually can lead to human errors, and scripting properly can require a significant amount of effort, both of which quickly turn the release process into a bottleneck.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902106053280">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>Luckily, Kubernetes has automated application upgrades as well. Using the concept of <em>Deployment</em>, we can describe how our application should be updated, using different strategies and tuning the various aspects of the update process. If you consider that you do multiple Deployments for every microservice instance per release cycle (which, depending on the team and project, can span from minutes to several months), this is another effort-saving automation by Kubernetes.</p>&#13;
&#13;
<p>In <a data-type="xref" data-xrefstyle="chap-num-title" href="ch02.html#PredictableDemands">Chapter 2, “Predictable Demands”</a>, we<a data-primary="Predictable Demands" data-type="indexterm" id="idm45902104163152"/> saw that, to do its job effectively, the scheduler requires sufficient resources on the host system, appropriate placement policies, and containers with adequately defined resource profiles. Similarly, for a Deployment to do its job correctly, it expects the containers to be good cloud native citizens. At the very core of a Deployment is the ability to start and stop a set of Pods predictably. For this to work as expected, the containers themselves usually listen and<a data-primary="Managed Lifecycle" data-type="indexterm" id="idm45902104162288"/><a data-primary="Managed Lifecycle" data-secondary="Declarative Deployment" data-type="indexterm" id="idm45902104161616"/> honor lifecycle events (such as SIGTERM; see <a data-type="xref" data-xrefstyle="chap-num-title" href="ch05.html#ManagedLifecycle">Chapter 5, “Managed Lifecycle”</a>) and also provide<a data-primary="Health Probe" data-type="indexterm" id="idm45902104159344"/><a data-primary="Health Probe" data-secondary="Declarative Deployment" data-type="indexterm" id="idm45902104158608"/> health-check endpoints as described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.html#HealthProbe">Chapter 4, “Health Probe”</a>, which indicate whether they started successfully.</p>&#13;
&#13;
<p>If a container covers these two areas accurately, the platform can cleanly shut down old containers and replace them by starting updated instances. Then all the remaining aspects of an update process can be defined in a<a data-primary="Predictable Demands" data-secondary="Declarative Deployment" data-type="indexterm" id="idm45902104155984"/> declarative way and executed as one atomic action with predefined steps and an expected outcome. Let’s see the options for a container update behavior.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902104154752">&#13;
<h1>Deployment Updates with kubectl rollout</h1>&#13;
<p>In<a data-primary="imperative rolling updates" data-type="indexterm" id="idm45902104153136"/><a data-primary="kubectl" data-secondary="deployment updates with rollout" data-type="indexterm" id="Kdepup03"/> previous versions of Kubernetes, rolling updates were implemented on the client side with the <code>kubectl rolling-update</code> command.&#13;
In Kubernetes 1.18, <code>rolling-update</code> was removed in favor of a <code>rollout</code> command for <code>kubectl</code>.&#13;
The difference is that <code>kubectl rollout</code> manages an application update on the server side by updating the Deployment <em>declaration</em> and leaving it to Kubernetes to perform the update. The <code>kubectl rolling-update</code> command, in contrast, was <em>imperative</em>: the client <code>kubectl</code> told the server what to do for each update step.</p>&#13;
&#13;
<p>A Deployment can be fully managed by updating the Kubernetes resources files. However, <code>kubectl rollout</code> comes in very handy for everyday rollout tasks:</p>&#13;
<dl>&#13;
<dt><code>kubectl rollout status</code></dt>&#13;
<dd>&#13;
<p>Shows the current status of a Deployment’s rollout.</p>&#13;
</dd>&#13;
<dt><code>kubectl rollout pause</code></dt>&#13;
<dd>&#13;
<p>Pauses a rolling update so that multiple changes can be applied to a Deployment without retriggering another rollout.</p>&#13;
</dd>&#13;
<dt><code>kubectl rollout resume</code></dt>&#13;
<dd>&#13;
<p>Resumes a previously paused rollout.</p>&#13;
</dd>&#13;
<dt><code>kubectl rollout undo</code></dt>&#13;
<dd>&#13;
<p>Performs a rollback to a prevision revision of a Deployment. A rollback is helpful in case of an error during the update.</p>&#13;
</dd>&#13;
<dt><code>kubectl rollout history</code></dt>&#13;
<dd>&#13;
<p>Shows the available revisions of a Deployment.</p>&#13;
</dd>&#13;
<dt><code>kubectl rollout restart</code></dt>&#13;
<dd>&#13;
<p>Does not perform an update but restarts the current set of Pods belonging to a Deployment using the configured rollout strategy.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>You can find usage examples for <code>kubectl rollout</code> commands in the <a href="https://oreil.ly/IrZR3">examples</a>.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rolling Deployment" data-type="sect2"><div class="sect2" id="idm45902099105232">&#13;
<h2>Rolling Deployment</h2>&#13;
&#13;
<p>The<a data-primary="rolling deployment" data-type="indexterm" id="idm45902099103248"/><a data-primary="deployment" data-secondary="rolling" data-type="indexterm" id="idm45902099102512"/> declarative way of updating applications in Kubernetes is through the concept of Deployment. Behind the scenes, the Deployment creates a<a data-primary="ReplicaSet" data-secondary="rolling Deployment" data-type="indexterm" id="idm45902099101280"/> ReplicaSet that supports set-based<a data-primary="label selectors" data-secondary="rolling Deployment" data-type="indexterm" id="idm45902099100208"/> label selectors. Also, the Deployment abstraction allows you to shape &#13;
<span class="keep-together">the update process</span> behavior with strategies such as <code>RollingUpdate</code> (default) and <code>Recreate</code>. <a data-type="xref" href="#ex-rolling-update">Example 3-1</a> shows the important bits for configuring a Deployment for a rolling update strategy.</p>&#13;
<div data-type="example" id="ex-rolling-update">&#13;
<h5><span class="label">Example 3-1. </span>Deployment for a rolling update</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code><code class="w">            </code><a class="co" href="#callout_declarative_deployment_CO1-1" id="co_declarative_deployment_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">strategy</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RollingUpdate</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">rollingUpdate</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">maxSurge</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w">        </code><a class="co" href="#callout_declarative_deployment_CO1-2" id="co_declarative_deployment_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">maxUnavailable</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w">  </code><a class="co" href="#callout_declarative_deployment_CO1-3" id="co_declarative_deployment_CO1-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">minReadySeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">60</code><code class="w">    </code><a class="co" href="#callout_declarative_deployment_CO1-4" id="co_declarative_deployment_CO1-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="nt">selector</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w-Error">  </code><code class="nt">template</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">readinessProbe</code><code class="p">:</code><code class="w">  </code><a class="co" href="#callout_declarative_deployment_CO1-5" id="co_declarative_deployment_CO1-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="nt">exec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"</code><code class="s">stat</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">/random-generator-ready</code><code class="s">"</code><code class="w"> </code><code class="p-Indicator">]</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_declarative_deployment_CO1-1" id="callout_declarative_deployment_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Declaration of three replicas. You need more than one replica for a rolling update to make sense.</p></dd>&#13;
<dt><a class="co" href="#co_declarative_deployment_CO1-2" id="callout_declarative_deployment_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Number of Pods that can be run temporarily in addition to the replicas specified during an update. In this example, it could be a maximum of four replicas.</p></dd>&#13;
<dt><a class="co" href="#co_declarative_deployment_CO1-3" id="callout_declarative_deployment_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Number of Pods that may be unavailable during the update. Here it could be that only two Pods are available at a time during the update.</p></dd>&#13;
<dt><a class="co" href="#co_declarative_deployment_CO1-4" id="callout_declarative_deployment_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Duration in seconds of all readiness probes for a rolled-out Pod needs to be healthy until the rollout continues.</p></dd>&#13;
<dt><a class="co" href="#co_declarative_deployment_CO1-5" id="callout_declarative_deployment_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Readiness<a data-primary="Health Probe" data-type="indexterm" id="idm45902099797776"/><a data-primary="Health Probe" data-secondary="Declarative Deployment" data-type="indexterm" id="idm45902099797040"/> probes that are very important for a rolling deployment to ensure zero downtime—don’t forget them (see <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.html#HealthProbe">Chapter 4, “Health Probe”</a>).</p></dd>&#13;
</dl></div>&#13;
&#13;
<p><code>RollingUpdate</code> strategy behavior ensures there is no downtime during the update process. Behind the scenes, the Deployment implementation performs similar moves by creating new ReplicaSets and replacing old containers with new ones. One enhancement here is that with Deployment, it is possible to control the rate of a new container rollout. The Deployment object allows you to control the range of available and excess Pods through<a data-primary="maxSurge" data-type="indexterm" id="idm45902099794256"/> <code>maxSurge</code> and<a data-primary="maxUnavailable" data-type="indexterm" id="idm45902099793008"/> <code>maxUnavailable</code> fields.</p>&#13;
&#13;
<p>These two fields can be either absolute numbers of Pods or relative percentages that are applied to the configured number of replicas for the Deployment and are rounded up (<code>maxSurge</code>) or down (<code>maxUnavailable</code>) to the next integer value.&#13;
By default, <code>maxSurge</code> and <code>maxUnavailable</code> are both set to 25%.</p>&#13;
&#13;
<p>Another important parameter that influences the rollout behavior is<a data-primary="minReadySeconds" data-type="indexterm" id="idm45902099789104"/> <code>minReadySeconds</code>.&#13;
This field specifies the duration in seconds that the readiness probes of a Pod need to be successful until the Pod itself is considered to be available in a rollout. Increasing this value guarantees that your application Pod is successfully running for some time before continuing with the rollout.&#13;
Also, a larger <code>minReadySeconds</code> interval helps in debugging and exploring the new version.&#13;
A <code>kubectl rollout pause</code> might be easier to leverage when the intervals between the update steps are larger.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-deploy-rolling">Figure 3-1</a> shows the rolling update process.</p>&#13;
&#13;
<figure class="width-95"><div class="figure" id="img-deploy-rolling">&#13;
<img alt="Rolling deployment" src="assets/kup2_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>Rolling deployment</h6>&#13;
</div></figure>&#13;
&#13;
<p>To trigger a declarative update, you have three options:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Replace the whole Deployment with the new version’s Deployment with <span class="keep-together"><code>kubectl replace</code></span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Patch (<code>kubectl patch</code>) or interactively edit (<code>kubectl edit</code>) the Deployment to set the new container image of the new version.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use <code>kubectl set image</code> to set the new image in the Deployment.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>See also the <a href="https://oreil.ly/xSsID">full example</a> in our repository, which demonstrates the usage of these commands and shows you how to monitor or roll back an upgrade with <code>kubectl rollout</code>.</p>&#13;
&#13;
<p>In addition to addressing the drawbacks of the imperative way of deploying services, the Deployment has the following benefits:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Deployment is a Kubernetes resource object whose status is entirely managed by Kubernetes internally. The whole update process is performed on the server side without client interaction.</p>&#13;
</li>&#13;
<li>&#13;
<p>The declarative nature of Deployment specifies how the deployed state should look rather than the steps necessary to get there.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Deployment definition is an executable object and more than just documentation. It can be tried and tested on multiple environments before reaching production.</p>&#13;
</li>&#13;
<li>&#13;
<p>The update process is also wholly recorded and versioned with options to pause, continue, and roll back to previous versions.<a data-primary="" data-startref="Kdepup03" data-type="indexterm" id="idm45902104113904"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Fixed Deployment" data-type="sect2"><div class="sect2" id="idm45902104112528">&#13;
<h2>Fixed Deployment</h2>&#13;
&#13;
<p>A<a data-primary="fixed Deployment" data-type="indexterm" id="idm45902104110368"/><a data-primary="deployment" data-secondary="fixed" data-type="indexterm" id="idm45902104109632"/> <code>RollingUpdate</code> strategy is useful for ensuring zero downtime during the update process. However, the side effect of this approach is that during the update process, two versions of the container are running at the same time. That may cause issues for the service consumers, especially when the update process has introduced backward-incompatible changes in the service APIs and the client is not capable of dealing with them. For this kind of scenario, you can use the<a data-primary="Recreate strategy" data-type="indexterm" id="idm45902104108144"/> <code>Recreate</code> strategy, which is illustrated in <a data-type="xref" href="#img-deploy-fixed">Figure 3-2</a>.</p>&#13;
&#13;
<figure class="width-95"><div class="figure" id="img-deploy-fixed">&#13;
<img alt="Fixed deployment using a Recreate strategy" src="assets/kup2_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>Fixed deployment using a <code>Recreate</code> strategy</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>Recreate</code> strategy has the effect of setting <code>maxUnavailable</code> to the number of declared replicas. This means it first kills all containers from the current version and then starts all new containers simultaneously when the old containers are evicted. The result of this sequence is that downtime occurs while all containers with old versions are stopped, and no new containers are ready to handle incoming requests. On the positive side, two different versions of the containers won’t be running at the same time, so service consumers can connect only one version at a time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Blue-Green Release" data-type="sect2"><div class="sect2" id="idm45902104101840">&#13;
<h2>Blue-Green Release</h2>&#13;
&#13;
<p>The<a data-primary="Blue-Green deployment" data-type="indexterm" id="idm45902104100272"/><a data-primary="deployment" data-secondary="Blue-Green" data-type="indexterm" id="idm45902104099536"/> <em>Blue-Green deployment</em> is a release strategy used for deploying software in a production environment by minimizing downtime and reducing risk. The Kubernetes Deployment abstraction is a fundamental concept that lets you define how Kubernetes transitions immutable containers from one version to another. We can use the Deployment primitive as a building block, together with other Kubernetes primitives, to implement this more advanced release strategy.</p>&#13;
&#13;
<p>A Blue-Green deployment needs to be done manually if no extensions like a service mesh<a data-primary="service meshes" data-type="indexterm" id="idm45902104097632"/> or<a data-primary="Knative" data-secondary="Blue-Green deployment" data-type="indexterm" id="idm45902104096800"/> Knative are used, though. Technically, it works by creating a second Deployment, with the latest version of the containers (let’s call it <em>green</em>) not serving any requests yet. At this stage, the old Pod replicas from the original Deployment (called <em>blue</em>) are still running and serving live requests.</p>&#13;
&#13;
<p>Once we are confident that the new version of the Pods is healthy and ready to handle live requests, we switch the traffic from old Pod replicas to the new replicas. You can do this in Kubernetes by updating the Service selector to match the new containers (labeled with green). As demonstrated in <a data-type="xref" href="#img-deploy-blue-green">Figure 3-3</a>, once the green (v1.1) containers handle all the traffic, the blue (v1.0) containers can be deleted and the resources freed for future Blue-Green deployments.</p>&#13;
&#13;
<figure class="width-95"><div class="figure" id="img-deploy-blue-green">&#13;
<img alt="Blue-Green release" src="assets/kup2_0303.png"/>&#13;
<h6><span class="label">Figure 3-3. </span>Blue-Green release</h6>&#13;
</div></figure>&#13;
&#13;
<p>A benefit of the Blue-Green approach is that only one version of the application is serving requests at a time, which reduces the complexity of handling multiple concurrent versions by the Service consumers. The downside is that it requires twice the application capacity while both blue and green containers are up and running. Also, significant complications can occur with long-running processes and database state drifts during the transitions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Canary Release" data-type="sect2"><div class="sect2" id="sec-deploy-canary">&#13;
<h2>Canary Release</h2>&#13;
&#13;
<p><em>Canary release</em> is<a data-primary="canary release" data-type="indexterm" id="idm45902100162448"/> a way to softly deploy a new version of an application into production by replacing only a small subset of old instances with new ones. This technique reduces the risk of introducing a new version into production by letting only some of the consumers reach the updated version. When we’re happy with the new version of our service and how it performed with a small sample of users, we can replace all the old instances with the new version in an additional step after this canary release. <a data-type="xref" href="#img-deploy-canary">Figure 3-4</a> shows a canary release in action.</p>&#13;
&#13;
<p>In Kubernetes, this technique can be implemented by creating a new<a data-primary="ReplicaSet" data-secondary="canary release" data-type="indexterm" id="idm45902100160400"/> Deployment with a small replica count that can be used as the canary instance. At this stage, the Service should direct some of the consumers to the updated Pod instances. After the canary release and once we are confident that everything with the new ReplicaSet works as expected, we scale the new ReplicaSet up, and the old ReplicaSet down to zero. In a way, we’re performing a controlled and user-tested incremental rollout.</p>&#13;
&#13;
<figure class="width-95"><div class="figure" id="img-deploy-canary">&#13;
<img alt="Canary release" src="assets/kup2_0304.png"/>&#13;
<h6><span class="label">Figure 3-4. </span>Canary release</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902100156960">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>The Deployment primitive is an example of Kubernetes turning the tedious process of manually updating applications into a declarative activity that can be repeated and automated. The out-of-the-box deployment strategies (rolling and recreate) control the replacement of old containers by new ones, and the advanced release strategies (Blue-Green and canary) control how the new version becomes available to service consumers. The latter two release strategies are based on a human decision for the transition trigger and as a consequence are not fully automated by Kubernetes but require human interaction. <a data-type="xref" href="#img-deploy-overview">Figure 3-5</a> summarizes of the deployment and release strategies, showing instance counts during transitions.</p>&#13;
&#13;
<figure class="width-70"><div class="figure" id="img-deploy-overview">&#13;
<img alt="Deployment and release strategies" src="assets/kup2_0305.png"/>&#13;
<h6><span class="label">Figure 3-5. </span>Deployment and release strategies</h6>&#13;
</div></figure>&#13;
&#13;
<p>All software is different, and deploying complex systems usually requires additional steps and checks. The techniques discussed in this chapter cover the Pod update process, but do not include updating and rolling back other Pod dependencies such as ConfigMaps, Secrets, or other dependent services.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902100151696">&#13;
<h1>Pre and Post Deployment Hooks</h1>&#13;
<p>In<a data-primary="deployment" data-secondary="pre and post hooks" data-type="indexterm" id="idm45902100150352"/><a data-primary="pre- and post-deployment hooks" data-type="indexterm" id="idm45902100149344"/><a data-primary="hooks, pre- and post-deployment" data-type="indexterm" id="idm45902100148608"/> the past, there has been a proposal for Kubernetes to allow <a href="https://oreil.ly/iGC-2">hooks in the deployment process</a>.&#13;
Pre and Post hooks would allow the execution of custom commands before and after Kubernetes has executed a deployment strategy.&#13;
Such commands could perform additional actions while the deployment is in progress and would additionally be able to abort, retry, or continue a deployment.&#13;
Those hooks are a good step toward new automated deployment and release strategies.&#13;
Unfortunately, this effort has been stalled for some years (as of 2023), so it is unclear whether this feature will ever come to Kubernetes.</p>&#13;
</div></aside>&#13;
&#13;
<p>One approach that works today is to create a script to manage the update process of services and their dependencies using the Deployment and other primitives discussed in this book.&#13;
However, this imperative approach that describes the individual update steps does not match the declarative nature of Kubernetes.</p>&#13;
&#13;
<p>As an alternative, higher-level declarative approaches have emerged on top of Kubernetes. The most important platforms are described in the sidebar that follows.&#13;
Those techniques work with operators (see <a data-type="xref" data-xrefstyle="chap-num-title" href="ch28.html#Operator">Chapter 28, “Operator”</a>) that take a declarative description of the rollout process and perform the necessary actions on the server side, some of them also including automatic rollbacks in case of an update error.&#13;
For advanced, production-ready rollout scenarios, it is recommended to look at one of those extensions.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="declarative-deployment-higher-level">&#13;
<h1>Higher-Level Deployments</h1>&#13;
<p>The<a data-primary="deployment" data-secondary="higher level" data-type="indexterm" id="idm45902100142976"/> Deployment resource is a good abstraction over ReplicaSets and Pods to allow a simple declarative rollout that a handful of parameters can tune. However, as we have seen, Deployment does not support more sophisticated strategies like<a data-primary="Knative" data-secondary="canary deployment" data-type="indexterm" id="idm45902100141840"/> canary or Blue-Green deployments directly. There are higher-level abstractions that enhance Kubernetes by introducing new resource types, enabling the declaration of more flexible deployment strategies. Those extensions all leverage the <em>Operator</em> pattern described in <a data-type="xref" href="ch28.html#Operator">Chapter 28</a> and introduce their own custom resources for describing the desired rollout behavior.</p>&#13;
&#13;
<p>As of 2023, the most prominent platforms that support higher-level Deployments include the following:</p>&#13;
<dl>&#13;
<dt>Flagger</dt>&#13;
<dd>&#13;
<p>Flagger<a data-primary="Flagger" data-type="indexterm" id="idm45902105406784"/> implements several deployment strategies and is part of the Flux CD GitOps tools. It supports canary and Blue-Green deployments and integrates with many ingress controllers and<a data-primary="service meshes" data-type="indexterm" id="idm45902105405920"/> service meshes to provide the necessary traffic split between your app’s old and new versions. It can also monitor the status of the rollout process based on a custom metric and detect if the rollout fails so that it can trigger an automatic rollback.</p>&#13;
</dd>&#13;
<dt>Argo Rollouts</dt>&#13;
<dd>&#13;
<p>The<a data-primary="Argo Rollouts" data-type="indexterm" id="idm45902105403840"/> focus on this part of the Argo family of tools is on providing a comprehensive and opinionated continuous delivery (CD) solution for Kubernetes. Argo Rollouts support advanced deployment strategies, like Flagger, and integrate into many ingress controllers and service meshes. It has very similar capabilities to Flagger, so the decision about which one to use should be based on which CD solution you prefer, Argo or Flux.</p>&#13;
</dd>&#13;
<dt>Knative</dt>&#13;
<dd>&#13;
<p>Knative<a data-primary="Knative" data-secondary="higher-level deployments" data-type="indexterm" id="idm45902105401696"/> a serverless platform on top of Kubernetes. A core feature of Knative is traffic-driven autoscaling support, which is described in detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch29.html#ElasticScale">Chapter 29, “Elastic Scale”</a>. Knative also provides a simplified deployment model and<a data-primary="Knative" data-secondary="traffic split" data-type="indexterm" id="idm45902105399184"/> traffic splitting, which is very helpful for supporting high-level deployment rollouts. The support for rollout or rollbacks is not as advanced as with Flagger or Argo Rollouts but is still a substantial improvement over the rollout capabilities of Kubernetes Deployments. If you are using Knative anyway, the intuitive way of splitting traffic between two application versions is a good alternative to Deployments.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Like Kubernetes, all of these projects are part of the<a data-primary="Cloud Native Computing Foundation (CNCF)" data-type="indexterm" id="idm45902105397568"/><a data-primary="CNCF (Cloud Native Computing Foundation)" data-type="indexterm" id="idm45902105396896"/> Cloud Native Computing Foundation (CNCF) project and have excellent community support.</p>&#13;
</div></aside>&#13;
&#13;
<p>Regardless of the deployment strategy you are using, it is essential for Kubernetes to know when your application Pods are up and running to perform the required sequence of steps to reach the defined target deployment state. The next pattern, <em>Health Probe</em>, in <a data-type="xref" href="ch04.html#HealthProbe">Chapter 4</a> describes how your application can communicate its health state to Kubernetes.<a data-primary="" data-startref="decdep03" data-type="indexterm" id="idm45902105394400"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="declarative-deployment-more-information">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/xSsID">Declarative Deployment Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/paEA0">Performing a Rolling Update</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/NKEnH">Deployments</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/wb7D5">Run a Stateless Application Using a Deployment</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/sbN9T">Blue-Green Deployment</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Z-vFT">Canary Release</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/JGL4C">Flagger: Deployment Strategies</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/0lzcD">Argo Rollouts</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/PAwMQ">Knative: Traffic Management</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>