<html><head></head><body><section data-pdf-bookmark="Chapter 28. Operator" data-type="chapter" epub:type="chapter"><div class="chapter" id="Operator">&#13;
<h1><span class="label">Chapter 28. </span>Operator</h1>&#13;
&#13;
&#13;
<p>An<a data-primary="operators" data-type="indexterm" id="oprtr28"/> operator is a<a data-primary="controllers" data-type="indexterm" id="idm45902083143136"/> controller that uses a CRD to encapsulate operational knowledge for a specific application in an algorithmic and automated form. The <em>Operator</em> pattern allows us to extend the <em>Controller</em> pattern from the preceding chapter for more flexibility and greater expressiveness.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902083141376">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>You<a data-primary="problems" data-secondary="controller, adding flexibility and expressiveness to" data-type="indexterm" id="idm45902083139872"/> learned in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch27.html#Controller">Chapter 27, “Controller”</a>, how to extend the Kubernetes platform in a simple and decoupled way. However, for extended use cases, plain custom controllers are not powerful enough, as they are limited to watching and managing Kubernetes intrinsic resources only. Moreover, sometimes we want to add new concepts to the Kubernetes platform, which requires additional domain objects. For example, let’s say we chose Prometheus as our monitoring solution and want to add it as a monitoring facility to Kubernetes in a well-defined way. Wouldn’t it be wonderful to have a Prometheus resource describing our monitoring setup and all the deployment details, similar to how we define other Kubernetes resources? Moreover, could we have resources relating to services we have to monitor (e.g., with a label selector)?</p>&#13;
&#13;
<p>These<a data-primary="CustomResourceDefinition (CRD)" data-secondary="uses for" data-type="indexterm" id="idm45902083136992"/> situations are precisely the kind of use cases where  CustomResourceDefinition (CRD) resources are very helpful. They allow extensions of the Kubernetes API, by adding custom resources to your Kubernetes cluster and using them as if they were native resources.&#13;
Custom resources, together with a controller acting on these resources, form the <em>Operator</em> pattern.</p>&#13;
&#13;
<p class="pagebreak-before">This <a href="https://oreil.ly/bFEU-">quote by Jimmy Zelinskie</a> probably describes the characteristics of operators best:</p>&#13;
<blockquote>&#13;
<p>An operator is a Kubernetes controller that understands two domains: Kubernetes and something else. By combining knowledge of both areas, it can automate tasks that usually require a human operator that understands both domains.</p></blockquote>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902083133136">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>As you saw in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch27.html#Controller">Chapter 27, “Controller”</a>, we can efficiently react to state changes of default Kubernetes resources. Now that you understand one half of the <em>Operator</em> pattern, let’s have a look at the other half—representing custom resources on Kubernetes using CRD resources.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Custom Resource Definitions" data-type="sect2"><div class="sect2" id="Operator-crd">&#13;
<h2>Custom Resource Definitions</h2>&#13;
&#13;
<p>With<a data-primary="CustomResourceDefinition (CRD)" data-secondary="managing domain concepts with" data-type="indexterm" id="idm45902083127680"/> a CRD, we can extend Kubernetes to manage our domain concepts on the Kubernetes platform. Custom resources are managed like any other resource, through the Kubernetes API, and are eventually stored in the backend store etcd.</p>&#13;
&#13;
<p>The preceding scenario is actually implemented with these new custom resources by the CoreOS<a data-primary="Prometheus operator" data-type="indexterm" id="idm45902083125968"/> Prometheus operator to allow seamless integration of Prometheus to Kubernetes. The Prometheus CRD is defined in <a data-type="xref" href="#ex-operator-crd">Example 28-1</a>, which also explains most of the available fields for a CRD.</p>&#13;
<div data-type="example" id="ex-operator-crd">&#13;
<h5><span class="label">Example 28-1. </span>CustomResourceDefinition</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apiextensions.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">CustomResourceDefinition</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheuses.monitoring.coreos.com</code><code class="w"> </code><a class="co" href="#callout_operator_CO1-1" id="co_operator_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">monitoring.coreos.com</code><code class="w">             </code><a class="co" href="#callout_operator_CO1-2" id="co_operator_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">names</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Prometheus</code><code class="w">                       </code><a class="co" href="#callout_operator_CO1-3" id="co_operator_CO1-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">plural</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheuses</code><code class="w">                   </code><a class="co" href="#callout_operator_CO1-4" id="co_operator_CO1-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">scope</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespaced</code><code class="w">                        </code><a class="co" href="#callout_operator_CO1-5" id="co_operator_CO1-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">versions</code><code class="p">:</code><code class="w">                                </code><a class="co" href="#callout_operator_CO1-6" id="co_operator_CO1-6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">                               </code><a class="co" href="#callout_operator_CO1-7" id="co_operator_CO1-7"><img alt="7" src="assets/7.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w">                          </code><a class="co" href="#callout_operator_CO1-8" id="co_operator_CO1-8"><img alt="8" src="assets/8.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">served</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w">                           </code><a class="co" href="#callout_operator_CO1-9" id="co_operator_CO1-9"><img alt="9" src="assets/9.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">schema</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">openAPIV3Schema</code><code class="p">:</code><code class="w"> </code><code class="p">...</code><code class="l-Scalar-Plain">.</code><code class="w">                </code><a class="co" href="#callout_operator_CO1-10" id="co_operator_CO1-10"><img alt="10" src="assets/10.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operator_CO1-1" id="callout_operator_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Name.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO1-2" id="callout_operator_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>API group it belongs to.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO1-3" id="callout_operator_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Kind used to identify instances of this resource.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO1-4" id="callout_operator_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Naming rule for creating the plural form, used for specifying a list of those objects.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO1-5" id="callout_operator_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Scope—whether the resource can be created cluster-wide or is specific to a namespace.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO1-6" id="callout_operator_CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Versions available for this CRD.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO1-7" id="callout_operator_CO1-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Name of a supported version.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO1-8" id="callout_operator_CO1-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Exactly one version has to be the storage version used for storing the definition in the backend.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO1-9" id="callout_operator_CO1-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Whether this version is served via the REST API.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO1-10" id="callout_operator_CO1-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>OpenAPI V3 schema for validation (not shown here).</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>An<a data-primary="OpenAPI V3 schema" data-type="indexterm" id="idm45902083001328"/> OpenAPI V3 schema can also be specified to allow Kubernetes to validate a custom resource. For simple use cases, this schema can be omitted, but for production-grade CRDs, the schema should be provided so that configuration errors can be detected early.</p>&#13;
&#13;
<p>Additionally, Kubernetes allows us to specify two possible<a data-primary="CustomResourceDefinition (CRD)" data-secondary="subresources" data-type="indexterm" id="idm45902082941120"/> subresources for our CRD via the spec field <code>subresources</code>:<sup><a data-type="noteref" href="ch28.html#idm45902082939568" id="idm45902082939568-marker">1</a></sup></p>&#13;
<dl>&#13;
<dt>scale</dt>&#13;
<dd>&#13;
<p>With this property, a CRD can specify how it manages its replica count. This field can be used to declare the JSON path, where the number of desired replicas of this custom resource is specified: the path to the property that holds the actual number of running replicas and an<a data-primary="label selectors" data-secondary="optional path to" data-type="indexterm" id="idm45902082937376"/> optional path to a label selector that can be used to find copies of custom resource instances. This label selector is usually optional but is required if you want to use this custom resource with the HorizontalPodAutoscaler explained in<a data-primary="Elastic Scale" data-type="indexterm" id="idm45902082936272"/><a data-primary="Elastic Scale" data-secondary="Operator" data-type="indexterm" id="idm45902082935600"/> <a data-type="xref" data-xrefstyle="chap-num-title" href="ch29.html#ElasticScale">Chapter 29, “Elastic Scale”</a>.</p>&#13;
</dd>&#13;
<dt>status</dt>&#13;
<dd>&#13;
<p>When this property is set, a new API call becomes available that allows you to update only the <code>status</code> field of a resource. This API call can be secured individually and allows the operator to reflect the <em>actual</em> status of the resource, which might differ from the <em>declared</em> state in the <code>spec</code> field. When a custom resource is updated as a whole, any sent <code>status</code> section is ignored, as is the case with standard Kubernetes resources.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#ex-operator-crd-subresource">Example 28-2</a> shows a potential subresource path as is also used for a regular Pod.</p>&#13;
<div data-type="example" id="ex-operator-crd-subresource">&#13;
<h5><span class="label">Example 28-2. </span>Subresource definition for a CustomResourceDefinition</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">CustomResourceDefinition</code><code class="w">&#13;
</code><code class="c1"># ...</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">subresources</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">status</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">scale</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">specReplicasPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">.spec.replicas</code><code class="w">         </code><a class="co" href="#callout_operator_CO2-1" id="co_operator_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">statusReplicasPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">.status.replicas</code><code class="w">     </code><a class="co" href="#callout_operator_CO2-2" id="co_operator_CO2-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">labelSelectorPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">.status.labelSelector</code><code class="w"> </code><a class="co" href="#callout_operator_CO2-3" id="co_operator_CO2-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operator_CO2-1" id="callout_operator_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>JSON path to the number of declared replicas.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO2-2" id="callout_operator_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>JSON path to the number of active replicas.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO2-3" id="callout_operator_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>JSON path to a label selector to query for the number of active replicas.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Once we define a CRD, we can easily create such a resource, as shown in &#13;
<span class="keep-together"><a data-type="xref" href="#ex-operator-cr-example">Example 28-3</a>.</span></p>&#13;
<div data-type="example" id="ex-operator-cr-example">&#13;
<h5><span class="label">Example 28-3. </span>A Prometheus custom resource</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">monitoring.coreos.com/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Prometheus</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">serviceMonitorSelector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">team</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">400Mi</code><code class="w"/></pre></div>&#13;
&#13;
<p>The <code>metadata</code> section has the same format and validation rules as any other Kubernetes resource. The <code>spec</code> contains the CRD-specific content, and Kubernetes validates against the given validation rule from the CRD.</p>&#13;
&#13;
<p>Custom resources alone are not of much use without an active component to act on them.&#13;
To give them some meaning, we need again our well-known controller, which watches the lifecycle of these resources and acts according to the declarations found within the resources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Controller and Operator Classification" data-type="sect2"><div class="sect2" id="operator-classification">&#13;
<h2>Controller and Operator Classification</h2>&#13;
&#13;
<p>Before<a data-primary="controllers" data-type="indexterm" id="idm45902082794384"/> we dive into writing our operator, let’s look at a few kinds of classifications for controllers, operators, and especially CRDs. Based on the operator’s action, broadly, the classifications are as follows:</p>&#13;
<dl>&#13;
<dt>Installation CRDs</dt>&#13;
<dd>&#13;
<p>Meant<a data-primary="CustomResourceDefinition (CRD)" data-secondary="installation CRD" data-type="indexterm" id="idm45902082792048"/> for installing and operating applications on the Kubernetes platform. Typical examples are the Prometheus CRDs, which we can use for installing and managing Prometheus itself.</p>&#13;
</dd>&#13;
<dt>Application CRDs</dt>&#13;
<dd>&#13;
<p>In<a data-primary="CustomResourceDefinition (CRD)" data-secondary="application CRD" data-type="indexterm" id="idm45902082789664"/> contrast, these are used to represent an application-specific domain concept. This kind of CRD allows applications deep integration with Kubernetes, which involves combining Kubernetes with an application-specific domain behavior. For example, the ServiceMonitor CRD is used by the<a data-primary="Prometheus operator" data-type="indexterm" id="idm45902082788256"/> Prometheus operator to register specific Kubernetes Services to be scraped by a Prometheus server. The Prometheus operator takes care of adapting the Prometheus server configuration accordingly.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Note that an operator can act on different kinds of CRDs as the Prometheus operator does in this case. The boundary between these two categories of CRDs is blurry.</p>&#13;
</div>&#13;
&#13;
<p>In our categorization of controller and operator, an operator is-a controller that uses CRDs.<sup><a data-type="noteref" href="ch28.html#idm45902082785568" id="idm45902082785568-marker">2</a></sup> However, even this distinction is a bit fuzzy as there are variations in between.</p>&#13;
&#13;
<p>One example is a controller, which uses a ConfigMap as a kind of replacement for a CRD. This approach makes sense in scenarios where default Kubernetes resources are not enough but creating CRDs is not feasible either. In this case, ConfigMap is an excellent middle ground, allowing encapsulation of domain logic within the content of a ConfigMap. An advantage of using a plain ConfigMap is that you don’t need to have the<a data-primary="cluster-admin" data-secondary="controller and operator classification" data-type="indexterm" id="idm45902082743312"/> cluster-admin rights you need when registering a CRD. In certain cluster setups, it is just not possible for you to register such a CRD (e.g., when running on public clusters like OpenShift Online).</p>&#13;
&#13;
<p>However, you can still use the concept of <em>Observe-Analyze-Act</em> when you replace a CRD with a plain ConfigMap that you use as your domain-specific configuration. The drawback is that you don’t get essential tool support like<a data-primary="kubectl" data-secondary="ConfigMap and" data-type="indexterm" id="idm45902082741568"/> <code>kubectl get</code> for CRDs; you have no validation on the API Server level and no support for API versioning. Also, you don’t have much influence on how you model the <code>status</code> field of a ConfigMap, whereas for a CRD, you are free to define your status model as you wish.<sup><a data-type="noteref" href="ch28.html#idm45902082739712" id="idm45902082739712-marker">3</a></sup></p>&#13;
&#13;
<p>Another advantage of CRDs is that you have a fine-grained permission model based on the kind of CRD, which you can tune individually, as is explained in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch26.html#AccessControl">Chapter 26, “Access Control”</a>. This kind of RBAC security is not possible when all your domain configuration is encapsulated in ConfigMaps, as all ConfigMaps in a namespace share the same permission setup.</p>&#13;
&#13;
<p>From an implementation point of view, it matters whether we implement a controller by restricting its usage to vanilla Kubernetes objects or whether we have custom resources managed by the controller. In the former case, we already have all types available in the Kubernetes client library of our choice. For the CRD case, we don’t have the type information out of the box, and we can either use a schemaless approach for managing CRD resources or define the custom types on our own, possibly based on an OpenAPI schema contained in the CRD definition. Support<a data-primary="CustomResourceDefinition (CRD)" data-secondary="support for" data-type="indexterm" id="idm45902082736048"/> for typed CRDs varies by client library and framework used.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-operator-spectrum">Figure 28-1</a> shows<a data-primary="controllers" data-secondary="operators" data-type="indexterm" id="idm45902082733888"/><a data-primary="controllers" data-type="indexterm" id="idm45902082732912"/> our controller and operator categorization starting from simpler resource definition options to more advanced with the boundary between controller and operator being the use of custom resources.</p>&#13;
&#13;
<figure><div class="figure" id="img-operator-spectrum">&#13;
<img alt="Spectrum of controllers and operators" src="assets/kup2_2801.png"/>&#13;
<h6><span class="label">Figure 28-1. </span>Spectrum of controllers and operators</h6>&#13;
</div></figure>&#13;
&#13;
<p>For operators, there is even a more advanced Kubernetes extension hook option.&#13;
When Kubernetes-managed CRDs are not sufficient to represent a problem domain, you can extend the Kubernetes API with its own aggregation layer. We can add a custom-implemented <code>APIService</code> resource as a new URL path to the Kubernetes API.</p>&#13;
&#13;
<p>To connect a Service that is backed by a Pod with the <code>APIService</code>, you can use a resource like that shown in <a data-type="xref" href="#ex-operator-api-service">Example 28-4</a>.</p>&#13;
<div data-type="example" id="ex-operator-api-service">&#13;
<h5><span class="label">Example 28-4. </span>API aggregation with a custom APIService</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apiregistration.k8s.io/v1beta1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">APIService</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1alpha1.sample-api.k8spatterns.io</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">sample-api.k8spattterns.io</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">service</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">custom-api-server</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1alpha1</code><code class="w"/></pre></div>&#13;
&#13;
<p>Besides the Service and Pod implementation, we need some additional security configuration for setting up the ServiceAccount under which the Pod is running.</p>&#13;
&#13;
<p>After it is set up, every request to the API Server <code>https://&lt;api server ip&gt;/apis/sample-api.k8spatterns.io/v1alpha1/namespaces/&lt;ns&gt;/...</code> is directed to our custom Service implementation. It’s up to this custom Service implementation to handle these requests, including persisting the resources managed via this API. This approach is different from the preceding CRD case, where Kubernetes itself completely manages the custom resources.</p>&#13;
&#13;
<p>With a custom API Server, you have many more degrees of freedom, which allows you to go beyond watching resource lifecycle events. On the other hand, you also have to implement much more logic, so for typical use cases, an operator dealing with plain CRDs is often good enough.</p>&#13;
&#13;
<p>A detailed exploration of the API Server capabilities is beyond the scope of this chapter.&#13;
The <a href="https://oreil.ly/eCcU9">official documentation</a> as well as a complete <a href="https://oreil.ly/qPCX7">sample-apiserver</a> have more detailed information.&#13;
Also, you can use the <a href="https://oreil.ly/G_qud">apiserver-builder</a> library, which helps with implementing API Server aggregation.</p>&#13;
&#13;
<p>Now, let’s see how you can develop and deploy operators with CRDs.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Operator Development and Deployment" data-type="sect2"><div class="sect2" id="idm45902082796016">&#13;
<h2>Operator Development and Deployment</h2>&#13;
&#13;
<p>Several<a data-primary="CustomResourceDefinition (CRD)" data-secondary="operator development and deployment" data-type="indexterm" id="idm45902082698176"/> toolkits and frameworks are available for developing operators. The three main projects aiding in the creation of operators are as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubebuilder developed under the SIG API Machinery of Kubernetes itself</p>&#13;
</li>&#13;
<li>&#13;
<p>Operator Framework, a CNCF project</p>&#13;
</li>&#13;
<li>&#13;
<p>Metacontroller from Google Cloud Platform</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We touch on each of these very briefly to give you a good starting point for developing and maintaining your own Operators.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubebuilder" data-type="sect3"><div class="sect3" id="idm45902082693344">&#13;
<h3>Kubebuilder</h3>&#13;
&#13;
<p><em>Kubebuilder</em>, a<a data-primary="Kubebuilder" data-type="indexterm" id="idm45902082691728"/> project by the SIG API Machinery,<sup><a data-type="noteref" href="ch28.html#idm45902082690816" id="idm45902082690816-marker">4</a></sup> is a framework and library for creating Kubernetes APIs via CustomResourceDefinitions.</p>&#13;
&#13;
<p>It comes with outstanding <a href="https://oreil.ly/cmYBo">documentation</a> that also covers general aspects for programming Kubernetes.&#13;
Kubebuilder’s focus is on creating Golang-based operators by adding higher-level abstractions on top of the Kubernetes API to remove some of the overhead.&#13;
It also offers scaffolding of new projects and supports multiple CRDs that can be watched by a single operator.&#13;
Other projects can consume Kubebuilder as a library, and it also offers a plugin architecture to extend the support to languages and platforms beyond Golang.&#13;
For programming against the Kubernetes API, Kubebuilder is an excellent starting point.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operator framework" data-type="sect3"><div class="sect3" id="idm45902082636800">&#13;
<h3>Operator framework</h3>&#13;
&#13;
<p>The<a data-primary="Operator Framework" data-type="indexterm" id="idm45902082635312"/> Operator Framework provides extensive support for developing operators. It offers several subcomponents:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The<a data-primary="Operator SDK" data-type="indexterm" id="opsdk28"/> <em>Operator SDK</em> provides a high-level API for accessing a Kubernetes cluster and a scaffolding to start an operator project.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <em>Operator Lifecycle Manager</em> manages the release and updates of operators and their CRDs. You can think of it as a kind of “operator operator.”</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Operator Hub</em> is a publicly available catalog of operators dedicated to sharing operators built by the community.</p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In the first edition of this book in 2019, we mentioned the high feature overlap of Kubebuilder and the Operator-SDK, and we speculated that both projects might eventually merge. It turned out that instead of a full merge, a different strategy was chosen by the community: all the overlapping parts have been moved to Kubebuilder, and the Operator-SDK uses Kubebuilder now as a dependency. This move is a good example of the power and self-healing effect of community-driven open source projects. The <a href="https://oreil.ly/0GM5e">article</a> “What Are the Differences Between Kubebuilder and Operator-SDK?” contains more information about the relationship between Kubebuilder and the Operator-SDK. The <em>Operator-SDK</em> offers everything needed for developing and maintaining Kubernetes operators. It is built on top of Kubebuilder and uses it directly for scaffolding and managing operators written in Golang. Beyond that, it benefits from Kubebuilder’s plugin system for creating operators based on other technologies. As of 2023, the<a data-primary="Java Operator SDK" data-type="indexterm" id="idm45902082626816"/> Operator-SDK provides plugins for creating operators based on Ansible playbooks or Helm Charts and Java-based operators that use a Quarkus runtime. When scaffolding a project, the SDK also adds the appropriate hooks for integration with the Operator Lifecycle Manager and the Operator Hub.<a data-primary="" data-startref="opsdk28" data-type="indexterm" id="idm45902082625680"/></p>&#13;
</div>&#13;
&#13;
<p>The<a data-primary="Operator Lifecycle Manager (OLM)" data-type="indexterm" id="idm45902082624224"/><a data-primary="OLM (Operator Lifecycle Manager)" data-type="indexterm" id="idm45902082623424"/> <em>Operator Lifecycle Manager</em> (OLM) provides valuable help when using operators. One issue with CRDs is that these resources can be registered only cluster-wide and require cluster-admin permissions. While regular Kubernetes users can typically manage all aspects of the namespaces they have granted access to, they can’t just use operators without interaction with a cluster administrator.</p>&#13;
&#13;
<p>To streamline this interaction, the OLM is a cluster service running in the background under a service account with permission to install CRDs. A dedicated CRD called<a data-primary="ClusterServiceVersion (CSV)" data-type="indexterm" id="idm45902082621808"/><a data-primary="CSV (ClusterServiceVersion)" data-type="indexterm" id="idm45902082621040"/> ClusterServiceVersion (CSV) is registered along with the OLM and allows us to specify the Deployment of an operator together with references to the CRD definitions associated with this operator. As soon as we have created such a CSV, one part of the OLM waits for that CRD and all its dependent CRDs to be registered. If this is the case, the OLM deploys the operator specified in the CSV. Then, another part of the OLM can be used to register these CRDs on behalf of a nonprivileged user. This approach is an elegant way to allow regular cluster users to install their operators.</p>&#13;
&#13;
<p>Operators can be easily published at the <a href="https://oreil.ly/K2t68">Operator Hub</a>.&#13;
Operator Hub makes it easy to discover and install operators.&#13;
The metadata-like name, icon, description, and more is extracted from the operator’s CSV and rendered in a friendly web UI.&#13;
Operator Hub also introduces the concept of <em>channels</em> that allow you to provide different streams like “stable” or “alpha,” to which users can subscribe for automatic updates of various maturity levels.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Metacontroller" data-type="sect3"><div class="sect3" id="idm45902082618416">&#13;
<h3>Metacontroller</h3>&#13;
&#13;
<p>Metacontroller<a data-primary="Metacontroller" data-type="indexterm" id="idm45902082616928"/> is very different from the other two operator building frameworks as it extends Kubernetes with APIs that encapsulate the common parts of writing custom controllers. It acts similarly to Kubernetes Controller Manager by running multiple controllers that are not hardcoded but are defined dynamically through Metacontroller-specific CRDs. In other words, it’s a delegating controller that calls out to the service providing the actual controller logic.</p>&#13;
&#13;
<p>Another way to describe Metacontroller is as declarative behavior. While CRDs allow us to store new types in Kubernetes APIs, Metacontroller makes it easy to define the behavior for standard or custom resources declaratively.</p>&#13;
&#13;
<p>When we define a controller through Metacontroller, we have to provide a function that contains only the business logic specific to our controller. Metacontroller handles all interactions with the Kubernetes APIs, runs a reconciliation loop on our behalf, and calls our function through a webhook. The webhook gets called with a well-defined payload describing the CRD event. As the function returns the value, we return a definition of the Kubernetes resources that should be created (or deleted) on behalf of our controller function.</p>&#13;
&#13;
<p>This delegation allows us to write functions in any language that can understand HTTP and JSON and that do not have any dependency on the Kubernetes API or its client libraries. The functions can be hosted on Kubernetes, or externally on a Functions-as-a-Service provider, or somewhere else.</p>&#13;
&#13;
<p>We cannot go into many details here, but if your use case involves extending and customizing Kubernetes with simple automation or orchestration, and you don’t need any extra functionality, you should have a look at Metacontroller, especially when you want to implement your business logic in a language other than Go. Some controller examples will demonstrate how to implement StatefulSet, Blue-Green Deployment, Indexed Job, and Service per Pod by using Metacontroller only.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example" data-type="sect2"><div class="sect2" id="Operator-example">&#13;
<h2>Example</h2>&#13;
&#13;
<p>Let’s look at a concrete operator example. We extend our example in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch27.html#Controller">Chapter 27, “Controller”</a>, and introduce a CRD of the type ConfigWatcher. An instance of this CRD then specifies a reference to the ConfigMap to watch and specifies which Pods to restart if this ConfigMap changes. With this approach, we remove the dependency of the ConfigMap on the Pods, as we don’t have to modify the ConfigMap itself to add triggering annotations. Also, with our simple annotation-based approach in the Controller example, we can connect only a ConfigMap to a single application too. With a CRD, arbitrary combinations of ConfigMaps and Pods are possible.</p>&#13;
&#13;
<p>This ConfigWatcher custom resource is shown in <a data-type="xref" href="#ex-operator-cr-config-watcher">Example 28-5</a>.</p>&#13;
<div data-type="example" id="ex-operator-cr-config-watcher">&#13;
<h5><span class="label">Example 28-5. </span>Simple ConfigWatcher resource</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigWatcher</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webapp-config-watcher</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">configMap</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webapp-config</code><code class="w"> </code><a class="co" href="#callout_operator_CO3-1" id="co_operator_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">             </code><a class="co" href="#callout_operator_CO3-2" id="co_operator_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webapp</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operator_CO3-1" id="callout_operator_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Reference to ConfigMap to watch.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO3-2" id="callout_operator_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Label selector to determine Pods to restart.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>In this definition, the attribute <code>configMap</code> references the name of the <code>ConfigMap</code> to watch. The field <code>podSelector</code> is a collection of labels and their values, which identify the Pods to restart.</p>&#13;
&#13;
<p>We define the type of this custom resource with a CRD (shown in <a data-type="xref" href="#ex-operator-crd-config-watcher">Example 28-6</a>).</p>&#13;
<div data-type="example" id="ex-operator-crd-config-watcher">&#13;
<h5><span class="label">Example 28-6. </span>ConfigWatcher CRD</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apiextensions.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">CustomResourceDefinition</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">configwatchers.k8spatterns.io</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">scope</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespaced</code><code class="w">          </code><a class="co" href="#callout_operator_CO4-1" id="co_operator_CO4-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns.io</code><code class="w">      </code><a class="co" href="#callout_operator_CO4-2" id="co_operator_CO4-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">names</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigWatcher</code><code class="w">      </code><a class="co" href="#callout_operator_CO4-3" id="co_operator_CO4-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">singular</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">configwatcher</code><code class="w">  </code><a class="co" href="#callout_operator_CO4-4" id="co_operator_CO4-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">plural</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">configwatchers</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">versions</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">                 </code><a class="co" href="#callout_operator_CO4-5" id="co_operator_CO4-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">served</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">schema</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">openAPIV3Schema</code><code class="p">:</code><code class="w">       </code><a class="co" href="#callout_operator_CO4-6" id="co_operator_CO4-6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">object</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">properties</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">configMap</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">string</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">description</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">Name</code><code class="nv"> </code><code class="s">of</code><code class="nv"> </code><code class="s">the</code><code class="nv"> </code><code class="s">ConfigMap</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">podSelector</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">object</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">description</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">Label</code><code class="nv"> </code><code class="s">selector</code><code class="nv"> </code><code class="s">for</code><code class="nv"> </code><code class="s">Pods</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">additionalProperties</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">string</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operator_CO4-1" id="callout_operator_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Connected to a namespace.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO4-2" id="callout_operator_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Dedicated API group.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO4-3" id="callout_operator_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Unique kind of this CRD.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO4-4" id="callout_operator_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Labels of the resource as used in tools like <code>kubectl</code>.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO4-5" id="callout_operator_CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Initial version.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO4-6" id="callout_operator_CO4-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>OpenAPI V3 schema specification for this CRD.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>For our operator to be able to manage custom resources of this type, we need to attach a ServiceAccount with the proper permissions to our operator’s Deployment.&#13;
For this task, we introduce a dedicated Role used later in a RoleBinding to attach it to the ServiceAccount in <a data-type="xref" href="#ex-operator-role">Example 28-7</a>.&#13;
We explain the concept and usage of ServiceAccounts, Roles, and RoleBindings in much more details in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch26.html#AccessControl">Chapter 26, “Access Control”</a>.&#13;
For now, it is sufficient to know that the Role definition in <a data-type="xref" href="#ex-operator-crd-config-watcher">Example 28-6</a> grants permission for all API operations to any instance of ConfigWatcher resources.</p>&#13;
<div data-type="example" id="ex-operator-role">&#13;
<h5><span class="label">Example 28-7. </span>Role definition allowing access to custom resource</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Role</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-watcher-crd</code><code class="w"/>&#13;
<code class="nt">rules</code><code class="p">:</code><code class="w"/>&#13;
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns.io</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">configwatchers</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">configwatchers/finalizers</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">verbs</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="nv">get</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">list</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">create</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">update</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">delete</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">deletecollection</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">watch</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w"/></pre></div>&#13;
&#13;
<p>With these CRDs in place, we can now define custom resources as in <a data-type="xref" href="#ex-operator-cr-config-watcher">Example 28-5</a>.</p>&#13;
&#13;
<p>To make sense of these resources, we have to implement a controller that evaluates these resources and triggers a Pod restart when the ConfigMap changes.</p>&#13;
&#13;
<p>We expand here on our controller script in <a data-type="xref" href="ch27.html#ex-controller-script">Example 27-2</a> and adapt the event loop in the controller script.</p>&#13;
&#13;
<p>In the case of a ConfigMap update, instead of checking for a specific annotation, we do a query on all resources of the kind ConfigWatcher and check whether the modified ConfigMap is included as a <code>configMap</code> value. <a data-type="xref" href="#ex-operator-watch-config-controller-script">Example 28-8</a> shows the reconciliation loop. Refer to our Git repository for the full example, which also includes detailed instructions for installing this operator.</p>&#13;
<div data-type="example" id="ex-operator-watch-config-controller-script">&#13;
<h5><span class="label">Example 28-8. </span>WatchConfig controller reconciliation loop</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code>curl</code><code class="w"> </code><code>-Ns</code><code class="w"> </code><code class="nv">$base</code><code>/api/v1/</code><code class="si">${</code><code class="nv">ns</code><code class="si">}</code><code>/configmaps?watch</code><code class="o">=</code><code class="nb">true</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code class="se">\ </code><code class="w">    </code><a class="co" href="#callout_operator_CO5-1" id="co_operator_CO5-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="k">while</code><code class="w"> </code><code class="nb">read</code><code class="w"> </code><code>-r</code><code class="w"> </code><code>event</code><code class="w">&#13;
</code><code class="k">do</code><code class="w">&#13;
  </code><code class="nv">type</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code><code class="w"> </code><code class="s2">"</code><code class="nv">$event</code><code class="s2">"</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code>jq</code><code class="w"> </code><code>-r</code><code class="w"> </code><code class="s1">'.type'</code><code class="k">)</code><code class="w">&#13;
  </code><code class="k">if</code><code class="w"> </code><code class="o">[</code><code class="w"> </code><code class="nv">$type</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"MODIFIED"</code><code class="w"> </code><code class="o">]</code><code class="p">;</code><code class="w"> </code><code class="k">then</code><code class="w">                         </code><a class="co" href="#callout_operator_CO5-2" id="co_operator_CO5-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
&#13;
    </code><code class="nv">watch_url</code><code class="o">=</code><code class="s2">"</code><code class="nv">$base</code><code class="s2">/apis/k8spatterns.io/v1/</code><code class="si">${</code><code class="nv">ns</code><code class="si">}</code><code class="s2">/configwatchers</code><code class="s2">"</code><code class="w">&#13;
    </code><code class="nv">config_map</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code><code class="w"> </code><code class="s2">"</code><code class="nv">$event</code><code class="s2">"</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code>jq</code><code class="w"> </code><code>-r</code><code class="w"> </code><code class="s1">'.object.metadata.name'</code><code class="k">)</code><code class="w">&#13;
&#13;
    </code><code class="nv">watcher_list</code><code class="o">=</code><code class="k">$(</code><code>curl</code><code class="w"> </code><code>-s</code><code class="w"> </code><code class="nv">$watch_url</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code>jq</code><code class="w"> </code><code>-r</code><code class="w"> </code><code class="s1">'.items[]'</code><code class="k">)</code><code class="w"> </code><a class="co" href="#callout_operator_CO5-3" id="co_operator_CO5-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
&#13;
    </code><code class="nv">watchers</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code><code class="w"> </code><code class="nv">$watcher_list</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code class="se">\ </code><code class="w">                    </code><a class="co" href="#callout_operator_CO5-4" id="co_operator_CO5-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
               </code><code>jq</code><code class="w"> </code><code>-r</code><code class="w"> </code><code class="s2">"</code><code class="s2">select(.spec.configMap == \"</code><code class="nv">$config_map</code><code class="s2">\") | .metadata.name</code><code class="s2">"</code><code class="k">)</code><code class="w">&#13;
&#13;
    </code><code class="k">for</code><code class="w"> </code><code>watcher</code><code class="w"> </code><code class="k">in</code><code class="w"> </code><code>watchers</code><code class="p">;</code><code class="w"> </code><code class="k">do</code><code class="w">                           </code><a class="co" href="#callout_operator_CO5-5" id="co_operator_CO5-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
      </code><code class="nv">label_selector</code><code class="o">=</code><code class="k">$(</code><code>extract_label_selector</code><code class="w"> </code><code class="nv">$watcher</code><code class="k">)</code><code class="w">&#13;
      </code><code>delete_pods_with_selector</code><code class="w"> </code><code class="s2">"</code><code class="nv">$label_selector</code><code class="s2">"</code><code class="w">&#13;
    </code><code class="k">done</code><code class="w">&#13;
  </code><code class="k">fi</code><code class="w">&#13;
</code><code class="k">done</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operator_CO5-1" id="callout_operator_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Start a watch stream to watch for ConfigMap changes for a given namespace.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO5-2" id="callout_operator_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Check for a <code>MODIFIED</code> event only.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO5-3" id="callout_operator_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Get a list of all installed ConfigWatcher custom resources.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO5-4" id="callout_operator_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Extract from this list all ConfigWatcher elements that refer to this ConfigMap.</p></dd>&#13;
<dt><a class="co" href="#co_operator_CO5-5" id="callout_operator_CO5-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>For every ConfigWatcher found, delete the configured Pod via a selector. The logic for calculating a label selector as well as the deletion of the Pods are omitted here for clarity. Refer to the example code in our Git repository for the full implementation.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>As for the controller example, this controller can be tested with a sample web application that is provided in our example Git repository. The only difference with this Deployment is that we use an unannotated ConfigMap for the application <span class="keep-together">configuration</span>.</p>&#13;
&#13;
<p>Although our operator is quite functional, it is also clear that our shell script-based operator is still quite simple and doesn’t cover edge or error cases.&#13;
You can find many more interesting, production-grade examples in the wild.</p>&#13;
&#13;
<p>The canonical place to find real-world operators is <a href="https://oreil.ly/K2t68">Operator Hub</a>.&#13;
The operators in this catalog are all based on the concepts covered in this chapter. We have already seen how a<a data-primary="Prometheus operator" data-type="indexterm" id="idm45902081965440"/> Prometheus operator can manage Prometheus installations. Another Golang-based operator is the<a data-primary="etcd operator" data-type="indexterm" id="idm45902081964592"/> etcd operator for managing an etcd key-value store and automating operational tasks like backing up and restoring the database.</p>&#13;
&#13;
<p>If you are looking for an operator written in the<a data-primary="Strimzi operator" data-type="indexterm" id="idm45902081963248"/> Java programming language, the <a href="https://oreil.ly/S1olv"><em>Strimzi Operator</em></a> is an excellent example of an operator that manages a complex messaging system like Apache Kafka<a data-primary="Apache Kafka" data-type="indexterm" id="idm45902081961584"/><a data-primary="Kafka" data-type="indexterm" id="idm45902081960912"/> on Kubernetes. Another good starting point for Java-based operators is the<a data-primary="Java Operator SDK" data-type="indexterm" id="idm45902081960112"/> <em>Java Operator Plugin</em>, part of the<a data-primary="Operator SDK" data-type="indexterm" id="idm45902081958896"/> Operator-SDK. As of 2023, it is still a young initiative; the best entry point for learning more about creating Java-based operators is the <a href="https://oreil.ly/pEPen">tutorial</a> that explains the process to create a fully working operator.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902082612656">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>While we have learned how to extend the Kubernetes platform, operators are still not a silver bullet. Before using an operator, you should carefully look at your use case to determine whether it fits the Kubernetes paradigm.</p>&#13;
&#13;
<p>In many cases, a plain controller working with standard resources is good enough.&#13;
This approach has the advantage that it doesn’t need any<a data-primary="cluster-admin" data-secondary="Controller" data-type="indexterm" id="idm45902081955488"/> cluster-admin permission to register a CRD, but it has its limitations when it comes to security and validation.</p>&#13;
&#13;
<p>An operator is a good fit for modeling a custom domain logic that fits nicely with the declarative Kubernetes way of handling resources with reactive controllers.</p>&#13;
&#13;
<p>More specifically, consider using an operator with CRDs for your application domain for any of the following situations:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You want tight integration into the already-existing Kubernetes<a data-primary="kubectl" data-secondary="integrating with" data-type="indexterm" id="idm45902081952400"/> tooling like <code>kubectl</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>You are working on a greenfield project where you can design the application from the ground up.</p>&#13;
</li>&#13;
<li>&#13;
<p>You benefit from Kubernetes concepts like resource paths, API groups, API versioning, and especially namespaces.</p>&#13;
</li>&#13;
<li>&#13;
<p>You want to have good client support for accessing the API with watches, authentication, role-based authorization, and selectors for metadata.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If your custom use case fits these criteria, but you need more flexibility in how custom resources can be implemented and persisted, consider using a custom API Server. However, you should also not consider Kubernetes extension points as the golden hammer for everything.</p>&#13;
&#13;
<p>If your use case is not declarative, if the data to manage does not fit into the Kubernetes resource model, or you don’t need a tight integration into the platform, you are probably better off writing your standalone API and exposing it with a classical Service or Ingress object.</p>&#13;
&#13;
<p>The <a href="https://oreil.ly/WdqWi">Kubernetes documentation</a> itself also has a chapter for suggestions on when to use a controller, operator, API aggregation, or custom API implementation.<a data-primary="" data-startref="oprtr28" data-type="indexterm" id="idm45902081945328"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="operator-more-information">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/iN2B4">Operator Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/aIGNA">OpenAPI V3</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/GeHKy">Kubebuilder</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/5JWcN">Operator Framework</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/etanj">Metacontroller</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/1iiab">Client Libraries</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/8ungP">Extend the Kubernetes API with CustomResourceDefinitions</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/0xhlw">Custom Resources</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/kyIsL">Sample-Controller</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/voY92">What Are Red Hat OpenShift Operators?</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45902082939568"><sup><a href="ch28.html#idm45902082939568-marker">1</a></sup> Kubernetes subresources are additional API endpoints that provide further functionality within a resource type.</p><p data-type="footnote" id="idm45902082785568"><sup><a href="ch28.html#idm45902082785568-marker">2</a></sup> <a href="https://oreil.ly/hZykR">is-a</a> emphasizes the inheritance relationship between operator and controller, that an operator has all characteristics of a controller plus a bit more.</p><p data-type="footnote" id="idm45902082739712"><sup><a href="ch28.html#idm45902082739712-marker">3</a></sup> However, you should be aware of common <a href="https://oreil.ly/klv65">API conventions</a> for <code>status</code> and other fields when designing your CRDs. Following common community conventions makes it easier for people and tooling to read your new API objects.</p><p data-type="footnote" id="idm45902082690816"><sup><a href="ch28.html#idm45902082690816-marker">4</a></sup> Special Interest Groups (SIGs) are how the Kubernetes community organizes feature areas. You can find a list of current SIGs on the <a href="https://oreil.ly/q6qd9">Kubernetes community site</a>.</p></div></div></section></body></html>