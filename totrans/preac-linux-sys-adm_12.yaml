- en: Chapter 12\. Troubleshooting Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some have compared Linux troubleshooting to an “exercise in futility,” but troubleshooting
    Linux is neither so dramatic nor difficult if you simply take time to investigate
    what’s going on with your system. All too often, rather than perform any relevant
    troubleshooting, sysadmins will make a quick backup and then reimage (wipe the
    disk and reinstall) the system. I’m not a fan of this practice, though in cases
    of significant security breaches, it’s the best option.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter teaches you general troubleshooting concepts and tools rather than
    how to troubleshoot a specific issue (such as how to fix a website that’s not
    working correctly). Troubleshooting individual problems could fill a very thick
    book or series of books. I discuss operating system troubleshooting, software,
    hardware, and security in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to give you some basic troubleshooting skills, introduce you
    to essential tools, and show you how to find a solution should other options fail.
    Troubleshooting is a personal process; not everyone approaches it the same way.
    These procedures and tools have carried me through my career, but your results
    may vary and, eventually, you’ll find steps and guidelines that work best for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin your lessons in troubleshooting with the operating system itself.
  prefs: []
  type: TYPE_NORMAL
- en: Reviving the Operating System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Troubleshooting the operating system is either very easy or next to impossible.
    There seems to be no middle ground. System errors are often, but not invariably,
    fatal. When I use the word *fatal* in this chapter, I mean unrecoverable errors
    that require you to reimage the system. Operating system problems can be as simple
    as running a filesystem check (`fsck`) and repairing a few files. It can be as
    complex as a multiday troubleshooting session ending in a full system reimage.
    For example, if you experience a kernel panic, your first thought might be to
    reimage the system, but this is only sometimes necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The following section demonstrates how to resolve a kernel panic.
  prefs: []
  type: TYPE_NORMAL
- en: De-escalating a Kernel Panic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple reasons systems boot with a kernel panic. Most of the time,
    it’s either a corrupted *initramfs* file or an improperly created *initramfs*
    file. The *initramfs* file is specific for each kernel, so if you’ve recently
    upgraded your kernel, it’s possible that the *initramfs* didn’t get created in
    the install process or that the *initramfs* creation process didn’t go well. Kernel
    panics can also result from a recent bad patch. Other issues may still cause kernel
    panics, such as hardware failure, but those listed here are the most common and
    easily remedied. A relatively simple procedure (discussed next) might make your
    system bootable again and save the pain of reinstalling everything.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’ve received a message similar to the example in [Figure 12-1](#linux_kernel_panic).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/plsa_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Linux kernel panic
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The screen *freezes* here. There is no “press any key to continue” message.
    You must power off the system and power it back on to begin a new boot process.
    At this point, reboot your system and either start from a bootable ISO, or restart
    and enter the rescue process from the Grub menu. You will be the root user when
    you boot into rescue mode or use a bootable ISO, so be careful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Display your kernel version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to re-create the correct *initramfs* from your kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You might receive a message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You must create the *initramfs* file using a different command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Reboot your system. Hopefully, it will boot without issue. If you experience
    another kernel panic after this repair procedure, you could have a bad hard disk,
    another corrupted boot-related file, or a buggy kernel. Retry the rescue process
    and install a different kernel. Be sure to have your ISO image handy for the process.
  prefs: []
  type: TYPE_NORMAL
- en: Boot to the root rescue shell, mount your ISO image, and install the kernel
    that’s available in the ISO image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, your root filesystem is mounted on */mnt/sysimage* and you
    mounted your ISO under */opt/mnt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Use the kernel package that’s in the ISO image. Now, reboot your system; if
    everything goes well, you should have a functioning system. If not, you should
    consider booting to the rescue environment again—creating a backup of critical
    files, if necessary—and then reimaging the system. Of course, this process may
    also result in kernel panic if you have a hardware problem, such as a bad disk
    or controller.
  prefs: []
  type: TYPE_NORMAL
- en: There are other sources of operating system problems, but they’re so varied
    that it’s impossible to cover them here. Instead, you should check the system’s
    logs, which the next section covers.
  prefs: []
  type: TYPE_NORMAL
- en: Scraping System Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scraping system logs means searching through logs for errors or other relevant
    messages. However, sysadmins live a good part of their lives in */var/log*; sometimes,
    log files are all you have to rely on for troubleshooting system problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'My starting point is to issue a filtered `dmesg` command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This often narrows the possibilities of where to look for a problem with the
    operating system and hardware. If you don’t find any relevant errors via `dmesg`,
    you can investigate further using other filters such as `fault`, `failed`, `undefined`,
    or `unknown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Use your system’s log files if previous searches reveal nothing of value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This might produce a very long list. If it does, I suggest redirecting the
    output to a file so that you can scrape these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can search for something more specific in this text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I grepped for `host` here, but you should `grep` for whatever term you need
    to search for in these results. Refine this process until you find the relevant
    error that fits your problem. It can take time. This is my process, but it usually
    yields valuable information and provides me with a few next steps for further
    investigation.
  prefs: []
  type: TYPE_NORMAL
- en: The next section deals with software troubleshooting and my process for finding
    errors and problems.
  prefs: []
  type: TYPE_NORMAL
- en: Unraveling Software Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software troubleshooting can be tricky. The root cause of software problems
    might not be the software. Still, the problem can manifest itself as a software
    issue until you investigate further. As any experienced sysadmin will tell you,
    software problems can have root causes in hardware, other software, file corruption
    or deletion, software dependency issues, network problems, duplicated ports, duplicated
    IP addresses, and dozens of possible configuration or misconfiguration problems
    anywhere on the system. Software error messages won’t necessarily pinpoint a solution,
    but they’re a first step. However, error codes and logs are a good starting place
    for troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I direct you to locate and sift through system and application
    logs and to perform any built-in or vendor-supplied status and configuration checks.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting System Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System logs are a great starting place to find errors, failures, and successes.
    Yes, successes are not necessarily benign. Think about the scenario where someone
    has breached your network, logs into a system with a legitimate account, becomes
    root, and then exfiltrates confidential data or encrypts your data. It’s only
    the acting party—the person fraudulently accessing the system—that isn’t legitimate.
    The system sees every login and action from this malicious actor as normal, legitimate,
    and successful. These actions probably wouldn’t set off any alarms at all.
  prefs: []
  type: TYPE_NORMAL
- en: Your system logs show what’s happening, so don’t discount checking for successful
    logins. In a later section of this chapter, I give you an example security script
    that shows you logins at a glance for your inspection.
  prefs: []
  type: TYPE_NORMAL
- en: System logs are located in */var/log*. To read these files, you must have root
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the output is too long and too wide for the text of this book, here
    are the two troubleshooting filters I use on system logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I always use the `-i` option to ignore case so that I’m sure to catch every
    instance of error and fail regardless of how the log captures them. The next section
    deals with checking application-specific logs, often more helpful than relying
    on system logs alone.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Application Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, application logs provide specific errors or error codes that help
    you troubleshoot software problems. These logs may be located in */var/log*, under
    the application’s home directory, or in some other directory, but always in a
    subdirectory named *log* or *logs*. For example, Apache’s logs are often in */var/log/httpd*,
    but on Red Hat Enterprise Linux–based systems, there is also a symbolic link from
    */etc/httpd/logs* to */var/log/httpd*. Often these links exist to be backward
    compatible with other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Internal Application Checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some developers include configuration checkers and specific tools with their
    software to help you identify, isolate, and troubleshoot problems. These utilities
    are your best option when facing application-specific configuration issues and
    failures. Some configuration files have a rather complex syntax, and missing a
    single parenthesis or semicolon can be extremely difficult to isolate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following command provides excellent feedback to check your
    Apache HTTP Server configuration syntax. When everything in the *httpd.conf* is
    configured correctly, you receive a `Syntax OK` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if a configuration directive is incorrect, your `configtest` results
    isolate the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration is also checked on the start or restart of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding error message, the line `Oct 16 08:49:44 server1 httpd[59189]:
    AH00526: Syntax error on line 34 of /etc/httpd/conf/httpd.conf:` (part of which
    has been elided in the preceding code listing) informs me there is a syntax error
    in my configuration file and I need to investigate further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of my search don’t help troubleshoot the syntax error, so I use
    the other recommended system tool, `journalctl`, from the preceding `apachectl`
    `restart` command (`See "systemctl status httpd.service" and "journalctl -xe"
    for details.`), the results are just as vague:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Your best course of action is to examine lines in the *httpd.conf* file you
    changed that caused the error. Common problems such as misspelling or using an
    incorrect directive are typical reasons for syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Firewalls and Their Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firewalls are great for slowing down intruders, but they can also interfere
    with troubleshooting. Avoid the temptation to disable your firewall during troubleshooting.
    Instead, add new rules to accommodate what you need to do. You might forget to
    re-enable the firewall, which can lead to disastrous consequences.
  prefs: []
  type: TYPE_NORMAL
- en: The firewall isn’t 100% foolproof, but it has value in slowing down a would-be
    intruder. Sometimes its existence is enough to deter a malicious actor and encourage
    them to seek out easier prey. It’s frustrating to troubleshoot a new service for
    hours to eventually remember that it could be your firewall causing the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Removing and Reinstalling Software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Endless troubleshooting is often an exercise in patience-testing and isn’t recommended.
    There’s no set standard for how long you should spend troubleshooting a software
    problem, but at some point, you must determine that further troubleshooting is
    a waste of your valuable time. You should back up the application’s configuration
    files and data at that time and then remove and reinstall it.
  prefs: []
  type: TYPE_NORMAL
- en: Before reinstalling an application, be sure you have installed the latest stable
    package available or downloaded the latest stable source code. If you were on
    the latest version, try returning to an earlier stable version. Also, be sure
    that your system is updated and has the latest compatible tools and utilities
    for your application. The *README* or *INSTALL* text files, included with source
    code packages, often list compatible compiler versions and versions of other required
    supporting software.
  prefs: []
  type: TYPE_NORMAL
- en: Rebooting Your System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of regular system rebooting is not only foreign to many Linux system
    administrators; it’s downright unheard of. However, rebooting should be a part
    of regular system maintenance. Rebooting refreshes both hardware and software
    configurations, but it also informs you of any failures or problems. For example,
    you might find that some applications don’t start automatically after a reboot.
    Perhaps you didn’t `enable` them with a `systemctl enable *service_name*` command.
    Starting a service places it into memory, sets up listening ports, and allows
    connectivity. Still, that service, unless enabled, will not start on the next
    reboot, whether human-initiated or one resulting from a crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dmesg` command informs you of any problems from your latest reboot. You
    can discover both software and hardware errors by filtering the results. Here
    are two such examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Rebooting your systems shouldn’t be controversial. Monthly warm booting (restart)
    and quarterly cold booting (power off/on) is a standard part of many enterprise
    maintenance cycles, as is patching, security auditing, and port scanning. The
    next section is a discussion of hardware troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Hardware Failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Troubleshooting hardware is generally very easy; hardware either works or doesn’t.
    There are times when hardware begins to fail, and you experience erratic behavior,
    such as intermittent functionality of a network interface card (NIC) or file corruption
    on a failing hard disk. But often a hardware device fails and you must replace
    it. Data center server systems have built-in redundancy of several subsystems
    so that failures aren’t catastrophic. Always purchase server systems with redundant
    power supplies, multiple NICs, and plenty of RAM. Set up disks in arrays such
    as RAID 10 so that failures don’t ruin your evenings and weekends.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you have a multidisk array, please note that if one of the drives fails,
    there will be a performance impact. You’ll receive a warning that a disk has failed,
    and if you have physical access to the system, it’s easy to determine, via status
    lights, which disk has failed. And, although there’s an expense involved, you
    should have multiple new disks on hand to swap out when failures occur. The other
    option is to migrate to solid-state drives (SSDs) that run cooler and have a longer
    lifespan than mechanical drives. Remember that heat is the enemy of electronics,
    which is why data centers seem windy and chilly. Heat dissipation is one of the
    big problems and major design features of any good data center.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections cover preemptive troubleshooting, diagnostics, and hardware
    replacement and a discussion of system design.
  prefs: []
  type: TYPE_NORMAL
- en: Preemptively Troubleshooting Hardware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unless you have some very smart hardware diagnostics from a blade server system
    chassis or a third-party software suite, preemptive hardware failure prediction
    isn’t possible. Native Linux commands provide you with a general listing or status.
    Still, if your hardware components are operating, it’s rare to find a “flagged”
    device or to receive a warning about an imminent failure.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware failures are difficult to predict because, as I mentioned earlier,
    hardware either works or doesn’t. Some hardware components *can* partially fail.
    Network interface cards (NICs) can begin to fail and “jabber” or send malformed
    packets. Jabbering network cards are failing and should be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanical hard disks can partially fail by corrupting files or by booting incorrectly,
    randomly, or not at all. Sometimes a failing hard drive will temporarily repair
    itself after a cold boot. Sometimes you can hear a mechanical hard disk spinning
    up, spinning down, clicking, or *clunking* when they fail. Use a recent backup
    and replace the drive. Use solid-state drives whenever possible. Mirror your drives
    whenever possible too. Solid-state drives will fail on a general or all-or-nothing
    basis. I’ve never seen a solid-state drive partially fail.
  prefs: []
  type: TYPE_NORMAL
- en: Memory “sticks” will generally fail on an all-or-nothing basis. I’ve never seen
    one partially fail. The RAM doesn’t count up completely during the boot process
    when a memory stick fails. For example, if a system contains 64 GB of RAM, it
    might only recognize 48 GB. Although memory sticks may fail individually, they
    are read in pairs. So if you have eight 8 GB memory sticks in a system to add
    up to a total of 64 GB, and you have a single stick failure, the RAM count fails
    in pairs. To clarify, if your system has four banks of two memory sticks (8 GB
    each × 8 sticks = 64 GB), and one memory stick fails, then its paired memory stick
    will also appear to have failed, and you will see only 48 GB of RAM count up on
    boot.
  prefs: []
  type: TYPE_NORMAL
- en: The next section introduces you to a handful of useful hardware commands.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering System Hardware Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I don’t have any bare metal systems with Linux on them. I only have virtual
    machines to work with. I suggest using the commands discussed in this section
    to collect hardware data for every unique physical system you manage and keeping
    this information where you can easily refer to it later. Gather hardware information
    for each bare-metal system and then collect the same information for a single
    virtual machine from each virtualization platform. Virtual hardware is very consistent
    per platform and even between virtual hosts. In other words, if you have all VMware
    hosts and your host software version is consistent, then your virtual machine
    hardware should all be the same. Virtual machines may move among hosts without
    issue because their virtual hardware is generic and consistent regardless of what
    the underlying hardware looks like.
  prefs: []
  type: TYPE_NORMAL
- en: The commands presented in this section gather information about your hardware,
    and while some of the information might overlap, it’s still good to gather information
    from multiple commands. As you’ll see, some commands gather specific details about
    your hardware, while others gather only product names and functions. You can execute
    the commands as a regular user, but some warn you to use the root account, or
    the information might be incomplete or inaccurate. All commands in this section
    are run as the root user. The output from these commands is generally too long
    to fully reproduce in this book, but I’ll provide excerpts for each to give you
    an idea of what the commands report. There are multiple options available for
    each command that offer custom output and reports. Refer to each command’s man
    page to learn more about their options. Finally, note that depending on your specific
    Linux distro, some of the tools discussed might be present and other tools might
    need to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: hwinfo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `hwinfo` utility probes your system’s hardware and reports on its findings.
    The report is very long but very thorough. You can use the `--short` option to
    create an abbreviated summary report. The following listing is the complete short
    report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The entire report is very long, but the short version is complete without all
    the details. Creating both reports for each system you manage is a good strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll cover the so-called “`ls` commands” for hardware. Each one begins
    with the letters `ls` and lists various pieces of a system’s hardware complement.
  prefs: []
  type: TYPE_NORMAL
- en: lshw
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `lshw` utility provides detailed hardware information, including CPU, mainboard,
    memory, firmware, cache configuration, and bus speeds. You can optionally create
    an HTML report version with the `-html` option. The following is a partial output
    from the `lshw` command with no options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `lshw` utility is a comprehensive hardware snapshot of your system. The
    remainder of this section’s `ls` commands are specific to subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: lspci
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `lspci` utility lists all PCI devices, their manufacturer, and version
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: One of the most interesting options for `lshw` is `-sanitize`, which removes
    any sensitive information from the report.
  prefs: []
  type: TYPE_NORMAL
- en: lsblk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `lsblk` utility lists all block devices, their mount points, sizes, and
    other information. To view a complete report available from `lsblk`, you must
    execute it as root because of how it queries information from *sysfs* and the
    *udev db* (if available):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use other options to extract more information, such as device owner,
    permissions, and UUID. The output isn’t formatted correctly for this text, but
    you can enter the following command to see extended block device information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `lsblk` utility does not report on RAM disk devices.
  prefs: []
  type: TYPE_NORMAL
- en: lscpu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `lscpu` utility reports  architecture information about a system’s CPUs.
    It has a lot of options, and some must be stacked, or used together, so refer
    to the man page to review specific requirements for the report you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: CPUs rarely fail, but the information is valuable if you need to check for compatibility
    or when upgrading to a new CPU generation.
  prefs: []
  type: TYPE_NORMAL
- en: Using these utilities for troubleshooting a system requires gathering pre-failure
    information as a hardware audit and then comparing those initial reports with
    those after a suspected failure. A simple `diff` between the pre- and post-failure
    reports will inform you of any differences. Remember that this works because many
    of these utilities probe your hardware when you execute them rather than only
    reading a configuration from a static system text file.
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers security troubleshooting and tools you use to assess
    your security.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Automated Security Checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before troubleshooting a problem, you must know it exists. The way to find out
    if you have a problem is through observation via logs, reports, failed processes,
    removed or damaged files, compromised accounts, and so on. Detecting and fixing
    security issues is a full-time job for software and personnel. In other words,
    if you manage more than a handful of server systems, and depending on their criticality,
    you need to purchase security software with monitoring, automatic updating, notification,
    and some security tools and utilities for system scanning, auditing, and mitigation.
    Furthermore, a single tool isn’t sufficient. You need an intrusion detection/prevention
    system, firewalls, SELinux, anti-malware, and numerous secure system configurations
    to improve your systems’ overall security profile.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I cover creating a daily security report that you can automate
    for reporting on system security. It’s impossible to watch every system 24 hours
    per day unless you have some automated processes taking care of it for you. Malicious
    actors and applications often stop, disrupt, or erase logs to cover their covert
    operations, so sometimes, the lack of information tells you that you have a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I start my day, I prefer to view an automated security report as an HTML
    page to determine if any problems require further investigation. The following
    is an example of a daily security script (*daily_report.sh*) that I’ve used in
    the past. The */opt/note* directory is a web-enabled directory aliased as *reports*
    in my Apache config. I’ve spaced it so that it’s easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the report file as *today’sdate.xhtml* ensures you can keep a list
    of these files for comparison. For example, if you believe you have a possible
    breach, you can perform a `diff` on two files to see if there are differences
    you should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'No response means the files are the same. However, if you perform a `diff`
    and receive something similar to the following, you need to begin investigating
    further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This `diff` shows that someone has created a new root-level account, `jamd`,
    on `10-21-2022`. Unfortunately, the way the intruder created this account, any
    file that `jamd` touches, modifies, or creates will have root ownership and will
    look as if the root account created or modified it. And, now that `jamd` has a
    root account, they can change the root password, remove accounts from */etc/passwd*,
    and remove the */etc/sudoers* file, essentially excluding system administrators
    from accessing the system except for through the console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Intruders rarely lock out system administrators because doing so will cause
    action and remediation. Instead, intruders try to cover their actions and use
    the systems for data exfiltration or attack other systems inside or outside the
    current network.
  prefs: []
  type: TYPE_NORMAL
- en: You can filter logs by specific errors or redirect output from other commands
    to the file, such as a firewall status check. Place the commands in this script
    that you use to check on your systems’ security and then set up a `cron` job as
    `www-data` to run the script daily and check it as soon as you get to work to
    begin some forensic investigation or breathe easy and continue your day. Ensure
    that the `www-data` user has read, write, and execute permissions on the */opt/note*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Troubleshooting is a learned skill that takes time and experience to sharpen,
    but remember to rely on your coworkers, knowledge bases, logs, and your favorite
    internet search engine to help you navigate difficult problems. There’s no shame
    in looking for help from a variety of sources. And remember, sometimes the best
    solution is to abandon a lengthy troubleshooting session and start with a clean
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.xhtml#securing_your_system) deals with securing your system,
    an ongoing task requiring focus, skill, and multiple layers of action.'
  prefs: []
  type: TYPE_NORMAL
