<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. The Linux Kernel"><div class="chapter" id="kernel">
<h1><span class="label">Chapter 2. </span>The Linux Kernel</h1>


<p><a data-type="indexterm" data-primary="kernel" id="ix_ch02-asciidoc0"/>In <a data-type="xref" href="ch01.xhtml#intro-os-overiew">“Why an Operating System at All?”</a>, we learned that the main function of an operating system
is to abstract over different hardware and provide us with an
API. Programming against this API allows
us to write applications without having to worry about where and how they are
executed. In a nutshell, the kernel provides such an API to programs.</p>

<p>In this chapter, we discuss what the Linux kernel is and how you should be
thinking about it as a whole as well as about its components. You will learn
about the overall Linux architecture and the essential role the Linux kernel
plays. One main takeaway of this chapter is that while the kernel
provides all the core functionality, on its own it is not the operating
system but only a very central part of it.</p>

<p>First, we take a bird’s-eye view, looking at how
the kernel fits in and interacts with the underlying hardware.
Then, we review the computational core, discussing
different CPU architectures and how they relate to the kernel.
Next, we zoom in on the individual kernel components and discuss the API
the kernel provides to programs you can run.
Finally, we look at how to customize and extend the Linux kernel.</p>

<p>The purpose of this chapter is to equip you with the necessary terminology,
make you aware of the interfacing between programs and the kernel, and give
you a basic idea what the functionality is. The chapter does not aim to turn
you into a kernel developer or even a sysadmin configuring and compiling
kernels. If, however, you want to dive into that, I’ve put together some
pointers at the end of the chapter.</p>

<p>Now, let’s jump into the deep end: the Linux architecture and the central
role the kernel plays in this context.</p>






<section data-type="sect1" data-pdf-bookmark="Linux Architecture"><div class="sect1" id="kernel-architecture">
<h1>Linux Architecture</h1>

<p><a data-type="indexterm" data-primary="kernel" data-secondary="Linux architecture and" id="idm45805441193184"/><a data-type="indexterm" data-primary="Linux (generally)" data-secondary="architecture" id="idm45805441192336"/>At a high level, the Linux architecture looks as depicted in <a data-type="xref" href="#fig-linux-arch">Figure 2-1</a>.
There are three distinct layers you can group things into:</p>
<dl>
<dt>Hardware</dt>
<dd>
<p>From CPUs and main memory to disk drives, network interfaces, and peripheral devices such as keyboards and monitors.</p>
</dd>
<dt>The kernel</dt>
<dd>
<p>The focus of the rest of this chapter. Note that there are
  a number of components that sit between the kernel and user land, such as
  the init system and system services (networking, etc.), but that are, strictly
  speaking, not part of the kernel.</p>
</dd>
<dt>User land</dt>
<dd>
<p><a data-type="indexterm" data-primary="user land" id="idm45805441186816"/>Where the majority of apps are running, including operating
  system components such as shells (discussed in <a data-type="xref" href="ch03.xhtml#shells-scripting">Chapter 3</a>),
  utilities like <code>ps</code> or <code>ssh</code>, and graphical user interfaces such
  as X Window System–based desktops.</p>
</dd>
</dl>

<p>We focus in this book on the upper two layers of <a data-type="xref" href="#fig-linux-arch">Figure 2-1</a>, that
is, the kernel and user land. We only touch on the hardware layer in this and a few other chapters, where relevant.</p>

<p>The interfaces between the different layers are well defined and part of the
Linux operating system package. Between the kernel and user land is the interface called <em>system calls</em> (<em>syscalls</em> for short). We will explore this in
detail in <a data-type="xref" href="#kernel-syscalls">“syscalls”</a>.</p>

<p>The interface between the hardware and the kernel is, unlike the syscalls,
not a single one. It consists of a collection of individual interfaces,
usually grouped by hardware:</p>
<ol>
<li>
<p>The CPU interface (see <a data-type="xref" href="#kernel-cpu-arch">“CPU Architectures”</a>)</p>
</li>
<li>
<p>The interface with the main memory, covered in <a data-type="xref" href="#kernel-memory-management">“Memory Management”</a></p>
</li>
<li>
<p>Network interfaces and drivers (wired and wireless; see <a data-type="xref" href="#kernel-networking">“Networking”</a>)</p>
</li>
<li>
<p>Filesystem and block devices driver interfaces (see <a data-type="xref" href="#kernel-filesystems">“Filesystems”</a>)</p>
</li>
<li>
<p>Character devices, hardware interrupts, and device drivers,
for input devices like keyboards, terminals, and other I/O (see <a data-type="xref" href="#kernel-drivers">“Device Drivers”</a>)</p>
</li>

</ol>

<figure><div id="fig-linux-arch" class="figure">
<img src="Images/lmlx_0201.png" alt="lmlx 0201" width="600" height="647"/>
<h6><span class="label">Figure 2-1. </span>A high-level view of the Linux architecture</h6>
</div></figure>

<p>As you can see, many of the things we usually consider part of the Linux
operating system, such as shell or utilities such as <code>grep</code>, <code>find</code>, and
<code>ping</code>, are in fact not part of the kernel but, very much like an app you download,
part of user land.</p>

<p>On the topic of user land, you will often read or hear about
user versus kernel mode. This effectively refers to how privileged the access to hardware
is and how restricted the abstractions available are.</p>

<p><a data-type="indexterm" data-primary="kernel mode" id="idm45805441168896"/><a data-type="indexterm" data-primary="user land" id="idm45805441168064"/>In general, <em>kernel mode</em> means fast execution with limited abstraction, whereas <em>user mode</em> means comparatively slower but safer and more convenient abstractions.
Unless you are a <a href="https://oreil.ly/AhAm6">kernel developer</a>,
you can almost always ignore kernel mode, since all your apps will run in user land.
Knowing how to interact with the kernel (<a data-type="xref" href="#kernel-syscalls">“syscalls”</a>), on the other
hand, is vital and part of our considerations.</p>

<p>With this Linux architecture overview out of the way, let’s work our way up
from the hardware.</p>
</div></section>













<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="CPU Architectures"><div class="sect1" id="kernel-cpu-arch">
<h1>CPU Architectures</h1>

<p><a data-type="indexterm" data-primary="CPU architectures" id="ix_ch02-asciidoc1"/><a data-type="indexterm" data-primary="kernel" data-secondary="CPU architectures and" id="ix_ch02-asciidoc2"/>Before we discuss the kernel components, let’s review
a basic concept: computer architectures or CPU families, which we will
use interchangeably. The fact that Linux runs on a large number of different
CPU architectures is arguably one of the reasons it is so popular.</p>

<p>Next to generic code and drivers, the Linux kernel contains
architecture-specific code. This separation allows it to port Linux and make
it available on new hardware quickly.</p>

<p>There are a number of ways to figure out what CPU your Linux is running. Let’s
have a look at a few in turn.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="def-bios">
<h5>The BIOS and UEFI</h5>
<p>Traditionally, UNIX and Linux used the Basic I/O System (BIOS) for bootstrapping itself.<a data-type="indexterm" data-primary="BIOS (Basic I/O System)" id="idm45805441158224"/>
When you power on your Linux laptop, it is entirely hardware-controlled.
First off, the hardware is wired to run the Power On Self Test
(POST), part of the BIOS. POST makes sure that the hardware (RAM, etc.) function
as specified. We will get into the details of the mechanics in <a data-type="xref" href="ch06.xhtml#linux-boot">“The Linux Startup Process”</a>.</p>

<p><a data-type="indexterm" data-primary="UEFI (Unified Extensible Firmware Interface)" id="idm45805441156496"/>In modern environments, the BIOS functions have been effectively replaced by the
<a href="https://oreil.ly/JBwSm">Unified Extensible
Firmware Interface (UEFI)</a>, a public specification that defines a software
interface between an operating system and platform firmware. You will still come
across the term <em>BIOS</em> in documentation and articles, so I suggest
you simply replace it with <em>UEFI</em> in your head and move on.</p>
</div></aside>

<p>One way is a dedicated tool called <code>dmidecode</code> that interacts with the BIOS. If this doesn’t yield results, you could try the following (output shortened):</p>

<pre data-type="programlisting" data-code-language="sh"><code>$</code><code> </code><code>lscpu</code><code>
</code><code>Architecture:</code><code>                </code><code>x86_64</code><code> </code><a class="co" id="co_the_linux_kernel_CO1-1" href="#callout_the_linux_kernel_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>CPU</code><code> </code><code>op-mode</code><code class="o">(</code><code>s</code><code class="o">)</code><code>:</code><code>              </code><code class="m">32</code><code>-bit,</code><code> </code><code class="m">64</code><code>-bit</code><code>
</code><code>Byte</code><code> </code><code>Order:</code><code>                  </code><code>Little</code><code> </code><code>Endian</code><code>
</code><code>Address</code><code> </code><code>sizes:</code><code>               </code><code class="m">40</code><code> </code><code>bits</code><code> </code><code>physical,</code><code> </code><code class="m">48</code><code> </code><code>bits</code><code> </code><code>virtual</code><code>
</code><code>CPU</code><code class="o">(</code><code>s</code><code class="o">)</code><code>:</code><code>                      </code><code class="m">4</code><code> </code><a class="co" id="co_the_linux_kernel_CO1-2" href="#callout_the_linux_kernel_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>On-line</code><code> </code><code>CPU</code><code class="o">(</code><code>s</code><code class="o">)</code><code> </code><code>list:</code><code>         </code><code class="m">0</code><code>-3</code><code>
</code><code>Thread</code><code class="o">(</code><code>s</code><code class="o">)</code><code> </code><code>per</code><code> </code><code>core:</code><code>          </code><code class="m">1</code><code>
</code><code>Core</code><code class="o">(</code><code>s</code><code class="o">)</code><code> </code><code>per</code><code> </code><code>socket:</code><code>          </code><code class="m">4</code><code>
</code><code>Socket</code><code class="o">(</code><code>s</code><code class="o">)</code><code>:</code><code>                   </code><code class="m">1</code><code>
</code><code>NUMA</code><code> </code><code>node</code><code class="o">(</code><code>s</code><code class="o">)</code><code>:</code><code>                </code><code class="m">1</code><code>
</code><code>Vendor</code><code> </code><code>ID:</code><code>                   </code><code>GenuineIntel</code><code>
</code><code>CPU</code><code> </code><code>family:</code><code>                  </code><code class="m">6</code><code>
</code><code>Model:</code><code>                       </code><code class="m">60</code><code>
</code><code>Model</code><code> </code><code>name:</code><code>                  </code><code>Intel</code><code> </code><code>Core</code><code> </code><code>Processor</code><code> </code><code class="o">(</code><code>Haswell,</code><code> </code><code>no</code><code> </code><code>TSX,</code><code> </code><code>IBRS</code><code class="o">)</code><code> </code><a class="co" id="co_the_linux_kernel_CO1-3" href="#callout_the_linux_kernel_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>Stepping:</code><code>                    </code><code class="m">1</code><code>
</code><code>CPU</code><code> </code><code>MHz:</code><code>                     </code><code class="m">2592</code><code>.094</code><code>
</code><code>...</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_the_linux_kernel_CO1-1" href="#co_the_linux_kernel_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The architecture we’re looking at here is <code>x86_64</code>.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO1-2" href="#co_the_linux_kernel_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>It looks like there are four CPUs available.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO1-3" href="#co_the_linux_kernel_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The CPU model name is Intel Core Processor (Haswell).</p></dd>
</dl>

<p>In the previous command, we saw that the CPU architecture was reported to
be <code>x86_64</code>, and the model was reported as “Intel Core Processor (Haswell).”
We will learn more about how to decode this in a moment.</p>

<p>Another way to glean similar architecture information is by using
<code>cat /proc/cpuinfo</code>, or, if you’re only interested in the architecture,
by simply calling <code>uname -m</code>.</p>

<p>Now that we have a handle on querying the architecture information on Linux,
let’s see how to decode it.</p>








<section data-type="sect2" data-pdf-bookmark="x86 Architecture"><div class="sect2" id="cpu-arch-x86">
<h2>x86 Architecture</h2>

<p><a data-type="indexterm" data-primary="CPU architectures" data-secondary="x86" id="idm45805440991440"/><a data-type="indexterm" data-primary="x86 architecture" id="idm45805440990592"/><a href="https://oreil.ly/PoQOT">x86</a> is an instruction set family originally
developed by Intel and later licensed to Advanced Micro Devices (AMD). Within the kernel, <code>x64</code>
refers to the Intel 64-bit processors, and <code>x86</code> stands for Intel 32-bit.
Further, <code>amd64</code> refers to AMD 64-bit processors.</p>

<p>Today, you’ll mostly find the x86 CPU family in desktops and laptops,
but it’s also widely used in servers. Specifically, <code>x86</code> forms the basis
of the public cloud. It is a powerful and widely available architecture but isn’t very energy efficient. Partially due to its heavy reliance on
out-of-order execution, it recently received a lot of attention around security
issues such as <a href="https://oreil.ly/nkEVB">Meltdown</a>.</p>

<p>For further details, for example the Linux/x86 boot protocol or Intel and AMD
specific background, see the <a href="https://oreil.ly/CBvRQ">x86-specific
kernel documentation</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="ARM Architecture"><div class="sect2" id="cpu-arch-arm">
<h2>ARM Architecture</h2>

<p><a data-type="indexterm" data-primary="ARM architecture" id="idm45805440984128"/><a data-type="indexterm" data-primary="CPU architectures" data-secondary="ARM" id="idm45805440983520"/>More than 30 years old, <a href="https://oreil.ly/E9HIN">ARM</a> is a
family of Reduced Instruction Set Computing (RISC) architectures.
RISC usually consists of many generic CPU registers along
with a small set of instructions that can be executed faster.</p>

<p>Because the designers at Acorn—the original company behind ARM—focused from the
get-go on minimal power consumption, you find ARM-based chips in a number of
portable devices such as iPhones. They are also in most Android-based phones and
in embedded systems found in IoT, such as in the Raspberry Pi.</p>

<p>Given that they are fast, cheap, and produce less heat than x86 chips, you shouldn’t be surprised to increasingly find ARM-based CPUs—such as <a href="https://oreil.ly/JpgdQ">AWS Graviton</a>—in the data center.
While simpler than x86, ARM is not immune to vulnerabilities, such as
<a href="https://oreil.ly/M79Yu">Spectre</a>. For further details, see the <a href="https://oreil.ly/i7kj4">ARM-specific
kernel documentation</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="RISC-V Architecture"><div class="sect2" id="cpu-arch-riscv">
<h2>RISC-V Architecture</h2>

<p><a data-type="indexterm" data-primary="BIOS (Basic I/O System)" id="idm45805440977632"/><a data-type="indexterm" data-primary="CPU architectures" data-secondary="RISC-V" id="idm45805440977024"/><a data-type="indexterm" data-primary="RISC-V architecture" id="idm45805440976176"/>An up-and-coming player, <a href="https://oreil.ly/wwnIA">RISC-V (pronounced <em>risk five</em>)</a>
is an open RISC standard that was originally developed by the University of California, Berkeley. As of 2021, a number of implementations exist, ranging from Alibaba Group and Nvidia
to start-ups such as SiFive. While exciting, this is a relatively new
and not widely used (yet) CPU family, and to get an idea how it look and feels,
you may want to research it a little—a good start is
Shae Erisson’s article <a href="https://oreil.ly/6senY">“Linux on RISC-V”</a>.</p>

<p>For further details, see the <a href="https://oreil.ly/LA1Oq">RISC-V
kernel documentation</a>.<a data-type="indexterm" data-startref="ix_ch02-asciidoc2" id="idm45805440972800"/><a data-type="indexterm" data-startref="ix_ch02-asciidoc1" id="idm45805440972192"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Kernel Components"><div class="sect1" id="kernel-components">
<h1>Kernel Components</h1>

<p><a data-type="indexterm" data-primary="kernel" data-secondary="components" id="ix_ch02-asciidoc3"/>Now that you know the basics of CPU architectures, it’s time to dive into the kernel. While the Linux kernel is a
monolithic one—that is, all the components discussed are part of a single
binary—there are functional areas in the code base that we can identify and
ascribe dedicated responsibilities.</p>

<p>As we’ve discussed in  <a data-type="xref" href="#kernel-architecture">“Linux Architecture”</a>, the kernel sits between the
hardware and the apps you want to run. The main functional blocks you find in
the kernel code base are as follows:</p>

<ul>
<li>
<p>Process management, such as starting a process based on an executable file</p>
</li>
<li>
<p>Memory management, such as allocating memory for a process or map
a file into memory</p>
</li>
<li>
<p>Networking, like managing network interfaces or providing the network stack</p>
</li>
<li>
<p>Filesystems providing file management and supporting the creation and deletion
of files</p>
</li>
<li>
<p>Management of character devices and device drivers</p>
</li>
</ul>

<p>These functional components often come with interdependencies, and it’s
a truly challenging task to make sure that the <a href="https://oreil.ly/6YDeF">kernel developer
motto</a> “Kernel
never breaks user land” holds true.</p>

<p>With that, let’s have a closer look at the kernel components.</p>








<section data-type="sect2" data-pdf-bookmark="Process Management"><div class="sect2" id="kernel-process-management">
<h2>Process Management</h2>

<p><a data-type="indexterm" data-primary="kernel" data-secondary="process management" id="ix_ch02-asciidoc4"/><a data-type="indexterm" data-primary="process management" id="ix_ch02-asciidoc5"/>There are a number of process management–related parts in the kernel. Some
of them deal with CPU architecture–specific things, such as interrupts,
and others focus on the launching and scheduling of programs.</p>

<p>Before we get to Linux specifics, let’s note that commonly, a process is the user-facing
unit, based on an executable program (or binary). A thread, on the other hand,
is a unit of execution in the context of a process. <a data-type="indexterm" data-primary="multithreading" id="idm45805440957168"/>You might have come across
the term <em>multithreading</em>, which means that a process has a number of parallel
executions going on, potentially running on different CPUs.</p>

<p>With this general view out of the way, let’s see how Linux goes about it. From
most granular to smallest unit, Linux has the following:</p>
<dl>
<dt>Sessions</dt>
<dd>
<p>Contain one or more process groups and represent a high-level user-facing
unit with optional <code>tty</code> attached. The kernel identifies a session via
a number called <em>session ID</em> (SID).</p>
</dd>
<dt>Process groups</dt>
<dd>
<p>Contain one or more processes, with at most one process group in a session
as the foreground process group. The kernel identifies a process group via
a number called <em>process group ID</em> (PGID).</p>
</dd>
<dt>Processes</dt>
<dd>
<p>Abstractions that group multiple resources (address space,
one or more threads, sockets, etc.), which the kernel exposes to you via
<em>/proc/self</em> for the current process. The kernel identifies a process via
a number called <em>process ID</em> (PID).</p>
</dd>
<dt>Threads</dt>
<dd>
<p>Implemented by the kernel as processes. That is, there are no dedicated
data structures representing threads. Rather, a thread is a process that shares
certain resources (such as memory or signal handlers) with other processes.
The kernel identifies a thread via <em>thread IDs</em> (TID) and <em>thread group IDs</em> (TGID),
with the semantics that a shared TGID value means a multithreaded process
(in user land; there are also kernel threads, but that’s beyond our scope).</p>
</dd>
<dt>Tasks</dt>
<dd>
<p>In the kernel there is a data structure called <code>task_struct</code>—defined in
<a href="https://oreil.ly/nIgz8"><em>sched.h</em></a>—that forms the basis of implementing processes and threads alike. This data
structure captures scheduling-related information, identifiers
(such as PID and TGID), and signal handlers, as well as other information, such as that related to
performance and security. In a nutshell, all of the aforementioned
units are derived and/or anchored in tasks; however, tasks are not
exposed as such outside of the kernel.</p>
</dd>
</dl>

<p>We will see sessions, process groups, and processes in action and learn how to manage
them in <a data-type="xref" href="ch06.xhtml#running-apps">Chapter 6</a>, and they’ll appear again in the context of containers
in 
<span class="keep-together"><a data-type="xref" href="ch09.xhtml#advanced">Chapter 9</a>.</span></p>

<p>Let’s see some of these concepts in action:</p>

<pre data-type="programlisting" data-code-language="sh"><code>$</code><code> </code><code>ps</code><code> </code><code>-j</code><code>
</code><code>PID</code><code>    </code><code>PGID</code><code>   </code><code>SID</code><code>   </code><code>TTY</code><code>     </code><code>TIME</code><code> </code><code>CMD</code><code>
</code><code class="m">6756</code><code>   </code><code class="m">6756</code><code>   </code><code class="m">6756</code><code>  </code><code>pts/0</code><code>   </code><code class="m">00</code><code>:00:00</code><code> </code><code>bash</code><code> </code><a class="co" id="co_the_linux_kernel_CO2-1" href="#callout_the_linux_kernel_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="m">6790</code><code>   </code><code class="m">6790</code><code>   </code><code class="m">6756</code><code>  </code><code>pts/0</code><code>   </code><code class="m">00</code><code>:00:00</code><code> </code><code>ps</code><code> </code><a class="co" id="co_the_linux_kernel_CO2-2" href="#callout_the_linux_kernel_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_the_linux_kernel_CO2-1" href="#co_the_linux_kernel_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The <code>bash</code> shell process has PID, PGID, and SID of 6756. From
<code>ls -al /proc/6756/task/6756/</code>, we can glean the task-level information.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO2-2" href="#co_the_linux_kernel_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The <code>ps</code> process has PID/PGID 6790 and the same SID as the shell.</p></dd>
</dl>

<p>We mentioned earlier on that in Linux the task data structure has some
scheduling-related information at the ready. <a data-type="indexterm" data-primary="process states" id="idm45805440910624"/>This means that at any given time a process
is in a certain state, as shown in <a data-type="xref" href="#fig-process-states">Figure 2-2</a>.</p>

<figure><div id="fig-process-states" class="figure">
<img src="Images/lmlx_0202.png" alt="lmlx 0202" width="600" height="382"/>
<h6><span class="label">Figure 2-2. </span>Linux process states</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Strictly speaking, the process states are a little more complicated; for example,
Linux distinguishes between interruptible and uninterruptible sleep, and there
is also the zombie state (in which it has lost its parent process). If you’re interested in
the details, check out the article
<a href="https://oreil.ly/XBXbU">“Process States in Linux”</a>.</p>
</div>

<p>Different events cause state transitions. For example, a running process
might transition to the waiting state when it carries out some I/O operation
(such as reading from a file) and can’t proceed with execution (off CPU).<a data-type="indexterm" data-startref="ix_ch02-asciidoc5" id="idm45805440875552"/><a data-type="indexterm" data-startref="ix_ch02-asciidoc4" id="idm45805440874944"/></p>

<p>Having taken a quick look at process management, let’s examine a
related topic: memory.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Memory Management"><div class="sect2" id="kernel-memory-management">
<h2>Memory Management</h2>

<p><a data-type="indexterm" data-primary="kernel" data-secondary="memory management" id="ix_ch02-asciidoc6"/><a data-type="indexterm" data-primary="memory management" id="ix_ch02-asciidoc7"/>Virtual memory makes your system appear as if it has more memory than it physically
has. In fact, every process gets a lot of (virtual) memory. This is how it works: both physical memory and virtual memory are divided into fixed-length chunks
we call <em>pages</em>.</p>

<p><a data-type="xref" href="#fig-virtual-memory-management">Figure 2-3</a> shows the virtual address spaces of two processes,
each with its own page table. These page tables map virtual pages of the
process into physical pages in main memory (aka RAM).</p>

<figure><div id="fig-virtual-memory-management" class="figure">
<img src="Images/lmlx_0203.png" alt="lmlx 0203" width="600" height="465"/>
<h6><span class="label">Figure 2-3. </span>Virtual memory management overview</h6>
</div></figure>

<p>Multiple virtual pages can point to the same physical page via their respective
process-level page tables. This is, in a sense, the core of  memory management:
how to effectively provide  each process with the illusion that its page actually
exists in RAM while using the existing space optimally.</p>

<p>Every time the CPU accesses a process’s virtual page, the CPU would in principle
have to translate the virtual address a process uses to the corresponding physical address.
<a data-type="indexterm" data-primary="TLB (translation lookaside buffer)" id="idm45805440866208"/><a data-type="indexterm" data-primary="translation lookaside buffer (TLB)" id="idm45805440865600"/>To speed up this process—which can be multilevel and hence slow—modern CPU architectures
support a lookup on-chip called <a href="https://oreil.ly/y3xy0">translation lookaside buffer
(TLB)</a>. The TLB is effectively a small cache that, in case of a miss, causes the
CPU to go  via the process page table(s) to calculate the physical address of a page
and update the TLB with it.</p>

<p>Traditionally, Linux had a default page size of 4 KB, but since kernel v2.6.3,
it supports <a href="https://oreil.ly/7rqLO">huge pages</a>, to better support
modern architectures and workloads. For example, 64-bit Linux allows you to use
up to 128 TB of virtual address space (with virtual being the theoretical
addressable number of memory addresses) per process, with an approximate 64 TB
of physical memory (with physical being the amount of RAM you have in your
machine) in total.</p>

<p>OK, that was a lot of theoretical information. Let’s have
a look at it from a more practical point of view. A very useful tool to figure
out memory-related information such as how much RAM is available to you is the
<em>/proc/meminfo</em> interface:</p>

<pre data-type="programlisting" data-code-language="sh"><code>$</code><code> </code><code>grep</code><code> </code><code>MemTotal</code><code> </code><code>/proc/meminfo</code><code> </code><a class="co" id="co_the_linux_kernel_CO3-1" href="#callout_the_linux_kernel_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>MemTotal:</code><code>        </code><code class="m">4014636</code><code> </code><code>kB</code><code>

</code><code>$</code><code> </code><code>grep</code><code> </code><code>VmallocTotal</code><code> </code><code>/proc/meminfo</code><code> </code><a class="co" id="co_the_linux_kernel_CO3-2" href="#callout_the_linux_kernel_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>VmallocTotal:</code><code>   </code><code class="m">34359738367</code><code> </code><code>kB</code><code>

</code><code>$</code><code> </code><code>grep</code><code> </code><code>Huge</code><code> </code><code>/proc/meminfo</code><code> </code><a class="co" id="co_the_linux_kernel_CO3-3" href="#callout_the_linux_kernel_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>AnonHugePages:</code><code>         </code><code class="m">0</code><code> </code><code>kB</code><code>
</code><code>ShmemHugePages:</code><code>        </code><code class="m">0</code><code> </code><code>kB</code><code>
</code><code>FileHugePages:</code><code>         </code><code class="m">0</code><code> </code><code>kB</code><code>
</code><code>HugePages_Total:</code><code>       </code><code class="m">0</code><code>
</code><code>HugePages_Free:</code><code>        </code><code class="m">0</code><code>
</code><code>HugePages_Rsvd:</code><code>        </code><code class="m">0</code><code>
</code><code>HugePages_Surp:</code><code>        </code><code class="m">0</code><code>
</code><code>Hugepagesize:</code><code>       </code><code class="m">2048</code><code> </code><code>kB</code><code>
</code><code>Hugetlb:</code><code>               </code><code class="m">0</code><code> </code><code>kB</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_the_linux_kernel_CO3-1" href="#co_the_linux_kernel_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>List details on physical memory (RAM); that’s 4 GB there.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO3-2" href="#co_the_linux_kernel_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>List details on virtual memory; that’s a bit more than 34 TB there.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO3-3" href="#co_the_linux_kernel_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>List huge pages information; apparently here the page size is 2 MB.</p></dd>
</dl>

<p>With<a data-type="indexterm" data-startref="ix_ch02-asciidoc7" id="idm45805440809232"/><a data-type="indexterm" data-startref="ix_ch02-asciidoc6" id="idm45805440808496"/> that, we move on to the next kernel function: networking.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Networking"><div class="sect2" id="kernel-networking">
<h2>Networking</h2>

<p><a data-type="indexterm" data-primary="kernel" data-secondary="networking functionality" id="idm45805440769408"/><a data-type="indexterm" data-primary="networking" data-secondary="kernel and" id="idm45805440768560"/>One important function of the kernel is to provide networking functionality.
Whether you want to browse the web or copy data to a
remote system, you depend on the network.</p>

<p>The Linux network stack follows a layered architecture:</p>
<dl>
<dt>Sockets</dt>
<dd>
<p>For abstracting communication</p>
</dd>
<dt>Transmission Control Protocol (TCP) and User Datagram Protocol (UDP)</dt>
<dd>
<p>For connection-oriented communication and connectionless communication, respectively</p>
</dd>
<dt>Internet Protocol (IP)</dt>
<dd>
<p>For addressing machines</p>
</dd>
</dl>

<p>These three actions are all that the kernel takes care of. The application layer
protocols such as HTTP or SSH are, usually, implemented in user land.</p>

<p>You can get an overview of your network interfaces using (output edited):</p>

<pre data-type="programlisting" data-code-language="sh">$ ip link
<code class="m">1</code>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <code class="m">65536</code> qdisc noqueue state UNKNOWN mode
   DEFAULT group default qlen <code class="m">1000</code> link/loopback <code class="m">00</code>:00:00:00:00:00
   brd <code class="m">00</code>:00:00:00:00:00
<code class="m">2</code>: enp0s1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <code class="m">1500</code> qdisc fq_codel state
   UP mode DEFAULT group default qlen <code class="m">1000</code> link/ether <code class="m">52</code>:54:00:12:34:56
   brd ff:ff:ff:ff:ff:ff</pre>

<p>Further, <code>ip route</code> provides you with routing information. Since we have a dedicated
networking chapter (<a data-type="xref" href="ch07.xhtml#networking">Chapter 7</a>) where we will dive deep into the networking stack,
the supported protocols, and typical  operations, we keep it at this and move on to
the next kernel component, block devices and filesystems.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Filesystems"><div class="sect2" id="kernel-filesystems">
<h2>Filesystems</h2>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="kernel and" id="idm45805440749696"/>Linux uses filesystems to organize files and directories on storage devices
such as hard disk drives (HDDs) and solid-state drives (SSDs) or flash memory.
There are many types of filesystems, such as <code>ext4</code> and <code>btrfs</code> or NTFS,
and you can have multiple instances of the same filesystem in use.</p>

<p><a data-type="indexterm" data-primary="Virtual File System (VFS)" id="idm45805440747472"/>Virtual File System (VFS) was originally introduced to support multiple
filesystem types and instances. The highest layer in VFS provides a common API
abstraction of functions such as open, close, read, and write.
At the bottom of VFS are filesystem abstractions called <em>plug-ins</em> for the given
filesystem.</p>

<p>We will go into greater detail on filesystems and file operations in
<a data-type="xref" href="ch05.xhtml#files">Chapter 5</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Device Drivers"><div class="sect2" id="kernel-drivers">
<h2>Device Drivers</h2>

<p><a data-type="indexterm" data-primary="device drivers" id="idm45805440720368"/><a data-type="indexterm" data-primary="drivers" id="idm45805440719760"/><a data-type="indexterm" data-primary="kernel" data-secondary="device drivers" id="idm45805440719152"/>A <em>driver</em> is a bit of code that runs in the kernel. Its job is to manage a device,
which can be actual hardware—like a keyboard, a mouse, or hard disk drives—or
it can be a pseudo-device such as a pseudo-terminal under <em>/dev/pts/</em> (which is
not a physical device but can be treated like one).</p>

<p><a data-type="indexterm" data-primary="graphics processing units (GPUs)" id="idm45805440717152"/>Another interesting class of hardware are
<a href="https://oreil.ly/os7pu"><em>graphics processing units</em>
(GPUs)</a>, which traditionally were used to accelerate graphics output and ease the load on the CPU. In recent years, GPUs have found a new use case
in the context of <a href="https://oreil.ly/qrVcY">machine learning</a>, and
hence they are not exclusively relevant in desktop environments.</p>

<p>The driver may be built statically into the kernel, or it
can be built as a kernel module (see <a data-type="xref" href="#kernel-modules">“Modules”</a>) so that it can be
dynamically loaded when needed.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you’re interested in an interactive way to explore device drivers
and how kernel components interact, check out the
<a href="https://oreil.ly/voBtR">Linux kernel map</a>.</p>
</div>

<p>The kernel <a href="https://oreil.ly/Cb6mw">driver model</a>
is complicated and out of scope for this book. However, following are a few hints for interacting with it, just enough so that you know where to
find what.</p>

<p>To get an overview of the devices on your Linux system, you can use the following:</p>

<pre data-type="programlisting" data-code-language="sh">$ ls -al /sys/devices/
total <code class="m">0</code>
drwxr-xr-x <code class="m">15</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 .
dr-xr-xr-x <code class="m">13</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 ..
drwxr-xr-x  <code class="m">6</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 LNXSYSTM:00
drwxr-xr-x  <code class="m">3</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 breakpoint
drwxr-xr-x  <code class="m">3</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">17</code>:41 isa
drwxr-xr-x  <code class="m">4</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 kprobe
drwxr-xr-x  <code class="m">5</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 msr
drwxr-xr-x <code class="m">15</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 pci0000:00
drwxr-xr-x <code class="m">14</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 platform
drwxr-xr-x  <code class="m">8</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 pnp0
drwxr-xr-x  <code class="m">3</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 software
drwxr-xr-x <code class="m">10</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 system
drwxr-xr-x  <code class="m">3</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 tracepoint
drwxr-xr-x  <code class="m">4</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 uprobe
drwxr-xr-x <code class="m">18</code> root root <code class="m">0</code> Aug <code class="m">17</code> <code class="m">15</code>:53 virtual</pre>

<p>Further, you can use the following to list mounted devices:</p>

<pre data-type="programlisting" data-code-language="sh">$ mount
sysfs on /sys <code class="nb">type</code> sysfs <code class="o">(</code>rw,nosuid,nodev,noexec,relatime<code class="o">)</code>
proc on /proc <code class="nb">type</code> proc <code class="o">(</code>rw,nosuid,nodev,noexec,relatime<code class="o">)</code>
devpts on /dev/pts <code class="nb">type</code> devpts <code class="o">(</code>rw,nosuid,noexec,relatime,gid<code class="o">=</code><code class="m">5</code>,mode<code class="o">=</code><code class="m">620</code>, <code class="se">\</code>
<code class="nv">ptmxmode</code><code class="o">=</code><code class="m">000</code><code class="o">)</code>
...
tmpfs on /run/snapd/ns <code class="nb">type</code> tmpfs <code class="o">(</code>rw,nosuid,nodev,noexec,relatime,<code class="se">\</code>
<code class="nv">size</code><code class="o">=</code>401464k,mode<code class="o">=</code><code class="m">755</code>,inode64<code class="o">)</code>
nsfs on /run/snapd/ns/lxd.mnt <code class="nb">type</code> nsfs <code class="o">(</code>rw<code class="o">)</code></pre>

<p>With this, we have covered the Linux kernel components and move to the
interface between the kernel and user land.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="syscalls"><div class="sect2" id="kernel-syscalls">
<h2>syscalls</h2>

<p><a data-type="indexterm" data-primary="kernel" data-secondary="syscalls" id="ix_ch02-asciidoc8"/><a data-type="indexterm" data-primary="system calls (syscalls)" id="ix_ch02-asciidoc9"/>Whether you sit in front of a terminal and type <code>touch test.txt</code> or
whether one of your apps wants to download the content of a file from a
remote system, at the end of the day you ask Linux to turn the high-level instruction,
such as “create a file” or “read all bytes from address so and so,” into a
set of concrete, architecture-dependent steps. In other words, the service
interface the kernel exposes and that user land entities call is the set
of system calls, or <a href="https://oreil.ly/UF09U">syscalls</a>
for short.</p>

<p>Linux has hundreds of syscalls: around three hundred or more, depending on the CPU family.
However, you and your programs don’t usually invoke these syscalls directly but
via what we call the <em>C standard library</em>. The standard library provides wrapper
functions and is available in various implementations, such as
<a href="https://oreil.ly/mZPRy">glibc</a> or <a href="https://oreil.ly/jnTCA">musl</a>.</p>

<p>These wrapper libraries perform an important task. They take care
of the repetitive low-level handling of the execution of a syscall. System
calls are implemented as software interrupts, causing an exception that
transfers the control to an exception handler. There are a number of steps to
take care of every time a syscall is invoked, as depicted in
<a data-type="xref" href="#fig-syscall-seq">Figure 2-4</a>:</p>

<figure><div id="fig-syscall-seq" class="figure">
<img src="Images/lmlx_0204.png" alt="lmlx 0204" width="600" height="443"/>
<h6><span class="label">Figure 2-4. </span>syscall execution steps in Linux</h6>
</div></figure>
<ol>
<li>
<p>Defined in <em>syscall.h</em> and architecture-dependent files, the kernel uses
a so-called <em>syscall table</em>, effectively an array of function pointers in memory
(stored in a variable called <code>sys_call_table</code>) to keep track of syscalls
and their corresponding handlers.</p>
</li>
<li>
<p>With the <code>system_call()</code> function acting like a syscall multiplexer,
it first saves the hardware context on the stack, then performs checks (like
if tracing is performed), and then jumps to the function pointed to by the
respective syscall number index in the <code>sys_call_table</code>.</p>
</li>
<li>
<p>After the syscall is completed with <code>sysexit</code>, the wrapper library restores the
hardware context, and the program execution resumes in user land.</p>
</li>

</ol>

<p>Notable in the previous steps is the switching between kernel mode and user
land mode, an operation that costs time.</p>

<p>OK, that was a little dry and theoretical, so to better appreciate how syscalls
look and feel in practice, let’s have a look at a concrete example. We will
use <a href="https://oreil.ly/ksV9B"><code>strace</code></a> to look behind the curtain, a tool
useful for troubleshooting, for example, if you don’t have the source code
of an app but want to learn what it does.</p>

<p>Let’s assume you wonder what syscalls are involved when you execute the
innocent-looking <code>ls</code> command. Here’s how you can find it out using <code>strace</code>:</p>

<pre data-type="programlisting" data-code-language="sh"><code>$</code><code> </code><code>strace</code><code> </code><code>ls</code><code> </code><a class="co" id="co_the_linux_kernel_CO4-1" href="#callout_the_linux_kernel_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>execve</code><code class="o">(</code><code class="s2">"/usr/bin/ls"</code><code>,</code><code> </code><code class="o">[</code><code class="s2">"ls"</code><code class="o">]</code><code>,</code><code> </code><code>0x7ffe29254910</code><code> </code><code>/*</code><code> </code><code class="m">24</code><code> </code><code>vars</code><code> </code><code>*/</code><code class="o">)</code><code> </code><code class="o">=</code><code> </code><code class="m">0</code><code> </code><a class="co" id="co_the_linux_kernel_CO4-2" href="#callout_the_linux_kernel_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>brk</code><code class="o">(</code><code>NULL</code><code class="o">)</code><code>                           </code><code class="o">=</code><code> </code><code>0x5596e5a3c000</code><code> </code><a class="co" id="co_the_linux_kernel_CO4-3" href="#callout_the_linux_kernel_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>...</code><code>
</code><code>access</code><code class="o">(</code><code class="s2">"/etc/ld.so.preload"</code><code>,</code><code> </code><code>R_OK</code><code class="o">)</code><code>  </code><code class="o">=</code><code> </code><code>-1</code><code> </code><code>ENOENT</code><code> </code><code class="o">(</code><code>No</code><code> </code><code>such</code><code> </code><code>file</code><code> </code><code>or</code><code> </code><code>directory</code><code class="o">)</code><code> </code><a class="co" id="co_the_linux_kernel_CO4-4" href="#callout_the_linux_kernel_CO4-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>openat</code><code class="o">(</code><code>AT_FDCWD,</code><code> </code><code class="s2">"/etc/ld.so.cache"</code><code>,</code><code> </code><code>O_RDONLY</code><code class="p">|</code><code>O_CLOEXEC</code><code class="o">)</code><code> </code><code class="o">=</code><code> </code><code class="m">3</code><code> </code><a class="co" id="co_the_linux_kernel_CO4-5" href="#callout_the_linux_kernel_CO4-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>
</code><code>...</code><code>
</code><code>read</code><code class="o">(</code><code class="m">3</code><code>,</code><code> </code><code class="s2">"\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0 p\0\0\0\0\0\0"</code><code>...,</code><code> </code><code class="se">\
</code><code class="m">832</code><code class="o">)</code><code> </code><code class="o">=</code><code> </code><code class="m">832</code><code> </code><a class="co" id="co_the_linux_kernel_CO4-6" href="#callout_the_linux_kernel_CO4-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a><code>
</code><code>...</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_the_linux_kernel_CO4-1" href="#co_the_linux_kernel_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>With <code>strace ls</code>, we ask <code>strace</code> to capture the syscall that <code>ls</code> uses. Note
that I edited the output since <code>strace</code> generates some 162 lines on my
system (this number varies between different distros, architectures, and
other factors). Further, the output you see there comes via <code>stderr</code>, so if
you want to redirect it, you have to use <code>2&gt;</code> here. You’ll learn more about this in <a data-type="xref" href="ch03.xhtml#shells-scripting">Chapter 3</a>.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO4-2" href="#co_the_linux_kernel_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The syscall <a href="https://oreil.ly/iasHW"><code>execve</code></a>
executes <em>/usr/bin/ls</em>, causing the shell process to be replaced.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO4-3" href="#co_the_linux_kernel_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The <a href="https://oreil.ly/HRuNj"><code>brk</code></a> syscall
is an outdated way to allocate memory; it’s safer and more portable to
use <code>malloc</code>. Note that <code>malloc</code> is not a syscall but a function that in
turn uses <code>mallocopt</code> to decide if it needs to use the <code>brk</code> syscall or
the <code>mmap</code> syscall based on the amount of memory accessed.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO4-4" href="#co_the_linux_kernel_CO4-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The <code>access</code> syscall checks if the process is allowed to access a certain
file.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO4-5" href="#co_the_linux_kernel_CO4-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Syscall <code>openat</code> opens the file <em>/etc/ld.so.cache</em> relative to a directory
file descriptor (here the first argument, <code>AT_FDCWD</code>, which stands for the
current directory) and using flags <code>O_RDONLY|O_CLOEXEC</code> (last argument).</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO4-6" href="#co_the_linux_kernel_CO4-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p>The <code>read</code> syscall reads from a file descriptor (first argument, <code>3</code>)
832 bytes (last argument) into a buffer (second argument).</p></dd>
</dl>

<p><code>strace</code> is useful to see exactly what syscalls have been called—in which order
and with which arguments—effectively hooking into the live stream of events between
user land and kernel. It’s also good for performance diagnostics. Let’s see
where a <code>curl</code> command spends most of its time (output shortened):</p>

<pre data-type="programlisting" data-code-language="sh"><code>$</code><code> </code><code>strace</code><code> </code><code>-c</code><code> </code><code class="se">\ </code><a class="co" id="co_the_linux_kernel_CO5-1" href="#callout_the_linux_kernel_CO5-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
         </code><code>curl</code><code> </code><code>-s</code><code> </code><code>https://mhausenblas.info</code><code> </code><code>&gt;</code><code> </code><code>/dev/null</code><code> </code><a class="co" id="co_the_linux_kernel_CO5-2" href="#callout_the_linux_kernel_CO5-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>%</code><code> </code><code class="nb">time</code><code>     </code><code>seconds</code><code>  </code><code>usecs/call</code><code>     </code><code>calls</code><code>    </code><code>errors</code><code> </code><code>syscall</code><code>
</code><code>------</code><code> </code><code>-----------</code><code> </code><code>-----------</code><code> </code><code>---------</code><code> </code><code>---------</code><code> </code><code>----------------</code><code>
 </code><code class="m">26</code><code>.75</code><code>    </code><code class="m">0</code><code>.031965</code><code>         </code><code class="m">148</code><code>       </code><code class="m">215</code><code>           </code><code>mmap</code><code>
 </code><code class="m">17</code><code>.52</code><code>    </code><code class="m">0</code><code>.020935</code><code>         </code><code class="m">136</code><code>       </code><code class="m">153</code><code>         </code><code class="m">3</code><code> </code><code class="nb">read</code><code>
 </code><code class="m">10</code><code>.15</code><code>    </code><code class="m">0</code><code>.012124</code><code>         </code><code class="m">175</code><code>        </code><code class="m">69</code><code>           </code><code>rt_sigaction</code><code>
  </code><code class="m">8</code><code>.00</code><code>    </code><code class="m">0</code><code>.009561</code><code>         </code><code class="m">147</code><code>        </code><code class="m">65</code><code>         </code><code class="m">1</code><code> </code><code>openat</code><code>
  </code><code class="m">7</code><code>.61</code><code>    </code><code class="m">0</code><code>.009098</code><code>         </code><code class="m">126</code><code>        </code><code class="m">72</code><code>           </code><code>close</code><code>
  </code><code>...</code><code>
  </code><code class="m">0</code><code>.00</code><code>    </code><code class="m">0</code><code>.000000</code><code>           </code><code class="m">0</code><code>         </code><code class="m">1</code><code>           </code><code>prlimit64</code><code>
</code><code>------</code><code> </code><code>-----------</code><code> </code><code>-----------</code><code> </code><code>---------</code><code> </code><code>---------</code><code> </code><code>----------------</code><code>
</code><code class="m">100</code><code>.00</code><code>    </code><code class="m">0</code><code>.119476</code><code>         </code><code class="m">141</code><code>       </code><code class="m">843</code><code>        </code><code class="m">11</code><code> </code><code>total</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_the_linux_kernel_CO5-1" href="#co_the_linux_kernel_CO5-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Use the <code>-c</code> option to generate overview stats of the syscalls used.</p></dd>
<dt><a class="co" id="callout_the_linux_kernel_CO5-2" href="#co_the_linux_kernel_CO5-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Discard all output of <code>curl</code>.</p></dd>
</dl>

<p>Interestingly, the <code>curl</code> command here spends almost half of its time with
<code>mmap</code> and <code>read</code> syscalls, and the <code>connect</code> syscall takes 0.3 ms—not bad.</p>

<p>To help you get a feeling for the coverage, I’ve put together <a data-type="xref" href="#table-sycalls-examples">Table 2-1</a>,
which lists examples of widely used syscalls across kernel components as
well as system-wide ones. You can look up details of syscalls, including
their parameters and return values, via
<a href="https://oreil.ly/qLOA3">section 2 of the man
pages</a>.</p>
<table id="table-sycalls-examples">
<caption><span class="label">Table 2-1. </span>Example syscalls</caption>
<thead>
<tr>
<th>Category</th>
<th>Example syscalls</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Process management</p></td>
<td><p><code>clone</code>, <code>fork</code>, <code>execve</code>, <code>wait</code>, <code>exit</code>, <code>getpid</code>,
<code>setuid</code>, <code>setns</code>, <code>getrusage</code>, <code>capset</code>, <code>ptrace</code></p></td>
</tr>
<tr>
<td><p>Memory management</p></td>
<td><p><code>brk</code>, <code>mmap</code>, <code>munmap</code>, <code>mremap</code>, <code>mlock</code>, <code>mincore</code></p></td>
</tr>
<tr>
<td><p>Networking</p></td>
<td><p><code>socket</code>, <code>setsockopt</code>, <code>getsockopt</code>, <code>bind</code>, <code>listen</code>, <code>accept</code>,
<code>connect</code>, <code>shutdown</code>, <code>recvfrom</code>, <code>recvmsg</code>, <code>sendto</code>, <code>sethostname</code>, <code>bpf</code></p></td>
</tr>
<tr>
<td><p>Filesystems</p></td>
<td><p><code>open</code>, <code>openat</code>, <code>close</code>, <code>mknod</code>, <code>rename</code>, <code>truncate</code>, <code>mkdir</code>,
<code>rmdir</code>, <code>getcwd</code>, <code>chdir</code>, <code>chroot</code>, <code>getdents</code>, <code>link</code>, <code>symlink</code>, <code>unlink</code>,
<code>umask</code>, <code>stat</code>, <code>chmod</code>, <code>utime</code>, <code>access</code>, <code>ioctl</code>, <code>flock</code>, <code>read</code>, <code>write</code>,
<code>lseek</code>, <code>sync</code>, <code>select</code>, <code>poll</code>, <code>mount</code>,</p></td>
</tr>
<tr>
<td><p>Time</p></td>
<td><p><code>time</code>, <code>clock_settime</code>, <code>timer_create</code>, <code>alarm</code>, <code>nanosleep</code></p></td>
</tr>
<tr>
<td><p>Signals</p></td>
<td><p><code>kill</code>, <code>pause</code>, <code>signalfd</code>, <code>eventfd</code>,</p></td>
</tr>
<tr>
<td><p>Global</p></td>
<td><p><code>uname</code>, <code>sysinfo</code>, <code>syslog</code>, <code>acct</code>, <code>_sysctl</code>, <code>iopl</code>, <code>reboot</code></p></td>
</tr>
</tbody>
</table>
<div data-type="tip"><h6>Tip</h6>
<p>There is a nice interactive <a href="https://oreil.ly/HKu6Y">syscall table</a>
available online with source code references<a data-type="indexterm" data-startref="ix_ch02-asciidoc9" id="idm45805440185088"/><a data-type="indexterm" data-startref="ix_ch02-asciidoc8" id="idm45805440184384"/>.<a data-type="indexterm" data-startref="ix_ch02-asciidoc3" id="idm45805440183584"/></p>
</div>

<p>Now that you have a basic idea of the Linux kernel, its main
components, and interface, let’s move on to the question of how to extend it.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Kernel Extensions"><div class="sect1" id="kernel-extension">
<h1>Kernel Extensions</h1>

<p><a data-type="indexterm" data-primary="kernel" data-secondary="extensions" id="ix_ch02-asciidoc10"/>In this section, we will focus on how to extend the kernel. In a sense, the
content here is advanced and optional. You won’t need it for your
day-to-day work, in general.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Configuring and compiling your own Linux kernel is out of scope for
this book. For information on how to do it, I recommend <a class="orm:hideurl" href="https://oreil.ly/jzFCj"><em>Linux Kernel in a Nutshell</em></a> (O’Reilly)
by Greg Kroah-Hartman, one of the main  Linux maintainers and project lead.
He covers the entire range of tasks, from downloading the source code to
configuration and installation steps, to kernel options at runtime.</p>
</div>

<p>Let’s start with something easy: how do you know what kernel version you’re using?
You can use the following command to determine this:</p>

<pre data-type="programlisting" data-code-language="sh"><code>$</code><code> </code><code>uname</code><code> </code><code>-srm</code><code>
</code><code>Linux</code><code> </code><code class="m">5</code><code>.11.0-25-generic</code><code> </code><code>x86_64</code><code> </code><a class="co" id="co_the_linux_kernel_CO6-1" href="#callout_the_linux_kernel_CO6-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_the_linux_kernel_CO6-1" href="#co_the_linux_kernel_CO6-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>From the <code>uname</code> output here, you can tell that at the time of writing,
I’m using a <a href="https://oreil.ly/FJdA1">5.11 kernel</a>
on an <code>x86_64</code> machine (see also <a data-type="xref" href="#cpu-arch-x86">“x86 Architecture”</a>).</p></dd>
</dl>

<p>Now that we know the kernel version, we can address the question of how to extend the
kernel out-of-tree—that is, without having to add features to the kernel source
code and then build it. For this extension we can use modules, so let’s
have a look at that.</p>








<section data-type="sect2" data-pdf-bookmark="Modules"><div class="sect2" id="kernel-modules">
<h2>Modules</h2>

<p><a data-type="indexterm" data-primary="kernel" data-secondary="modules" id="idm45805440160144"/><a data-type="indexterm" data-primary="module, kernel and" id="idm45805440138656"/>In a nutshell, a <em>module</em> is a program that you can load into a kernel on demand.
That is, you do not necessarily have to recompile the kernel and/or reboot the
machine. Nowadays, Linux detects most of the hardware automatically, and with it
Linux loads its modules automatically. But there are cases where you want to
manually load a module. Consider the following case: the kernel detects a video
card and loads a generic module. However, the video card manufacturer offers a better
third-party module (not available in the Linux kernel) that you may choose to
use instead.</p>

<p>To list available modules, run the following command (output has been edited down, as there
are over one thousand lines on my system):</p>

<pre data-type="programlisting" data-code-language="sh">$ find /lib/modules/<code class="k">$(</code>uname -r<code class="k">)</code> -type f -name <code class="s1">'*.ko*'</code>
/lib/modules/5.11.0-25-generic/kernel/ubuntu/ubuntu-host/ubuntu-host.ko
/lib/modules/5.11.0-25-generic/kernel/fs/nls/nls_iso8859-1.ko
/lib/modules/5.11.0-25-generic/kernel/fs/ceph/ceph.ko
/lib/modules/5.11.0-25-generic/kernel/fs/nfsd/nfsd.ko
...
/lib/modules/5.11.0-25-generic/kernel/net/ipv6/esp6.ko
/lib/modules/5.11.0-25-generic/kernel/net/ipv6/ip6_vti.ko
/lib/modules/5.11.0-25-generic/kernel/net/sctp/sctp_diag.ko
/lib/modules/5.11.0-25-generic/kernel/net/sctp/sctp.ko
/lib/modules/5.11.0-25-generic/kernel/net/netrom/netrom.ko</pre>

<p>That’s great! But which modules did the kernel actually load? Let’s take a look
(output shortened):</p>

<pre data-type="programlisting" data-code-language="sh">$ lsmod
Module                  Size  Used by
...
linear                 <code class="m">20480</code>  <code class="m">0</code>
crct10dif_pclmul       <code class="m">16384</code>  <code class="m">1</code>
crc32_pclmul           <code class="m">16384</code>  <code class="m">0</code>
ghash_clmulni_intel    <code class="m">16384</code>  <code class="m">0</code>
virtio_net             <code class="m">57344</code>  <code class="m">0</code>
net_failover           <code class="m">20480</code>  <code class="m">1</code> virtio_net
ahci                   <code class="m">40960</code>  <code class="m">0</code>
aesni_intel           <code class="m">372736</code>  <code class="m">0</code>
crypto_simd            <code class="m">16384</code>  <code class="m">1</code> aesni_intel
cryptd                 <code class="m">24576</code>  <code class="m">2</code> crypto_simd,ghash_clmulni_intel
glue_helper            <code class="m">16384</code>  <code class="m">1</code> aesni_intel</pre>

<p>Note that the preceding information is available via <em>/proc/modules</em>. This is thanks to
the kernel exposing this information via a pseudo-filesystem interface;
more on this topic is presented in <a data-type="xref" href="ch06.xhtml#running-apps">Chapter 6</a>.</p>

<p>Want to learn more about a module or have a nice way to manipulate kernel
modules? Then <code>modprobe</code> is your friend. For example, to list the dependencies:</p>

<pre data-type="programlisting" data-code-language="sh">$ modprobe --show-depends async_memcpy
insmod /lib/modules/5.11.0-25-generic/kernel/crypto/async_tx/async_tx.ko
insmod /lib/modules/5.11.0-25-generic/kernel/crypto/async_tx/async_memcpy.ko</pre>

<p>Next up: an alternative, modern way to extend the kernel.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="A Modern Way to Extend the Kernel: eBPF"><div class="sect2" id="ebpf">
<h2>A Modern Way to Extend the Kernel: eBPF</h2>

<p><a data-type="indexterm" data-primary="eBPF" id="idm45805440078720"/><a data-type="indexterm" data-primary="kernel" data-secondary="eBPF and" id="idm45805440078112"/>An increasingly popular way to extend kernel functionality is eBPF. Originally
known as <em>Berkeley Packet Filter</em> (BPF), nowadays the kernel project and technology
is commonly known as <em>eBPF</em> (a term that does not stand for anything).</p>

<p>Technically, eBPF is a feature of the Linux kernel, and you’ll need the Linux kernel
version 3.15 or above to benefit from it. It enables you to safely and efficiently extend
the Linux kernel functions by using the <a href="https://oreil.ly/cltxg"><code>bpf</code></a>
syscall. eBPF is implemented as an in-kernel virtual machine using a custom 64-bit
RISC instruction set.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you want to learn more about what is enabled in which kernel version for eBPF,
you can use the <a href="https://oreil.ly/HtKO8">iovisor/bcc
docs on GitHub</a>.</p>
</div>

<p>In <a data-type="xref" href="#fig-bpf-overview">Figure 2-5</a> you see a high-level overview taken from Brendan Gregg’s book
<a href="https://oreil.ly/sfYKK"><em>BPF Performance Tools: Linux System and Application Observability</em></a> (Addison Wesley).</p>

<figure><div id="fig-bpf-overview" class="figure">
<img src="Images/lmlx_0205.png" alt="lmlx 0205" width="600" height="204"/>
<h6><span class="label">Figure 2-5. </span>eBPF overview in the Linux kernel</h6>
</div></figure>

<p>eBPF is already used in a number of places and for use cases such as the following:</p>
<dl>
<dt>As a CNI plug-in to enable pod networking in Kubernetes</dt>
<dd>
<p>For example, in
 <a href="https://oreil.ly/BS0iz">Cilium</a> and Project Calico. Also,
 for service scalability.</p>
</dd>
<dt>For observability</dt>
<dd>
<p>For Linux kernel tracing, such as with
  <a href="https://oreil.ly/0M0oV">iovisor/bpftrace</a>, as well as in a clustered
  setup with <a href="https://oreil.ly/7yzhq">Hubble</a> (see <a data-type="xref" href="ch08.xhtml#observability">Chapter 8</a>).</p>
</dd>
<dt>As a security control</dt>
<dd>
<p>For example, to perform container runtime scanning as
  you can use with projects such as <a href="https://falco.org">CNCF Falco</a>.</p>
</dd>
<dt>For network load balancing</dt>
<dd>
<p>Such as in Facebook’s L4 <a href="https://oreil.ly/HqMZg">katran</a>
  library.</p>
</dd>
</dl>

<p>In mid-2021, the Linux Foundation announced that Facebook, Google, Isovalent,
Microsoft, and Netflix joined together to
<a href="https://oreil.ly/g2buM">create the eBPF Foundation</a>,
and with it giving the eBPF project a vendor-neutral home. Stay tuned!</p>

<p>If you want to stay on top of things, have a look at <a class="orm:hideurl" href="https://ebpf.io/"><em>ebpf.io</em></a>.<a data-type="indexterm" data-startref="ix_ch02-asciidoc10" id="idm45805440011936"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45805440011104">
<h1>Conclusion</h1>

<p>The Linux kernel is the core of the Linux operating system, and no matter
what distribution or environment you are using
Linux in—be it on your desktop or in the cloud—you should have a basic idea
of its components and functionality.</p>

<p>In this chapter, we reviewed the overall Linux architecture, the role of the
kernel, and its interfaces. Most importantly, the kernel abstracts
away the differences of the hardware—CPU architectures and peripheral devices—and
makes Linux very portable. The most important interface is the syscall
interface, through which the kernel exposes its functionality—be it opening a
file, allocating memory, or listing network 
<span class="keep-together">interfaces.</span></p>

<p>We have also looked a bit at the inner workings of the kernel, including modules and
eBPF. If you want to extend the kernel functionality or implement performant
tasks in the kernel (controlled from the user space), then eBPF is definitely worth
taking a closer look at.</p>

<p>If you want to learn more about certain aspects of the kernel, the following resources
should provide you with some starting points:</p>
<dl>
<dt>General</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/HCLmX"><em>The Linux Programming Interface</em></a> by Michael Kerrisk (No Starch Press).</p>
</li>
<li>
<p><a href="https://oreil.ly/lMzbW">Linux Kernel Teaching</a>
provides a nice introduction with deep dives across the board.</p>
</li>
<li>
<p><a href="https://oreil.ly/it2jK">“Anatomy of the Linux Kernel”</a> gives
a quick high-level intro.</p>
</li>
<li>
<p><a href="https://oreil.ly/9d93Y">“Operating System Kernels”</a>
has a nice overview and comparison of kernel design approaches.</p>
</li>
<li>
<p><a href="https://oreil.ly/OSfbA">KernelNewbies</a> is a great resource if you want to
dive deeper into hands-on topics.</p>
</li>
<li>
<p><a href="https://oreil.ly/kSov7">kernelstats</a> shows some interesting
distributions over time.</p>
</li>
<li>
<p><a href="https://oreil.ly/G55tF">The Linux Kernel Map</a> is a
visual representation of kernel components and dependencies.</p>
</li>
</ul>
</dd>
<dt>Memory management</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/uKjtQ"><em>Understanding the Linux Virtual Memory Manager</em></a></p>
</li>
<li>
<p><a href="https://oreil.ly/dBLkt">“The Slab Allocator in the Linux Kernel”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/sTBhM">Kernel docs</a></p>
</li>
</ul>
</dd>
<dt>Device drivers</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/Kn7CZ"><em>Linux Device Drivers</em></a> by Jonathan Corbet</p>
</li>
<li>
<p><a href="https://oreil.ly/a0chO">“How to Install a Device Driver on Linux”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/EGXIh">Character Device Drivers</a></p>
</li>
<li>
<p><a href="https://oreil.ly/jkiwB"><em>Linux Device Drivers: Tutorial for Linux Driver Development</em></a></p>
</li>
</ul>
</dd>
<dt>syscalls</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/yCdTi">“Linux Interrupts: The Basic Concepts”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/A3XMT">The Linux Kernel: System Calls</a></p>
</li>
<li>
<p><a href="https://oreil.ly/mezjr">Linux System Call Table</a></p>
</li>
<li>
<p><a href="https://oreil.ly/tf6CW"><em>syscalls.h</em> source code</a></p>
</li>
<li>
<p><a href="https://oreil.ly/K7Zid">syscall lookup for x86 and x86_64</a></p>
</li>
</ul>
</dd>
<dt>eBPF</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/Afdsx">“Introduction to eBPF”</a> by Matt Oswalt</p>
</li>
<li>
<p><a href="https://oreil.ly/Fnj5t">eBPF maps documentation</a></p>
</li>
</ul>
</dd>
</dl>

<p>Equipped with this knowledge, we’re now ready to climb up the abstraction ladder
a bit and move to the primary user interface we consider in this book: the shell,
both in manual usage as well as automation through scripts.<a data-type="indexterm" data-startref="ix_ch02-asciidoc0" id="idm45805439970112"/></p>
</div></section>







</div></section></div></body></html>