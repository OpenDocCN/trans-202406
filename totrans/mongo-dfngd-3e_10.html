<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Transactions"><div class="chapter" id="chapter-transactions"><h1><span class="label">Chapter 8. </span>Transactions</h1><p>Transactions<a data-type="indexterm" data-primary="transactions" data-secondary="defined" id="idm45882358639160"/> are logical groups of processing in a database, and each
  group or transaction can contain one or more operations such as reads and/or
  writes across multiple documents. MongoDB supports ACID-compliant
  transactions across multiple operations, collections, databases, documents,
  and shards. In this chapter, we introduce transactions, define what ACID
  means for a database, highlight how you use these in your applications, and
  provide tips for tuning transactions in MongoDB. We will cover:</p><ul><li><p>What a transaction is</p></li><li><p>How to use transactions</p></li><li><p>Tuning transaction limits for your application</p></li></ul><section data-type="sect1" data-pdf-bookmark="Introduction to Transactions"><div class="sect1" id="idm45882358635912"><h1>Introduction to Transactions</h1><p>As we mentioned above, a <span class="firstterm">transaction</span> is a
    logical unit of processing in a database that includes one or more
    database operations, which can be read or write operations. There are
    situations where your application may require reads and writes to multiple
    documents (in one or more collections) as part of this logical unit of
    processing. An important aspect of a transaction is that it is never
    partially completed—it either succeeds or fails.</p><div data-type="note" epub:type="note"><h6>Note</h6><p>In<a data-type="indexterm" data-primary="transactions" data-secondary="MongoDB versions and drivers supporting" id="idm45882358633208"/> order to use transactions, your MongoDB deployment must
      be on MongoDB version 4.2 or later and your MongoDB drivers must be
      updated for MongoDB 4.2 or later. MongoDB provides a <a href="https://oreil.ly/Oe9NE">Driver
      Compatibility Reference page</a> that you can use to ensure your
      MongoDB Driver version is compatible.</p></div><section data-type="sect2" data-pdf-bookmark="A Definition of ACID"><div class="sect2" id="idm45882358631016"><h2>A Definition of ACID</h2><p>ACID<a data-type="indexterm" data-primary="transactions" data-secondary="ACID definition" id="idm45882358630104"/> is the accepted set of properties a transaction must meet
      to be a “true” transaction. <span class="firstterm">ACID</span> is an acronym
      for Atomicity, Consistency, Isolation, and Durability<a data-type="indexterm" data-primary="ACID (Atomicity, Consistency, Isolation, and&#10;          Durability)" id="idm45882358628040"/>. ACID transactions guarantee the validity of your data
      and of your database’s state even where power failures or other errors
      occur.</p><p><span class="firstterm">Atomicity<a data-type="indexterm" data-primary="atomicity" id="idm45882358626168"/></span> ensures that all operations inside a
      transaction will either be applied or nothing will be applied. A
      transaction can never be partially applied; either it is committed or it
      aborts.</p><p><span class="firstterm">Consistency<a data-type="indexterm" data-primary="consistency" data-secondary="defined" id="idm45882358624200"/></span> ensures that if a transaction succeeds, the
      database will move from one consistent state to the next consistent
      state.</p><p><span class="firstterm">Isolation<a data-type="indexterm" data-primary="isolation" id="idm45882358622136"/></span> is the property that permits multiple
      transactions to run at the same time in your database. It guarantees
      that a transaction will not view the partial results of any other
      transaction, which means multiple parallel transactions will have the
      same results as running each of the transactions sequentially.</p><p><span class="firstterm">Durability<a data-type="indexterm" data-primary="durability" data-secondary="defined" id="idm45882358620136"/></span> ensures that when a transaction is committed
      all data will persist even in the case of a system failure.</p><p>A<a data-type="indexterm" data-primary="databases" data-secondary="ACID compliant" id="idm45882358618488"/> database is said to be ACID-compliant when it ensures
      that all these properties are met and that only successful transactions
      can be processed. In situations where a failure occurs before a
      transaction is completed, ACID compliance ensures that no data will be
      changed.</p><p>MongoDB<a data-type="indexterm" data-primary="MongoDB" data-secondary="ACID compliant transactions" id="idm45882358616696"/> is a distributed database with ACID compliant
      transactions across replica sets and/or across shards. The network layer
      adds an additional level of complexity. The engineering team at MongoDB
      provided <a href="https://www.mongodb.com/transactions">several chalk
      and talk videos</a> that describe how they implemented the necessary
      features to support ACID transactions.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="How to Use Transactions"><div class="sect1" id="idm45882358614408"><h1>How to Use Transactions</h1><p>MongoDB<a data-type="indexterm" data-primary="transactions" data-secondary="using" id="Tusing08"/> provides two APIs to use transactions. The first is a
    similar syntax to relational databases (e.g., <code class="keep-together">start_transaction </code> and <code class="keep-together">commit_transaction</code>) called
    the core API<a data-type="indexterm" data-primary="core API" id="coreapi08"/> and the second is called the<a data-type="indexterm" data-primary="call back API" id="callback08"/> callback API, which is the recommended approach to using
    transactions.</p><p>The core API does not provide retry logic<a data-type="indexterm" data-primary="retry logic" id="idm45882358607352"/> for the majority of errors and requires the developer to
    code the logic for the operations, the transaction commit function, and
    any retry and error logic required.</p><p class="pagebreak-before">The callback API provides a single function that wraps a large
    degree of functionality when compared to the core API, including starting
    a transaction associated with a specified logical session, executing a
    function supplied as the callback function, and then committing the
    transaction (or aborting on error). This function also includes retry
    logic that handle commit errors. The callback API was added in MongoDB 4.2
    to simplify application development with transactions as well as make it
    easier to add application retry logic to handle any transaction
    errors.</p><p>In both APIs, the developer is responsible for starting the logical
    session that will be used by the transaction. Both APIs require operations
    in a transaction to be associated with a specific logical
    session<a data-type="indexterm" data-primary="logical sessions" id="idm45882358604568"/> (i.e., pass in the session to each operation). A logical
    session in MongoDB tracks the time and sequencing of the operations in the
    context of the entire MongoDB deployment. A logical session or server
    session is part of the underlying framework used by client sessions to
    support retryable writes and causal consistency in MongoDB—both of these
    features were added in MongoDB version 3.6 as part of the foundation
    required to support transactions. A<a data-type="indexterm" data-primary="causal consistency" id="idm45882358603112"/> specific sequence of read and write operations that have a
    causal relationship reflected by their ordering is defined as a causally
    consistent client session in MongoDB. A client session is started by an
    application and used to interact with a server session.</p><p>In 2019, six senior engineers from MongoDB published a paper at the
    SIGMOD 2019 conference entitled <a href="https://oreil.ly/IFLvm">“Implementation of
    Cluster-wide Logical Clock and Causal Consistency in
    MongoDB”</a>.<sup><a data-type="noteref" id="idm45882358533432-marker" href="ch08.xhtml#idm45882358533432">1</a></sup> This<a data-type="indexterm" data-primary="MongoDB" data-secondary="logical sessions and causal consistency in" id="idm45882358532344"/> paper provides a deeper technical explanation of the
    mechanics behind logical sessions and causal consistency in MongoDB. The paper documents the efforts from a multiteam, multiyear engineering project. The work involved changing aspects of the storage layer, adding a new replication consensus protocol, modifying the sharding architecture, refactoring sharding cluster metadata, and adding a global logical clock. These changes provide the foundation required by the database before ACID-compliant transactions can be added.</p><p class="pagebreak-after">The complexity and additional coding required in applications are
    the main reasons to recommend the callback API over the core API. These
    differences between the APIs are summarized in <a data-type="xref" href="#table-transactions-1">Table 8-1</a>.</p><table id="table-transactions-1"><caption><span class="label">Table 8-1. </span>Comparison of Core API versus Callback API</caption><thead><tr><th>Core API</th><th>Callback API</th></tr></thead><tbody><tr><td>Requires explicit call to start the transaction and commit
            the transaction.</td><td>Starts a transaction, executes the specified operations,
            and commits (or aborts on error).</td></tr><tr><td>Does not incorporate error-handling logic for
            TransientTransactionError and UnknownTransactionCommitResult, and
            instead provides the flexibility to incorporate custom error
            handling for these errors.</td><td>Automatically incorporates error-handling logic for
            TransientTransactionError and
            UnknownTransactionCommitResult.</td></tr><tr><td>Requires explicit logical session to be passed to API for
            the specific transaction.</td><td>Requires explicit logical session to be passed to API for
            the specific transaction.</td></tr></tbody></table><p>To understand the differences between these two APIs, we can compare
    the APIs using a simple transaction example for an ecommerce site where an
    order is placed and the corresponding items are removed from the available
    stock as they are sold. This involves two documents in different
    collections in a single transaction. The two operations, which will be the
    core of our transaction example, are:</p><pre data-type="programlisting" data-code-language="python">    <code class="n">orders</code><code class="o">.</code><code class="n">insert_one</code><code class="p">({</code><code class="s2">"sku"</code><code class="p">:</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code> <code class="mi">100</code><code class="p">},</code> <code class="n">session</code><code class="o">=</code><code class="n">session</code><code class="p">)</code>
    <code class="n">inventory</code><code class="o">.</code><code class="n">update_one</code><code class="p">({</code><code class="s2">"sku"</code><code class="p">:</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code> <code class="p">{</code><code class="s2">"$gte"</code><code class="p">:</code> <code class="mi">100</code><code class="p">}},</code>
                         <code class="p">{</code><code class="s2">"$inc"</code><code class="p">:</code> <code class="p">{</code><code class="s2">"qty"</code><code class="p">:</code> <code class="o">-</code><code class="mi">100</code><code class="p">}},</code> <code class="n">session</code><code class="o">=</code><code class="n">session</code><code class="p">)</code></pre><p>First, let’s see how the core API can be used in Python for our
    transaction example. The two operations of our transaction are highlighted
    in Step 1 of the program listing below:</p><pre data-type="programlisting" data-code-language="python"><code class="c1"># Define the uriString using the DNS Seedlist Connection Format </code>
<code class="c1"># for the connection</code>
<code class="n">uri</code> <code class="o">=</code> <code class="s1">'mongodb+srv://server.example.com/'</code>
<code class="n">client</code> <code class="o">=</code> <code class="n">MongoClient</code><code class="p">(</code><code class="n">uriString</code><code class="p">)</code>

<code class="n">my_wc_majority</code> <code class="o">=</code> <code class="n">WriteConcern</code><code class="p">(</code><code class="s1">'majority'</code><code class="p">,</code> <code class="n">wtimeout</code><code class="o">=</code><code class="mi">1000</code><code class="p">)</code>

<code class="c1"># Prerequisite / Step 0: Create collections, if they don't already exist. </code>
<code class="c1"># CRUD operations in transactions must be on existing collections.</code>

<code class="n">client</code><code class="o">.</code><code class="n">get_database</code><code class="p">(</code> <code class="s2">"webshop"</code><code class="p">,</code>
                     <code class="n">write_concern</code><code class="o">=</code><code class="n">my_wc_majority</code><code class="p">)</code><code class="o">.</code><code class="n">orders</code><code class="o">.</code><code class="n">insert_one</code><code class="p">({</code><code class="s2">"sku"</code><code class="p">:</code>
                     <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code><code class="mi">0</code><code class="p">})</code>
<code class="n">client</code><code class="o">.</code><code class="n">get_database</code><code class="p">(</code> <code class="s2">"webshop"</code><code class="p">,</code>
                     <code class="n">write_concern</code><code class="o">=</code><code class="n">my_wc_majority</code><code class="p">)</code><code class="o">.</code><code class="n">inventory</code><code class="o">.</code><code class="n">insert_one</code><code class="p">(</code>
                     <code class="p">{</code><code class="s2">"sku"</code><code class="p">:</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code> <code class="mi">1000</code><code class="p">})</code>

<code class="c1"># Step 1: Define the operations and their sequence within the transaction</code>
<code class="k">def</code> <code class="nf">update_orders_and_inventory</code><code class="p">(</code><code class="n">my_session</code><code class="p">):</code>
    <code class="n">orders</code> <code class="o">=</code> <code class="n">session</code><code class="o">.</code><code class="n">client</code><code class="o">.</code><code class="n">webshop</code><code class="o">.</code><code class="n">orders</code>
    <code class="n">inventory</code> <code class="o">=</code> <code class="n">session</code><code class="o">.</code><code class="n">client</code><code class="o">.</code><code class="n">webshop</code><code class="o">.</code><code class="n">inventory</code>


    <code class="k">with</code> <code class="n">session</code><code class="o">.</code><code class="n">start_transaction</code><code class="p">(</code>
            <code class="n">read_concern</code><code class="o">=</code><code class="n">ReadConcern</code><code class="p">(</code><code class="s2">"snapshot"</code><code class="p">),</code>
            <code class="n">write_concern</code><code class="o">=</code><code class="n">WriteConcern</code><code class="p">(</code><code class="n">w</code><code class="o">=</code><code class="s2">"majority"</code><code class="p">),</code>
            <code class="n">read_preference</code><code class="o">=</code><code class="n">ReadPreference</code><code class="o">.</code><code class="n">PRIMARY</code><code class="p">):</code>

        <code class="n">orders</code><code class="o">.</code><code class="n">insert_one</code><code class="p">({</code><code class="s2">"sku"</code><code class="p">:</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code> <code class="mi">100</code><code class="p">},</code> <code class="n">session</code><code class="o">=</code><code class="n">my_session</code><code class="p">)</code>
        <code class="n">inventory</code><code class="o">.</code><code class="n">update_one</code><code class="p">({</code><code class="s2">"sku"</code><code class="p">:</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code> <code class="p">{</code><code class="s2">"$gte"</code><code class="p">:</code> <code class="mi">100</code><code class="p">}},</code>
                             <code class="p">{</code><code class="s2">"$inc"</code><code class="p">:</code> <code class="p">{</code><code class="s2">"qty"</code><code class="p">:</code> <code class="o">-</code><code class="mi">100</code><code class="p">}},</code> <code class="n">session</code><code class="o">=</code><code class="n">my_session</code><code class="p">)</code>
        <code class="n">commit_with_retry</code><code class="p">(</code><code class="n">my_session</code><code class="p">)</code>

<code class="c1"># Step 2: Attempt to run and commit transaction with retry logic</code>
<code class="k">def</code> <code class="nf">commit_with_retry</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="k">while</code> <code class="bp">True</code><code class="p">:</code>
        <code class="k">try</code><code class="p">:</code>
            <code class="c1"># Commit uses write concern set at transaction start.</code>
            <code class="n">session</code><code class="o">.</code><code class="n">commit_transaction</code><code class="p">()</code>
            <code class="k">print</code><code class="p">(</code><code class="s2">"Transaction committed."</code><code class="p">)</code>
            <code class="k">break</code>
        <code class="k">except</code> <code class="p">(</code><code class="n">ConnectionFailure</code><code class="p">,</code> <code class="n">OperationFailure</code><code class="p">)</code> <code class="k">as</code> <code class="n">exc</code><code class="p">:</code>
            <code class="c1"># Can retry commit</code>
            <code class="k">if</code> <code class="n">exc</code><code class="o">.</code><code class="n">has_error_label</code><code class="p">(</code><code class="s2">"UnknownTransactionCommitResult"</code><code class="p">):</code>
                <code class="k">print</code><code class="p">(</code><code class="s2">"UnknownTransactionCommitResult, retrying "</code>
                      <code class="s2">"commit operation ..."</code><code class="p">)</code>
                <code class="k">continue</code>
            <code class="k">else</code><code class="p">:</code>
                <code class="k">print</code><code class="p">(</code><code class="s2">"Error during commit ..."</code><code class="p">)</code>
                <code class="k">raise</code>

<code class="c1"># Step 3: Attempt with retry logic to run the transaction function txn_func</code>
<code class="k">def</code> <code class="nf">run_transaction_with_retry</code><code class="p">(</code><code class="n">txn_func</code><code class="p">,</code> <code class="n">session</code><code class="p">):</code>
    <code class="k">while</code> <code class="bp">True</code><code class="p">:</code>
        <code class="k">try</code><code class="p">:</code>
            <code class="n">txn_func</code><code class="p">(</code><code class="n">session</code><code class="p">)</code>  <code class="c1"># performs transaction</code>
            <code class="k">break</code>
        <code class="k">except</code> <code class="p">(</code><code class="n">ConnectionFailure</code><code class="p">,</code> <code class="n">OperationFailure</code><code class="p">)</code> <code class="k">as</code> <code class="n">exc</code><code class="p">:</code>
            <code class="c1"># If transient error, retry the whole transaction</code>
            <code class="k">if</code> <code class="n">exc</code><code class="o">.</code><code class="n">has_error_label</code><code class="p">(</code><code class="s2">"TransientTransactionError"</code><code class="p">):</code>
                <code class="k">print</code><code class="p">(</code><code class="s2">"TransientTransactionError, retrying transaction ..."</code><code class="p">)</code>
                <code class="k">continue</code>
            <code class="k">else</code><code class="p">:</code>
                <code class="k">raise</code>

<code class="c1"># Step 4: Start a session.</code>
<code class="k">with</code> <code class="n">client</code><code class="o">.</code><code class="n">start_session</code><code class="p">()</code> <code class="k">as</code> <code class="n">my_session</code><code class="p">:</code>

<code class="c1"># Step 5: Call the function 'run_transaction_with_retry' passing it the function</code>
<code class="c1"># to call 'update_orders_and_inventory' and the session 'my_session' to associate</code>
<code class="c1"># with this transaction.</code>

    <code class="k">try</code><code class="p">:</code>
        <code class="n">run_transaction_with_retry</code><code class="p">(</code><code class="n">update_orders_and_inventory</code><code class="p">,</code> <code class="n">my_session</code><code class="p">)</code>
    <code class="k">except</code> <code class="ne">Exception</code> <code class="k">as</code> <code class="n">exc</code><code class="p">:</code>
        <code class="c1"># Do something with error. The error handling code is not</code>
        <code class="c1"># implemented for you with the Core API.</code>
        <code class="k">raise</code></pre><p>Now, let’s look at how the the callback API can be used in Python
    for this same transaction example. The two operations of our transaction
    are highlighted in Step 1 of the program listing below:</p><pre data-type="programlisting" data-code-language="python"><code class="c1"># Define the uriString using the DNS Seedlist Connection Format </code>
<code class="c1"># for the connection</code>
<code class="n">uriString</code> <code class="o">=</code> <code class="s1">'mongodb+srv://server.example.com/'</code>
<code class="n">client</code> <code class="o">=</code> <code class="n">MongoClient</code><code class="p">(</code><code class="n">uriString</code><code class="p">)</code>

<code class="n">my_wc_majority</code> <code class="o">=</code> <code class="n">WriteConcern</code><code class="p">(</code><code class="s1">'majority'</code><code class="p">,</code> <code class="n">wtimeout</code><code class="o">=</code><code class="mi">1000</code><code class="p">)</code>

<code class="c1"># Prerequisite / Step 0: Create collections, if they don't already exist.</code>
<code class="c1"># CRUD operations in transactions must be on existing collections.</code>

<code class="n">client</code><code class="o">.</code><code class="n">get_database</code><code class="p">(</code> <code class="s2">"webshop"</code><code class="p">,</code>
                     <code class="n">write_concern</code><code class="o">=</code><code class="n">my_wc_majority</code><code class="p">)</code><code class="o">.</code><code class="n">orders</code><code class="o">.</code><code class="n">insert_one</code><code class="p">({</code><code class="s2">"sku"</code><code class="p">:</code>
                     <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code><code class="mi">0</code><code class="p">})</code>
<code class="n">client</code><code class="o">.</code><code class="n">get_database</code><code class="p">(</code> <code class="s2">"webshop"</code><code class="p">,</code>
                     <code class="n">write_concern</code><code class="o">=</code><code class="n">my_wc_majority</code><code class="p">)</code><code class="o">.</code><code class="n">inventory</code><code class="o">.</code><code class="n">insert_one</code><code class="p">(</code>
                     <code class="p">{</code><code class="s2">"sku"</code><code class="p">:</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code> <code class="mi">1000</code><code class="p">})</code>

<code class="c1"># Step 1: Define the callback that specifies the sequence of operations to</code>
<code class="c1"># perform inside the transactions.</code>

<code class="k">def</code> <code class="nf">callback</code><code class="p">(</code><code class="n">my_session</code><code class="p">):</code>
    <code class="n">orders</code> <code class="o">=</code> <code class="n">my_session</code><code class="o">.</code><code class="n">client</code><code class="o">.</code><code class="n">webshop</code><code class="o">.</code><code class="n">orders</code>
    <code class="n">inventory</code> <code class="o">=</code> <code class="n">my_session</code><code class="o">.</code><code class="n">client</code><code class="o">.</code><code class="n">webshop</code><code class="o">.</code><code class="n">inventory</code>

    <code class="c1"># Important:: You must pass the session variable 'my_session' to </code>
    <code class="c1"># the operations.</code>

    <code class="n">orders</code><code class="o">.</code><code class="n">insert_one</code><code class="p">({</code><code class="s2">"sku"</code><code class="p">:</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code> <code class="mi">100</code><code class="p">},</code> <code class="n">session</code><code class="o">=</code><code class="n">my_session</code><code class="p">)</code>
    <code class="n">inventory</code><code class="o">.</code><code class="n">update_one</code><code class="p">({</code><code class="s2">"sku"</code><code class="p">:</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="s2">"qty"</code><code class="p">:</code> <code class="p">{</code><code class="s2">"$gte"</code><code class="p">:</code> <code class="mi">100</code><code class="p">}},</code>
                         <code class="p">{</code><code class="s2">"$inc"</code><code class="p">:</code> <code class="p">{</code><code class="s2">"qty"</code><code class="p">:</code> <code class="o">-</code><code class="mi">100</code><code class="p">}},</code> <code class="n">session</code><code class="o">=</code><code class="n">my_session</code><code class="p">)</code>

<code class="c1">#. Step 2: Start a client session.</code>

<code class="k">with</code> <code class="n">client</code><code class="o">.</code><code class="n">start_session</code><code class="p">()</code> <code class="k">as</code> <code class="n">session</code><code class="p">:</code>

<code class="c1"># Step 3: Use with_transaction to start a transaction, execute the callback,</code>
<code class="c1"># and commit (or abort on error).</code>

    <code class="n">session</code><code class="o">.</code><code class="n">with_transaction</code><code class="p">(</code><code class="n">callback</code><code class="p">,</code>
                             <code class="n">read_concern</code><code class="o">=</code><code class="n">ReadConcern</code><code class="p">(</code><code class="s1">'local'</code><code class="p">),</code>
                             <code class="n">write_concern</code><code class="o">=</code><code class="n">my_write_concern_majority</code><code class="p">,</code>
                             <code class="n">read_preference</code><code class="o">=</code><code class="n">ReadPreference</code><code class="o">.</code><code class="n">PRIMARY</code><code class="p">)</code>
<code class="p">}</code></pre><div data-type="note" epub:type="note"><h6>Note</h6><p>In MongoDB multidocument transactions, you may only perform
      read/write (CRUD) operations on existing collections or databases. As
      shown in our example, you must first create a collection outside of a
      transaction if you wish to insert it into a transaction. Create, drop,
      or index operations are not permitted in a<a data-type="indexterm" data-startref="Tusing08" id="idm45882358056280"/> transaction.</p></div></div></section><section data-type="sect1" data-pdf-bookmark="Tuning Transaction Limits for Your Application"><div class="sect1" id="idm45882358614104"><h1>Tuning Transaction Limits for Your Application</h1><p>There<a data-type="indexterm" data-primary="transactions" data-secondary="tuning transaction limits" id="Ttuning08"/> are a few parameters that are important to be aware of when
    using transactions. They can be adjusted to ensure your application can
    make the optimal use of transactions.</p><section data-type="sect2" data-pdf-bookmark="Timing and Oplog Size Limits"><div class="sect2" id="idm45882357987608"><h2>Timing and Oplog Size Limits</h2><p>There are two main categories of limits in MongoDB transactions.
      The first relates to timing limits of the transaction, controlling how
      long a specific transaction can run, the time a transaction will wait to
      acquire locks, and the maximum length that all transactions will run.
      The second category specifically relates to the MongoDB oplog entry and
      size limits for an individual entry.</p><dl><dt>Time limits</dt><dd><p>The default maximum runtime of a transaction is one minute
            or less. This can be <span class="keep-together">increased by modifying the limit controlled
            by <code class="keep-together">transactionLifetime</code></span><code>LimitSeconds</code> at
            a <code>mongod</code> instance level. In the
            case of sharded clusters, the parameter must be set on all shard
            replica set members. After this time has elapsed, a transaction
            will be considered expired and will be aborted by a cleanup
            process, which runs periodically. The cleanup process will run
            once every 60 seconds or every <code class="keep-together"> transactionLifetimeLimitSeconds/2</code>,
            whichever is lower.</p><p>To explicitly set a time limit on a transaction, it is
            recommended that you specify a <code class="keep-together">maxTimeMS</code> on <code class="keep-together">commitTransaction</code>.
            If <code class="keep-together">maxTimeMS</code> is not set then <code>transactionLifetimeLimitSeconds</code> will be
            used or if it is set but would exceed <code>transactionLifetimeLimitSeconds </code> then
            <code>transactionLifetimeLimitSeconds</code>
            will be used instead.</p><p>The default maximum time a transaction will wait to acquire
            the locks it needs for the operations in the transaction is 5 ms.
            This can be increased by modifying the limit controlled by
            <code class="keep-together">
            maxTransactionLockRequestTimeoutMillis</code>. If the
            transaction is unable to acquire the locks within this time, it
            will abort. <code>
            maxTransactionLockRequestTimeoutMillis</code> can be set to
            <code> 0</code>, <code>-1</code>, or a number greater than <code>0</code>. Setting it to <code>0</code> means a transaction will abort if it
            is unable to immediately acquire all the locks it requires. A
            setting of <code>-1</code> will use the
            operation-specific timeout as specified by <code class="keep-together">maxTimeMS</code>. Any
            number greater than <code>0</code>
            configures the wait time to that time in seconds as the specified
            period that a transaction will attempt to acquire the required
            locks.</p></dd><dt>Oplog size limits</dt><dd><p>MongoDB<a data-type="indexterm" data-primary="oplogs" data-secondary="size limits" id="idm45882357971832"/> will create as many oplog entries as required for
            the write operations in a transaction. However, each oplog entry
            must be within the BSON document size limit of 16MB.</p></dd></dl><p>Transactions provide a useful feature in MongoDB to ensure
      consistency, but they should be used with the rich document model. The
      flexibility of this model and using best practices such as schema design
      patterns will help avoid the use of transactions for most situations.
      Transactions are a powerful feature, best used sparingly in
      your<a data-type="indexterm" data-startref="Ttuning08" id="idm45882357969720"/>
      applications.</p></div></section></div></section><div data-type="footnotes"><p data-type="footnote" id="idm45882358533432"><sup><a href="ch08.xhtml#idm45882358533432-marker">1</a></sup> The authors are Misha Tyulenev, staff software engineer for
        sharding; Andy Schwerin, vice president for Distributed Systems; Asya
        Kamsky, principal product manager for Distributed Systems; Randolph
        Tan, senior software engineer for sharding; Alyson Cabral, product
        manager for Distributed Systems; and Jack Mulrow, software engineer
        for sharding.</p></div></div></section></div>



  </body></html>