<html><head></head><body><section data-pdf-bookmark="Chapter 2. JSX" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch02">&#13;
<h1><span class="label">Chapter 2. </span>JSX</h1>&#13;
&#13;
&#13;
<p>In <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>, we learned about the basics of React and its&#13;
origin story, comparing it to other popular JavaScript libraries and&#13;
frameworks of its time. We learned about the true value proposition of&#13;
React and why it’s a thing.</p>&#13;
&#13;
<p>In this chapter, we’ll learn about JSX<a data-primary="JSX (JavaScript Syntax eXtension)" data-type="indexterm" id="ix_JSXJavaScriptSyntaxeXtension.02.9.39"/>,&#13;
which is a syntax extension for JavaScript that allows us to write&#13;
HTML-like code within our JavaScript code. Back when React &#13;
<span class="keep-together">was&#13;
introduced</span> in 2013, it was the first thing people noticed and heavily&#13;
criticized, &#13;
<span class="keep-together">so it makes sense</span> to zero in on it this early in the book.&#13;
With that, let’s dive deep into this language extension, how it works,&#13;
and how we can conceptually make our own code.</p>&#13;
&#13;
<p>To begin our discussion, let’s understand what JSX stands for. We&#13;
already know that JS is JavaScript. Does that mean JSX is JavaScript&#13;
version 10? Like Mac OS X? Is it JS Xtra? We may think the X in JSX&#13;
means 10 or Xtra, which would both be good guesses! But the X in JSX&#13;
stands for <em>JavaScript Syntax eXtension</em>. It’s also sometimes called&#13;
<em>JavaScript XML</em>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JavaScript XML?" data-type="sect1"><div class="sect1" id="id25">&#13;
<h1>JavaScript XML?</h1>&#13;
&#13;
<p>If you’ve been around the web for a while, you might remember<a data-primary="AJAX" data-type="indexterm" id="id427"/> the term&#13;
<em>AJAX</em>, or <em>Asynchronous JavaScript and XML</em>, from around the 2000s. AJAX&#13;
was essentially a new way of using existing technologies to&#13;
create highly interactive web pages that updated asynchronously and&#13;
in place, instead of the status quo at the time: each state change would&#13;
load an entire new page.</p>&#13;
&#13;
<p>Using tools like <code>XMLHttpRequest</code> in the browser, it would initiate an&#13;
asynchronous (that is, nonblocking) request over HTTP (HyperText&#13;
Transfer Protocol). The response to this request traditionally would be&#13;
a response in XML. Today, we tend to respond with JSON<a data-primary="JSON" data-type="indexterm" id="id428"/> instead. This is&#13;
likely one of the reasons why <code>fetch</code> has overtaken <code>XMLHTTPRequest</code>,&#13;
since <code>XMLHttpRequest</code> has XML in the name.</p>&#13;
&#13;
<p>JSX is a syntax extension for JavaScript that allows developers to write&#13;
HTML-like code within their JavaScript code. It was originally developed&#13;
by Meta<a data-primary="Meta (Facebook)" data-type="indexterm" id="id429"/><a data-primary="Facebook" data-type="indexterm" id="id430"/> to be used with React, but it has since been adopted by other&#13;
libraries and frameworks as well. JSX is not a separate language, but&#13;
rather a syntax extension that is transformed into regular JavaScript&#13;
code by a compiler or transpiler. When JSX code is compiled, it is&#13;
transformed into plain JavaScript code. We’ll get into the details of&#13;
this later.</p>&#13;
&#13;
<p>While JSX syntax looks similar to HTML, there are some key differences.&#13;
For example, JSX uses curly braces<a data-primary="curly braces ({}), embedding JSX expressions in" data-type="indexterm" id="id431"/><a data-primary="{} (curly braces), embedding JSX expressions in" data-type="indexterm" id="id432"/><a data-primary="expressions in JSX" data-type="indexterm" id="id433"/><a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="expressions in" data-type="indexterm" id="id434"/> <code>{}</code> to embed JavaScript expressions&#13;
within the HTML-like code. Additionally, JSX attributes are written in&#13;
camel case<a data-primary="camel case for attributes in JSX" data-type="indexterm" id="id435"/><a data-primary="attributes, camel case for JSX" data-type="indexterm" id="id436"/> instead of HTML attributes: <code>onclick</code> in HTML is <code>onClick</code> in&#13;
JSX. HTML elements are written in &#13;
<span class="keep-together">lowercase</span> instead of&#13;
title case<a data-primary="title case for JSX elements" data-type="indexterm" id="id437"/><a data-primary="elements" data-secondary="JSX versus HTML syntax" data-type="indexterm" id="id438"/><a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="versus HTML" data-type="indexterm" id="id439"/><a data-primary="HTML" data-secondary="versus JSX syntax" data-secondary-sortas="JSX syntax" data-type="indexterm" id="id440"/> like custom JSX elements or components: <code>div</code> is HTML, <code>Div</code>&#13;
is a React component.</p>&#13;
&#13;
<p>Further, we should mention that it is possible to create React<a data-primary="React" data-secondary="writing without JSX" data-type="indexterm" id="ix_ReactwritingwithoutJSX.02.58.13"/> applications without JSX, but the code tends to&#13;
become hard to read, reason about, and maintain. Still, &#13;
<span class="keep-together">if we want</span> to,&#13;
we can. Let’s look at a React component expressed with JSX and without.</p>&#13;
&#13;
<p>Here’s an example of a list with JSX:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">section</code> <code class="na">id</code><code class="o">=</code><code class="s">"list"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">This</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="nx">my</code><code class="w"> </code><code class="nx">list</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Isn</code><code class="err">'</code><code class="nx">t</code><code class="w"> </code><code class="nx">my</code><code class="w"> </code><code class="nx">list</code><code class="w"> </code><code class="nx">amazing</code><code class="o">?</code><code class="w"> </code><code class="nx">It</code><code class="w"> </code><code class="nx">contains</code><code class="w"> </code><code class="nx">amazing</code><code class="w"> </code><code class="nx">things</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">amazingThings</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">t</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">t</code><code class="p">.</code><code class="nx">id</code><code class="p">}&gt;{</code><code class="nx">t</code><code class="p">.</code><code class="nx">label</code><code class="p">}&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">))}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;/</code><code class="nt">section</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>Here’s an example of the same list without JSX:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">MyComponent</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
    <code class="s2">"section"</code><code class="p">,</code>&#13;
    <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s2">"list"</code> <code class="p">},</code>&#13;
    <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"h1"</code><code class="p">,</code> <code class="p">{},</code> <code class="s2">"This is my list!"</code><code class="p">),</code>&#13;
    <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
      <code class="s2">"p"</code><code class="p">,</code>&#13;
      <code class="p">{},</code>&#13;
      <code class="s2">"Isn't my list amazing? It contains amazing things!"</code>&#13;
    <code class="p">),</code>&#13;
    <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
      <code class="s2">"ul"</code><code class="p">,</code>&#13;
      <code class="p">{},</code>&#13;
      <code class="nx">amazingThings</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">t</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
        <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"li"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">key</code><code class="o">:</code> <code class="nx">t</code><code class="p">.</code><code class="nx">id</code> <code class="p">},</code> <code class="nx">t</code><code class="p">.</code><code class="nx">label</code><code class="p">)</code>&#13;
      <code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
  <code class="p">);</code></pre>&#13;
&#13;
<p>For the sake of clarity, we’ve used an earlier JSX transform to&#13;
illustrate how React was written without JSX. We’ll get into transforms&#13;
in detail later in this chapter, but for now let’s establish&#13;
that a transform<a data-primary="transforms" data-type="indexterm" id="id441"/> is something that takes syntax A and turns it into&#13;
syntax B.</p>&#13;
&#13;
<p>Nowadays, React ships with a newer transform introduced in React 17 that&#13;
automatically imports some special functions to essentially do the same&#13;
thing. This is a minor detail in the grand scheme of things, but with&#13;
the newer transformer, we’d express the list without JSX like so:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">jsx</code><code class="w"> </code><code class="kr">as</code><code class="w"> </code><code class="nx">_jsx</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react/jsx-runtime"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">jsxs</code><code class="w"> </code><code class="kr">as</code><code class="w"> </code><code class="nx">_jsxs</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react/jsx-runtime"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">_jsxs</code><code class="p">(</code><code class="s2">"section"</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">id</code><code class="o">:</code><code class="w"> </code><code class="s2">"list"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">children</code><code class="o">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">_jsx</code><code class="p">(</code><code class="s2">"h1"</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">children</code><code class="o">:</code><code class="w"> </code><code class="s2">"This is my list!"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}),</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">_jsx</code><code class="p">(</code><code class="s2">"p"</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">children</code><code class="o">:</code><code class="w"> </code><code class="s2">"Isn't my list amazing? It contains amazing things!"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}),</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">_jsx</code><code class="p">(</code><code class="s2">"ul"</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">children</code><code class="o">:</code><code class="w"> </code><code class="nx">amazingThings</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">t</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">_jsx</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">            </code><code class="s2">"li"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">              </code><code class="nx">children</code><code class="o">:</code><code class="w"> </code><code class="nx">t</code><code class="p">.</code><code class="nx">label</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">            </code><code class="nx">t</code><code class="p">.</code><code class="nx">id</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">),</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}),</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">],</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">});</code><code class="w"/></pre>&#13;
&#13;
<p>Either way, do you see the difference between examples with and without&#13;
JSX? You might find the first example with JSX far more readable and&#13;
maintainable than the latter. The former is JSX, the latter is vanilla&#13;
JS. Let’s talk about its trade-offs<a data-startref="ix_ReactwritingwithoutJSX.02.58.13" data-type="indexterm" id="id442"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Benefits of JSX" data-type="sect1"><div class="sect1" id="id26">&#13;
<h1>Benefits of JSX</h1>&#13;
&#13;
<p>There are several benefits to using JSX<a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="benefits and drawbacks" data-type="indexterm" id="ix_JSXJavaScriptSyntaxeXtensionbenefitsanddrawbacks.02.152.40"/> in web development:</p>&#13;
<dl>&#13;
<dt>Easier to read and write</dt>&#13;
<dd>&#13;
<p>JSX syntax is easier to read and write,&#13;
especially for developers who are familiar with HTML.</p>&#13;
</dd>&#13;
<dt>Improved security</dt>&#13;
<dd>&#13;
<p>JSX code can be compiled into safer<a data-primary="security" data-secondary="JSX code as safer than JavaScript" data-type="indexterm" id="id443"/><a data-primary="type safety" data-type="indexterm" id="id444"/> JavaScript&#13;
code that produces HTML strings that have dangerous characters removed,&#13;
like <code>&lt;</code> and <code>&gt;</code>, which could create new elements. Instead, these HTML&#13;
strings replace the angular brackets with the less-than and greater-than&#13;
signs in this scenario to make things safer. This process is called&#13;
sanitization<a data-primary="sanitization" data-type="indexterm" id="id445"/>.</p>&#13;
</dd>&#13;
<dt>Strong typing</dt>&#13;
<dd>&#13;
<p>JSX allows for strong typing<a data-primary="strong typing, in JSX" data-type="indexterm" id="id446"/>, which can help catch&#13;
errors before they occur. This is because JSX can be expressed with&#13;
TypeScript<a data-primary="TypeScript" data-type="indexterm" id="id447"/>, but even without TypeScript it can still benefit from enhanced type safety through the use of JSDoc-style comments<a data-primary="JSDoc-style comments" data-type="indexterm" id="id448"/><a data-primary="propTypes" data-type="indexterm" id="id449"/> and <code>propTypes</code>.</p>&#13;
</dd>&#13;
<dt>Encourages component-based architecture</dt>&#13;
<dd>&#13;
<p>JSX encourages a&#13;
component-based architecture<a data-primary="component-based architecture" data-secondary="JSX encouragement of" data-type="indexterm" id="id450"/>, which can help make code more modular and&#13;
easier to maintain.</p>&#13;
</dd>&#13;
<dt>Widely used</dt>&#13;
<dd>&#13;
<p>JSX is widely used in the React community and is also&#13;
supported by other libraries and frameworks.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Drawbacks of JSX" data-type="sect1"><div class="sect1" id="id27">&#13;
<h1>Drawbacks of JSX</h1>&#13;
&#13;
<p>There are also some drawbacks to using JSX:</p>&#13;
<dl>&#13;
<dt>Learning curve</dt>&#13;
<dd>&#13;
<p>Developers who are not familiar with JSX may find it&#13;
difficult to learn and understand.</p>&#13;
</dd>&#13;
<dt>Requires tooling</dt>&#13;
<dd>&#13;
<p>JSX code must be compiled<a data-primary="compiling code, JSX" data-type="indexterm" id="id451"/> into regular JavaScript&#13;
code before it can be executed, which adds an extra step to the&#13;
development toolchain. Other alternatives, like Vue.js<a data-primary="Vue.js" data-type="indexterm" id="id452"/>, for example, can&#13;
work immediately in a browser environment when included as nothing more&#13;
than a <code>&lt;script&gt;</code> tag in a page.</p>&#13;
</dd>&#13;
<dt>Mixing of concerns</dt>&#13;
<dd>&#13;
<p>Some developers argue that JSX mixes concerns<a data-primary="separation of concerns (SoC)" data-secondary="argument that JSX fails to maintain" data-type="indexterm" id="id453"/><a data-primary="separation of concerns (SoC)" data-secondary="and presentational/container component patterns" data-type="indexterm" id="id454"/> by&#13;
combining HTML-like code with JavaScript code, making it harder to&#13;
separate presentation from logic.</p>&#13;
</dd>&#13;
<dt>Partial JavaScript compatibility</dt>&#13;
<dd>&#13;
<p>JSX<a data-primary="JavaScript" data-secondary="JSX partial compatibility issue" data-type="indexterm" id="id455"/> supports inline expressions,&#13;
but not inline blocks. That is, inside a tree of JSX elements, we can&#13;
have inline expression, but not if or switch blocks. This can be&#13;
somewhat difficult to reason about for engineers newer to JSX.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Despite its drawbacks, JSX has become a popular choice for web&#13;
developers, particularly those of us working with React. It offers a&#13;
powerful and flexible way to create components and build user&#13;
interfaces, and has been embraced by a large and active community. In&#13;
addition to its use with React, JSX has also been adopted by other&#13;
libraries and frameworks, including Vue.js, Solid, Qwik, and more. This&#13;
shows that JSX has wider applications beyond just React, and its&#13;
popularity is likely to continue to grow in the coming years, even&#13;
breaking out of the React and web ecosystem by influencing&#13;
implementations like SwiftUI<a data-primary="SwiftUI" data-type="indexterm" id="id456"/><a data-primary="Apple’s SwiftUI" data-type="indexterm" id="id457"/> in the iOS space and more.</p>&#13;
&#13;
<p>Overall, JSX is a powerful and flexible tool that can help us build&#13;
dynamic and responsive user interfaces. JSX was created with one job:&#13;
make expressing, presenting, and maintaining the code for React&#13;
components simple while preserving powerful capabilities such as&#13;
iteration, computation, and inline execution.</p>&#13;
&#13;
<p>JSX becomes vanilla JavaScript before it makes it to the browser. How&#13;
does it accomplish this? Let’s take a look under the hood<a data-startref="ix_JSXJavaScriptSyntaxeXtensionbenefitsanddrawbacks.02.152.40" data-type="indexterm" id="id458"/>!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Under the Hood" data-type="sect1"><div class="sect1" id="under_the_hood">&#13;
<h1>Under the Hood</h1>&#13;
&#13;
<p>How does one make a language extension? How do they work? To answer these&#13;
questions, we need to understand a little bit about programming languages<a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="and code basics" data-secondary-sortas="code basics" data-type="indexterm" id="ix_JSXJavaScriptSyntaxeXtensionandcodebasics.02.225.74"/>. Specifically, we need to explore how, exactly, code like this&#13;
outputs <code>3</code>:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">);</code></pre>&#13;
&#13;
<p>Understanding this will help us understand JSX better, which will in&#13;
turn help us understand React better, thereby increasing our fluency&#13;
with React.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Does Code Work?" data-type="sect2"><div class="sect2" id="id28">&#13;
<h2>How Does Code Work?</h2>&#13;
&#13;
<p>The code snippet we just saw is literally just text. How is&#13;
this interpreted by a computer and then executed? For starters, it’s not&#13;
a big, clever <code>RegExp</code> (regular expression)<a data-primary="regular expressions" data-type="indexterm" id="id459"/> that can identify key words&#13;
in a text file. I once tried to build a programming language this way&#13;
and failed miserably, because regular expressions are often hard to get&#13;
right, harder still to read back and mentally parse, and quite difficult&#13;
to maintain because of the readability issues. For example, what follows&#13;
is a regular expression to identify a valid email address. At first&#13;
glance, it’s almost impossible to know its &#13;
<span class="keep-together">purpose:</span></p>&#13;
<pre>\[(?:[a-z0-9!#\$%&amp;'\*\+-/=\?\^_`{\|}~]+(?:\.[a-z0-9!#\$%&amp;'\*\+-/=\?\^_`{\|}~]+)\&#13;
*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0&#13;
e-\x7f])\*")@(?:(?:[a-z0-9](?:[a-z0-9-]\*?[a-z0-9])?\.)\*?[a-z0-9](?:[a-z0-9-]\*&#13;
?[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4]&#13;
[0-9]|[01]?[0-9][0-9]?|[a-z0-9-]\*?[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\&#13;
x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])\+)\])\]</pre>&#13;
&#13;
<p>That regular expression isn’t even fully valid because the full version doesn’t fit on the page! This is why instead of using regular expressions, code is compiled<a data-primary="compilers" data-type="indexterm" id="id460"/> using&#13;
a <em>compiler</em>. A compiler is a piece of software that translates source&#13;
code written in a high-level programming language into a syntax tree&#13;
(literally, a tree data structure like a JavaScript object) according to&#13;
specific rules. The process of compiling code involves several steps,&#13;
including lexical analysis, parsing, semantic analysis, optimization,&#13;
and code generation. Let’s explore each of these steps in more detail&#13;
and discuss the role of compilers in the modern software development&#13;
landscape.</p>&#13;
&#13;
<p>A compiler<a data-primary="compiling code, JSX" data-type="indexterm" id="ix_compilingcodeJSX.02.271.11"/> uses a three-step process (at least in JavaScript anyway)&#13;
that is in play here. These steps are called <em>tokenization</em>, <em>parsing</em>,&#13;
and <em>code generation</em>. Let’s look at each of these steps in more detail:</p>&#13;
<dl>&#13;
<dt>Tokenization</dt>&#13;
<dd>&#13;
<p>Essentially breaking up a string of characters into&#13;
meaningful <em>tokens</em>. When a tokenizer<a data-primary="tokenization" data-type="indexterm" id="id461"/> is stateful and each token&#13;
contains state about its parents and/or children, a tokenizer is called&#13;
a <em>lexer</em>. This is a necessary simplification for the purposes of our&#13;
discussion here: lexing<a data-primary="lexers and lexer rules" data-type="indexterm" id="id462"/> is essentially stateful tokenization.</p>&#13;
&#13;
<p>Lexers have <em>lexer rules</em> that, in some cases, indeed use a regular&#13;
expression or similar to detect key tokens like variable names, object&#13;
keys and values, and more in a text string representing a programming&#13;
language. The lexer then maps these key words to some type of enumerable&#13;
value, depending on its implementation. For example, <code>const</code> becomes <code>0</code>, <code>let</code> becomes <code>1</code>, <code>function</code> becomes <code>2</code>, etc.</p>&#13;
&#13;
<p>Once a string is tokenized or lexed, we move on to the next step, parsing.</p>&#13;
</dd>&#13;
<dt>Parsing</dt>&#13;
<dd>&#13;
<p>The process<a data-primary="parsing" data-type="indexterm" id="ix_parsing.02.291.12"/><a data-primary="syntax tree, parsing to create" data-type="indexterm" id="ix_syntaxtreeparsingtocreate.02.291.12"/> of taking the tokens and converting them into&#13;
a syntax tree. The syntax tree is a data structure that represents the&#13;
structure of the code. For example, the code snippet we looked at earlier would be represented as a syntax tree, like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
<code class="nx">type</code><code class="o">:</code> <code class="s2">"Program"</code><code class="p">,</code>&#13;
<code class="nx">body</code><code class="o">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
    <code class="nx">type</code><code class="o">:</code> <code class="s2">"VariableDeclaration"</code><code class="p">,</code>&#13;
    <code class="nx">declarations</code><code class="o">:</code> <code class="p">[</code>&#13;
        <code class="p">{</code>&#13;
        <code class="nx">type</code><code class="o">:</code> <code class="s2">"VariableDeclarator"</code><code class="p">,</code>&#13;
        <code class="nx">id</code><code class="o">:</code> <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"Identifier"</code><code class="p">,</code>&#13;
            <code class="nx">name</code><code class="o">:</code> <code class="s2">"a"</code>&#13;
        <code class="p">},</code>&#13;
        <code class="nx">init</code><code class="o">:</code> <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"Literal"</code><code class="p">,</code>&#13;
            <code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
            <code class="nx">raw</code><code class="o">:</code> <code class="s2">"1"</code>&#13;
        <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">],</code>&#13;
    <code class="nx">kind</code><code class="o">:</code> <code class="s2">"const"</code>&#13;
    <code class="p">},</code>&#13;
    <code class="p">{</code>&#13;
    <code class="nx">type</code><code class="o">:</code> <code class="s2">"VariableDeclaration"</code><code class="p">,</code>&#13;
    <code class="nx">declarations</code><code class="o">:</code> <code class="p">[</code>&#13;
        <code class="p">{</code>&#13;
        <code class="nx">type</code><code class="o">:</code> <code class="s2">"VariableDeclarator"</code><code class="p">,</code>&#13;
        <code class="nx">id</code><code class="o">:</code> <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"Identifier"</code><code class="p">,</code>&#13;
            <code class="nx">name</code><code class="o">:</code> <code class="s2">"b"</code>&#13;
        <code class="p">},</code>&#13;
        <code class="nx">init</code><code class="o">:</code> <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"Literal"</code><code class="p">,</code>&#13;
            <code class="nx">value</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
            <code class="nx">raw</code><code class="o">:</code> <code class="s2">"2"</code>&#13;
        <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">],</code>&#13;
    <code class="nx">kind</code><code class="o">:</code> <code class="s2">"let"</code>&#13;
    <code class="p">},</code>&#13;
    <code class="p">{</code>&#13;
    <code class="nx">type</code><code class="o">:</code> <code class="s2">"ExpressionStatement"</code><code class="p">,</code>&#13;
    <code class="nx">expression</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">type</code><code class="o">:</code> <code class="s2">"CallExpression"</code><code class="p">,</code>&#13;
        <code class="nx">callee</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">type</code><code class="o">:</code> <code class="s2">"Identifier"</code><code class="p">,</code>&#13;
        <code class="nx">name</code><code class="o">:</code> <code class="s2">"console"</code>&#13;
        <code class="p">},</code>&#13;
        <code class="nx">arguments</code><code class="o">:</code> <code class="p">[</code>&#13;
        <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"BinaryExpression"</code><code class="p">,</code>&#13;
            <code class="nx">left</code><code class="o">:</code> <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"Identifier"</code><code class="p">,</code>&#13;
            <code class="nx">name</code><code class="o">:</code> <code class="s2">"a"</code>&#13;
            <code class="p">},</code>&#13;
            <code class="nx">right</code><code class="o">:</code> <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"Identifier"</code><code class="p">,</code>&#13;
            <code class="nx">name</code><code class="o">:</code> <code class="s2">"b"</code>&#13;
            <code class="p">},</code>&#13;
            <code class="nx">operator</code><code class="o">:</code> <code class="s2">"+"</code>&#13;
        <code class="p">}</code>&#13;
        <code class="p">]</code>&#13;
    <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The string, thanks to the parser, becomes a JSON object<a data-primary="JSON" data-type="indexterm" id="id463"/>. As programmers,&#13;
when we have a data structure like this, we can do some really fun&#13;
things. Language engines use these data structures to complete the&#13;
process with the third step, code generation<a data-startref="ix_parsing.02.291.12" data-type="indexterm" id="id464"/><a data-startref="ix_syntaxtreeparsingtocreate.02.291.12" data-type="indexterm" id="id465"/>.</p>&#13;
</dd>&#13;
<dt>Code generation</dt>&#13;
<dd>&#13;
<p>This is where the compiler generates<a data-primary="code generation" data-type="indexterm" id="id466"/> machine code from the abstract syntax tree (AST). This involves translating the code in the AST<a data-primary="AST (abstract syntax tree)" data-type="indexterm" id="id467"/><a data-primary="abstract syntax tree (AST)" data-type="indexterm" id="id468"/> into a series of&#13;
instructions that can be executed directly by the computer’s processor.&#13;
The resulting machine code is then executed by the JavaScript engine.&#13;
Overall, the process of converting an AST into machine code is complex&#13;
and involves many different steps. However, modern compilers are&#13;
highly sophisticated and can produce highly optimized code that runs&#13;
efficiently on a wide range of hardware architectures<a data-startref="ix_compilingcodeJSX.02.271.11" data-type="indexterm" id="id469"/>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>There are several types of compilers<a data-primary="compilers" data-type="indexterm" id="id470"/>, each with different&#13;
characteristics and use cases. Some of the most common types of&#13;
compilers include:</p>&#13;
<dl>&#13;
<dt>Native compilers</dt>&#13;
<dd>&#13;
<p>These compilers<a data-primary="native compilers" data-type="indexterm" id="id471"/> produce machine code&#13;
that can be executed directly by the target platform’s processor. Native&#13;
compilers are typically used to create standalone applications or&#13;
system-level software.</p>&#13;
</dd>&#13;
<dt>Cross-compilers</dt>&#13;
<dd>&#13;
<p>These compilers<a data-primary="cross-compilers" data-type="indexterm" id="id472"/> produce machine code for&#13;
a different platform than the one on which the compiler is running.&#13;
Cross-compilers are often used in embedded systems development or when&#13;
targeting specialized hardware.</p>&#13;
</dd>&#13;
<dt>Just-in-Time (JIT) compilers</dt>&#13;
<dd>&#13;
<p>These compilers<a data-primary="Just-in-Time (JIT) compilers" data-type="indexterm" id="id473"/> translate&#13;
code into machine code at runtime, rather than ahead of time. JIT&#13;
compilers are commonly used in virtual machines, such as the Java&#13;
virtual machine, and can offer significant performance advantages over&#13;
traditional interpreters.</p>&#13;
</dd>&#13;
<dt>Interpreters</dt>&#13;
<dd>&#13;
<p>These programs execute source code directly,&#13;
without the need for compilation. Interpreters<a data-primary="interpreters" data-type="indexterm" id="id474"/> are typically slower than&#13;
compilers, but offer greater flexibility and ease of use.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>To execute JavaScript<a data-primary="JavaScript" data-secondary="JIT compiler execution of" data-type="indexterm" id="id475"/> code efficiently, many modern environments,&#13;
including web browsers, utilize JIT compilers. In these&#13;
systems, JavaScript source code might first be translated into an&#13;
intermediate representation, such as bytecode. The JIT compiler then&#13;
dynamically compiles this bytecode into machine code as the program&#13;
runs. This on-the-fly compilation allows the engine to make&#13;
optimizations based on real-time information, such as variable types and&#13;
frequently executed code paths. Some engines employ multiple stages of&#13;
compilation, starting with a quick, nonoptimized compilation to begin&#13;
execution swiftly, followed by more optimized compilation for frequently&#13;
executed code segments. This dynamic approach allows JavaScript engines&#13;
to achieve impressive performance for a wide range of applications.</p>&#13;
&#13;
<p><em>Runtimes</em> usually interface with engines<a data-primary="runtimes" data-seealso="browsers" data-type="indexterm" id="id476"/> to provide more contextual&#13;
helpers and features for their specific environment. The most popular&#13;
JavaScript runtime, by far, is the common web browser, such as Google&#13;
Chrome: it ships the Chromium <em>runtime</em> that interfaces with the&#13;
engine. Similarly, on the server side we use the Node.js runtime&#13;
that still uses the v8 <em>engine</em>. What more engines and runtimes can you&#13;
identify in the wild?</p>&#13;
&#13;
<p>Runtimes give JavaScript engines context<a data-primary="context updates" data-type="indexterm" id="id477"/><a data-primary="updates" data-secondary="context" data-type="indexterm" id="id478"/>, like the <code>window</code> object and&#13;
the <code>document</code> object that browser runtimes ship with. If you’ve worked&#13;
with both browsers and Node.js<a data-primary="Node.js" data-type="indexterm" id="id479"/> before, you may have noticed Node.js does&#13;
not have a global <code>window</code> object. This is because it’s a different&#13;
runtime and, as such, provides different context. Cloudflare<a data-primary="Cloudflare" data-type="indexterm" id="id480"/> created a&#13;
similar runtime called <em>Workers</em> whose<a data-primary="Workers runtime, Cloudflare" data-type="indexterm" id="id481"/> sole responsibility is executing&#13;
JavaScript on globally distributed machines called edge servers, with&#13;
Bun and Deno being even more alternative runtimes—but we’re digressing.&#13;
How does this all relate to JSX<a data-startref="ix_JSXJavaScriptSyntaxeXtensionandcodebasics.02.225.74" data-type="indexterm" id="id482"/>?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Extending JavaScript Syntax with JSX" data-type="sect2"><div class="sect2" id="id29">&#13;
<h2>Extending JavaScript Syntax with JSX</h2>&#13;
&#13;
<p>Now that we understand how we would extend JavaScript syntax, how does&#13;
JSX<a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="extending JavaScript with" data-type="indexterm" id="ix_JSXJavaScriptSyntaxeXtensionextendingJavaScriptwith.02.437.4"/><a data-primary="JavaScript" data-secondary="extending with JSX" data-type="indexterm" id="ix_JavaScriptextendingwithJSX.02.437.4"/> work? How would we do it? To extend JavaScript syntax, we’d need to&#13;
either have a different engine that can understand our new syntax, or&#13;
deal with our new syntax before it reaches the engine. The former is&#13;
nearly impossible to do because engines require a lot of thought to&#13;
create and maintain since they tend to be widely used. If we decided to&#13;
go with that option, it might take years or decades before we can use&#13;
our extended syntax! We’d then have to make sure our “bespoke&#13;
special engine” is used everywhere. How would we convince browser&#13;
vendors and other stakeholders to switch to our unpopular new thing?&#13;
This wouldn’t work.</p>&#13;
&#13;
<p>The latter is quicker: let’s explore how we can deal with our new syntax&#13;
before it reaches the engine. To do this, we need to create our own&#13;
lexer and parser that can understand our extended language: that is,&#13;
take a text string of code and understand it. Then, instead of&#13;
generating machine code as is traditional, we can take this syntax tree&#13;
and instead generate plain old regular vanilla JavaScript that all&#13;
current engines can understand. This is precisely<a data-primary="Babel" data-type="indexterm" id="id483"/> what <em>Babel</em> in the&#13;
JavaScript ecosystem does, along with other tools like TypeScript,&#13;
Traceur, and swc (see <a data-type="xref" href="#figure2-1">Figure 2-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure2-1">&#13;
<img alt="Creating a new JSX engine vs. using a JS preprocessor" src="assets/frea_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>Creating a new JSX engine versus using a JS preprocessor</h6>&#13;
</div></figure>&#13;
&#13;
<p>Because of this, JSX cannot be used directly in the browser, but instead&#13;
requires a “build step” where a custom parser runs against it, then&#13;
compiles it into a syntax tree. This code is then transformed into&#13;
vanilla JavaScript in a final, distributable bundle. This is called&#13;
<em>transpilation</em>: transformed<a data-primary="transpilation" data-type="indexterm" id="id484"/>, then compiled code.</p>&#13;
&#13;
<p>To be clear, transpilation is the process of taking source code written&#13;
in one language and transforming it into another language that has a&#13;
similar level of abstraction. That’s why it’s also known<a data-primary="source-to-source compilation" data-type="indexterm" id="id485"/> as&#13;
<em>source-to-source compilation</em>.</p>&#13;
&#13;
<p>Formally, it’s a type of translator<a data-primary="translator, JSX as form of" data-type="indexterm" id="id486"/>. This generic term could refer to a&#13;
compiler, assembler, or interpreter, for example. Conceptually, it’s&#13;
near-identical to compiling<a data-primary="compiling code, JSX" data-type="indexterm" id="id487"/>, except the target language is something on&#13;
a similar abstraction level like the source &#13;
<span class="keep-together">language.</span></p>&#13;
&#13;
<p>For example, TypeScript<a data-primary="TypeScript" data-type="indexterm" id="id488"/> is a high-level language that, when transpiled,&#13;
is turned into JavaScript (another high-level language). Babel’s&#13;
transpilation of ES6 JavaScript code into ES5 JavaScript is another&#13;
example.</p>&#13;
&#13;
<p>Now that we understand how we can build our own extension of JavaScript,&#13;
let’s look at what we can do with this specific extension JSX<a data-startref="ix_JSXJavaScriptSyntaxeXtensionextendingJavaScriptwith.02.437.4" data-type="indexterm" id="id489"/><a data-startref="ix_JavaScriptextendingwithJSX.02.437.4" data-type="indexterm" id="id490"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The JSX Pragma" data-type="sect1"><div class="sect1" id="id30">&#13;
<h1>The JSX Pragma</h1>&#13;
&#13;
<p>It all starts<a data-primary="&lt; (angle bracket), JSX pragma" data-type="indexterm" id="id491"/> with <code>&lt;</code>, which, on its own, is an unrecognizable&#13;
character in JavaScript when used outside of comparison operations. When&#13;
a JavaScript engine encounters this, it throws a&#13;
<code>SyntaxError: Unexpected token '&lt;'</code>. In JSX<a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="pragma of" data-type="indexterm" id="id492"/>, this “JSX pragma” can be&#13;
transpiled into a function call. A pragma is a compiler<a data-primary="compiling code, JSX" data-type="indexterm" id="id493"/> directive to&#13;
provide additional information to the compiler, usually beyond what is&#13;
conveyed in the language itself. It can, for example, tell the compiler&#13;
how it should handle some contents of a file.</p>&#13;
&#13;
<p>Examples of this in JavaScript are the “use strict” pragmas that we&#13;
sometimes see atop older modules, and the recent “use client” pragma in&#13;
the context of React Server Components (RSCs). More on those in <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>.</p>&#13;
&#13;
<p>The name of the function to call when a parser sees a <code>&lt;</code> pragma is&#13;
configurable, and defaults to the <a data-primary="React.createElement function" data-type="indexterm" id="id494"/><a data-primary="_jsxs function" data-primary-sortas="jsxs" data-type="indexterm" id="id495"/>function <code>React.createElement</code> or&#13;
<code>_jsxs</code> with the newer transform, as discussed earlier. The signature of&#13;
this function is expected to be this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">function</code> <code class="nx">pragma</code><code class="p">(</code><code class="nx">tag</code><code class="p">,</code> <code class="nx">props</code><code class="p">,</code> <code class="p">...</code><code class="nx">children</code><code class="p">)</code></pre>&#13;
&#13;
<p>That is, it receives <code>tag</code>, <code>props</code>, and <code>children</code> as arguments.&#13;
Here’s how JSX maps to regular JavaScript syntax. The following JSX code:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">MyComponent</code> <code class="na">prop</code><code class="o">=</code><code class="s">"value"</code><code class="p">&gt;</code><code class="nx">contents</code><code class="p">&lt;/</code><code class="nt">MyComponent</code><code class="p">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>becomes the following JavaScript code:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="nx">MyComponent</code><code class="p">,</code> <code class="p">{</code> <code class="nx">prop</code><code class="o">:</code> <code class="s2">"value"</code> <code class="p">},</code> <code class="s2">"contents"</code><code class="p">);</code></pre>&#13;
&#13;
<p>Notice the mapping between the tag (<code>MyComponent</code>), the props&#13;
(<code>prop="value"</code>), and the children (<code>"contents"</code>). This is essentially&#13;
the role of the JSX pragma: syntax sugar over multiple, recursive&#13;
function calls. The JSX pragma is effectively an alias: <code>&lt;</code> instead of&#13;
<code>React.createElement</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Expressions" data-type="sect1"><div class="sect1" id="id31">&#13;
<h1>Expressions</h1>&#13;
&#13;
<p>One of the most powerful features<a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="expressions in" data-type="indexterm" id="id496"/><a data-primary="expressions in JSX" data-type="indexterm" id="id497"/> of JSX is the ability to execute code&#13;
inside a tree of elements<a data-primary="tree of React elements" data-secondary="executing code in" data-type="indexterm" id="id498"/><a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="tree of elements in" data-type="indexterm" id="id499"/>. To iterate over a list as we did in <a data-type="xref" href="#under_the_hood">“Under the Hood”</a>, we can put executable code inside&#13;
curly braces<a data-primary="curly braces ({}), embedding JSX expressions in" data-type="indexterm" id="id500"/><a data-primary="{} (curly braces), embedding JSX expressions in" data-type="indexterm" id="id501"/> like we did with our <code>map</code> earlier in this chapter. If we&#13;
want to show a sum of two numbers in JSX, we’d do it like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">1</code><code class="p">;</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">2</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">Box</code><code class="p">&gt;</code><code class="nx">Here</code><code class="err">'</code><code class="nx">s</code><code class="w"> </code><code class="nx">an</code><code class="w"> </code><code class="nx">expression</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">a</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">b</code><code class="p">}&lt;/</code><code class="nt">Box</code><code class="p">&gt;;</code><code class="w"/></pre>&#13;
&#13;
<p>This will render <code>Here's an expression: 3</code>, because the stuff inside&#13;
curly brackets is executed as an expression. Using JSX expressions, we&#13;
can iterate over lists and &#13;
<span class="keep-together">execute</span> a variety of expressions, including&#13;
conditional checks with ternary operations, string replacement, and&#13;
more.</p>&#13;
&#13;
<p>Here’s another example with a conditional check using a ternary&#13;
operation:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">1</code><code class="p">;</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">2</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">Box</code><code class="p">&gt;</code><code class="nx">Is</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="nx">more</code><code class="w"> </code><code class="nx">than</code><code class="w"> </code><code class="nx">a</code><code class="o">?</code><code class="w"> </code><code class="p">{</code><code class="nx">b</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="s2">"YES"</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="s2">"NO"</code><code class="p">}&lt;/</code><code class="nt">Box</code><code class="p">&gt;;</code><code class="w"/></pre>&#13;
&#13;
<p>This will render <code>Is b more than a? YES</code> since the comparison is an&#13;
evaluated expression. For posterity, it’s worth mentioning here that JSX&#13;
expressions are exactly that—expressions. It’s not possible to execute&#13;
statements inside of a JSX element tree. This will not work:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">Box</code><code class="p">&gt;</code><code class="nx">Here</code><code class="err">'</code><code class="nx">s</code><code class="w"> </code><code class="nx">an</code><code class="w"> </code><code class="nx">expression</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">1</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">2</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">a</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="nx">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="mf">3</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}&lt;/</code><code class="nt">Box</code><code class="p">&gt;;</code><code class="w"/></pre>&#13;
&#13;
<p>It doesn’t work because statements do not return anything and are&#13;
considered side effects: they set state without yielding a value. After&#13;
statements and computations, how would we print a value inline? Notice that in the example, we just put the number <code>3</code> in there on line 6.&#13;
How is our renderer supposed to know we intend to print <code>3</code>? This is why&#13;
expressions are evaluated, but statements are not<a data-startref="ix_JSXJavaScriptSyntaxeXtension.02.9.39" data-type="indexterm" id="id502"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chapter Review" data-type="sect1"><div class="sect1" id="id223">&#13;
<h1>Chapter Review</h1>&#13;
&#13;
<p>OK, we’ve covered a fair amount of ground on the topic of JSX. We should be feeling pretty confident (or even fluent, if you&#13;
will) about the topic, to the point where we can confidently explain&#13;
aspects of it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect1"><div class="sect1" id="id224">&#13;
<h1>Review Questions</h1>&#13;
&#13;
<p>Let’s make sure you’ve fully grasped the topics we covered. Take a&#13;
moment to answer the following questions:</p>&#13;
<ol>&#13;
<li>&#13;
<p>What is JSX? What are some of its pros and cons?</p>&#13;
</li>&#13;
<li>&#13;
<p>What is the difference between JSX and HTML?</p>&#13;
</li>&#13;
<li>&#13;
<p>How does a string of text become machine code?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are JSX expressions, and what benefits do they provide?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>If you have trouble answering these questions, this chapter may be worth&#13;
another read. If not, let’s explore the next chapter.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Up Next" data-type="sect1"><div class="sect1" id="id225">&#13;
<h1>Up Next</h1>&#13;
&#13;
<p>Now that we’re pretty fluent with JSX, let’s turn our attention to the&#13;
next aspect of React and see how we can squeeze the most knowledge out&#13;
of it to further boost our fluency. Let’s explore the virtual DOM.</p>&#13;
</div></section>&#13;
</div></section></body></html>