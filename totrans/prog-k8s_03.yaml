- en: Chapter 3\. Basics of client-go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll now focus on the Kubernetes programming interface in Go. You’ll learn
    how to access the Kubernetes API of the well-known native types like pods, services,
    and deployment. In later chapters, these techniques will be extended to user-defined
    types. Here, though, we first concentrate on all API objects that are shipped
    with every Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes project provides a number of third-party consumable Git repositories
    under the *kubernetes* organization on GitHub. You’ll need to import all of these
    with the domain alias *k8s.io/…* (not *github.com/kubernetes/…*) into your project.
    We’ll present the most important of these repositories in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Client Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Kubernetes programming interface in Go mainly consists of the *k8s.io/client-go*
    library (for brevity we will just call it `client-go` going forward). *client-go*
    is a typical web service client library that supports all API types that are officially
    part of Kubernetes. It can be used to execute the usual REST verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Create*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Get*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*List*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Update*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Delete*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Patch*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these REST verbs are implemented using the [“The HTTP Interface of the
    API Server”](ch02.html#api-server-http-interface). Furthermore, the verb `Watch`
    is supported, which is special for Kubernetes-like APIs, and one of the main differentiators
    compared to other APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '[`client-go`](http://bit.ly/2RryyLM) is available on GitHub (see [Figure 3-1](#github-client-go)),
    and used in Go code with the *k8s.io/client-go* package name. It is shipped in
    parallel to Kubernetes itself; that is, for each Kubernetes `1.x.y` release, there
    is a `client-go` release with a matching tag `kubernetes-1.x.y`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The `client-go` repository on Github](assets/prku_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. The client-go repository on GitHub
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition, there is a semantic versioning scheme. For example, `client-go`
    9.0.0 matches the Kubernetes 1.12 release, `client-go` 10.0.0 matches Kubernetes
    1.13, and so on. There may be more fine-grained releases in the future. Besides
    the client code for Kubernetes API objects, `client-go` also contains a lot of
    generic library code. This is also used for user-defined API objects in [Chapter 4](ch04.html#ch_crds).
    See [Figure 3-1](#github-client-go) for a list of packages.
  prefs: []
  type: TYPE_NORMAL
- en: While all packages have their use, most of your code that speaks to Kubernetes
    APIs will use *tools/clientcmd/* to set up a client from a `kubeconfig` file and
    *kubernetes/* for the actual Kubernetes API clients. We will see code doing this
    very soon. Before that, let’s finish a quick walk through with other relevant
    repositories and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes API Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, `client-go` holds the client interfaces. The Kubernetes API
    Go types for objects like pods, services, and deployments are located in [their
    own repository](http://bit.ly/2ZA6dWH). It is accessed as `k8s.io/api` in Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Pods are part of the legacy API group (often also called the “core” group) version
    `v1`. Hence, the `Pod` Go type is found in *k8s.io/api/core/v1*, and similarly
    for all other API types in Kubernetes. See [Figure 3-2](#github-api) for a list
    of packages, most of which correspond to Kubernetes API groups and their versions.
  prefs: []
  type: TYPE_NORMAL
- en: The actual Go types are contained in a *types.go* file (e.g., *k8s.io/api/core/v1/types.go*).
    In addition, there are other files, most of them automatically generated by a
    code generator.
  prefs: []
  type: TYPE_NORMAL
- en: '![API repository on Github](assets/prku_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. The API repository on GitHub
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: API Machinery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Last but not least, there is a third repository called [API Machinery](http://bit.ly/2xAZiR2),
    which is used as `k8s.io/apimachinery` in Go. It includes all the generic building
    blocks to implement a Kubernetes-like API. API Machinery is not restricted to
    container management, so, for example, it could be used to build APIs for an online
    shop or any other business-specific domain.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, you’ll meet a lot of API Machinery packages in Kubernetes-native
    Go code. An important one is *k8s.io/apimachinery/pkg/apis/meta/v1.* It contains
    many of the generic API types such as `ObjectMeta`, `TypeMeta`, `GetOptions`,
    and `ListOptions` (see [Figure 3-3](#github-apimachinery)).
  prefs: []
  type: TYPE_NORMAL
- en: '![API Machinery repository on Github](assets/prku_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. The API Machinery repository on GitHub
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating and Using a Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we know all the building blocks to create a Kubernetes client object, which
    means we can access resources in a Kubernetes cluster. Assuming you have access
    to a cluster in your local environment (i.e., `kubectl` is properly set up and
    credentials are configured), the following code illustrates how you can use `client-go`
    in a Go project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code imports the `meta/v1` package to get access to `metav1.GetOptions`.
    Furthermore, it imports `clientcmd` from `client-go` in order to read and parse
    the kubeconfig (i.e., the client configuration with server name, credentials,
    etc.). Then it imports the `client-go` `kubernetes` package with the client sets
    for Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: The default location for the kubeconfig file is in *.kube/config* in the user’s
    home directory. This is also where `kubectl` gets the credentials for the Kubernetes
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'That kubeconfig is then read and parsed using `clientcmd.BuildConfigFromFlags`.
    We omitted the mandatory error handling throughout this code, but the `err` variable
    would normally contain, for example, the syntax error if a kubeconfig is not well
    formed. As syntax errors are common in Go code, such an error ought to be checked
    for properly, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From `clientcmd.BuildConfigFromFlags` we get a `rest.Config`, which you can
    find in the *k8s.io/client-go/rest* package). This is passed to `kubernetes.NewForConfig`
    in order to create the actual Kubernetes *client set*. It’s called a *client set*
    because it contains multiple clients for all native Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running a binary inside of a pod in a cluster, the `kubelet` will automatically
    mount a service account into the container at */var/run/secrets/kubernetes.io/serviceaccount*.
    It replaces the kubeconfig file just mentioned and can easily be turned into a
    `rest.Config` via the `rest.InClusterConfig()` method. You’ll often find the following
    combination of `rest.InClusterConfig()` and `clientcmd.BuildConfigFromFlags()`,
    including support for the `KUBECONFIG` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example code we select the core group in `v1` with `clientset.CoreV1()`
    and then access the pod `"example"` in the `"book"` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that only the last function call, `Get`, actually accesses the server.
    Both `CoreV1` and `Pods` select the client and set the namespace only for the
    following `Get` call (this is often called the *builder pattern*, in this case
    to build a request).
  prefs: []
  type: TYPE_NORMAL
- en: The `Get` call sends an HTTP `GET` request to */api/v1/namespaces/book/pods/example*
    on the server, which is set in the kubeconfig. If the Kubernetes API server answers
    with HTTP code `200`, the body of the response will carry the encoded pod objects,
    either as JSON—which is the default wire format of `client-go`—or as protocol
    buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can enable protobuf for native Kubernetes resource clients by modifying
    the REST config before creating a client from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the custom resources presented in [Chapter 4](ch04.html#ch_crds) do
    not support protocol buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning and Compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes APIs are versioned. We have seen in the previous section that pods
    are in `v1` of the core group. The core group actually exists in only one version
    today. There are other groups, though—for example, the `apps` group, which exists
    in `v1`, `v1beta2,` and `v1beta1` (as of this writing). If you look into the [*k8s.io/api/apps*](http://bit.ly/2L1Nyio)
    package, you will find all the API objects of these versions. In the [*k8s.io/client-go/kubernetes/typed/apps*](http://bit.ly/2x45Uab)
    package, you’ll see the client implementations for all of these versions.
  prefs: []
  type: TYPE_NORMAL
- en: All of this is only the client side. It does not say anything about the Kubernetes
    cluster and its API server. Using a client with a version of an API group that
    the API server does not support will fail. Clients are hardcoded to a version,
    and the application developer has to select the right API group version in order
    to speak to the cluster at hand. See [“API Versions and Compatibility Guarantees”](#api-versions)
    for more on API group compatibility guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: A second aspect of compatibility is the meta API features of the API server
    that `client-go` is speaking to. For example, there are option structs for CRUD
    verbs, like `CreateOptions`, `GetOptions`, `UpdateOptions`, and `DeleteOptions`.
    Another important one is `ObjectMeta` (discussed in detail in [“ObjectMeta”](#ObjectMeta)),
    which is part of every kind. All of these are frequently extended with new features;
    we usually call them *API machinery features*. In the Go documentation of their
    fields, comments specify when features are considered alpha or beta. The same
    API compatibility guarantees apply as for any other API fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example that follows, the `DeleteOptions` struct is defined in the package
    [*k8s.io/apimachinery/pkg/apis/meta/v1/types.go*](http://bit.ly/2MZ9flL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The last field, `DryRun`, was added in Kubernetes 1.12 as alpha and in 1.13
    as beta (enabled by default). It is not understood by the API server in earlier
    versions. Depending on the feature, passing such an option might simply be ignored
    or even rejected. So it is important to have a `client-go` version that is not
    too far off from the cluster version.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The reference for which fields are available in which quality level is the sources
    in *k8s.io/api*, which are accessible, for example, for Kubernetes 1.13 in the
    [`release-1.13` branch](http://bit.ly/2Yrhjgq). Alpha fields are marked as such
    in their description.
  prefs: []
  type: TYPE_NORMAL
- en: There is [generated API documentation](http://bit.ly/2YrfiB2) for easier consumption.
    It is the same information, though, as in *k8s.io/api*.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, many alpha and beta features have corresponding [feature
    gates](http://bit.ly/2RP5nmi) (check here for the [primary source](http://bit.ly/2FPZPTT)).
    Features are tracked in [issues](http://bit.ly/2YuHYcd).
  prefs: []
  type: TYPE_NORMAL
- en: The formally guaranteed support matrix between cluster and `client-go` versions
    is published in the `client-go` [README](http://bit.ly/2RryyLM) (see [Table 3-1](#client-go-compatibility)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. client-go compatibility with Kubernetes versions
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Kubernetes 1.9 | Kubernetes 1.10 | Kubernetes 1.11 | Kubernetes 1.12 |
    Kubernetes 1.13 | Kubernetes 1.14 | Kubernetes 1.15 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| client-go 6.0 | ✓ | +– | +– | +– | +– | +– | +– |'
  prefs: []
  type: TYPE_TB
- en: '| client-go 7.0 | +– | ✓ | +– | +– | +– | +– | +– |'
  prefs: []
  type: TYPE_TB
- en: '| client-go 8.0 | +– | +– | ✓ | +– | +– | +– | +– |'
  prefs: []
  type: TYPE_TB
- en: '| client-go 9.0 | +– | +– | +– | ✓ | +– | +– | +– |'
  prefs: []
  type: TYPE_TB
- en: '| client-go 10.0 | +– | +– | +– | +– | ✓ | +– | +– |'
  prefs: []
  type: TYPE_TB
- en: '| client-go 11.0 | +– | +– | +– | +– | +– | ✓ | +– |'
  prefs: []
  type: TYPE_TB
- en: '| client-go 12.0 | +– | +– | +– | +– | +– | +– | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| client-go HEAD | +– | +– | +– | +– | +– | +– | +– |'
  prefs: []
  type: TYPE_TB
- en: '✓: both `client-go` and the Kubernetes version have the same features and the
    same API group versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: `client-go` has features or API group versions that may be absent from
    the Kubernetes cluster. This may be because of added functionality in `client-go`
    or because Kubernetes removed old, deprecated functionality. However, everything
    they have in common (i.e., most APIs) will work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`–`: `client-go` is knowingly incompatible with the Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The takeaway from [Table 3-1](#client-go-compatibility) is that the `client-go`
    library is supported with its corresponding cluster version. In case of version
    skew, developers have to carefully consider which features and which API groups
    they use and whether these are supported in the cluster version the application
    speaks to.
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 3-1](#client-go-compatibility), the `client-go` versions are listed.
    We briefly mentioned in [“The Client Library”](#client-go) that `client-go` uses
    semantic versioning (semver) formally, though by increasing the major version
    of `client-go` each time the minor version of Kubernetes (the 13 in 1.13.2) is
    increased. With `client-go` 1.0 being released for Kubernetes 1.4, we are now
    at `client-go` 12.0 (at the time of this writing) for Kubernetes 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: This semver applies only to `client-go` itself, not to API Machinery or the
    API repository. Instead, the latter are tagged using Kubernetes versions, as seen
    in [Figure 3-4](#client-go-versioning). See [“Vendoring”](#vendoring) to see what
    this means for vendoring *k8s.io/client-go*, *k8s.io/apimachinery*, and *k8s.io/api*
    in your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-go versioning](assets/prku_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. client-go versioning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: API Versions and Compatibility Guarantees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the previous section, the selection of the right API group versions
    may be crucial if you target different cluster versions with your code. Kubernetes
    versions all API groups. A common Kubernetes-style versioning scheme is used,
    which consists of alpha, beta, and GA (general availability) versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1alpha1`, `v1alpha2`, `v2alpha1`, and so on are called *alpha versions* and
    considered unstable. This means:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They might go away or change at any time, in any incompatible way.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Data might be dropped, get lost, or become inaccessible from Kubernetes version
    to version.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They are often disabled by default, if the administrator does not opt in manually.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v1beta1`, `v1beta2`, `v2beta1`, and so on, are called *beta versions*. They
    are on the way to stability, which means:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They will still exist for at least one Kubernetes release in parallel to the
    corresponding stable API version.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They will usually not change in incompatible ways, but there is no strict guarantee
    of that.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects stored in a beta version will not be dropped or become inaccessible.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Beta versions are often enabled in clusters by default. But this might depend
    on the Kubernetes distribution or cloud provider used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v1`, `v2`, and so on are stable, generally available APIs; that is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They will stay.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They will be compatible.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kubernetes has a [formal deprecation policy](http://bit.ly/2FOrKU8) behind these
    rules of thumb. You can find many more details about which APIs constructs are
    considered compatible at the [Kubernetes community GitHub](http://bit.ly/2XKPWAX).
  prefs: []
  type: TYPE_NORMAL
- en: 'In connection to API group versions, there are two important points to keep
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'API group versions apply to API resources as a whole, like the format of pods
    or services. In addition to API group versions, API resources might have single
    fields that are versioned orthogonally; for example, fields in stable APIs might
    be marked as alpha quality in their Go inline code documentation. The same rules
    as those just listed for API groups will apply to those fields. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An alpha field in a stable API could become incompatible, lose data, or go
    away at any time. For example, the `ObjectMeta.Initializers` field, which was
    never promoted beyond alpha, will go away in the near future (it is deprecated
    in 1.14):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'It usually will be disabled by default and must be enabled with an API server
    feature gate, like so:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The behavior of the API server will differ from field to field. Some alpha fields
    will be rejected and some will be ignored if the corresponding feature gate is
    not enabled. This is documented in the field description (see `TTLSecondsAfterFinished`
    in the previous example).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, API group versions play a role in accessing the API. Between different
    versions of the same resource, there is an on-the-fly conversion done by the API
    server. That is, you can access objects created in one version (e.g., `v1beta1`)
    in any of the other supported versions (e.g., `v1`) without any further work in
    your application. This is very convenient for building backward- and forward-compatible
    applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each object stored in `etcd` is stored in a specific version. By default, this
    is called the *storage version* of that resource. While the storage version can
    change from Kubernetes version to version, the object stored in `etcd` will not
    automatically be updated as of this writing. Hence, the cluster administrator
    has to make sure migration happens in time when Kubernetes clusters are updated,
    before old version support is dropped. There is no generic migration mechanism
    for that, and migration differs from Kubernetes distribution to distribution.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the application developer, though, this operational work should not matter
    at all. On-the-fly conversion will make sure the application has a unified picture
    of the objects in the cluster. The application will not even notice which storage
    version is in use. Storage versioning will be transparent to the written Go code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes Objects in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Creating and Using a Client”](#rest-client-config), we saw how to create
    a client for the core group in order to access pods in a Kubernetes cluster. In
    the following, we want to look in more detail at what a pod—or any other Kubernetes
    resource, for that matter—is in the world of Go.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes resources—or more precisely the objects—that are instances of a kind^([1](ch03.html#idm46336866123400))
    and are served as a resource by the API server are represented as structs. Depending
    on the kind in question, their fields of course differ. But on the other hand,
    they share a common structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the type system point of view, Kubernetes objects fulfill a Go interface
    called `runtime.Object` from the package *k8s.io/apimachinery/pkg/runtime*, which
    actually is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `schema.ObjectKind` (from the *k8s.io/apimachinery/pkg/runtime/schema*
    package) is another simple interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, a Kubernetes object in Go is a data structure that can:'
  prefs: []
  type: TYPE_NORMAL
- en: Return *and* set the GroupVersionKind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be *deep-copied*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *deep copy* is a clone of the data structure such that it does not share any
    memory with the original object. It is used wherever code has to mutate an object
    without modifying the original. See [“Global Tags”](ch05.html#global-tags) about
    code generation for details on how deep copy is implemented in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, an object stores its type and allows cloning.
  prefs: []
  type: TYPE_NORMAL
- en: TypeMeta
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `runtime.Object` is only an interface, we want to know how it is actually
    implemented. Kubernetes objects from *k8s.io/api* implement the type getter and
    setter of `schema.ObjectKind` by embedding the `metav1.TypeMeta` struct from the
    package *k8s.io/apimachinery/meta/v1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, a pod declaration in Go looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `TypeMeta` is embedded. Moreover, the pod type has JSON tags
    that also declare `TypeMeta` as being inlined.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This `",inline"` tag is actually superfluous with the Golang JSON en/decoders:
    embedded structs are automatically inlined.'
  prefs: []
  type: TYPE_NORMAL
- en: This is different in the [YAML en/decoder *go-yaml/yaml*](http://bit.ly/2ZuPZy2),
    which was used in very early Kubernetes code in parallel to JSON. We inherited
    the [inline tag from that time](http://bit.ly/2IUGwcC), but today it is merely
    documentation without any effect.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML serializers foudn in *k8s.io/apimachinery/pkg/runtime/serializer/yaml*
    use the *sigs.k8s.io/yaml* marshal and unmarshal functions. And these in turn
    encode and decode YAML via `interface{}`, and use the JSON encoder into and decoder
    from Golang API structs.
  prefs: []
  type: TYPE_NORMAL
- en: This matches the YAML representation of a pod, which all Kubernetes users know:^([2](ch03.html#idm46336865870888))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The version is stored in `TypeMeta.APIVersion`, the kind in `TypeMeta.Kind`.
  prefs: []
  type: TYPE_NORMAL
- en: When running the example in [“Creating and Using a Client”](#rest-client-config)
    to get a pod from the cluster, notice that the pod object returned by the client
    does not actually have the kind and the version set. The convention in `client-go`–based
    applications is that these fields are empty in memory, and they are filled with
    the actual values on the wire only when they’re marshaled to JSON or protobuf.
    This is done automatically by the client, however, or, more precisely, by a versioning
    serializer.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, `client-go`–based applications check the Golang type of objects
    to determine the object at hand. This might differ in other frameworks, like the
    Operator SDK (see [“The Operator SDK”](ch06.html#operator-sdk)).
  prefs: []
  type: TYPE_NORMAL
- en: ObjectMeta
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to `TypeMeta`, most top-level objects have a field of type `metav1.ObjectMeta`,
    again from the *k8s.io/apimachinery/pkg/meta/v1* package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In JSON or YAML these fields are under *metadata*. For example, for the previous
    pod, `metav1.ObjectMeta` stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In general, it contains all metalevel information like name, namespace, resource
    version (not to be confused with the API group version), several timestamps, and
    the well-known labels and annotations is part of `ObjectMeta`. See [“Anatomy of
    a type”](ch04.html#anatomy-of-CRD-types) for a deeper discussion of `ObjectMeta`
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: The resource version was discussed earlier in [“Optimistic Concurrency”](ch01.html#optimistic-concurrency).
    It is hardly ever read or written from `client-go` code. But it is one of the
    fields in Kubernetes that makes the whole system work. `resourceVersion` is part
    of `ObjectMeta` because each object with embedded `ObjectMeta` corresponds to
    a key in `etcd` where the `resourceVersion` value originated.
  prefs: []
  type: TYPE_NORMAL
- en: spec and status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, nearly every top-level object has a `spec` and a `status` section.
    This convention comes from the declarative nature of the Kubernetes API: `spec`
    is the user desire, and `status` is the outcome of that desire, usually filled
    by a controller in the system. See [“Controllers and Operators”](ch01.html#ch_controllers-operators)
    for a detailed discussion of controllers in Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: There are only a few exceptions to the `spec` and `status` convention in the
    system—for example, endpoints in the core group, or RBAC objects like `ClusterRole`.
  prefs: []
  type: TYPE_NORMAL
- en: Client Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the introductory example in [“Creating and Using a Client”](#rest-client-config),
    we saw that `kubernetes.NewForConfig(config)` gives us a *client set*. A client
    set gives access to clients for multiple API groups and resources. In the case
    of `kubernetes.NewForConfig(config)` from *k8s.io/client-go/kubernetes*, we get
    access to all API groups and resources defined in *k8s.io/api*. This is, with
    a few exceptions—such as `APIServices` (for aggregated API servers) and `CustomResourceDefinition`
    (see [Chapter 4](ch04.html#ch_crds))—the whole set of resources served by the
    Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html#ch_autocodegen), we will explain how these client sets
    are actually generated from the API types (*k8s.io/api*, in this case). Third-party
    projects with custom APIs use more than just the Kubernetes client sets. What
    all of the client sets have in common is a REST config (e.g., returned by `clientcmd.BuildConfigFromFlags("",
    *kubeconfig)`, like in the example).
  prefs: []
  type: TYPE_NORMAL
- en: 'The client set main interface in *k8s.io/client-go/kubernetes/typed* for Kubernetes-native
    resources looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There used to be unversioned methods in this interface—for example, just `Apps()
    appsv1.AppsV1Interface`—but they were deprecated as of Kubernetes 1.14–based `client-go`
    11.0\. As mentioned before, it is seen as a good practice to be very explicit
    about the version of an API group that an application uses.
  prefs: []
  type: TYPE_NORMAL
- en: Every client set also gives access to the discovery client (it will be used
    by the `RESTMappers`; see [“REST Mapping”](#RESTMapping) and [“Using the API from
    the Command Line”](ch02.html#api-cli)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind each `GroupVersion` method (e.g., `AppsV1beta1`), we find the resources
    of the API group—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'with `RESTClient` being a generic *REST client*, and one interface per resource,
    as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the scope of the resource—that is, whether it is cluster or namespace
    scoped—the accessor (here `DeploymentGetter`) may or may not have a `namespace`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `DeploymentInterface` gives access to all the supported verbs of the resource.
    Most of them are self-explanatory, but those requiring additional commentary are
    described next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Status Subresources: UpdateStatus'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deployments have a so-called *status subresource*. This means that `UpdateStatus`
    uses an additional HTTP endpoint suffixed with `/status`. While updates on the
    */apis/apps/v1beta1/namespaces/*`ns`*/deployments/*`name`** endpoint can change
    only the spec of the deployment, the endpoint /*apis/apps/v1beta1/namespaces/*`ns`*/deployments/*`name`*/status*
    can change only the status of the object. This is useful in order to set different
    permissions for spec updates (done by a human) and status updates (done by a controller).
  prefs: []
  type: TYPE_NORMAL
- en: By default the `client-gen` (see [“client-gen Tags”](ch05.html#clientgen-tags))
    generates the `UpdateStatus()` method. The existence of the method does not guarantee
    that the resource actually supports the subresource. This will be important when
    we’re working with CRDs in [“Subresources”](ch04.html#crd-subresources).
  prefs: []
  type: TYPE_NORMAL
- en: Listings and Deletions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DeleteCollection` allows us to delete multiple objects of a namespace at once.
    The `ListOptions` parameter allows us to define which objects should be deleted
    using a *field* or *label selector*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Watches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Watch` gives an event interface for all changes (adds, removes, and updates)
    to objects. The returned `watch.Interface` from *k8s.io/apimachinery/pkg/watch*
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result channel of the `watch` interface returns three kinds of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While it is tempting to use this interface directly, in practice it is actually
    discouraged in favor of informers (see [“Informers and Caching”](#informers)).
    Informers are a combination of this event interface and an in-memory cache with
    indexed lookup. This is by far the most common use case for watches. Under the
    hood informers first call `List` on the client to get the set of all objects (as
    a baseline for the cache) and then `Watch` to update the cache. They handle error
    conditions correctly—that is, recover from network issues or other cluster problems.
  prefs: []
  type: TYPE_NORMAL
- en: Client Expansion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DeploymentExpansion` is actually an empty interface. It is used to add custom
    client behavior, but it’s hardly used in Kubernetes nowadays. Instead, the client
    generator allows us to add custom methods in a declarative way (see [“client-gen
    Tags”](ch05.html#clientgen-tags)).'
  prefs: []
  type: TYPE_NORMAL
- en: Note again that all of those methods in `DeploymentInterface` neither expect
    valid information in the `TypeMeta` fields `Kind` and `APIVersion`, nor set those
    fields on `Get()` and `List()` (see also [“TypeMeta”](#TypeMeta)). These fields
    are filled with real values only on the wire.
  prefs: []
  type: TYPE_NORMAL
- en: Client Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is worth looking at the different options we can set when creating a client
    set. In the note before [“Versioning and Compatibility”](#versioning-capability),
    we saw that we can switch to the protobuf wire format for native Kubernetes types.
    Protobuf is more efficient than JSON (both spacewise and for the CPU load of the
    client and server) and therefore preferable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For debugging purposes and readability of metrics, it is often helpful to differentiate
    between different clients accessing the API server. To do so, we can set the *user
    agent* field in the REST config. The default value is `binary/version (os/arch)
    kubernetes/commit`; for example, `kubectl` will use a user agent like `kubectl/v1.14.0
    (darwin/amd64) kubernetes/d654b49`. If that pattern does not suffice for the setup,
    it can be customized like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Other values often overridden in the REST config are those for client-side
    *rate limiting* and *timeouts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `QPS` value defaults to `5` requests per second, with a burst of `10`.
  prefs: []
  type: TYPE_NORMAL
- en: The timeout has no default value, at least not in the client REST config. By
    default the Kubernetes API server will timeout every request that is not a *long-running*
    request after 60 seconds. A long-running request can be a watch request or unbounded
    requests to subresources like */exec*, */portforward*, or */proxy*.
  prefs: []
  type: TYPE_NORMAL
- en: Informers and Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client interface in [“Client Sets”](#clientsets) includes the `Watch` verb,
    which offers an event interface that reacts to changes (adds, removes, updates)
    of objects. Informers give a higher-level programming interface for the most common
    use case for watches: in-memory caching and fast, indexed lookup of objects by
    name or other properties in-memory.'
  prefs: []
  type: TYPE_NORMAL
- en: A controller that accesses the API server every time it needs an object creates
    a high load on the system. In-memory caching using informers is the solution to
    this problem. Moreover, informers can react to changes of objects nearly in real-time
    instead of requiring polling requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-5](#informers-figure) shows the conceptional pattern of informers;
    specifically, they:'
  prefs: []
  type: TYPE_NORMAL
- en: Get input from the API server as events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offer a client-like interface called `Lister` to get and list objects from the
    in-memory cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register event handlers for adds, removes, and updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the in-memory cache using a *store*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Informers](assets/prku_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Informers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Informers also have advanced error behavior: when the long-running watch connection
    breaks down, they recover from it by trying another watch request, picking up
    the event stream without losing any events. If the outage is long, and the API
    server lost events because `etcd` purged them from its database before the new
    watch request was successful, the informer will relist all objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to *relists*, there is a configurable *resync period* for reconciliation
    between the in-memory cache and the business logic: the registered event handlers
    will be called for all objects each time this period has passed. Common values
    are in minutes (e.g., 10 or 30 minutes).'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The resync is purely in-memory and *does not trigger a call to the server*.
    This used to be different but was [eventually changed](http://bit.ly/2FmeMge)
    because the error behavior of the watch mechanism had been improved enough to
    make relists unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: All this advanced and battle-proven error behavior is a good reason for using
    informers instead of rolling out custom logic using the client `Watch()` method
    directly. Informers are used everywhere in Kubernetes itself and are one of the
    main architectural concepts in the Kubernetes API design.
  prefs: []
  type: TYPE_NORMAL
- en: While informers are preferred over polling, they create load on the API server.
    One binary should instantiate only one informer per GroupVersionResource. To make
    sharing of informers easy, we can instantiate an informer by using the *shared
    informer factory*.
  prefs: []
  type: TYPE_NORMAL
- en: The shared informer factory allows informers to be shared for the same resource
    in an application. In other words, different control loops can use the same watch
    connection to the API server under the hood. For example, the `kube-controller-manager`,
    one of the main Kubernetes cluster components (see [“The API Server”](ch02.html#api-server)),
    has a larger, two-digit number of controllers. But for each resource (e.g., pods),
    there is only one informer in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Always use a shared informer factory to instantiate informers. Don’t try to
    instantiate informers manually. The overhead is minimal, and a nontrivial controller
    binary that does not use shared informers probably is opening multiple watch connections
    for the same resource somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a REST config (see [“Creating and Using a Client”](#rest-client-config)),
    it is easy to create a shared informer factory using a client set. The informers
    are generated by a code generator and shipped as part of `client-go` for the standard
    Kubernetes resources in *k8s.io/client-go/informers*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The example shows how to get a shared informer for pods.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that informers allow for the addition of event handlers for the
    three cases *add*, *update*, and *delete*. These are usually used to trigger the
    business logic of a controller—that is, to process a certain object again (see
    [“Controllers and Operators”](ch01.html#ch_controllers-operators)). Often those
    handlers just add the modified object into a work queue.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that many event handlers can be added. The whole shared informer factory
    concept exists only because this is so common in controller binaries with many
    control loops, each installing event handlers to add objects to their own work
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: After registering handlers, the shared informer factory has to be started. There
    are Go routines under the hood that do the actual calls to the API server. The
    `Start` method (with a stop channel to control the lifecycle) starts these Go
    routines, and the `WaitForCacheSync()` method makes the code wait for the first
    `List` calls to the clients to finish. If the controller logic requires that the
    cache is filled, this `WaitForCacheSync` call is essential.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the event interface of the watches behind the scenes leads to a
    certain lag. In a setup with proper capacity planning, this lag is not huge. Of
    course, it is good practice to measure this lag using metrics. But the lag exists
    regardless, so the application logic has be built in such a way that the lag does
    not harm the behavior of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The lag of informers can lead to races between changes the controller makes
    with `client-go` directly on the API server, and the state of the world as known
    by the informers.
  prefs: []
  type: TYPE_NORMAL
- en: If the controller changes an object, the informer in the same process has to
    wait until the corresponding event arrives and the in-memory store is then updated.
    This process is not instantaneous, and another controller work loop run might
    be started through another trigger before the previous change has become visible.
  prefs: []
  type: TYPE_NORMAL
- en: The resync interval of 30 seconds in this example leads to a complete set of
    events being sent to the registered `UpdateFunc` such that the controller logic
    is able to reconcile its state with that of the API server. By comparing the `ObjectMeta.resourceVersion`
    field, it is possible to distinguish a real update from a resync.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Choosing a good resync interval depends on the context. For example, 30 seconds
    is pretty short. In many situations several minutes, or even 30 minutes, is a
    good choice. In the worst case, 30 minutes means that it takes 30 minutes until
    a bug in the code (e.g., a lost signal due to bad error handling) is repaired
    via reconciliation.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the final line in the example calling `Get("client-go")` is purely
    in-memory; there is no access to the API server. Objects in the in-memory store
    cannot be modified directly. Instead, the client set must be used for any write
    access to the resources. The informer will then get events from the API server
    and update its in-memory store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The informer constructor `NewSharedInformerFactory` in the example caches all
    objects of a resource in all namespaces in the store. If this is too much for
    the application, there is an alternative constructor with more flexibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It allows us to specify a namespace and to pass a `TweakListOptionsFunc`, which
    may mutate the `ListOptions` struct used to list and watch objects using the `List`
    and `Watch` calls of the client. It can be used to set *label* or *field selectors*,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Informers are one of the building blocks of controllers. In [Chapter 6](ch06.html#ch_operator-solutions)
    we will see what a typical `client-go`-based controller looks like. After the
    clients and informers, the third main building block is the work queue. Let’s
    look at it now.
  prefs: []
  type: TYPE_NORMAL
- en: Work Queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A work queue is a data structure. You can add elements and take elements out
    of the queue, in an order predefined by the queue. Formally, this kind of queue
    is called a *priority queue*. `client-go` provides a powerful implementation for
    the purpose of building controllers in [*k8s.io/client-go/util/workqueue*](http://bit.ly/2IV0JPz).
  prefs: []
  type: TYPE_NORMAL
- en: 'More precisely, the package contains a number of variants for different purposes.
    The base interface implemented by all variants looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here `Add(item)` adds an item, `Len()` gives the length, and `Get()` returns
    an item with the highest priority (and it blocks until one is available). Every
    item returned by `Get()` needs a `Done(item)` call when the controller has finished
    processing it. Meanwhile, a repeated `Add(item)` will only mark the item as dirty
    such that it is readded when `Done(item)` has been called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following queue types are derived from this generic interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DelayingInterface` can add an item at a later time. This makes it easier to
    requeue items after failures without ending up in a hot-loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RateLimitingInterface` rate-limits items being added to the queue. It extends
    the `DelayingInterface:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Most interesting here is the `Forget(item)` method: it resets the back-off
    of the given item. Usually, it will be called when an item has been processed
    successfully.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The rate limiting algorithm can be passed to the constructor `NewRateLimitingQueue`.
    There are several rate limiters defined in the same package, such as the `BucketRateLimiter`,
    the `ItemExponentialFailureRateLimiter`, the `ItemFastSlowRateLimiter`, and the
    `MaxOfRateLimiter`. For more details, you can refer to the package documentation.
    Most controllers will just use the `DefaultControllerRateLimiter() *RateLimiter`
    functions, which gives:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An exponential back-off starting at 5 ms and going up to 1,000 seconds, doubling
    the delay on each error
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A maximal rate of 10 items per second and 100 items burst
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the context, you might want to customize the values. A 1,000 seconds
    maximal back-off per item is a lot for certain controller applications.
  prefs: []
  type: TYPE_NORMAL
- en: API Machinery in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API Machinery repository implements the basics of the Kubernetes type system.
    But what is this type system exactly? What is a type to begin with?
  prefs: []
  type: TYPE_NORMAL
- en: The term *type* actually does not exist in the terminology of API Machinery.
    Instead, it refers to *kinds*.
  prefs: []
  type: TYPE_NORMAL
- en: Kinds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kinds are divided into API groups and are versioned, as we already have seen
    in [“API Terminology”](ch02.html#terminology). Therefore, a core term in the API
    Machinery repository is GroupVersionKind, or *GVK* for short.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, each GVK corresponds to one Go type. In contrast, a Go type can belong
    to multiple GVKs.
  prefs: []
  type: TYPE_NORMAL
- en: Kinds do not formally map one-to-one to HTTP paths. Many kinds have HTTP REST
    endpoints that are used to access objects of the given kind. But there are also
    kinds without any HTTP endpoint (e.g., [*admission.k8s.io/v1beta1.AdmissionReview*](http://bit.ly/2XJXBQD),
    which is used to call out to a webhook). There are also kinds that are returned
    from many endpoints—for example, [*meta.k8s.io/v1.Status*](http://bit.ly/31Ktjvz),
    which is returned by all endpoints to report a nonobject status like an error.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, kinds are formatted in [CamelCase](http://bit.ly/31IqMSC) like
    words and are usually singular. Depending on the context, their concrete format
    differs. For CustomResourceDefinition kinds, it must be a DNS path label (RFC
    1035).
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In parallel to kinds, as we saw in [“API Terminology”](ch02.html#terminology),
    there is the concept of a *resource*. Resources are again grouped and versioned,
    leading to the term *GroupVersionResource*, or *GVR* for short.
  prefs: []
  type: TYPE_NORMAL
- en: Each GVR corresponds to one HTTP (base) path. GVRs are used to identify REST
    endpoints of the Kubernetes API. For example, the GVR *apps/v1.deployments* maps
    to */apis/apps/v1/namespaces/`namespace`/deployments*.
  prefs: []
  type: TYPE_NORMAL
- en: Client libraries use this mapping to construct the HTTP path to access a GVR.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, resources are lowercase and plural, usually corresponding to
    the plural words of the parallel kind. They must conform to the DNS path label
    format (RFC 1025). As resources map directly to HTTP paths, this is not surprising.
  prefs: []
  type: TYPE_NORMAL
- en: REST Mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mapping of a GVK to a GVR is called *REST mapping*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `RESTMapper` is the [Golang interface](http://bit.ly/2Y7wYS8) that enables
    us to request the GVR for a GVK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'where the type `RESTMapping` on the right looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, a `RESTMapper` provides a number of convenience functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, a partial GVR means that not all fields are set. For example, imagine
    you type `**kubectl get pods**`. In that case, the group and the version are missing.
    A `RESTMapper` with enough information might still manage to map it to the `v1
    Pods` kind.
  prefs: []
  type: TYPE_NORMAL
- en: For the preceding deployment example, a `RESTMapper` that knows about deployments
    (more about what this means in a bit) will map [*apps/v1.Deployment*](http://bit.ly/2IujaLU)
    to *apps/v1.deployments* as a namespaced resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple different implementations of the `RESTMapper` interface.
    The most important one for client applications is the discovery-based [`DeferredDiscoveryRESTMapper`](http://bit.ly/2XroxUq)
    in the package *k8s.io/client-go/restmapper*: it uses discovery information from
    the Kubernetes API server to dynamically build up the REST mapping. It will also
    work with non-core resources like custom resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Scheme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final core concept we want to present here in the context of the Kubernetes
    type system is the [*scheme*](http://bit.ly/2N1PGJB) in the package *k8s.io/apimachinery/pkg/runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A scheme connects the world of Golang with the implementation-independent world
    of GVKs. The main feature of a scheme is the mapping of Golang types to possible
    GVKs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in [“Kubernetes Objects in Go”](#kube-objects), an object can return
    its group and kind via the `GetObjectKind() schema.ObjectKind` method. However,
    these values are empty most of the time and are therefore pretty useless for identification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the scheme takes the Golang type of the given object via reflection
    and maps it to the registered GVK(s) of that Golang type. For that to work, of
    course, the Golang types have to be registered into the scheme like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The scheme is used not only to register the Golang types and their GVK, but
    also to store a list of conversion functions and defaulters (see [Figure 3-6](#scheme-spider)).
    We’ll discuss conversions and defaulters in more detail in [Chapter 8](ch08.html#ch_custom-api-servers).
    It is the data source to implement encoders and decoders as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![The scheme, connecting Golang data types with the GVK, conversions and defaulters](assets/prku_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. The scheme, connecting Golang data types with the GVK, conversions,
    and defaulters
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For Kubernetes core types there is a [predefined scheme in the `client-go` client
    set](http://bit.ly/2FkXDn2) in the package *k8s.io/client-go/kubernetes/scheme*,
    with all the types preregistered. Actually, every client set generated by the
    `client-gen` code generator (see [Chapter 5](ch05.html#ch_autocodegen)) has the
    subpackage `scheme` with all types in all groups and versions in the client set.
  prefs: []
  type: TYPE_NORMAL
- en: With the scheme we conclude our deep dive into API Machinery concepts. If you
    only remember one thing about these concepts, let it be [Figure 3-7](#scheme-restmapper-http-path).
  prefs: []
  type: TYPE_NORMAL
- en: '![From Golang types to GVKs to GVRs to an HTTP path — API machinery in a nutshell](assets/prku_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. From Golang types to GVKs to GVRs to an HTTP path—API Machinery
    in a nutshell
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vendoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in this chapter that *k8s.io/client-go*, *k8s.io/api*, and *k8s.io/apimachinery*
    are central to Kubernetes programming in Golang. Golang uses *vendoring* to include
    these libraries in a third-party application source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Vendoring is a moving target in the Golang community. At the time of this writing,
    several vendoring tools are common, such as *godeps*, *dep*, and *glide*. At the
    same time, Go 1.12 is getting support for Go modules, which will probably become
    the standard vendoring method in the Go community in the future, but is not ready
    in the Kubernetes ecosystem at this time.
  prefs: []
  type: TYPE_NORMAL
- en: Most projects nowadays use either `dep` or `glide`. Kubernetes itself in *github.com/kubernetes/kubernetes*
    made the jump to Go modules for the 1.15 development cycle. The following comments
    are relevant for all of these vendoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: The source of truth for supported dependency versions in each of the *k8s.io/**
    repositories is the shipped *Godeps/Godeps.json* file. It is important to stress
    that any other dependency selection can break the functionality of the library.
  prefs: []
  type: TYPE_NORMAL
- en: See [“The Client Library”](#client-go) for more on the published tags of *k8s.io/client-go*,
    *k8s.io/api*, and *k8s.io/apimachinery* and which tags are compatible with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: glide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Projects using `glide` can use its ability to read the *Godeps/Godeps.json*
    file on any dependency change. This has proven to work pretty reliably: the developer
    has only to declare the right *k8s.io/client-go* version, and `glide` will select
    the right version of *k8s.io/apimachinery*, *k8s.io/api*, and other dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For some projects on GitHub, the *glide.yaml* file might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With that, `glide install -v` will download *k8s.io/client-go* and its dependencies
    into the local *vendor/* package. Here, `-v` means to drop *vendor/* packages
    from vendored libraries. This is required for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: If you update to a new version of `client-go` by editing *glide.yaml*, `glide
    update -v` will download the new dependencies, again in the right versions.
  prefs: []
  type: TYPE_NORMAL
- en: dep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`dep` is often considered more powerful and advanced than `glide`. For a long
    time it was seen as the successor to `glide` in the ecosystem and seemed destined
    to be *the* Go vendoring tool. At the time of this writing, its future is not
    clear, and Go modules seem to be the path forward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of `client-go`, it is very important to be aware of a couple
    of restrictions of `dep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dep` does read *Godeps/Godeps.json* on the first run of `dep init`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dep` does not read *Godeps/Godeps.json* on later `dep ensure -update` calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that the resolution for dependencies of `client-go` is most probably
    wrong when the `client-go` version is updated in *Godep.toml*. This is unfortunate,
    because it requires the developer to explicitly and usually manually declare *all*
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'A working and consistent *Godep.toml* file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Not only does *Gopkg.toml* declare explicit versions for both *k8s.io/apimachinery*
    and *k8s.io/api*, it also has overrides for them. This is necessary for when the
    project is started without explicit imports of packages from those two repositories.
    In that case, without these overrides `dep` would ignore the constraints in the
    beginning, and the developer would get wrong dependencies from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Even the *Gopkg.toml* file shown here is technically not correct because it
    is incomplete, as it does not declare dependencies *on all* other libraries required
    by `client-go`. In the past, an upstream library broke compilation of `client-go`.
    So be prepared for this to happen if you use `dep` for dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: Go Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go modules are the future of dependency management in Golang. They were introduced
    in Go 1.11 with [preliminary support](http://bit.ly/2FmBp3Y) and were further
    stabilized in 1.12\. A number of commands, like `go run` and `go get`, work with
    Go modules by setting the `GO111MODULE=on` environment variable. In Go 1.13 this
    will be the default setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go modules are driven by a *go.mod* file in the root of a project. Here is
    an excerpt of the *go.mod* file for our *github.com/programming-kubernetes/pizza-apiserver*
    project in [Chapter 8](ch08.html#ch_custom-api-servers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`client-go` `v11.0.0`—matching Kubernetes 1.14—and older versions do not have
    explicit support for Go modules. Still, it is possible to use Go modules with
    the Kubernetes libraries, as you see in the preceding example.'
  prefs: []
  type: TYPE_NORMAL
- en: As long as `client-go` and the other Kubernetes repositories do not ship a *go.mod*
    file, though (at least until Kubernetes 1.15), the right versions must be selected
    manually. That is, you’ll need a complete list of all dependencies matching the
    revisions of dependencies of the *Godeps/Godeps.json* in `client-go`.
  prefs: []
  type: TYPE_NORMAL
- en: Also note the not-very-readable revisions in the previous example. They are
    pseudo-versions derived from existing tags, or using `v0.0.0` as the prefix if
    there are no tags. Even worse, you can reference tagged versions in that file,
    but the Go module commands will replace those on the next run with the pseudo-versions.
  prefs: []
  type: TYPE_NORMAL
- en: With `client-go` `v12.0.0`—matching Kubernetes 1.15—we ship a *go.mod* file
    and deprecate support for all other vendoring tools (see the [corresponding proposal
    document](http://bit.ly/2IZ9MPg)). The shipped *go.mod* file includes all dependencies,
    and your project *go.mod* file no longer has to list all transitive dependencies
    manually. In later releases, it’s also possible that the tagging scheme will be
    changed to fix the ugly pseudo-revisions and replace them with proper semver tags.
    But at the time of this writing, this is still not fully implemented or decided.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter our focus was on the Kubernetes programming interface in Go.
    We discussed accessing the Kubernetes API of well-known core types—that is, the
    API objects that are shipped with every Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: With this we’ve covered the basics of the Kubernetes API and its representation
    in Go. Now we’re ready to move on to the topic of custom resources, one of the
    pillars of operators.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.html#idm46336866123400-marker)) See [“API Terminology”](ch02.html#terminology).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.html#idm46336865870888-marker)) `kubectl` `explain` `pod` lets you
    query the API server for the schema of an object, including field documentation.
  prefs: []
  type: TYPE_NORMAL
