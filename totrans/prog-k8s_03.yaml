- en: Chapter 3\. Basics of client-go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. client-go 的基础知识
- en: We’ll now focus on the Kubernetes programming interface in Go. You’ll learn
    how to access the Kubernetes API of the well-known native types like pods, services,
    and deployment. In later chapters, these techniques will be extended to user-defined
    types. Here, though, we first concentrate on all API objects that are shipped
    with every Kubernetes cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将专注于 Go 中的 Kubernetes 编程接口。您将学习如何访问 Kubernetes API 中的众所周知的原生类型，例如 pods、services
    和 deployments。在后续章节中，这些技术将扩展到用户定义的类型。然而，在此之前，我们首先集中讨论每个 Kubernetes 集群都提供的所有 API
    对象。
- en: The Repositories
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: The Kubernetes project provides a number of third-party consumable Git repositories
    under the *kubernetes* organization on GitHub. You’ll need to import all of these
    with the domain alias *k8s.io/…* (not *github.com/kubernetes/…*) into your project.
    We’ll present the most important of these repositories in the following sections.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 项目在 GitHub 上的 *kubernetes* 组织下提供了许多第三方可消费的 Git 仓库。您需要将所有这些仓库使用域别名
    *k8s.io/…*（而不是 *github.com/kubernetes/…*）导入到您的项目中。我们将在以下部分介绍其中最重要的仓库。
- en: The Client Library
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端库
- en: 'The Kubernetes programming interface in Go mainly consists of the *k8s.io/client-go*
    library (for brevity we will just call it `client-go` going forward). *client-go*
    is a typical web service client library that supports all API types that are officially
    part of Kubernetes. It can be used to execute the usual REST verbs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中使用 Go 编程接口主要由 *k8s.io/client-go* 库组成（简称为 `client-go`）。*client-go*
    是一个典型的 Web 服务客户端库，支持所有官方 Kubernetes API 类型。它可以用来执行常见的 REST 动词：
- en: '*Create*'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建*'
- en: '*Get*'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取*'
- en: '*List*'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*列表*'
- en: '*Update*'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新*'
- en: '*Delete*'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*删除*'
- en: '*Patch*'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修补*'
- en: Each of these REST verbs are implemented using the [“The HTTP Interface of the
    API Server”](ch02.html#api-server-http-interface). Furthermore, the verb `Watch`
    is supported, which is special for Kubernetes-like APIs, and one of the main differentiators
    compared to other APIs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个这些 REST 动词都是使用[“API 服务器的 HTTP 接口”](ch02.html#api-server-http-interface)实现的。此外，还支持动词
    `Watch`，这是 Kubernetes 类似 API 的特殊功能，也是与其他 API 的主要区别之一。
- en: '[`client-go`](http://bit.ly/2RryyLM) is available on GitHub (see [Figure 3-1](#github-client-go)),
    and used in Go code with the *k8s.io/client-go* package name. It is shipped in
    parallel to Kubernetes itself; that is, for each Kubernetes `1.x.y` release, there
    is a `client-go` release with a matching tag `kubernetes-1.x.y`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[`client-go`](http://bit.ly/2RryyLM) 在 GitHub 上可用（参见[图 3-1](#github-client-go)），在
    Go 代码中使用 *k8s.io/client-go* 包名。它与 Kubernetes 本身并行发布；也就是说，对于每个 Kubernetes `1.x.y`
    发布，都有一个与之匹配的 `client-go` 发布，带有相应的标签 `kubernetes-1.x.y`。'
- en: '![The `client-go` repository on Github](assets/prku_0301.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![在 Github 上的 `client-go` 仓库](assets/prku_0301.png)'
- en: Figure 3-1\. The client-go repository on GitHub
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1. GitHub 上的 `client-go` 仓库
- en: In addition, there is a semantic versioning scheme. For example, `client-go`
    9.0.0 matches the Kubernetes 1.12 release, `client-go` 10.0.0 matches Kubernetes
    1.13, and so on. There may be more fine-grained releases in the future. Besides
    the client code for Kubernetes API objects, `client-go` also contains a lot of
    generic library code. This is also used for user-defined API objects in [Chapter 4](ch04.html#ch_crds).
    See [Figure 3-1](#github-client-go) for a list of packages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一个语义版本控制方案。例如，`client-go` 9.0.0 对应 Kubernetes 1.12 发布，`client-go` 10.0.0
    对应 Kubernetes 1.13，依此类推。未来可能会有更精细的发布。除了 Kubernetes API 对象的客户端代码，`client-go` 还包含许多通用库代码。这也用于用户定义的
    API 对象在[第 4 章](ch04.html#ch_crds)中使用。参见[图 3-1](#github-client-go)以获取包列表。
- en: While all packages have their use, most of your code that speaks to Kubernetes
    APIs will use *tools/clientcmd/* to set up a client from a `kubeconfig` file and
    *kubernetes/* for the actual Kubernetes API clients. We will see code doing this
    very soon. Before that, let’s finish a quick walk through with other relevant
    repositories and packages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有包都有其用途，但大部分与 Kubernetes API 进行交互的代码将使用 *tools/clientcmd/* 从 `kubeconfig`
    文件设置客户端，以及用于实际 Kubernetes API 客户端的 *kubernetes/*。我们很快将看到执行此操作的代码。在此之前，让我们快速浏览其他相关的仓库和包。
- en: Kubernetes API Types
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes API 类型
- en: As we have seen, `client-go` holds the client interfaces. The Kubernetes API
    Go types for objects like pods, services, and deployments are located in [their
    own repository](http://bit.ly/2ZA6dWH). It is accessed as `k8s.io/api` in Go code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`client-go` 拥有客户端接口。用于 pods、services 和 deployments 等 Kubernetes API Go
    类型的对象位于[它们自己的仓库](http://bit.ly/2ZA6dWH)中。在 Go 代码中，它被访问为 `k8s.io/api`。
- en: Pods are part of the legacy API group (often also called the “core” group) version
    `v1`. Hence, the `Pod` Go type is found in *k8s.io/api/core/v1*, and similarly
    for all other API types in Kubernetes. See [Figure 3-2](#github-api) for a list
    of packages, most of which correspond to Kubernetes API groups and their versions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是遗留 API 组的一部分（通常也称为“核心”组）版本 `v1`。因此，`Pod` Go 类型位于 *k8s.io/api/core/v1*，其他
    Kubernetes 中的所有 API 类型类似。参见 [图 3-2](#github-api) 获取包列表，其中大多数对应于 Kubernetes API
    组及其版本。
- en: The actual Go types are contained in a *types.go* file (e.g., *k8s.io/api/core/v1/types.go*).
    In addition, there are other files, most of them automatically generated by a
    code generator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 Go 类型包含在一个 *types.go* 文件中（例如 *k8s.io/api/core/v1/types.go*）。此外，还有其他文件，其中大多数是由代码生成器自动生成的。
- en: '![API repository on Github](assets/prku_0302.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub 上的 API 仓库](assets/prku_0302.png)'
- en: Figure 3-2\. The API repository on GitHub
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. GitHub 上的 API 仓库
- en: API Machinery
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 机制
- en: Last but not least, there is a third repository called [API Machinery](http://bit.ly/2xAZiR2),
    which is used as `k8s.io/apimachinery` in Go. It includes all the generic building
    blocks to implement a Kubernetes-like API. API Machinery is not restricted to
    container management, so, for example, it could be used to build APIs for an online
    shop or any other business-specific domain.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，有第三个仓库称为 [API Machinery](http://bit.ly/2xAZiR2)，在 Go 中被用作 `k8s.io/apimachinery`。它包括所有用于实现类似
    Kubernetes API 的通用构建模块。API 机制不仅限于容器管理，例如，它也可以用于构建在线商店或任何其他业务特定域的 API。
- en: Nevertheless, you’ll meet a lot of API Machinery packages in Kubernetes-native
    Go code. An important one is *k8s.io/apimachinery/pkg/apis/meta/v1.* It contains
    many of the generic API types such as `ObjectMeta`, `TypeMeta`, `GetOptions`,
    and `ListOptions` (see [Figure 3-3](#github-apimachinery)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在 Kubernetes 原生 Go 代码中会遇到许多 API 机制包。其中一个重要的是 *k8s.io/apimachinery/pkg/apis/meta/v1.*。它包含许多通用的
    API 类型，如 `ObjectMeta`、`TypeMeta`、`GetOptions` 和 `ListOptions`（见 [图 3-3](#github-apimachinery)）。
- en: '![API Machinery repository on Github](assets/prku_0303.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub 上的 API 机制仓库](assets/prku_0303.png)'
- en: Figure 3-3\. The API Machinery repository on GitHub
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. GitHub 上的 API 机制仓库
- en: Creating and Using a Client
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用客户端
- en: 'Now we know all the building blocks to create a Kubernetes client object, which
    means we can access resources in a Kubernetes cluster. Assuming you have access
    to a cluster in your local environment (i.e., `kubectl` is properly set up and
    credentials are configured), the following code illustrates how you can use `client-go`
    in a Go project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了创建 Kubernetes 客户端对象的所有构建模块，这意味着我们可以访问 Kubernetes 集群中的资源。假设您可以在本地环境中访问集群（即
    `kubectl` 正确设置并配置了凭据），以下代码演示了如何在 Go 项目中使用 `client-go`：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code imports the `meta/v1` package to get access to `metav1.GetOptions`.
    Furthermore, it imports `clientcmd` from `client-go` in order to read and parse
    the kubeconfig (i.e., the client configuration with server name, credentials,
    etc.). Then it imports the `client-go` `kubernetes` package with the client sets
    for Kubernetes resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码导入 `meta/v1` 包以访问 `metav1.GetOptions`。此外，它从 `client-go` 导入 `clientcmd` 以读取和解析
    kubeconfig（即包含服务器名称、凭据等的客户端配置）。然后它导入 `client-go` 的 `kubernetes` 包，其中包含用于 Kubernetes
    资源的客户端集。
- en: The default location for the kubeconfig file is in *.kube/config* in the user’s
    home directory. This is also where `kubectl` gets the credentials for the Kubernetes
    clusters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: kubeconfig 文件的默认位置在用户的主目录中的 *.kube/config*。这也是 `kubectl` 获取 Kubernetes 集群凭据的地方。
- en: 'That kubeconfig is then read and parsed using `clientcmd.BuildConfigFromFlags`.
    We omitted the mandatory error handling throughout this code, but the `err` variable
    would normally contain, for example, the syntax error if a kubeconfig is not well
    formed. As syntax errors are common in Go code, such an error ought to be checked
    for properly, like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `clientcmd.BuildConfigFromFlags` 读取并解析 kubeconfig。我们在代码中省略了强制的错误处理，但 `err`
    变量通常会包含例如 kubeconfig 格式不正确的语法错误。由于语法错误在 Go 代码中很常见，因此应适当检查此类错误，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From `clientcmd.BuildConfigFromFlags` we get a `rest.Config`, which you can
    find in the *k8s.io/client-go/rest* package). This is passed to `kubernetes.NewForConfig`
    in order to create the actual Kubernetes *client set*. It’s called a *client set*
    because it contains multiple clients for all native Kubernetes resources.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `clientcmd.BuildConfigFromFlags` 我们得到一个 `rest.Config`，你可以在 *k8s.io/client-go/rest*
    包中找到）。这个配置传递给 `kubernetes.NewForConfig` 以创建实际的 Kubernetes *客户端集*。它被称为 *客户端集*，因为它包含多个客户端，用于访问所有原生
    Kubernetes 资源。
- en: 'When running a binary inside of a pod in a cluster, the `kubelet` will automatically
    mount a service account into the container at */var/run/secrets/kubernetes.io/serviceaccount*.
    It replaces the kubeconfig file just mentioned and can easily be turned into a
    `rest.Config` via the `rest.InClusterConfig()` method. You’ll often find the following
    combination of `rest.InClusterConfig()` and `clientcmd.BuildConfigFromFlags()`,
    including support for the `KUBECONFIG` environment variable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中的 Pod 内运行二进制文件时，`kubelet` 将自动将一个服务帐户挂载到容器中的 */var/run/secrets/kubernetes.io/serviceaccount*。它替换了刚提到的
    kubeconfig 文件，可以通过 `rest.InClusterConfig()` 方法轻松转换为 `rest.Config`。你经常会找到以下组合：`rest.InClusterConfig()`
    和 `clientcmd.BuildConfigFromFlags()`，包括对 `KUBECONFIG` 环境变量的支持。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the following example code we select the core group in `v1` with `clientset.CoreV1()`
    and then access the pod `"example"` in the `"book"` namespace:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例代码中，我们选择 `v1` 版本的核心组 `clientset.CoreV1()`，然后访问命名空间 `"book"` 中的 pod `"example"`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that only the last function call, `Get`, actually accesses the server.
    Both `CoreV1` and `Pods` select the client and set the namespace only for the
    following `Get` call (this is often called the *builder pattern*, in this case
    to build a request).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有最后一个函数调用 `Get` 实际访问了服务器。`CoreV1` 和 `Pods` 都选择了客户端，并且仅为以下 `Get` 调用设置了命名空间（这通常被称为
    *生成器模式*，在这种情况下用于构建请求）。
- en: The `Get` call sends an HTTP `GET` request to */api/v1/namespaces/book/pods/example*
    on the server, which is set in the kubeconfig. If the Kubernetes API server answers
    with HTTP code `200`, the body of the response will carry the encoded pod objects,
    either as JSON—which is the default wire format of `client-go`—or as protocol
    buffers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get` 调用向服务器发送 HTTP `GET` 请求，路径为 */api/v1/namespaces/book/pods/example*，该路径在
    kubeconfig 中设置。如果 Kubernetes API 服务器以 HTTP 状态码 `200` 响应，则响应体将携带编码后的 Pod 对象，可以是
    JSON 格式（这是 `client-go` 的默认传输格式）或者协议缓冲区格式。'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can enable protobuf for native Kubernetes resource clients by modifying
    the REST config before creating a client from it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在创建客户端之前修改 REST 配置来为原生 Kubernetes 资源客户端启用协议缓冲区支持：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the custom resources presented in [Chapter 4](ch04.html#ch_crds) do
    not support protocol buffers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[第 4 章](ch04.html#ch_crds) 中介绍的自定义资源不支持协议缓冲区。
- en: Versioning and Compatibility
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制和兼容性
- en: Kubernetes APIs are versioned. We have seen in the previous section that pods
    are in `v1` of the core group. The core group actually exists in only one version
    today. There are other groups, though—for example, the `apps` group, which exists
    in `v1`, `v1beta2,` and `v1beta1` (as of this writing). If you look into the [*k8s.io/api/apps*](http://bit.ly/2L1Nyio)
    package, you will find all the API objects of these versions. In the [*k8s.io/client-go/kubernetes/typed/apps*](http://bit.ly/2x45Uab)
    package, you’ll see the client implementations for all of these versions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 是有版本的。在前一节中我们看到 pods 属于核心组的 `v1` 版本。实际上，核心组目前只存在一个版本。但也有其他组，例如
    `apps` 组，在 `v1`、`v1beta2` 和 `v1beta1`（截至本文撰写时）中存在。如果你查看 [*k8s.io/api/apps*](http://bit.ly/2L1Nyio)
    包，你会找到所有这些版本的 API 对象。在 [*k8s.io/client-go/kubernetes/typed/apps*](http://bit.ly/2x45Uab)
    包中，你会看到所有这些版本的客户端实现。
- en: All of this is only the client side. It does not say anything about the Kubernetes
    cluster and its API server. Using a client with a version of an API group that
    the API server does not support will fail. Clients are hardcoded to a version,
    and the application developer has to select the right API group version in order
    to speak to the cluster at hand. See [“API Versions and Compatibility Guarantees”](#api-versions)
    for more on API group compatibility guarantees.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些仅涉及客户端端。它并未涉及 Kubernetes 集群及其 API 服务器的任何内容。使用客户端与 API 服务器不支持的 API 组版本将导致失败。客户端是硬编码到一个版本中的，应用程序开发人员必须选择正确的
    API 组版本以便与手头的集群进行通信。有关 API 组兼容性保证的更多信息，请参见 [“API 版本和兼容性保证”](#api-versions)。
- en: A second aspect of compatibility is the meta API features of the API server
    that `client-go` is speaking to. For example, there are option structs for CRUD
    verbs, like `CreateOptions`, `GetOptions`, `UpdateOptions`, and `DeleteOptions`.
    Another important one is `ObjectMeta` (discussed in detail in [“ObjectMeta”](#ObjectMeta)),
    which is part of every kind. All of these are frequently extended with new features;
    we usually call them *API machinery features*. In the Go documentation of their
    fields, comments specify when features are considered alpha or beta. The same
    API compatibility guarantees apply as for any other API fields.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 兼容性的第二个方面是`client-go`与 API 服务器的元 API 功能。例如，有用于 CRUD 动词的选项结构体，比如`CreateOptions`、`GetOptions`、`UpdateOptions`和`DeleteOptions`。另一个重要的是`ObjectMeta`（在[“ObjectMeta”](#ObjectMeta)中详细讨论），它是每种类型的一部分。所有这些都经常通过新功能进行扩展；在它们的字段中，注释指定何时将功能视为
    alpha 或 beta。与任何其他 API 字段一样，相同的 API 兼容性保证适用于它们。
- en: 'In the example that follows, the `DeleteOptions` struct is defined in the package
    [*k8s.io/apimachinery/pkg/apis/meta/v1/types.go*](http://bit.ly/2MZ9flL):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，`DeleteOptions` 结构体在包[*k8s.io/apimachinery/pkg/apis/meta/v1/types.go*](http://bit.ly/2MZ9flL)中定义：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The last field, `DryRun`, was added in Kubernetes 1.12 as alpha and in 1.13
    as beta (enabled by default). It is not understood by the API server in earlier
    versions. Depending on the feature, passing such an option might simply be ignored
    or even rejected. So it is important to have a `client-go` version that is not
    too far off from the cluster version.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字段，`DryRun`，在 Kubernetes 1.12 中作为 alpha 版本添加，在 1.13 中作为 beta 版本（默认启用）。在较早的版本中，API
    服务器无法理解它。根据功能，传递这样的选项可能会被简单地忽略或者甚至拒绝。因此，拥有一个与集群版本不相距太远的`client-go`版本非常重要。
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The reference for which fields are available in which quality level is the sources
    in *k8s.io/api*, which are accessible, for example, for Kubernetes 1.13 in the
    [`release-1.13` branch](http://bit.ly/2Yrhjgq). Alpha fields are marked as such
    in their description.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些字段在哪个质量级别可用的参考是*k8s.io/api*中的源代码，例如，在[`release-1.13`分支](http://bit.ly/2Yrhjgq)中，为
    Kubernetes 1.13 标记为 alpha 的字段已被标注。
- en: There is [generated API documentation](http://bit.ly/2YrfiB2) for easier consumption.
    It is the same information, though, as in *k8s.io/api*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有[生成的 API 文档](http://bit.ly/2YrfiB2)更便于使用。尽管如此，它的信息与*k8s.io/api*中的相同。
- en: Last but not least, many alpha and beta features have corresponding [feature
    gates](http://bit.ly/2RP5nmi) (check here for the [primary source](http://bit.ly/2FPZPTT)).
    Features are tracked in [issues](http://bit.ly/2YuHYcd).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，许多 alpha 和 beta 功能都有相应的[功能门](http://bit.ly/2RP5nmi)（请查看[主要来源](http://bit.ly/2FPZPTT)）。这些功能在[问题](http://bit.ly/2YuHYcd)中有追踪。
- en: The formally guaranteed support matrix between cluster and `client-go` versions
    is published in the `client-go` [README](http://bit.ly/2RryyLM) (see [Table 3-1](#client-go-compatibility)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 集群与`client-go`版本之间的正式保证支持矩阵已在`client-go`的[README](http://bit.ly/2RryyLM)中发布（参见[表
    3-1](#client-go-compatibility)）。
- en: Table 3-1\. client-go compatibility with Kubernetes versions
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. `client-go` 与 Kubernetes 版本的兼容性
- en: '|  | Kubernetes 1.9 | Kubernetes 1.10 | Kubernetes 1.11 | Kubernetes 1.12 |
    Kubernetes 1.13 | Kubernetes 1.14 | Kubernetes 1.15 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  | Kubernetes 1.9 | Kubernetes 1.10 | Kubernetes 1.11 | Kubernetes 1.12 |
    Kubernetes 1.13 | Kubernetes 1.14 | Kubernetes 1.15 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| client-go 6.0 | ✓ | +– | +– | +– | +– | +– | +– |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| client-go 6.0 | ✓ | +– | +– | +– | +– | +– | +– |'
- en: '| client-go 7.0 | +– | ✓ | +– | +– | +– | +– | +– |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| client-go 7.0 | +– | ✓ | +– | +– | +– | +– | +– |'
- en: '| client-go 8.0 | +– | +– | ✓ | +– | +– | +– | +– |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| client-go 8.0 | +– | +– | ✓ | +– | +– | +– | +– |'
- en: '| client-go 9.0 | +– | +– | +– | ✓ | +– | +– | +– |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| client-go 9.0 | +– | +– | +– | ✓ | +– | +– | +– |'
- en: '| client-go 10.0 | +– | +– | +– | +– | ✓ | +– | +– |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| client-go 10.0 | +– | +– | +– | +– | ✓ | +– | +– |'
- en: '| client-go 11.0 | +– | +– | +– | +– | +– | ✓ | +– |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| client-go 11.0 | +– | +– | +– | +– | +– | ✓ | +– |'
- en: '| client-go 12.0 | +– | +– | +– | +– | +– | +– | ✓ |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| client-go 12.0 | +– | +– | +– | +– | +– | +– | ✓ |'
- en: '| client-go HEAD | +– | +– | +– | +– | +– | +– | +– |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| client-go HEAD | +– | +– | +– | +– | +– | +– | +– |'
- en: '✓: both `client-go` and the Kubernetes version have the same features and the
    same API group versions.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '✓: `client-go` 和 Kubernetes 版本在功能和 API 组版本上是相同的。'
- en: '`+`: `client-go` has features or API group versions that may be absent from
    the Kubernetes cluster. This may be because of added functionality in `client-go`
    or because Kubernetes removed old, deprecated functionality. However, everything
    they have in common (i.e., most APIs) will work.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：`client-go` 具有功能或 API 组版本，可能在 Kubernetes 集群中不存在。这可能是因为 `client-go` 中添加了新功能，或者因为
    Kubernetes 删除了旧的、不推荐使用的功能。然而，它们共享的所有内容（即大多数 API）都将正常工作。'
- en: '`–`: `client-go` is knowingly incompatible with the Kubernetes cluster.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–`：`client-go` 明知与 Kubernetes 集群不兼容。'
- en: The takeaway from [Table 3-1](#client-go-compatibility) is that the `client-go`
    library is supported with its corresponding cluster version. In case of version
    skew, developers have to carefully consider which features and which API groups
    they use and whether these are supported in the cluster version the application
    speaks to.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [表 3-1](#client-go-compatibility) 中可以得出结论，`client-go` 库与其相应的集群版本兼容。在版本不一致的情况下，开发人员必须仔细考虑他们使用的功能和
    API 组是否在应用程序所连接的集群版本中得到支持。
- en: In [Table 3-1](#client-go-compatibility), the `client-go` versions are listed.
    We briefly mentioned in [“The Client Library”](#client-go) that `client-go` uses
    semantic versioning (semver) formally, though by increasing the major version
    of `client-go` each time the minor version of Kubernetes (the 13 in 1.13.2) is
    increased. With `client-go` 1.0 being released for Kubernetes 1.4, we are now
    at `client-go` 12.0 (at the time of this writing) for Kubernetes 1.15.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [表 3-1](#client-go-compatibility) 中列出了 `client-go` 的版本。我们在 [“客户端库”](#client-go)
    中简要提到，`client-go` 使用语义化版本控制（semver），每次增加 Kubernetes 的小版本时，增加 `client-go` 的主版本。`client-go`
    1.0 是为 Kubernetes 1.4 发布的，现在我们在 Kubernetes 1.15 时的 `client-go` 版本为 12.0（截至撰写本文时）。
- en: This semver applies only to `client-go` itself, not to API Machinery or the
    API repository. Instead, the latter are tagged using Kubernetes versions, as seen
    in [Figure 3-4](#client-go-versioning). See [“Vendoring”](#vendoring) to see what
    this means for vendoring *k8s.io/client-go*, *k8s.io/apimachinery*, and *k8s.io/api*
    in your project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此 semver 仅适用于 `client-go` 本身，不适用于 API Machinery 或 API 仓库。相反，后者使用 Kubernetes
    版本进行标记，如 [图 3-4](#client-go-versioning) 所示。查看 [“Vendoring”](#vendoring) 以了解它在项目中对
    *k8s.io/client-go*、*k8s.io/apimachinery* 和 *k8s.io/api* 的意义。
- en: '![Client-go versioning](assets/prku_0304.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Client-go 版本控制](assets/prku_0304.png)'
- en: Figure 3-4\. client-go versioning
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. client-go 版本控制
- en: API Versions and Compatibility Guarantees
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 版本和兼容性保证
- en: As seen in the previous section, the selection of the right API group versions
    may be crucial if you target different cluster versions with your code. Kubernetes
    versions all API groups. A common Kubernetes-style versioning scheme is used,
    which consists of alpha, beta, and GA (general availability) versions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一节所示，如果您的代码面向不同的集群版本，选择正确的 API 组版本可能至关重要。Kubernetes 使用常见的版本控制方案，其中包括 alpha、beta
    和 GA（一般可用）版本。
- en: 'The pattern is:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模式为：
- en: '`v1alpha1`, `v1alpha2`, `v2alpha1`, and so on are called *alpha versions* and
    considered unstable. This means:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v1alpha1`、`v1alpha2`、`v2alpha1` 等被称为 *alpha 版本*，并被认为是不稳定的。这意味着：'
- en: They might go away or change at any time, in any incompatible way.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能随时以任何不兼容的方式消失或更改。
- en: Data might be dropped, get lost, or become inaccessible from Kubernetes version
    to version.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可能会在 Kubernetes 的不同版本之间丢失、丢弃或变得不可访问。
- en: They are often disabled by default, if the administrator does not opt in manually.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，它们通常是禁用的，除非管理员手动选择启用。
- en: '`v1beta1`, `v1beta2`, `v2beta1`, and so on, are called *beta versions*. They
    are on the way to stability, which means:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v1beta1`、`v1beta2`、`v2beta1` 等被称为 *beta 版本*。它们正在通向稳定性，这意味着：'
- en: They will still exist for at least one Kubernetes release in parallel to the
    corresponding stable API version.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将与相应的稳定 API 版本并行存在至少一个 Kubernetes 发布周期。
- en: They will usually not change in incompatible ways, but there is no strict guarantee
    of that.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常不会以不兼容的方式更改，但没有严格的保证。
- en: Objects stored in a beta version will not be dropped or become inaccessible.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在 beta 版本中的对象不会丢失或变得不可访问。
- en: Beta versions are often enabled in clusters by default. But this might depend
    on the Kubernetes distribution or cloud provider used.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Beta 版本通常在集群中默认启用。但这可能取决于使用的 Kubernetes 分发版或云提供商。
- en: '`v1`, `v2`, and so on are stable, generally available APIs; that is:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v1`、`v2` 等是稳定的、通用可用的 API；也就是说：'
- en: They will stay.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将保留下去。
- en: They will be compatible.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将保持兼容性。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Kubernetes has a [formal deprecation policy](http://bit.ly/2FOrKU8) behind these
    rules of thumb. You can find many more details about which APIs constructs are
    considered compatible at the [Kubernetes community GitHub](http://bit.ly/2XKPWAX).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 在这些经验法则背后有一个[正式的废弃政策](http://bit.ly/2FOrKU8)。您可以在[Kubernetes 社区的
    GitHub](http://bit.ly/2XKPWAX)上找到关于哪些 API 构造被视为兼容的更多详细信息。
- en: 'In connection to API group versions, there are two important points to keep
    in mind:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 API 组版本，有两个重要的要点需要记住：
- en: 'API group versions apply to API resources as a whole, like the format of pods
    or services. In addition to API group versions, API resources might have single
    fields that are versioned orthogonally; for example, fields in stable APIs might
    be marked as alpha quality in their Go inline code documentation. The same rules
    as those just listed for API groups will apply to those fields. For example:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 组版本适用于整个 API 资源，例如 pods 或 services 的格式。除了 API 组版本外，API 资源可能还有单独版本化的字段；例如，在其
    Go 内联代码文档中，稳定的 API 中的字段可能被标记为 alpha 质量。对于这些字段，将适用于与 API 组相同的规则。例如：
- en: 'An alpha field in a stable API could become incompatible, lose data, or go
    away at any time. For example, the `ObjectMeta.Initializers` field, which was
    never promoted beyond alpha, will go away in the near future (it is deprecated
    in 1.14):'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定 API 中的 alpha 字段可能会变得不兼容，丢失数据或随时消失。例如，`ObjectMeta.Initializers` 字段，从未超出 alpha
    阶段，将在不久的将来消失（在 1.14 版本中已弃用）：
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It usually will be disabled by default and must be enabled with an API server
    feature gate, like so:'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，默认情况下将禁用它，并且必须使用 API 服务器功能门限进行启用，例如：
- en: '[PRE7]'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The behavior of the API server will differ from field to field. Some alpha fields
    will be rejected and some will be ignored if the corresponding feature gate is
    not enabled. This is documented in the field description (see `TTLSecondsAfterFinished`
    in the previous example).
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 服务器的行为将因字段而异。如果未启用相应的功能门限，则某些 alpha 字段将被拒绝，而某些将被忽略。这在字段描述中有文档记录（参见前面示例中的
    `TTLSecondsAfterFinished`）。
- en: Furthermore, API group versions play a role in accessing the API. Between different
    versions of the same resource, there is an on-the-fly conversion done by the API
    server. That is, you can access objects created in one version (e.g., `v1beta1`)
    in any of the other supported versions (e.g., `v1`) without any further work in
    your application. This is very convenient for building backward- and forward-compatible
    applications.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，API 组版本在访问 API 时起到了作用。在同一资源的不同版本之间，API 服务器会进行即时转换。也就是说，您可以访问在一个版本（例如 `v1beta1`）中创建的对象，而无需在应用程序中进行任何其他工作，即在任何其他支持的版本（例如
    `v1`）中。这对于构建向后和向前兼容的应用程序非常方便。
- en: Each object stored in `etcd` is stored in a specific version. By default, this
    is called the *storage version* of that resource. While the storage version can
    change from Kubernetes version to version, the object stored in `etcd` will not
    automatically be updated as of this writing. Hence, the cluster administrator
    has to make sure migration happens in time when Kubernetes clusters are updated,
    before old version support is dropped. There is no generic migration mechanism
    for that, and migration differs from Kubernetes distribution to distribution.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在 `etcd` 中的每个对象都以特定版本存储。默认情况下，这称为该资源的*存储版本*。虽然存储版本可以在 Kubernetes 的不同版本中更改，但在撰写本文时，存储在
    `etcd` 中的对象不会自动更新。因此，集群管理员必须确保在更新 Kubernetes 集群时及时进行迁移，以防止旧版本支持被弃用。目前没有通用的迁移机制，并且迁移因
    Kubernetes 发行版而异。
- en: For the application developer, though, this operational work should not matter
    at all. On-the-fly conversion will make sure the application has a unified picture
    of the objects in the cluster. The application will not even notice which storage
    version is in use. Storage versioning will be transparent to the written Go code.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于应用程序开发人员而言，这些操作工作实际上并不重要。即时转换将确保应用程序对集群中的对象有一个统一的视图。应用程序甚至不会注意到使用的是哪个存储版本。存储版本控制对编写的
    Go 代码是透明的。
- en: Kubernetes Objects in Go
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 中的 Go 对象
- en: In [“Creating and Using a Client”](#rest-client-config), we saw how to create
    a client for the core group in order to access pods in a Kubernetes cluster. In
    the following, we want to look in more detail at what a pod—or any other Kubernetes
    resource, for that matter—is in the world of Go.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“创建和使用客户端”](#rest-client-config)中，我们看到如何为核心组创建客户端，以便访问 Kubernetes 集群中的 pods。接下来，我们希望更详细地查看在
    Go 世界中的 pod — 或者说任何其他 Kubernetes 资源的 — 是什么。
- en: Kubernetes resources—or more precisely the objects—that are instances of a kind^([1](ch03.html#idm46336866123400))
    and are served as a resource by the API server are represented as structs. Depending
    on the kind in question, their fields of course differ. But on the other hand,
    they share a common structure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 资源——或更确切地说，作为 API 服务器资源提供的对象——作为结构体表示。根据问题中的种类，它们的字段当然不同。但另一方面，它们共享一个通用结构。
- en: 'From the type system point of view, Kubernetes objects fulfill a Go interface
    called `runtime.Object` from the package *k8s.io/apimachinery/pkg/runtime*, which
    actually is very simple:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型系统的角度来看，Kubernetes 对象实现了一个名为`runtime.Object`的 Go 接口，位于 *k8s.io/apimachinery/pkg/runtime*
    包中，实际上非常简单：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, `schema.ObjectKind` (from the *k8s.io/apimachinery/pkg/runtime/schema*
    package) is another simple interface:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`schema.ObjectKind`（来自 *k8s.io/apimachinery/pkg/runtime/schema* 包）是另一个简单的接口：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In other words, a Kubernetes object in Go is a data structure that can:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Go 中的 Kubernetes 对象是一个数据结构，可以：
- en: Return *and* set the GroupVersionKind
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回*和*设置 GroupVersionKind
- en: Be *deep-copied*
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行*深度复制*
- en: A *deep copy* is a clone of the data structure such that it does not share any
    memory with the original object. It is used wherever code has to mutate an object
    without modifying the original. See [“Global Tags”](ch05.html#global-tags) about
    code generation for details on how deep copy is implemented in Kubernetes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*深度复制* 是数据结构的克隆，不与原始对象共享任何内存。它在代码需要变异对象而不修改原始对象时使用。有关在 Kubernetes 中实现深度复制的详细信息，请参阅
    [“全局标签”](ch05.html#global-tags)。'
- en: Put simply, an object stores its type and allows cloning.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，一个对象存储其类型并允许克隆。
- en: TypeMeta
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeMeta
- en: 'While `runtime.Object` is only an interface, we want to know how it is actually
    implemented. Kubernetes objects from *k8s.io/api* implement the type getter and
    setter of `schema.ObjectKind` by embedding the `metav1.TypeMeta` struct from the
    package *k8s.io/apimachinery/meta/v1*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `runtime.Object` 只是一个接口，但我们想知道它是如何实际实现的。来自 *k8s.io/api* 的 Kubernetes 对象通过嵌入来实现
    `schema.ObjectKind` 的类型获取器和设置器，该结构从 *k8s.io/apimachinery/meta/v1* 包中的 `metav1.TypeMeta`
    结构中继承：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this, a pod declaration in Go looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，Go 中的 pod 声明看起来像这样：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, `TypeMeta` is embedded. Moreover, the pod type has JSON tags
    that also declare `TypeMeta` as being inlined.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`TypeMeta` 被嵌入其中。此外，pod 类型具有 JSON 标签，也声明了 `TypeMeta` 是内联的。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'This `",inline"` tag is actually superfluous with the Golang JSON en/decoders:
    embedded structs are automatically inlined.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `",inline"` 标签实际上在 Golang 的 JSON 解/编码器中是多余的：嵌入结构体会自动内联。
- en: This is different in the [YAML en/decoder *go-yaml/yaml*](http://bit.ly/2ZuPZy2),
    which was used in very early Kubernetes code in parallel to JSON. We inherited
    the [inline tag from that time](http://bit.ly/2IUGwcC), but today it is merely
    documentation without any effect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 [YAML 解/编码器 *go-yaml/yaml*](http://bit.ly/2ZuPZy2) 中是不同的，该解/编码器在 Kubernetes
    初期代码中与 JSON 并行使用。我们继承了 [那个时代的内联标签](http://bit.ly/2IUGwcC)，但今天它仅仅是文档，没有任何实际作用。
- en: The YAML serializers foudn in *k8s.io/apimachinery/pkg/runtime/serializer/yaml*
    use the *sigs.k8s.io/yaml* marshal and unmarshal functions. And these in turn
    encode and decode YAML via `interface{}`, and use the JSON encoder into and decoder
    from Golang API structs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*k8s.io/apimachinery/pkg/runtime/serializer/yaml* 中的 YAML 序列化器使用 *sigs.k8s.io/yaml*
    的编组和解组函数。而这些又通过 `interface{}` 编码和解码 YAML，并使用 Golang API 结构的 JSON 编码器和解码器。'
- en: This matches the YAML representation of a pod, which all Kubernetes users know:^([2](ch03.html#idm46336865870888))
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 pod 的 YAML 表示相匹配，所有 Kubernetes 用户都知道：^([2](ch03.html#idm46336865870888))
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The version is stored in `TypeMeta.APIVersion`, the kind in `TypeMeta.Kind`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 版本存储在 `TypeMeta.APIVersion` 中，种类存储在 `TypeMeta.Kind` 中。
- en: When running the example in [“Creating and Using a Client”](#rest-client-config)
    to get a pod from the cluster, notice that the pod object returned by the client
    does not actually have the kind and the version set. The convention in `client-go`–based
    applications is that these fields are empty in memory, and they are filled with
    the actual values on the wire only when they’re marshaled to JSON or protobuf.
    This is done automatically by the client, however, or, more precisely, by a versioning
    serializer.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 [“创建和使用客户端”](#rest-client-config) 中运行示例以从集群获取一个 pod 时，请注意客户端返回的 pod 对象实际上未设置种类和版本。基于
    `client-go` 的应用程序约定这些字段在内存中为空，并且只有在被编组为 JSON 或 protobuf 时才会填充实际值。这由客户端自动完成，更准确地说是由版本化序列化器完成。
- en: In other words, `client-go`–based applications check the Golang type of objects
    to determine the object at hand. This might differ in other frameworks, like the
    Operator SDK (see [“The Operator SDK”](ch06.html#operator-sdk)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，基于`client-go`的应用程序会检查对象的Golang类型，以确定手头的对象。在其他框架中可能会有所不同，比如操作员SDK（参见[“操作员SDK”](ch06.html#operator-sdk)）。
- en: ObjectMeta
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ObjectMeta
- en: 'In addition to `TypeMeta`, most top-level objects have a field of type `metav1.ObjectMeta`,
    again from the *k8s.io/apimachinery/pkg/meta/v1* package:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`TypeMeta`之外，大多数顶层对象都具有类型为`metav1.ObjectMeta`的字段，同样来自*k8s.io/apimachinery/pkg/meta/v1*包：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In JSON or YAML these fields are under *metadata*. For example, for the previous
    pod, `metav1.ObjectMeta` stores:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSON或YAML中，这些字段位于*metadata*下。例如，对于先前的pod，`metav1.ObjectMeta`存储：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In general, it contains all metalevel information like name, namespace, resource
    version (not to be confused with the API group version), several timestamps, and
    the well-known labels and annotations is part of `ObjectMeta`. See [“Anatomy of
    a type”](ch04.html#anatomy-of-CRD-types) for a deeper discussion of `ObjectMeta`
    fields.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，它包含所有的元级信息，如名称、命名空间、资源版本（不要与API组版本混淆）、几个时间戳以及著名的标签和注释，这些都是`ObjectMeta`的一部分。详细讨论`ObjectMeta`字段，请参阅[“类型解剖”](ch04.html#anatomy-of-CRD-types)。
- en: The resource version was discussed earlier in [“Optimistic Concurrency”](ch01.html#optimistic-concurrency).
    It is hardly ever read or written from `client-go` code. But it is one of the
    fields in Kubernetes that makes the whole system work. `resourceVersion` is part
    of `ObjectMeta` because each object with embedded `ObjectMeta` corresponds to
    a key in `etcd` where the `resourceVersion` value originated.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“乐观并发”](ch01.html#optimistic-concurrency)中已经讨论过资源版本。在`client-go`代码中几乎不会读取或写入。但它是使整个系统工作的Kubernetes字段之一。`resourceVersion`作为`ObjectMeta`的一部分，因为每个具有嵌入`ObjectMeta`的对象对应于`etcd`中的键，其中`resourceVersion`值起源于此。
- en: spec and status
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: spec和status
- en: 'Finally, nearly every top-level object has a `spec` and a `status` section.
    This convention comes from the declarative nature of the Kubernetes API: `spec`
    is the user desire, and `status` is the outcome of that desire, usually filled
    by a controller in the system. See [“Controllers and Operators”](ch01.html#ch_controllers-operators)
    for a detailed discussion of controllers in Kubernetes.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，几乎每个顶级对象都有一个`spec`和一个`status`部分。这一约定来自Kubernetes API的声明性质：`spec`是用户的愿望，而`status`是这个愿望的结果，通常由系统中的控制器填充。有关Kubernetes中控制器的详细讨论，请参阅[“控制器和操作员”](ch01.html#ch_controllers-operators)。
- en: There are only a few exceptions to the `spec` and `status` convention in the
    system—for example, endpoints in the core group, or RBAC objects like `ClusterRole`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中`spec`和`status`约定只有几个例外，例如核心组中的端点或类似`ClusterRole`的RBAC对象。
- en: Client Sets
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端集
- en: In the introductory example in [“Creating and Using a Client”](#rest-client-config),
    we saw that `kubernetes.NewForConfig(config)` gives us a *client set*. A client
    set gives access to clients for multiple API groups and resources. In the case
    of `kubernetes.NewForConfig(config)` from *k8s.io/client-go/kubernetes*, we get
    access to all API groups and resources defined in *k8s.io/api*. This is, with
    a few exceptions—such as `APIServices` (for aggregated API servers) and `CustomResourceDefinition`
    (see [Chapter 4](ch04.html#ch_crds))—the whole set of resources served by the
    Kubernetes API server.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“创建和使用客户端”](#rest-client-config)的介绍示例中，我们看到`kubernetes.NewForConfig(config)`给了我们一个*客户端集*。客户端集提供对多个API组和资源的客户端访问。对于来自*k8s.io/client-go/kubernetes*的`kubernetes.NewForConfig(config)`，我们获得了所有在*k8s.io/api*中定义的API组和资源的访问权限。这是整个由Kubernetes
    API服务器提供的资源集，除了一些例外，如`APIServices`（用于聚合API服务器）和`CustomResourceDefinition`（参见[第4章](ch04.html#ch_crds)）。
- en: In [Chapter 5](ch05.html#ch_autocodegen), we will explain how these client sets
    are actually generated from the API types (*k8s.io/api*, in this case). Third-party
    projects with custom APIs use more than just the Kubernetes client sets. What
    all of the client sets have in common is a REST config (e.g., returned by `clientcmd.BuildConfigFromFlags("",
    *kubeconfig)`, like in the example).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html#ch_autocodegen)中，我们将解释这些客户端集是如何从API类型（*k8s.io/api*，在这种情况下）实际生成的。具有自定义API的第三方项目使用的不仅仅是Kubernetes客户端集。所有客户端集共同拥有的是REST配置（例如，由`clientcmd.BuildConfigFromFlags("",
    *kubeconfig)`返回，就像示例中的那样）。
- en: 'The client set main interface in *k8s.io/client-go/kubernetes/typed* for Kubernetes-native
    resources looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes本地资源的`k8s.io/client-go/kubernetes/typed`中的客户端集主接口如下所示：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There used to be unversioned methods in this interface—for example, just `Apps()
    appsv1.AppsV1Interface`—but they were deprecated as of Kubernetes 1.14–based `client-go`
    11.0\. As mentioned before, it is seen as a good practice to be very explicit
    about the version of an API group that an application uses.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在此接口中曾经存在未版本化的方法——例如，只有 `Apps() appsv1.AppsV1Interface`——但它们在 Kubernetes 1.14
    及基于 `client-go` 11.0 之后已被弃用。如前所述，明确指定应用程序使用的 API 组的版本被视为一种良好的实践。
- en: Every client set also gives access to the discovery client (it will be used
    by the `RESTMappers`; see [“REST Mapping”](#RESTMapping) and [“Using the API from
    the Command Line”](ch02.html#api-cli)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端集还可以访问发现客户端（它将被 `RESTMappers` 使用；参见 [“REST 映射”](#RESTMapping) 和 [“使用命令行访问
    API”](ch02.html#api-cli)）。
- en: 'Behind each `GroupVersion` method (e.g., `AppsV1beta1`), we find the resources
    of the API group—for example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 `GroupVersion` 方法的背后（例如 `AppsV1beta1`），我们找到 API 组的资源——例如：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'with `RESTClient` being a generic *REST client*, and one interface per resource,
    as in:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `RESTClient` 是一个通用的 *REST 客户端*，每个资源都有一个接口，如下所示：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Depending on the scope of the resource—that is, whether it is cluster or namespace
    scoped—the accessor (here `DeploymentGetter`) may or may not have a `namespace`
    argument.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据资源的范围——即集群范围还是命名空间范围——访问器（这里是 `DeploymentGetter`）可能有也可能没有 `namespace` 参数。
- en: The `DeploymentInterface` gives access to all the supported verbs of the resource.
    Most of them are self-explanatory, but those requiring additional commentary are
    described next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeploymentInterface` 提供对资源支持的所有动词的访问。其中大多数都是不言自明的，但需要额外评论的将在接下来描述。'
- en: 'Status Subresources: UpdateStatus'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态子资源：UpdateStatus
- en: Deployments have a so-called *status subresource*. This means that `UpdateStatus`
    uses an additional HTTP endpoint suffixed with `/status`. While updates on the
    */apis/apps/v1beta1/namespaces/*`ns`*/deployments/*`name`** endpoint can change
    only the spec of the deployment, the endpoint /*apis/apps/v1beta1/namespaces/*`ns`*/deployments/*`name`*/status*
    can change only the status of the object. This is useful in order to set different
    permissions for spec updates (done by a human) and status updates (done by a controller).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 部署有所谓的*状态子资源*。这意味着 `UpdateStatus` 使用一个额外的 HTTP 终端点，后缀为 `/status`。虽然在 */apis/apps/v1beta1/namespaces/*`ns`*/deployments/*`name`**
    终端点上的更新只能更改部署的规范，但在 */apis/apps/v1beta1/namespaces/*`ns`*/deployments/*`name`*/status*
    终端点上的更新只能更改对象的状态。这在为规范更新（由人类完成）和状态更新（由控制器完成）设置不同权限时非常有用。
- en: By default the `client-gen` (see [“client-gen Tags”](ch05.html#clientgen-tags))
    generates the `UpdateStatus()` method. The existence of the method does not guarantee
    that the resource actually supports the subresource. This will be important when
    we’re working with CRDs in [“Subresources”](ch04.html#crd-subresources).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`client-gen`（参见 [“client-gen 标签”](ch05.html#clientgen-tags)）会生成 `UpdateStatus()`
    方法。方法的存在并不保证资源实际上支持子资源。在处理 CRD 时这一点非常重要，见 [“子资源”](ch04.html#crd-subresources)。
- en: Listings and Deletions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出和删除
- en: '`DeleteCollection` allows us to delete multiple objects of a namespace at once.
    The `ListOptions` parameter allows us to define which objects should be deleted
    using a *field* or *label selector*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteCollection` 允许我们一次性删除命名空间中的多个对象。`ListOptions` 参数允许我们使用*字段*或*标签选择器*定义要删除的对象：'
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Watches
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Watches
- en: '`Watch` gives an event interface for all changes (adds, removes, and updates)
    to objects. The returned `watch.Interface` from *k8s.io/apimachinery/pkg/watch*
    looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Watch` 为所有对象的更改（添加、删除和更新）提供事件接口。来自 *k8s.io/apimachinery/pkg/watch* 的返回的 `watch.Interface`
    如下所示：'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result channel of the `watch` interface returns three kinds of events:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch` 接口的结果通道返回三种类型的事件：'
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While it is tempting to use this interface directly, in practice it is actually
    discouraged in favor of informers (see [“Informers and Caching”](#informers)).
    Informers are a combination of this event interface and an in-memory cache with
    indexed lookup. This is by far the most common use case for watches. Under the
    hood informers first call `List` on the client to get the set of all objects (as
    a baseline for the cache) and then `Watch` to update the cache. They handle error
    conditions correctly—that is, recover from network issues or other cluster problems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接使用这个接口很诱人，但实际上不鼓励这样做，而是推荐使用 informers（参见 [“Informers 和缓存”](#informers)）。Informers
    是这个事件接口和带有索引查找的内存缓存的组合。这是观察事件最常见的用例。在幕后，informers 首先调用客户端的 `List` 方法获取所有对象的集合（作为缓存的基线），然后调用
    `Watch` 方法更新缓存。它们可以正确处理错误条件——即从网络问题或其他集群问题中恢复。
- en: Client Expansion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端扩展
- en: '`DeploymentExpansion` is actually an empty interface. It is used to add custom
    client behavior, but it’s hardly used in Kubernetes nowadays. Instead, the client
    generator allows us to add custom methods in a declarative way (see [“client-gen
    Tags”](ch05.html#clientgen-tags)).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeploymentExpansion` 实际上是一个空接口。它用于以声明方式添加自定义客户端行为，但在当前 Kubernetes 中很少使用。相反，客户端生成器允许我们以声明方式添加自定义方法（参见
    [“client-gen Tags”](ch05.html#clientgen-tags)）。'
- en: Note again that all of those methods in `DeploymentInterface` neither expect
    valid information in the `TypeMeta` fields `Kind` and `APIVersion`, nor set those
    fields on `Get()` and `List()` (see also [“TypeMeta”](#TypeMeta)). These fields
    are filled with real values only on the wire.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，`DeploymentInterface` 中的所有方法既不期望 `TypeMeta` 字段 `Kind` 和 `APIVersion` 中的有效信息，也不在
    `Get()` 和 `List()` 方法中设置这些字段（另见 [“TypeMeta”](#TypeMeta)）。这些字段仅在传输时填充真实的值。
- en: Client Options
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端选项
- en: It is worth looking at the different options we can set when creating a client
    set. In the note before [“Versioning and Compatibility”](#versioning-capability),
    we saw that we can switch to the protobuf wire format for native Kubernetes types.
    Protobuf is more efficient than JSON (both spacewise and for the CPU load of the
    client and server) and therefore preferable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在创建客户端集时，我们可以设置不同的选项。在 [“版本和兼容性”](#versioning-capability) 之前的注释中，我们看到我们可以切换到原生
    Kubernetes 类型的 protobuf 传输格式。Protobuf 比 JSON 更高效（在空间和客户端与服务器的 CPU 负载方面），因此更可取。
- en: 'For debugging purposes and readability of metrics, it is often helpful to differentiate
    between different clients accessing the API server. To do so, we can set the *user
    agent* field in the REST config. The default value is `binary/version (os/arch)
    kubernetes/commit`; for example, `kubectl` will use a user agent like `kubectl/v1.14.0
    (darwin/amd64) kubernetes/d654b49`. If that pattern does not suffice for the setup,
    it can be customized like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 出于调试目的和指标的可读性，区分访问 API 服务器的不同客户端通常很有帮助。为此，我们可以在 REST 配置中设置 *用户代理* 字段。默认值是 `binary/version
    (os/arch) kubernetes/commit`，例如，`kubectl` 将使用类似 `kubectl/v1.14.0 (darwin/amd64)
    kubernetes/d654b49` 的用户代理。如果这种模式不足以满足设置要求，可以进行定制，如下所示：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Other values often overridden in the REST config are those for client-side
    *rate limiting* and *timeouts*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: REST 配置中经常被覆盖的其他值包括客户端端的 *速率限制* 和 *超时*：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `QPS` value defaults to `5` requests per second, with a burst of `10`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPS` 值默认为每秒 `5` 个请求，突发为 `10`。'
- en: The timeout has no default value, at least not in the client REST config. By
    default the Kubernetes API server will timeout every request that is not a *long-running*
    request after 60 seconds. A long-running request can be a watch request or unbounded
    requests to subresources like */exec*, */portforward*, or */proxy*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 超时在客户端 REST 配置中没有默认值，至少 Kubernetes API 服务器会在 60 秒后超时每个不是 *长期运行* 请求的请求。长期运行请求可以是观察请求或对子资源如
    */exec*、*/portforward* 或 */proxy* 的无边界请求。
- en: Informers and Caching
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Informers 和 缓存
- en: 'The client interface in [“Client Sets”](#clientsets) includes the `Watch` verb,
    which offers an event interface that reacts to changes (adds, removes, updates)
    of objects. Informers give a higher-level programming interface for the most common
    use case for watches: in-memory caching and fast, indexed lookup of objects by
    name or other properties in-memory.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[“客户端集”](#clientsets) 中的客户端接口包括 `Watch` 动词，提供了一个事件接口，用于响应对象的变更（添加、移除、更新）。Informers
    为观察的最常见用例提供了更高级的编程接口：内存缓存和通过名称或其他属性在内存中快速索引查找对象。'
- en: A controller that accesses the API server every time it needs an object creates
    a high load on the system. In-memory caching using informers is the solution to
    this problem. Moreover, informers can react to changes of objects nearly in real-time
    instead of requiring polling requests.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每当控制器需要对象时都会访问 API 服务器，这会给系统带来很大的负载。使用内存中的缓存通过 informers 是解决这个问题的方案。此外，informers
    几乎可以实时地响应对象的变更，而不需要轮询请求。
- en: '[Figure 3-5](#informers-figure) shows the conceptional pattern of informers;
    specifically, they:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-5](#informers-figure) 展示了 informers 的概念模式；特别是它们：'
- en: Get input from the API server as events.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为事件从 API 服务器获取输入。
- en: Offer a client-like interface called `Lister` to get and list objects from the
    in-memory cache.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个名为 `Lister` 的类似客户端的接口，用于从内存缓存中获取和列出对象。
- en: Register event handlers for adds, removes, and updates.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册用于添加、移除和更新的事件处理程序。
- en: Implement the in-memory cache using a *store*.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *store* 实现内存缓存。
- en: '![Informers](assets/prku_0305.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Informers](assets/prku_0305.png)'
- en: Figure 3-5\. Informers
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-5\. Informers
- en: 'Informers also have advanced error behavior: when the long-running watch connection
    breaks down, they recover from it by trying another watch request, picking up
    the event stream without losing any events. If the outage is long, and the API
    server lost events because `etcd` purged them from its database before the new
    watch request was successful, the informer will relist all objects.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通知器还具有先进的错误处理行为：当长时间运行的监视连接断开时，它们通过尝试另一个监视请求来从中恢复，捕捉事件流而不会丢失任何事件。如果中断时间很长，并且
    API 服务器在新的监视请求成功之前因`etcd`从其数据库中清除了事件而丢失了事件，则通知器将重新列出所有对象。
- en: 'Next to *relists*, there is a configurable *resync period* for reconciliation
    between the in-memory cache and the business logic: the registered event handlers
    will be called for all objects each time this period has passed. Common values
    are in minutes (e.g., 10 or 30 minutes).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*重新列出*，还有一个可配置的*重新同步周期*，用于在内存缓存和业务逻辑之间进行协调：每当此周期经过时，将为所有对象调用注册的事件处理程序。常见的值以分钟为单位（例如，10分钟或30分钟）。
- en: Warning
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The resync is purely in-memory and *does not trigger a call to the server*.
    This used to be different but was [eventually changed](http://bit.ly/2FmeMge)
    because the error behavior of the watch mechanism had been improved enough to
    make relists unnecessary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重新同步仅在内存中进行，*不会触发对服务器的调用*。这曾经有所不同，但因为监视机制的错误行为得到了改进，使得重新列出不再必要，最终进行了[更改](http://bit.ly/2FmeMge)。
- en: All this advanced and battle-proven error behavior is a good reason for using
    informers instead of rolling out custom logic using the client `Watch()` method
    directly. Informers are used everywhere in Kubernetes itself and are one of the
    main architectural concepts in the Kubernetes API design.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些先进且经过实战验证的错误处理行为是使用通知器而不是直接使用客户端`Watch()`方法部署自定义逻辑的一个很好的理由。通知器在 Kubernetes
    自身的各个地方都被使用，并且是 Kubernetes API 设计中的主要架构概念之一。
- en: While informers are preferred over polling, they create load on the API server.
    One binary should instantiate only one informer per GroupVersionResource. To make
    sharing of informers easy, we can instantiate an informer by using the *shared
    informer factory*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通知器优于轮询，但它们会给 API 服务器带来负载。一个二进制文件应该仅实例化每个 GroupVersionResource 一个通知器。为了简化通知器的共享，我们可以使用*共享的通知器工厂*来实例化通知器。
- en: The shared informer factory allows informers to be shared for the same resource
    in an application. In other words, different control loops can use the same watch
    connection to the API server under the hood. For example, the `kube-controller-manager`,
    one of the main Kubernetes cluster components (see [“The API Server”](ch02.html#api-server)),
    has a larger, two-digit number of controllers. But for each resource (e.g., pods),
    there is only one informer in the process.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的通知器工厂允许在应用程序中为相同资源共享通知器。换句话说，不同的控制循环可以在幕后共用同一个对 API 服务器的监视连接。例如，`kube-controller-manager`，Kubernetes
    集群的主要组件之一（参见[“API 服务器”](ch02.html#api-server)），有多个两位数的控制器。但对于每个资源（例如 pods），在进程中只有一个通知器。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Always use a shared informer factory to instantiate informers. Don’t try to
    instantiate informers manually. The overhead is minimal, and a nontrivial controller
    binary that does not use shared informers probably is opening multiple watch connections
    for the same resource somewhere.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用共享的通知器工厂来实例化通知器。不要试图手动实例化通知器。开销很小，一个不使用共享通知器的复杂控制器二进制文件可能在某个地方为同一资源打开多个监视连接。
- en: 'Starting with a REST config (see [“Creating and Using a Client”](#rest-client-config)),
    it is easy to create a shared informer factory using a client set. The informers
    are generated by a code generator and shipped as part of `client-go` for the standard
    Kubernetes resources in *k8s.io/client-go/informers*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从 REST 配置开始（参见[“创建和使用客户端”](#rest-client-config)），使用客户端集轻松创建共享的通知器工厂。通知器由代码生成器生成，并作为`client-go`的一部分提供给标准
    Kubernetes 资源在*k8s.io/client-go/informers*中：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The example shows how to get a shared informer for pods.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了如何获取 pods 的共享通知器。
- en: You can see that informers allow for the addition of event handlers for the
    three cases *add*, *update*, and *delete*. These are usually used to trigger the
    business logic of a controller—that is, to process a certain object again (see
    [“Controllers and Operators”](ch01.html#ch_controllers-operators)). Often those
    handlers just add the modified object into a work queue.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，通知器允许为三种情况*添加*、*更新*和*删除*添加事件处理程序。这些通常用于触发控制器的业务逻辑，即再次处理特定对象（参见[“控制器和操作员”](ch01.html#ch_controllers-operators)）。通常，这些处理程序只是将修改后的对象添加到工作队列中。
- en: Also note that many event handlers can be added. The whole shared informer factory
    concept exists only because this is so common in controller binaries with many
    control loops, each installing event handlers to add objects to their own work
    queue.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，可以添加许多事件处理程序。整个共享Informer工厂概念之所以存在，是因为在具有多个控制循环的控制器二进制文件中，每个循环都安装事件处理程序来将对象添加到它们自己的工作队列中。
- en: After registering handlers, the shared informer factory has to be started. There
    are Go routines under the hood that do the actual calls to the API server. The
    `Start` method (with a stop channel to control the lifecycle) starts these Go
    routines, and the `WaitForCacheSync()` method makes the code wait for the first
    `List` calls to the clients to finish. If the controller logic requires that the
    cache is filled, this `WaitForCacheSync` call is essential.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册处理程序之后，共享Informer工厂必须启动。在幕后有Go协程来实际调用API服务器。`Start`方法（带有停止通道以控制生命周期）启动这些Go协程，而`WaitForCacheSync()`方法则使代码等待第一个`List`调用完成。如果控制器逻辑要求填充缓存，则`WaitForCacheSync`调用是必不可少的。
- en: In general, the event interface of the watches behind the scenes leads to a
    certain lag. In a setup with proper capacity planning, this lag is not huge. Of
    course, it is good practice to measure this lag using metrics. But the lag exists
    regardless, so the application logic has be built in such a way that the lag does
    not harm the behavior of the code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，手表背后的事件接口会导致某种程度的滞后。在进行适当的容量规划设置时，这种滞后并不严重。当然，使用度量衡来测量这种滞后是一个好的实践。但无论如何，这种滞后是存在的，因此应用程序的逻辑必须构建得足够健壮，以免影响代码的行为。
- en: Warning
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The lag of informers can lead to races between changes the controller makes
    with `client-go` directly on the API server, and the state of the world as known
    by the informers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Informer的滞后可能导致控制器在直接使用`client-go`在API服务器上进行更改时与Informer知道的世界状态之间发生竞争。
- en: If the controller changes an object, the informer in the same process has to
    wait until the corresponding event arrives and the in-memory store is then updated.
    This process is not instantaneous, and another controller work loop run might
    be started through another trigger before the previous change has become visible.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制器更改一个对象，则同一进程中的Informer必须等待相应事件到达并更新内存存储。这个过程不是即时的，在前一个更改可见之前可能会通过另一个触发器启动另一个控制器工作循环。
- en: The resync interval of 30 seconds in this example leads to a complete set of
    events being sent to the registered `UpdateFunc` such that the controller logic
    is able to reconcile its state with that of the API server. By comparing the `ObjectMeta.resourceVersion`
    field, it is possible to distinguish a real update from a resync.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，30秒的重新同步间隔会导致所有事件的完整集合发送到注册的`UpdateFunc`，以便控制器逻辑能够将其状态与API服务器的状态协调。通过比较`ObjectMeta.resourceVersion`字段，可以区分真实更新和重新同步。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Choosing a good resync interval depends on the context. For example, 30 seconds
    is pretty short. In many situations several minutes, or even 30 minutes, is a
    good choice. In the worst case, 30 minutes means that it takes 30 minutes until
    a bug in the code (e.g., a lost signal due to bad error handling) is repaired
    via reconciliation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个良好的重新同步间隔取决于上下文。例如，30秒相当短。在许多情况下，几分钟，甚至30分钟，是一个不错的选择。在最坏的情况下，30分钟意味着需要30分钟才能通过协调来修复代码中的错误（例如，由于错误处理不当而丢失信号）。
- en: Also note that the final line in the example calling `Get("client-go")` is purely
    in-memory; there is no access to the API server. Objects in the in-memory store
    cannot be modified directly. Instead, the client set must be used for any write
    access to the resources. The informer will then get events from the API server
    and update its in-memory store.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在例子中调用`Get("client-go")`的最后一行纯粹是在内存中进行的；没有访问API服务器。在内存存储中的对象不能直接修改。相反，必须使用客户端集来访问资源进行任何写操作。然后，Informer将从API服务器获取事件并更新其内存存储。
- en: 'The informer constructor `NewSharedInformerFactory` in the example caches all
    objects of a resource in all namespaces in the store. If this is too much for
    the application, there is an alternative constructor with more flexibility:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，Informer构造函数`NewSharedInformerFactory`会在存储中缓存所有命名空间中资源的所有对象。如果这对应用程序来说太多，还有一个更灵活的替代构造函数：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It allows us to specify a namespace and to pass a `TweakListOptionsFunc`, which
    may mutate the `ListOptions` struct used to list and watch objects using the `List`
    and `Watch` calls of the client. It can be used to set *label* or *field selectors*,
    for example.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们指定一个命名空间，并传递一个`TweakListOptionsFunc`，它可以改变用于通过客户端的`List`和`Watch`调用列出和监视对象的`ListOptions`结构体。例如，它可以用来设置*标签*或*字段选择器*。
- en: Informers are one of the building blocks of controllers. In [Chapter 6](ch06.html#ch_operator-solutions)
    we will see what a typical `client-go`-based controller looks like. After the
    clients and informers, the third main building block is the work queue. Let’s
    look at it now.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Informers是控制器的构建块之一。在[第6章](ch06.html#ch_operator-solutions)中，我们将看到一个基于`client-go`的典型控制器的样子。在客户端和Informers之后，第三个主要的构建块是工作队列。现在让我们来看一下。
- en: Work Queue
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作队列
- en: A work queue is a data structure. You can add elements and take elements out
    of the queue, in an order predefined by the queue. Formally, this kind of queue
    is called a *priority queue*. `client-go` provides a powerful implementation for
    the purpose of building controllers in [*k8s.io/client-go/util/workqueue*](http://bit.ly/2IV0JPz).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 工作队列是一种数据结构。您可以向队列中添加元素并取出元素，按照队列预定义的顺序。严格来说，这种类型的队列被称为*优先级队列*。`client-go`提供了一个强大的实现，用于构建控制器在[*k8s.io/client-go/util/workqueue*](http://bit.ly/2IV0JPz)。
- en: 'More precisely, the package contains a number of variants for different purposes.
    The base interface implemented by all variants looks like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 更确切地说，该软件包包含了几个用于不同目的的变体。所有变体实现的基本接口看起来是这样的：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here `Add(item)` adds an item, `Len()` gives the length, and `Get()` returns
    an item with the highest priority (and it blocks until one is available). Every
    item returned by `Get()` needs a `Done(item)` call when the controller has finished
    processing it. Meanwhile, a repeated `Add(item)` will only mark the item as dirty
    such that it is readded when `Done(item)` has been called.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Add(item)`添加一个项目，`Len()`返回长度，`Get()`返回具有最高优先级的项目（并阻塞直到可用）。每个由`Get()`返回的项目在控制器处理完毕后需要调用`Done(item)`。与此同时，重复的`Add(item)`只会将项目标记为脏，直到调用了`Done(item)`后重新添加它。
- en: 'The following queue types are derived from this generic interface:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下队列类型是从这个通用接口派生的：
- en: '`DelayingInterface` can add an item at a later time. This makes it easier to
    requeue items after failures without ending up in a hot-loop:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DelayingInterface` 可以在稍后时间添加项目。这使得在失败后重新排队项目更容易，而不会陷入热循环：'
- en: '[PRE26]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`RateLimitingInterface` rate-limits items being added to the queue. It extends
    the `DelayingInterface:`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RateLimitingInterface` 限制添加到队列中的项目。它扩展了`DelayingInterface`：'
- en: '[PRE27]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Most interesting here is the `Forget(item)` method: it resets the back-off
    of the given item. Usually, it will be called when an item has been processed
    successfully.'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里最有趣的是`Forget(item)`方法：它重置给定项目的退避。通常，在成功处理项目后会调用它。
- en: 'The rate limiting algorithm can be passed to the constructor `NewRateLimitingQueue`.
    There are several rate limiters defined in the same package, such as the `BucketRateLimiter`,
    the `ItemExponentialFailureRateLimiter`, the `ItemFastSlowRateLimiter`, and the
    `MaxOfRateLimiter`. For more details, you can refer to the package documentation.
    Most controllers will just use the `DefaultControllerRateLimiter() *RateLimiter`
    functions, which gives:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以将速率限制算法传递给构造函数`NewRateLimitingQueue`。同一软件包中定义了几种速率限制器，如`BucketRateLimiter`、`ItemExponentialFailureRateLimiter`、`ItemFastSlowRateLimiter`和`MaxOfRateLimiter`。有关更多详细信息，请参阅软件包文档。大多数控制器将只使用`DefaultControllerRateLimiter()
    *RateLimiter`函数，这给出：
- en: An exponential back-off starting at 5 ms and going up to 1,000 seconds, doubling
    the delay on each error
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以5毫秒开始的指数退避，最高达1,000秒，每次错误时延迟加倍。
- en: A maximal rate of 10 items per second and 100 items burst
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒最大10个项目和100个项目突发
- en: Depending on the context, you might want to customize the values. A 1,000 seconds
    maximal back-off per item is a lot for certain controller applications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，您可能希望自定义这些值。对于某些控制器应用程序来说，每个项目的最大1,000秒退避是很多的。
- en: API Machinery in Depth
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解API Machinery
- en: The API Machinery repository implements the basics of the Kubernetes type system.
    But what is this type system exactly? What is a type to begin with?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: API Machinery存储库实现了Kubernetes类型系统的基础。但是，这个类型系统到底是什么？类型首先是什么？
- en: The term *type* actually does not exist in the terminology of API Machinery.
    Instead, it refers to *kinds*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*类型*实际上在API Machinery的术语中并不存在。相反，它指的是*种类*。
- en: Kinds
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 种类
- en: Kinds are divided into API groups and are versioned, as we already have seen
    in [“API Terminology”](ch02.html#terminology). Therefore, a core term in the API
    Machinery repository is GroupVersionKind, or *GVK* for short.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 类型被分为 API 组并进行版本化，正如我们在 [“API Terminology”](ch02.html#terminology) 中已经看到的那样。因此，API
    Machinery 代码库中的核心术语是 GroupVersionKind，简称为 *GVK*。
- en: In Go, each GVK corresponds to one Go type. In contrast, a Go type can belong
    to multiple GVKs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，每个 GVK 对应于一个 Go 类型。相反，一个 Go 类型可以属于多个 GVK。
- en: Kinds do not formally map one-to-one to HTTP paths. Many kinds have HTTP REST
    endpoints that are used to access objects of the given kind. But there are also
    kinds without any HTTP endpoint (e.g., [*admission.k8s.io/v1beta1.AdmissionReview*](http://bit.ly/2XJXBQD),
    which is used to call out to a webhook). There are also kinds that are returned
    from many endpoints—for example, [*meta.k8s.io/v1.Status*](http://bit.ly/31Ktjvz),
    which is returned by all endpoints to report a nonobject status like an error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 类型并不正式地一对一映射到 HTTP 路径。许多类型有用于访问给定类型对象的 HTTP REST 终点。但也有一些没有任何 HTTP 终点的类型（例如，[*admission.k8s.io/v1beta1.AdmissionReview*](http://bit.ly/2XJXBQD)，用于调用
    webhook）。还有一些类型从多个终点返回，例如，[*meta.k8s.io/v1.Status*](http://bit.ly/31Ktjvz)，它由所有终点返回以报告非对象状态，如错误。
- en: By convention, kinds are formatted in [CamelCase](http://bit.ly/31IqMSC) like
    words and are usually singular. Depending on the context, their concrete format
    differs. For CustomResourceDefinition kinds, it must be a DNS path label (RFC
    1035).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 根据惯例，类型采用类似单词的 [CamelCase](http://bit.ly/31IqMSC) 格式，并且通常是单数形式。根据上下文，它们的具体格式不同。对于
    CustomResourceDefinition 类型，它必须是 DNS 路径标签（RFC 1035）。
- en: Resources
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: In parallel to kinds, as we saw in [“API Terminology”](ch02.html#terminology),
    there is the concept of a *resource*. Resources are again grouped and versioned,
    leading to the term *GroupVersionResource*, or *GVR* for short.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型并行的是资源，正如我们在 [“API Terminology”](ch02.html#terminology) 中看到的那样，还有一个 *resource*
    概念。资源再次分组并进行版本化，导致术语 *GroupVersionResource*，简称为 *GVR*。
- en: Each GVR corresponds to one HTTP (base) path. GVRs are used to identify REST
    endpoints of the Kubernetes API. For example, the GVR *apps/v1.deployments* maps
    to */apis/apps/v1/namespaces/`namespace`/deployments*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 GVR 对应一个 HTTP（基本）路径。GVR 用于标识 Kubernetes API 的 REST 终点。例如，GVR *apps/v1.deployments*
    映射到 */apis/apps/v1/namespaces/`namespace`/deployments*。
- en: Client libraries use this mapping to construct the HTTP path to access a GVR.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端库使用此映射来构造访问 GVR 的 HTTP 路径。
- en: By convention, resources are lowercase and plural, usually corresponding to
    the plural words of the parallel kind. They must conform to the DNS path label
    format (RFC 1025). As resources map directly to HTTP paths, this is not surprising.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，资源是小写且复数形式，通常对应于并行类型的复数词。它们必须符合 DNS 路径标签格式（RFC 1025）。由于资源直接映射到 HTTP 路径，这一点并不奇怪。
- en: REST Mapping
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST 映射
- en: The mapping of a GVK to a GVR is called *REST mapping*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: GVK 到 GVR 的映射称为 *REST 映射*。
- en: 'A `RESTMapper` is the [Golang interface](http://bit.ly/2Y7wYS8) that enables
    us to request the GVR for a GVK:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESTMapper` 是一个 [Golang 接口](http://bit.ly/2Y7wYS8)，它使我们能够请求 GVK 的 GVR：'
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'where the type `RESTMapping` on the right looks like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的 `RESTMapping` 类型看起来像这样：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In addition, a `RESTMapper` provides a number of convenience functions:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`RESTMapper` 提供了许多便利函数：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, a partial GVR means that not all fields are set. For example, imagine
    you type `**kubectl get pods**`. In that case, the group and the version are missing.
    A `RESTMapper` with enough information might still manage to map it to the `v1
    Pods` kind.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，部分 GVR 意味着并非所有字段都已设置。例如，想象一下你输入 `**kubectl get pods**`。在这种情况下，组和版本是缺失的。具有足够信息的
    `RESTMapper` 可能仍然能够将其映射到 `v1 Pods` 类型。
- en: For the preceding deployment example, a `RESTMapper` that knows about deployments
    (more about what this means in a bit) will map [*apps/v1.Deployment*](http://bit.ly/2IujaLU)
    to *apps/v1.deployments* as a namespaced resource.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前述部署示例，一个了解部署的 `RESTMapper`（稍后会详细介绍这意味着什么）将 [*apps/v1.Deployment*](http://bit.ly/2IujaLU)
    映射到 *apps/v1.deployments* 作为命名空间资源。
- en: 'There are multiple different implementations of the `RESTMapper` interface.
    The most important one for client applications is the discovery-based [`DeferredDiscoveryRESTMapper`](http://bit.ly/2XroxUq)
    in the package *k8s.io/client-go/restmapper*: it uses discovery information from
    the Kubernetes API server to dynamically build up the REST mapping. It will also
    work with non-core resources like custom resources.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESTMapper` 接口有多种不同的实现方式。对于客户端应用程序来说，最重要的是基于发现的 [`DeferredDiscoveryRESTMapper`](http://bit.ly/2XroxUq)，位于包
    *k8s.io/client-go/restmapper* 中：它使用来自 Kubernetes API 服务器的发现信息动态构建 REST 映射。它还可以处理像自定义资源这样的非核心资源。'
- en: Scheme
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scheme
- en: The final core concept we want to present here in the context of the Kubernetes
    type system is the [*scheme*](http://bit.ly/2N1PGJB) in the package *k8s.io/apimachinery/pkg/runtime*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Kubernetes 类型系统的上下文中想要展示的最后一个核心概念是[*方案*](http://bit.ly/2N1PGJB)，位于包 *k8s.io/apimachinery/pkg/runtime*
    中。
- en: 'A scheme connects the world of Golang with the implementation-independent world
    of GVKs. The main feature of a scheme is the mapping of Golang types to possible
    GVKs:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方案连接了 Golang 的世界和独立于实现的 GVK 的世界。方案的主要特性是将 Golang 类型映射到可能的 GVK：
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we saw in [“Kubernetes Objects in Go”](#kube-objects), an object can return
    its group and kind via the `GetObjectKind() schema.ObjectKind` method. However,
    these values are empty most of the time and are therefore pretty useless for identification.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [“在 Go 中的 Kubernetes 对象”](#kube-objects) 中看到的，一个对象可以通过 `GetObjectKind()
    schema.ObjectKind` 方法返回其组和种类。然而，大多数时间这些值都是空的，因此在标识方面相当无用。
- en: 'Instead, the scheme takes the Golang type of the given object via reflection
    and maps it to the registered GVK(s) of that Golang type. For that to work, of
    course, the Golang types have to be registered into the scheme like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，方案通过反射获取给定对象的 Golang 类型，并将其映射到该 Golang 类型的注册 GVK(s)。为此，当然，这些 Golang 类型必须像这样注册到方案中：
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The scheme is used not only to register the Golang types and their GVK, but
    also to store a list of conversion functions and defaulters (see [Figure 3-6](#scheme-spider)).
    We’ll discuss conversions and defaulters in more detail in [Chapter 8](ch08.html#ch_custom-api-servers).
    It is the data source to implement encoders and decoders as well.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 方案不仅用于注册 Golang 类型及其 GVK，还用于存储转换函数和默认值（见 [图 3-6](#scheme-spider)）。我们将在 [第 8
    章](ch08.html#ch_custom-api-servers) 更详细地讨论转换和默认值。它是实现编码器和解码器的数据源。
- en: '![The scheme, connecting Golang data types with the GVK, conversions and defaulters](assets/prku_0306.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![该方案将 Golang 数据类型与 GVK、转换和默认值连接起来](assets/prku_0306.png)'
- en: Figure 3-6\. The scheme, connecting Golang data types with the GVK, conversions,
    and defaulters
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-6\. 该方案将 Golang 数据类型与 GVK、转换和默认值连接起来
- en: For Kubernetes core types there is a [predefined scheme in the `client-go` client
    set](http://bit.ly/2FkXDn2) in the package *k8s.io/client-go/kubernetes/scheme*,
    with all the types preregistered. Actually, every client set generated by the
    `client-gen` code generator (see [Chapter 5](ch05.html#ch_autocodegen)) has the
    subpackage `scheme` with all types in all groups and versions in the client set.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Kubernetes 核心类型，`client-go` 客户端集中有一个[预定义的方案](http://bit.ly/2FkXDn2)，位于包 *k8s.io/client-go/kubernetes/scheme*
    中，并预先注册了所有类型。实际上，每个由 `client-gen` 代码生成器生成的客户端集都有子包 `scheme`，其中包含客户端集中所有组和版本中的所有类型。
- en: With the scheme we conclude our deep dive into API Machinery concepts. If you
    only remember one thing about these concepts, let it be [Figure 3-7](#scheme-restmapper-http-path).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个方案，我们结束了对 API Machinery 概念的深入探讨。如果你只记住这些概念中的一件事，那就是 [图 3-7](#scheme-restmapper-http-path)。
- en: '![From Golang types to GVKs to GVRs to an HTTP path — API machinery in a nutshell](assets/prku_0307.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![从 Golang 类型到 GVK 再到 GVR 再到 HTTP 路径 —— API Machinery 的核心概述](assets/prku_0307.png)'
- en: Figure 3-7\. From Golang types to GVKs to GVRs to an HTTP path—API Machinery
    in a nutshell
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-7\. 从 Golang 类型到 GVK、GVR 再到 HTTP 路径 —— API Machinery 的核心概述
- en: Vendoring
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vendoring
- en: We have seen in this chapter that *k8s.io/client-go*, *k8s.io/api*, and *k8s.io/apimachinery*
    are central to Kubernetes programming in Golang. Golang uses *vendoring* to include
    these libraries in a third-party application source code repository.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到 *k8s.io/client-go*、*k8s.io/api* 和 *k8s.io/apimachinery* 在 Golang 中的
    Kubernetes 编程中占据了核心位置。Golang 使用 *vendoring* 将这些库包含在第三方应用程序源代码库中。
- en: Vendoring is a moving target in the Golang community. At the time of this writing,
    several vendoring tools are common, such as *godeps*, *dep*, and *glide*. At the
    same time, Go 1.12 is getting support for Go modules, which will probably become
    the standard vendoring method in the Go community in the future, but is not ready
    in the Kubernetes ecosystem at this time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在Golang社区中，依赖管理一直是一个动态的目标。在撰写本文时，有几种常见的依赖管理工具，如*godeps*、*dep*和*glide*。同时，Go
    1.12开始支持Go模块，这可能会成为将来Go社区的标准依赖管理方法，但目前在Kubernetes生态系统中尚未准备好。
- en: Most projects nowadays use either `dep` or `glide`. Kubernetes itself in *github.com/kubernetes/kubernetes*
    made the jump to Go modules for the 1.15 development cycle. The following comments
    are relevant for all of these vendoring tools.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目现在使用*dep*或*glide*。Kubernetes本身在*github.com/kubernetes/kubernetes*上已经在1.15开发周期中转向了Go模块。以下评论适用于所有这些依赖管理工具。
- en: The source of truth for supported dependency versions in each of the *k8s.io/**
    repositories is the shipped *Godeps/Godeps.json* file. It is important to stress
    that any other dependency selection can break the functionality of the library.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在*k8s.io/**仓库中，每个支持的依赖版本的真实来源是已发布的*Godeps/Godeps.json*文件。强调任何其他依赖选择都可能破坏库的功能性是非常重要的。
- en: See [“The Client Library”](#client-go) for more on the published tags of *k8s.io/client-go*,
    *k8s.io/api*, and *k8s.io/apimachinery* and which tags are compatible with each
    other.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[“客户端库”](#client-go)获取有关*k8s.io/client-go*、*k8s.io/api*和*k8s.io/apimachinery*的发布标签及其兼容性的更多信息。
- en: glide
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: glide
- en: 'Projects using `glide` can use its ability to read the *Godeps/Godeps.json*
    file on any dependency change. This has proven to work pretty reliably: the developer
    has only to declare the right *k8s.io/client-go* version, and `glide` will select
    the right version of *k8s.io/apimachinery*, *k8s.io/api*, and other dependencies.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glide`的项目可以利用其读取任何依赖变更时的*Godeps/Godeps.json*文件的能力。这已被证明非常可靠：开发者只需声明正确的*k8s.io/client-go*版本，`glide`将选择正确版本的*k8s.io/apimachinery*、*k8s.io/api*和其他依赖项。
- en: 'For some projects on GitHub, the *glide.yaml* file might look like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GitHub上的一些项目，*glide.yaml*文件可能如下所示：
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With that, `glide install -v` will download *k8s.io/client-go* and its dependencies
    into the local *vendor/* package. Here, `-v` means to drop *vendor/* packages
    from vendored libraries. This is required for our purposes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行`glide install -v`，将*k8s.io/client-go*及其依赖项下载到本地*vendor/*包中。这里的`-v`表示从依赖库的*vendor/*包中删除。这对我们的目的是必需的。
- en: If you update to a new version of `client-go` by editing *glide.yaml*, `glide
    update -v` will download the new dependencies, again in the right versions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过编辑*glide.yaml*更新到新版本的`client-go`，则执行`glide update -v`将下载新的依赖项，并确保版本正确。
- en: dep
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dep
- en: '`dep` is often considered more powerful and advanced than `glide`. For a long
    time it was seen as the successor to `glide` in the ecosystem and seemed destined
    to be *the* Go vendoring tool. At the time of this writing, its future is not
    clear, and Go modules seem to be the path forward.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`dep`通常被认为比`glide`更强大和先进。长期以来，它被视为生态系统中`glide`的继任者，并且似乎注定成为Go的*终极*依赖管理工具。在撰写本文时，其未来尚不明朗，而Go模块似乎是前进的道路。'
- en: 'In the context of `client-go`, it is very important to be aware of a couple
    of restrictions of `dep`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client-go`的上下文中，要特别注意`dep`的一些限制：
- en: '`dep` does read *Godeps/Godeps.json* on the first run of `dep init`.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dep`在首次运行`dep init`时会读取*Godeps/Godeps.json*。'
- en: '`dep` does not read *Godeps/Godeps.json* on later `dep ensure -update` calls.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dep`在后续的`dep ensure -update`调用中不会读取*Godeps/Godeps.json*。'
- en: This means that the resolution for dependencies of `client-go` is most probably
    wrong when the `client-go` version is updated in *Godep.toml*. This is unfortunate,
    because it requires the developer to explicitly and usually manually declare *all*
    dependencies.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当`client-go`版本在*Godep.toml*中更新时，依赖解析很可能是错误的。这是不幸的，因为它要求开发者显式地并通常是手动地声明*所有*依赖关系。
- en: 'A working and consistent *Godep.toml* file looks like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作和一致的*Godep.toml*文件看起来像这样：
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Warning
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Not only does *Gopkg.toml* declare explicit versions for both *k8s.io/apimachinery*
    and *k8s.io/api*, it also has overrides for them. This is necessary for when the
    project is started without explicit imports of packages from those two repositories.
    In that case, without these overrides `dep` would ignore the constraints in the
    beginning, and the developer would get wrong dependencies from the beginning.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gopkg.toml* 不仅为 *k8s.io/apimachinery* 和 *k8s.io/api* 声明了显式版本，还为它们提供了覆盖。当项目启动时没有显式导入这两个仓库的包时，这是必要的。在这种情况下，如果没有这些覆盖，`dep`
    将从一开始忽略约束，并且开发人员将从一开始就得到错误的依赖项。'
- en: Even the *Gopkg.toml* file shown here is technically not correct because it
    is incomplete, as it does not declare dependencies *on all* other libraries required
    by `client-go`. In the past, an upstream library broke compilation of `client-go`.
    So be prepared for this to happen if you use `dep` for dependency management.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这里显示的 *Gopkg.toml* 文件在技术上也不正确，因为它是不完整的，没有声明对 `client-go` 所需所有其他库的依赖关系。在过去，一个上游库损坏了
    `client-go` 的编译。因此，如果使用 `dep` 进行依赖管理，务必要做好这种情况的准备。
- en: Go Modules
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go Modules
- en: Go modules are the future of dependency management in Golang. They were introduced
    in Go 1.11 with [preliminary support](http://bit.ly/2FmBp3Y) and were further
    stabilized in 1.12\. A number of commands, like `go run` and `go get`, work with
    Go modules by setting the `GO111MODULE=on` environment variable. In Go 1.13 this
    will be the default setting.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块是 Golang 中依赖管理的未来。它们在 Go 1.11 中引入了[初步支持](http://bit.ly/2FmBp3Y)，并在 1.12
    版本中进一步稳定。像 `go run` 和 `go get` 这样的多个命令通过设置 `GO111MODULE=on` 环境变量来支持 Go 模块。在 Go
    1.13 中，这将成为默认设置。
- en: 'Go modules are driven by a *go.mod* file in the root of a project. Here is
    an excerpt of the *go.mod* file for our *github.com/programming-kubernetes/pizza-apiserver*
    project in [Chapter 8](ch08.html#ch_custom-api-servers):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块由项目根目录中的 *go.mod* 文件驱动。以下是我们 *github.com/programming-kubernetes/pizza-apiserver*
    项目的 *go.mod* 文件节选，详见[第 8 章](ch08.html#ch_custom-api-servers)。
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`client-go` `v11.0.0`—matching Kubernetes 1.14—and older versions do not have
    explicit support for Go modules. Still, it is possible to use Go modules with
    the Kubernetes libraries, as you see in the preceding example.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`client-go` `v11.0.0`—与 Kubernetes 1.14 匹配—以及早期版本并没有明确支持 Go 模块。尽管如此，你仍然可以在
    Kubernetes 库中使用 Go 模块，正如前面的例子所示。'
- en: As long as `client-go` and the other Kubernetes repositories do not ship a *go.mod*
    file, though (at least until Kubernetes 1.15), the right versions must be selected
    manually. That is, you’ll need a complete list of all dependencies matching the
    revisions of dependencies of the *Godeps/Godeps.json* in `client-go`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 `client-go` 和其他 Kubernetes 仓库没有发布 *go.mod* 文件（至少在 Kubernetes 1.15 之前），就必须手动选择正确的版本。换句话说，你需要完整列出与
    `client-go` 的 *Godeps/Godeps.json* 依赖修订版本匹配的所有依赖项。
- en: Also note the not-very-readable revisions in the previous example. They are
    pseudo-versions derived from existing tags, or using `v0.0.0` as the prefix if
    there are no tags. Even worse, you can reference tagged versions in that file,
    but the Go module commands will replace those on the next run with the pseudo-versions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意前面示例中不太易读的修订版本。它们是从现有标签派生的伪版本，或者如果没有标签，则使用 `v0.0.0` 作为前缀。更糟糕的是，你可以在该文件中引用带有标签的版本，但是
    Go 模块命令会在下一次运行时用伪版本替换它们。
- en: With `client-go` `v12.0.0`—matching Kubernetes 1.15—we ship a *go.mod* file
    and deprecate support for all other vendoring tools (see the [corresponding proposal
    document](http://bit.ly/2IZ9MPg)). The shipped *go.mod* file includes all dependencies,
    and your project *go.mod* file no longer has to list all transitive dependencies
    manually. In later releases, it’s also possible that the tagging scheme will be
    changed to fix the ugly pseudo-revisions and replace them with proper semver tags.
    But at the time of this writing, this is still not fully implemented or decided.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`client-go` `v12.0.0`—与 Kubernetes 1.15 匹配—我们将提供一个 *go.mod* 文件，并停止支持所有其他供应工具（请参阅[相应的提案文件](http://bit.ly/2IZ9MPg)）。所提供的
    *go.mod* 文件包含所有依赖项，因此你的项目 *go.mod* 文件不再需要手动列出所有传递依赖项。在后续版本中，可能会更改标签方案，以修复难看的伪修订版本，并用正确的语义版本标签替换它们。但在撰写本文时，这仍未完全实施或决定。'
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter our focus was on the Kubernetes programming interface in Go.
    We discussed accessing the Kubernetes API of well-known core types—that is, the
    API objects that are shipped with every Kubernetes cluster.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们重点讨论了使用 Go 编程的 Kubernetes API。我们讨论了如何访问那些与每个 Kubernetes 集群一起提供的核心类型的 Kubernetes
    API 对象。
- en: With this we’ve covered the basics of the Kubernetes API and its representation
    in Go. Now we’re ready to move on to the topic of custom resources, one of the
    pillars of operators.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Kubernetes API 的基础知识及其在 Go 中的表示。现在我们准备进入自定义资源的话题，这是运营商的支柱之一。
- en: ^([1](ch03.html#idm46336866123400-marker)) See [“API Terminology”](ch02.html#terminology).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#idm46336866123400-marker)) 参见[“API术语”](ch02.html#terminology)。
- en: ^([2](ch03.html#idm46336865870888-marker)) `kubectl` `explain` `pod` lets you
    query the API server for the schema of an object, including field documentation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#idm46336865870888-marker)) `kubectl` `explain` `pod` 允许您查询 API
    服务器以获取对象的模式，包括字段文档。
