<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Introducing Helm"><div class="chapter" id="introducing_helm">
<h1><span class="label">Chapter 1. </span>Introducing Helm</h1>


<p class="lead">Helm is the package manager for Kubernetes. That is the way the Helm developers have described Helm since the very first commits to the Git repository. And that sentence is the topic of this chapter.<a data-type="indexterm" data-primary="Helm" data-secondary="package manager" id="idm46125996364072"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Helm" data-tertiary="package manager" id="idm46125996363096"/><a data-type="indexterm" data-primary="package managers" data-secondary="Helm as" id="idm46125996361880"/></p>

<p>In this chapter, we will start with a conceptual look at the cloud native ecosystem, in which Kubernetes is a key technology. We will take a fresh look at what Kubernetes has to offer to set the stage for describing Helm.</p>

<p>Next, we will look at the problems Helm sets out to solve. In this section, we will look at the concept of package management and why we have modeled Helm this way. We will also visit some of the unique facets of installing packages into a cluster management tool like Kubernetes.</p>

<p>Finally, we will finish the chapter with a high-level look at Helm’s architecture, focusing on the concepts of charts, templates, and releases. By the end of the chapter, you will understand how Helm fits into the broader ecosystem of tools, and you will be familiar with the terminology and concepts we will be using throughout this book.</p>






<section data-type="sect1" data-pdf-bookmark="The Cloud Native Ecosystem"><div class="sect1" id="idm46125996358696">
<h1>The Cloud Native Ecosystem</h1>

<p>The emergence of cloud technologies has clearly changed the way the industry looks at hardware, system management, physical networking, and so on. <a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="about" id="idm46125996357000"/><a data-type="indexterm" data-primary="getting started" data-secondary="cloud native ecosystem" data-seealso="cloud native ecosystem" id="idm46125996356024"/>Virtual machines replaced physical servers, storage services displaced talk of hard drives, and automation tools rose in prominence. This was perhaps an early change in the way the industry conceptualized the cloud. But as the strengths and weaknesses of this new approach became clearer, the practices of designing applications and services also began to shift.</p>

<p>Developers and operators began to question the practice of building large single-binary applications that executed on beefy hardware. They recognized the difficulty of sharing data across different applications while retaining data integrity. Distributed locking, storage, and caching became mainstream problems instead of points of academic interest. Large software packages were broken down into smaller discrete executables. And, as <a data-type="indexterm" data-primary="Kubernetes" data-secondary="founder" id="idm46125996353464"/><a data-type="indexterm" data-primary="Burns, Brendan" id="idm46125996352488"/>Kubernetes founder Brendan Burns often puts it, “distributed computing went from an advanced topic to Computer Science 101.”</p>

<p>The term <em>cloud native</em> captures this cognitive shift in what one might call our <em>architectural view</em> of the cloud. When we design our systems around the capabilities and constraints of the cloud, we are designing cloud native systems.</p>








<section data-type="sect2" data-pdf-bookmark="Containers and Microservices"><div class="sect2" id="idm46125996350024">
<h2>Containers and Microservices</h2>

<p>At the very heart of cloud native computing is this philosophical perspective that <em>smaller discrete standalone services</em> are preferable to <em>large monolithic services</em> that do everything. Instead of writing a single large application that handles everything from generating the user interface to processing task queues to interacting with databases and caches, the cloud native approach is to write a series of smaller services, each relatively special purpose, and then join these services together to serve a higher-level purpose. In such a model, one service might be the sole user of a relational database. Services that wish to access the data will contact that service over (typically) a <a data-type="indexterm" data-primary="REST (representational state transfer) APIs" id="idm46125996346968"/><a data-type="indexterm" data-primary="JSON (JavaScript Object Notation)" data-secondary="service queries and data updates" id="idm46125996346328"/>representational state transfer (REST) API. And, using JavaScript Object Notation (JSON) over HTTP, these other services will query and update data.</p>

<p>This breakdown allows developers to hide the low-level implementation and instead offer a set of features specific to the business logic of the broader application.</p>










<section data-type="sect3" data-pdf-bookmark="Microservices"><div class="sect3" id="idm46125996344328">
<h3>Microservices</h3>

<p>Where once an application consisted of a single executable that did all of the work, <a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="microservices" id="idm46125996342760"/><a data-type="indexterm" data-primary="microservices" id="idm46125996341784"/>cloud native applications are <em>distributed applications</em>. While separate programs each take responsibility for one or two discrete tasks, together these programs all form a single logical application.</p>

<p>With all this theory, a simple example may better explain how this works. Imagine an ecommerce website. We can think of several tasks that jointly comprise this sort of website. There is a product catalog, user accounts and shopping carts, a payment processor that handles the security-sensitive process of monetary transactions, and a frontend through which customers view items and select their purchases. There is also an administrative interface where the store owners manage inventory and fulfill orders.</p>

<p>Historically, applications like this were once built as one single program. The code responsible for each of these units of work was all compiled together into one large executable, which was then often run on a single large piece of hardware.</p>

<p>The cloud native approach to such an application, though, is to break this ecommerce application into multiple pieces. One handles payment transactions. Another tracks the product catalog. Yet another provides the administrative, and so on. <a data-type="indexterm" data-primary="REST (representational state transfer) APIs" id="idm46125996338136"/>These services then communicate with each other over the network using well-defined REST APIs.</p>

<p>Taken to an extreme, an application is broken down into its smallest constituent parts, and each part is a program. This is the <em>microservice architecture</em>. Standing at the opposite end of the spectrum of a monolithic application, a microservice is responsible for handling only one small part of the overall application’s processing.</p>

<p>The microservice concept has had an outsized influence on the evolution of cloud native computing. And nowhere is this more evident than in the emergence of <em>container computing</em>.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Containers"><div class="sect3" id="idm46125996334936">
<h3>Containers</h3>

<p>It is common to compare and contrast a container and a virtual machine. A virtual machine runs an entire operating system in an isolated environment on a host machine. <a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="containers" data-tertiary="about" id="idm46125996332984"/><a data-type="indexterm" data-primary="containers" data-secondary="about" id="idm46125996331736"/>A container, in contrast, has its own filesystem, but is executed in the same operating system kernel as the host.</p>

<p>But there is a second way of conceptualizing the container—one that may prove more beneficial for the present discussion. As its name suggests, a <em>container</em> provides a useful way of packaging up the runtime environment for a single program so that the executable is guaranteed to have all of its dependencies satisfied when it is moved from one host to another.</p>

<p>This is a more philosophical approach, perhaps, because it imposes some non-technical restrictions on a container. For example, one could package a dozen different programs in a single container and execute them all at the same time. <a data-type="indexterm" data-primary="Docker" data-secondary="container design" id="idm46125996328680"/>But containers, at least as they were designed by Docker, were intended as a vehicle for one top-level program.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When we talk about programs here, we’re really thinking at a higher level of abstraction than “a binary.” Most Docker containers have at least a few executables that are there merely to assist the main program. But these executables are auxiliary to the primary function of the container. For example, a web server may require a few other local utilities for starting up or performing low-level tasks (Apache, for example, has tools for modules), but it is the web server itself that is the primary program.</p>
</div>

<p>Containers and microservices are, by design, a perfect match. Small discrete programs<a data-type="indexterm" data-primary="microservices" data-secondary="containers for" id="idm46125996325400"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="microservices" data-tertiary="containers for" id="idm46125996324424"/> can be packaged, along with all their dependencies, into svelte containers. And those containers can be moved around from host to host. When executing a container, the host need not have all the tools required to execute the program because all of those tools are packaged within the container. The host merely must have the ability to run containers.</p>

<p>For example, if a program is built in Python 3, the host does not need to install Python, configure it, and then install all the libraries that the program requires. All of that is packaged in the container. When the host executes the container, the correct version of Python 3 and each required library is already stored in the container.</p>

<p>Taking this one step further, a host can freely execute containers with competing requirements. A containerized Python 2 program can run in the same host as a containerized Python 3 requirement, and the host’s administrators need not do any special work to configure these competing requirements!</p>

<p>These examples illustrate one of the features of the cloud native ecosystem: <a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="about" data-tertiary="dependencies handled" id="idm46125996320824"/>administrators, operators, and site reliability engineers (SREs) are no longer in the business of managing program dependencies. Instead, they are free to focus on a higher level of resource allocation. Rather than fretting over which versions of Python, Ruby, and Node are running on different servers, operators can focus on whether network, storage, and CPU resources are correctly allocated for these containerized workloads.</p>

<p>Running a program in complete isolation is sometimes useful. But more often, we want to expose some aspects of this container to the outside world. <a data-type="indexterm" data-primary="containers" data-secondary="about" data-tertiary="runtime connecting to world" id="idm46125996318360"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="containers" data-tertiary="runtime connecting to world" id="idm46125996317096"/>We want to give it access to storage. We want to allow it to answer network connections. And we want to inject tidbits of configuration into the container based on our present needs. All of these tasks (and more still) are provided by the container runtime. When a container declares that it has a service that is internally listening on port 8080, the container runtime may grant it access on the host port 8000. Thus, when the host gets a network request on port 8000, the container sees this as a request on its port 8080. Likewise, a host can mount a filesystem into the container, or set specific environment variables inside of the container. In this way, a container can participate in the broader environment around it—including not just other containers on that host, but remote services on the local network or even the internet.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Container images and registries"><div class="sect3" id="idm46125996334344">
<h3>Container images and registries</h3>

<p>Container technology is a sophisticated and fascinating space in its own right. But for our purposes, we only need to understand a few more things about how containers work before be can proceed to the next layer of the cloud native stack.</p>

<p>As we discussed in the previous section, a container is a program together with its dependencies and environment. <a data-type="indexterm" data-primary="containers" data-secondary="container images" data-tertiary="about" id="idm46125996312312"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="containers" data-tertiary="container images" id="idm46125996311064"/><a data-type="indexterm" data-primary="images (container images)" data-secondary="about" id="idm46125996309848"/>This whole thing can be packaged together into a portable representation called a <em>container image</em> (often just referred to as an <em>image</em>). Images are not packaged into one large binary; instead, they are packaged into discrete <em>layers</em>, each of which has its own unique identifier. When images are moved around, they are moved as a collection of layers, which provides a huge advantage. If one host has an image with five layers and another host needs the same image, it only needs to fetch the layers that it doesn’t already have. So if it has two of the five layers already, it only needs to fetch three layers to rebuild the entire container.</p>

<p>There is a crucial piece of technology that provides the ability to move container images around. <a data-type="indexterm" data-primary="containers" data-secondary="container images" data-tertiary="image registry" id="idm46125996306504"/><a data-type="indexterm" data-primary="images (container images)" data-secondary="image registry" id="idm46125996305256"/>An <em>image registry</em> is a specialized piece of storage technology that houses containers, making them available for hosts. A host can <em>push</em> a container image to a registry, which transfers the layers to the registry. And then another host can <em>pull</em> the image from the registry to the host’s environment, after which the host can execute the container.</p>

<p>The registry manages the layers. When one host requests an image, the registry lets the host know which layers compose that image. The host can then determine which layers (if any) are missing and subsequently download just those layers from the 
<span class="keep-together">registry</span>.</p>

<p>A registry uses up to three pieces of information to identify a particular image:</p>
<dl>
<dt>Name</dt>
<dd>
<p>An image <em>name</em> can range from simple to complex, <a data-type="indexterm" data-primary="images (container images)" data-secondary="image registry" data-tertiary="image name" id="idm46125996297960"/><a data-type="indexterm" data-primary="containers" data-secondary="container images" data-tertiary="image name" id="idm46125996296744"/><a data-type="indexterm" data-primary="names" data-secondary="container images" id="idm46125996295528"/>depending on the registry that stores the image: <code>nginx</code>, <code>servers/nginx</code>, or <code>example.com/servers/nginx</code>.</p>
</dd>
<dt>Tag</dt>
<dd>
<p>The <em>tag</em> typically refers to the version of the software installed (<code>v1.2.3</code>), <a data-type="indexterm" data-primary="images (container images)" data-secondary="image registry" data-tertiary="tag" id="idm46125996290904"/><a data-type="indexterm" data-primary="containers" data-secondary="container images" data-tertiary="tag" id="idm46125996289656"/><a data-type="indexterm" data-primary="tag of container image" id="idm46125996288440"/>though tags are really just arbitrary strings. The tags <code>latest</code> and <code>stable</code> are often used to indicate “the most recent version” and “the most recent production-ready version,” respectively.</p>
</dd>
<dt>Digest</dt>
<dd>
<p>Sometimes it is important to pull a very specific version of an image. <a data-type="indexterm" data-primary="images (container images)" data-secondary="image registry" data-tertiary="digest" id="idm46125998173512"/><a data-type="indexterm" data-primary="images (container images)" data-secondary="digest" id="idm46125998172216"/><a data-type="indexterm" data-primary="containers" data-secondary="container images" data-tertiary="digest" id="idm46125998171304"/><a data-type="indexterm" data-primary="digest of container images" id="idm46125998170088"/>Since tags are <em>mutable</em>, there is no guarantee that at any given time a tag refers to <em>exactly</em> a specific version of the software. So registries support fetching images by <em>digest</em>, which is a SHA-256 or SHA-512 digest of the image’s layer information.</p>
</dd>
</dl>

<p>Throughout this book, we will see images referenced using the three preceding pieces of information. The canonical format for combining these is <code>name:tag@digest</code>, where only <code>name</code> is required. Thus, <code>example.com/servers/nginx:latest</code> says “give me the tag <code>latest</code> for the image named <code>example.com/servers/nginx</code>.” And</p>

<pre data-type="programlisting">example.com/my/app@sha256:
a428de44a9059feee59237a5881c2d2cffa93757d99026156e4ea544577ab7f3</pre>

<p>says “give me <code>example.com/my/app</code> with the exact digest given here.”</p>

<p>While there is plenty more to learn about images and containers, we have enough knowledge now to move on to the next important topic: schedulers. And in that section, we’ll discover Kubernetes.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Schedules and Kubernetes"><div class="sect2" id="idm46125996314280">
<h2>Schedules and Kubernetes</h2>

<p>In the previous section we saw how containers encapsulate individual programs and their required environment. Containers can be executed locally on workstations or remotely on servers.</p>

<p>As developers began packaging their applications into containers and operators began using containers as an artifact for deployment, a new set of questions emerged. <a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="about scheduling containers" id="idm46125998160376"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="about scheduling containers" id="idm46125998159112"/><a data-type="indexterm" data-primary="containers" data-secondary="scheduling execution" id="idm46125998158152"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="containers" data-tertiary="scheduling" id="idm46125998157208"/>How do we best execute lots of containers? How do we best facilitate a microservice architecture where lots of containers need to work together? How do we judiciously share access to things like network attached storage, load balancers, and gateways? How do we manage injecting configuration information into lots of containers? And perhaps most importantly, how do we manage resources like memory, CPU, network bandwidth, and storage space?</p>

<p>Moving even one level beyond, people began asking (based on their experiences with virtual machines) how one might manage distributing containers across multiple hosts, spreading the load equitably while still judiciously using resources? Or, more simply, how do we run the fewest possible hosts while running as many containers as we need?</p>

<p>In 2015, the time was right: Docker containers were making inroads into the enterprise. And there was a clear need for a tool that could manage container scheduling and resource management across hosts. Multiple technologies landed on the scene: Mesos introduced Marathon; Docker created Swarm; Hashicorp released Nomad; and Google created an open source sibling to its internal Borg platform, and named this technology Kubernetes (the Greek word for a ship’s captain).</p>

<p>All of these projects were providing an implementation of a clustered container management system that could schedule containers and wire them up for hosting sophisticated microservice-like distributed applications.</p>

<p>Each of these schedulers had strengths and weaknesses. But Kubernetes introduced two concepts that set it apart from the crowd: <em>declarative infrastructure</em> and the <em>reconciliation loop</em>.</p>










<section data-type="sect3" data-pdf-bookmark="Declarative infrastructure"><div class="sect3" id="idm46125998151608">
<h3>Declarative infrastructure</h3>

<p>Consider the case of deploying a container. One might approach the process of deploying a container like this:<a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="declarative infrastructure" id="idm46125998150104"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="declarative infrastructure" id="idm46125998148792"/><a data-type="indexterm" data-primary="declarative infrastructure of Kubernetes" id="idm46125998147832"/><a data-type="indexterm" data-primary="containers" data-secondary="scheduling execution" data-tertiary="declarative infrastructure" id="idm46125998147128"/><a data-type="indexterm" data-primary="resources" data-secondary="declarative resource definitions" id="idm46125998145896"/> I create the container. I open a port for it to listen on, and then I attach some storage at this particular place on the filesystem. Then I wait for everything to be initialized. Then I test it to see if the container is ready. Then I mark it as available.</p>

<p>In this approach, we are thinking <em>procedurally</em> by focusing on the process of setting up a container. But Kubernetes’ design is that we think <em>declaratively</em>. We tell the scheduler (Kubernetes) what our desired state is, and Kubernetes takes care of converting that declarative statement into its own internal procedures.</p>

<p>Installing a container on Kubernetes, then, is more a matter of saying, “I want this container running on this port with this amount of CPU and some storage mounted at this location on the filesystem.” Kubernetes works behind the scenes to wire everything up according to our declaration of what we want.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="The reconciliation loop"><div class="sect3" id="idm46125998141944">
<h3>The reconciliation loop</h3>

<p>How does Kubernetes work behind the scenes to do all of this? When we viewed things procedurally, <a data-type="indexterm" data-primary="Kubernetes" data-secondary="reconciliation loop" id="idm46125998140504"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="reconciliation loop" id="idm46125998139528"/><a data-type="indexterm" data-primary="containers" data-secondary="scheduling execution" data-tertiary="reconciliation loop" id="idm46125998138312"/><a data-type="indexterm" data-primary="reconciliation loop of Kubernetes" id="idm46125998137096"/>there was a certain order of operations there. How does Kubernetes know the order? This is where the idea of the <em>reconciliation loop</em> comes into play.</p>

<p>In a reconciliation loop, the scheduler says “here is the user’s desired state. Here is the current state. They are not the same, so I will take steps to reconcile them.” The user wants storage for the container. Currently there is no storage attached. So Kubernetes creates a unit of storage and attaches it to the container. The container needs a public network address. None exists. So a new address is attached to the container. Different subsystems in Kubernetes work to fulfill their individual part of the user’s overall declaration of desired state.</p>

<p>Eventually, Kubernetes will either succeed in creating the user’s desired environment or will arrive at the conclusion that it cannot realize the user’s desires. Meanwhile, the user takes a passive role in observing the Kubernetes cluster and waiting for it to achieve success or mark the installation as failed.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="From containers to pods, services, deployments, etc."><div class="sect3" id="idm46125998133688">
<h3>From containers to pods, services, deployments, etc.</h3>

<p>While concise, the preceding example is a little misleading. Kubernetes doesn’t necessarily treat the container as the unit of work. Instead, <a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="about" id="idm46125998131512"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="pods" id="ch01-pods"/><a data-type="indexterm" data-primary="pods" data-secondary="about" id="idm46125998128776"/><a data-type="indexterm" data-primary="containers" data-secondary="scheduling execution" data-tertiary="pods" id="idm46125998127832"/>Kubernetes introduces a higher-level abstraction called a <em>pod</em>. A pod is an abstract envelope that describes a discrete unit of work. A pod describes not just a container, but one or more containers (as well as their configuration and requirements) that together perform one unit of work:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code> </code><a class="co" id="co_introducing_helm_CO1-1" href="#callout_introducing_helm_CO1-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Pod</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">example-pod</code><code>
</code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">containers</code><code class="p">:</code><code> </code><a class="co" id="co_introducing_helm_CO1-2" href="#callout_introducing_helm_CO1-2"><img src="Images/2.png" alt="2"/></a><code>
</code><code>    </code><code class="p-Indicator">-</code><code> </code><code class="nt">image</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">nginx:latest</code><code class="s">"</code><code>
</code><code>      </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">example-nginx</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_introducing_helm_CO1-1" href="#co_introducing_helm_CO1-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>The first two lines define the Kubernetes kind (v1 Pod).</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO1-2" href="#co_introducing_helm_CO1-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>A pod can have one or more containers.</p></dd>
</dl>

<p>Most frequently, a pod only has one container. But sometimes they have <a data-type="indexterm" data-primary="pods" data-secondary="init containers" id="idm46126001025224"/><a data-type="indexterm" data-primary="init containers" id="idm46126001024248"/><a data-type="indexterm" data-primary="containers" data-secondary="init containers" id="idm46126001023576"/>containers that do some preconfiguration for the main container, exiting before the main container comes online. These are called <em>init containers</em>. <a data-type="indexterm" data-primary="pods" data-secondary="sidecar containers" id="idm46126001021976"/><a data-type="indexterm" data-primary="containers" data-secondary="sidecar containers" id="idm46126000956184"/><a data-type="indexterm" data-primary="sidecar containers" id="idm46126000955240"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="init containers" id="idm46126000954568"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="sidecar containers" id="idm46126000953352"/>Other times, there are containers that run alongside the main container and provide auxiliary services. These are called <em>sidecar containers</em>. These are all considered part of the same pod.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In the preceding code, we have written a definition of a Kubernetes <code>Pod</code> resource. <a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="Pod resource" id="idm46126000949800"/><a data-type="indexterm" data-primary="pods" data-secondary="Pod resource" id="idm46126000948520"/><a data-type="indexterm" data-primary="JSON (JavaScript Object Notation)" data-secondary="manifests for resources" id="idm46126000947576"/><a data-type="indexterm" data-primary="resources" data-secondary="about use of term" id="idm46126000946664"/><a data-type="indexterm" data-primary="manifests" data-secondary="about" id="idm46126000945720"/><a data-type="indexterm" data-primary="YAML" data-secondary="manifests for resources" id="idm46126000944776"/><a data-type="indexterm" data-primary="resources" data-secondary="manifests" id="idm46126000943832"/>These definitions, when expressed as YAML or JSON, are referred to as <em>manifests</em>. A manifest can contain one or more Kubernetes <em>resources</em> (also called <em>objects</em> or <em>resource definitions</em>). Each resource is associated with one of the Kubernetes <em>types</em>, such as a <code>Pod</code> or 
<span class="keep-together"><code>Deployment</code></span>. In this book, we typically use <em>resource</em> because the word <em>object</em> is overloaded: YAML defines the word <em>object</em> to mean a named key/value structure.</p>
</div>

<p>A <code>Pod</code> describes what configuration the container or containers need (such as network ports or filesystem mount points). <a data-type="indexterm" data-primary="Kubernetes" data-secondary="configuration information storage" id="idm46126000936824"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="configuration information storage" id="idm46126000935848"/><a data-type="indexterm" data-primary="ConfigMaps (Kubernetes)" id="idm46126000934664"/><a data-type="indexterm" data-primary="pods" data-secondary="manifests" id="idm46126000933992"/><a data-type="indexterm" data-primary="pods" data-secondary="configuration information storage" id="idm46126000933048"/><a data-type="indexterm" data-primary="Secrets (Kubernetes)" id="idm46126000932136"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Secrets" id="idm46126000931464"/><a data-type="indexterm" data-primary="YAML" data-secondary="ConfigMap" id="idm46126000930520"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="configuration information storage" id="idm46126000929576"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="manifests" id="idm46126000928392"/><a data-type="indexterm" data-primary="configuration" data-secondary="pod configuration information storage" id="idm46126000927176"/>Configuration information in Kubernetes may be stored in <em>ConfigMaps</em> or, for sensitive information, <em>Secrets</em>. And the <code>Pod</code>’s definition may then relate those <code>ConfigMap</code>s and <code>Secret</code>s to environment variables or files within each container. As Kubernetes sees those relationships, it will attempt to attach and configure the configuration data as described in the <code>Pod</code> definition:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code> </code><a class="co" id="co_introducing_helm_CO2-1" href="#callout_introducing_helm_CO2-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ConfigMap</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">configuration-data</code><code>
</code><code class="nt">data</code><code class="p">:</code><code> </code><a class="co" id="co_introducing_helm_CO2-2" href="#callout_introducing_helm_CO2-2"><img src="Images/2.png" alt="2"/></a><code>
</code><code>    </code><code class="nt">backgroundColor</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">blue</code><code>
</code><code>    </code><code class="nt">title</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Learning</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">Helm</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_introducing_helm_CO2-1" href="#co_introducing_helm_CO2-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>In this case, we have declared a <code>v1 ConfigMap</code> object.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO2-2" href="#co_introducing_helm_CO2-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>Inside of <code>data</code>, we declare some arbitrary name/value pairs.</p></dd>
</dl>

<p>A <code>Secret</code> is structurally similar to a <code>ConfigMap</code>, except that the values in the <code>data</code> section must be Base64 encoded.</p>

<p><code>Pod</code>s are linked to configuration objects (like <code>ConfigMap</code> or <code>Secret</code>) <a data-type="indexterm" data-primary="pods" data-secondary="configuration information storage" data-tertiary="volumes linking" id="idm46126000858968"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="volumes linking to configuration" id="idm46126000857672"/><a data-type="indexterm" data-primary="volumes linking pods to configuration objects" id="idm46126000856440"/><a data-type="indexterm" data-primary="configuration" data-secondary="pod configuration information storage" data-tertiary="volumes linking" id="idm46126000855800"/>using <em>volumes</em>. In this example, we take the previous <code>Pod</code> example and attach the <code>Secret</code> above:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Pod</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">example-pod</code><code>
</code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">volumes</code><code class="p">:</code><code> </code><a class="co" id="co_introducing_helm_CO3-1" href="#callout_introducing_helm_CO3-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code>    </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">my-configuration</code><code>
</code><code>      </code><code class="nt">configMap</code><code class="p">:</code><code>
</code><code>        </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">configuration-data</code><code> </code><a class="co" id="co_introducing_helm_CO3-2" href="#callout_introducing_helm_CO3-2"><img src="Images/2.png" alt="2"/></a><code>
</code><code>    </code><code class="nt">containers</code><code class="p">:</code><code>
</code><code>    </code><code class="p-Indicator">-</code><code> </code><code class="nt">image</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">nginx:latest</code><code class="s">"</code><code>
</code><code>      </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">example-nginx</code><code>
</code><code>      </code><code class="nt">env</code><code class="p">:</code><code> </code><a class="co" id="co_introducing_helm_CO3-3" href="#callout_introducing_helm_CO3-3"><img src="Images/3.png" alt="3"/></a><code>
</code><code>        </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">BACKGROUND_COLOR</code><code> </code><a class="co" id="co_introducing_helm_CO3-4" href="#callout_introducing_helm_CO3-4"><img src="Images/4.png" alt="4"/></a><code>
</code><code>          </code><code class="nt">valueFrom</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code>
</code><code>                </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">configuration-data</code><code> </code><a class="co" id="co_introducing_helm_CO3-5" href="#callout_introducing_helm_CO3-5"><img src="Images/5.png" alt="5"/></a><code>
</code><code>                </code><code class="nt">key</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">backgroundColor</code><code> </code><a class="co" id="co_introducing_helm_CO3-6" href="#callout_introducing_helm_CO3-6"><img src="Images/6.png" alt="6"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_introducing_helm_CO3-1" href="#co_introducing_helm_CO3-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>The <code>volumes</code> section tells Kubernetes which storage sources this pod needs.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO3-2" href="#co_introducing_helm_CO3-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>The name <code>configuration-data</code> is the name of our <code>ConfigMap</code> we created in the previous example.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO3-3" href="#co_introducing_helm_CO3-3"><img src="Images/3.png" alt="3"/></a></dt>
<dd><p>The <code>env</code> section injects environment variables into the container.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO3-4" href="#co_introducing_helm_CO3-4"><img src="Images/4.png" alt="4"/></a></dt>
<dd><p>The environment variable will be named <code>BACKGROUND_COLOR</code> inside of the 
<span class="keep-together">container</span>.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO3-5" href="#co_introducing_helm_CO3-5"><img src="Images/5.png" alt="5"/></a></dt>
<dd><p>This is the name of the <code>ConfigMap</code> it will use. This map must be in <code>volumes</code> if we want to use it as a filesystem volume.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO3-6" href="#co_introducing_helm_CO3-6"><img src="Images/6.png" alt="6"/></a></dt>
<dd><p>This is the name of the key inside the <code>data</code> section of the <code>ConfigMap</code>.</p></dd>
</dl>

<p>A pod is the “primitive” description of a runnable unit of work, with containers as part of that pod.<a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="about" id="idm46126000707608"/><a data-type="indexterm" data-primary="pods" data-secondary="about" id="idm46126000706360"/> But Kubernetes introduces higher-order concepts.</p>

<p>Consider a web application. We might not want to run just one instance of this web application. If we ran just one, and it failed, our site would go down. And if we wanted to upgrade it, we would have to figure out how to do so without taking down the whole site. Thus, <a data-type="indexterm" data-primary="Kubernetes" data-secondary="Deployment" id="idm46126000704392"/><a data-type="indexterm" data-primary="pods" data-secondary="Deployment" id="idm46126000703416"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="Deployment" id="idm46126000702472"/><a data-type="indexterm" data-primary="Deployment (Kubernetes)" id="idm46126000701256"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="Deployment" id="idm46126000700584"/>Kubernetes introduced the concept of a <em>Deployment</em>. A <code>Deployment</code> describes an application as a collection of identical pods. The <code>Deployment</code> is composed of some top-level configuration data as well as a template for how to construct a replica pod.</p>

<p>With a <code>Deployment</code>, we can tell Kubernetes to create our app with a single pod. <a data-type="indexterm" data-primary="scalability in Deployment (Kubernetes)" id="idm46126000696904"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Deployment" data-tertiary="HorizontalPodAutoscaler" id="idm46126000696232"/><a data-type="indexterm" data-primary="HorizontalPodAutoscaler (Kubernetes)" id="idm46126000695016"/><a data-type="indexterm" data-primary="Deployment (Kubernetes)" data-secondary="HorizontalPodAutoscaler" id="idm46126000694328"/>Then we can scale it up to five pods. And back down to three. We can attach a <em>HorizontalPodAutoscaler</em> (another Kubernetes type) and configure that to scale our pod based on resource usage. And when we <a data-type="indexterm" data-primary="Kubernetes" data-secondary="Deployment" data-tertiary="upgrading application via" id="idm46126000692760"/><a data-type="indexterm" data-primary="Deployment (Kubernetes)" data-secondary="upgrading application via" id="idm46126000691496"/><a data-type="indexterm" data-primary="upgrades" data-secondary="Deployment handling" id="idm46126000690536"/><a data-type="indexterm" data-primary="YAML" data-secondary="Deployment" id="idm46126000689592"/>upgrade the application, the <code>Deployment</code> can employ various strategies for incrementally upgrading individual pods without taking down our entire application:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">apps/v1</code><code> </code><a class="co" id="co_introducing_helm_CO4-1" href="#callout_introducing_helm_CO4-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Deployment</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">example-deployment</code><code>
</code><code>    </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>        </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">my-deployment</code><code>
</code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">replicas</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">3</code><code> </code><a class="co" id="co_introducing_helm_CO4-2" href="#callout_introducing_helm_CO4-2"><img src="Images/2.png" alt="2"/></a><code>
</code><code>    </code><code class="nt">selector</code><code class="p">:</code><code>
</code><code>        </code><code class="nt">matchLabels</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">my-deployment</code><code>
</code><code>    </code><code class="nt">template</code><code class="p">:</code><code> </code><a class="co" id="co_introducing_helm_CO4-3" href="#callout_introducing_helm_CO4-3"><img src="Images/3.png" alt="3"/></a><code>
</code><code>        </code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>                </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">my-deployment</code><code>
</code><code>        </code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">containers</code><code class="p">:</code><code>
</code><code>            </code><code class="p-Indicator">-</code><code> </code><code class="nt">image</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">nginx:latest</code><code class="s">"</code><code>
</code><code>              </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">example-nginx</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_introducing_helm_CO4-1" href="#co_introducing_helm_CO4-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>This is an <code>apps/v1 Deployment</code> object.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO4-2" href="#co_introducing_helm_CO4-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>Inside of the spec, we ask for three replicas of the following <code>template</code>.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO4-3" href="#co_introducing_helm_CO4-3"><img src="Images/3.png" alt="3"/></a></dt>
<dd><p>The template specifies how each replica pod should look.</p></dd>
</dl>

<p>When it comes to attaching a Kubernetes application to other things on the network, <a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="Service" id="idm46126000586808"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Service" id="idm46126000585672"/><a data-type="indexterm" data-primary="Service (Kubernetes)" data-secondary="about" id="idm46126000560360"/><a data-type="indexterm" data-primary="pods" data-secondary="Service" id="idm46126000559416"/><a data-type="indexterm" data-primary="YAML" data-secondary="Service" id="idm46126000558472"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="Service" id="idm46126000557528"/>Kubernetes provides <em>Service</em> definitions. A <code>Service</code> is a persistent network resource (sort of like a static IP) that persists even if the pod or pods attached to it go away. In this way, Kubernetes <code>Pod</code>s can come and go while the network layer can continue to route traffic to the same <code>Service</code> endpoint. While a <code>Service</code> is an abstract Kubernetes concept, behind the scenes it may be implemented as anything from a routing rule to an external load balancer:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code> </code><a class="co" id="co_introducing_helm_CO5-1" href="#callout_introducing_helm_CO5-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Service</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">example-service</code><code>
</code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">selector</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">my-deployment</code><code> </code><a class="co" id="co_introducing_helm_CO5-2" href="#callout_introducing_helm_CO5-2"><img src="Images/2.png" alt="2"/></a><code>
</code><code>  </code><code class="nt">ports</code><code class="p">:</code><code>
</code><code>    </code><code class="p-Indicator">-</code><code> </code><code class="nt">protocol</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">TCP</code><code> </code><a class="co" id="co_introducing_helm_CO5-3" href="#callout_introducing_helm_CO5-3"><img src="Images/3.png" alt="3"/></a><code>
</code><code>      </code><code class="nt">port</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">80</code><code>
</code><code>      </code><code class="nt">targetPort</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_introducing_helm_CO5-1" href="#co_introducing_helm_CO5-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>The kind is <code>v1 Service</code>.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO5-2" href="#co_introducing_helm_CO5-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>This <code>Service</code> will route to pods with the <code>app: my-deployment</code> label.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO5-3" href="#co_introducing_helm_CO5-3"><img src="Images/3.png" alt="3"/></a></dt>
<dd><p>TCP traffic to port <code>80</code> of this <code>Service</code> will be routed to port <code>8080</code> on the pods that match the <code>app: my-deployment</code> label.</p></dd>
</dl>

<p>The <code>Service</code> described will route traffic to the <code>Deployment</code> we created earlier.<a data-type="indexterm" data-startref="ch01-pods" id="idm46126000465496"/></p>

<p>We’ve introduced a few of the many Kubernetes types. There are dozens more that we could cover, but the most frequently used by far are <code>Pod</code>, <code>Deployment</code>, <code>ConfigMap</code>, <code>Secret</code>, and <code>Service</code>. In the next chapter we will begin working with these concepts more directly. But for now, armed with some generic information, we can introduce Helm.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Helm’s Goals"><div class="sect1" id="idm46125998162248">
<h1>Helm’s Goals</h1>

<p>Up to this point, we have focused on the broader cloud native ecosystem and on Kubernetes’ role within that ecosystem. In this section, we will change focus to Helm.<a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="Helm and" id="idm46126000460584"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Helm" data-tertiary="about Kubernetes and" id="idm46126000459336"/><a data-type="indexterm" data-primary="Helm" data-secondary="about Kubernetes and" id="idm46126000458120"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Helm" data-tertiary="about" id="idm46126000457176"/></p>

<p>In the previous section, we saw several distinct Kubernetes resources: A <code>Pod</code>, a 
<span class="keep-together"><code>ConfigMap</code></span>, a <code>Deployment</code>, and a <code>Service</code>. Each of these performs some discrete role. But an <em>application</em> typically requires more than one of these.</p>

<p>For example, the WordPress CMS system can be run inside of Kubernetes. But typically it would need at least a <code>Deployment</code> (for the WordPress server), a <code>ConfigMap</code> for configuration and probably a <code>Secret</code> (to keep passwords), a few <code>Service</code> objects, a <code>StatefulSet</code> running a database, and a few role-based access control (RBAC) rules. Already, a Kubernetes description of a basic WordPress site would span thousands of lines of YAML. At the very core of Helm is this idea that all of those objects can be packaged to be installed, updated, and deleted <em>together</em>.</p>

<p>When we wrote Helm, we had three main goals:<a data-type="indexterm" data-primary="Helm" data-secondary="goals of" id="ch01-goal"/></p>
<ol>
<li>
<p>Make it easy to go from “zero to Kubernetes”</p>
</li>
<li>
<p>Provide a package management system like operating systems have</p>
</li>
<li>
<p>Emphasize security and configurability for deploying applications to Kubernetes</p>
</li>

</ol>

<p>We will look at each of these three goals, and then take a look at one other aspect of Helm’s usage: its participation in the life cycle management story.</p>








<section data-type="sect2" data-pdf-bookmark="From Zero to Kubernetes"><div class="sect2" id="idm46126000444008">
<h2>From Zero to Kubernetes</h2>

<p>The Helm project started in 2015, a few months before the inaugural KubeCon. <a data-type="indexterm" data-primary="Helm" data-secondary="about Kubernetes and" data-tertiary="ease of Kubernetes setup" id="idm46126000442440"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Helm" data-tertiary="ease of Kubernetes setup" id="idm46126000441176"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Helm" data-tertiary="ease of Kubernetes setup" id="idm46126000439944"/>Kubernetes was difficult to set up, often requiring new users to compile the Kubernetes source code and then use some shell scripts to get Kubernetes running. And once the cluster was up, new users were expected to write YAML (as we did in previous sections) from scratch. There were few basic examples and no production-ready examples.</p>

<p>We wanted to invert the learning cycle: instead of requiring users to start with basic examples and try to construct their own applications, we wanted to provide users with ready-made production-ready examples. Users could install those examples, see them in action, and then learn how Kubernetes worked.</p>

<p>That was, and still is to this day, our first priority with Helm: make it easier to get going with Kubernetes. In our view, a new Helm user with an existing Kubernetes cluster should be able to go from download to an installed application in five minutes or less.</p>

<p>But Helm isn’t <em>just</em> a learning tool. It is a package manager.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Package Management"><div class="sect2" id="idm46126000435848">
<h2>Package Management</h2>

<p>Kubernetes is like an operating system. At its foundation, an operating system provides an environment for executing programs.<a data-type="indexterm" data-primary="Helm" data-secondary="package manager" id="idm46126000434104"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Helm" data-tertiary="package management overview" id="idm46126000433128"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Helm" data-tertiary="package management overview" id="idm46126000431944"/><a data-type="indexterm" data-primary="Helm" data-secondary="about Kubernetes and" data-tertiary="package management overview" id="idm46126000430712"/><a data-type="indexterm" data-primary="package managers" data-secondary="Helm as" id="idm46126000429480"/> It provides the tools necessary to store, execute, and monitor the life cycle of a program.</p>

<p>Instead of executing programs, it executes containers. But similar to an operating system, it provides the tools necessary to store, execute, and monitor those containers.</p>

<p>Most operating systems are supported by a <em>package manager</em>. The <a data-type="indexterm" data-primary="package managers" data-secondary="about" id="idm46126000426888"/>job of the package manager is to make it easy to find, install, upgrade, and delete the programs on an operating system. Package managers provide semantics for bundling programs into installable applications, and they provide a scheme for storing and retrieving packages, as well as installing and managing them.</p>

<p>As we envisioned Kubernetes as an operating system, we quickly saw the need for a Kubernetes package manager. From the first commit to the Helm source code repository, we have consistently applied the package management metaphor to Helm:</p>

<ul>
<li>
<p>Helm provides package repositories and search capabilities to find what Kubernetes applications are available.</p>
</li>
<li>
<p>Helm has the familiar install, upgrade, and delete commands.</p>
</li>
<li>
<p>Helm defines a method for configuring packages prior to installing them.</p>
</li>
<li>
<p>Additionally, Helm has tools for seeing what is already installed and how it is configured.</p>
</li>
</ul>

<p>We initially modeled Helm after Homebrew (a package manager for macOS) and Apt (the package manager for Debian). But as Helm has matured, we have sought to learn from as many different package managers as we can.</p>

<p>There are some differences between typical operating systems and Kubernetes. <a data-type="indexterm" data-primary="Kubernetes" data-secondary="operating systems versus" id="idm46126000419576"/><a data-type="indexterm" data-primary="operating systems versus Kubernetes" id="idm46126000418584"/>
<span class="keep-together">One of</span> them is that Kubernetes supports running many instances of the same application. While I may only install the database MariaDB once on my workstation, a Kubernetes cluster could be running tens, hundreds, or even thousands of MariaDB 
<span class="keep-together">installations</span>—each with a different configuration or even a different version.</p>

<p>Another notion that is rare in typical operating systems, but is central to Kubernetes, is the idea of a <em>namespace</em>. <a data-type="indexterm" data-primary="Kubernetes" data-secondary="namespace" id="idm46126000415176"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="operating systems versus" data-tertiary="namespace" id="idm46126000414168"/><a data-type="indexterm" data-primary="namespace (Kubernetes)" id="idm46126000412936"/><a data-type="indexterm" data-primary="resources" data-secondary="namespace" id="idm46126000412264"/>In Kubernetes, a namespace is an arbitrary grouping mechanism that defines a boundary between the things inside the namespace and the things outside. There are many different ways to organize resources with namespaces, but oftentimes they are used as a fixture to which <a data-type="indexterm" data-primary="security" data-secondary="namespaces" id="idm46126000410904"/>security is attached. For example, perhaps only specific users can access resources inside of a namespace.</p>

<p>These are just a few ways that Kubernetes differs from traditional operating systems. These and other differences have presented challenges in the design of Helm. We have had to build Helm to take advantage of these differences, but without giving up on our package management metaphor.</p>

<p>For example, the Helm installation command requires not only the name of the package, but also a user-supplied name by which the installed version of that package will be referenced. In the next chapter, we’ll see examples of this.</p>

<p>Likewise, operations in Helm are namespace-sensitive. One can install the same application into two different namespaces, and Helm provides tools to manage these different instances of the application.</p>

<p>In the end, though, Helm remains firmly in the package management class of tools.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Security, Reusability, and Configurability"><div class="sect2" id="idm46126000435224">
<h2>Security, Reusability, and Configurability</h2>

<p>Our third goal with Helm was to focus on three “must haves” for managing applications in a cluster:</p>
<ol>
<li>
<p>Security</p>
</li>
<li>
<p>Reusability</p>
</li>
<li>
<p>Configurability</p>
</li>

</ol>

<p>In short, we wanted to make Helm aware enough about these principles that Helm users can have confidence in the packages they use. A user should be able to <em>verify</em> that a package came from a trustworthy source (and was not tampered with), <em>reuse</em> the same package multiple times, and <em>configure</em> the package to fit their needs.</p>

<p>Whereas Helm’s developers have direct control over the previous two design goals, this one is unique: Helm can only provide the right tools for <em>package authors</em> and hope that these creators choose to realize these three “must haves.”</p>










<section data-type="sect3" data-pdf-bookmark="Security"><div class="sect3" id="idm46126000399576">
<h3>Security</h3>

<p>Security is a broad category. In this context, though, we are referring to the <a data-type="indexterm" data-primary="Helm" data-secondary="about Kubernetes and" data-tertiary="security" id="idm46126000398008"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Helm" data-tertiary="security" id="idm46126000396760"/><a data-type="indexterm" data-primary="security" data-secondary="chart security" id="idm46126000395544"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Helm" data-tertiary="security" id="idm46126000394600"/><a data-type="indexterm" data-primary="Helm" data-secondary="security" id="idm46126000393384"/><a data-type="indexterm" data-primary="charts" data-secondary="security" id="idm46126000392440"/>idea that when a user examines a package, the user has the ability to verify certain things about the package:</p>

<ul>
<li>
<p>The package comes from a trusted source.</p>
</li>
<li>
<p>The network connection over which the package is pulled is secured.</p>
</li>
<li>
<p>The package has not been tampered with.</p>
</li>
<li>
<p>The package can be easily inspected so the user can see what it does.</p>
</li>
<li>
<p>The user can see what configuration the package has, and see how different inputs impact the output of a package.</p>
</li>
</ul>

<p>Throughout this book, and especially in <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a>, we will cover security in more detail. But these five capabilities are things we believe we have provided with Helm.</p>

<p>Helm provides a <em>provenance</em> feature to establish verification about a <a data-type="indexterm" data-primary="chart repositories" data-secondary="provenance file" data-tertiary="provenance of charts" id="idm46126000383848"/><a data-type="indexterm" data-primary="security" data-secondary="chart security" data-tertiary="provenance feature" id="idm46126000382600"/><a data-type="indexterm" data-primary="packages" data-secondary="provenance feature of Helm" id="idm46126000381384"/><a data-type="indexterm" data-primary="Helm" data-secondary="security" data-tertiary="provenance of packages" id="idm46126000380472"/><a data-type="indexterm" data-primary="provenance of charts" id="idm46126000379256"/><a data-type="indexterm" data-primary="charts" data-secondary="security" data-tertiary="provenance feature" id="idm46126000378584"/>package’s origin, author, and integrity. Helm supports Secure Sockets Layer/Transport Layer Security (SSL/TLS) for securely sending data across the network. And Helm provides dry-run, template, and linting commands to examine packages and their possible 
<span class="keep-together">permutations</span>.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Reusability"><div class="sect3" id="idm46126000376312">
<h3>Reusability</h3>

<p>A virtue of package management is its ability to install the same thing repeatedly and predictably.<a data-type="indexterm" data-primary="reusability in Helm" id="idm46126000374760"/><a data-type="indexterm" data-primary="configuration" data-secondary="reusability in Helm" id="idm46126000374056"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Helm" data-tertiary="reusability" id="idm46126000373112"/> With Helm, this idea is extended slightly: we may want to even install the same thing (repeatedly and predictably) into the same cluster or even same namespace in a cluster.</p>

<p>Helm charts are the key to reusability. A chart provides a pattern for producing<a data-type="indexterm" data-primary="charts" data-secondary="reusability via" id="idm46126000371192"/> the same Kubernetes manifests. But charts also allow users to provide additional configuration (which we will talk about in the next chapter). So Helm provides patterns for storing configuration so that the combination of a chart plus its configuration can even be done repeatedly.</p>

<p>In this way, Helm encourages Kubernetes users to package their YAML into charts so that these descriptions can be reused.<a data-type="indexterm" data-primary="YAML" data-secondary="reusability in Helm" id="idm46126000369256"/></p>

<p>In the Linux world, each Linux distribution has its own package manager and repositories. This is not the case in the Kubernetes world. Helm was constructed so that all Kubernetes distributions could share the same package manager, and (with very, very few exceptions) the same packages as well. When there are differences between two different Kubernetes distributions, charts can accommodate this using templates (discussed more thoroughly in <a data-type="xref" href="ch05.xhtml#developing_templates">Chapter 5</a>) coupled with configuration.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Configurability"><div class="sect3" id="idm46126000366472">
<h3>Configurability</h3>

<p>Helm provides patterns for taking a Helm chart and then supplying some additional configuration.<a data-type="indexterm" data-primary="configuration" data-secondary="configurability in Helm" id="idm46126000364824"/><a data-type="indexterm" data-primary="charts" data-secondary="configurability via" id="idm46126000363848"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Helm" data-tertiary="configurability" id="idm46126000362904"/> For example, I might install a website with Helm, but want to set (at installation time) the name of that website. Helm provides tools to configure packages at installation time, and to reconfigure installations during upgrades. But a word of caution is in order.</p>

<p>Helm is a package manager. <a data-type="indexterm" data-primary="package managers" data-secondary="Helm as" data-tertiary="configuration management and" id="idm46126000360840"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Helm" data-tertiary="package manager" id="idm46126000359528"/><a data-type="indexterm" data-primary="Helm" data-secondary="package manager" id="idm46126000358312"/>Another class of software handles <em>configuration management</em>. This class of software, typified by Puppet, Ansible, and Chef, focuses on how a given piece of software (often packaged) is <em>specifically configured</em> for its host environment. Its responsibility is to manage configuration changes over time.</p>

<p>Helm was not designed to be a configuration management tool, though there is at least some overlap between package management and configuration management.</p>

<p>Package management is typically confined to implementing three verbs:<a data-type="indexterm" data-primary="package managers" data-secondary="about" data-tertiary="configuration management versus" id="idm46126000355160"/> install, upgrade, and delete. Configuration management is a higher-order concept that focuses on managing an application or applications over time. This is sometimes called “day-two ops.”</p>

<p>While Helm did not set out to be a configuration management tool, it is sometimes used as one. Organizations rely upon Helm not just to install, upgrade, and delete, but also to track changes over time, to track configuration, and to determine whether an application as a whole is running. Helm can be stretched this way, but if you want a strong configuration management solution, you may want to leverage other tools in the Helm ecosystem. Many tools like Helmfile, Flux, and Reckoner have filled in details in the larger configuration management story.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The Helm community has created a wealth of tools that interoperate with or augment Helm.<a data-type="indexterm" data-primary="resources for learning" data-secondary="Helm Developer Guide" data-tertiary="tools that interoperate with Helm" id="idm46126000351432"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="tools that interoperate with Helm" id="idm46126000350168"/><a data-type="indexterm" data-primary="Helm" data-secondary="tools that interoperate with" id="idm46126000349208"/> The Helm project maintains a list of those tools in the <a href="https://oreil.ly/hOqca">official documentation</a>.</p>
</div>

<p>One of the common themes you will notice in Helm charts is that configuration options<a data-type="indexterm" data-primary="configuration" data-secondary="configurability in Helm" data-tertiary="charts in development versus production" id="idm46126000346888"/><a data-type="indexterm" data-primary="charts" data-secondary="development versus production" id="idm46126000345624"/> are often set up so that you can take the same chart and release a minimal version of it into your development environment, or (with different configuration options) a sophisticated version into your production environment.<a data-type="indexterm" data-startref="ch01-goal" id="idm46126000344296"/></p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Helm’s Architecture"><div class="sect1" id="idm46126000461608">
<h1>Helm’s Architecture</h1>

<p>In the final section of this chapter, we will briefly turn to the high-level architecture of Helm. As well as rounding out the conceptual discussion of cloud native Kubernetes applications and package management, this section paves the way for <a data-type="xref" href="ch02.xhtml#Using_Helm">Chapter 2</a>, where we will dive into using Helm.</p>








<section data-type="sect2" data-pdf-bookmark="Kubernetes Resources"><div class="sect2" id="idm46126000341144">
<h2>Kubernetes Resources</h2>

<p>We have had a look at several kinds of Kubernetes resources. We saw a <a data-type="indexterm" data-primary="Helm" data-secondary="architecture" data-tertiary="Kubernetes resources" id="idm46126000339224"/><a data-type="indexterm" data-primary="architecture of Helm" data-secondary="Kubernetes resources" id="idm46126000337976"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Helm" data-tertiary="resources in architecture" id="idm46126000337032"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="resources" data-tertiary="Helm architecture" id="idm46126000335800"/><a data-type="indexterm" data-primary="resources" data-secondary="Helm architecture" id="idm46126000334584"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Helm" data-tertiary="architecture" id="ch01-arch"/>couple of <code>Pod</code> definitions, a <code>ConfigMap</code>, a <code>Deployment</code>, and a <code>Service</code>. There are dozens more provided by Kubernetes. You can even use custom resource definitions (CRDs) for defining your own custom resource types. The main Kubernetes documentation provides both accessible guides and detailed API documentation on each kind.</p>

<p>Throughout this book, we will use many different Kubernetes resource types. While we discuss them in context, you may find it beneficial to skim through the main Kubernetes document as you run across new resource definitions.</p>

<p>As we discussed earlier, resource definitions are <em>declarative</em>. You, the user, <a data-type="indexterm" data-primary="resources" data-secondary="declarative resource definitions" id="idm46126000328408"/><a data-type="indexterm" data-primary="custom resource definitions (CRDs)" data-secondary="declarative resource definitions" id="idm46126000327432"/><a data-type="indexterm" data-primary="declarative infrastructure of Kubernetes" data-secondary="resources in Helm architecture" id="idm46126000326504"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="declarative infrastructure" id="idm46126000325448"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="declarative infrastructure" data-tertiary="resources in Helm architecture" id="idm46126000324216"/>describe for Kubernetes the desired state of a resource. For example, you can read the <code>Pod</code> definition we created earlier in the chapter as a statement that, “I want Kubernetes to make me a <code>Pod</code> that has these features.” It is up to Kubernetes to figure out how to configure and run a pod according to your specification.</p>

<p>All Kubernetes resource definitions share a common subset of elements. The following manifest uses a <code>Deployment</code> to illustrate the main structural elements of a resource definition:<a data-type="indexterm" data-primary="YAML" data-secondary="Deployment" data-tertiary="resource definition" id="idm46126000320968"/><a data-type="indexterm" data-primary="Deployment (Kubernetes)" data-secondary="resource definition example" id="idm46126000319640"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Deployment" data-tertiary="resource definition example" id="idm46126000318728"/><a data-type="indexterm" data-primary="cloud native ecosystem" data-secondary="Kubernetes" data-tertiary="Deployment" id="idm46126000317496"/></p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">apps/v1</code><code> </code><a class="co" id="co_introducing_helm_CO6-1" href="#callout_introducing_helm_CO6-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Deployment</code><code> </code><a class="co" id="co_introducing_helm_CO6-2" href="#callout_introducing_helm_CO6-2"><img src="Images/2.png" alt="2"/></a><code>
</code><code class="nt">metadata</code><code class="p">:</code><code> </code><a class="co" id="co_introducing_helm_CO6-3" href="#callout_introducing_helm_CO6-3"><img src="Images/3.png" alt="3"/></a><code>
</code><code>    </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">example-deployment</code><code> </code><a class="co" id="co_introducing_helm_CO6-4" href="#callout_introducing_helm_CO6-4"><img src="Images/4.png" alt="4"/></a><code>
</code><code>    </code><code class="nt">labels</code><code class="p">:</code><code> </code><a class="co" id="co_introducing_helm_CO6-5" href="#callout_introducing_helm_CO6-5"><img src="Images/5.png" alt="5"/></a><code>
</code><code>        </code><code class="nt">some-name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">some-value</code><code>
</code><code>    </code><code class="nt">annotations</code><code class="p">:</code><code> </code><a class="co" id="co_introducing_helm_CO6-6" href="#callout_introducing_helm_CO6-6"><img src="Images/6.png" alt="6"/></a><code>
</code><code>        </code><code class="nt">some-name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">some-value</code><code>
</code><code class="c1"># resource-specific YAML</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_introducing_helm_CO6-1" href="#co_introducing_helm_CO6-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The API family and version for this resource.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO6-2" href="#co_introducing_helm_CO6-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The kind of resource. Combined with <code>apiVersion</code>, we get the “resource type”.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO6-3" href="#co_introducing_helm_CO6-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The <code>metadata</code> section contains top-level data about the resource.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO6-4" href="#co_introducing_helm_CO6-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>A <code>name</code> is required for almost every resource type.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO6-5" href="#co_introducing_helm_CO6-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Labels are used to give Kubernetes query-able “handles” to your resources.</p></dd>
<dt><a class="co" id="callout_introducing_helm_CO6-6" href="#co_introducing_helm_CO6-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p>Annotations provide a way for authors to attach their own keys and values to a resource.</p></dd>
</dl>

<p>Of particular note, a <em>resource type</em> in Kubernetes is composed of three pieces of 
<span class="keep-together">information</span>:<a data-type="indexterm" data-primary="Kubernetes" data-secondary="resources" data-tertiary="resource type" id="idm46126000222168"/><a data-type="indexterm" data-primary="resources" data-secondary="resource type" id="idm46126000220888"/></p>
<dl>
<dt>API group (or family)</dt>
<dd>
<p>Several base resource types like <code>Pod</code> and <code>ConfigMap</code> omit this name.</p>
</dd>
<dt>API version</dt>
<dd>
<p>Expressed as a <code>v</code>, followed by a major version and an optional stability marker. For example, <code>v1</code> is a stable “version 1,” while <code>v1alpha</code> indicates an unstable “version 1 alpha 1.”</p>
</dd>
<dt>Resource kind</dt>
<dd>
<p>The (capitalized) name of the specific resource within the API group.</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While a full resource type name is something like <code>apps/v1 Deployment</code> or <code>v1 Pod</code> (for core types), Kubernetes users will often omit the group and version when talking or writing about well-known types. For example, in this book we simply write <code>Deployment</code> instead of <code>apps/v1 Deployment</code>. Fully qualified names are used when specifying an exact version or when discussing a resource type defined in a CRD.</p>
</div>

<p>Thus, <code>apps/v1 Deployment</code> indicates that the API group “apps” has a “version 1” (stable) resource kind called “Deployment.”</p>

<p>Kubernetes supports two main formats for declaring the resources you want: JSON and YAML.<a data-type="indexterm" data-primary="JSON (JavaScript Object Notation)" data-secondary="YAML as superset of" id="idm46126000208568"/><a data-type="indexterm" data-primary="YAML" data-secondary="superset of JSON" id="idm46126000207576"/> Strictly speaking, YAML is a <em>superset</em> of JSON. All JSON documents are valid YAML, but YAML adds a number of additional features.</p>

<p>In this book, we stick to the YAML format. We find it easier to read and write, and almost all Helm users choose YAML over JSON. However, should your preferences differ, both Kubernetes and Helm support plain JSON.</p>

<p>Earlier, we introduced the term <em>manifest</em>. A manifest is just a <a data-type="indexterm" data-primary="manifests" data-secondary="about" id="idm46126000204312"/><a data-type="indexterm" data-primary="YAML" data-secondary="manifests for resources" id="idm46126000203304"/><a data-type="indexterm" data-primary="JSON (JavaScript Object Notation)" data-secondary="manifests for resources" id="idm46126000202360"/><a data-type="indexterm" data-primary="resources" data-secondary="manifests" id="idm46126000201352"/>Kubernetes resource serialized to either its JSON or YAML format. It would be fair to call our earlier <code>Pod</code>, <code>ConfigMap</code>, <code>Deployment</code>, and <code>Service</code> examples each a <em>Kubernetes manifest</em>, since they are resources expressed in YAML.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Charts"><div class="sect2" id="idm46126000340552">
<h2>Charts</h2>

<p>We have already talked about Helm packages in this chapter. In Helm’s vocabulary, a package is called a <em>chart</em>.<a data-type="indexterm" data-primary="charts" data-secondary="as packages" data-secondary-sortas="packages" id="idm46126000195592"/><a data-type="indexterm" data-primary="packages" data-secondary="charts as" id="idm46126000194312"/><a data-type="indexterm" data-primary="package managers" data-secondary="charts as packages" id="idm46126000193368"/><a data-type="indexterm" data-primary="Helm" data-secondary="charts" data-seealso="charts" id="idm46126000192424"/><a data-type="indexterm" data-primary="charts" data-secondary="about" id="idm46126000191208"/><a data-type="indexterm" data-primary="resources" data-secondary="charts" data-seealso="charts" id="idm46126000190264"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="resources" data-tertiary="charts" data-seealso="charts" id="idm46126000189048"/><a data-type="indexterm" data-primary="Helm" data-secondary="architecture" data-tertiary="charts" id="idm46126000187560"/><a data-type="indexterm" data-primary="architecture of Helm" data-secondary="charts" id="idm46126000186344"/> The name is a play on the nautical nature of Kubernetes (which means “ship’s captain” in Greek) and Helm (which is the steering mechanism of a ship). A chart plots the way a Kubernetes application should be installed.</p>

<p>A chart is a set of files and directories that adhere to the chart specification for describing the resources to be installed into Kubernetes. <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a> explains the chart structure in detail, but there are a few high-level concepts we will introduce here.</p>

<p>A chart contains a file called <em>Chart.yaml</em> that describes the chart. <a data-type="indexterm" data-primary="YAML" data-secondary="Chart.yaml" data-seealso="Chart.yaml file" id="idm46126000182856"/><a data-type="indexterm" data-primary="charts" data-secondary="about" data-tertiary="Chart.yaml" id="idm46126000181608"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="about charts" id="idm46126000180392"/>It has information about the chart version, the name and description of the chart, and who authored the chart.</p>

<p>A chart contains <em>templates</em> as well. These are Kubernetes manifests<a data-type="indexterm" data-primary="manifests" data-secondary="templates as" id="idm46126000178360"/><a data-type="indexterm" data-primary="templates" data-secondary="about charts" id="idm46126000177384"/><a data-type="indexterm" data-primary="charts" data-secondary="about" data-tertiary="templates" id="idm46126000176440"/> (like we saw earlier in this chapter) that are potentially annotated with templating directives. We will cover these in detail in <a data-type="xref" href="ch05.xhtml#developing_templates">Chapter 5</a>.</p>

<p>A chart may also contain a <em>values.yaml</em> file that provides default configuration.<a data-type="indexterm" data-primary="YAML" data-secondary="values.yaml file" data-seealso="values.yaml file" id="idm46126000173256"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="about charts" id="idm46126000172008"/><a data-type="indexterm" data-primary="charts" data-secondary="about" data-tertiary="values.yaml" id="idm46126000171064"/><a data-type="indexterm" data-primary="configuration" data-secondary="values.yaml file" id="idm46126000169848"/> This file contains parameters that you can override during installation and upgrade.</p>

<p>These are the basic things you will find in a Helm chart, though there are others that we will cover in <a data-type="xref" href="ch04.xhtml#building_a_chart">Chapter 4</a>. When you see a Helm chart, though, it may be presented in either unpacked or packed form.<a data-type="indexterm" data-primary="charts" data-secondary="about" data-tertiary="packed versus unpacked" id="idm46126000167320"/></p>

<p>An <em>unpacked</em> Helm chart is just a directory. Inside, it will have a <em>Chart.yaml</em>, <a data-type="indexterm" data-primary="unpacked charts" id="idm46126000164632"/>a 
<span class="keep-together"><em>values.yaml</em></span>, a <em>templates/</em> directory, and perhaps other things as well. A <em>packed</em> Helm chart contains the same information as an unpacked one, but it is tarred and gzipped into a single file.<a data-type="indexterm" data-primary="packed charts" id="idm46126000161896"/></p>

<p>An unpacked chart is represented by a directory with the name of the chart. For example, the chart named <em>mychart</em> will be unpacked into a directory named <em>mychart/</em>. In contrast, a packed chart has the name <em>and version</em> of the chart, as well as the <code>tgz</code> suffix: <code>mychart-1.2.3.tgz</code>.</p>

<p>Charts are stored in <em>chart repositories</em>, which we will cover in <a data-type="xref" href="ch07.xhtml#chart_repositories">Chapter 7</a>. <a data-type="indexterm" data-primary="chart repositories" data-secondary="about" data-tertiary="Helm working with" id="idm46126000156744"/>Helm knows how to download and install charts from repositories.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Resources, Installations, and Releases"><div class="sect2" id="idm46126000197464">
<h2>Resources, Installations, and Releases</h2>

<p>To tie together the terminology introduced in this section, when a Helm chart is installed into Kubernetes, this is what happens:<a data-type="indexterm" data-primary="Helm" data-secondary="about Kubernetes and" data-tertiary="chart installed into Kubernetes" id="idm46126000153672"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Helm" data-tertiary="chart installed into Kubernetes" id="idm46126000152360"/><a data-type="indexterm" data-primary="charts" data-secondary="about" data-tertiary="installed into Kubernetes" id="idm46126000151128"/><a data-type="indexterm" data-primary="resources" data-secondary="charts" id="idm46126000149896"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="declarative infrastructure" data-tertiary="chart installed into Kubernetes" id="idm46126000148952"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="about" id="idm46126000147704"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="Kubernetes overview" id="idm46126000146760"/><a data-type="indexterm" data-primary="Helm" data-secondary="architecture" data-tertiary="charts installed into Kubernetes" id="idm46126000145544"/></p>
<ol>
<li>
<p>Helm reads the chart (downloading if necessary).</p>
</li>
<li>
<p>It sends the values into the templates, generating Kubernetes manifests.<a data-type="indexterm" data-primary="templates" data-secondary="chart installed into Kubernetes" id="idm46126000142424"/><a data-type="indexterm" data-primary="manifests" data-secondary="chart installed into Kubernetes" id="idm46126000141432"/><a data-type="indexterm" data-primary="releases" data-secondary="chart installed into Kubernetes" id="idm46126000140472"/><a data-type="indexterm" data-primary="releases" data-secondary="templates" id="idm46126000139512"/></p>
</li>
<li>
<p>The manifests are sent to Kubernetes.</p>
</li>
<li>
<p>Kubernetes creates the requested resources inside of the cluster.</p>
</li>

</ol>

<p>When a Helm chart is installed, Helm will generate as many resource definitions as it needs. Some may create one or two, others may create hundreds. When Kubernetes receives these definitions, it will create resources for them.</p>

<p>A Helm chart may have many resource definitions. Kubernetes sees each of these as a discrete thing. But in Helm’s view all of the resources defined by a chart are related. For example, my WordPress application may have a <code>Deployment</code>, a <code>ConfigMap</code>, a 
<span class="keep-together"><code>Service</code></span>, and so on. But they are all part of one <em>chart</em>. And when I install them, they are all part of the same <em>installation</em>. The same chart can be installed more than once (with a different name each time). Thus, I may have multiple installations of the same chart, just as I might have multiple resources of the same Kubernetes resource type.</p>

<p>And this brings us to one final term. Once we install our WordPress chart, we have an installation of that chart. <a data-type="indexterm" data-primary="upgrades" data-secondary="releases" data-seealso="releases" id="idm46126000131816"/><a data-type="indexterm" data-primary="releases" data-secondary="about" id="idm46126000130568"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="upgrading an installation" data-tertiary="releases" id="idm46126000129624"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="upgrading and releases" id="idm46126000128344"/>Then we upgrade that chart using <code>helm upgrade</code>. Now, that installation has two releases. A new <em>release</em> of an installation is created each time we use Helm to modify the installation.</p>

<p>A release is created when we install a new version of WordPress. But a release is also created when we merely change the configuration of an installation, or when we rollback an installation. This is an important feature of Helm that we will see again in <a data-type="xref" href="ch07.xhtml#chart_repositories">Chapter 7</a>.<a data-type="indexterm" data-startref="ch01-arch" id="idm46126000124616"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="A Brief Note About Helm 2"><div class="sect2" id="idm46126000123784">
<h2>A Brief Note About Helm 2</h2>

<p>Those familiar with Helm 2 may notice certain concepts missing from this book. <a data-type="indexterm" data-primary="Helm" data-secondary="versions" data-tertiary="charts and" id="idm46126000122520"/><a data-type="indexterm" data-primary="versions of Helm" data-secondary="charts and" id="idm46126000121272"/><a data-type="indexterm" data-primary="charts" data-secondary="about" data-tertiary="Helm version and" id="idm46126000120328"/><a data-type="indexterm" data-primary="Helm" data-secondary="charts" data-tertiary="versions of Helm and" id="idm46126000119112"/>There is no mention of Tiller or gRPC. These things were removed from Helm 3, which is the subject of the present book. Also, this version of the book focuses on version 2 Helm charts. As confusing as it is, the Helm chart version increments separately from the Helm version. So Helm v2 used Helm Charts v1, and Helm v3 uses Helm Charts v2. These differ in a few important ways from version 1 Helm Charts—most notably in the way dependencies are declared. Helm 2 and Helm Charts v1 are considered deprecated.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46126000116984">
<h1>Conclusion</h1>

<p>The material here should prepare you for the coming chapters. But we hope it also provided insight into why we built Helm the way we did. Helm is only successful if it makes Kubernetes more usable both for the first-time users and for the long-time operations teams and SREs that use Helm day to day. The remainder of this book is dedicated to explaining (with lots of examples) how to get the most out of Helm—and how to do so securely and idiomatically.</p>
</div></section>







</div></section></div></body></html>