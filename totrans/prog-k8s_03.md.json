["```\nimport (\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/client-go/tools/clientcmd\"\n    \"k8s.io/client-go/kubernetes\"\n)\n\nkubeconfig = flag.String(\"kubeconfig\", \"~/.kube/config\", \"kubeconfig file\")\nflag.Parse()\nconfig, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\nclientset, err := kubernetes.NewForConfig(config)\n\npod, err := clientset.CoreV1().Pods(\"book\").Get(\"example\", metav1.GetOptions{})\n```", "```\nconfig, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\nif err != nil {\n    fmt.Printf(\"The kubeconfig cannot be loaded: %v\\n\", err\n    os.Exit(1)\n}\n```", "```\nconfig, err := rest.InClusterConfig()\nif err != nil {\n    // fallback to kubeconfig\n    kubeconfig := filepath.Join(\"~\", \".kube\", \"config\")\n    if envvar := os.Getenv(\"KUBECONFIG\"); len(envvar) >0 {\n        kubeconfig = envvar\n    }\n    config, err = clientcmd.BuildConfigFromFlags(\"\", kubeconfig)\n    if err != nil {\n        fmt.Printf(\"The kubeconfig cannot be loaded: %v\\n\", err\n        os.Exit(1)\n    }\n}\n```", "```\n pod, err := clientset.CoreV1().Pods(\"book\").Get(\"example\", metav1.GetOptions{})\n```", "```\ncfg, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\ncfg.AcceptContentTypes = \"application/vnd.kubernetes.protobuf,\n application/json\"\ncfg.ContentType = \"application/vnd.kubernetes.protobuf\"\nclientset, err := kubernetes.NewForConfig(cfg)\n```", "```\n// DeleteOptions may be provided when deleting an API object.\ntype DeleteOptions struct {\n    TypeMeta `json:\",inline\"`\n\n    GracePeriodSeconds *int64 `json:\"gracePeriodSeconds,omitempty\"`\n    Preconditions *Preconditions `json:\"preconditions,omitempty\"`\n    OrphanDependents *bool `json:\"orphanDependents,omitempty\"`\n    PropagationPolicy *DeletionPropagation `json:\"propagationPolicy,omitempty\"`\n\n    // When present, indicates that modifications should not be\n    // persisted. An invalid or unrecognized dryRun directive will\n    // result in an error response and no further processing of the\n    // request. Valid values are:\n    // - All: all dry run stages will be processed\n    // +optional\n    DryRun []string `json:\"dryRun,omitempty\" protobuf:\"bytes,5,rep,name=dryRun\"`\n}\n```", "```\n        // DEPRECATED - initializers are an alpha field and will be removed\n        // in v1.15.\n        Initializers *Initializers `json:\"initializers,omitempty\"\n        ```", "```\n        type JobSpec struct {\n            ...\n            // This field is alpha-level and is only honored by servers that\n            // enable the TTLAfterFinished feature.\n            TTLSecondsAfterFinished *int32 `json:\"ttlSecondsAfterFinished,omitempty\"\n        }\n        ```", "```\n// Object interface must be supported by all API types registered with Scheme.\n// Since objects in a scheme are expected to be serialized to the wire, the\n// interface an Object must provide to the Scheme allows serializers to set\n// the kind, version, and group the object is represented as. An Object may\n// choose to return a no-op ObjectKindAccessor in cases where it is not\n// expected to be serialized.\ntype Object interface {\n    GetObjectKind() schema.ObjectKind\n    DeepCopyObject() Object\n}\n```", "```\n// All objects that are serialized from a Scheme encode their type information.\n// This interface is used by serialization to set type information from the\n// Scheme onto the serialized version of an object. For objects that cannot\n// be serialized or have unique requirements, this interface may be a no-op.\ntype ObjectKind interface {\n    // SetGroupVersionKind sets or clears the intended serialized kind of an\n    // object. Passing kind nil should clear the current setting.\n    SetGroupVersionKind(kind GroupVersionKind)\n    // GroupVersionKind returns the stored group, version, and kind of an\n    // object, or nil if the object does not expose or provide these fields.\n    GroupVersionKind() GroupVersionKind\n}\n```", "```\n// TypeMeta describes an individual object in an API response or request\n// with strings representing the type of the object and its API schema version.\n// Structures that are versioned or persisted should inline TypeMeta.\n//\n// +k8s:deepcopy-gen=false\ntype TypeMeta struct {\n    // Kind is a string value representing the REST resource this object\n    // represents. Servers may infer this from the endpoint the client submits\n    // requests to.\n    // Cannot be updated.\n    // In CamelCase.\n    // +optional\n    Kind string `json:\"kind,omitempty\" protobuf:\"bytes,1,opt,name=kind\"`\n\n    // APIVersion defines the versioned schema of this representation of an\n    // object. Servers should convert recognized schemas to the latest internal\n    // value, and may reject unrecognized values.\n    // +optional\n    APIVersion string `json:\"apiVersion,omitempty\"`\n}\n```", "```\n// Pod is a collection of containers that can run on a host. This resource is\n// created by clients and scheduled onto hosts.\ntype Pod struct {\n    metav1.TypeMeta `json:\",inline\"`\n    // Standard object's metadata.\n    // +optional\n    metav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n    // Specification of the desired behavior of the pod.\n    // +optional\n    Spec PodSpec `json:\"spec,omitempty\"`\n\n    // Most recently observed status of the pod.\n    // This data may not be up to date.\n    // Populated by the system.\n    // Read-only.\n    // +optional\n    Status PodStatus `json:\"status,omitempty\"`\n}\n```", "```\napiVersion: v1\nkind: Pod\nmetadata:\n  namespace: default\n  name: example\nspec:\n  containers:\n  - name: hello\n    image: debian:latest\n    command:\n    - /bin/sh\n    args:\n    - -c\n    - echo \"hello world\"; sleep 10000\n```", "```\ntype ObjectMeta struct {\n    Name string `json:\"name,omitempty\"`\n    Namespace string `json:\"namespace,omitempty\"`\n    UID types.UID `json:\"uid,omitempty\"`\n    ResourceVersion string `json:\"resourceVersion,omitempty\"`\n    CreationTimestamp Time `json:\"creationTimestamp,omitempty\"`\n    DeletionTimestamp *Time `json:\"deletionTimestamp,omitempty\"`\n    Labels map[string]string `json:\"labels,omitempty\"`\n    Annotations map[string]string `json:\"annotations,omitempty\"`\n    ...\n}\n```", "```\nmetadata:\n  namespace: default\n  name: example\n```", "```\ntype Interface interface {\n    Discovery() discovery.DiscoveryInterface\n    AppsV1() appsv1.AppsV1Interface\n    AppsV1beta1() appsv1beta1.AppsV1beta1Interface\n    AppsV1beta2() appsv1beta2.AppsV1beta2Interface\n    AuthenticationV1() authenticationv1.AuthenticationV1Interface\n    AuthenticationV1beta1() authenticationv1beta1.AuthenticationV1beta1Interface\n    AuthorizationV1() authorizationv1.AuthorizationV1Interface\n    AuthorizationV1beta1() authorizationv1beta1.AuthorizationV1beta1Interface\n\n    ...\n}\n```", "```\ntype AppsV1beta1Interface interface {\n    RESTClient() rest.Interface\n    ControllerRevisionsGetter\n    DeploymentsGetter\n    StatefulSetsGetter\n}\n```", "```\n// DeploymentsGetter has a method to return a DeploymentInterface.\n// A group's client should implement this interface.\ntype DeploymentsGetter interface {\n    Deployments(namespace string) DeploymentInterface\n}\n\n// DeploymentInterface has methods to work with Deployment resources.\ntype DeploymentInterface interface {\n    Create(*v1beta1.Deployment) (*v1beta1.Deployment, error)\n    Update(*v1beta1.Deployment) (*v1beta1.Deployment, error)\n    UpdateStatus(*v1beta1.Deployment) (*v1beta1.Deployment, error)\n    Delete(name string, options *v1.DeleteOptions) error\n    DeleteCollection(options *v1.DeleteOptions, listOptions v1.ListOptions) error\n    Get(name string, options v1.GetOptions) (*v1beta1.Deployment, error)\n    List(opts v1.ListOptions) (*v1beta1.DeploymentList, error)\n    Watch(opts v1.ListOptions) (watch.Interface, error)\n    Patch(name string, pt types.PatchType, data []byte, subresources ...string)\n        (result *v1beta1.Deployment, err error)\n    DeploymentExpansion\n}\n```", "```\ntype ListOptions struct {\n    ...\n\n    // A selector to restrict the list of returned objects by their labels.\n    // Defaults to everything.\n    // +optional\n    LabelSelector string `json:\"labelSelector,omitempty\"`\n    // A selector to restrict the list of returned objects by their fields.\n    // Defaults to everything.\n    // +optional\n    FieldSelector string `json:\"fieldSelector,omitempty\"`\n\n    ...\n}\n```", "```\n// Interface can be implemented by anything that knows how to watch and\n// report changes.\ntype Interface interface {\n    // Stops watching. Will close the channel returned by ResultChan(). Releases\n    // any resources used by the watch.\n    Stop()\n\n    // Returns a chan which will receive all the events. If an error occurs\n    // or Stop() is called, this channel will be closed, in which case the\n    // watch should be completely cleaned up.\n    ResultChan() <-chan Event\n}\n```", "```\n// EventType defines the possible types of events.\ntype EventType string\n\nconst (\n    Added    EventType = \"ADDED\"\n    Modified EventType = \"MODIFIED\"\n    Deleted  EventType = \"DELETED\"\n    Error    EventType = \"ERROR\"\n)\n\n// Event represents a single event to a watched resource.\n// +k8s:deepcopy-gen=true\ntype Event struct {\n    Type EventType\n\n    // Object is:\n    //  * If Type is Added or Modified: the new state of the object.\n    //  * If Type is Deleted: the state of the object immediately before\n    //    deletion.\n    //  * If Type is Error: *api.Status is recommended; other types may\n    //    make sense depending on context.\n    Object runtime.Object\n}\n```", "```\ncfg, err := clientcmd.BuildConfigFromFlags(\"\", *kubeconfig)\ncfg.AcceptContentTypes = \"application/vnd.kubernetes.protobuf,application/json\"\ncfg.UserAgent = fmt.Sprintf(\n    \"book-example/v1.0 (%s/%s) kubernetes/v1.0\",\n    runtime.GOOS, runtime.GOARCH\n)\nclientset, err := kubernetes.NewForConfig(cfg)\n```", "```\n// Config holds the common attributes that can be passed to a Kubernetes\n// client on initialization.\ntype Config struct {\n    ...\n\n    // QPS indicates the maximum QPS to the master from this client.\n    // If it's zero, the created RESTClient will use DefaultQPS: 5\n    QPS float32\n\n    // Maximum burst for throttle.\n    // If it's zero, the created RESTClient will use DefaultBurst: 10.\n    Burst int\n\n    // The maximum length of time to wait before giving up on a server request.\n    // A value of zero means no timeout.\n    Timeout time.Duration\n\n    ...\n}\n```", "```\nimport (\n    ...\n    \"k8s.io/client-go/informers\"\n)\n...\nclientset, err := kubernetes.NewForConfig(config)\ninformerFactory := informers.NewSharedInformerFactory(clientset, time.Second*30)\npodInformer := informerFactory.Core().V1().Pods()\npodInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{\n    AddFunc: func(new interface{}) {...},\n    UpdateFunc: func(old, new interface{}) {...},\n    DeleteFunc: func(obj interface{}) {...},\n})\ninformerFactory.Start(wait.NeverStop)\ninformerFactory.WaitForCacheSync(wait.NeverStop)\npod, err := podInformer.Lister().Pods(\"programming-kubernetes\").Get(\"client-go\")\n```", "```\n// NewFilteredSharedInformerFactory constructs a new instance of\n// sharedInformerFactory. Listers obtained via this sharedInformerFactory will be\n// subject to the same filters as specified here.\nfunc NewFilteredSharedInformerFactory(\n    client versioned.Interface, defaultResync time.Duration,\n    namespace string,\n    tweakListOptions internalinterfaces.TweakListOptionsFunc\n) SharedInformerFactor\n\ntype TweakListOptionsFunc func(*v1.ListOptions)\n```", "```\ntype Interface interface {\n    Add(item interface{})\n    Len() int\n    Get() (item interface{}, shutdown bool)\n    Done(item interface{})\n    ShutDown()\n    ShuttingDown() bool\n}\n```", "```\n    type DelayingInterface interface {\n        Interface\n        // AddAfter adds an item to the workqueue after the\n        // indicated duration has passed.\n        AddAfter(item interface{}, duration time.Duration)\n    }\n    ```", "```\n    type RateLimitingInterface interface {\n        DelayingInterface\n\n        // AddRateLimited adds an item to the workqueue after the rate\n        // limiter says it's OK.\n        AddRateLimited(item interface{})\n\n        // Forget indicates that an item is finished being retried.\n        // It doesn't matter whether it's for perm failing or success;\n        // we'll stop the rate limiter from tracking it. This only clears\n        // the `rateLimiter`; you still have to call `Done` on the queue.\n        Forget(item interface{})\n\n        // NumRequeues returns back how many times the item was requeued.\n        NumRequeues(item interface{}) int\n    }\n    ```", "```\nRESTMapping(gk schema.GroupKind, versions ...string) (*RESTMapping, error)\n```", "```\ntype RESTMapping struct {\n    // Resource is the GroupVersionResource (location) for this endpoint.\n    Resource schema.GroupVersionResource.\n\n    // GroupVersionKind is the GroupVersionKind (data format) to submit\n    // to this endpoint.\n    GroupVersionKind schema.GroupVersionKind\n\n    // Scope contains the information needed to deal with REST Resources\n    // that are in a resource hierarchy.\n    Scope RESTScope\n}\n```", "```\n// KindFor takes a partial resource and returns the single match.\n// Returns an error if there are multiple matches.\nKindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error)\n\n// KindsFor takes a partial resource and returns the list of potential\n// kinds in priority order.\nKindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error)\n\n// ResourceFor takes a partial resource and returns the single match.\n// Returns an error if there are multiple matches.\nResourceFor(input schema.GroupVersionResource) (schema.GroupVersionResource, error)\n\n// ResourcesFor takes a partial resource and returns the list of potential\n// resource in priority order.\nResourcesFor(input schema.GroupVersionResource) ([]schema.GroupVersionResource, error)\n\n// RESTMappings returns all resource mappings for the provided group kind\n// if no version search is provided. Otherwise identifies a preferred resource\n// mapping for the provided version(s).\nRESTMappings(gk schema.GroupKind, versions ...string) ([]*RESTMapping, error)\n```", "```\nfunc (s *Scheme) ObjectKinds(obj Object) ([]schema.GroupVersionKind, bool, error)\n```", "```\nscheme.AddKnownTypes(schema.GroupVersionKind{\"\", \"v1\", \"Pod\"}, &Pod{})\n```", "```\npackage: github.com/book/example\nimport:\n- package: k8s.io/client-go\n  version: v10.0.0\n...\n```", "```\n[[constraint]]\n  name = \"k8s.io/api\"\n  version = \"kubernetes-1.13.0\"\n\n[[constraint]]\n  name = \"k8s.io/apimachinery\"\n  version = \"kubernetes-1.13.0\"\n\n[[constraint]]\n  name = \"k8s.io/client-go\"\n  version = \"10.0.0\"\n\n[prune]\n  go-tests = true\n  unused-packages = true\n\n# the following overrides are necessary to enforce\n# the given version, even though our\n# code does not import the packages directly.\n[[override]]\n  name = \"k8s.io/api\"\n  version = \"kubernetes-1.13.0\"\n\n[[override]]\n  name = \"k8s.io/apimachinery\"\n  version = \"kubernetes-1.13.0\"\n\n[[override]]\n  name = \"k8s.io/client-go\"\n  version = \"10.0.0\"\n```", "```\nmodule github.com/programming-kubernetes/pizza-apiserver\n\nrequire (\n    ...\n    k8s.io/api v0.0.0-20190222213804-5cb15d344471 // indirect\n    k8s.io/apimachinery v0.0.0-20190221213512-86fb29eff628\n    k8s.io/apiserver v0.0.0-20190319190228-a4358799e4fe\n    k8s.io/client-go v2.0.0-alpha.0.0.20190307161346-7621a5ebb88b+incompatible\n    k8s.io/klog v0.2.1-0.20190311220638-291f19f84ceb\n    k8s.io/kube-openapi v0.0.0-20190320154901-c59034cc13d5 // indirect\n    k8s.io/utils v0.0.0-20190308190857-21c4ce38f2a7 // indirect\n    sigs.k8s.io/yaml v1.1.0 // indirect\n)\n```"]