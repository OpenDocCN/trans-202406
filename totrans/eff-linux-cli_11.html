<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Leveraging Text Files"><div class="chapter" id="ch_text">
<h1><span class="label">Chapter 9. </span>Leveraging Text Files</h1>


<p><a data-type="indexterm" data-primary="file" data-secondary="text" data-see="text files" id="idm46586638567632"/><a data-type="indexterm" data-primary="text" data-secondary="files" data-see="text files" id="idm46586638566448"/><a data-type="indexterm" data-primary="text files" data-secondary="about" id="idm46586638565232"/><a data-type="indexterm" data-primary="plain text" data-see="text files" id="idm46586638564288"/>
Plain text is the most common data format<a data-type="indexterm" data-primary="text" data-secondary="Linux data format" id="idm46586638563216"/> on many Linux systems. The
content sent from command to command in most pipelines is text.
Programmers’ source code files, system configuration files in <em>/etc</em>,
and HTML and Markdown files are all text files. Email messages are
text; even attachments are stored as text internally for
transport. You might even store everyday files like shopping lists and
personal notes as text.</p>

<p>Contrast this with today’s internet, which is a mishmash of streaming
audio and video, social media posts, in-browser documents in Google
Docs and Office 365, PDFs, and other rich media. (Not to mention the
data handled by mobile apps, which have hidden the concept of a “file”
from a whole generation.)  Against this backdrop, plain-text files
seem almost quaint.</p>

<p>Nevertheless, any text file can become a rich source of data that you<a data-type="indexterm" data-primary="text files" data-secondary="designing" id="idm46586638560576"/>
can mine with carefully crafted Linux commands, especially if the text
is structured. Each line in the file <em>/etc/passwd</em>,<a data-type="indexterm" data-primary="/etc/passwd file" id="idm46586638558960"/><a data-type="indexterm" data-primary="/etc/passwd file" data-primary-sortas="etc password" id="idm46586638558224"/><a data-type="indexterm" data-primary="passwd file" data-see="/etc/passwd file" id="idm46586638557280"/> for example,
represents a Linux user and has seven fields, including username,
numeric user ID, home directory, and more. The fields are separated by
colons, making the file easily parsed by <code>cut -d:</code> or <code>awk
-F:</code>. Here’s a command that prints all usernames (the first field)
alphabetically:<a data-type="indexterm" data-primary="cut command" data-secondary="examples" id="idm46586638555376"/><a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586638554400"/></p>

<pre data-type="programlisting">$ <strong>cut -d: -f1 /etc/passwd | sort</strong>
avahi
backup
daemon
⋮</pre>

<p class="pagebreak-before">And here’s one that separates human users from system accounts by their
numeric user IDs and sends users a welcome email. Let’s build this
brash one-liner<a data-type="indexterm" data-primary="brash one-liner" id="idm46586638551760"/> step-by-step. First, use <code>awk</code> to
print the usernames (field 1) when the numeric user ID (field 3) is
1000 or greater:<a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586638550384"/></p>
<pre data-type="programlisting">$ <strong>awk -F: '$3&gt;=1000 {print $1}' /etc/passwd</strong>
jones
smith</pre>

<p>Then produce greetings by piping to <code>xargs</code>:<a data-type="indexterm" data-primary="xargs command" data-secondary="examples" id="idm46586638547424"/></p>
<pre data-type="programlisting">$ <strong>awk -F: '$3&gt;=1000 {print $1}' /etc/passwd \
  | xargs -I@ echo "Hi there, @!"</strong>
Hi there, jones!
Hi there, smith!</pre>

<p>Then generate commands (strings) to pipe each greeting to the <code>mail</code><a data-type="indexterm" data-primary="mail command" id="idm46586638544496"/>
command, which sends email to a given user with a given subject line
(<code>-s</code>):<a data-type="indexterm" data-primary="mail command" data-secondary="subject line (-s option)" id="idm46586638543280"/></p>
<pre data-type="programlisting">$ <strong>awk -F: '$3&gt;=1000 {print $1}' /etc/passwd \
  | xargs -I@ echo 'echo "Hi there, @!" | mail -s greetings @'</strong>
echo "Hi there, jones!" | mail -s greetings jones
echo "Hi there, smith!" | mail -s greetings smith</pre>

<p>Finally, pipe the generated commands to <code>bash</code> to send the emails:<a data-type="indexterm" data-primary="pipes" data-secondary="piping commands to bash" data-tertiary="examples" id="idm46586638540000"/></p>
<pre data-type="programlisting">$ <strong>awk -F: '$3&gt;=1000 {print $1}' /etc/passwd \
  | xargs -I@ echo 'echo "Hi there, @!" | mail -s greetings @' \
  | bash</strong>
echo "Hi there, jones!" | mail -s greetings jones
echo "Hi there, smith!" | mail -s greetings smith</pre>

<p>The preceding solutions, like many others in this book, begin with an
existing text file and manipulate its contents with commands. It’s
time to reverse that approach and intentionally <em>design new text
files</em> that partner well with Linux commands.<sup><a data-type="noteref" id="idm46586638536576-marker" href="ch09.xhtml#idm46586638536576">1</a></sup> This is a winning strategy to get work done efficiently on a
Linux system. All it takes is four steps:</p>
<ol>
<li>
<p>Notice a business problem you want to solve that involves data.</p>
</li>
<li>
<p>Store the data in a text file in a convenient format.</p>
</li>
<li>
<p>Invent Linux commands that process the file to solve the problem.</p>
</li>
<li>
<p>(<em>Optional</em>.) Capture those commands in scripts, aliases, or functions
to be simpler to run.</p>
</li>

</ol>

<p>In this chapter, you’ll construct a variety of structured text files, and
create commands to process them, to solve several business problems.</p>






<section data-type="sect1" data-pdf-bookmark="A First Example: Finding Files"><div class="sect1" id="section_finding_files">
<h1>A First Example: Finding Files</h1>

<p><a data-type="indexterm" data-primary="locating" data-secondary="files" data-tertiary="quickly" id="idm46586638527408"/><a data-type="indexterm" data-primary="finding files" data-secondary="quickly" id="idm46586638526160"/><a data-type="indexterm" data-primary="text files" data-secondary="finding files" id="idm46586638525216"/><a data-type="indexterm" data-primary="file" data-secondary="finding" data-tertiary="quickly" id="idm46586638524272"/><a data-type="indexterm" data-primary="find command" data-secondary="script quicker" id="idm46586638523056"/>
Suppose your home directory contains tens of thousands of files and
subdirectories, and every so often, you can’t remember where you put
one of them. The <code>find</code> command locates a file by name, such as
<em>animals.txt</em>:<a data-type="indexterm" data-primary="find command" data-secondary="examples" id="idm46586638521120"/></p>

<pre data-type="programlisting">$ <strong>find $HOME -name animals.txt -print</strong>
/home/smith/Work/Writing/Books/Lists/animals.txt</pre>

<p>but <code>find</code> is slow because it searches your entire home directory, and
you need to locate files regularly. This is step 1, noticing a
business problem that involves data: finding files in your home
directory quickly by name.</p>

<p>Step 2 is storing the data in a text file in a convenient format. Run
<code>find</code> once to build a list of all your files and directories, one
file path per line, and store it in a hidden file:</p>

<pre data-type="programlisting">$ <strong>find $HOME -print &gt; $HOME/.ALLFILES</strong>
$ <strong>head -n3 $HOME/.ALLFILES</strong>
/home/smith
/home/smith/Work
/home/smith/Work/resume.pdf
⋮</pre>

<p>Now you have the data: a line-by-line index of your files. Step 3 is
inventing Linux commands to speed up searches for files, and for that,
use <code>grep</code>. It’s much quicker to <code>grep</code> through a large file than to
run <code>find</code> in a large directory tree:<a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586638513440"/></p>

<pre data-type="programlisting">$ <strong>grep animals.txt $HOME/.ALLFILES</strong>
/home/smith/Work/Writing/Books/Lists/animals.txt</pre>

<p>Step 4 is to make the command easier to run. Write a one-line script
named <code>ff</code>,<a data-type="indexterm" data-primary="ff script" id="idm46586638510448"/> for “find files,” that runs <code>grep</code> with any user-supplied
options and a search string, as in <a data-type="xref" href="#ex_ff">Example 9-1</a>.</p>
<div id="ex_ff" data-type="example">
<h5><span class="label">Example 9-1. </span>The <code>ff</code> script</h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="c1"># $@ means all arguments provided to the script</code>
grep <code class="s2">"</code><code class="nv">$@</code><code class="s2">"</code> <code class="nv">$HOME</code>/.ALLFILES</pre></div>

<p>Make the script executable and place it into any directory in your
search path, such as your personal <em>bin</em> subdirectory:</p>
<pre data-type="programlisting">$ <strong>chmod +x ff</strong>
$ <strong>echo $PATH</strong>                                        <em>Check your search path</em>
<mark class="box">/home/smith/bin</mark>:/usr/local/bin:/usr/bin:/bin
$ <strong>mv ff ~/bin</strong></pre>

<p>Run <code>ff</code> anytime to locate files quickly when you can’t remember where
you put them.</p>

<pre data-type="programlisting">$ <strong>ff animal</strong>
/home/smith/Work/Writing/Books/Lists/animals.txt
$ <strong>ff -i animal | less</strong>                               <em>Case-insensitive grep</em>
/home/smith/Work/Writing/Books/Lists/animals.txt
/home/smith/Vacations/Zoos/Animals/pandas.txt
/home/smith/Vacations/Zoos/Animals/tigers.txt
⋮
$ <strong>ff -i animal | wc -l</strong>                              <em>How many matches?</em>
16</pre>

<p>Rerun the <code>find</code> command every so often to update the index. (Or
better yet, create a scheduled job with <code>cron<a data-type="indexterm" data-primary="cron" id="idm46586638496544"/></code>; see
<a data-type="xref" href="ch11.xhtml#section_crontab">“Learn cron, crontab, and at”</a>.) Voilà—you’ve built a fast, flexible
file-search utility out of two small commands. Linux systems provide<a data-type="indexterm" data-primary="desktop environment" data-secondary="file search utilities" id="idm46586638494752"/>
other applications that index and search files quickly, such as the
<code>locate</code> command and the search utilities in GNOME<a data-type="indexterm" data-primary="GNOME" id="idm46586638493296"/>, KDE Plasma<a data-type="indexterm" data-primary="KDE Plasma" id="idm46586638492464"/>, and
other desktop environments, but that’s beside the point.
Look how easy it was to build it <em>yourself</em>. And the key to success
was to create a text file in a simple format.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Checking Domain Expiration"><div class="sect1" id="idm46586638528960">
<h1>Checking Domain Expiration</h1>

<p><a data-type="indexterm" data-primary="domain name expiration" id="idm46586638457280"/><a data-type="indexterm" data-primary="expiring domain names" id="idm46586638456672"/><a data-type="indexterm" data-primary="text files" data-secondary="checking domain expiration" id="idm46586638456064"/>
For the next example, suppose you own some internet domain names and
want to keep track of when they expire so you can renew them. That’s
step 1, identify the business problem. Step 2 is to create a file of
those domain names, such as <em>domains.txt</em>, one domain name per line:</p>

<pre data-type="programlisting">example.com
oreilly.com
efficientlinux.com
⋮</pre>

<p>Step 3 is to invent commands that leverage this text file to determine
expiration dates. Start with the <code>whois</code><a data-type="indexterm" data-primary="whois command" id="idm46586638453056"/> command, which queries a domain
registrar<a data-type="indexterm" data-primary="registrar of domain" id="idm46586638452320"/> for information about a domain:</p>

<pre data-type="programlisting">$ <strong>whois example.com | less</strong>
Domain Name: EXAMPLE.COM
Registry Domain ID: 2336799_DOMAIN_COM-VRSN
Registrar WHOIS Server: whois.iana.org
Updated Date: 2021-08-14T07:01:44Z
Creation Date: 1995-08-14T04:00:00Z
Registry Expiry Date: 2022-08-13T04:00:00Z
⋮</pre>

<p>The expiration date is preceded by the string “Registry Expiry Date”, which
you can isolate with <code>grep</code> and <code>awk</code>:<a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586638449120"/><a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586638448112"/></p>

<pre data-type="programlisting">$ <strong>whois example.com | grep 'Registry Expiry Date:'</strong>
Registry Expiry Date: 2022-08-13T04:00:00Z
$ <strong>whois example.com | grep 'Registry Expiry Date:' | awk '{print $4}'</strong>
2022-08-13T04:00:00Z</pre>

<p>Make the date more readable via the <code>date --date</code><a data-type="indexterm" data-primary="date command" data-secondary="format conversion (--date option)" id="idm46586638444848"/> command, which can
convert a date string from one format to another:</p>

<pre data-type="programlisting">$ <strong>date --date 2022-08-13T04:00:00Z</strong>
Sat Aug 13 00:00:00 EDT 2022
$ <strong>date --date 2022-08-13T04:00:00Z +'%Y-%m-%d'</strong>       <em>Year-month-day format</em>
2022-08-13</pre>

<p>Use command substitution to feed the date string from <code>whois</code> to the
<code>date</code> command:<a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586638440432"/></p>

<pre data-type="programlisting">$ <strong>echo $(whois example.com | grep 'Registry Expiry Date:' | awk '{print $4}')</strong>
2022-08-13T04:00:00Z
$ <strong>date \
  --date $(whois example.com \
           | grep 'Registry Expiry Date:' \
	   | awk '{print $4}') \
  +'%Y-%m-%d'</strong>
2022-08-13</pre>

<p>You now have a command that queries a registrar and prints an
expiration date. Create a script <code>check-expiry</code>,<a data-type="indexterm" data-primary="check-expiry scripts" id="idm46586638436800"/> shown in
<a data-type="xref" href="#ex_check_expiry">Example 9-2</a>, that runs the preceding command and prints the
expiration date, a tab, and the domain name:</p>

<pre data-type="programlisting">$ <strong>./check-expiry example.com</strong>
2022-08-13	example.com</pre>
<div id="ex_check_expiry" data-type="example">
<h5><span class="label">Example 9-2. </span>The <code>check-expiry</code> script</h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="nv">expdate</code><code class="o">=</code><code class="k">$(</code>date <code class="se">\</code>
            --date <code class="k">$(</code>whois <code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code> <code class="se">\</code>
	             <code class="p">|</code> grep <code class="s1">'Registry Expiry Date:'</code> <code class="se">\</code>
		     <code class="p">|</code> awk <code class="s1">'{print $4}'</code><code class="k">)</code> <code class="se">\</code>
            +<code class="s1">'%Y-%m-%d'</code><code class="k">)</code>
<code class="nb">echo</code> <code class="s2">"</code><code class="nv">$expdate</code><code class="s2">	</code><code class="nv">$1</code><code class="s2">"</code>		<code class="c1"># Two values separated by a tab</code></pre></div>

<p>Now, check all domains in the file <em>domains.txt</em> using a loop.<a data-type="indexterm" data-primary="while loop" data-secondary="while read" id="idm46586638408176"/><a data-type="indexterm" data-primary="loops" data-secondary="bash" data-tertiary="while read loop" id="idm46586638407328"/> Create
a new script, <code>check-expiry-all</code>, shown in <a data-type="xref" href="#ex_check_expiry_all">Example 9-3</a>.</p>
<div id="ex_check_expiry_all" data-type="example">
<h5><span class="label">Example 9-3. </span>The <code>check-expiry-all</code> script</h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
cat domains.txt <code class="p">|</code> <code class="k">while</code> <code class="nb">read</code> domain<code class="p">;</code> <code class="k">do</code>
    ./check-expiry <code class="s2">"</code><code class="nv">$domain</code><code class="s2">"</code>
    sleep <code class="m">5</code>			<code class="c1"># Be kind to the registrar's server</code>
<code class="k">done</code></pre></div>

<p>Run the script in the background, since it may take a while if you
have many domains, and redirect all output (stdout and stderr) to
a file:</p>

<pre data-type="programlisting">$ <strong>./check-expiry-all &amp;&gt; expiry.txt &amp;</strong></pre>

<p>When the script finishes, the file <em>expiry.txt</em> contains the desired
information:</p>

<pre data-type="programlisting">$ <strong>cat expiry.txt</strong>
2022-08-13	example.com
2022-05-26	oreilly.com
2022-09-17	efficientlinux.com
⋮</pre>

<p>Hooray! But don’t stop there. The file <em>expiry.txt</em> is itself nicely
structured for further processing, with two tabbed columns.  For
example, sort the dates and find the next domain to renew:<a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586638354336"/><a data-type="indexterm" data-primary="head command" data-secondary="examples" id="idm46586638353360"/></p>

<pre data-type="programlisting">$ <strong>sort -n expiry.txt | head -n1</strong>
2022-05-26	oreilly.com</pre>

<p>Or, use <code>awk</code> to find domains that have expired or are expiring today—that is, their expiration date (field 1) is less than or equal to
today’s date (printed with <code>date +%Y-%m-%d</code>):<a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586638323632"/><a data-type="indexterm" data-primary="date command" data-secondary="examples" id="idm46586638322720"/><a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586638321744"/></p>

<pre data-type="programlisting">$ <strong>awk "\$1&lt;=\"$(date +%Y-%m-%d)\"" expiry.txt</strong></pre>

<p>A few notes on the preceding <code>awk</code> command:</p>

<ul>
<li>
<p>I escaped<a data-type="indexterm" data-primary="escaping" data-secondary="shell versus awk" id="idm46586638317936"/> the dollar sign (before <code>$1</code>) and the double quotes around
the date string so the shell doesn’t evaluate them before <code>awk</code> can.</p>
</li>
<li>
<p>I’ve cheated a bit by using the string operator <code>&lt;=</code> to
compare dates. It’s not a mathematical comparison, just a string
comparison,<a data-type="indexterm" data-primary="awk programs" data-secondary="string comparison" id="idm46586638314576"/><a data-type="indexterm" data-primary="strings" data-secondary="awk string comparison" id="idm46586638313600"/> but it works because the date format, <em><code>YYYY-MM-DD</code></em>,
sorts alphabetically and chronologically in the same order.</p>
</li>
</ul>

<p>With more effort, you could do date math in <code>awk</code> to report expiration
dates, say, two weeks in advance, then create a scheduled job to run
the script nightly and email you a report. Feel free to
experiment. The point here, however, is that once again, with a
handful of commands, you’ve built a useful utility that’s driven by a
text file.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Building an Area Code Database"><div class="sect1" id="sec_areacodes">
<h1>Building an Area Code Database</h1>

<p><a data-type="indexterm" data-primary="area codes" data-secondary="database" id="idm46586638308688"/><a data-type="indexterm" data-primary="text files" data-secondary="area codes database" id="idm46586638307776"/>
The next example uses a file with three fields that you can process in
many ways. The file, named <em>areacodes.txt</em>, contains telephone area
codes for the United States. Retrieve one from this book’s <a href="https://efficientlinux.com/examples">supplemental material</a> in the directory
<em>chapter09/build_area_code_database</em>, or create your own file, say,
from <a href="https://oreil.ly/yz2M1">Wikipedia</a>:<sup><a data-type="noteref" id="idm46586638304304-marker" href="ch09.xhtml#idm46586638304304">2</a></sup></p>

<pre data-type="programlisting">201	NJ	Hackensack, Jersey City
202	DC	Washington
203	CT	New Haven, Stamford
⋮
989	MI	Saginaw</pre>
<div data-type="tip"><h6>Tip</h6>
<p>Arrange the fields with predictable lengths first,<a data-type="indexterm" data-primary="text files" data-secondary="arranging columns neatly" id="idm46586638300416"/> so columns appear
neatly lined up to the eye. Look how messy the file appears if you
put the city names in the first column:</p>

<pre data-type="programlisting">Hackensack, Jersey City	201	NJ
Washington	202	DC
⋮</pre>
</div>

<p>Once this file is in place, you can do a lot with it. Look up area
codes by state with <code>grep</code>, adding the <code>-w</code><a data-type="indexterm" data-primary="grep command" data-secondary="full word matching (-w option)" id="idm46586638297296"/> option to match full words
only (in case other text coincidentally contains “NJ”):<a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586638296176"/></p>

<pre data-type="programlisting">$ <strong>grep -w NJ areacodes.txt</strong>
201	NJ	Hackensack, Jersey City
551	NJ	Hackensack, Jersey City
609	NJ	Atlantic City, Trenton, southeast and central west
⋮</pre>

<p>or look up cities by area code:</p>

<pre data-type="programlisting">$ <strong>grep -w 202 areacodes.txt</strong>
202	DC	Washington</pre>

<p>or by any string in the file:</p>

<pre data-type="programlisting">$ <strong>grep Washing areacodes.txt</strong>
202	DC	Washington
227	MD	Silver Spring, Washington suburbs, Frederick
240	MD	Silver Spring, Washington suburbs, Frederick
⋮</pre>

<p>Count the area codes with <code>wc</code>:<a data-type="indexterm" data-primary="wc command" data-secondary="examples" id="idm46586638289872"/></p>

<pre data-type="programlisting">$ <strong>wc -l areacodes.txt</strong>
375 areacodes.txt</pre>

<p>Find the state with the most area codes (the winner is California with 38):<a data-type="indexterm" data-primary="cut command" data-secondary="examples" id="idm46586638287312"/><a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586638286336"/><a data-type="indexterm" data-primary="uniq command" data-secondary="examples" id="idm46586638285392"/><a data-type="indexterm" data-primary="head command" data-secondary="examples" id="idm46586638284448"/></p>

<pre data-type="programlisting">$ <strong>cut -f2 areacodes.txt | sort | uniq -c | sort -nr | head -n1</strong>
     38 CA</pre>

<p>Convert the file to CSV format<a data-type="indexterm" data-primary="CSV format" id="idm46586638281840"/> to import into a spreadsheet
application. Print the third field enclosed in double quotes to
prevent its commas from being interpreted as CSV separator characters:<a data-type="indexterm" data-primary="separator" data-secondary="CSV files" id="idm46586638281008"/><a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586638280064"/></p>

<pre data-type="programlisting">$ <strong>awk -F'\t' '{printf "%s,%s,\"%s\"\n", $1, $2, $3}' areacodes.txt \
  &gt; areacodes.csv</strong>
$ <strong>head -n3 areacodes.csv</strong>
201,NJ,"Hackensack, Jersey City"
202,DC,"Washington"
203,CT,"New Haven, Stamford"</pre>

<p>Collate all area codes for a given state onto a single line:</p>

<pre data-type="programlisting">$ <strong>awk '$2~/^NJ$/{ac=ac FS $1} END {print "NJ:" ac}' areacodes.txt</strong>
NJ: 201 551 609 732 848 856 862 908 973</pre>

<p>or collate for each state, using arrays<a data-type="indexterm" data-primary="awk programs" data-secondary="arrays" id="idm46586638275008"/><a data-type="indexterm" data-primary="arrays, awk" id="idm46586638274032"/> and <code>for</code> loops<a data-type="indexterm" data-primary="for loop" data-secondary="awk" id="idm46586638272816"/><a data-type="indexterm" data-primary="loops" data-secondary="awk for loop" id="idm46586638271808"/><a data-type="indexterm" data-primary="awk programs" data-secondary="loops" id="idm46586638270864"/> as in <a data-type="xref" href="ch05.xhtml#sec_awk_arrays">“Improving the duplicate file detector”</a>:</p>

<pre data-type="programlisting">$ <strong>awk '{arr[$2]=arr[$2] " " $1} \
         END {for (i in arr) print i ":" arr[i]}' areacodes.txt \
  | sort</strong>
AB: 403 780
AK: 907
AL: 205 251 256 334 659
⋮
WY: 307</pre>

<p>Turn any of the preceding commands into aliases, functions, or
scripts, whatever is convenient. A simple example is the <code>areacode</code>
script in <a data-type="xref" href="#ex_areacodes">Example 9-4</a>.<a data-type="indexterm" data-primary="area codes" data-secondary="areacode script" id="idm46586638266016"/><a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586638265040"/></p>
<div id="ex_areacodes" data-type="example">
<h5><span class="label">Example 9-4. </span>The <code>areacode</code> script</h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="k">if</code> <code class="o">[</code> -n <code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
  grep -iw <code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code> areacodes.txt
<code class="k">fi</code></pre></div>

<p>The <code>areacode</code> script searches for any whole word in the <em>areacodes.txt</em> file,
such as an area code, state abbreviation, or city name:</p>

<pre data-type="programlisting">$ <strong>areacode 617</strong>
617	MA	Boston</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Building a Password Manager"><div class="sect1" id="section_pman">
<h1>Building a Password Manager</h1>

<p><a data-type="indexterm" data-primary="text files" data-secondary="password manager" id="passmangr"/><a data-type="indexterm" data-primary="password manager" id="passmangr2"/>
For a final, in-depth example, let’s store usernames, passwords, and
notes in an encrypted text file, in a structured format for easy
retrieval on the command line. The resulting command is a basic
password manager, an application that eases the burden of memorizing
lots of complicated passwords.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Password management is a complex topic in computer security<a data-type="indexterm" data-primary="security" data-secondary="password management" id="idm46586638235600"/>. This
example creates an extremely basic password manager as an educational
exercise. Don’t use it for mission-critical applications.</p>
</div>

<p class="pagebreak-after">The password file, named <em>vault</em>, has three fields separated by
single tab characters:</p>

<ul>
<li>
<p>Username</p>
</li>
<li>
<p>Password</p>
</li>
<li>
<p>Notes (any text)</p>
</li>
</ul>

<p>Create the <em>vault</em> file and add the data. The file is not encrypted
yet, so insert only fake passwords for now:</p>

<pre data-type="programlisting">$ <strong>touch vault</strong>                                     <em>Create an empty file</em>
$ <strong>chmod 600 vault</strong>                                 <em>Set file permissions</em>
$ <strong>emacs vault</strong>                                     <em>Edit the file</em>
$ <strong>cat vault</strong>
sally	fake1	google.com account
ssmith	fake2	dropbox.com account for work
s999	fake3	Bank of America account, bankofamerica.com
smith2	fake4	My blog at wordpress.org
birdy	fake5	dropbox.com account for home</pre>

<p>Store the vault in a known location:</p>
<pre data-type="programlisting">$ <strong>mkdir ~/etc</strong>
$ <strong>mv vault ~/etc</strong></pre>

<p>The idea is to use a pattern-matching program like <code>grep</code> or <code>awk</code> to
print lines that match a given string. This simple but powerful
technique can match any part of any line, rather than just usernames
or websites. For example:<a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586638203184"/></p>

<pre data-type="programlisting">$ <strong>cd ~/etc</strong>
$ <strong>grep sally vault</strong>                            <em>Match a username</em>
sally	fake1	google.com account
$ <strong>grep work vault</strong>                             <em>Match the notes</em>
ssmith	fake2	dropbox.com account for work
$ <strong>grep drop vault</strong>                             <em>Match multiple lines</em>
ssmith	fake2	dropbox.com account for work
birdy	fake5	dropbox.com account for home</pre>

<p>Capture this simple functionality in a script; then, let’s improve it
step-by-step, including finally encrypting the <em>vault</em> file. Call the
script <code>pman</code><a data-type="indexterm" data-primary="pman script" id="pman"/> for “password manager” and create the trivial version in
<a data-type="xref" href="#ex_pman_1">Example 9-5</a>.</p>
<div id="ex_pman_1" data-type="example">
<h5><span class="label">Example 9-5. </span><code>pman</code> version 1: as simple as it gets</h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="c1"># Just print matching lines</code>
grep <code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code> <code class="nv">$HOME</code>/etc/vault</pre></div>

<p>Store the script in your search path:</p>

<pre data-type="programlisting">$ <strong>chmod 700 pman</strong>
$ <strong>mv pman ~/bin</strong></pre>

<p>Try the script:</p>

<pre data-type="programlisting">$ <strong>pman goog</strong>
sally	fake1	google.com account
$ <strong>pman account</strong>
sally	fake1	google.com account
ssmith	fake2	dropbox.com account for work
s999	fake3	Bank of America account, bankofamerica.com
birdy	fake5	dropbox.com account for home
$ <strong>pman facebook</strong>                                        <em>(produces no output)</em></pre>

<p>The next version in <a data-type="xref" href="#ex_pman_2">Example 9-6</a> adds a bit of error checking and some
memorable variable names.</p>
<div id="ex_pman_2" data-type="example">
<h5><span class="label">Example 9-6. </span><code>pman</code> version 2: add some error checking<a data-type="indexterm" data-primary="$0" data-secondary="shell script name" id="idm46586638188512"/><a data-type="indexterm" data-primary="dollar sign ($)" data-secondary="$0" data-tertiary="shell script name" id="idm46586638187536"/><a data-type="indexterm" data-primary="basename command" id="idm46586638186320"/><a data-type="indexterm" data-primary="&gt;&amp;2 to redirect stdout to stderr" id="idm46586638185648"/><a data-type="indexterm" data-primary="greater than (&gt;)" data-secondary="&gt;&amp;2 to redirect stdout to stderr" id="idm46586638185008"/><a data-type="indexterm" data-primary="greater than (&gt;)" data-secondary="redirecting stdout" id="idm46586638184096"/><a data-type="indexterm" data-primary="redirection" data-secondary="echo to stderr" id="idm46586638183152"/><a data-type="indexterm" data-primary="echo command" data-secondary="printing on stderr" id="idm46586638182208"/></h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="c1"># Capture the script name.</code>
<code class="c1"># $0 is the path to the script, and basename prints the final filename.</code>
<code class="nv">PROGRAM</code><code class="o">=</code><code class="k">$(</code>basename <code class="nv">$0</code><code class="k">)</code>
<code class="c1"># Location of the password vault</code>
<code class="nv">DATABASE</code><code class="o">=</code><code class="nv">$HOME</code>/etc/vault

<code class="c1"># Ensure that at least one argument was provided to the script.</code>
<code class="c1"># The expression &gt;&amp;2 directs echo to print on stderr instead of stdout.</code>
<code class="k">if</code> <code class="o">[</code> <code class="nv">$#</code> -ne <code class="m">1</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: look up passwords by string"</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"Usage: </code><code class="nv">$PROGRAM</code><code class="s2"> string"</code>
    <code class="nb">exit</code> <code class="m">1</code>
<code class="k">fi</code>
<code class="c1"># Store the first argument in a friendly, named variable</code>
<code class="nv">searchstring</code><code class="o">=</code><code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code>

<code class="c1"># Search the vault and print an error message if nothing matches</code>
grep <code class="s2">"</code><code class="nv">$searchstring</code><code class="s2">"</code> <code class="s2">"</code><code class="nv">$DATABASE</code><code class="s2">"</code>
<code class="k">if</code> <code class="o">[</code> <code class="nv">$?</code> -ne <code class="m">0</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: no matches for '</code><code class="nv">$searchstring</code><code class="s2">'"</code>
    <code class="nb">exit</code> <code class="m">1</code>
<code class="k">fi</code></pre></div>

<p>Run the script:</p>

<pre data-type="programlisting">$ <strong>pman</strong>
pman: look up passwords by string
Usage: pman string
$ <strong>pman smith</strong>
ssmith	fake2	dropbox.com account for work
smith2	fake4	My blog at wordpress.org
$ <strong>pman xyzzy</strong>
pman: no matches for 'xyzzy'</pre>

<p>A shortcoming of this technique is that it won’t scale. If <em>vault</em>
contained hundreds of lines and <code>grep</code> matched and printed 63 of them,
you’d have to hunt by eye to find the password you need. Improve the
script by adding a unique key (a string) to each line in the third
column, and update <code>pman</code> to search for that unique key first. The
<em>vault</em> file, with third column bolded, now looks like:</p>

<pre data-type="programlisting">sally	fake1	<strong>google</strong>	google.com account
ssmith	fake2	<strong>dropbox</strong>	dropbox.com account for work
s999	fake3	<strong>bank</strong>	Bank of America account, bankofamerica.com
smith2	fake4	<strong>blog</strong>	My blog at wordpress.org
birdy	fake5	<strong>dropbox2</strong>	dropbox.com account for home</pre>

<p><a data-type="xref" href="#ex_pman_3">Example 9-7</a> shows the updated script that uses <code>awk</code> instead of
<code>grep</code>. It also uses command substitution to capture the output and
check if it’s empty (the test <code>-z</code><a data-type="indexterm" data-primary="zero" data-secondary="string length test" id="idm46586638028000"/><a data-type="indexterm" data-primary="empty string test" id="idm46586638027024"/><a data-type="indexterm" data-primary="strings" data-secondary="empty string test" id="idm46586638026352"/> means “zero length string”). Notice
that if you search for a key that doesn’t exist in <em>vault</em>, <code>pman</code>
falls back to its original behavior and prints all lines that match
the search string.</p>
<div id="ex_pman_3" data-type="example">
<h5><span class="label">Example 9-7. </span><code>pman</code> version 3: prioritize searching for the key in the third column<a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586638022896"/><a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586638021920"/></h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="nv">PROGRAM</code><code class="o">=</code><code class="k">$(</code>basename <code class="nv">$0</code><code class="k">)</code>
<code class="nv">DATABASE</code><code class="o">=</code><code class="nv">$HOME</code>/etc/vault

<code class="k">if</code> <code class="o">[</code> <code class="nv">$#</code> -ne <code class="m">1</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: look up passwords"</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"Usage: </code><code class="nv">$PROGRAM</code><code class="s2"> string"</code>
    <code class="nb">exit</code> <code class="m">1</code>
<code class="k">fi</code>
<code class="nv">searchstring</code><code class="o">=</code><code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code>

<code class="c1"># Look for exact matches in the third column</code>
<code class="nv">match</code><code class="o">=</code><code class="k">$(</code>awk <code class="s1">'$3~/^'</code><code class="nv">$searchstring</code><code class="s1">'$/'</code> <code class="s2">"</code><code class="nv">$DATABASE</code><code class="s2">"</code><code class="k">)</code>

<code class="c1"># If the search string doesn't match a key, find all matches</code>
<code class="k">if</code> <code class="o">[</code> -z <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    <code class="nv">match</code><code class="o">=</code><code class="k">$(</code>awk <code class="s2">"/</code><code class="nv">$searchstring</code><code class="s2">/"</code> <code class="s2">"</code><code class="nv">$DATABASE</code><code class="s2">"</code><code class="k">)</code>
<code class="k">fi</code>

<code class="c1"># If still no match, print an error message and exit</code>
<code class="k">if</code> <code class="o">[</code> -z <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: no matches for '</code><code class="nv">$searchstring</code><code class="s2">'"</code>
    <code class="nb">exit</code> <code class="m">1</code>
<code class="k">fi</code>

<code class="c1"># Print the match</code>
<code class="nb">echo</code> <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code></pre></div>

<p class="pagebreak-before">Run the script:</p>

<pre data-type="programlisting">$ <strong>pman dropbox</strong>
ssmith	fake2	dropbox	dropbox.com account for work
$ <strong>pman drop</strong>
ssmith	fake2	dropbox	dropbox.com account for work
birdy	fake5	dropbox2	dropbox.com account for home</pre>

<p>The plain-text file <em>vault</em> is a security risk, so encrypt it with the
standard Linux encryption<a data-type="indexterm" data-primary="text files" data-secondary="encrypted" id="idm46586637962464"/><a data-type="indexterm" data-primary="encrypted text file" id="idm46586637961488"/><a data-type="indexterm" data-primary="file" data-secondary="encrypted" id="idm46586637960816"/> program GnuPG,<a data-type="indexterm" data-primary="gpg command (GnuPG)" id="idm46586637959744"/> which is invoked as <code>gpg</code>.
If you already have GnuPG set up for use, that’s great.  Otherwise,
set it up with the following command, supplying your email
address:<sup><a data-type="noteref" id="idm46586637958336-marker" href="ch09.xhtml#idm46586637958336">3</a></sup></p>

<pre data-type="programlisting">$ <strong>gpg --quick-generate-key <em>your_email_address</em> default default never</strong></pre>

<p>You’re prompted for a passphrase for the key (twice). Provide a
strong passphrase. When <code>gpg</code> completes, you’re ready to encrypt the
password file using public key encryption, producing the file
<em>vault.gpg</em>:</p>

<pre data-type="programlisting">$ <strong>cd ~/etc</strong>
$ <strong>gpg -e -r <em>your_email_address</em> vault</strong>
$ <strong>ls vault* </strong>
vault   vault.gpg</pre>

<p>As a test, decrypt the <em>vault.gpg</em> file to stdout:<sup><a data-type="noteref" id="idm46586637859744-marker" href="ch09.xhtml#idm46586637859744">4</a></sup></p>

<pre data-type="programlisting">$ <strong>gpg -d -q vault.gpg</strong>
Passphrase: <strong>xxxxxxxx</strong>
sally	fake1	google	google.com account
ssmith	fake2	dropbox	dropbox.com account for work
⋮</pre>

<p>Next, update your script to use the encrypted <em>vault.gpg</em> file instead
of the plain-text <em>vault</em> file. That means decrypting <em>vault.gpg</em> to
stdout and piping its contents to <code>awk</code> for matching, as in <a data-type="xref" href="#ex_pman_4">Example 9-8</a>.<a data-type="indexterm" data-primary="awk command" data-secondary="examples" id="idm46586637852800"/><a data-type="indexterm" data-primary="command substitution" data-secondary="examples" id="idm46586637851824"/></p>
<div id="ex_pman_4" data-type="example">
<h5><span class="label">Example 9-8. </span><code>pman</code> version 4: using an encrypted vault</h5>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="nv">PROGRAM</code><code class="o">=</code><code class="k">$(</code>basename <code class="nv">$0</code><code class="k">)</code>
<code class="c1"># Use the encrypted file</code>
<code class="nv">DATABASE</code><code class="o">=</code><code class="nv">$HOME</code>/etc/vault.gpg

<code class="k">if</code> <code class="o">[</code> <code class="nv">$#</code> -ne <code class="m">1</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: look up passwords"</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"Usage: </code><code class="nv">$PROGRAM</code><code class="s2"> string"</code>
    <code class="nb">exit</code> <code class="m">1</code>
<code class="k">fi</code>
<code class="nv">searchstring</code><code class="o">=</code><code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code>

<code class="c1"># Store the decrypted text in a variable</code>
<code class="nv">decrypted</code><code class="o">=</code><code class="k">$(</code>gpg -d -q <code class="s2">"</code><code class="nv">$DATABASE</code><code class="s2">"</code><code class="k">)</code>
<code class="c1"># Look for exact matches in the third column</code>
<code class="nv">match</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code> <code class="s2">"</code><code class="nv">$decrypted</code><code class="s2">"</code> <code class="p">|</code> awk <code class="s1">'$3~/^'</code><code class="nv">$searchstring</code><code class="s1">'$/'</code><code class="k">)</code>

<code class="c1"># If the search string doesn't match a key, find all matches</code>
<code class="k">if</code> <code class="o">[</code> -z <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    <code class="nv">match</code><code class="o">=</code><code class="k">$(</code><code class="nb">echo</code> <code class="s2">"</code><code class="nv">$decrypted</code><code class="s2">"</code> <code class="p">|</code> awk <code class="s2">"/</code><code class="nv">$searchstring</code><code class="s2">/"</code><code class="k">)</code>
<code class="k">fi</code>

<code class="c1"># If still no match, print an error message and exit</code>
<code class="k">if</code> <code class="o">[</code> -z <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code> <code class="o">]</code><code class="p">;</code> <code class="k">then</code>
    &gt;<code class="p">&amp;</code><code class="m">2</code> <code class="nb">echo</code> <code class="s2">"</code><code class="nv">$PROGRAM</code><code class="s2">: no matches for '</code><code class="nv">$searchstring</code><code class="s2">'"</code>
    <code class="nb">exit</code> <code class="m">1</code>
<code class="k">fi</code>

<code class="c1"># Print the match</code>
<code class="nb">echo</code> <code class="s2">"</code><code class="nv">$match</code><code class="s2">"</code></pre></div>

<p>The script now displays passwords from the encrypted file:</p>

<pre data-type="programlisting">$ <strong>pman dropbox</strong>
Passphrase: <strong>xxxxxxxx</strong>
ssmith	fake2	dropbox	dropbox.com account for work
$ <strong>pman drop</strong>
Passphrase: <strong>xxxxxxxx</strong>
ssmith	fake2	dropbox	dropbox.com account for work
birdy	fake5	dropbox2	dropbox.com account for home</pre>

<p>All the pieces are in place now for your password manager. Some final steps are:</p>

<ul>
<li>
<p>When you’re convinced that you can decrypt the <em>vault.gpg</em> file
reliably, delete the original <em>vault</em> file.</p>
</li>
<li>
<p>If you wish, replace the fake passwords with real ones. See
<a data-type="xref" href="#sidebar_gpg_edit">“Editing Encrypted Files Directly”</a> for advice on editing an encrypted text file.</p>
</li>
<li>
<p>Support comments in the password vault—lines that begin with a
pound sign (<code>#</code>)—so you can make notes about the entries. To do so,
update the script to pipe the decrypted contents to <code>grep -v</code> to
filter any lines that begin with a pound sign:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">decrypted</code><code class="o">=</code><code class="k">$(</code>gpg -d -q <code class="s2">"</code><code class="nv">$DATABASE</code><code class="s2">"</code> <code class="p">|</code> grep -v <code class="s1">'^#'</code><code class="k">)</code></pre>
</li>
</ul>

<p>Printing passwords on stdout isn’t great for security.
<a data-type="xref" href="ch10.xhtml#sec_pman2">“Improving the Password Manager”</a> will update this script to copy and paste
passwords instead of printing them.<a data-type="indexterm" data-startref="pman" id="idm46586637672304"/><a data-type="indexterm" data-startref="passmangr" id="idm46586637671696"/><a data-type="indexterm" data-startref="passmangr2" id="idm46586637671024"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_gpg_edit">
<h5>Editing Encrypted Files Directly</h5>
<p>To<a data-type="indexterm" data-primary="encrypted text file" data-secondary="editing" id="idm46586637668352"/><a data-type="indexterm" data-primary="editing files" data-secondary="encrypted text files" id="idm46586637667344"/><a data-type="indexterm" data-primary="file" data-secondary="encrypted" data-tertiary="editing" id="idm46586637666400"/><a data-type="indexterm" data-primary="text files" data-secondary="encrypted" data-tertiary="editing" id="idm46586637665184"/> modify an encrypted file, the most direct, tedious, and insecure
method is to decrypt the file, edit it, and re-encrypt it.</p>

<pre data-type="programlisting">$ <strong>cd ~/etc</strong>
$ <strong>gpg vault.gpg</strong>                               <em>Decrypt</em>
Passphrase: <strong>xxxxxxxx</strong>
$ <strong>emacs vault</strong>                                 <em>Use your favorite text editor</em>
$ <strong>gpg -e -r <em><code>your_email_address</code></em> vault</strong>          <em>Encrypt for yourself</em>
$ <strong>rm vault</strong></pre>

<p>For easier editing of the <em>vault.gpg</em> file, both <code>emacs</code> and <code>vim</code> have
modes for editing GnuPG-encrypted files. Begin by adding this line to
a <code>bash</code> configuration file and sourcing it in any associated shells:<a data-type="indexterm" data-primary="variables" data-secondary="GPG_TTY" id="idm46586637630176"/><a data-type="indexterm" data-primary="gpg command (GnuPG)" data-secondary="GPG_TTY variable" id="idm46586637629200"/></p>

<pre data-type="programlisting" data-code-language="bash"><code class="nb">export</code> <code class="nv">GPG_TTY</code><code class="o">=</code><code class="k">$(</code>tty<code class="k">)</code></pre>

<p>For <code>emacs</code>, set up the EasyPG package,<a data-type="indexterm" data-primary="EasyPG package" id="idm46586637613872"/><a data-type="indexterm" data-primary="emacs editor" data-secondary="EasyPG package" id="idm46586637613264"/>
which is built-in. Add the
following lines to the configuration file <em>$HOME/.emacs</em><a data-type="indexterm" data-primary="configuration files" data-secondary="text editors" id="idm46586637624720"/><a data-type="indexterm" data-primary="text editors" data-secondary="configuration files" id="idm46586637623744"/>
and restart <code>emacs</code>. Replace the string <em>GnuPG ID here</em>
with the email address associated with your key, such as
<code>smith@example.com</code>:</p>

<pre data-type="programlisting">(load-library "pinentry")
(setq epa-pinentry-mode 'loopback)
(setq epa-file-encrypt-to "<em>GnuPG ID here</em>")
(pinentry-start)</pre>

<p>Then edit any encrypted file, and <code>emacs</code> prompts for your
passphrase and decrypts it into a buffer for editing. On save, <code>emacs</code>
encrypts the contents of the buffer.</p>

<p>For <code>vim</code>, try the plugin
<a href="https://oreil.ly/mnwYc">vim-gnupg</a><a data-type="indexterm" data-primary="vim editor" data-secondary="vim-gnupg plugin" id="idm46586637605248"/> and add these lines
to the configuration file <em>$HOME/.vimrc</em>:</p>

<pre data-type="programlisting">let g:GPGPreferArmor=1
let g:GPGDefaultRecipients=["<em>GnuPG ID here</em>"]</pre>

<p>Consider creating an alias to edit the password vault conveniently,
using the technique from the section <a data-type="xref" href="ch04.xhtml#tip_edit_alias">“Edit Frequently Edited Files with an Alias”</a>:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nb">alias</code> <code class="nv">pwedit</code><code class="o">=</code><code class="s2">"</code><code class="nv">$EDITOR</code><code class="s2"> </code><code class="nv">$HOME</code><code class="s2">/etc/vault.gpg"</code></pre>
</div></aside>
</div></section>













<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586637595200">
<h1>Summary</h1>

<p>File paths, domain names, area codes, and login credentials are just a
few examples of data that work well in a structured text file. How
about:</p>

<ul>
<li>
<p>Your music files? (Use a Linux command like <code>id3tool</code> to extract ID3
information from your MP3 files and place it into a file.)</p>
</li>
<li>
<p>The contacts on your mobile device? (Use an app to export the
contacts to CSV format, upload them to cloud storage, and then
download them to your Linux machine for processing.)</p>
</li>
<li>
<p>Your grades in school? (Use <code>awk</code> to track your grade point
average.)</p>
</li>
<li>
<p>A list of movies you’ve seen or books you’ve read, with additional
data (ratings, authors, actors, etc.)?</p>
</li>
</ul>

<p>In this manner, you can build an ecosystem of time-saving commands that
are personally meaningful or productive for work, limited only by your
imagination.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586638536576"><sup><a href="ch09.xhtml#idm46586638536576-marker">1</a></sup> This approach is similar to designing a database schema<a data-type="indexterm" data-primary="database schema" id="idm46586638535952"/> to work well with known queries.</p><p data-type="footnote" id="idm46586638304304"><sup><a href="ch09.xhtml#idm46586638304304-marker">2</a></sup> The <a href="https://oreil.ly/SptWL">official list of area codes in CSV format</a>, <a data-type="indexterm" data-primary="CSV format" id="idm46586638302928"/>maintained by the North American Numbering Plan Administrator, lacks city names.</p><p data-type="footnote" id="idm46586637958336"><sup><a href="ch09.xhtml#idm46586637958336-marker">3</a></sup> This command generates a public/private key pair with all default options and an expiration date of “never.” To learn more, see <code>man gpg</code> to read about <code>gpg</code> options, or seek out a GnuPG tutorial online.</p><p data-type="footnote" id="idm46586637859744"><sup><a href="ch09.xhtml#idm46586637859744-marker">4</a></sup> If <code>gpg</code> proceeds without prompting for your passphrase, it has cached<a data-type="indexterm" data-primary="caching" data-secondary="gpg passphrase" id="idm46586637858704"/> (saved) your passphrase temporarily.</p></div></div></section></div></body></html>