<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Functions"><div class="chapter" id="functions">
<h1><span class="label">Chapter 5. </span>Functions</h1>

<blockquote>
<p>Function arguments</p>

<p>In one end, out the other</p>

<p>As a return type</p></blockquote>

<p>In <a data-type="xref" data-xrefstyle="chap-num-title" href="ch02.xhtml#the_type_system">Chapter 2, “The Type System”</a>, you saw how to use type annotations to annotate values of variables.
Now, you’ll see how to do the same with function parameters and return types—and why that can be useful.</p>






<section data-type="sect1" data-pdf-bookmark="Function Parameters"><div class="sect1" id="idm45584689261728">
<h1>Function Parameters</h1>

<p>Take<a data-type="indexterm" data-primary="functions" data-secondary="parameters" data-tertiary="type annotations for" id="function-param-typeanno"/><a data-type="indexterm" data-primary="parameters" data-secondary="type annotations for" id="params-typeanno"/><a data-type="indexterm" data-primary="type annotations" data-secondary="for function parameters" id="typeanno-params"/> the following <code>sing</code> function that takes in a <code>song</code> parameter and logs it:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">sing</code><code class="p">(</code><code class="nx">song</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Singing: </code><code class="si">${</code><code class="nx">song</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>What value type did the developer who wrote the <code>sing</code> function intend for the <code>song</code> parameter to be provided with?</p>

<p>Is it a <code>string</code>?
Is it an object with an overridden <code>toString()</code> method?
Is this code buggy?
<em>Who knows?!</em></p>

<p>Without explicit type information declared, we may never know—TypeScript will consider it to be the <code>any</code> type, meaning the parameter’s type could be anything.</p>

<p>As with variables, TypeScript allows you to declare the type of function parameters with a type annotation.
Now we can use a <code>: string</code> to tell TypeScript that the <code>song</code> parameter is of type <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">sing</code><code class="p">(</code><code class="nx">song</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Singing: </code><code class="si">${</code><code class="nx">song</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Much better: now we know what type <code>song</code> is meant to be!</p>

<p>Note that you don’t need to add proper type annotations to function parameters for your code to be valid TypeScript syntax.
TypeScript might yell at you with type errors, but the emitted JavaScript will still run.
The previous code snippet missing a type declaration on the <code>song</code> parameter will still convert from TypeScript to JavaScript.
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a> will cover how to configure TypeScript’s complaints about parameters that are implicitly of type <code>any</code> the <a data-type="indexterm" data-primary="functions" data-secondary="parameters" data-tertiary="type annotations for" data-startref="function-param-typeanno" id="idm45584689185728"/><a data-type="indexterm" data-primary="parameters" data-secondary="type annotations for" data-startref="params-typeanno" id="idm45584689184176"/><a data-type="indexterm" data-primary="type annotations" data-secondary="for function parameters" data-startref="typeanno-params" id="idm45584689182960"/>way <code>song</code> is.</p>








<section data-type="sect2" data-pdf-bookmark="Required Parameters"><div class="sect2" id="idm45584689181200">
<h2>Required Parameters</h2>

<p>Unlike<a data-type="indexterm" data-primary="functions" data-secondary="parameters" data-tertiary="required" id="idm45584689179600"/><a data-type="indexterm" data-primary="parameters" data-secondary="required" id="idm45584689178320"/><a data-type="indexterm" data-primary="required parameters" id="idm45584689177376"/> JavaScript, which allows functions to be called with any number of arguments, TypeScript assumes that all parameters declared on a function are required.
If a function is called with a wrong number of arguments, TypeScript will protest in the form of a type error.
TypeScript’s argument counting will come into play if a function is called with either too few or too many arguments.</p>

<p>This <code>singTwo</code> function requires two parameters, so passing one argument and passing three arguments are both not allowed:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">singTwo</code><code class="p">(</code><code class="nx">first</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">second</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">first</code><code class="si">}</code><code class="sb"> / </code><code class="si">${</code><code class="nx">second</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// Logs: "Ball and Chain / undefined"</code>
<code class="nx">singTwo</code><code class="p">(</code><code class="s2">"Ball and Chain"</code><code class="p">);</code>
<code class="c1">//      ~~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Expected 2 arguments, but got 1.</code>

<code class="c1">// Logs: "I Will Survive / Higher Love"</code>
<code class="nx">singTwo</code><code class="p">(</code><code class="s2">"I Will Survive"</code><code class="p">,</code> <code class="s2">"Higher Love"</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="c1">// Logs: "Go Your Own Way / The Chain"</code>
<code class="nx">singTwo</code><code class="p">(</code><code class="s2">"Go Your Own Way"</code><code class="p">,</code> <code class="s2">"The Chain"</code><code class="p">,</code> <code class="s2">"Dreams"</code><code class="p">);</code>
<code class="c1">//                                      ~~~~~~~~</code>
<code class="c1">// Error: Expected 2 arguments, but got 3.</code></pre>

<p>Enforcing that required parameters be provided to a function helps enforce type safety by making sure all expected argument values exist inside the function.
Failing to ensure those values exist could result in unexpected behavior in code, such as the previous <code>singTwo</code> function logging <code>undefined</code> or ignoring an argument.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Parameter</em> refers to a function’s declaration of what it expects to receive as an argument.
<em>Argument</em> refers to a value provided to a parameter in a function call.
In the previous example, <code>first</code> and <code>second</code> are parameters, while strings such as <code>"Dreams"</code> are arguments.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Optional Parameters"><div class="sect2" id="idm45584689102560">
<h2>Optional Parameters</h2>

<p>Recall<a data-type="indexterm" data-primary="functions" data-secondary="parameters" data-tertiary="optional" id="function-param-optional"/><a data-type="indexterm" data-primary="parameters" data-secondary="optional" id="parameters-optional"/><a data-type="indexterm" data-primary="optional parameters" id="optional-parameters"/> that in JavaScript, if a function parameter is not provided, its argument value inside the function defaults to <code>undefined</code>.
Sometimes function parameters are not necessary to provide, and the intended use of the function is for that <code>undefined</code> value.
We wouldn’t want TypeScript to report type errors for failing to provide arguments to those optional parameters.
TypeScript allows annotating a parameter as optional by <a data-type="indexterm" data-primary="? (question mark)" data-secondary="optional parameters" id="idm45584689056704"/><a data-type="indexterm" data-primary="question mark (?)" data-secondary="optional parameters" id="idm45584689055728"/>adding a <code>?</code> before the <code>:</code> in its type annotation—similar to optional object type properties.</p>

<p>Optional parameters don’t need to be provided to function calls.
Their types therefore always have <code>| undefined</code> added as a union type.</p>

<p>In the following <code>announceSong</code> function, the <code>singer</code> parameter is marked optional.
Its type <a data-type="indexterm" data-primary="undefined primitive" data-secondary="for optional parameters" data-secondary-sortas="optional parameters" id="idm45584689051312"/>is <code>string | undefined</code>, and it doesn’t need to be provided by callers of the function.
If <code>singer</code> is provided, it may be a <code>string</code> value or <code>undefined</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">announceSong</code><code class="p">(</code><code class="nx">song</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">singer?</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Song: </code><code class="si">${</code><code class="nx">song</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>

  <code class="k">if</code> <code class="p">(</code><code class="nx">singer</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Singer: </code><code class="si">${</code><code class="nx">singer</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">announceSong</code><code class="p">(</code><code class="s2">"Greensleeves"</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">announceSong</code><code class="p">(</code><code class="s2">"Greensleeves"</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">announceSong</code><code class="p">(</code><code class="s2">"Chandelier"</code><code class="p">,</code> <code class="s2">"Sia"</code><code class="p">);</code> <code class="c1">// Ok</code></pre>

<p>These optional parameters are always implicitly able to be <code>undefined</code>.
In the previous code, <code>singer</code> starts off as being of type <code>string | undefined</code>, then is narrowed to just <code>string</code> by the <code>if</code> statement.</p>

<p>Optional parameters are not the same as parameters with union types that happen to include <code>| undefined</code>.
Parameters that aren’t marked as optional with a <code>?</code> must always be provided, even if the value is explicitly <code>undefined</code>.</p>

<p>The <code>singer</code> parameter in this <code>announceSongBy</code> function must be provided explicitly.
It may be a <code>string</code> value or <code>undefined</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">announceSongBy</code><code class="p">(</code><code class="nx">song</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">singer</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>

<code class="nx">announceSongBy</code><code class="p">(</code><code class="s2">"Greensleeves"</code><code class="p">);</code>
<code class="c1">// Error: Expected 2 arguments, but got 1.</code>

<code class="nx">announceSongBy</code><code class="p">(</code><code class="s2">"Greensleeves"</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">announceSongBy</code><code class="p">(</code><code class="s2">"Chandelier"</code><code class="p">,</code> <code class="s2">"Sia"</code><code class="p">);</code> <code class="c1">// Ok</code></pre>

<p>Any optional parameters for a function must be the last parameters.
Placing an optional parameter before a required parameter would trigger a TypeScript syntax <a data-type="indexterm" data-primary="functions" data-secondary="parameters" data-tertiary="optional" data-startref="function-param-optional" id="idm45584688931360"/><a data-type="indexterm" data-primary="parameters" data-secondary="optional" data-startref="parameters-optional" id="idm45584688922304"/><a data-type="indexterm" data-primary="optional parameters" data-startref="optional-parameters" id="idm45584688921088"/>error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">announceSinger</code><code class="p">(</code><code class="nx">singer?</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">song</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{}</code>
<code class="c1">//                                       ~~~~</code>
<code class="c1">// Error: A required parameter cannot follow an optional parameter.</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Default Parameters"><div class="sect2" id="idm45584689062288">
<h2>Default Parameters</h2>

<p>Optional <a data-type="indexterm" data-primary="functions" data-secondary="parameters" data-tertiary="default" id="idm45584688875616"/><a data-type="indexterm" data-primary="parameters" data-secondary="default" id="idm45584688874336"/><a data-type="indexterm" data-primary="default parameters" id="idm45584688873392"/><a data-type="indexterm" data-primary="undefined primitive" data-secondary="for default parameters" data-secondary-sortas="default parameters" id="idm45584688872720"/> parameters in JavaScript may be given a default value with an <code>=</code> and a value in their declaration.
For these optional parameters, because a value is provided by default, their TypeScript type does not implicitly have the <code>| undefined</code> union added on inside the function.
TypeScript will still allow the function to be called with missing or <code>undefined</code> arguments for those parameters.</p>

<p>TypeScript’s type inference works similarly for default function parameter values as it does for initial variable values.
If a parameter has a default value and doesn’t have a type annotation, TypeScript will infer the parameter’s type based on that default value.</p>

<p>In the following <code>rateSong</code> function, <code>rating</code> is inferred to be of type <code>number</code>, but is an optional <code>number | undefined</code> in the code that calls the function:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">rateSong</code><code class="p">(</code><code class="nx">song</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">rating</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">song</code><code class="si">}</code><code class="sb"> gets </code><code class="si">${</code><code class="nx">rating</code><code class="si">}</code><code class="sb">/5 stars!`</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">rateSong</code><code class="p">(</code><code class="s2">"Photograph"</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">rateSong</code><code class="p">(</code><code class="s2">"Set Fire to the Rain"</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">rateSong</code><code class="p">(</code><code class="s2">"Set Fire to the Rain"</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">rateSong</code><code class="p">(</code><code class="s2">"At Last!"</code><code class="p">,</code> <code class="s2">"100"</code><code class="p">);</code>
<code class="c1">//                   ~~~~~</code>
<code class="c1">// Error: Argument of type '"100"' is not assignable</code>
<code class="c1">// to parameter of type 'number | undefined'.</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Rest Parameters"><div class="sect2" id="idm45584688737584">
<h2>Rest Parameters</h2>

<p>Some <a data-type="indexterm" data-primary="functions" data-secondary="parameters" data-tertiary="rest" id="function-param-rest"/><a data-type="indexterm" data-primary="parameters" data-secondary="rest" data-tertiary="as arrays" data-tertiary-sortas="arrays" id="parameter-rest"/><a data-type="indexterm" data-primary="rest parameters" data-secondary="as arrays" data-secondary-sortas="arrays" id="rest-parameters"/><a data-type="indexterm" data-primary="arrays" data-secondary="rest parameters as" id="array-rest-param"/>functions in JavaScript are made to be called with any number of arguments.
The <code>...</code> spread operator<a data-type="indexterm" data-primary=". . . (ellipsis), spread operator" id="idm45584688787952"/><a data-type="indexterm" data-primary="ellipsis (. . .), spread operator" id="idm45584688787248"/><a data-type="indexterm" data-primary="spread operator (. . .)" id="idm45584688786608"/> may be placed on the last parameter in a function declaration to indicate any “rest” arguments passed to the function starting at that parameter should all be stored in a single array.</p>

<p>TypeScript allows declaring the types of these rest parameters similarly to regular parameters, except with a <code>[]</code> syntax added at the end to indicate it’s an array of arguments.</p>

<p>Here, <code>singAllTheSongs</code> is allowed to take zero or more arguments of type <code>string</code> for its <code>songs</code> rest parameter:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">singAllTheSongs</code><code class="p">(</code><code class="nx">singer</code>: <code class="nx">string</code><code class="p">,</code> <code class="p">...</code><code class="nx">songs</code>: <code class="nx">string</code><code class="p">[])</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">song</code> <code class="nx">of</code> <code class="nx">songs</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">song</code><code class="si">}</code><code class="sb">, by </code><code class="si">${</code><code class="nx">singer</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">singAllTheSongs</code><code class="p">(</code><code class="s2">"Alicia Keys"</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">singAllTheSongs</code><code class="p">(</code><code class="s2">"Lady Gaga"</code><code class="p">,</code> <code class="s2">"Bad Romance"</code><code class="p">,</code> <code class="s2">"Just Dance"</code><code class="p">,</code> <code class="s2">"Poker Face"</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">singAllTheSongs</code><code class="p">(</code><code class="s2">"Ella Fitzgerald"</code><code class="p">,</code> <code class="mi">2000</code><code class="p">);</code>
<code class="c1">//                                 ~~~~</code>
<code class="c1">// Error: Argument of type 'number' is not</code>
<code class="c1">// assignable to parameter of type 'string'.</code></pre>

<p>I’ll cover working with arrays in TypeScript <a data-type="indexterm" data-primary="functions" data-secondary="parameters" data-tertiary="rest" data-startref="function-param-rest" id="idm45584688725328"/><a data-type="indexterm" data-primary="parameters" data-secondary="rest" data-tertiary="as arrays" data-tertiary-sortas="arrays" data-startref="parameter-rest" id="idm45584688691456"/><a data-type="indexterm" data-primary="rest parameters" data-secondary="as arrays" data-secondary-sortas="arrays" data-startref="rest-parameters" id="idm45584688689696"/><a data-type="indexterm" data-primary="arrays" data-secondary="rest parameters as" data-startref="array-rest-param" id="idm45584688688208"/>in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch06.xhtml#arrays_chapter">Chapter 6, “Arrays”</a>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Return Types"><div class="sect1" id="idm45584689261136">
<h1>Return Types</h1>

<p>TypeScript <a data-type="indexterm" data-primary="functions" data-secondary="return types" data-tertiary="described" id="idm45584688684064"/><a data-type="indexterm" data-primary="types" data-secondary="function return types" data-tertiary="described" id="idm45584688624336"/><a data-type="indexterm" data-primary="return types" data-secondary="described" id="idm45584688623248"/>is perceptive: if it understands all the possible values returned by a function, it’ll know what type the function returns.
In this example, <code>singSongs</code> is understood by TypeScript to return a <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: (songs: string[]) =&gt; number</code>
<code class="kd">function</code> <code class="nx">singSongs</code><code class="p">(</code><code class="nx">songs</code>: <code class="nx">string</code><code class="p">[])</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">song</code> <code class="nx">of</code> <code class="nx">songs</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">song</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="nx">songs</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>If a function contains multiple <code>return</code> statements with different values, TypeScript will infer the return type to be a union of all the possible returned types.</p>

<p>This <code>getSongAt</code> function would be inferred to return <code>string | undefined</code> because its two possible returned values are typed <code>string</code> and <code>undefined</code>, 
<span class="keep-together">respectively:</span></p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: (songs: string[], index: number) =&gt; string | undefined</code>
<code class="kd">function</code> <code class="nx">getSongAt</code><code class="p">(</code><code class="nx">songs</code>: <code class="nx">string</code><code class="p">[],</code> <code class="nx">index</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">index</code> <code class="o">&lt;</code> <code class="nx">songs</code><code class="p">.</code><code class="nx">length</code>
    <code class="o">?</code> <code class="nx">songs</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code>
    <code class="o">:</code> <code class="kc">undefined</code><code class="p">;</code>
<code class="p">}</code></pre>








<section data-type="sect2" data-pdf-bookmark="Explicit Return Types"><div class="sect2" id="idm45584688536848">
<h2>Explicit Return Types</h2>

<p>As with <a data-type="indexterm" data-primary="functions" data-secondary="return types" data-tertiary="explicit" id="function-return-explicit"/><a data-type="indexterm" data-primary="types" data-secondary="function return types" data-tertiary="explicit" id="type-return-explicit"/><a data-type="indexterm" data-primary="return types" data-secondary="explicit" id="return-explicit"/><a data-type="indexterm" data-primary="explicit return types" id="explicit-return"/><a data-type="indexterm" data-primary="type annotations" data-secondary="for function return types" data-secondary-sortas="function return types" id="type-anno-return"/>variables, I generally recommend not bothering to explicitly declare the return types of functions with type annotations.
However, there are a few cases where it can be useful specifically for functions:</p>

<ul>
<li>
<p>You might want to enforce functions with many possible returned values always return the same type of value.</p>
</li>
<li>
<p>TypeScript will refuse to try to reason through return types of recursive function.</p>
</li>
<li>
<p>It can speed up TypeScript type checking in very large projects—i.e., those with hundreds of TypeScript files or more.</p>
</li>
</ul>

<p>Function declaration return type annotations are placed after the <code>)</code> following the list of parameters.</p>

<p>For a function declaration, that falls just before the <code>{</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">singSongsRecursive</code><code class="p">(</code><code class="nx">songs</code>: <code class="nx">string</code><code class="p">[],</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">songs</code><code class="p">.</code><code class="nx">length</code> <code class="o">?</code> <code class="nx">singSongsRecursive</code><code class="p">(</code><code class="nx">songs</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="nx">count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code> <code class="o">:</code> <code class="nx">count</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>For arrow functions (also known as lambdas), that falls just before the <code>=&gt;</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">singSongsRecursive</code> <code class="o">=</code> <code class="p">(</code><code class="nx">songs</code>: <code class="nx">string</code><code class="p">[],</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="o">=&gt;</code>
  <code class="nx">songs</code><code class="p">.</code><code class="nx">length</code> <code class="o">?</code> <code class="nx">singSongsRecursive</code><code class="p">(</code><code class="nx">songs</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="nx">count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code> <code class="o">:</code> <code class="nx">count</code><code class="p">;</code></pre>

<p>If a <code>return</code> statement in a function returns a value not assignable to the function’s return type, TypeScript will give an assignability complaint.</p>

<p>Here, the <code>getSongRecordingDate</code> function is explicitly declared as returning <code>Date | undefined</code>, but one of its return statements incorrectly provides a <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">getSongRecordingDate</code><code class="p">(</code><code class="nx">song</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Date</code><code class="o"> | </code><code class="nx">undefined</code> <code class="p">{</code>
  <code class="k">switch</code> <code class="p">(</code><code class="nx">song</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">case</code> <code class="s2">"Strange Fruit"</code><code class="o">:</code>
      <code class="k">return</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s1">'April 20, 1939'</code><code class="p">);</code> <code class="c1">// Ok</code>

    <code class="k">case</code> <code class="s2">"Greensleeves"</code><code class="o">:</code>
      <code class="k">return</code> <code class="s2">"unknown"</code><code class="p">;</code>
      <code class="c1">// Error: Type 'string' is not assignable to type 'Date'.</code>

    <code class="k">default</code><code class="o">:</code>
      <code class="k">return</code> <code class="kc">undefined</code><code class="p">;</code> <code class="c1">// Ok</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Function Types"><div class="sect1" id="idm45584688523760">
<h1>Function Types</h1>

<p>JavaScript<a data-type="indexterm" data-primary="functions" data-secondary="as types" data-tertiary="described" data-secondary-sortas="types" id="function-type-describe"/><a data-type="indexterm" data-primary="types" data-secondary="functions as" data-tertiary="described" id="type-function-describe"/> allows us to pass functions around as values.
That means we need a way to declare the type of a parameter or variable meant to hold a function.</p>

<p>Function type syntax looks similar to an arrow function, but with a type instead of the body.</p>

<p>This <code>nothingInGivesString</code> variable’s type describes a function with no parameters and a returned <code>string</code> value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">nothingInGivesString</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code></pre>

<p>This <code>inputAndOutput</code> variable’s type describes a function with a <code>string[]</code> parameter, an optional <code>count</code> parameter, and a returned <code>number</code> value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">inputAndOutput</code><code class="o">:</code> <code class="p">(</code><code class="nx">songs</code>: <code class="nx">string</code><code class="p">[],</code> <code class="nx">count?</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code></pre>

<p>Function types are frequently used to describe callback parameters (parameters meant to be called as functions).</p>

<p>For example, the following <code>runOnSongs</code> snippet declares the type of its <code>getSongAt</code> parameter to be a function that takes in an <code>index: number</code> and returns a <code>string</code>.
Passing <code>getSongAt</code> matches that type, but <code>logSong</code> fails for taking in a <code>string</code> as its parameter instead of a <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">songs</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Juice"</code><code class="p">,</code> <code class="s2">"Shake It Off"</code><code class="p">,</code> <code class="s2">"What's Up"</code><code class="p">];</code>

<code class="kd">function</code> <code class="nx">runOnSongs</code><code class="p">(</code><code class="nx">getSongAt</code><code class="o">:</code> <code class="p">(</code><code class="nx">index</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">songs</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">getSongAt</code><code class="p">(</code><code class="nx">i</code><code class="p">));</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">getSongAt</code><code class="p">(</code><code class="nx">index</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">songs</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">runOnSongs</code><code class="p">(</code><code class="nx">getSongAt</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="kd">function</code> <code class="nx">logSong</code><code class="p">(</code><code class="nx">song</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">song</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">runOnSongs</code><code class="p">(</code><code class="nx">logSong</code><code class="p">);</code>
<code class="c1">//         ~~~~~~~</code>
<code class="c1">// Error: Argument of type '(song: string) =&gt; string' is not</code>
<code class="c1">// assignable to parameter of type '(index: number) =&gt; string'.</code>
<code class="c1">//   Types of parameters 'song' and 'index' are incompatible.</code>
<code class="c1">//     Type 'number' is not assignable to type 'string'.</code></pre>

<p>The error message for <code>runOnSongs(logSong)</code> is an example of an <a data-type="indexterm" data-primary="errors" data-secondary="assignability errors" data-tertiary="for function types" data-tertiary-sortas="function types" id="errors-assign-function"/><a data-type="indexterm" data-primary="assignability" data-secondary="errors" data-tertiary="for function types" data-tertiary-sortas="function types" id="assign-error-function"/>assignability error that includes a few levels of details.
When complaining that two function types aren’t assignable to each other, TypeScript will typically give three levels of detail, with increasing levels of specificity:</p>
<ol>
<li>
<p>The first indentation level prints out the two function types.</p>
</li>
<li>
<p>The next indentation level specifies which part is mismatched.</p>
</li>
<li>
<p>The last indentation level is the precise assignability complaint of the mismatched part.</p>
</li>

</ol>

<p>In the previous code snippet, those levels are:</p>
<ol>
<li>
<p><code>logSong</code>s: <code>(strong: string) =&gt; string</code> is the provided type being assigned to the <code>getSongAt: (index: number) =&gt; string</code> recipient</p>
</li>
<li>
<p>The <code>song</code> parameter of <code>logSong</code> being assigned to the <code>index</code> parameter of 
<span class="keep-together"><code>getSongAt</code></span></p>
</li>
<li>
<p><code>song</code>’s <code>number</code> type is not assignable to <code>index</code>’s <code>string</code> type</p>
</li>

</ol>
<div data-type="tip"><h6>Tip</h6>
<p>TypeScript’s multiline errors can seem daunting at first.
Reading through them line-by-line and understanding what each part is conveying goes a long way to comprehending the <a data-type="indexterm" data-primary="functions" data-secondary="as types" data-tertiary="described" data-secondary-sortas="types" data-startref="function-type-describe" id="idm45584688038848"/><a data-type="indexterm" data-primary="types" data-secondary="functions as" data-tertiary="described" data-startref="type-function-describe" id="idm45584688037056"/>error.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Function Type Parentheses"><div class="sect2" id="idm45584688035184">
<h2>Function Type Parentheses</h2>

<p>Function types<a data-type="indexterm" data-primary="functions" data-secondary="as types" data-tertiary="parentheses in" data-secondary-sortas="types" id="idm45584688033712"/><a data-type="indexterm" data-primary="types" data-secondary="functions as" data-tertiary="parentheses in" id="idm45584688032160"/><a data-type="indexterm" data-primary="parentheses ()" data-secondary="in function types" id="idm45584688030944"/><a data-type="indexterm" data-primary="() (parentheses)" data-secondary="in function types" id="idm45584688030000"/> may be placed anywhere that another type would be used.
That includes union types.</p>

<p>In union types, parentheses may be used to indicate which part of an annotation is the function return or the surrounding union type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type is a function that returns a union: string | undefined</code>
<code class="kd">let</code> <code class="nx">returnsStringOrUndefined</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">undefined</code><code class="p">;</code>

<code class="c1">// Type is either undefined or a function that returns a string</code>
<code class="kd">let</code> <code class="nx">maybeReturnsString</code><code class="o">:</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">)</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code></pre>

<p>Later chapters that introduce more type syntaxes will show other places where function types must be wrapped with parentheses.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Parameter Type Inferences"><div class="sect2" id="idm45584688016800">
<h2>Parameter Type Inferences</h2>

<p>It <a data-type="indexterm" data-primary="functions" data-secondary="as types" data-tertiary="inferring parameter types" data-secondary-sortas="types" id="function-type-infer"/><a data-type="indexterm" data-primary="types" data-secondary="functions as" data-tertiary="inferring parameter types" id="type-function-infer"/><a data-type="indexterm" data-primary="parameters" data-secondary="inferring types" id="parameters-infer"/>would be cumbersome if we had to declare parameter types for every function we write, including inline functions used as parameters.
Fortunately, TypeScript can infer the types of parameters in a function provided to a location with a declared type.</p>

<p>This <code>singer</code> variable is known to be a function that takes in a parameter of type <code>string</code>, so the <code>song</code> parameter in the function later assigned to <code>singer</code> is known to be a <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">singer</code><code class="o">:</code> <code class="p">(</code><code class="nx">song</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>

<code class="nx">singer</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">song</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// Type of song: string</code>
  <code class="k">return</code> <code class="sb">`Singing: </code><code class="si">${</code><code class="nx">song</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code><code class="si">}</code><code class="sb">!`</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="p">};</code></pre>

<p>Functions passed as arguments to parameters with function parameter types will have their parameter types inferred as well.</p>

<p>For example, the <code>song</code> and <code>index</code> parameters here are inferred by TypeScript to be <code>string</code> and <code>number</code>, respectively:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">songs</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Call Me"</code><code class="p">,</code> <code class="s2">"Jolene"</code><code class="p">,</code> <code class="s2">"The Chain"</code><code class="p">];</code>

<code class="c1">// song: string</code>
<code class="c1">// index: number</code>
<code class="nx">songs</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">song</code><code class="p">,</code> <code class="nx">index</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">song</code><code class="si">}</code><code class="sb"> is at index </code><code class="si">${</code><code class="nx">index</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">});</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Function Type Aliases"><div class="sect2" id="idm45584687885152">
<h2>Function Type Aliases</h2>

<p>Remember <a data-type="indexterm" data-primary="functions" data-secondary="as types" data-tertiary="type aliases for" data-secondary-sortas="types" id="function-type-alias"/><a data-type="indexterm" data-primary="types" data-secondary="functions as" data-tertiary="type aliases for" id="type-function-alias"/><a data-type="indexterm" data-primary="type aliases" data-secondary="for functions" id="typealias-function"/>type aliases from <a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.xhtml#unions_and_literals">Chapter 3, “Unions and Literals”</a>?
They can be used for function types as well.</p>

<p>This <code>StringToNumber</code> type aliases a function that takes in a <code>string</code> and returns a <code>number</code>, which means it can be used later to describe the types of variables:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">StringToNumber</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code>

<code class="kd">let</code> <code class="nx">stringToNumber</code>: <code class="nx">StringToNumber</code><code class="p">;</code>

<code class="nx">stringToNumber</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">stringToNumber</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">input</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
<code class="c1">//                          ~~~~~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Type 'string' is not assignable to type 'number'.</code></pre>

<p>Similarly, function parameters can themselves be typed with aliases that happen to refer to a function type.</p>

<p>This <code>usesNumberToString</code> function has a single parameter which is itself the <code>NumberToString</code> aliased function type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">NumberToString</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">usesNumberToString</code><code class="p">(</code><code class="nx">numberToString</code>: <code class="nx">NumberToString</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`The string is: </code><code class="si">${</code><code class="nx">numberToString</code><code class="p">(</code><code class="mi">1234</code><code class="p">)</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">usesNumberToString</code><code class="p">((</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="sb">`</code><code class="si">${</code><code class="nx">input</code><code class="si">}</code><code class="sb">! Hooray!`</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">usesNumberToString</code><code class="p">((</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">input</code> <code class="o">*</code> <code class="mi">2</code><code class="p">);</code>
<code class="c1">//                            ~~~~~~~~~</code>
<code class="c1">// Error: Type 'number' is not assignable to type 'string'.</code></pre>

<p>Type aliases are particularly useful for function types.
They can save a lot of horizontal space in having to repeatedly write out parameters and/or return <a data-type="indexterm" data-primary="functions" data-secondary="as types" data-tertiary="type aliases for" data-secondary-sortas="types" data-startref="function-type-alias" id="idm45584687735696"/><a data-type="indexterm" data-primary="types" data-secondary="functions as" data-tertiary="type aliases for" data-startref="type-function-alias" id="idm45584687713616"/><a data-type="indexterm" data-primary="type aliases" data-secondary="for functions" data-startref="typealias-function" id="idm45584687712128"/>types.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="More Return Types"><div class="sect1" id="idm45584688311088">
<h1>More Return Types</h1>

<p>Now, let’s look at two more return types: <code>void</code> and <code>never</code>.</p>








<section data-type="sect2" data-pdf-bookmark="Void Returns"><div class="sect2" id="idm45584687665136">
<h2>Void Returns</h2>

<p>Some <a data-type="indexterm" data-primary="functions" data-secondary="return types" data-tertiary="void" id="function-return-void"/><a data-type="indexterm" data-primary="types" data-secondary="function return types" data-tertiary="void" id="type-return-void"/><a data-type="indexterm" data-primary="return types" data-secondary="void" id="return-void"/><a data-type="indexterm" data-primary="void return type" id="void-return"/>functions aren’t meant to return any value.
They either have no <code>return</code> statements or only have <code>return</code> statements that don’t return a value.
TypeScript allows using a <code>void</code> keyword to refer to the return type of such a function that returns nothing.</p>

<p>Functions whose return type is <code>void</code> may not return a value.
This <code>logSong</code> function is declared as returning <code>void</code>, so it’s not allowed to return a value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">logSong</code><code class="p">(</code><code class="nx">song</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">song</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code><code class="p">;</code> <code class="c1">// Ok</code>
  <code class="p">}</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">song</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>

  <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
  <code class="c1">// Error: Type 'boolean' is not assignable to type 'void'.</code>
<code class="p">}</code></pre>

<p><code>void</code> can be useful as the return type in a function type declaration.
When used in a function type declaration, <code>void</code> indicates that any returned value from the function would be ignored.</p>

<p class="less_space pagebreak-before">For example, this <code>songLogger</code> variable represents a function that takes in a <code>song: string</code> and doesn’t return a value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">songLogger</code><code class="o">:</code> <code class="p">(</code><code class="nx">song</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>

<code class="nx">songLogger</code> <code class="o">=</code> <code class="p">(</code><code class="nx">song</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">songs</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">};</code>

<code class="nx">songLogger</code><code class="p">(</code><code class="s2">"Heart of Glass"</code><code class="p">);</code> <code class="c1">// Ok</code></pre>

<p>Note that<a data-type="indexterm" data-primary="undefined primitive" data-secondary="void return type vs." id="idm45584687568176"/> although JavaScript functions all return <code>undefined</code> by default if no real value is returned, <code>void</code> is not the same as <code>undefined</code>.
<code>void</code> means the return type of a function will be ignored, while <code>undefined</code> is a literal value to be returned.
Trying to assign a value of type <code>void</code> to a value whose type instead includes <code>undefined</code> is a type error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">returnsVoid() {</code>
  <code class="k">return</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">lazyValue</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>

<code class="nx">lazyValue</code> <code class="o">=</code> <code class="nx">returnsVoid</code><code class="p">();</code>
<code class="c1">// Error: Type 'void' is not assignable to type 'string | undefined'.</code></pre>

<p>The distinction between <code>undefined</code> and <code>void</code> returns is particularly useful for ignoring any returned value from a function passed to a location whose type is declared as returning <code>void</code>.
For example, the built-in <code>forEach</code> method on arrays takes in a callback that returns <code>void</code>.
Functions provided to <code>forEach</code> can return any value they want.
<code>records.push(record)</code> in the following <code>saveRecords</code> function returns a <code>number</code> (the returned value from an array’s <code>.push()</code>), yet is still allowed to be the returned value for the arrow function passed to <code>newRecords.forEach</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">records</code>: <code class="nx">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>

<code class="kd">function</code> <code class="nx">saveRecords</code><code class="p">(</code><code class="nx">newRecords</code>: <code class="nx">string</code><code class="p">[])</code> <code class="p">{</code>
  <code class="nx">newRecords</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">record</code> <code class="o">=&gt;</code> <code class="nx">records</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">record</code><code class="p">));</code>
<code class="p">}</code>

<code class="nx">saveRecords</code><code class="p">([</code><code class="s1">'21'</code><code class="p">,</code> <code class="s1">'Come On Over'</code><code class="p">,</code> <code class="s1">'The Bodyguard'</code><code class="p">])</code></pre>

<p>The <code>void</code> type is not JavaScript.
It’s a TypeScript keyword used to declare return types of functions.
Remember, it’s an indication that a function’s returned value isn’t meant to be used, not a value that can itself be <a data-type="indexterm" data-primary="functions" data-secondary="return types" data-tertiary="void" data-startref="function-return-void" id="idm45584687450752"/><a data-type="indexterm" data-primary="types" data-secondary="function return types" data-tertiary="void" data-startref="type-return-void" id="idm45584687449328"/><a data-type="indexterm" data-primary="return types" data-secondary="void" data-startref="return-void" id="idm45584687447840"/><a data-type="indexterm" data-primary="void return type" data-startref="void-return" id="idm45584687446624"/>returned.</p>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Never Returns"><div class="sect2" id="idm45584687664544">
<h2>Never Returns</h2>

<p>Some <a data-type="indexterm" data-primary="functions" data-secondary="return types" data-tertiary="never" id="idm45584687443808"/><a data-type="indexterm" data-primary="types" data-secondary="function return types" data-tertiary="never" id="idm45584687442528"/><a data-type="indexterm" data-primary="return types" data-secondary="never" id="idm45584687441312"/><a data-type="indexterm" data-primary="never type" data-secondary="as function return type" data-secondary-sortas="function return type" id="idm45584687399008"/>functions not only don’t return a value, but aren’t meant to return at all.
Never-returning functions are those that always throw an error or run an infinite loop (hopefully intentionally!).</p>

<p>If a function is meant to never return, adding an explicit <code>: never</code> type annotation indicates that any code after a call to that function won’t run.
This <code>fail</code> function only ever throws an error, so it can help TypeScript’s control flow analysis with type narrowing <code>param</code> to <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">fail</code><code class="p">(</code><code class="nx">message</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">never</code> <code class="p">{</code>
    <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`Invariant failure: </code><code class="si">${</code><code class="nx">message</code><code class="si">}</code><code class="sb">.`</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">workWithUnsafeParam</code><code class="p">(</code><code class="nx">param</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">param</code> <code class="o">!==</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">fail</code><code class="p">(</code><code class="sb">`param should be a string, not </code><code class="si">${</code><code class="k">typeof</code> <code class="nx">param</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="c1">// Here, param is known to be type string</code>
    <code class="nx">param</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok</code>
<code class="p">}</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>never</code> is not the same as <code>void</code>.
<code>void</code> is for a function that returns nothing.
<code>never</code> is for a function that never returns.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Function Overloads"><div class="sect1" id="idm45584687354064">
<h1>Function Overloads</h1>

<p>Some <a data-type="indexterm" data-primary="functions" data-secondary="overloading" id="function-overload"/><a data-type="indexterm" data-primary="overload signatures" id="overload-signature"/><a data-type="indexterm" data-primary="implementations" data-secondary="signatures" id="implementation-signature"/>JavaScript functions are able to be called with drastically different sets of parameters that can’t be represented just by optional and/or rest parameters.
These functions can be described with a TypeScript syntax called <em>overload signatures</em>: declaring different versions of the function’s name, parameters, and return types multiple times before one final <em>implementation signature</em> and the body of the function.</p>

<p>When determining whether to emit a syntax error for a call to an overloaded function, TypeScript will only look at the function’s overload signatures.
The implementation signature is only used by the function’s internal logic.</p>

<p>This <code>createDate</code> function is meant to be called either with one <code>timestamp</code> parameter or with three parameters—<code>month</code>, <code>day</code>, and <code>year</code>.
Calling with either of those numbers of arguments is allowed, but calling with two arguments would cause a type error because no overload signature allows for two arguments.
In this example, the first two lines are the overload signatures, and the third line is the implementation signature:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kd">function</code> <code class="nx">createDate</code><code class="p">(</code><code class="nx">timestamp</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="nb">Date</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">createDate</code><code class="p">(</code><code class="nx">month</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">day</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">year</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="nb">Date</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">createDate</code><code class="p">(</code><code class="nx">monthOrTimestamp</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">day?</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">year?</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">day</code> <code class="o">===</code> <code class="kc">undefined</code> <code class="o">||</code> <code class="nx">year</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="nx">monthOrTimestamp</code><code class="p">)</code>
    <code class="o">:</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="nx">year</code><code class="p">,</code> <code class="nx">monthOrTimestamp</code><code class="p">,</code> <code class="nx">day</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">createDate</code><code class="p">(</code><code class="mi">554356800</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">createDate</code><code class="p">(</code><code class="mi">7</code><code class="p">,</code> <code class="mi">27</code><code class="p">,</code> <code class="mi">1987</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">createDate</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>
<code class="c1">// Error: No overload expects 2 arguments, but overloads</code>
<code class="c1">// do exist that expect either 1 or 3 arguments.</code></pre>

<p>Overload signatures, as with other type system syntaxes, are erased when compiling TypeScript to output JavaScript.</p>

<p>The previous code snippet’s function would compile to roughly the following 
<span class="keep-together">JavaScript:</span></p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">createDate</code><code class="p">(</code><code class="nx">monthOrTimestamp</code><code class="p">,</code> <code class="nx">day</code><code class="p">,</code> <code class="nx">year</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">day</code> <code class="o">===</code> <code class="kc">undefined</code> <code class="o">||</code> <code class="nx">year</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="nx">monthOrTimestamp</code><code class="p">)</code>
    <code class="o">:</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="nx">year</code><code class="p">,</code> <code class="nx">monthOrTimestamp</code><code class="p">,</code> <code class="nx">day</code><code class="p">);</code>
<code class="p">}</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Function overloads are generally used as a last resort for complex, difficult-to-describe function types.
It’s generally better to keep functions simple and avoid using function overloads when 
<span class="keep-together">possible.</span></p>
</div>








<section data-type="sect2" data-pdf-bookmark="Call-Signature Compatibility"><div class="sect2" id="idm45584687138192">
<h2>Call-Signature Compatibility</h2>

<p>The implementation signature used for an overloaded function’s implementation is what the function’s implementation uses for parameter types and return type.
Thus, the return type and each parameter in a function’s overload signatures must be assignable to the parameter at the same index in its implementation signature.
In other words, the implementation signature has to be compatible with all of the overload signatures.</p>

<p>This <code>format</code> function’s implementation signature declares its first parameter to be a <code>string</code>.
While the first two overload signatures are compatible for also being type <code>string</code>, the third overload signature’s <code>() =&gt; string</code> type is <a data-type="indexterm" data-primary="functions" data-secondary="overloading" data-startref="function-overload" id="idm45584687134592"/><a data-type="indexterm" data-primary="overload signatures" data-startref="overload-signature" id="idm45584687133312"/><a data-type="indexterm" data-primary="implementations" data-secondary="signatures" data-startref="implementation-signature" id="idm45584687087904"/>not compatible:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kd">function</code> <code class="nx">format</code><code class="p">(</code><code class="nx">data</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="kd">function</code> <code class="nx">format</code><code class="p">(</code><code class="nx">data</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">needle</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">haystack</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="kd">function</code> <code class="nx">format</code><code class="p">(</code><code class="nx">getData</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="c1">//       ~~~~~~</code>
<code class="c1">// This overload signature is not compatible with its implementation signature.</code>

<code class="kd">function</code> <code class="nx">format</code><code class="p">(</code><code class="nx">data</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">needle?</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">haystack?</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">needle</code> <code class="o">&amp;&amp;</code> <code class="nx">haystack</code> <code class="o">?</code> <code class="nx">data</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="nx">needle</code><code class="p">,</code> <code class="nx">haystack</code><code class="p">)</code> <code class="o">:</code> <code class="nx">data</code><code class="p">;</code>
<code class="p">}</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584687353440">
<h1>Summary</h1>

<p>In this chapter, you saw how a function’s parameters and return types can be inferred or explicitly declared in TypeScript:</p>

<ul>
<li>
<p>Declaring function parameter types with type annotations</p>
</li>
<li>
<p>Declaring optional parameters, default values, and rest parameters to change type system behavior</p>
</li>
<li>
<p>Declaring function return types with type annotations</p>
</li>
<li>
<p>Describing functions that don’t return a usable value with the <code>void</code> type</p>
</li>
<li>
<p>Describing functions that don’t return at all with the <code>never</code> type</p>
</li>
<li>
<p>Using function overloads to describe varying function call signatures</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/functions"><em class="hyperlink">https://learningtypescript.com/functions</em></a>.</p>
</div>
<blockquote class="joke">
<p>What makes a TypeScript project good?</p>

<p>It functions well.</p></blockquote>
</div></section>







</div></section></div></body></html>