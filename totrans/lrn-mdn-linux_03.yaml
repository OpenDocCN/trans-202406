- en: Chapter 3\. Shells and Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll focus on interacting with Linux on the terminal, that
    is, via the shell that exposes a command-line interface (CLI). It is vitally important
    to be able to use the shell effectively to accomplish everyday tasks, and to that
    end we focus on usability here.
  prefs: []
  type: TYPE_NORMAL
- en: First, we review some terminology and provide a gentle and concise introduction
    to shell basics. Then we have a look at modern, human-friendly shells, such as
    the Fish shell. We’ll also look at configuration and common tasks in the shell.
    Then, we move on to the topic of how to effectively work on the CLI using a terminal
    multiplexer, enabling you to work with multiple sessions, local or remote. In
    the last part of this chapter, we switch gears and focus on automating tasks in
    the shell using scripts, including best practices for writing scripts in a safe,
    secure, and portable manner and also how to lint and test scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two major ways to interact with Linux, from a CLI perspective. The
    first way is manually—that is, a human user sits in front of the terminal, interactively
    typing commands and consuming the output. This ad-hoc interaction works for most
    of the things you want to do in the shell on a day-to-day basis, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing directories, finding files, or looking for content in files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying files between directories or to remote machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading emails or the news or sending a Tweet from the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, we’ll learn how to conveniently and efficiently work with multiple
    shell sessions at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The other mode of operation is the automated processing of a series of commands
    in a special kind of file that the shell interprets for you and in turn executes.
    This mode is usually called *shell scripting* or just *scripting*. You typically
    want to use a script rather than manually repeating certain tasks. Also, scripts
    are the basis of many config and install systems. Scripts are indeed very convenient.
    However, they can also pose a danger if used without precautions. So, whenever
    you think about writing a script, keep the XKCD web comic shown in [Figure 3-1](#fig-xkcd-automation)
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0301](Images/lmlx_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1\. XKCD on [automation](https://oreil.ly/GSKUb). *Credit*: Randall
    Munroe (shared under CC BY-NC 2.5 license)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I strongly recommend that you have a Linux environment available and try out
    the examples shown here right away. With that, are you ready for some (inter)action?
    If so, then let’s start with some terminology and basic shell usage.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into different options and configurations, let’s focus on some
    basic terms such as *terminal* and *shell*. In this section I’ll define the terminology
    and show you how to accomplish everyday tasks in the shell. We’ll also review
    modern commands and see them in action.
  prefs: []
  type: TYPE_NORMAL
- en: Terminals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with the terminal, or terminal emulator, or soft terminal, all of
    which refer to the same thing: a *terminal* is a program that provides a textual
    user interface. That is, a terminal supports reading characters from the keyboard
    and displaying them on the screen. Many years ago, these used to be integrated
    devices (keyboard and screen together), but nowadays terminals are simply apps.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the basic character-oriented input and output, terminals support
    so-called [*escape sequences*, or *escape codes*](https://oreil.ly/AT5qC), for
    cursor and screen handling and potentially support for colors. For example, pressing
    Ctrl+H causes a backspace, which deletes the character to the left of the cursor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The environment variable `TERM` has the terminal emulator in use, and its configuration
    is available via `infocmp` as follows (note that the output has been shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The output of `infocmp` is not easy to digest. If you want to learn about the
    capabilities in detail, consult the [terminfo](https://oreil.ly/qjwiv) database.
    For example, in my concrete output, the terminal supports 80 columns (`cols#80`)
    and 24 lines (`lines#24`) for output as well as 256 colors (`colors#0x100`, in
    hexadecimal notation).
  prefs: []
  type: TYPE_NORMAL
- en: Examples of terminals include not only `xterm`, `rxvt`, and the Gnome terminator
    but also new generation ones that utilize the GPU, such as [Alacritty](https://oreil.ly/zm9M9),
    [kitty](https://oreil.ly/oxyMn), and [warp](https://oreil.ly/WBG9S).
  prefs: []
  type: TYPE_NORMAL
- en: In [“Terminal Multiplexer”](#terminal-mux), we will come back to the topic of
    the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Shells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next up is the *shell*, a program that runs inside the terminal and acts as
    a command interpreter. The shell offers input and output handling via streams,
    supports variables, has some built-in commands you can use, deals with command
    execution and status, and usually supports both interactive usage as well as scripted
    usage ([“Scripting”](#scripting)).
  prefs: []
  type: TYPE_NORMAL
- en: The shell is formally defined in [`sh`](https://oreil.ly/ISxwU), and we often
    come across the term [POSIX shell](https://oreil.ly/rkfqG), which will become
    more important in the context of scripts and portability.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, we had the Bourne shell `sh`, named after the author, but nowadays
    it’s usually replaced with the [bash](https://oreil.ly/C9coL) shell—a wordplay
    on the original version, short for “Bourne Again Shell”—which is widely used as
    the default.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about what you’re using, use the `file -h /bin/sh` command
    to find out, or if that fails, try `echo $0` or `echo $SHELL`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, we assume the bash shell (`bash`), unless we call it out explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more implementations of `sh` as well as other variants, such
    as the Korn shell, `ksh`, and C shell, `csh`, which are not widely used today.
    We will, however, review modern `bash` replacements in [“Human-Friendly Shells”](#human-friendly-shells).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start our shell basics with two fundamental features: streams and variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with the topic of input (streams) and output (streams), or I/O for
    short. How can you feed a program some input? How do you control where the output
    of a program lands, say, on the terminal or in a file?
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, the shell equips every process with three default file descriptors
    (FDs) for input and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stdin` (FD 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdout` (FD 1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stderr` (FD 2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These FDs are, as depicted in [Figure 3-2](#fig-shell-streams), by default connected
    to your screen and keyboard, respectively. In other words, unless you specify
    something else, a command you enter in the shell will take its input (`stdin`)
    from your keyboard, and it will deliver its output (`stdout`) to your screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell interaction demonstrates this default behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example using `cat`, you see the defaults in action. Note that
    I used Ctrl+C (shown as `^C`) to terminate the command.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0302](Images/lmlx_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Shell I/O default streams
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you don’t want to use the defaults the shell gives you—for example, you don’t
    want `stderr` to be outputted on the screen but want to save it in a file—you
    can [redirect](https://oreil.ly/pOIjp) the streams.
  prefs: []
  type: TYPE_NORMAL
- en: You redirect the output stream of a process using `$FD>` and `<$FD`, with `$FD`
    being the file descriptor—for example, `2>` means redirect the `stderr` stream.
    Note that `1>` and `>` are the same since `stdout` is the default. If you want
    to redirect both `stdout` and `stderr`, use `&>`, and when you want to get rid
    of a stream, you can use `/dev/null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how that works in the context of a concrete example, downloading
    some HTML content via `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Discard all output by redirecting both `stdout` and `stderr` to */dev/null*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Redirect the output and status to different files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_shells_and_scripting_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Interactively enter input and save to file; use Ctrl+D to stop capturing and
    store the content.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_shells_and_scripting_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Lowercase all words, using the `tr` command that reads from `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shells usually understand a number of special characters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Ampersand (`&`)
  prefs: []
  type: TYPE_NORMAL
- en: Placed at the end of a command, executes the command in the background (see
    also [“Job control”](#job-control))
  prefs: []
  type: TYPE_NORMAL
- en: Backslash (`\`)
  prefs: []
  type: TYPE_NORMAL
- en: Used to continue a command on the next line, for better readability of long
    commands
  prefs: []
  type: TYPE_NORMAL
- en: Pipe (`|`)
  prefs: []
  type: TYPE_NORMAL
- en: Connects `stdout` of one process with the `stdin` of the next process, allowing
    you to pass data without having to store it in files as a temporary place
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let’s see some of the theoretical content in action. Let’s try to figure
    out how many lines an HTML file contains by downloading it using `curl` and then
    piping the content to the `wc` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `curl` to download the content from the URL, and discard the status that
    it outputs on `stderr`. (Note: in practice, you’d use the `-s` option of `curl`,
    but we want to learn how to apply our hard-gained knowledge, right?)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `stdout` of `curl` is fed to `stdin` of `wc`, which counts the number of
    lines with the `-l` option.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of commands, streams, and redirection,
    let’s move on to another core shell feature, the handling of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A term you will come across often in the context of shells is *variables*.
    Whenever you don’t want to or cannot hardcode a value, you can use a variable
    to store and change a value. Use cases include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to handle configuration items that Linux exposes—for example,
    the place where the shell looks for executables captured in the `$PATH` variable.
    This is kind of an interface where a variable might be read/write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to interactively query the user for a value, say, in the context
    of a script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to shorten input by defining a long value once—for example, the
    URL of an HTTP API. This use case roughly corresponds to a `const` value in a
    program language since you don’t change the value after you have declared the
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We distinguish between two kinds of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs: []
  type: TYPE_NORMAL
- en: Shell-wide settings; list them with `env`.
  prefs: []
  type: TYPE_NORMAL
- en: Shell variables
  prefs: []
  type: TYPE_NORMAL
- en: Valid in the context of the current execution; list with `set` in bash. Shell
    variables are not inherited by subprocesses.
  prefs: []
  type: TYPE_NORMAL
- en: You can, in bash, use `export` to create an environment variable. When you want
    to access the value of a variable, put a `$` in front of it, and when you want
    to get rid of it, use `unset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, that was a lot of information. Let’s see how that looks in practice (in
    bash):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a shell variable called `MY_VAR`, and assign a value of 42.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: List shell variables and filter out `MY_VAR`. Note the `_=`, indicating it’s
    not exported.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_shells_and_scripting_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new environment variable called `MY_GLOBAL_VAR`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_shells_and_scripting_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: List shell variables and filter out all that start with `MY_`. We see, as expected,
    both of the variables we created in the previous steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_shells_and_scripting_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: List environment variables. We see `MY_GLOBAL_VAR`, as we would hope.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_shells_and_scripting_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shell session—that is, a child process of the current shell session
    that doesn’t inherit `MY_VAR`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_shells_and_scripting_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Access the environment variable `MY_GLOBAL_VAR`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_shells_and_scripting_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: List the shell variables, which gives us only `MY_GLOBAL_VAR` since we’re in
    a child process.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](#co_shells_and_scripting_CO4-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Exit the child process, remove the `MY_VAR` shell variable, and list our shell
    variables. As expected, `MY_VAR` is gone.
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 3-1](#table-common-variables) I put together common shell and environment
    variables. You will find those variables almost everywhere, and they are important
    to understand and to use. For any of the variables, you can have a look at the
    respective value using `echo $XXX`, with `XXX` being the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Common shell and environment variables
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Type | Semantics |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `EDITOR` | Environment | The path to program used by default to edit files
    |'
  prefs: []
  type: TYPE_TB
- en: '| `HOME` | POSIX | The path of the home directory of the current user |'
  prefs: []
  type: TYPE_TB
- en: '| `HOSTNAME` | bash shell | The name of the current host |'
  prefs: []
  type: TYPE_TB
- en: '| `IFS` | POSIX | List of characters to separate fields; used when the shell
    splits words on expansion |'
  prefs: []
  type: TYPE_TB
- en: '| `PATH` | POSIX | Contains a list of directories in which the shell looks
    for executable programs (binaries or scripts) |'
  prefs: []
  type: TYPE_TB
- en: '| `PS1` | Environment | The primary prompt string in use |'
  prefs: []
  type: TYPE_TB
- en: '| `PWD` | Environment | The full path of the working directory |'
  prefs: []
  type: TYPE_TB
- en: '| `OLDPWD` | bash shell | The full path of the directory before the last `cd`
    command |'
  prefs: []
  type: TYPE_TB
- en: '| `RANDOM` | bash shell | A random integer between 0 and 32767 |'
  prefs: []
  type: TYPE_TB
- en: '| `SHELL` | Environment | Contains the currently used shell |'
  prefs: []
  type: TYPE_TB
- en: '| `TERM` | Environment | The terminal emulator used |'
  prefs: []
  type: TYPE_TB
- en: '| `UID` | Environment | Current user unique ID (integer value) |'
  prefs: []
  type: TYPE_TB
- en: '| `USER` | Environment | Current user name |'
  prefs: []
  type: TYPE_TB
- en: '| `_` | bash shell | Last argument to the previous command executed in the
    foreground |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | bash shell | Exit status; see [“Exit status”](#shell-exit-status) |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | bash shell | The ID of the current process (integer value) |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | bash shell | The name of the current process |'
  prefs: []
  type: TYPE_TB
- en: Further, check out the full list of [bash-specific variables](https://oreil.ly/EIgVc),
    and also note that the variables from [Table 3-1](#table-common-variables) will
    come in handy again in the context of [“Scripting”](#scripting).
  prefs: []
  type: TYPE_NORMAL
- en: Exit status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The shell communicates the completion of a command execution to the caller using
    what is called the *exit status*. In general, it is expected that a Linux command
    returns a status when it terminates. This can either be a normal termination (happy
    path) or an abnormal termination (something went wrong). A `0` exit status means
    that the command was successfully run, without any errors, whereas a nonzero value
    between 1 and 255 signals a failure. To query the exit status, use `echo $?`.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with exit status handling in a pipeline, since some shells make only
    the last status available. You can work around that limitation [by using `$PIPESTATUS`](https://oreil.ly/mMz9k).
  prefs: []
  type: TYPE_NORMAL
- en: Built-in commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shells come with a number of built-in commands. Some useful examples are `yes`,
    `echo`, `cat`, or `read` (depending on the Linux distro, some of those commands
    might not be built-ins but located in */usr/bin*). You can use the `help` command
    to list built-ins. Do remember, however, that everything else is a shell-external
    program that you usually can find in */usr/bin* (for user commands) or in */usr/sbin*
    (for administrative commands).
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you know where to find an executable? Here are some ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One of the technical reviewers of this book rightfully pointed out that `which`
    is a non-POSIX, external program that may not always be available. Also, they
    suggested using `*command* -v` rather than `which` to get the program path and
    or shell alias/function. See also the [shellcheck docs](https://oreil.ly/5toUM)
    for further details on the matter.
  prefs: []
  type: TYPE_NORMAL
- en: Job control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A feature most shells support is called [*job control*](https://oreil.ly/zeMsU).
    By default, when you enter a command, it takes control of the screen and the keyboard,
    which we usually call *running in the foreground*. But what if you don’t want
    to run something interactively, or, in case of a server, what if there is no input
    from `stdin` at all? Enter job control and background jobs: to launch a process
    in the background, put an `&` at the end, or to send a foreground process to the
    background, press Ctrl+Z.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows this in action, giving you a rough idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: By putting the `&` at the end, we launch the command in the background.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: List all jobs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_shells_and_scripting_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: With the `fg` command, we can bring a process to the foreground. If you want
    to quit the `watch` command, use Ctrl+C.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to keep a background process running, even after you close the shell
    you can prepend the `nohup` command. Further, for a process that is already running
    and wasn’t prepended with `nohup`, you can use `disown` after the fact to achieve
    the same effect. Finally, if you want to get rid of a running process, you can
    use the `kill` command with various levels of forcefulness (see [“Signals”](ch09.xhtml#signals)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: Rather than job control, I recommend using terminal multiplexer, as discussed
    in [“Terminal Multiplexer”](#terminal-mux). These programs take care of the most
    common use cases (shell closes, multiple processes running and need coordination,
    etc.) and also support working with remote systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to discuss modern replacements for frequently used core commands
    that have been around forever.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a handful of commands you will find yourself using over and over again
    on a daily basis. These include commands for navigating directories (`cd`), listing
    the content of a directory (`ls`), finding files (`find`), and displaying the
    content of files (`cat`, `less`). Given that you are using these commands so often,
    you want to be as efficient as possible—every keystroke counts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern variations exist for some of these often-used commands. Some of them
    are drop-in replacements, and others extend the functionality. All of them offer
    somewhat sane default values for common operations and rich output that is generally
    easier to comprehend, and they usually lead to you typing less to accomplish the
    same task. This reduces the friction when you work with the shell, making it more
    enjoyable and improving the flow. If you want to learn more about modern tooling,
    check out [Appendix B](app02.xhtml#appendix-modern). In this context, a word of
    caution, especially if you’re applying this knowledge in an enterprise environment:
    I have no stake in any of these tools and purely recommend them because I have
    found them useful myself. A good way to go about installing and using any of these
    tools is to use a version of the tool that has been vetted by your Linux distro
    of choice.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing directory contents with exa
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever you want to know what a directory contains, you use `ls` or one of
    its variants with parameters. For example, in bash I used to have `l` aliased
    to `ls -GAhltr`. But there’s a better way: [`exa`](https://oreil.ly/5lPAl), a
    modern replacement for `ls`, written in Rust, with built-in support for Git and
    tree rendering. In this context, what would you guess is the most often used command
    after you’ve listed the directory content? In my experience it’s to clear the
    screen, and very often people use `clear`. That’s typing five characters and then
    hitting `ENTER`. You can have the same effect much faster—simply use Ctrl+L.'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing file contents with bat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s assume that you listed a directory’s contents and found a file you want
    to inspect. You’d use `cat`, maybe? There’s something better I recommend you have
    a look at: [`bat`](https://oreil.ly/w3K76). The `bat` command, shown in [Figure 3-3](#fig-bat-rendering),
    comes with syntax highlighting, shows nonprintable characters, supports Git, and
    has an integrated pager (the page-wise viewing of files longer than what can be
    displayed on the screen).'
  prefs: []
  type: TYPE_NORMAL
- en: Finding content in files with rg
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditionally, you would use `grep` to find something in a file. However, there’s
    a modern command, [`rg`](https://oreil.ly/u3Sfw), that is fast and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to compare `rg` to a `find` and `grep` combination in this example,
    where we want to find YAML files that contain the string “sample”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `find` and `grep` together to find a string in YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `rg` for the same task.
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the commands and the results in the previous example, you see
    that not only is `rg` easier to use but the results are more informative (providing
    context, in this case the line number).
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0303](Images/lmlx_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Rendering of a Go file (top) and a YAML file (bottom) by `bat`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JSON data processing with jq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And now for a bonus command. This one, `jq`, is not an actual replacement but
    more like a specialized tool for JSON, a popular textual data format. You find
    JSON in HTTP APIs and configuration files alike.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, use [`jq`](https://oreil.ly/9s7yh) rather than `awk` or `sed` to pick out
    certain values. For example, by using a [JSON generator](https://oreil.ly/bcT9d)
    to generate some random data, I have a 2.4 kB JSON file *example.json* that looks
    something like this (only showing the first record here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say we’re interested in all “first” friends—that is, entry 0 in the `friends`
    array—of people whose favorite fruit is “strawberry.” With `jq` you would do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That was some CLI fun, right? If you’re interested in finding out more about
    the topic of modern commands and what other candidates there might be for you
    to replace, check out the [modern-unix repo](https://oreil.ly/cBAXt), which lists
    suggestions. Let’s now move our focus to some common tasks beyond directory navigation
    and file content viewing and how to go about them.
  prefs: []
  type: TYPE_NORMAL
- en: Common Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of things you likely find yourself doing often, and there
    are certain tricks you can use to speed up your tasks in the shell. Let’s review
    these common tasks and see how we can be more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Shorten often-used commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One fundamental insight with interfaces is that commands that you are using
    very often should take the least effort—they should be quick to enter. Now apply
    this idea to the shell: rather than `git diff --color-moved`, I type `d` (a single
    character), since I’m viewing changes in my repositories many hundreds of times
    per day. Depending on the shell, there are different ways to achieve this: in
    bash this is called an [*alias*](https://oreil.ly/fbBvm), and in Fish ([“Fish
    Shell”](#fish-shell)) there are [abbreviations](https://oreil.ly/rrmNI) you can
    use.'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you enter commands on the shell prompt, there are a number of things you
    might want to do, such as navigating the line (for example, moving the cursor
    to the start) or manipulating the line (say, deleting everything left of the cursor).
    [Table 3-2](#table-shell-shortcuts) lists common shell shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Shell navigation and editing shortcuts
  prefs: []
  type: TYPE_NORMAL
- en: '| Action | Command | Note |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Move cursor to start of line | Ctrl+a | - |'
  prefs: []
  type: TYPE_TB
- en: '| Move cursor to end of line | Ctrl+e | - |'
  prefs: []
  type: TYPE_TB
- en: '| Move cursor forward one character | Ctrl+f | - |'
  prefs: []
  type: TYPE_TB
- en: '| Move cursor back one character | Ctrl+b | - |'
  prefs: []
  type: TYPE_TB
- en: '| Move cursor forward one word | Alt+f | Works only with left Alt |'
  prefs: []
  type: TYPE_TB
- en: '| Move cursor back one word | Alt+b | - |'
  prefs: []
  type: TYPE_TB
- en: '| Delete current character | Ctrl+d | - |'
  prefs: []
  type: TYPE_TB
- en: '| Delete character left of cursor | Ctrl+h | - |'
  prefs: []
  type: TYPE_TB
- en: '| Delete word left of cursor | Ctrl+w | - |'
  prefs: []
  type: TYPE_TB
- en: '| Delete everything right of cursor | Ctrl+k | - |'
  prefs: []
  type: TYPE_TB
- en: '| Delete everything left of cursor | Ctrl+u | - |'
  prefs: []
  type: TYPE_TB
- en: '| Clear screen | Ctrl+l | - |'
  prefs: []
  type: TYPE_TB
- en: '| Cancel command | Ctrl+c | - |'
  prefs: []
  type: TYPE_TB
- en: '| Undo | Ctrl+_ | bash only |'
  prefs: []
  type: TYPE_TB
- en: '| Search history | Ctrl+r | Some shells |'
  prefs: []
  type: TYPE_TB
- en: '| Cancel search | Ctrl+g | Some shells |'
  prefs: []
  type: TYPE_TB
- en: Note that not all shortcuts may be supported in all shells, and certain actions
    such as history management may be implemented differently in certain shells. In
    addition, you might want to know that these shortcuts are based on Emacs editing
    keystrokes. Should you prefer `vi`, you can use `set -o vi` in your *.bashrc*
    file, for example, to perform command-line editing based on `vi` keystrokes. Finally,
    taking [Table 3-2](#table-shell-shortcuts) as a starting point, try out what your
    shell supports and see how you can configure it to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: File content management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don’t always want to fire up an editor such as `vi` to add a single line
    of text. And sometimes you can’t do it—for example, in the context of writing
    a shell script ([“Scripting”](#scripting)).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can you manipulate textual content? Let’s have a look at a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file by redirecting the `echo` output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: View content of file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_shells_and_scripting_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Append a line to file using the `>>` operator and then view content.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_shells_and_scripting_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Replace content from file using `sed` and output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_shells_and_scripting_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file using the [here document](https://oreil.ly/FPWqT).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_shells_and_scripting_CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Show differences between the files we created.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the basic file content manipulation techniques, let’s have
    a look at the advanced viewing of file contents.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing long files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For long files—that is, files that have more lines than the shell can display
    on your screen—you can use pagers like `less` or `bat` (`bat` comes with a built-in
    pager). With paging, a program splits the output into pages where each page fits
    into what the screen can display and some commands to navigate the pages (view
    next page, previous page, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to deal with long files is to display only a select region of the
    file, like the first few lines. There are two handy commands for this: `head`
    and `tail`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to display the beginning of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a long file (100 lines here).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Display the first five lines of the long file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, to get live updates of a file that is constantly growing, we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Display the end of a log file using `tail`, with the `-f` option meaning to
    follow, or to update automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in this section we look at dealing with date and time.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `date` command can be a useful way to generate unique file names. It allows
    you to generate dates in various formats, including the [Unix time stamp](https://oreil.ly/xB7UG),
    as well as to convert between different date and time formats.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a UNIX time stamp.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert a UNIX time stamp to a human-readable date.
  prefs: []
  type: TYPE_NORMAL
- en: With that we wrap up the shell basics section. By now you should have a good
    understanding of what terminals and shells are and how to use them to do basic
    tasks such as navigating the filesystem, finding files, and more. We now move
    on to the topic of human-friendly shells.
  prefs: []
  type: TYPE_NORMAL
- en: Human-Friendly Shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the [bash shell](https://oreil.ly/9GNyA) is likely still the most widely
    used shell, it is not necessarily the most human-friendly one. It has been around
    since the late 1980s, and its age sometimes shows. There are a number of modern,
    human-friendly shells I strongly recommend you evaluate and use instead of bash.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first examine in detail one concrete example of a modern, human-friendly
    shell called the Fish shell and then briefly discuss others, just to make sure
    you have an idea about the range of choices. We wrap up this section with a quick
    recommendation and conclusion in [“Which Shell Should I Use?”](#which-shell-should-you-use).
  prefs: []
  type: TYPE_NORMAL
- en: Fish Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Fish shell](https://fishshell.com/) describes itself as a smart and user-friendly
    command-line shell. Let’s have a look at some basic usage first and then move
    on to configuration topics.
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For many daily tasks, you won’t notice a big difference from bash in terms
    of input; most of the commands provided in [Table 3-2](#table-shell-shortcuts)
    are valid. However, there are two areas where `fish` is different from and much
    more convenient than `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no explicit history management.
  prefs: []
  type: TYPE_NORMAL
- en: You simply type and you get previous executions of a command shown. You can
    use the up and down key to select one (see [Figure 3-4](#fig-fish-history)).
  prefs: []
  type: TYPE_NORMAL
- en: Autosuggestions are available for many commands.
  prefs: []
  type: TYPE_NORMAL
- en: This is shown in [Figure 3-5](#fig-fish-autocompletion). In addition, when you
    press Tab, the Fish shell will try to complete the command, argument, or path,
    giving you visual hints such as coloring your input red if it doesn’t recognize
    the command.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0304](Images/lmlx_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Fish history handling in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![lmlx 0305](Images/lmlx_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Fish autosuggestion in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Table 3-3](#table-fish-reference) lists some common `fish` commands. In this
    context, note specifically the handling of environment variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-3\. Fish shell reference
  prefs: []
  type: TYPE_NORMAL
- en: '| Task | Command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Export environment variable `KEY` with value `VAL` | `set -x KEY VAL` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete environment variable `KEY` | `set -e KEY` |'
  prefs: []
  type: TYPE_TB
- en: '| Inline env var `KEY` for command `cmd` | `env KEY=VAL cmd` |'
  prefs: []
  type: TYPE_TB
- en: '| Change path length to 1 | `set -g fish_prompt_pwd_dir_length 1` |'
  prefs: []
  type: TYPE_TB
- en: '| Manage abbreviations | `abbr` |'
  prefs: []
  type: TYPE_TB
- en: '| Manage functions | `functions` and `funcd` |'
  prefs: []
  type: TYPE_TB
- en: Unlike other shells, `fish` stores the exit status of the last command in a
    variable called `$status` instead of in `$?`.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re coming from bash, you may also want to consult the [Fish FAQ](https://oreil.ly/Nk2S2),
    which addresses most of the gotchas.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To [configure the Fish shell](https://oreil.ly/FCSne), you simply enter the
    `fish_config` command (you might need to add the `browse` subcommand, depending
    on your distro), and `fish` will launch a server via *[*http://localhost:8000*](http://localhost:8000)*
    and automatically open your default browser with a fancy UI, shown in [Figure 3-6](#fig-fish-config-ui),
    which allows you to view and change settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0306](Images/lmlx_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. Fish shell configuration via browser
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To switch between `vi` and Emacs (default) key bindings for command-line navigation,
    use the `fish_vi_key_bindings` to start `vi` mode, and use `fish_default_key_bindings`
    to reset it to Emacs. Note that the changes will take place in all active shell
    sessions immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now see how I have configured my environment. In fact, my config is rather
    short; in *config.fish* I have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'My prompt, defined in *fish_prompt.fish*, looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding prompt definition yields the prompt shown in [Figure 3-7](#fig-fish-prompt);
    note the difference between a directory that contains a Git repo and one that
    does not, a built-in visual cue to speed up your flow. Also, notice the current
    time on the righthand side.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0307](Images/lmlx_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. Fish shell prompt
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'My abbreviations—think of these as `alias` replacements, as found in other
    shells—look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To add a new abbreviation, use `abbr --add`. Abbreviations are handy for simple
    commands that take no arguments. What if you have a more complicated construct
    you want to shorten? Say you want to shorten a sequence involving `git` that also
    takes an argument. Meet functions in Fish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at an example function, which is defined in the file
    named *c.fish*. We can use the `functions` command to list all defined functions,
    the `function` command to create a new function, and in this case the command
    `function c` to edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With that we have reached the end of the Fish section, in which we walked through
    a usage tutorial and configuration tips. Now let’s have a quick look at other
    modern shells.
  prefs: []
  type: TYPE_NORMAL
- en: Z-shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Z-shell](https://oreil.ly/6y06N), or `zsh`, is a Bourne-like shell with a
    powerful [completion](https://oreil.ly/bqS8y) system and rich theming support.
    With [Oh My Zsh](https://ohmyz.sh), you can pretty much configure and use `zsh`
    in the way you’ve seen earlier on with `fish` while retaining wide backward compatibility
    with bash.'
  prefs: []
  type: TYPE_NORMAL
- en: '`zsh` uses five startup files, as shown in the following example (note that
    if `$ZDOTDIR` is not set, `zsh` uses `$HOME` instead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sourced on all invocations of the shell. It should contain commands to set the
    search path, plus other important environment variables. But it should not contain
    commands that produce output or assume the shell is attached to a `tty`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Meant as an alternative to *.zlogin* for `ksh` fans (these two are not intended
    to be used together); similar to *.zlogin*, except that it is sourced before *.zshrc*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_shells_and_scripting_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sourced in interactive shells. It should contain commands to set up aliases,
    functions, options, key bindings, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_shells_and_scripting_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sourced in login shells. It should contain commands that should be executed
    only in login shells. Note that *.zlogin* is not the place for alias definitions,
    options, environment variable settings, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_shells_and_scripting_CO11-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Sourced when login shells exit.
  prefs: []
  type: TYPE_NORMAL
- en: For more `zsh` plug-ins, see also the [awesome-zsh-plugins repo on GitHub](https://oreil.ly/XHwBd).
    If you want to learn `zsh`, consider reading [“An Introduction to the Z Shell”](https://oreil.ly/cMfnw)
    by Paul Falstad and Bas de Bakker.
  prefs: []
  type: TYPE_NORMAL
- en: Other Modern Shells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to `fish` and `zsh`, there are a number of other interesting—but
    not necessarily always bash-compatible—shells available out there. When you have
    a look at those, ask yourself what the focus of the respective shell is (interactive
    usage vs. scripting) and how active the community around it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of modern shells for Linux I came across and can recommend you
    have a look at include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oil shell](https://www.oilshell.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Targets Python and JavaScript users. Put in other words, the focus is less on
    interactive use but more on scripting.
  prefs: []
  type: TYPE_NORMAL
- en: '[murex](https://murex.rocks)'
  prefs: []
  type: TYPE_NORMAL
- en: A POSIX shell that sports interesting features such as an integrated testing
    framework, typed pipelines, and event-driven programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[Nushell](https://www.nushell.sh)'
  prefs: []
  type: TYPE_NORMAL
- en: An experimental new shell paradigm, featuring tabular output with a powerful
    query language. Learn more via the detailed [Nu Book](https://oreil.ly/jIa5w).
  prefs: []
  type: TYPE_NORMAL
- en: '[PowerShell](https://oreil.ly/bYKnd)'
  prefs: []
  type: TYPE_NORMAL
- en: A cross-platform shell that started off as a fork of the Windows PowerShell
    and offers a different set of semantics and interactions than POSIX shells.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more options out there. Keep looking and see what works best
    for you. Try thinking beyond bash and optimize for your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Which Shell Should I Use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point in time, every modern shell—other than bash—seems like a good
    choice, from a human-centric perspective. Smooth auto-complete, easy config, and
    smart environments are no luxury in 2022, and given the time you usually spend
    on the command line, you should try out different shells and pick the one you
    like most. I personally use the Fish shell, but many of my peers are super happy
    with the Z-shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have issues that make you hesitant to move away from bash, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You work in remote systems and/or cannot install your own shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve stayed with bash due to compatibility and/or muscle memory. It can be
    hard to get rid of certain habits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all instructions (implicitly) assume bash. For example, you’ll see instructions
    like `export FOO=BAR`, which is bash specific.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It turns out that these issues are by and large not relevant to most users.
    While you may have to temporarily use bash in a remote system, most of the time
    you will be working in an environment that you control. There is a learning curve,
    but the investment pays off in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, let’s focus on another way to boost your productivity in the terminal:
    multiplexer.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal Multiplexer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We came across terminals at the beginning of this chapter, in [“Terminals”](#terminals).
    Now let’s dive deeper into the topic of how to improve your terminal usage, building
    on a concept that is both simple and powerful: multiplexing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of it in this way: you usually work on different things that can be grouped
    together. For example, you may work on an open source project, author a blog post
    or docs, access a server remotely, interact with an HTTP API to test things, and
    so forth. These tasks may each require one or more terminal windows, and often
    you want or need to do potentially interdependent tasks in two windows at the
    same time. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: You are using the `watch` command to periodically execute a directory listing
    and at the same time edit a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You start a server process (a web server or application server) and want to
    have it running in the foreground (see also [“Job control”](#job-control)) to
    keep an eye on the logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to edit a file using `vi` and at the same time use `git` to query the
    status and commit changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a VM running in the public cloud and want to `ssh` into it while having
    the possibility to manage files locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think of all these examples as things that logically belong together and that
    in terms of time duration can range from short term (a few minutes) to long term
    (days and weeks). The grouping of those tasks is usually called a *session*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there are a number of challenges if you want to achieve this grouping:'
  prefs: []
  type: TYPE_NORMAL
- en: You need multiple windows, so one solution is to launch multiple terminals or,
    if the UI supports it, multiple instances (tabs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would like to have all the windows and paths around, even if you close the
    terminal or the remote side closes down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to expand or zoom in and out to focus on certain tasks while keeping
    an overview of all your sessions and being able to navigate between them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable these tasks, people came up with the idea of overlaying a terminal
    with multiple windows (and sessions, to group windows)—in other words, multiplexing
    the terminal I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a brief look at the original implementation of terminal multiplexing,
    called `screen`. Then we’ll focus in-depth on a widely used implement called `tmux`
    and wrap up with other options in this space.
  prefs: []
  type: TYPE_NORMAL
- en: screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`screen`](https://oreil.ly/xx3ik) is the original terminal multiplexer and
    is still used. Unless you’re in a remote environment where nothing else is available
    and/or you can’t install another multiplexer, you should probably not be using
    `screen`. One reason is that it’s not actively maintained anymore, and another
    is that it’s not very flexible and lacks a number of features modern terminal
    multiplexers have.'
  prefs: []
  type: TYPE_NORMAL
- en: tmux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`tmux`](https://oreil.ly/kVg7M) is a flexible and rich terminal multiplexer
    that you can bend to your needs. As you can see in [Figure 3-8](#fig-tmux-concept),
    there are three core elements you’re interacting with in `tmux`, from coarse-grained
    to fine-grained units:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/lmlx_0308.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-8\. The `tmux` elements: sessions, windows, and panes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sessions
  prefs: []
  type: TYPE_NORMAL
- en: A logical unit that you can think of as a working environment dedicated to a
    specific task such as “working on project X” or “writing blog post Y.” It’s the
    container for all other units.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a window as a tab in a browser, belonging to a session. It’s
    optional to use, and often you only have one window per session.
  prefs: []
  type: TYPE_NORMAL
- en: Panes
  prefs: []
  type: TYPE_NORMAL
- en: 'These are your workhorses, effectively a single shell instance running. A pane
    is part of a window, and you can easily split it vertically or horizontally, as
    well as expand/collapse it (think: zoom) and close panes as you need them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like `screen`, in `tmux` you have the ability to attach and detach a session.
    Let’s assume we start from scratch, let’s launch it with a session called `test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, `tmux` is running as a server, and you find yourself
    in a shell you’ve configured in `tmux`, running as the client. This client/server
    model allows you to create, enter, leave, and destroy sessions and use the shells
    running in it without having to think of the processes running (or failing) in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '`tmux` uses Ctrl+b as the default keyboard shortcut, also called *prefix* or
    *trigger*. So for example, to list all windows, you would press Ctrl+b and then
    w, or to expand the current (active) pane, you would use Ctrl+b and then z.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In `tmux` the default trigger is Ctrl+b. To improve the flow, I mapped the trigger
    to an unused key, so a single keystroke is sufficient. I did this by first mapping
    the trigger to the Home key in `tmux` and then mapping that Home key to the Caps
    Lock key by changing its mapping in */usr/share/X11/xkb/symbols/pc* to `key <CAPS>
    { [ Home ] };`.
  prefs: []
  type: TYPE_NORMAL
- en: This double-mapping was a workaround I needed to do. Depending on your target
    key or terminal, you might not have to do this, but I encourage you to map Ctrl+b
    to an unused key you can easily reach since you will press it many times a day.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use any of the commands listed in [Table 3-4](#table-tmux-reference)
    to manage further sessions, windows, and panes. Also, when pressing Ctrl+b+d,
    you can detach sessions. This means effectively that you put `tmux` into the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you then start a new terminal instance or, say, you `ssh` to your machine
    from a remote place, you can then attach to an existing session, so let’s do that
    with the `test` session we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Attach to existing session called `test`. Note that if you want to detach the
    session from its previous terminal, you would also supply the `-d` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-4](#table-tmux-reference) lists common `tmux` commands grouped by
    the units discussed, from widest scope (session) to narrowest (pane).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-4\. `tmux` reference
  prefs: []
  type: TYPE_NORMAL
- en: '| Target | Task | Command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Session | Create new | `:new -s NAME` |'
  prefs: []
  type: TYPE_TB
- en: '| Session | Rename | trigger + `$` |'
  prefs: []
  type: TYPE_TB
- en: '| Session | List all | trigger + `s` |'
  prefs: []
  type: TYPE_TB
- en: '| Session | Close | trigger  |'
  prefs: []
  type: TYPE_TB
- en: '| Window | Create new | trigger + `c` |'
  prefs: []
  type: TYPE_TB
- en: '| Window | Rename | trigger + `,` |'
  prefs: []
  type: TYPE_TB
- en: '| Window | Switch to | trigger + `1` … `9` |'
  prefs: []
  type: TYPE_TB
- en: '| Window | List all | trigger + `w` |'
  prefs: []
  type: TYPE_TB
- en: '| Window | Close | trigger + `&` |'
  prefs: []
  type: TYPE_TB
- en: '| Pane | Split horizontal | trigger + `"` |'
  prefs: []
  type: TYPE_TB
- en: '| Pane | Split vertical | trigger + `%` |'
  prefs: []
  type: TYPE_TB
- en: '| Pane | Toggle | trigger + `z` |'
  prefs: []
  type: TYPE_TB
- en: '| Pane | Close | trigger + `x` |'
  prefs: []
  type: TYPE_TB
- en: 'Now that you have a basic idea of how to use `tmux`, let’s turn our attention
    to configuring and customizing it. My *.tmux.conf* looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This line and the next two lines change the trigger to `Home`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Reload config via trigger + r.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_shells_and_scripting_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This line and the next redefine pane splitting; retain current directory of
    existing pane.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_shells_and_scripting_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds shortcuts for new and kill sessions.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_shells_and_scripting_CO13-5)'
  prefs: []
  type: TYPE_NORMAL
- en: No delays.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_shells_and_scripting_CO13-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Enable mouse selections.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_shells_and_scripting_CO13-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the default terminal mode to 256-color mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_shells_and_scripting_CO13-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Theme settings (next six lines).
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](#co_shells_and_scripting_CO13-9)'
  prefs: []
  type: TYPE_NORMAL
- en: 'From here to the end: plug-in management.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First install [tpm](https://oreil.ly/hsoau), the `tmux` plug-in manager, and
    then trigger + I for the plug-ins. The plug-ins used here are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[tmux-resurrect](https://oreil.ly/JugvE)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows you to restore sessions with Ctrl+s (safe) and Ctrl+r (restore)
  prefs: []
  type: TYPE_NORMAL
- en: '[tmux-continuum](https://oreil.ly/KvT7l)'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically saves/restores a session (15-minute interval)
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-9](#fig-tmux-example) shows my Alacritty terminal running `tmux`.
    You can see the sessions with the shortcuts 0 to 9, located in the left upper
    corner.'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0309](Images/lmlx_0309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. An example `tmux` instance in action, showing available sessions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While `tmux` certainly is an excellent choice, there are indeed other options
    than `tmux`, so let’s have a peek.
  prefs: []
  type: TYPE_NORMAL
- en: Other Multiplexers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other terminal multiplexers you can have a look at and try out include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[tmuxinator](https://oreil.ly/JyWmA)'
  prefs: []
  type: TYPE_NORMAL
- en: A meta-tool allowing you to manage `tmux` sessions
  prefs: []
  type: TYPE_NORMAL
- en: '[Byobu](https://oreil.ly/pJLa2)'
  prefs: []
  type: TYPE_NORMAL
- en: A wrapper around either `screen` or `tmux`; it’s especially interesting if you’re
    using the Ubuntu- or Debian-based Linux distros
  prefs: []
  type: TYPE_NORMAL
- en: '[Zellij](https://oreil.ly/ZRHnX)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls itself a terminal workspace, is written in Rust, and goes beyond what
    `tmux` offers, including a layout engine and a powerful plug-in system
  prefs: []
  type: TYPE_NORMAL
- en: '[dvtm](https://oreil.ly/yaTan)'
  prefs: []
  type: TYPE_NORMAL
- en: Brings the concept of tiling window management to the terminal; it’s powerful
    but has a learning curve like `tmux`
  prefs: []
  type: TYPE_NORMAL
- en: '[3mux](https://oreil.ly/S6nvV)'
  prefs: []
  type: TYPE_NORMAL
- en: A simple terminal multiplexer written in Go; it’s easy to use but not as powerful
    as `tmux`
  prefs: []
  type: TYPE_NORMAL
- en: With this quick review of multiplexer options out of the way, let’s talk about
    selecting one.
  prefs: []
  type: TYPE_NORMAL
- en: Which Multiplexer Should I Use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike with shells for human users, I do have a concrete preference here in
    the context of terminal multiplexer: use `tmux`. The reasons are manifold: it
    is mature, stable, rich (has many available plug-ins), and flexible. Many folks
    are using it, so there’s plenty of material out there to read up on as well as
    help available. The other multiplexers are exciting but relatively new or are,
    as is the case with `screen`, no longer in their prime.'
  prefs: []
  type: TYPE_NORMAL
- en: With that, I hope I was able to convince you to consider using a terminal multiplexer
    to improve your terminal and shell experience, speed up your tasks, and make the
    overall flow smoother.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we turn our attention to the last topic in this chapter, automating tasks
    with shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections of this chapter, we focused on the manual, interactive
    usage of the shell. Once you’ve done a certain task over and over again manually
    on the prompt, it’s likely time to automate the task. This is where scripts come
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we focus on writing scripts in bash. This is due to two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the scripts out there are written in bash, and hence you will find a
    lot of examples and help available for bash scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The likelihood of finding bash available on a target system is high, making
    your potential user base bigger than if you used a (potentially more powerful
    but esoteric or not widely used) alternative to bash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just to provide you with some context before we start, there are shell scripts
    out there that clock in at [several thousands](https://oreil.ly/0oWzI) of lines
    of code. Not that I encourage you to aim for this—quite the opposite: if you find
    yourself writing long scripts, ask yourself if a proper scripting language such
    as Python or Ruby is the better choice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s step back now and develop a short but useful example, applying good practices
    along the way. Let’s assume we want to automate the task of displaying a single
    statement on the screen that, given a user’s GitHub handle, shows when the user
    joined, using their full name, something along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How do we go about automating this task with a script? Let’s start with the
    basics, then review portability, and work our way up to the “business logic” of
    the script.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The good news is that by interactively using a shell, you already know most
    of the relevant terms and techniques. In addition to variables, streams and redirection,
    and common commands, there are a few specific things you want to be familiar with
    in the context of scripts, so let’s review them.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While shells usually treat everything as strings (if you want to perform some
    more complicated numerical tasks, you should probably not use a shell script),
    they do support some advanced data types such as arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at arrays in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define an array with three elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Access the first element; this would print `Linux`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_shells_and_scripting_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the length of the array, resulting in `numberofos` being 3.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flow control allows you to branch (`if`) or repeat (`for` and `while`) in your
    script, making the execution dependent on a certain condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some usage examples of flow control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Basic loop iterating over a directory, printing each file name
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Range loop
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_shells_and_scripting_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Forever loop; break out with Ctrl+C
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions allow you to write more modular and reusable scripts. You have to
    define the function before you use it since the shell interprets the script from
    top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple function example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Function definition; parameters implicitly passed via `$n`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Function invocation; the output is “Hi Michael hope you are well!”
  prefs: []
  type: TYPE_NORMAL
- en: Advanced I/O
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With `read` you can read user input from `stdin` that you can use to elicit
    runtime input—for example, with a menu of options. Further, rather than using
    `echo`, consider `printf`, which allows you fine-grained control over the output,
    including colors. `printf` is also more portable than `echo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example usage of the advanced I/O in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Read value from user input.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Output value read in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: There are other, more advanced concepts available for you, such as [signals
    and traps](https://oreil.ly/JsV1v). Given that we want to provide only an overview
    and introduction to the scripting topic here, I will refer you to the excellent
    [bash Scripting Cheatsheet](https://oreil.ly/nVjhN) for a comprehensive reference
    of all the relevant constructs. If you are serious about writing shell scripts,
    I recommend you read [*bash Cookbook*](https://oreil.ly/0jEt9) by Carl Albing,
    JP Vossen, and Cameron Newham, which contains lots and lots of great snippets
    you can use as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Portable bash Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll now look at what it means to write portable scripts in bash. But wait.
    What does *portable* mean, and why should you care?
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of [“Shells”](#shells), we defined what *POSIX* means, so let’s
    build on that. When I say “portable,” I mean that we are not making too many assumptions—implicitly
    or explicitly—about the environment a script will be executed in. If a script
    is portable, it runs on many different systems (shells, Linux distros, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: But remember that, even if you pin down the type of shell, in our case to bash,
    not all features work the same way across different versions of a shell. At the
    end of the day, it boils down to the number of different environments you can
    test your script in.
  prefs: []
  type: TYPE_NORMAL
- en: Executing portable scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How are scripts executed? First, let’s state that scripts really are simply
    text files; the extension doesn’t matter, although often you find *.sh* used as
    a convention. But there are two things that turn a text file into a script that
    is executable and able to be run by the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: The text file needs to declare the interpreter in the first line, using what
    is called [*shebang*](https://oreil.ly/88BcE) (or *hashbang*), which is written
    as `#!` (see also the first line of the template that follows).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you need to make the script executable using, for example, `chmod +x`,
    which allows everyone to run it, or, even better, `chmod 750`, which is more along
    the lines of the least privileges principle, as it allows only the user and group
    associated with the script to run it. We’ll dive deep into this topic in [Chapter 4](ch04.xhtml#access-control).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know the basics, let’s have a look at a concrete template we can
    use as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: A skeleton template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A skeleton template for a portable bash shell script that you can use as a
    seed looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_shells_and_scripting_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The [hashbang](https://oreil.ly/l6xNO) instructs the program loader that we
    want it to use `bash` to interpret this script.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_shells_and_scripting_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define that we want to stop the script execution if an error happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_shells_and_scripting_CO18-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Define that we treat unset variables as an error (so the script is less likely
    to fail silently).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_shells_and_scripting_CO18-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Define that when one part of a pipe fails, the whole pipe should be considered
    failed. This helps to avoid silent failures.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_shells_and_scripting_CO18-5)'
  prefs: []
  type: TYPE_NORMAL
- en: An example command-line parameter with a default value.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this template later in this section to implement our GitHub info
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Good practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’m using *good* practices instead of *best* practices because what you should
    do depends on the situation and how far you want to go. There is a difference
    between a script you write for yourself and one that you ship to thousands of
    users, but in general, high-level good practices writing scripts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fail fast and loud
  prefs: []
  type: TYPE_NORMAL
- en: Avoid silent fails, and fail fast; things like `errexit` and `pipefail` do that
    for you. Since bash tends to fail silently by default, failing fast is almost
    always a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive information
  prefs: []
  type: TYPE_NORMAL
- en: Don’t hardcode any sensitive information such as passwords into the script.
    Such information should be provided at runtime, via user input or calling out
    to an API. Also, consider that a `ps` reveals program parameters and more, which
    is another way that sensitive information can be leaked.
  prefs: []
  type: TYPE_NORMAL
- en: Input sanitization
  prefs: []
  type: TYPE_NORMAL
- en: Set and provide sane defaults for variables where possible, and sanitize the
    input you receive from users or other sources. For example, launch parameters
    provided or interactively ingested via the `read` command to avoid situations
    where an innocent-looking `rm -rf "$PROJECTHOME/"*` wipes your drive because the
    variable wasn’t set.
  prefs: []
  type: TYPE_NORMAL
- en: Check dependencies
  prefs: []
  type: TYPE_NORMAL
- en: Don’t assume that a certain tool or command is available, unless it’s a build-in
    or you know your target environment. Just because your machine has `curl` installed
    doesn’t mean the target machine has. If possible, provide fallbacks—for example,
    if no `curl` is available, use `wget`.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs: []
  type: TYPE_NORMAL
- en: When your script fails (and it’s not a matter of if but when and where), provide
    actionable instructions for your users. For example, rather than `Error 123`,
    say what has failed and how your user can fix the situation, such as `Tried to
    write to /project/xyz/ but seems this is read-only for me`.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs: []
  type: TYPE_NORMAL
- en: Document your scripts inline (using `# Some doc here`) for main blocks, and
    try to stick to 80-column width for readability and diffing.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs: []
  type: TYPE_NORMAL
- en: Consider versioning your scripts using Git.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs: []
  type: TYPE_NORMAL
- en: Lint and *test* the scripts. Since this is such an important practice, we will
    discuss it in greater detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to making scripts safe(r) by linting them while developing
    and testing them before you distribute them.
  prefs: []
  type: TYPE_NORMAL
- en: Linting and Testing Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you’re developing, you want to check and lint your scripts, making sure
    that you’re using commands and instructions correctly. There’s a nice way to do
    that, depicted in [Figure 3-10](#fig-shellcheck), with the program [ShellCheck](https://oreil.ly/Z3blD);
    you can download and install it locally, or you can also use the online version
    via [*shell​​check.net*](https://oreil.ly/EVVRg). Also, consider formatting your
    script with [shfmt](https://oreil.ly/obaKQ). It automatically fixes issues that
    can be reported later by `shellcheck`.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0310](Images/lmlx_0310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10\. A screenshot of the online ShellCheck tool
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: And further, before you check your script into a repo, consider using `bats`
    to test it. [`bats`](https://oreil.ly/uVNgh), short for Bash Automated Testing
    System, allows you to define test files as a bash script with special syntax for
    test cases. Each test case is simply a bash function with a description, and you
    would typically invoke these scripts as part of a CI pipeline—for example, as
    a GitHub action.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll put our good practices for script writing, linting, and testing into
    use. Let’s implement the example script we specified in the beginning of this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'End-to-End Example: GitHub User Info Script'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this end-to-end example, we bring all of the preceding tips and tooling together
    to implement our example script that is supposed to take a GitHub user handle
    and print out a message that contains what year the user joined, along with their
    full name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how one implementation looks, taking the good practices into account.
    Store the following in a file called *gh-user-info.sh*, and make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#custom_co_shells_and_scripting_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a default value to use if user doesn’t supply one.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#custom_co_shells_and_scripting_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `curl`, access the [GitHub API](https://oreil.ly/A7CLS) to download the
    user information as a JSON file, and store it in a temporary file (next line).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#custom_co_shells_and_scripting_CO19-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `jq`, pull out the fields we need. Note that the `created_at` field has
    a value that looks something like `"2009-02-07T16:07:32Z"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#custom_co_shells_and_scripting_CO19-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `cut`, extract the year from the `created_at` field in the JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#custom_co_shells_and_scripting_CO19-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Assemble the output message and print to screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s run it with the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations, you now have everything at your disposal to use the shell,
    both interactively on the prompt and for scripting. Before we wrap up, take a
    moment to think about the following concerning our *gh-user-info.sh* script:'
  prefs: []
  type: TYPE_NORMAL
- en: What if the JSON blob the GitHub API returns is not valid? What if we encounter
    a 500 HTTP error? Maybe adding a message along the lines of “try later” is more
    useful if there’s nothing the user can do themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the script to work, you need network access, otherwise the `curl` call will
    fail. What could you do about a lack of network access? Informing the user about
    it and suggesting what they can do to check networking may be an option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about improvements around dependency checks—for example, we implicitly
    assume here that `curl` is installed. Can you maybe add a check that makes the
    binary variable and falls back to `wget`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How about adding some usage help? If the script is called with an `-h` or `--help`
    parameter, perhaps show a concrete usage example and the options that users can
    use to influence the execution (ideally, including defining default values used).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You see now that, although this script looks good and works in most cases, there’s
    always something you can improve, such as making the script more robust and providing
    actionable error messages. In this context, consider using frameworks such as
    [bashing](https://oreil.ly/gLmlB), [rerun](https://oreil.ly/t8U9u), or [rr](https://oreil.ly/7F2lT)
    to improve modularity.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on working with Linux in the terminal, a textual
    user interface. We discussed shell terminology, provided a hands-on introduction
    to using the shell basics, and reviewed common tasks and how you can improve your
    shell productivity using modern variants of certain commands (such as `exa` rather
    than `ls`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at modern, human-friendly shells, specifically at `fish`, and
    how to configure and use them. Further, we covered the terminal multiplexer by
    using `tmux` as the hands-on example, enabling you to work with multiple local
    or remote sessions. Using modern shells and multiplexers can dramatically improve
    your efficiency on the command line, and I strongly recommend you consider adopting
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we discussed automating tasks by writing safe and portable shell scripts,
    including linting and testing said scripts. Remember that shells are effectively
    command interpreters, and as with any kind of language, you have to practice to
    get fluent. Having said this, now that you’re equipped with the basics of using
    Linux from the command line, you can already work with the majority of Linux-based
    systems out there, be it an embedded system or a cloud VM. In any case, you’ll
    find a way to get hold of a terminal and issue commands interactively or via executing
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to dive deeper into the topics discussed in this chapter, here
    are some additional resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Terminals
  prefs: []
  type: TYPE_NORMAL
- en: '[“Anatomy of a Terminal Emulator”](https://oreil.ly/u2CFr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“The TTY Demystified”](https://oreil.ly/8GT6s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“The Terminal, the Console and the Shell—What Are They?”](https://oreil.ly/vyVAV)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“What Is a TTY on Linux? (and How to Use the tty Command)”](https://oreil.ly/E0EGG)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Your Terminal Is Not a Terminal: An Introduction to Streams”](https://oreil.ly/xIEoZ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shells
  prefs: []
  type: TYPE_NORMAL
- en: '[“Unix Shells: bash, Fish, ksh, tcsh, zsh”](https://oreil.ly/4pepC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Comparison of Command Shells”](https://oreil.ly/RQfS6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“bash vs zsh” thread on reddit](https://oreil.ly/kseEe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Ghost in the Shell—Part 7—ZSH Setup”](https://oreil.ly/1KGz6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal multiplexer
  prefs: []
  type: TYPE_NORMAL
- en: '[“A tmux Crash Course”](https://oreil.ly/soqPv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“A Quick and Easy Guide to tmux”](https://oreil.ly/0hVCS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Use tmux on Linux (and Why It’s Better Than screen)”](https://oreil.ly/Q75TR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*The Tao of tmux*](https://oreil.ly/QDsYI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*tmux 2: Productive Mouse-Free Development*](https://oreil.ly/eO9y2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tmux Cheat Sheet & Quick Reference website](https://oreil.ly/SWCa5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell scripts
  prefs: []
  type: TYPE_NORMAL
- en: '[“Shell Style Guide”](https://oreil.ly/3cxAw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“bash Style Guide”](https://oreil.ly/zfy1v)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“bash Best Practices”](https://oreil.ly/eC1ol)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“bash Scripting Cheatsheet”](https://oreil.ly/nVroM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Writing bash Scripts That Are Not Only bash: Checking for bashisms and Testing
    with Dash”](https://oreil.ly/D0zwe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the shell basics at our disposal, we now turn our focus to access control
    and enforcement in Linux.
  prefs: []
  type: TYPE_NORMAL
