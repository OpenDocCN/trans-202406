<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Multithreaded Patterns" class="calibre4"><div class="preface" id="ch_patterns">
<h1 class="calibre12"><span class="keep-together">Chapter 6. </span>Multithreaded Patterns</h1>


<p class="author1">The JavaScript APIs that expose multithreading are, on their own, really quite basic with the functionality they provide. As you saw in <a data-type="xref" href="ch04.xhtml#ch_shared_mem" class="calibre6">Chapter 4</a>, the purpose of the <code class="calibre18">SharedArrayBuffer</code> is to store a raw, binary representation of data. Even <a data-type="xref" href="ch05.xhtml#ch_adv_shared_mem" class="calibre6">Chapter 5</a> continued this pattern with the <code class="calibre18">Atomics</code> object, exposing rather primitive methods for coordinating or modifying a handful of bytes at a time.</p>

<p class="author1">Just looking at such abstract and low-level APIs can make it difficult to see the big picture, or what these APIs can really be used for. It’s admittedly difficult to take these concepts and convert them into something that is genuinely useful for an application. That’s what this chapter is for.</p>

<p class="author1">This chapter contains popular design patterns for implementing multithreaded functionality inside an application. These design patterns take inspiration from the past, as each of them existed long before JavaScript was even invented. Though working demos of them are likely available in many forms, such as C++ textbooks, translating them for use with JavaScript isn’t always straightforward.</p>

<p class="author1">By examining these patterns you’ll get a much better feel for how the applications you develop can benefit from multithreading.</p>






<section data-type="sect1" data-pdf-bookmark="Thread Pool" class="calibre4"><div class="preface" id="ch_patterns_sec_threadpool">
<h1 class="calibre13">Thread Pool</h1>

<p class="author1">The thread pool is a very popular <a data-type="indexterm" data-primary="patterns" data-secondary="thread pool" id="idm45995915246648" class="calibre6"/><a data-type="indexterm" data-primary="thread pool" id="idm45995915245800" class="calibre6"/>pattern that is used in most multithreaded applications in some form or another. Essentially, a <em class="calibre7">thread pool</em> is a collection of <a data-type="indexterm" data-primary="worker threads" data-secondary="thread pool" id="idm45995915244568" class="calibre6"/><a data-type="indexterm" data-primary="thread pool" data-secondary="worker threads" id="idm45995915243720" class="calibre6"/>homogeneous worker threads that are each capable of carrying out CPU-intensive tasks that the application may depend on. This differs somewhat from the approach you’ve been using so far where usually a single worker thread, or a finite number of workers, has been used. As an example of this, the <code class="calibre18">libuv</code> library <a data-type="indexterm" data-primary="libuv library" id="idm45995915242040" class="calibre6"/><a data-type="indexterm" data-primary="libraries" data-secondary="libuv" id="idm45995915241432" class="calibre6"/>that Node.js depends on provides a thread pool, defaulting to four threads, for performing low-level I/O operations.</p>

<p class="author1">This pattern might feel similar to distributed systems that you may have worked with in the past. For example, with a container orchestration platform, there’s usually a collection of machines that are each capable of running application containers. With such a system each machine might have different capabilities, such as running different operating systems or having different memory and CPU resources. When this happens, the orchestrator may assign points to each machine based on resources and applications, then consume said points. On the other hand, a thread pool is much simpler because each worker is capable of carrying out the same work and each thread is just as capable as the other since they’re all running on the same machine.</p>

<p class="author1">The first question when creating a thread pool is how many threads should be in the pool?</p>








<section data-type="sect2" data-pdf-bookmark="Pool Size" class="calibre4"><div class="preface" id="idm45995915238680">
<h2 class="calibre37">Pool Size</h2>

<p class="author1">There are essentially two types <a data-type="indexterm" data-primary="patterns" data-secondary="thread pool" data-tertiary="pool size" id="patpoolsize" class="calibre6"/><a data-type="indexterm" data-primary="thread pool" data-secondary="size" id="thpsize" class="calibre6"/>of programs: those that run in the background, like a system daemon process, which ideally shouldn’t consume that many resources, and programs that run in the foreground that any given user is more likely to be aware of, like a desktop application or a web server. Browser applications are usually constrained to running as foreground applications, whereas Node.js applications are free to run in the background—though Node.js is most commonly used to build servers, frequently as the only process inside a container. In either case, the intent with a JavaScript application is often to be the main focus at a particular point in time, and any computations necessary to achieve the purpose of the program should ideally be executed as soon as possible.</p>

<p class="author1">To execute instructions as quickly as possible, it makes sense to break them up and run them in parallel. To maximize CPU usage it figures that each of the cores in a given CPU should be used, as equally as possible, by the application. Thus, the number of CPU cores available to the machine should be a determining factor for the number of threads—aka workers—an application should use.</p>

<p class="author1">Typically, the size of a thread pool won’t need to dynamically change throughout the lifetime of an application. Usually there’s a reason the number of workers is chosen, and that reason doesn’t often change. That’s why you’ll work with a thread pool with a fixed size, dynamically chosen when the application launches.</p>

<p class="author1">Here is the idiomatic approach for getting the number of threads available to the currently running JavaScript application, depending on whether the code runs inside a browser or inside a Node.js process:</p>

<pre data-type="programlisting" data-code-language="javascript" class="calibre38"><code class="c">// browser</code>
<code class="nx">cores</code> <code class="o">=</code> <code class="nx">navigator</code><code class="p">.</code><code class="nx">hardwareConcurrency</code><code class="p">;</code>

<code class="c">// Node.js</code>
<code class="nx">cores</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'os'</code><code class="p">).</code><code class="nx">cpus</code><code class="p">().</code><code class="nx">length</code><code class="p">;</code></pre>

<p class="author1">One thing to keep in mind is that with most operating systems there is not a direct correlation between a <a data-type="indexterm" data-primary="threads" data-secondary="CPU core and" id="idm45995915219592" class="calibre6"/><a data-type="indexterm" data-primary="CPU core, threads" id="idm45995915218744" class="calibre6"/>thread and a CPU core. For example, when running an application with four threads on a CPU with four cores, it’s not like the first core is always handling the first thread, the second core the second thread, and so forth. Instead, the operating system constantly moves tasks around, occasionally interrupting a running program to handle the work of another application. In a modern operating system there are often hundreds of background processes that need to be occasionally checked. This often means that a single CPU core will be handling the work of more than one thread.</p>

<p class="author1">Each time a CPU core switches focus between programs—or threads of a program—a small context shift overhead comes into play. Because of this, having too many threads compared to the number of CPU cores can cause a loss of performance. The constant context switching will actually make an application slower, so applications should attempt to reduce the number of threads clamoring for attention from the OS. However, having too few threads can then mean that an application takes too long to do its thing, resulting in a poor user experience or otherwise wasted hardware.</p>

<p class="author1">Another thing to keep in mind is that if an application makes a thread pool with four workers, then the minimum number of threads that application is using is five because the main thread of the application also comes into play. There are also background threads to consider, like the <code class="calibre18">libuv</code> thread pool, a garbage collection thread if the JavaScript engine employs one, the thread used to render the browser chrome, and so on. All of these will affect the performance of the application.</p>
<div data-type="tip" class="calibre22"><h6 class="calibre23">Tip</h6>
<p class="author1">The characteristics of the application itself will also affect the ideal size of a thread pool. Are you writing a cryptocurrency miner that does 99.9% of the work in each thread and almost no I/O and no work in the main thread? In that case using the number of available cores as the size of the thread pool might be OK. Or are you writing a video streaming and transcoding service that performs heavy CPU and heavy I/O? In that case, you may want to use the number of available cores minus two. You’ll need to perform benchmarks with your application to find the perfect number, but a reasonable starting point might be to use the number of available cores minus <a data-type="indexterm" data-primary="patterns" data-secondary="thread pool" data-tertiary="pool size" data-startref="patpoolsize" id="idm45995915213336" class="calibre6"/><a data-type="indexterm" data-primary="thread pool" data-secondary="size" data-startref="thpsize" id="idm45995915207608" class="calibre6"/>one and then tweak when necessary.</p>
</div>

<p class="author1">Once you have determined the number of threads to use, you’re ready to determine how to dispatch work to the workers.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Dispatch Strategies" class="calibre4"><div class="preface" id="idm45995915238088">
<h2 class="calibre37">Dispatch Strategies</h2>

<p class="author1">Because the goal of a thread pool <a data-type="indexterm" data-primary="thread pool" data-secondary="dispatch and" id="idm45995915204056" class="calibre6"/><a data-type="indexterm" data-primary="dispatching tasks" id="idm45995915203080" class="calibre6"/><a data-type="indexterm" data-primary="task dispatch, thread pools" id="idm45995915202408" class="calibre6"/><a data-type="indexterm" data-primary="patterns" data-secondary="thread pool" data-tertiary="dispatch methods" id="pattdismeth" class="calibre6"/>is to maximize the work that can be done in parallel, it stands to reason that no single worker should get too much work to handle and no threads should be sitting there idle without work to do. A naive approach might be to just collect tasks to be done, then pass them in once the number of tasks ready to be performed meets the number of worker threads and continue once they all complete. However, each task isn’t guaranteed to take the same amount of time to complete. It could be that some are very fast, taking milliseconds, and others may be slow, taking seconds or longer. A more robust solution must therefore be built.</p>

<p class="author1">A few strategies are often employed by applications to dispatch tasks to workers in a worker pool. These strategies draw parallels to those used by reverse proxies for the purpose of sending requests to backend services. Here’s a list of the most common strategies:</p>
<dl class="calibre14">
<dt class="calibre15">Round robin</dt>
<dd class="calibre16">
<p class="calibre17">Each task is given to the next <a data-type="indexterm" data-primary="thread pool" data-secondary="dispatch and" data-tertiary="round robin" id="idm45995915197112" class="calibre6"/><a data-type="indexterm" data-primary="dispatching tasks" data-secondary="round robin" id="idm45995915195864" class="calibre6"/><a data-type="indexterm" data-primary="task dispatch, thread pools" data-secondary="round robin" id="idm45995915194920" class="calibre6"/>worker in the pool, wrapping around to the beginning once the end has been hit. So, with a pool size of three, the first task goes to Worker 1, then Worker 2, then Worker 3, then back to Worker 1, and so on. The benefit of this is that each thread gets the exact same number of tasks to perform, but the drawback is that if the complexities of each task is a multiple of the number of threads (like each 6th task takes a long time to perform), then there will be an unfair distribution of work. The HAProxy reverse proxy refers to this as <code class="calibre18">roundrobin</code>.</p>
</dd>
<dt class="calibre15">Random</dt>
<dd class="calibre16">
<p class="calibre17">Each task is assigned to a <a data-type="indexterm" data-primary="thread pool" data-secondary="dispatch and" data-tertiary="random" id="idm45995915191592" class="calibre6"/><a data-type="indexterm" data-primary="dispatching tasks" data-secondary="random" id="idm45995915190344" class="calibre6"/><a data-type="indexterm" data-primary="task dispatch, thread pools" data-secondary="random" id="idm45995915165608" class="calibre6"/>random worker in the pool. Although this is the simplest to build, being entirely stateless, it can also mean that some of the workers are sometimes given too much work to perform, and others will sometimes be given too little work to perform.</p>
</dd>
<dt class="calibre15">Least busy</dt>
<dd class="calibre16">
<p class="calibre17">A count of the number of tasks being <a data-type="indexterm" data-primary="thread pool" data-secondary="dispatch and" data-tertiary="least busy" id="idm45995915163224" class="calibre6"/><a data-type="indexterm" data-primary="dispatching tasks" data-secondary="least busy" id="idm45995915162136" class="calibre6"/><a data-type="indexterm" data-primary="task dispatch, thread pools" data-secondary="least busy" id="idm45995915161288" class="calibre6"/>performed by each worker is maintained, and when a new task comes along it is given to the least busy worker. This can even be extrapolated so that each worker only has a single task to perform at a time. When two workers have a tie for the least amount of work, then one can be chosen randomly. This is perhaps the most robust approach, especially if each task consumes the same amount of CPU, but it does require the most effort 
<span class="keep-together">to implement</span>. If some tasks use fewer resources, such as if a task calls 
<span class="keep-together"><code class="calibre18">setTimeout()</code></span>, then it can lead to skew in worker workloads. HAProxy refers to this as 
<span class="keep-together"><code class="calibre18">leastconn</code>.</span></p>
</dd>
</dl>

<p class="author1">Other strategies employed by reverse proxies might have a nonobvious implementation that could be made in your applications as well. For example, HAProxy has a strategy for load balancing called <code class="calibre18">source</code>, which takes a hash of the client’s IP address and uses that to consistently route requests to a single backend. An equivalent to this might be useful in cases where worker threads maintain an in-memory cache of data- and routing-related tasks to the same worker could result in more cache hits, <a data-type="indexterm" data-primary="patterns" data-secondary="thread pool" data-tertiary="dispatch methods" data-startref="pattdismeth" id="idm45995915156072" class="calibre6"/>but such an approach is a little harder to generalize.</p>
<div data-type="tip" class="calibre22"><h6 class="calibre23">Tip</h6>
<p class="author1">Depending on the nature of your application, you may find that one of these strategies offers much better performance than the others. Again, benchmarking is your friend when it comes to measuring a given application’s performance.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Example Implementation" class="calibre4"><div class="preface" id="idm45995915153096">
<h2 class="calibre37">Example Implementation</h2>

<p class="author1">This example repurposes the existing files from <em class="calibre7">ch2-patterns/</em> that you created in <a data-type="xref" href="ch02.xhtml#ch_browser_sec_libs_sub_interface" class="calibre6">“Putting It All Together”</a>, but a lot of the error handling has been removed for brevity, and the code has been made compatible with Node.js. Create a new directory named <em class="calibre7">ch6-thread-pool/</em> to house the files that you’ll create in this section.</p>

<p class="author1">The first file you’ll <a data-type="indexterm" data-primary="thread pool" data-secondary="implementing" id="thrimp" class="calibre6"/><a data-type="indexterm" data-primary="patterns" data-secondary="thread pool" data-tertiary="implementation example" id="threadimp" class="calibre6"/>create is <em class="calibre7">main.js</em>. This is the entrypoint into the application. The previous version of this code just used a <code class="calibre18">Promise.allSettled()</code> call to add tasks to the pool, but that’s not all that interesting because it adds everything at the same time. Instead, this application exposes a web server, and every request then creates a new task for the thread pool. With this approach, previous tasks might have been completed by the time the pool is consulted, which then results in more interesting patterns like with a real-world application.</p>

<p class="author1">Add the content from <a data-type="xref" href="#ex_threadpool_main" class="calibre6">Example 6-1</a> to <em class="calibre7">main.js</em> to start off your application.</p>
<div id="ex_threadpool_main" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-1. </span><em class="calibre7">ch6-thread-pool/main.js</em></h5>
<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="calibre18">#!/usr/bin/env node
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">http</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">require</code><code class="p">(</code><code class="s">'http'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">RpcWorkerPool</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">require</code><code class="p">(</code><code class="s">'./rpc-worker.js'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">worker</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">RpcWorkerPool</code><code class="p">(</code><code class="s">'./worker.js'</code><code class="p">,</code><code class="calibre18">
  </code><code class="nb">Number</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">THREADS</code><code class="p">)</code><code class="p">,</code><code class="calibre18"> </code><a class="calibre6" id="manual_co_multithreaded_patterns_CO1-1" href="#manual_callout_multithreaded_patterns_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">STRATEGY</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="manual_co_multithreaded_patterns_CO1-2" href="#manual_callout_multithreaded_patterns_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">

</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">server</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">createServer</code><code class="p">(</code><code class="nx">async</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">req</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">res</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">value</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="mi">100_000_000</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">sum</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">await</code><code class="calibre18"> </code><code class="nx">worker</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="s">'square_sum'</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">value</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">res</code><code class="p">.</code><code class="nx">end</code><code class="p">(</code><code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="p">{</code><code class="calibre18"> </code><code class="nx">sum</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">value</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code class="calibre18">

</code><code class="nx">server</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="mi">1337</code><code class="p">,</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="calibre18"> </code><code class="kr">throw</code><code class="calibre18"> </code><code class="nx">err</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'http://localhost:1337/'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="manual_callout_multithreaded_patterns_CO1-1" href="#manual_co_multithreaded_patterns_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The <code class="calibre18">THREADS</code> environment variable controls the pool size.</p></dd>
<dt class="calibre15"><a class="calibre6" id="manual_callout_multithreaded_patterns_CO1-2" href="#manual_co_multithreaded_patterns_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The <code class="calibre18">STRATEGY</code> environment variable sets the dispatch strategy.</p></dd>
</dl></div>

<p class="author1">This application used <a data-type="indexterm" data-primary="THREADS variable" id="idm45995915040888" class="calibre6"/><a data-type="indexterm" data-primary="STRATEGY variable" id="idm45995915040184" class="calibre6"/><a data-type="indexterm" data-primary="environment variables" data-secondary="THREADS" id="idm45995915039512" class="calibre6"/><a data-type="indexterm" data-primary="environment variables" data-secondary="STRATEGY" id="idm45995915038568" class="calibre6"/>two environment variables to make it easy to experiment with. The first is named <code class="calibre18">THREADS</code> and will be used to set the number of threads in the thread pool. The second environment variable is <code class="calibre18">STRATEGY</code>, which can be used to set the thread pool dispatch strategy. Otherwise, the server isn’t too exciting, as it just uses the built-in <code class="calibre18">http</code> module. The server listens on port 1337, and any request, regardless of path, triggers the handler. Each request calls the <code class="calibre18">square_sum</code> command defined in the workers while passing in a value between 0 and 100 million.</p>

<p class="author1">Next, create a file named <em class="calibre7">worker.js</em>, and add the content from <a data-type="xref" href="#ex_threadpool_worker" class="calibre6">Example 6-2</a> to it.</p>
<div id="ex_threadpool_worker" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-2. </span><em class="calibre7">ch6-thread-pool/worker.js</em></h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code> <code class="p">{</code> <code class="nx">parentPort</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'worker_threads'</code><code class="p">);</code>

<code class="kr">function</code> <code class="nx">asyncOnMessageWrap</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">return</code> <code class="nx">async</code> <code class="kr">function</code><code class="p">(</code><code class="nx">msg</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">parentPort</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="nx">await</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">msg</code><code class="p">));</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">commands</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">async</code> <code class="nx">square_sum</code><code class="p">(</code><code class="nx">max</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">await</code> <code class="kr">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">res</code><code class="p">,</code> <code class="mi">100</code><code class="p">));</code>
    <code class="kr">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="kr">for</code> <code class="p">(</code><code class="kr">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">max</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">sum</code> <code class="o">+=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
    <code class="kr">return</code> <code class="nx">sum</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="nx">parentPort</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'message'</code><code class="p">,</code> <code class="nx">asyncOnMessageWrap</code><code class="p">(</code><code class="nx">async</code> <code class="p">({</code> <code class="nx">method</code><code class="p">,</code> <code class="nx">params</code><code class="p">,</code> <code class="nx">id</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">({</code>
  <code class="nx">result</code><code class="o">:</code> <code class="nx">await</code> <code class="nx">commands</code><code class="p">[</code><code class="nx">method</code><code class="p">](...</code><code class="nx">params</code><code class="p">),</code> <code class="nx">id</code>
<code class="p">})));</code></pre></div>

<p class="author1">This file isn’t too interesting because it’s essentially a simplified version of the <em class="calibre7">worker.js</em> file that you previously created. A lot of the error handling was removed to make the code shorter (feel free to add it back if you like), and the code has also been modified to be compatible with the Node.js APIs. In this example only a single command remains, namely <code class="calibre18">square_sum</code>.</p>

<p class="author1">Next, create a file named <em class="calibre7">rpc-worker.js</em>. This file <a data-type="indexterm" data-primary="rpc-worker.js file" id="idm45995915027928" class="calibre6"/>is going to be quite large and has been broken up into smaller sections. First, add the content from <a data-type="xref" href="#ex_threadpool_rpcworker_1" class="calibre6">Example 6-3</a> to it.</p>
<div id="ex_threadpool_rpcworker_1" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-3. </span><em class="calibre7">ch6-thread-pool/rpc-worker.js</em> (part 1)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">require</code><code class="p">(</code><code class="s">'worker_threads'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">CORES</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">require</code><code class="p">(</code><code class="s">'os'</code><code class="p">)</code><code class="p">.</code><code class="nx">cpus</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">STRATEGIES</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Set</code><code class="p">(</code><code class="p">[</code><code class="calibre18"> </code><code class="s">'roundrobin'</code><code class="p">,</code><code class="calibre18"> </code><code class="s">'random'</code><code class="p">,</code><code class="calibre18"> </code><code class="s">'leastbusy'</code><code class="calibre18"> </code><code class="p">]</code><code class="p">)</code><code class="p">;</code><code class="calibre18">

</code><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">class</code><code class="calibre18"> </code><code class="nx">RpcWorkerPool</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="nx">constructor</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">size</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">strategy</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="s">'roundrobin'</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">size</code><code class="calibre18"> </code><code class="o">===</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">)</code><code class="calibre18">     </code><code class="kr">this</code><code class="p">.</code><code class="nx">size</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">CORES</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO1-1" href="#callout_multithreaded_patterns_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
    </code><code class="kr">else</code><code class="calibre18"> </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">size</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">)</code><code class="calibre18">  </code><code class="kr">this</code><code class="p">.</code><code class="nx">size</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">CORES</code><code class="calibre18"> </code><code class="o">+</code><code class="calibre18"> </code><code class="nx">size</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">1</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">else</code><code class="calibre18">                </code><code class="kr">this</code><code class="p">.</code><code class="nx">size</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">size</code><code class="p">;</code><code class="calibre18">

    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="o">!</code><code class="nx">STRATEGIES</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">strategy</code><code class="p">)</code><code class="p">)</code><code class="calibre18"> </code><code class="kr">throw</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">TypeError</code><code class="p">(</code><code class="s">'invalid strategy'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">this</code><code class="p">.</code><code class="nx">strategy</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">strategy</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO1-2" href="#callout_multithreaded_patterns_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
    </code><code class="kr">this</code><code class="p">.</code><code class="nx">rr_index</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="o">-</code><code class="mi">1</code><code class="p">;</code><code class="calibre18">

    </code><code class="kr">this</code><code class="p">.</code><code class="nx">next_command_id</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">this</code><code class="p">.</code><code class="nx">workers</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="p">[</code><code class="p">]</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO1-3" href="#callout_multithreaded_patterns_CO1-3"><img src="Images/3.png" alt="3" class="calibre32"/></a><code class="calibre18">
    </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">size</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="o">++</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">worker</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">(</code><code class="nx">path</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">this</code><code class="p">.</code><code class="nx">workers</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="p">{</code><code class="calibre18"> </code><code class="nx">worker</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">in_flight_commands</code><code class="o">:</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Map</code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO1-4" href="#callout_multithreaded_patterns_CO1-4"><img src="Images/4.png" alt="4" class="calibre32"/></a><code class="calibre18">
      </code><code class="nx">worker</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'message'</code><code class="p">,</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">msg</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
        </code><code class="kr">this</code><code class="p">.</code><code class="nx">onMessageHandler</code><code class="p">(</code><code class="nx">msg</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">i</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
  </code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO1-1" href="#co_multithreaded_patterns_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The thread pool size is highly configurable.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO1-2" href="#co_multithreaded_patterns_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The strategy is validated and stored.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO1-3" href="#co_multithreaded_patterns_CO1-3"><img src="Images/3.png" alt="3" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">An array of workers is maintained instead of just one.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO1-4" href="#co_multithreaded_patterns_CO1-4"><img src="Images/4.png" alt="4" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The <code class="calibre18">in_flight_commands</code> list is now maintained per worker.</p></dd>
</dl></div>

<p class="author1">This file starts off by requiring the <code class="calibre18">worker_threads</code> core module to create workers, as well as the <code class="calibre18">os</code> module <a data-type="indexterm" data-primary="modules" data-secondary="os module" id="idm45995914854472" class="calibre6"/><a data-type="indexterm" data-primary="os module" id="idm45995914853464" class="calibre6"/><a data-type="indexterm" data-primary="worker_threads module" id="idm45995914852792" class="calibre6"/><a data-type="indexterm" data-primary="modules" data-secondary="worker_threads" id="idm45995914852120" class="calibre6"/>to get the number of available CPU cores. After that the <code class="calibre18">RpcWorkerPool</code> class is <a data-type="indexterm" data-primary="RpcWorkerPool class" id="idm45995914863048" class="calibre6"/><a data-type="indexterm" data-primary="classes" data-secondary="RpcWorkerPool" id="idm45995914862424" class="calibre6"/>defined and exported. Next, the constructor for the class is provided. The constructor takes three arguments, with the first being the path to the worker file, the second being the size of the pool, and the third being the strategy to use.</p>

<p class="author1">The pool size is highly configurable and allows the caller to provide a number. If the number is positive, then it is used as the size of the pool. The default value is zero, and if provided, the number of CPU cores is used for the pool size. If a negative number is provided, then that number is subtracted from the number of available cores and that is used instead. So, on an 8 core machine, passing in a pool size of –2 would result in a pool size of 6.</p>

<p class="author1">The strategy argument may be one of <code class="calibre18">roundrobin</code> (the default), <code class="calibre18">random</code>, or <code class="calibre18">leastbusy</code>. The value is validated before being assigned to the class. The <code class="calibre18">rr_index</code> value is used as the round robin index and is a number that cycles through the next available worker ID.</p>

<p class="author1">The <code class="calibre18">next_command_id</code> is still global across all threads, so the first command will be <code class="calibre18">1</code> and the next will be <code class="calibre18">2</code>, regardless of whether the commands are both handled by the same worker thread or not.</p>

<p class="author1">Finally, the <code class="calibre18">workers</code> class property is <a data-type="indexterm" data-primary="workers class property" id="idm45995914867080" class="calibre6"/>an array of workers instead of the previous singular <code class="calibre18">worker</code> property. The code to handle it is largely the same, but the <code class="calibre18">in_flight_commands</code> list is now local to the individual workers, and the ID of the worker is passed as an additional argument <a data-type="indexterm" data-primary="onMessageHandler() method" id="idm45995914865288" class="calibre6"/><a data-type="indexterm" data-primary="methods" data-secondary="onMessageHandler()" id="idm45995914864616" class="calibre6"/>to the <code class="calibre18">onMessageHandler()</code> method. This is because the individual worker will later need to be looked up when a message is sent back to the main process.</p>

<p class="author1">Continue editing the file by adding the content from <a data-type="xref" href="#ex_threadpool_rpcworker_2" class="calibre6">Example 6-4</a> to it.</p>
<div id="ex_threadpool_rpcworker_2" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-4. </span><em class="calibre7">ch6-thread-pool/rpc-worker.js</em> (part 2)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28">  <code class="nx">onMessageHandler</code><code class="p">(</code><code class="nx">msg</code><code class="p">,</code> <code class="nx">worker_id</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">worker</code> <code class="o">=</code> <code class="kr">this</code><code class="p">.</code><code class="nx">workers</code><code class="p">[</code><code class="nx">worker_id</code><code class="p">];</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">result</code><code class="p">,</code> <code class="nx">error</code><code class="p">,</code> <code class="nx">id</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">msg</code><code class="p">;</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">worker</code><code class="p">.</code><code class="nx">in_flight_commands</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>
    <code class="nx">worker</code><code class="p">.</code><code class="nx">in_flight_commands</code><code class="p">.</code><code class="kr">delete</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>
    <code class="kr">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="nx">reject</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>
    <code class="kr">else</code> <code class="nx">resolve</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code>
  <code class="p">}</code></pre></div>

<p class="author1">This part of the file defines the <code class="calibre18">onMessageHandler()</code> method that is called when a worker sends a message back to the main thread. It’s mostly the same as before, except this time it accepts an additional argument, <code class="calibre18">worker_id</code>, which is used to look up the worker that sent the message. Once it looks up the worker, it handles the promise rejection/resolve and removes the entry from the list of pending commands.</p>

<p class="author1">Continue editing the file by adding the content from <a data-type="xref" href="#ex_threadpool_rpcworker_3" class="calibre6">Example 6-5</a> to it.</p>
<div id="ex_threadpool_rpcworker_3" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-5. </span><em class="calibre7">ch6-thread-pool/rpc-worker.js</em> (part 3)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="calibre18">  </code><code class="nx">exec</code><code class="p">(</code><code class="nx">method</code><code class="p">,</code><code class="calibre18"> </code><code class="p">...</code><code class="nx">args</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">id</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="o">++</code><code class="kr">this</code><code class="p">.</code><code class="nx">next_command_id</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">resolve</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">reject</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">promise</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nb">Promise</code><code class="p">(</code><code class="p">(</code><code class="nx">res</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">rej</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">resolve</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">res</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">reject</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">rej</code><code class="p">;</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">worker</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">getWorker</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO2-1" href="#callout_multithreaded_patterns_CO2-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
    </code><code class="nx">worker</code><code class="p">.</code><code class="nx">in_flight_commands</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">resolve</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">reject</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="nx">worker</code><code class="p">.</code><code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="p">{</code><code class="calibre18"> </code><code class="nx">method</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">params</code><code class="o">:</code><code class="calibre18"> </code><code class="nx">args</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">id</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">promise</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO2-1" href="#co_multithreaded_patterns_CO2-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The applicable worker is looked up.</p></dd>
</dl></div>

<p class="author1">This chunk of the file <a data-type="indexterm" data-primary="exec() method" id="idm45995914370968" class="calibre6"/>defines the <code class="calibre18">exec()</code> method, which is what the application calls when it wants to execute a command in one of the workers. Again, it’s largely unchanged, but this time it calls the <code class="calibre18">getWorker()</code> method to get the appropriate worker to handle the next command, instead of working with a single default worker. That method is defined in the next section.</p>

<p class="author1">Finish editing the file by adding the content from <a data-type="xref" href="#ex_threadpool_rpcworker_4" class="calibre6">Example 6-6</a> to it.</p>
<div id="ex_threadpool_rpcworker_4" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-6. </span><em class="calibre7">ch6-thread-pool/rpc-worker.js</em> (part 4)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28">  <code class="nx">getWorker</code><code class="p">()</code> <code class="p">{</code>
    <code class="kr">let</code> <code class="nx">id</code><code class="p">;</code>
    <code class="kr">if</code> <code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">strategy</code> <code class="o">===</code> <code class="s">'random'</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">id</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="kr">this</code><code class="p">.</code><code class="nx">size</code><code class="p">);</code>
    <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">strategy</code> <code class="o">===</code> <code class="s">'roundrobin'</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">this</code><code class="p">.</code><code class="nx">rr_index</code><code class="o">++</code><code class="p">;</code>
      <code class="kr">if</code> <code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">rr_index</code> <code class="o">&gt;=</code> <code class="kr">this</code><code class="p">.</code><code class="nx">size</code><code class="p">)</code> <code class="kr">this</code><code class="p">.</code><code class="nx">rr_index</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
      <code class="nx">id</code> <code class="o">=</code> <code class="kr">this</code><code class="p">.</code><code class="nx">rr_index</code><code class="p">;</code>
    <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">strategy</code> <code class="o">===</code> <code class="s">'leastbusy'</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">let</code> <code class="nx">min</code> <code class="o">=</code> <code class="kr">Infinity</code><code class="p">;</code>
      <code class="kr">for</code> <code class="p">(</code><code class="kr">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="kr">this</code><code class="p">.</code><code class="nx">size</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">let</code> <code class="nx">worker</code> <code class="o">=</code> <code class="kr">this</code><code class="p">.</code><code class="nx">workers</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
        <code class="kr">if</code> <code class="p">(</code><code class="nx">worker</code><code class="p">.</code><code class="nx">in_flight_commands</code><code class="p">.</code><code class="nx">size</code> <code class="o">&lt;</code> <code class="nx">min</code><code class="p">)</code> <code class="p">{</code>
          <code class="nx">min</code> <code class="o">=</code> <code class="nx">worker</code><code class="p">.</code><code class="nx">in_flight_commands</code><code class="p">.</code><code class="nx">size</code><code class="p">;</code>
          <code class="nx">id</code> <code class="o">=</code> <code class="nx">i</code><code class="p">;</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Selected Worker:'</code><code class="p">,</code> <code class="nx">id</code><code class="p">);</code>
    <code class="kr">return</code> <code class="kr">this</code><code class="p">.</code><code class="nx">workers</code><code class="p">[</code><code class="nx">id</code><code class="p">];</code>
  <code class="p">}</code>
<code class="p">};</code></pre></div>

<p class="author1">This final chunk of the file defines a final, new <a data-type="indexterm" data-primary="getWorker() method" id="idm45995914225976" class="calibre6"/><a data-type="indexterm" data-primary="methods" data-secondary="getWorker()" id="idm45995914225368" class="calibre6"/>method named <code class="calibre18">getWorker()</code>. This method considers the strategy that was defined for the class instance when determining which worker to use next. The bulk of the function is a large <code class="calibre18">if</code> statement where each branch correlates to a strategy.</p>

<p class="author1">The first one, <code class="calibre18">random</code>, doesn’t require any additional state, making it the simplest. All the function does is to randomly choose one of the entries in the pool and then choose that as a candidate.</p>

<p class="author1">The second branch, for <code class="calibre18">roundrobin</code>, is slightly more complicated. This one makes use of a class property named <code class="calibre18">rr_index</code>, incrementing the value and then returning the worker located at the new index. Once the index exceeds the number of workers, it then wraps back around to zero.</p>

<p class="author1">The final branch, for <code class="calibre18">leastbusy</code>, has the most complexity. It works by looping through each one of the workers, noting the number of commands that it currently has in progress by looking at the size of the <code class="calibre18">in_flight_commands</code> map, and determining if it’s the smallest value that has been encountered so far. If so, it then decides that worker is the next to be used. Note that this implementation will stop at the first matching worker with the lowest number of in-flight commands; so the first time it runs it will always choose worker 0. A more robust implementation might look at all of the candidates with the lowest, equal commands, and choose one randomly. The chosen worker ID is logged so that you can tell what’s happening.</p>

<p class="author1">Now that your application has been prepared, you’re ready to execute it. Open up two terminal windows and navigate <a data-type="indexterm" data-primary="code samples" data-secondary="ch6-thread-pool directory" id="idm45995914033720" class="calibre6"/>to the <em class="calibre7">ch6-thread-pool/</em> directory in the first one. In this terminal window execute the following command:</p>

<pre data-type="programlisting" class="calibre38">$ THREADS=3 STRATEGY=leastbusy node main.js</pre>

<p class="author1">This starts a process with a thread pool containing three workers using the <code class="calibre18">leastbusy</code> strategy.</p>

<p class="author1">Next, run the following command in the second terminal window:</p>

<pre data-type="programlisting" class="calibre38">$ npx autocannon -c 5 -a 20 http://localhost:1337</pre>

<p class="author1">This executes the <code class="calibre18">autocannon</code> command, which <a data-type="indexterm" data-primary="npm packages" data-secondary="autocannon" id="idm45995914028584" class="calibre6"/>is an npm package for performing benchmarks. In this case, though, you’re not actually running a benchmark, but you’re instead just running a whole bunch of queries. The command is configured to open five connections at a time and send a total of 20 requests. Essentially, this will make 5 requests seemingly in parallel, then as the requests are closed the remaining 15 requests will be made. This is akin to a production web server you might build.</p>

<p class="author1">Since the application is using the <code class="calibre18">leastbusy</code> strategy, and because the code is written to choose the first process with the fewest commands, the first five requests should then essentially be treated as round robin. With a pool size of three, when the application first runs, each worker has zero tasks. So the code first elects to use Worker 0. For the second request, the first worker has one task while the second and third worker have zero, so the second is chosen. Then the third. For the fourth, each of the three workers is consulted, each having one task, and so the first is chosen again.</p>

<p class="author1">After the first five tasks are assigned, the remaining worker assignments are essentially random, as each command takes essentially a random amount of time to 
<span class="keep-together">succeed</span>.</p>

<p class="author1">Next, kill the server using Ctrl+C, and then run it again using the <code class="calibre18">roundrobin</code> 
<span class="keep-together">strategy</span>:</p>

<pre data-type="programlisting" class="calibre38">$ THREADS=3 STRATEGY=roundrobin node main.js</pre>

<p class="author1">Run the same <code class="calibre18">autocannon</code> command as before in the second terminal. This time you should see that the tasks are always executed in the order of 0, 1, 2, 0, and so on.</p>

<p class="author1">Finally, kill the server with Ctrl+C again, and run it again with the random strategy:</p>

<pre data-type="programlisting" class="calibre38">$ THREADS=3 STRATEGY=random node main.js</pre>

<p class="author1">Run the <code class="calibre18">autocannon</code> command a final time and note the results. This time it should be entirely random. If you notice the same worker getting chosen multiple times in a row, it likely means that worker is overloaded.</p>

<p class="author1"><a data-type="xref" href="#list_threadpool_strategy" class="calibre6">Table 6-1</a> contains sample output from a previous run of this experiment. Each column corresponds to a new request, and the number in the table contains the ID of the worker that was chosen to serve the request.</p>
<table id="list_threadpool_strategy" class="calibre46">
<caption class="calibre47"><span class="keep-together">Table 6-1. </span>Example thread pool strategy output</caption>
<thead class="calibre48">
<tr class="calibre49">
<th class="calibre50">Strategy</th>
<th class="calibre50">R1</th>
<th class="calibre50">R2</th>
<th class="calibre50">R3</th>
<th class="calibre50">R4</th>
<th class="calibre50">R5</th>
<th class="calibre50">R6</th>
<th class="calibre50">R7</th>
<th class="calibre50">R8</th>
<th class="calibre50">R9</th>
<th class="calibre50">R10</th>
</tr>
</thead>
<tbody class="calibre51">
<tr class="calibre49">
<td class="calibre52"><p class="author1">Least busy</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">2</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">2</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">0</p></td>
</tr>
<tr class="calibre53">
<td class="calibre52"><p class="author1">Round robin</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">2</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">2</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">2</p></td>
<td class="calibre52"><p class="author1">0</p></td>
</tr>
<tr class="calibre49">
<td class="calibre52"><p class="author1">Random</p></td>
<td class="calibre52"><p class="author1">2</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">0</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">1</p></td>
<td class="calibre52"><p class="author1">0</p></td>
</tr>
</tbody>
</table>

<p class="author1">In this particular run the random approach hardly ever <a data-type="indexterm" data-primary="thread pool" data-secondary="implementing" data-startref="thrimp" id="idm45995913988696" class="calibre6"/><a data-type="indexterm" data-primary="patterns" data-secondary="thread pool" data-tertiary="implementation example" data-startref="threadimp" id="idm45995913987448" class="calibre6"/>used the worker with an ID 
<span class="keep-together">of 2.</span></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Mutex: A Basic Lock" class="calibre4"><div class="preface" id="ch_patterns_sec_basiclock">
<h1 class="calibre13">Mutex: A Basic Lock</h1>

<p class="author1">A mutually exclusive lock, or <em class="calibre7">mutex</em>, is a mechanism <a data-type="indexterm" data-primary="mutex (Linux)" id="mutx" class="calibre6"/><a data-type="indexterm" data-primary="Linux" data-secondary="mutex" id="linmx" class="calibre6"/>for controlling access to some shared data. It ensures that only one task may use that resource at any given time. Here, a task can mean any sort of concurrent task, but most often the concept is used when working with multiple threads, to avoid race conditions. A task <em class="calibre7">acquires</em> the lock in order to run code that accesses the shared data, and then <em class="calibre7">releases</em> the lock once it’s done. The code between the acquisition and the release is called the <em class="calibre7">critical section</em>. If a task attempts to acquire the <a data-type="indexterm" data-primary="locks" data-seealso="mutex (Linux)" id="idm45995913979464" class="calibre6"/>lock while another task has it, that task will be blocked until the other task releases the lock.</p>

<p class="author1">It may not be obvious why you might want to use a mutex when we have atomic operations at our disposal through the <code class="calibre18">Atomics</code> object. Surely it’s more efficient to use atomic operations to modify and read data, since we’re blocking other operations for shorter time periods, right? It turns out that code often requires that data not be modified externally across more than one operation. Put another way, the units of atomicity provided by atomic operations are too small for many algorithms’ critical sections. For example, two integers may be read from several parts of shared memory, then summed up to be written to another part. If values are changed in between the two retrievals, the sum will reflect values from two different tasks, which can lead to logic errors later on in the program.</p>

<p class="author1">Let’s look at an example program that initializes a buffer with a bunch of numbers and performs some basic math on them in several threads. We’ll have each thread grab a value at a unique index per thread, then grab a value from a shared index, multiply those together, and write them at the shared index. Then we’ll read from that shared index and check that it’s equal to the product of the previous two reads. In between the two reads, we’ll perform a busy loop to simulate doing some other work that takes some time.</p>

<p class="author1">Make a directory called <em class="calibre7">ch6-mutex</em> and put the <a data-type="indexterm" data-primary="code samples" data-secondary="ch6-mutex" id="idm45995913974968" class="calibre6"/>contents of <a data-type="xref" href="#ex_ch6_mutex_1" class="calibre6">Example 6-7</a> into a file called <em class="calibre7">thread_product.js</em>.</p>
<div id="ex_ch6_mutex_1" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-7. </span><em class="calibre7">ch6-mutex/thread-product.js</em></h5>
<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="nx">Worker</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">isMainThread</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="calibre18">
</code><code class="p">}</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">require</code><code class="p">(</code><code class="s">'worker_threads'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">assert</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">require</code><code class="p">(</code><code class="s">'assert'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">

</code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">isMainThread</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">shared</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">SharedArrayBuffer</code><code class="p">(</code><code class="mi">4</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="mi">4</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="manual_co_multithreaded_patterns_CO3-1" href="#manual_callout_multithreaded_patterns_CO3-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">sharedInts</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Int32Array</code><code class="p">(</code><code class="nx">shared</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">sharedInts</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="p">[</code><code class="mi">2</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">3</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">5</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">7</code><code class="p">]</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="mi">3</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="o">++</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">(</code><code class="nx">__filename</code><code class="p">,</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="o">:</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">i</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">shared</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code><code class="calibre18">
</code><code class="p">}</code><code class="calibre18"> </code><code class="kr">else</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">i</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">shared</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">sharedInts</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Int32Array</code><code class="p">(</code><code class="nx">shared</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">a</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">Atomics</code><code class="p">.</code><code class="nx">load</code><code class="p">(</code><code class="nx">sharedInts</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">i</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">j</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">j</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="mi">1_000_000</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">j</code><code class="o">++</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="p">}</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">b</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">Atomics</code><code class="p">.</code><code class="nx">load</code><code class="p">(</code><code class="nx">sharedInts</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">3</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">Atomics</code><code class="p">.</code><code class="nx">store</code><code class="p">(</code><code class="nx">sharedInts</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">3</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">a</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nx">b</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">assert</code><code class="p">.</code><code class="nx">strictEqual</code><code class="p">(</code><code class="nx">Atomics</code><code class="p">.</code><code class="nx">load</code><code class="p">(</code><code class="nx">sharedInts</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">3</code><code class="p">)</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">a</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nx">b</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="manual_co_multithreaded_patterns_CO3-2" href="#manual_callout_multithreaded_patterns_CO3-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
</code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="manual_callout_multithreaded_patterns_CO3-1" href="#manual_co_multithreaded_patterns_CO3-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">We’ll be using three threads and an <code class="calibre18">Int32Array</code> to hold the data, so we need it big enough to hold three 32-bit integers, plus a fourth to be the shared multiplier/result.</p></dd>
<dt class="calibre15"><a class="calibre6" id="manual_callout_multithreaded_patterns_CO3-2" href="#manual_co_multithreaded_patterns_CO3-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">Here, we’re checking our work. In a real-world application, there likely would be no check here, but this simulates depending on the result to perform other actions, which may happen later on in the program.</p></dd>
</dl></div>

<p class="author1">You can run this example as follows:</p>

<pre data-type="programlisting" class="calibre38">$ node thread-product.js</pre>

<p class="author1">You might find that on the first try, or even the first bunch of tries, this works fine, but go ahead and keep running it. Alternatively you may find that the assertion fails immediately. At some point, within the first 20 or so attempts, you should see that the assertion fails. While we’re using atomic operations, we’re using four of them, and between any of these, some change can occur in these <a data-type="indexterm" data-primary="race condition" id="idm45995913800200" class="calibre6"/>values. This is a classic example of a race condition. All the threads are reading and writing concurrently (though not in parallel, since the operations themselves are atomic), so the results aren’t deterministic for given input values.</p>

<p class="author1">To solve this, we’ll implement a <code class="calibre18">Mutex</code> class using <a data-type="indexterm" data-primary="Mutex class" id="idm45995913798088" class="calibre6"/><a data-type="indexterm" data-primary="classes" data-secondary="Mutex" id="idm45995913797352" class="calibre6"/>the primitives we have in <code class="calibre18">Atomics</code>. We’ll be making use of <code class="calibre18">Atomics.wait()</code> to wait until the lock can be acquired, and <code class="calibre18">Atomics.notify()</code> to notify threads that the lock has been released. We’ll use <code class="calibre18">Atomics.compareExchange()</code> to swap the locked/unlocked state and determine whether we need to wait to get the lock. Create a file in the same directory called <em class="calibre7">mutex.js</em> and add the contents of <a data-type="xref" href="#ex_ch6_mutex_2" class="calibre6">Example 6-8</a> to get started on the <code class="calibre18">Mutex</code> class.</p>
<div id="ex_ch6_mutex_2" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-8. </span><em class="calibre7">ch6-mutex/mutex.js</em> (part 1)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code> <code class="nx">UNLOCKED</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">LOCKED</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

<code class="kr">const</code> <code class="p">{</code>
  <code class="nx">compareExchange</code><code class="p">,</code> <code class="nx">wait</code><code class="p">,</code> <code class="nx">notify</code>
<code class="p">}</code> <code class="o">=</code> <code class="nx">Atomics</code><code class="p">;</code>

<code class="kr">class</code> <code class="nx">Mutex</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">(</code><code class="nx">shared</code><code class="p">,</code> <code class="nx">index</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">shared</code> <code class="o">=</code> <code class="nx">shared</code><code class="p">;</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">=</code> <code class="nx">index</code><code class="p">;</code>
  <code class="p">}</code></pre></div>

<p class="author1">Here we’ve defined our <code class="calibre18">LOCKED</code> and <code class="calibre18">UNLOCKED</code> states as 1 and 0, respectively. Really, they can be any values that fit in the <code class="calibre18">TypedArray</code> we pass into the <code class="calibre18">Mutex</code> constructor, but <a data-type="indexterm" data-primary="constructors" data-secondary="Mutex" id="idm45995913745768" class="calibre6"/>sticking with 1 and 0 makes it easier to think about as a boolean value. We have 
<span class="keep-together">set up</span> the constructor to take in two values that will be assigned to properties: the 
<span class="keep-together"><code class="calibre18">TypedArray</code></span> we’ll be operating on, and the index in that array that we’ll use as the lock status. Now, we’re ready to start using <code class="calibre18">Atomics</code> to add <a data-type="indexterm" data-primary="acquire() method" id="idm45995913742600" class="calibre6"/><a data-type="indexterm" data-primary="methods" data-secondary="acquire()" id="idm45995913741864" class="calibre6"/>the <code class="calibre18">acquire()</code> method, which uses the destructured <code class="calibre18">Atomics</code>. Add the <code class="calibre18">acquire()</code> method from <a data-type="xref" href="#ex_ch6_mutex_3" class="calibre6">Example 6-9</a>.</p>
<div id="ex_ch6_mutex_3" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-9. </span><em class="calibre7">ch6-mutex/mutex.js</em> (part 2)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28">  <code class="nx">acquire</code><code class="p">()</code> <code class="p">{</code>
    <code class="kr">if</code> <code class="p">(</code><code class="nx">compareExchange</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">shared</code><code class="p">,</code> <code class="kr">this</code><code class="p">.</code><code class="nx">index</code><code class="p">,</code> <code class="nx">UNLOCKED</code><code class="p">,</code> <code class="nx">LOCKED</code><code class="p">)</code> <code class="o">===</code> <code class="nx">UNLOCKED</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">return</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">wait</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">shared</code><code class="p">,</code> <code class="kr">this</code><code class="p">.</code><code class="nx">index</code><code class="p">,</code> <code class="nx">LOCKED</code><code class="p">);</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">acquire</code><code class="p">();</code>
  <code class="p">}</code></pre></div>

<p class="author1">To acquire a lock, we make <a data-type="indexterm" data-primary="locks" data-secondary="acquiring" id="idm45995913611336" class="calibre6"/>an attempt to swap the <code class="calibre18">UNLOCKED</code> state for the <code class="calibre18">LOCKED</code> state at the mutex’s array index, using <code class="calibre18">Atomics.compareExchange()</code>. If the swap is successful, then there’s nothing left to do and we’ve acquired the lock, so we can just return. Otherwise we need to wait for unlocking, which in this case means waiting for notification that the value change from <code class="calibre18">LOCKED</code> to anything else. Then we make another attempt to acquire the lock. We’re doing this through recursion here to illustrate the “retry” nature of the operation, but it could just as easily be a loop. It should work on the second time through since we’ve specifically waited for it to become unlocked, but in between the <code class="calibre18">wait()</code> and the <code class="calibre18">compareExchange()</code>, the value may have changed, so we need to check again. In a real-world implementation, you might want to both add a timeout on the <code class="calibre18">wait()</code> and limit the number of attempts that can be made.</p>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="author1">In many production mutex implementations, in addition to the “unlocked” and “locked” states, you’ll often find a <a data-type="indexterm" data-primary="locked and contended state, mutex" id="idm45995913649336" class="calibre6"/>state meaning “locked and contended.” <em class="calibre7">Contention</em> arises when one thread attempts to acquire a lock that’s already held by another thread. By keeping track of this state, the mutex code can avoid using extra <code class="calibre18">notify()</code> calls, allowing for better performance.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar" class="calibre54"><div class="sidebar" id="idm45995913647176">
<h5 class="calibre55">Semaphores</h5>
<p class="author1">The element in the shared array that we use to represent the state of being locked or unlocked is a <a data-type="indexterm" data-primary="semaphores" id="idm45995913645736" class="calibre6"/>trivial example of a <em class="calibre7">semaphore</em>. Semaphores are variables used to convey state information between threads. They indicate a count of a resource being used. In the case of a mutex, we limit this to 1, but semaphores in other scenarios may involve other limits for other purposes.</p>
</div></aside>

<p class="author1">Now we’ll look at releasing a lock. Add the <code class="calibre18">release()</code> method shown in <a data-type="xref" href="#ex_ch6_mutex_4" class="calibre6">Example 6-10</a>.</p>
<div id="ex_ch6_mutex_4" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-10. </span><em class="calibre7">ch6-mutex/mutex.js</em> (part 3)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28">  <code class="nx">release</code><code class="p">()</code> <code class="p">{</code>
    <code class="kr">if</code> <code class="p">(</code><code class="nx">compareExchange</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">shared</code><code class="p">,</code> <code class="kr">this</code><code class="p">.</code><code class="nx">index</code><code class="p">,</code> <code class="nx">LOCKED</code><code class="p">,</code> <code class="nx">UNLOCKED</code><code class="p">)</code> <code class="o">!==</code> <code class="nx">LOCKED</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">throw</code> <code class="kr">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'was not acquired'</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="nx">notify</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">shared</code><code class="p">,</code> <code class="kr">this</code><code class="p">.</code><code class="nx">index</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>
  <code class="p">}</code></pre></div>

<p class="author1">Here we’re using <code class="calibre18">Atomics.compareExchange()</code> to swap <a data-type="indexterm" data-primary="locks" data-secondary="releasing" id="idm45995913563528" class="calibre6"/>the locked state again, much as we did to acquire the lock. This time, we want to make sure that the original state was indeed <code class="calibre18">LOCKED</code> since we don’t want to release the lock if we haven’t acquired it. The only thing left to do at this point is to <code class="calibre18">notify()</code>, enabling a waiting thread (if there is one) to acquire the lock. We set the count for <code class="calibre18">notify()</code> to 1, because there’s no need to wake more than one sleeping thread, since only one can ever hold the lock at one time.</p>

<p class="author1">What we have now is enough to work as a serviceable mutex lock. However, it’s relatively easy to acquire a lock and forget to release it, or in some other way have an unexpected critical section. For many use cases, the critical section is well-defined and knowable ahead of time. In those cases, it makes sense to have a helper method on the <code class="calibre18">Mutex</code> class to wrap critical sections with ease. Let’s do exactly that by adding the <code class="calibre18">exec()</code> method in <a data-type="xref" href="#ex_ch6_mutex_5" class="calibre6">Example 6-11</a>, which will also finish off the class.</p>
<div id="ex_ch6_mutex_5" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-11. </span><em class="calibre7">ch6-mutex/mutex.js</em> (part 4)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28">  <code class="nx">exec</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">acquire</code><code class="p">();</code>
    <code class="kr">try</code> <code class="p">{</code>
      <code class="kr">return</code> <code class="nx">fn</code><code class="p">();</code>
    <code class="p">}</code> <code class="kr">finally</code> <code class="p">{</code>
      <code class="kr">this</code><code class="p">.</code><code class="nx">release</code><code class="p">();</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">Mutex</code><code class="p">;</code></pre></div>

<p class="author1">All we’re doing here is calling the passed-in function and returning its value, but wrapping that with an <code class="calibre18">acquire()</code> beforehand and <code class="calibre18">release()</code> afterward. This way the passed-in function contains all the code of our critical section. Note that we call the passed-in function inside a <code class="calibre18">try</code> block, with the <code class="calibre18">release()</code> happening in the corresponding <code class="calibre18">finally</code>. Since the passed-in function could throw an exception, we want to make sure that we release the lock even in that scenario. This completes our <code class="calibre18">Mutex</code> class, so now we can move on to using it in our example.</p>

<p class="author1">Make a copy of <em class="calibre7">thread-product.js</em> in the <a data-type="indexterm" data-primary="thread-product-mutex.js file" id="idm45995913538024" class="calibre6"/>same directory, called <em class="calibre7">thread-product-mutex.js</em>. In that file <code class="calibre18">require</code> the <em class="calibre7">mutex.js</em> file and assign it to a <code class="calibre18">const</code> called <code class="calibre18">Mutex</code>. Add another 4 bytes to the <code class="calibre18">SharedArrayBuffer</code> (e.g., <code class="calibre18">new SharedArrayBuffer(4 * 5)</code>) for our lock to use, then replace everything in the <code class="calibre18">else</code> block with the contents of <a data-type="xref" href="#ex_ch6_mutex_6" class="calibre6">Example 6-12</a>.</p>
<div id="ex_ch6_mutex_6" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-12. </span><em class="calibre7">ch6-mutex/thread-product-mutex.js</em></h5>
<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="calibre18">  </code><code class="kr">const</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">i</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">shared</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">sharedInts</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Int32Array</code><code class="p">(</code><code class="nx">shared</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">mutex</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Mutex</code><code class="p">(</code><code class="nx">sharedInts</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">4</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="manual_co_multithreaded_patterns_CO5-1" href="#manual_callout_multithreaded_patterns_CO5-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="nx">mutex</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">a</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">sharedInts</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="manual_co_multithreaded_patterns_CO5-2" href="#manual_callout_multithreaded_patterns_CO5-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
    </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">j</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">j</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="mi">1_000_000</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">j</code><code class="o">++</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="p">}</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">b</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">sharedInts</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="p">;</code><code class="calibre18">
    </code><code class="nx">sharedInts</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">a</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nx">b</code><code class="p">;</code><code class="calibre18">
    </code><code class="nx">assert</code><code class="p">.</code><code class="nx">strictEqual</code><code class="p">(</code><code class="nx">sharedInts</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">a</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nx">b</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="manual_callout_multithreaded_patterns_CO5-1" href="#manual_co_multithreaded_patterns_CO5-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">Before this line, everything’s the same as when we weren’t using the mutex. Now, we’ll initialize one, using the fifth element of our <code class="calibre18">Int32Array</code> as our lock data.</p></dd>
<dt class="calibre15"><a class="calibre6" id="manual_callout_multithreaded_patterns_CO5-2" href="#manual_co_multithreaded_patterns_CO5-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">Inside the function passed to <code class="calibre18">exec()</code>, we’re in our critical section, which is protected by the lock. This means we don’t need atomic operations to read or manipulate the array. Instead, we can just operate on it like any other <code class="calibre18">TypedArray</code>.</p></dd>
</dl></div>

<p class="author1">In addition to enabling ordinary array access techniques, the mutex has allowed us to ensure that no other thread is able to modify these pieces of data while we’re looking at them. Because of that, our assertion would never fail. Give it a try! Run the following command to run this example, and even run it tens, hundreds, or even thousands of times. It will never fail the assertion like the version using only atomics did:</p>

<pre data-type="programlisting" class="calibre38">$ node thread-product-mutex.js</pre>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="author1">Mutexes are straightforward tools to lock access to a resource. They allow critical sections to operate without interference from other threads. They are one example of how we can leverage combinations of atomic operations to make new building blocks for multithreaded <a data-type="indexterm" data-primary="mutex (Linux)" data-startref="mutx" id="idm45995913379976" class="calibre6"/><a data-type="indexterm" data-primary="Linux" data-secondary="mutex" data-startref="linmx" id="idm45995913379000" class="calibre6"/>programming. In the next section, <a data-type="xref" href="#ch_patterns_sec_stream" class="calibre6">“Streaming Data with Ring Buffers”</a>, we’ll put this building block to some practical use.</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Streaming Data with Ring Buffers" class="calibre4"><div class="preface" id="ch_patterns_sec_stream">
<h1 class="calibre13">Streaming Data with Ring Buffers</h1>

<p class="author1">Many applications involve <a data-type="indexterm" data-primary="streaming data" data-secondary="ring buffers and" id="idm45995913374680" class="calibre6"/><a data-type="indexterm" data-primary="buffers" data-secondary="ring buffers" id="idm45995913373736" class="calibre6"/><a data-type="indexterm" data-primary="ring buffers" data-seealso="circular buffers" id="idm45995913372792" class="calibre6"/>streaming data. For example, HTTP requests and responses are usually presented via HTTP APIs as sequences of byte data coming in as chunks as they are received. In network applications, data chunks are size-constrained by packet sizes. In filesystem applications, data chunks can be size-constrained by kernel buffer sizes. Even if we output data to these resources without any regard for streaming, the kernel will break the data up into chunks in order to send it to its destination in a buffered manner.</p>

<p class="author1">Streaming data also occurs in user applications and can be used as a way to transfer larger amounts of data between computation units, like processes or threads. Even without separate computation units, you may want or need to hold data in some kind of buffer before <a data-type="indexterm" data-primary="circular buffers" id="idm45995913370520" class="calibre6"/>processing it. This is where <em class="calibre7">ring buffers</em>, also known as <em class="calibre7">circular buffers</em>, come in handy.</p>

<p class="author1">A ring buffer is an implementation of a first-in-first-out (FIFO) queue, implemented using a pair of indices into an array of data in memory. Crucially, for efficiency, when data is inserted into the queue, it won’t ever move to another spot in memory. Instead, we move the indices around as data gets added to or removed from the queue. The array is treated as if one end is connected to the other, creating a ring of data. This means that if these indices are incremented past the end of the array, they’ll go back to the beginning.</p>

<p class="author1">An analog in the physical world is the restaurant order wheel, commonly found in North American diners. In restaurants using this kind of system, the wheel is usually placed in a part of the restaurant that divides the customer-facing area from the kitchen. Orders are taken from the customers on note papers, which are then inserted into the wheel in order. Then, on the kitchen side, the cooks can grab orders off the wheel in the same order so that food is cooked in the appropriate order, and no customer is left waiting too long for their food. This is a bounded<sup class="calibre39"><a data-type="noteref" id="idm45995913366808-marker" href="ch06.xhtml#idm45995913366808" class="calibre40">1</a></sup> FIFO queue, just like our ring buffers. Indeed, it’s also literally circular!</p>

<p class="author1">To implement a ring buffer, we’ll need <a data-type="indexterm" data-primary="streaming data" data-secondary="ring buffers and" data-tertiary="implementing" id="idm45995913364936" class="calibre6"/><a data-type="indexterm" data-primary="buffers" data-secondary="ring buffers" data-tertiary="implementing" id="idm45995913363688" class="calibre6"/><a data-type="indexterm" data-primary="ring buffers" data-secondary="implementing" id="idm45995913362472" class="calibre6"/><a data-type="indexterm" data-primary="head index" id="idm45995913361528" class="calibre6"/><a data-type="indexterm" data-primary="tail index" id="idm45995913360888" class="calibre6"/>the two indices, <code class="calibre18">head</code> and <code class="calibre18">tail</code>. The <code class="calibre18">head</code> index refers to the next position to add data into the queue, and the <code class="calibre18">tail</code> index refers to the next position to read data out of the queue from. When data is written to or read from the queue, we increase the <code class="calibre18">head</code> or <code class="calibre18">tail</code> index, respectively, by the amount of data written or read, modulo the size of the buffer.</p>

<p class="author1"><a data-type="xref" href="#fig_ring_buffer" class="calibre6">Figure 6-1</a> visualizes how a ring buffer works using a ring with a 16-byte buffer. The first diagram contains 4 bytes of data, starting at Byte 0 (where the tail is located) and ending at Byte 3 (with head one byte ahead at Byte 4). Once four bytes of data are added to the buffer, the head marker moves forward four bytes to Byte 8, shown in the second diagram. In the final diagram, the first four bytes have been read, so the tail moves to Byte 4.</p>

<figure class="calibre29"><div id="fig_ring_buffer" class="figure">
<img src="Images/mtjs_0601.png" alt="mtjs 0601" class="calibre68"/>
<h6 class="calibre30"><span class="keep-together">Figure 6-1. </span>Writing data moves the head forward, while reading data moves the tail 
<span class="keep-together">forward</span></h6>
</div></figure>

<p class="author1">Let’s make an implementation of a ring buffer. We’ll start off not worrying about threads, but to make our lives easier later on, we’ll store <code class="calibre18">head</code> and <code class="calibre18">tail</code> as well as the current <code class="calibre18">length</code> of the queue in a <code class="calibre18">TypedArray</code>. We could try just using the difference between <code class="calibre18">head</code> and <code class="calibre18">tail</code> as the length, but that leaves us with an ambiguous case, where we can’t tell if the queue is empty or full when the <code class="calibre18">head</code> and <code class="calibre18">tail</code> are the same value, so we’ll have a separate value for <code class="calibre18">length</code>. We’ll start by setting up the constructor and acessors, by adding the contents of <a data-type="xref" href="#ex_ch6_ringbuffer_1" class="calibre6">Example 6-13</a> to a file called <em class="calibre7">ch6-ring-buffer/ring-buffer.js</em>.</p>
<div id="ex_ch6_ringbuffer_1" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-13. </span><em class="calibre7">ch6-ring-buffer/ring-buffer.js</em> (part 1)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">class</code> <code class="nx">RingBuffer</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">(</code><code class="nx">meta</code><code class="c">/*: Uint32Array[3]*/</code><code class="p">,</code> <code class="nx">buffer</code> <code class="c">/*: Uint8Array */</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">meta</code> <code class="o">=</code> <code class="nx">meta</code><code class="p">;</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code> <code class="o">=</code> <code class="nx">buffer</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">get</code> <code class="nx">head</code><code class="p">()</code> <code class="p">{</code>
    <code class="kr">return</code> <code class="kr">this</code><code class="p">.</code><code class="nx">meta</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>
  <code class="p">}</code>

  <code class="nx">set</code> <code class="nx">head</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">meta</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="nx">n</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">get</code> <code class="nx">tail</code><code class="p">()</code> <code class="p">{</code>
    <code class="kr">return</code> <code class="kr">this</code><code class="p">.</code><code class="nx">meta</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>
  <code class="p">}</code>

  <code class="nx">set</code> <code class="nx">tail</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">meta</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">n</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">get</code> <code class="nx">length</code><code class="p">()</code> <code class="p">{</code>
    <code class="kr">return</code> <code class="kr">this</code><code class="p">.</code><code class="nx">meta</code><code class="p">[</code><code class="mi">2</code><code class="p">];</code>
  <code class="p">}</code>

  <code class="nx">set</code> <code class="nx">length</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">meta</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="nx">n</code><code class="p">;</code>
  <code class="p">}</code></pre></div>

<p class="author1">The constructor takes in a three-element <code class="calibre18">Uint32Array</code> called <code class="calibre18">meta</code>, which we’ll use for our <code class="calibre18">head</code>, <code class="calibre18">tail</code>, and <code class="calibre18">length</code>. For convenience, we’ve also added those properties as getters and setters, which internally just access those array elements. It also takes in a <code class="calibre18">Uint8Array</code> that will be the backing storage for our ring buffer. Next, we’ll add the <code class="calibre18">write()</code> method. Add the method as defined in <a data-type="xref" href="#ex_ch6_ringbuffer_2" class="calibre6">Example 6-14</a>.</p>
<div id="ex_ch6_ringbuffer_2" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-14. </span><em class="calibre7">ch6-ring-buffer/ring-buffer.js</em> (part 2)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="calibre18">  </code><code class="nx">write</code><code class="p">(</code><code class="nx">data</code><code class="calibre18"> </code><code class="c">/*: Uint8Array */</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO3-1" href="#callout_multithreaded_patterns_CO3-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
    </code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">bytesWritten</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">bytesWritten</code><code class="calibre18"> </code><code class="o">&gt;</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">length</code><code class="calibre18"> </code><code class="o">-</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO3-2" href="#callout_multithreaded_patterns_CO3-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
      </code><code class="nx">bytesWritten</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">length</code><code class="calibre18"> </code><code class="o">-</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code><code class="calibre18">
      </code><code class="nx">data</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">data</code><code class="p">.</code><code class="nx">subarray</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">bytesWritten</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">bytesWritten</code><code class="calibre18"> </code><code class="o">===</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">bytesWritten</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="calibre18">
      </code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="calibre18"> </code><code class="o">&gt;=</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="calibre18"> </code><code class="o">&amp;&amp;</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">length</code><code class="calibre18"> </code><code class="o">-</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="calibre18"> </code><code class="o">&gt;=</code><code class="calibre18"> </code><code class="nx">bytesWritten</code><code class="p">)</code><code class="calibre18"> </code><code class="o">||</code><code class="calibre18">
      </code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="calibre18"> </code><code class="o">&amp;&amp;</code><code class="calibre18"> </code><code class="nx">bytesWritten</code><code class="calibre18"> </code><code class="o">&lt;=</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="calibre18"> </code><code class="o">-</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="p">)</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO3-3" href="#callout_multithreaded_patterns_CO3-3"><img src="Images/3.png" alt="3" class="calibre32"/></a><code class="calibre18">
    </code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="c">// Enough space after the head. Just write it in and increase the head.
</code><code class="calibre18">      </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">data</code><code class="p">,</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="calibre18"> </code><code class="o">+=</code><code class="calibre18"> </code><code class="nx">bytesWritten</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18"> </code><code class="kr">else</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO3-4" href="#callout_multithreaded_patterns_CO3-4"><img src="Images/4.png" alt="4" class="calibre32"/></a><code class="calibre18">
      </code><code class="c">// We need to split the chunk into two.
</code><code class="calibre18">      </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">endSpaceAvailable</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">length</code><code class="calibre18"> </code><code class="o">-</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">endChunk</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">data</code><code class="p">.</code><code class="nx">subarray</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">endSpaceAvailable</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">beginChunk</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">data</code><code class="p">.</code><code class="nx">subarray</code><code class="p">(</code><code class="nx">endSpaceAvailable</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">endChunk</code><code class="p">,</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">beginChunk</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">beginChunk</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
    </code><code class="kr">this</code><code class="p">.</code><code class="nx">length</code><code class="calibre18"> </code><code class="o">+=</code><code class="calibre18"> </code><code class="nx">bytesWritten</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">bytesWritten</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO3-1" href="#co_multithreaded_patterns_CO3-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">In order for this code to work correctly, <code class="calibre18">data</code> needs to be an instance of the same <code class="calibre18">TypedArray</code> as <code class="calibre18">this.buffer</code>. This can be checked via static type checking, or with an assertion, or both.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO3-2" href="#co_multithreaded_patterns_CO3-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">If there’s not enough space in the buffer for all the data to be written, we’ll write as many bytes as we can to fill the buffer and return the number of bytes that were written. This notifies whoever is writing the data that they’ll need to wait for some of the data to be read out of it before continuing to write.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO3-3" href="#co_multithreaded_patterns_CO3-3"><img src="Images/3.png" alt="3" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">This conditional represents when we have enough <em class="calibre7">contiguous</em> space to write the data. This happens when either the head is after the tail in the array and the space after the head is bigger than the data to write, <em class="calibre7">or</em> when the head is before the tail and there’s enough space between the tail and the head. For either of these conditions, we can just write the data to the array and increase the head index by the length of the data.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO3-4" href="#co_multithreaded_patterns_CO3-4"><img src="Images/4.png" alt="4" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">On the other side of that <code class="calibre18">if</code> block, we need to write data until the end of the array and then wrap it around to write at the beginning of the array. This means splitting the data into a chunk to write at the end and a chunk to write at the beginning, and writing them accordingly. We’re using <code class="calibre18">subarray()</code> rather than <code class="calibre18">slice()</code> to chop up the data to avoid unnecessary secondary copy operations.</p></dd>
</dl></div>

<p class="author1">Writing turns out to be just a matter of copying the bytes over using <code class="calibre18">set()</code> and changing the <code class="calibre18">head</code> index appropriately, with a special case for when the data is split across the boundaries of the array. Reading is very similar, as shown in the <code class="calibre18">read()</code> method in <a data-type="xref" href="#ex_ch6_ringbuffer_3" class="calibre6">Example 6-15</a>.</p>
<div id="ex_ch6_ringbuffer_3" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-15. </span><em class="calibre7">ch6-ring-buffer/ring-buffer.js</em> (part 3)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="calibre18">  </code><code class="nx">read</code><code class="p">(</code><code class="nx">bytes</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">bytes</code><code class="calibre18"> </code><code class="o">&gt;</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO4-1" href="#callout_multithreaded_patterns_CO4-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
      </code><code class="nx">bytes</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">bytes</code><code class="calibre18"> </code><code class="o">===</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="kr">return</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Uint8Array</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
    </code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">readData</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="calibre18">
      </code><code class="kr">this</code><code class="p">.</code><code class="nx">head</code><code class="calibre18"> </code><code class="o">&gt;</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="calibre18"> </code><code class="o">||</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">length</code><code class="calibre18"> </code><code class="o">-</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="calibre18"> </code><code class="o">&gt;=</code><code class="calibre18"> </code><code class="nx">bytes</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO4-2" href="#callout_multithreaded_patterns_CO4-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
    </code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="c">// The data is in a contiguous chunk.
</code><code class="calibre18">      </code><code class="nx">readData</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">bytes</code><code class="p">)</code><code class="calibre18">
      </code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="calibre18"> </code><code class="o">+=</code><code class="calibre18"> </code><code class="nx">bytes</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18"> </code><code class="kr">else</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO4-3" href="#callout_multithreaded_patterns_CO4-3"><img src="Images/3.png" alt="3" class="calibre32"/></a><code class="calibre18">
      </code><code class="c">// Read from the end and the beginning.
</code><code class="calibre18">      </code><code class="nx">readData</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Uint8Array</code><code class="p">(</code><code class="nx">bytes</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">endBytesToRead</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">length</code><code class="calibre18"> </code><code class="o">-</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="p">;</code><code class="calibre18">
      </code><code class="nx">readData</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">subarray</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="p">,</code><code class="calibre18"> </code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="nx">readData</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">buffer</code><code class="p">.</code><code class="nx">subarray</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">bytes</code><code class="calibre18"> </code><code class="o">-</code><code class="calibre18"> </code><code class="nx">endBytesToRead</code><code class="p">)</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">endBytesToRead</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">this</code><code class="p">.</code><code class="nx">tail</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">bytes</code><code class="calibre18"> </code><code class="o">-</code><code class="calibre18"> </code><code class="nx">endBytesToRead</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
    </code><code class="kr">this</code><code class="p">.</code><code class="nx">length</code><code class="calibre18"> </code><code class="o">-=</code><code class="calibre18"> </code><code class="nx">bytes</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">readData</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code><code class="calibre18">
</code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO4-1" href="#co_multithreaded_patterns_CO4-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The input to <code class="calibre18">read()</code> is the number of bytes <em class="calibre7">requested</em>. If there aren’t enough bytes in the queue, it will instead return all the bytes currently in the queue.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO4-2" href="#co_multithreaded_patterns_CO4-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">If the requested data is in a contiguous chunk reading from the <code class="calibre18">tail</code>, we’ll just give that directly to the caller using <code class="calibre18">slice()</code> to get a copy of those bytes. We’ll move the tail to the end of the returned bytes.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO4-3" href="#co_multithreaded_patterns_CO4-3"><img src="Images/3.png" alt="3" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">In the <code class="calibre18">else</code> case, the data is split across the boundaries of the array, so we need to get both chunks and stitch them together in reverse order. To do that, we’ll allocate a big enough <code class="calibre18">Uint8Array</code>, then copy the data from the beginning and end of the array. The new tail is set to the end of the chunk at the beginning of the array.</p></dd>
</dl></div>

<p class="author1">When reading bytes out of the queue, it’s important to <em class="calibre7">copy</em> them out, rather than just refer to the same memory. If we don’t, then other data written to the queue might end up in these arrays at some time in the future, which is something we don’t want. That’s why we use <code class="calibre18">slice()</code> or a new <code class="calibre18">Uint8Array</code> for the returned data.</p>

<p class="author1">At this point, we have a <a data-type="indexterm" data-primary="streaming data" data-secondary="ring buffers and" data-tertiary="single-threaded bounded queue" id="idm45995912748968" class="calibre6"/><a data-type="indexterm" data-primary="buffers" data-secondary="ring buffers" data-tertiary="single-threaded bounded queue" id="idm45995912747864" class="calibre6"/><a data-type="indexterm" data-primary="ring buffers" data-secondary="single-threaded bounded queue" id="idm45995912978440" class="calibre6"/>working single-threaded bounded queue, implemented as a ring buffer. If we wanted to use it with one thread writing (the <em class="calibre7">producer</em>) and one thread reading (the <em class="calibre7">consumer</em>), we could use a <code class="calibre18">SharedArrayBuffer</code> as the backing storage for the inputs to constructor, pass that to another thread, and instantiate it there as well. Unfortunately, we haven’t yet used any atomic operations or identified and isolated critical sections using locks, so if multiple threads use the buffer, we can end up with race conditions and bad data. We’ll need to rectify this.</p>

<p class="author1">The read and write operations assume that none of the <code class="calibre18">head</code>, <code class="calibre18">tail</code>, or <code class="calibre18">length</code> are going to change by other threads throughout the operation. We may be able to get more specific than that later on, but being this general to start will at least give us the thread safety we need to avoid race conditions. We can use the <code class="calibre18">Mutex</code> class from <a data-type="xref" href="#ch_patterns_sec_basiclock" class="calibre6">“Mutex: A Basic Lock”</a> to identify critical sections and make sure they’re only executed one at a time.</p>

<p class="author1">Let’s require the <code class="calibre18">Mutex</code> class and add the wrapper class in <a data-type="xref" href="#ex_ch6_ringbuffer_4" class="calibre6">Example 6-16</a> to the file that will make use of our existing <code class="calibre18">RingBuffer</code> class.</p>
<div id="ex_ch6_ringbuffer_4" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-16. </span><em class="calibre7">ch6-ring-buffer/ring-buffer.js</em> (part 4)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code> <code class="nx">Mutex</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'../ch6-mutex/mutex.js'</code><code class="p">);</code>

<code class="kr">class</code> <code class="nx">SharedRingBuffer</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">(</code><code class="nx">shared</code><code class="c">/*: number | SharedArrayBuffer*/</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">shared</code> <code class="o">=</code> <code class="kr">typeof</code> <code class="nx">shared</code> <code class="o">===</code> <code class="s">'number'</code> <code class="o">?</code>
      <code class="kr">new</code> <code class="nx">SharedArrayBuffer</code><code class="p">(</code><code class="nx">shared</code> <code class="o">+</code> <code class="mi">16</code><code class="p">)</code> <code class="o">:</code> <code class="nx">shared</code><code class="p">;</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">ringBuffer</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">RingBuffer</code><code class="p">(</code>
      <code class="kr">new</code> <code class="nx">Uint32Array</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">shared</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code>
      <code class="kr">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">shared</code><code class="p">,</code> <code class="mi">16</code><code class="p">)</code>
    <code class="p">);</code>
    <code class="kr">this</code><code class="p">.</code><code class="nx">lock</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Mutex</code><code class="p">(</code><code class="kr">new</code> <code class="nx">Int32Array</code><code class="p">(</code><code class="kr">this</code><code class="p">.</code><code class="nx">shared</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">));</code>
  <code class="p">}</code>

  <code class="nx">write</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">return</code> <code class="kr">this</code><code class="p">.</code><code class="nx">lock</code><code class="p">.</code><code class="nx">exec</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="kr">this</code><code class="p">.</code><code class="nx">ringBuffer</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">data</code><code class="p">));</code>
  <code class="p">}</code>

  <code class="nx">read</code><code class="p">(</code><code class="nx">bytes</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">return</code> <code class="kr">this</code><code class="p">.</code><code class="nx">lock</code><code class="p">.</code><code class="nx">exec</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="kr">this</code><code class="p">.</code><code class="nx">ringBuffer</code><code class="p">.</code><code class="nx">read</code><code class="p">(</code><code class="nx">bytes</code><code class="p">));</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>

<p class="author1">To start it off, the constructor accepts or creates the <code class="calibre18">SharedArrayBuffer</code>. Notice that we add 16 bytes to the size of the buffer to handle both the <code class="calibre18">Mutex</code>, which needs a one-element <code class="calibre18">Int32Array</code>, and the <code class="calibre18">RingBuffer</code> metadata, which needs a three-element <code class="calibre18">Uint32Array</code>. We’ll lay out the memory as in <a data-type="xref" href="#table_ringbuffer_mem" class="calibre6">Table 6-2</a>.</p>
<table id="table_ringbuffer_mem" class="calibre46">
<caption class="calibre47"><span class="keep-together">Table 6-2. </span>SharedRingBuffer memory layout</caption>
<thead class="calibre48">
<tr class="calibre49">
<th class="calibre50">Data</th>
<th class="calibre50">Type[Size]</th>
<th class="calibre50">SharedArrayBuffer Index</th>
</tr>
</thead>
<tbody class="calibre51">
<tr class="calibre49">
<td class="calibre52"><p class="author1">Mutex</p></td>
<td class="calibre52"><p class="author1">Int32Array[1]</p></td>
<td class="calibre52"><p class="author1">0</p></td>
</tr>
<tr class="calibre53">
<td class="calibre52"><p class="author1">RingBuffer meta</p></td>
<td class="calibre52"><p class="author1">Uint32Array[3]</p></td>
<td class="calibre52"><p class="author1">4</p></td>
</tr>
<tr class="calibre49">
<td class="calibre52"><p class="author1">RingBuffer buffer</p></td>
<td class="calibre52"><p class="author1">Uint32Array[size]</p></td>
<td class="calibre52"><p class="author1">16</p></td>
</tr>
</tbody>
</table>

<p class="author1">The <code class="calibre18">read()</code> and <code class="calibre18">write()</code> operations are wrapped with the <code class="calibre18">exec()</code> method from the <code class="calibre18">Mutex</code>. Recall that this prevents <a data-type="indexterm" data-primary="mutex (Linux)" data-secondary="exec() method" id="idm45995912401192" class="calibre6"/>any other critical sections protected by the same mutex from running at the same time. By wrapping them, we ensure that even if we have multiple threads both reading from and writing to the same queue, we won’t have any race conditions from <code class="calibre18">head</code> or <code class="calibre18">tail</code> being modified externally in the middle of these critical sections.</p>

<p class="author1">To see this data structure in action, let’s create some <em class="calibre7">producer</em> and <em class="calibre7">consumer</em> threads. We’ll set up a <code class="calibre18">SharedRingBuffer</code> with 100 bytes to work with. The producer threads will write the string <code class="calibre18">"Hello, World!\n"</code> to the <code class="calibre18">SharedRingBuffer</code>, repeatedly, as fast as they can acquire the lock. The consumer threads will attempt to read 20 bytes at a time, and we’ll log how many bytes they were able to read. The code to get this done is all in <a data-type="xref" href="#ex_ch6_ringbuffer_5" class="calibre6">Example 6-17</a>, which you can add to the end of <em class="calibre7">ch6-ring-buffer/ring-buffer.js</em>.</p>
<div id="ex_ch6_ringbuffer_5" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-17. </span><em class="calibre7">ch6-ring-buffer/ring-buffer.js</em> (part 5)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">isMainThread</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">require</code><code class="p">(</code><code class="s">'worker_threads'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">fs</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">require</code><code class="p">(</code><code class="s">'fs'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">

</code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">isMainThread</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">shared</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">SharedArrayBuffer</code><code class="p">(</code><code class="mi">116</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">threads</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="p">[</code><code class="calibre18">
    </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">(</code><code class="nx">__filename</code><code class="p">,</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="o">:</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">shared</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">isProducer</code><code class="o">:</code><code class="calibre18"> </code><code class="kr">true</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="p">,</code><code class="calibre18">
    </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">(</code><code class="nx">__filename</code><code class="p">,</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="o">:</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">shared</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">isProducer</code><code class="o">:</code><code class="calibre18"> </code><code class="kr">true</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="p">,</code><code class="calibre18">
    </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">(</code><code class="nx">__filename</code><code class="p">,</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="o">:</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">shared</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">isProducer</code><code class="o">:</code><code class="calibre18"> </code><code class="kr">false</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="p">,</code><code class="calibre18">
    </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">(</code><code class="nx">__filename</code><code class="p">,</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="o">:</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">shared</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">isProducer</code><code class="o">:</code><code class="calibre18"> </code><code class="kr">false</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="p">}</code><code class="p">)</code><code class="calibre18">
  </code><code class="p">]</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="calibre18"> </code><code class="kr">else</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">shared</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">isProducer</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">workerData</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">ringBuffer</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">SharedRingBuffer</code><code class="p">(</code><code class="nx">shared</code><code class="p">)</code><code class="p">;</code><code class="calibre18">

  </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">isProducer</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">buffer</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">Buffer</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="s">'Hello, World!\n'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">while</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">true</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="nx">ringBuffer</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">buffer</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
  </code><code class="p">}</code><code class="calibre18"> </code><code class="kr">else</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">while</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">true</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">readBytes</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">ringBuffer</code><code class="p">.</code><code class="nx">read</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="nx">fs</code><code class="p">.</code><code class="nx">writeSync</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="calibre18"> </code><code class="s">`</code><code class="s">Read </code><code class="si">${</code><code class="nx">readBytes</code><code class="p">.</code><code class="nx">length</code><code class="si">}</code><code class="s"> bytes</code><code class="si">\</code><code class="s">n</code><code class="s">`</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO5-1" href="#callout_multithreaded_patterns_CO5-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
  </code><code class="p">}</code><code class="calibre18">
</code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO5-1" href="#co_multithreaded_patterns_CO5-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">You might notice that we’re not using <code class="calibre18">console.log()</code> to write our byte counts to <code class="calibre18">stdout</code> and instead using a synchronous write to the file descriptor corresponding to <code class="calibre18">stdout</code>. This is because we’re using an infinite loop without any <code class="calibre18">await</code> inside. We’re starving the Node.js event loop, so with <code class="calibre18">console.log</code> or any other asynchronous logger, we’d never actually see any output.</p></dd>
</dl></div>

<p class="author1">You can run this example with Node.js as follows:</p>

<pre data-type="programlisting" class="calibre38">$ node ring-buffer.js</pre>

<p class="author1">The output produced by this script will show the number of bytes read in each iteration in each consumer thread. Because we’re asking for 20 bytes each time, you’ll see that as the maximum number read. You’ll see all zeros sometimes when the queue is empty. You’ll see other numbers when the queue is partially full.</p>

<p class="author1">A number of things can be tweaked in our example. The size of the <code class="calibre18">SharedRingBuffer</code>, the number of producer and consumer threads, the size of the written message, and the number of bytes being attempted to be read all contribute to the throughput of data. As with anything else, it’s always worth measuring and tweaking the values to find the optimal state for your application. Go ahead and try tweaking some of these in the example code and see how the output changes.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre54"><div class="sidebar" id="idm45995912097416">
<h5 class="calibre55">Lock-Free Queues</h5>
<p class="author1">Our implementation of a ring buffer may be functionally sound, but it isn’t the most efficient. In order to perform <em class="calibre7">any</em> operation on the data, all other threads are blocked from accessing the data. While this may be the simplest approach, solutions without using locks do exist, which instead take advantage of carefully used atomic operations for synchronization. The trade-off here is complexity.</p>
</div></aside>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Actor Model" class="calibre4"><div class="preface" id="ch_patterns_sec_actors">
<h1 class="calibre13">Actor Model</h1>

<p class="author1">The <em class="calibre7">actor model</em> is a programming <a data-type="indexterm" data-primary="actor models" id="idm45995912093224" class="calibre6"/>pattern for performing concurrent computation that was first devised in the 1970s. With this model an <em class="calibre7">actor</em> is a primitive container that allows for executing code. An actor is capable of running logic, creating more actors, sending messages to other actors, and receiving messages.</p>

<p class="author1">These actors communicate with the outside world by way of message passing; otherwise, they have their own isolated access to memory. An actor is a first-class citizen in the Erlang <a data-type="indexterm" data-primary="Erlang" id="idm45995912091064" class="calibre6"/>programming language,<sup class="calibre39"><a data-type="noteref" id="idm45995912090232-marker" href="ch06.xhtml#idm45995912090232" class="calibre40">2</a></sup> but it can certainly be emulated using JavaScript.</p>

<p class="author1">The actor model is designed to allow computations to run in a highly parallelized manner without necessarily having to worry about where the code is running or even the protocol used to implement the communication. Really, it should be transparent to program code whether one actor communicates with another actor locally or remotely. <a data-type="xref" href="#fig_actor_model" class="calibre6">Figure 6-2</a> shows how actors can be spread out across processes and machines.</p>

<figure class="calibre29"><div id="fig_actor_model" class="figure">
<img src="Images/mtjs_0602.png" alt="mtjs 0602" class="calibre69"/>
<h6 class="calibre30"><span class="keep-together">Figure 6-2. </span>Actors can be spread across processes and machines</h6>
</div></figure>








<section data-type="sect2" data-pdf-bookmark="Pattern Nuances" class="calibre4"><div class="preface" id="idm45995912085912">
<h2 class="calibre37">Pattern Nuances</h2>

<p class="author1">Actors are able to process each message, or task, that they receive one at a time. When these messages are <a data-type="indexterm" data-primary="patterns" data-secondary="actor models" id="pattact" class="calibre6"/><a data-type="indexterm" data-primary="actor models" data-secondary="patterns" id="idm45995912082968" class="calibre6"/>first received, they sit in a message queue, sometimes referred to as a mailbox. Having a queue is convenient because if two messages were received at once then they both shouldn’t be processed at the same time. Without a queue, one actor might need to check if another actor is ready before sending a message, which would be a very tedious process.</p>

<p class="author1">Although no two actors are able to write to the same piece of shared memory, they are free to mutate their own memory. This includes maintaining state modifications over time. For example, an actor could keep track of the number of messages that it has processed, and then deliver that data in messages that it later outputs.</p>

<p class="author1">Because there’s no shared memory involved, the actor model is able to avoid some of the multithreading pitfalls discussed earlier, such as race conditions and deadlocks. In many ways, an actor is like a function in a functional language, accepting inputs and avoiding access to global state.</p>

<p class="author1">Since actors handle a single task at a time they can often be implemented in a single-threaded fashion. And, while a single actor is only able to process a single task at a time, different actors are free to run code in parallel.</p>

<p class="author1">A system that uses actors shouldn’t expect that messages are guaranteed to be ordered on a FIFO basis. Instead, it should be resilient to delays and out-of-order delivery, especially since actors can be spread across a network.</p>

<p class="author1">Individual actors can also have the concept of an address, which is a way to uniquely refer to a single actor. One way to represent this value could be to use a URI. 
<span class="keep-together">For example</span>, <code class="calibre18">tcp://127.0.0.1:1234/3</code> might refer to the third actor running in a 
<span class="keep-together">program</span> on the local computer listening on port 1234. The implementation covered here doesn’t use such addresses.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Relating to JavaScript" class="calibre4"><div class="preface" id="idm45995912076104">
<h2 class="calibre37">Relating to JavaScript</h2>

<p class="author1">The actors that exist as first-class <a data-type="indexterm" data-primary="actor models" data-secondary="JavaScript and" id="idm45995912074696" class="calibre6"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="actor models and" id="idm45995912073720" class="calibre6"/>citizens in languages such as Erlang can’t be perfectly reproduced using JavaScript, but we can certainly try. There are likely dozens of ways to draw parallels and implement actors, and this section exposes you to one of them.</p>

<p class="author1">One draw of the actor model is that actors don’t need to be limited to a single machine. This means that processes can run on more than one machine and communicate over the network. We can implement this using Node.js processes, each communicating using JSON via the TCP protocol.</p>

<p class="author1">Because individual actors should be able to run code in parallel with other actors, and each actor processes only a single task at a time, it then stands to reason that actors should probably run on different threads to maximize system usage. One way to go about this is to instantiate new worker threads. Another way would be to have dedicated processes for each actor, but that would use more resources.</p>

<p class="author1">Because there is no need to deal with shared memory between the different actors, the <code class="calibre18">SharedArrayBuffer</code> and <code class="calibre18">Atomics</code> objects can be largely ignored (though a more robust system might rely on them for coordination purposes).</p>

<p class="author1">Actors require a message queue so that while one message is being processed another message can wait until the actor is ready. JavaScript workers sort of handle this for us using the <code class="calibre18">postMessage()</code> method. Messages delivered in this manner wait until the current JavaScript stack is complete before grabbing the next message. If each actor is only running synchronous code, then this built-in queue can be used. On the other hand, if actors can perform asynchronous work, then a manual queue will need to be built instead.</p>

<p class="author1">So far the actor model might sound familiar to the thread pool pattern covered in <a data-type="xref" href="#ch_patterns_sec_threadpool" class="calibre6">“Thread Pool”</a>. Indeed, there are a lot of similarities, and you can almost think of the actor model as a pool of thread pools. But there are enough differences that the two concepts are worth differentiating. Really, the actor model promises a unique paradigm for computing, truly a high-level programming pattern that can change the way you approach writing code. In practice, the actor model involves programs that often depend on thread pools.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Example Implementation" class="calibre4"><div class="preface" id="idm45995912066056">
<h2 class="calibre37">Example Implementation</h2>

<p class="author1">Create a new directory named <em class="calibre7">ch6-actors/</em> for this <a data-type="indexterm" data-primary="actor models" data-secondary="example implementation" id="actimp" class="calibre6"/>implementation. Inside this directory, copy and paste the existing <em class="calibre7">ch6-thread-pool/rpc-worker.js</em> file from <a data-type="xref" href="#ex_threadpool_rpcworker_1" class="calibre6">Example 6-3</a> and the <em class="calibre7">ch6-thread-pool/worker.js</em> file from <a data-type="xref" href="#ex_threadpool_worker" class="calibre6">Example 6-2</a>. Those files will be used as the basis of the thread pool in this example and can remain unchanged.</p>

<p class="author1">Next, create a file named <em class="calibre7">ch6-actors/server.js</em> and add the content from <a data-type="xref" href="#ex_actor_server_1" class="calibre6">Example 6-18</a> to it.</p>
<div id="ex_actor_server_1" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-18. </span><em class="calibre7">ch6-actors/server.js</em> (part 1)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="calibre18">#!/usr/bin/env node</code>

<code class="kr">const</code> <code class="nx">http</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'http'</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">net</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'net'</code><code class="p">);</code>

<code class="kr">const</code> <code class="p">[,,</code> <code class="nx">web_host</code><code class="p">,</code> <code class="nx">actor_host</code><code class="p">]</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">;</code>
<code class="kr">const</code> <code class="p">[</code><code class="nx">web_hostname</code><code class="p">,</code> <code class="nx">web_port</code><code class="p">]</code> <code class="o">=</code> <code class="nx">web_host</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">':'</code><code class="p">);</code>
<code class="kr">const</code> <code class="p">[</code><code class="nx">actor_hostname</code><code class="p">,</code> <code class="nx">actor_port</code><code class="p">]</code> <code class="o">=</code> <code class="nx">actor_host</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">':'</code><code class="p">);</code>

<code class="kr">let</code> <code class="nx">message_id</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="kr">let</code> <code class="nx">actors</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Set</code><code class="p">();</code> <code class="c">// collection of actor handlers</code>
<code class="kr">let</code> <code class="nx">messages</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Map</code><code class="p">();</code> <code class="c">// message ID -&gt; HTTP response</code></pre></div>

<p class="author1">This file creates two server instances. The first is a TCP server, a rather basic protocol, while the second is an HTTP server, which is a higher-level protocol based on TCP, though the two server instances won’t depend on each other. The first part of this file contains boilerplate for accepting command-line arguments to configure the two servers.</p>

<p class="author1">The <code class="calibre18">message_id</code> variable contains a <a data-type="indexterm" data-primary="actor models" data-secondary="message_id variable" id="idm45995912340600" class="calibre6"/>number that will increment as each new HTTP request is made. The <code class="calibre18">messages</code> variable contains a mapping of message IDs to response handlers that will be used to reply to the messages. This is the same pattern that you used in <a data-type="xref" href="#ch_patterns_sec_threadpool" class="calibre6">“Thread Pool”</a>. Finally, the <code class="calibre18">actors</code> variable <a data-type="indexterm" data-primary="actor models" data-secondary="actors variable" id="idm45995912337800" class="calibre6"/>contains a collection of handler functions that are used to send messages to external actor 
<span class="keep-together">processes</span>.</p>

<p class="author1">Next, add the content from <a data-type="xref" href="#ex_actor_server_2" class="calibre6">Example 6-19</a> to the file.</p>
<div id="ex_actor_server_2" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-19. </span><em class="calibre7">ch6-actors/server.js</em> (part 2)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="nx">net</code><code class="p">.</code><code class="nx">createServer</code><code class="p">(</code><code class="p">(</code><code class="nx">client</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">handler</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">data</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="nx">client</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code><code class="calibre18"> </code><code class="o">+</code><code class="calibre18"> </code><code class="s">'\0'</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO6-1" href="#callout_multithreaded_patterns_CO6-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="nx">actors</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">handler</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'actor pool connected'</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">actors</code><code class="p">.</code><code class="nx">size</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">client</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'end'</code><code class="p">,</code><code class="calibre18"> </code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="nx">actors</code><code class="p">.</code><code class="kr">delete</code><code class="p">(</code><code class="nx">handler</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO6-2" href="#callout_multithreaded_patterns_CO6-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'actor pool disconnected'</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">actors</code><code class="p">.</code><code class="nx">size</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code><code class="p">)</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'data'</code><code class="p">,</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">raw_data</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">chunks</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nb">String</code><code class="p">(</code><code class="nx">raw_data</code><code class="p">)</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">'\0'</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO6-3" href="#callout_multithreaded_patterns_CO6-3"><img src="Images/3.png" alt="3" class="calibre32"/></a><code class="calibre18">
    </code><code class="nx">chunks</code><code class="p">.</code><code class="nx">pop</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO6-4" href="#callout_multithreaded_patterns_CO6-4"><img src="Images/4.png" alt="4" class="calibre32"/></a><code class="calibre18">
    </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">chunk</code><code class="calibre18"> </code><code class="kr">of</code><code class="calibre18"> </code><code class="nx">chunks</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">data</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">chunk</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">res</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">messages</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="nx">res</code><code class="p">.</code><code class="nx">end</code><code class="p">(</code><code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code><code class="calibre18"> </code><code class="o">+</code><code class="calibre18"> </code><code class="s">'\0'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="nx">messages</code><code class="p">.</code><code class="kr">delete</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
  </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="p">)</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="nx">actor_port</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">actor_hostname</code><code class="p">,</code><code class="calibre18"> </code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">`</code><code class="s">actor: tcp://</code><code class="si">${</code><code class="nx">actor_hostname</code><code class="si">}</code><code class="s">:</code><code class="si">${</code><code class="nx">actor_port</code><code class="si">}</code><code class="s">`</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO6-1" href="#co_multithreaded_patterns_CO6-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">A null byte <code class="calibre18">'\0'</code> is inserted between messages.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO6-2" href="#co_multithreaded_patterns_CO6-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">When a client connection is closed, it is removed from the <code class="calibre18">actors</code> set.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO6-3" href="#co_multithreaded_patterns_CO6-3"><img src="Images/3.png" alt="3" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The <code class="calibre18">data</code> events may contain multiple messages and are split on null bytes.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO6-4" href="#co_multithreaded_patterns_CO6-4"><img src="Images/4.png" alt="4" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The final byte is a null byte, so the last entry in <code class="calibre18">chunks</code> is an empty string.</p></dd>
</dl></div>

<p class="author1">This file creates the TCP server. This is how dedicated actor processes will connect to the main <a data-type="indexterm" data-primary="actor models" data-secondary="main server process" id="idm45995911480424" class="calibre6"/>server process. The <code class="calibre18">net.createServer()</code> callback is called <a data-type="indexterm" data-primary="actor models" data-secondary="client argument" id="idm45995911478904" class="calibre6"/>each time an actor process connects. The <code class="calibre18">client</code> argument represents a TCP client, essentially a connection to the actor process. A message is logged each time a connection is made, and a handler function for conveniently messaging the actor is added to the <code class="calibre18">actors</code> collection.</p>

<p class="author1">When a client disconnects from the server, that client’s handler function is deleted from the <code class="calibre18">actors</code> collection. Actors communicate with the server by sending messages over TCP, which triggers the <code class="calibre18">data</code> event.<sup class="calibre39"><a data-type="noteref" id="idm45995911475144-marker" href="ch06.xhtml#idm45995911475144" class="calibre40">3</a></sup> The messages they send are JSON-encoded data. This data contains an <code class="calibre18">id</code> field which correlates to the message ID. When the callback is run, the correlating handler function is retrieved from the <code class="calibre18">messages</code> map. Finally, the response message is sent back to the HTTP request, the message is removed from the <code class="calibre18">messages</code> map, and the server listens on the specified interface and port.</p>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="author1">The connection between the server and the actor pool client is a long-lived connection. That is why event handlers are set up for things like the <code class="calibre18">data</code> and <code class="calibre18">end</code> events.</p>
</div>

<p class="author1">Notably missing from this file is an error handler for the client connection. Since it’s missing, a connection error will cause the server process to terminate. A more robust solution would delete the client from the <code class="calibre18">actors</code> collection.</p>

<p class="author1">The <code class="calibre18">'\0'</code> null bytes are inserted between messages because when one side emits a message it’s not guaranteed to arrive in a single <code class="calibre18">data</code> event on the other side. Notably, when multiple messages are sent in quick succession, they will arrive in a single <code class="calibre18">data</code> event. This is a bug you won’t encounter while making single requests with <code class="calibre18">curl</code>, but that you would encounter when making many requests with <code class="calibre18">autocannon</code>. This results in multiple JSON documents concatenated together, like so: <code class="calibre18">{"id":1…}{"id":2…}</code>. Passing that value into <code class="calibre18">JSON.parse()</code> results in an error. The null bytes cause the events to resemble this: <code class="calibre18">{"id":1…}\0{"id":2…}\0</code>. The string is then split on the null byte and each segment is parsed separately. If a null byte were to appear in a JSON object, it would be escaped, meaning it’s safe to use a null byte to separate JSON documents.</p>

<p class="author1">Next, add the content from <a data-type="xref" href="#ex_actor_server_3" class="calibre6">Example 6-20</a> to the file.</p>
<div id="ex_actor_server_3" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-20. </span><em class="calibre7">ch6-actors/server.js</em> (part 3)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="nx">http</code><code class="p">.</code><code class="nx">createServer</code><code class="p">(</code><code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">message_id</code><code class="o">++</code><code class="p">;</code>
  <code class="kr">if</code> <code class="p">(</code><code class="nx">actors</code><code class="p">.</code><code class="nx">size</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="kr">return</code> <code class="nx">res</code><code class="p">.</code><code class="nx">end</code><code class="p">(</code><code class="s">'ERROR: EMPTY ACTOR POOL'</code><code class="p">);</code>
  <code class="kr">const</code> <code class="nx">actor</code> <code class="o">=</code> <code class="nx">randomActor</code><code class="p">();</code>
  <code class="nx">messages</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">message_id</code><code class="p">,</code> <code class="nx">res</code><code class="p">);</code>
  <code class="nx">actor</code><code class="p">({</code>
    <code class="nx">id</code><code class="o">:</code> <code class="nx">message_id</code><code class="p">,</code>
    <code class="nx">method</code><code class="o">:</code> <code class="s">'square_sum'</code><code class="p">,</code>
    <code class="nx">args</code><code class="o">:</code> <code class="p">[</code><code class="nb">Number</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">url</code><code class="p">.</code><code class="nx">substr</code><code class="p">(</code><code class="mi">1</code><code class="p">))]</code>
  <code class="p">});</code>
<code class="p">}).</code><code class="nx">listen</code><code class="p">(</code><code class="nx">web_port</code><code class="p">,</code> <code class="nx">web_hostname</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">`web:   http://</code><code class="si">${</code><code class="nx">web_hostname</code><code class="si">}</code><code class="s">:</code><code class="si">${</code><code class="nx">web_port</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
<code class="p">});</code></pre></div>

<p class="author1">This part of the file creates an HTTP server. Unlike the TCP server, each request represents a short-lived connection. The <code class="calibre18">http.createServer()</code> callback is called once for each HTTP request that is received.</p>

<p class="author1">Inside this callback the current message ID is incremented and the list of actors is consulted. If it’s empty, which can happen when the server starts but an actor hasn’t joined, an error message “ERROR: EMPTY ACTOR POOL” is returned. Otherwise, if actors are present, a random one is then chosen. This isn’t the best approach, though — a more robust solution is discussed at the end of this section.</p>

<p class="author1">Next, a JSON message is sent to the actor. The message contains an <code class="calibre18">id</code> field which represents the message ID, a <code class="calibre18">method</code> field which represents the function to be called (always <code class="calibre18">square_sum</code> in this case), and finally the list of arguments. In this case the HTTP request path contains a slash and a number, like <em class="calibre7">/42</em>, and the number is extracted to be used as the argument. Finally, the server listens on the provided interface and port.</p>

<p class="author1">Next, add the content from <a data-type="xref" href="#ex_actor_server_4" class="calibre6">Example 6-21</a> to the file.</p>
<div id="ex_actor_server_4" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-21. </span><em class="calibre7">ch6-actors/server.js</em> (part 4)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">function</code> <code class="nx">randomActor</code><code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">pool</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">actors</code><code class="p">);</code>
  <code class="kr">return</code> <code class="nx">pool</code><code class="p">[</code><code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="nx">pool</code><code class="p">.</code><code class="nx">length</code><code class="p">)];</code>
<code class="p">}</code></pre></div>

<p class="author1">This part of the file just grabs a random actor handler from the <code class="calibre18">actors</code> list.</p>

<p class="author1">With this file complete (for now), create a new file named <em class="calibre7">ch6-actors/actor.js</em>. This file represents a process that doesn’t provide a server, but instead will connect to the other server process. Start the file off by adding the content from <a data-type="xref" href="#ex_actor_actor_1" class="calibre6">Example 6-22</a> to it.</p>
<div id="ex_actor_actor_1" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-22. </span><em class="calibre7">ch6-actors/actor.js</em> (part 1)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="calibre18">#!/usr/bin/env node</code>

<code class="kr">const</code> <code class="nx">net</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'net'</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">RpcWorkerPool</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'./rpc-worker.js'</code><code class="p">);</code>

<code class="kr">const</code> <code class="p">[,,</code> <code class="nx">host</code><code class="p">]</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">;</code>
<code class="kr">const</code> <code class="p">[</code><code class="nx">hostname</code><code class="p">,</code> <code class="nx">port</code><code class="p">]</code> <code class="o">=</code> <code class="nx">host</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">':'</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">worker</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">RpcWorkerPool</code><code class="p">(</code><code class="s">'./worker.js'</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="s">'leastbusy'</code><code class="p">);</code></pre></div>

<p class="author1">Again, this file starts off with some boilerplate to extract the hostname and port information for the server <a data-type="indexterm" data-primary="RpcWorkerPool class" id="idm45995911527112" class="calibre6"/><a data-type="indexterm" data-primary="classes" data-secondary="RpcWorkerPool" id="idm45995911619768" class="calibre6"/>process. It also initializes a thread pool using the <code class="calibre18">RpcWorkerPool</code> class. The pool has a strict size of four threads, which can be thought of as four actors, and uses the <code class="calibre18">leastbusy</code> algorithm.</p>

<p class="author1">Next, add the content from <a data-type="xref" href="#ex_actor_actor_2" class="calibre6">Example 6-23</a> to the file.</p>
<div id="ex_actor_actor_2" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-23. </span><em class="calibre7">ch6-actors/actor.js</em> (part 2)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code><code class="calibre18"> </code><code class="nx">upstream</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">net</code><code class="p">.</code><code class="nx">connect</code><code class="p">(</code><code class="nx">port</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">hostname</code><code class="p">,</code><code class="calibre18"> </code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'connected to server'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="p">)</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'data'</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">async</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">raw_data</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">chunks</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nb">String</code><code class="p">(</code><code class="nx">raw_data</code><code class="p">)</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">'\0'</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_multithreaded_patterns_CO7-1" href="#callout_multithreaded_patterns_CO7-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="nx">chunks</code><code class="p">.</code><code class="nx">pop</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">chunk</code><code class="calibre18"> </code><code class="kr">of</code><code class="calibre18"> </code><code class="nx">chunks</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">data</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">chunk</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">value</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">await</code><code class="calibre18"> </code><code class="nx">worker</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">method</code><code class="p">,</code><code class="calibre18"> </code><code class="p">...</code><code class="nx">data</code><code class="p">.</code><code class="nx">args</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="nx">upstream</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="p">{</code><code class="calibre18">
      </code><code class="nx">id</code><code class="o">:</code><code class="calibre18"> </code><code class="nx">data</code><code class="p">.</code><code class="nx">id</code><code class="p">,</code><code class="calibre18">
      </code><code class="nx">value</code><code class="p">,</code><code class="calibre18">
      </code><code class="nx">pid</code><code class="o">:</code><code class="calibre18"> </code><code class="nx">process</code><code class="p">.</code><code class="nx">pid</code><code class="calibre18">
    </code><code class="p">}</code><code class="p">)</code><code class="calibre18"> </code><code class="o">+</code><code class="calibre18"> </code><code class="s">'\0'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code><code class="calibre18">
</code><code class="p">}</code><code class="p">)</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'end'</code><code class="p">,</code><code class="calibre18"> </code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'disconnect from server'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_multithreaded_patterns_CO7-1" href="#co_multithreaded_patterns_CO7-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The actor also needs to handle null byte chunk separation.</p></dd>
</dl></div>

<p class="author1">The <code class="calibre18">net.connect()</code> method creates a <a data-type="indexterm" data-primary="net.connect() method" id="idm45995912187576" class="calibre6"/><a data-type="indexterm" data-primary="methods" data-secondary="net.connect()" id="idm45995912186840" class="calibre6"/>connection to the upstream port and hostname, which represents the server process, logging a message once the connection succeeds. When the server sends a message to this actor, it triggers the <code class="calibre18">data</code> event, passing in a buffer instance as the <code class="calibre18">raw_data</code> argument. This data, containing a JSON payload, is then parsed.</p>

<p class="author1">The actor process then invokes one of its workers, calling the requested method and passing in the arguments. Once the worker/actor is finished, the data is then sent back to the server instance. The same message ID is preserved using the <code class="calibre18">id</code> property. This value must be provided because a given actor process can receive multiple message requests at the same time and the main server process needs to know which reply correlates with which request. The returned <code class="calibre18">value</code> is also provided in the message. The process ID is also provided as metadata in the response assigned to <code class="calibre18">pid</code> so that you can visualize which program is calculating what data.</p>

<p class="author1">Again, notably missing is proper error handling. If a connection error were to happen, you would see the process terminate entirely.</p>

<p class="author1"><a data-type="xref" href="#fig_actor_impl" class="calibre6">Figure 6-3</a> is a visualization of the implementation you’ve just built.</p>

<figure class="calibre29"><div id="fig_actor_impl" class="figure">
<img src="Images/mtjs_0603.png" alt="mtjs 0603" class="calibre70"/>
<h6 class="calibre30"><span class="keep-together">Figure 6-3. </span>A visualization of the actor model implementation in this section</h6>
</div></figure>

<p class="author1">Now that your files are complete, you’re ready to run your programs. First, run the server, providing a hostname and port to use for the HTTP server, followed by a hostname and port to use for the TCP server. You can do this by running the following command:</p>

<pre data-type="programlisting" class="calibre38">$ node server.js 127.0.0.1:8000 127.0.0.1:9000
# web:   http://127.0.0.1:8000
# actor: tcp://127.0.0.1:9000</pre>

<p class="author1">In this case the process displays the two server addresses.</p>

<p class="author1">Next, send a request to the server in a new terminal window:</p>

<pre data-type="programlisting" class="calibre38">$ curl http://localhost:8000/9999
# ERROR: EMPTY ACTOR POOL</pre>

<p class="author1">Whoops! In this case the server replied with an error. Since there are no running actor processes, there is nothing that can execute the work.</p>

<p class="author1">Next, run an actor process and give it the hostname and port for the server instance. You can do that by running the following command:</p>

<pre data-type="programlisting" class="calibre38">$ node actor.js 127.0.0.1:9000</pre>

<p class="author1">You should see a message printed from both the server and the worker process that a connection was established. Next, run the <code class="calibre18">curl</code> command again in a separate terminal window:</p>

<pre data-type="programlisting" class="calibre38">$ curl http://localhost:8000/99999
# {"id":4,"value":21081376.519967034,"pid":160004}</pre>

<p class="author1">You should get back a similar value to the one printed earlier. With the new actor process attached, the program went from having zero actors available to perform work to having four actors. But you don’t need to stop there. In another terminal window run another instance of the worker using the same command, and issue another <code class="calibre18">curl</code> command:</p>

<pre data-type="programlisting" class="calibre38">$ node actor.js 127.0.0.1:9000

$ curl http://localhost:8000/8888888
# {"id":4,"value":21081376.519967034,"pid":160005}</pre>

<p class="author1">As you run the command multiple times you should see that the <code class="calibre18">pid</code> value changes in the response. Congratulations, you’ve now dynamically increased the count of actors available to your application. This was done at runtime, effectively increasing the performance of your application without downtime.</p>

<p class="author1">Now, one of the benefits of the actor pattern is that it doesn’t really matter where the code runs. In this case the actors live inside an external process. This allowed the error to happen when the server was first executed: an HTTP request was made, but an actor process hadn’t yet connected. One way to fix this is to add some actors to the server process as well.</p>

<p class="author1">Modify the first <em class="calibre7">ch6-actors/server.js</em> file and add the content from <a data-type="xref" href="#ex_actor_server_5" class="calibre6">Example 6-24</a> to it.</p>
<div id="ex_actor_server_5" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 6-24. </span><em class="calibre7">ch6-actors/server.js</em> (part 5, bonus)</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code> <code class="nx">RpcWorkerPool</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'./rpc-worker.js'</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">worker</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">RpcWorkerPool</code><code class="p">(</code><code class="s">'./worker.js'</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="s">'leastbusy'</code><code class="p">);</code>
<code class="nx">actors</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">async</code> <code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">worker</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">method</code><code class="p">,</code> <code class="p">...</code><code class="nx">data</code><code class="p">.</code><code class="nx">args</code><code class="p">);</code>
  <code class="nx">messages</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">id</code><code class="p">).</code><code class="nx">end</code><code class="p">(</code><code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">({</code>
    <code class="nx">id</code><code class="o">:</code> <code class="nx">data</code><code class="p">.</code><code class="nx">id</code><code class="p">,</code>
    <code class="nx">value</code><code class="p">,</code>
    <code class="nx">pid</code><code class="o">:</code> <code class="s">'server'</code>
  <code class="p">})</code> <code class="o">+</code> <code class="s">'\0'</code><code class="p">);</code>
  <code class="nx">messages</code><code class="p">.</code><code class="kr">delete</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>
<code class="p">});</code></pre></div>

<p class="author1">This addition to the file creates a worker thread pool in the server process, effectively adding an additional four actors to the pool. Kill the existing server and actor processes that you’ve created with Ctrl+C. Then, run your new server code and send it a <code class="calibre18">curl</code> request:</p>

<pre data-type="programlisting" class="calibre38">$ node server.js 127.0.0.1:8000 127.0.0.1:9000
$ curl http://localhost:8000/8888888
# {"id":8,"value":17667693458.923462,"pid":"server"}</pre>

<p class="author1">In this case the <code class="calibre18">pid</code> value has been hardcoded to <code class="calibre18">server</code> to signify that the process performing the calculation is the server process. Much like before, you can run some more actor processes to have them connect to the server and run more <code class="calibre18">curl</code> commands to send requests to the server. When this happens you should see that requests are handled either by dedicated actor processes or by the server.</p>

<p class="author1">With the actor pattern, you shouldn’t think of the joined actors as external APIs. Instead, think of them as an extension of the program itself. This pattern can be powerful, and it comes with an interesting use case. <em class="calibre7">Hot code loading</em> is when newer versions <a data-type="indexterm" data-primary="hot code loading" id="idm45995910936024" class="calibre6"/><a data-type="indexterm" data-primary="actor models" data-secondary="hot code loading" id="idm45995910935320" class="calibre6"/>of application code replaces old versions and is done while the application continues to run. With the actor pattern you’ve built, you are able to modify the <em class="calibre7">actor.js</em> / <em class="calibre7">worker.js</em> files, modify the existing <code class="calibre18">square_sum()</code> method, or even add new methods. Then, you can launch new actor programs and terminate old actor programs, and the main server will then start using the new actors.</p>

<p class="author1">Also worth noting is that the version of the actor model covered in this section does have several shortcomings that should be considered before implementing something like this in production. The first is that, although the individual actors within an actor process are chosen by which is least busy, the actor process itself is chosen randomly. This can lead to skewed workloads. To fix this you would need some sort of coordination mechanism to keep track of which actors are free.</p>

<p class="author1">Another shortcoming is that individual actors aren’t addressable by other actors; in fact, one actor cannot call code from another actor. Architecturally, the processes resemble the star topology, where actor processes strictly connect to the server process. Ideally, all actors could connect with each other, and actors could individually address each other.</p>

<p class="author1">A big benefit of this approach is that of <a data-type="indexterm" data-primary="actor models" data-secondary="example implementation" data-startref="actimp" id="idm45995910930360" class="calibre6"/>resilience. With the approach covered in this section there’s only a single HTTP server. If the server process dies, then the whole application dies. A more resilient system might have each process be both an HTTP server and a TCP server, and have a reverse proxy route requests to all processes. Once these changes are made, you are closer to the actor model implementation provided by more robust platforms.</p>
</div></section>





</div></section>







<div data-type="footnotes" class="calibre41"><p data-type="footnote" id="idm45995913366808" class="calibre42"><sup class="calibre43"><a href="ch06.xhtml#idm45995913366808-marker" class="calibre40">1</a></sup> In practice, restaurants can get much busier than what the order wheel can handle. Restaurants will often solve this with such tricks as inserting more than one order paper in the same slot on the wheel, with some agreed-upon ordering in each slot. In the case of our ring buffers, we can’t shove more than one piece of data into an array slot, so we can’t use the same hack. Instead, a more complete system should have a way of indicating that the queue is full and can’t handle any more data right now. As you’ll see, we’re going to do exactly that.</p><p data-type="footnote" id="idm45995912090232" class="calibre42"><sup class="calibre43"><a href="ch06.xhtml#idm45995912090232-marker" class="calibre40">2</a></sup> Another noteworthy implementation of the actor pattern is in the Scala language.</p><p data-type="footnote" id="idm45995911475144" class="calibre42"><sup class="calibre43"><a href="ch06.xhtml#idm45995911475144-marker" class="calibre40">3</a></sup> Large messages, like if strings are being passed instead of a few small numbers, may get split across TCP message boundaries and arrive in multiple <code class="calibre18">data</code> events. Keep this in mind if adapting this code for production use.</p></div></div></section></div></body></html>