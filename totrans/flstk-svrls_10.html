<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. Working with Images and Storage"><div class="chapter" id="ch10">
<h1><span class="label">Chapter 10. </span>Working with Images and Storage</h1>


<p><a data-type="indexterm" data-primary="image storage" data-secondary="about" id="idm45364346502824"/>Many applications need to have a way to manage file, image, and video storage. While it’s possible to transform these objects into binary data and store them directly in your database, it’s usually better not to. Instead, using a managed file-hosting service like Amazon S3 is better because it’s less expensive, faster, and just as secure.</p>

<p>In this chapter, we’ll look at how to create a photo-sharing app that renders posts with photos in a stream in real time, allowing you to share an image along with a caption for the image.</p>






<section data-type="sect1" data-pdf-bookmark="Using Amazon S3"><div class="sect1" id="idm45364346500632">
<h1>Using Amazon S3</h1>

<p><a data-type="indexterm" data-primary="Amazon S3" data-secondary="image storage using" id="amz_is"/><a data-type="indexterm" data-primary="image storage" data-secondary="using Amazon S3" id="is_amz"/>Amazon S3 allows you to have secure file hosting that scales as you need it. Amplify uses S3 as the Storage category for handling the storage of files like images, videos, PDFs, and more.</p>

<p>When working with S3, you typically will have three types of file access available:</p>
<dl>
<dt>Public</dt>
<dd>
<p><a data-type="indexterm" data-primary="AWS SDKs" id="idm45364346493992"/><a data-type="indexterm" data-primary="public files" id="idm45364346493288"/>Items stored with public access will be accessible by all users of your app. These files are stored under the <em>public/</em> path in your S3 bucket. Public does not mean that anyone with the URL of the resource can view it, though. In order to be viewed, you must use the Amplify SDK to retrieve a temporarily signed URL of the resource. This signed URL will be set to expire after a set period of time (15 minutes by default).</p>
</dd>
<dt>Private</dt>
<dd>
<p><a data-type="indexterm" data-primary="private files" id="idm45364346490472"/>Items are readable by all users, but writable only by the creating user. In S3, the files are stored under the path <em>private/{user_identity_id}</em>, where the <em>user_identity_id</em> corresponds to the unique Amazon Cognito ID for that user.</p>
</dd>
<dt>Protected</dt>
<dd>
<p><a data-type="indexterm" data-primary="protected files" id="idm45364346487448"/>These files are only accessible for the individual user. Files are stored under the path <em>private/{user_identity_id}</em> where the <em>user_identity_id</em> corresponds to the unique Amazon Cognito ID for that user.</p>
</dd>
</dl>

<p>By default, when storing a file, it will be set to <code>public</code> unless otherwise specified:</p>

<pre data-type="programlisting">await Storage.put('test.txt', 'Hello')</pre>

<p>If you would like to specify either <code>private</code> or <code>protected</code> access, you need to specify the level when saving:</p>

<pre data-type="programlisting">/* Private level access */
await Storage.put('test.txt', 'Private Content', {
  level: 'private',
  contentType: 'text/plain'
})

/* Protected level access */
await Storage.put('test.txt', 'Protected Content', {
  level: 'protected',
  contentType: 'text/plain'
})</pre>

<p>The storage category uses Amazon S3 to store file types including images, PDFs, video, text files, and more.</p>

<p>To put this all together, we’ll use a combination of a GraphQL API along with Amazon S3 to work as the backend for the app. The GraphQL schema will hold the fields for the image title, the image key stored in S3, and the unique ID.</p>

<p>Let’s take a look at the schema we will be using:</p>

<pre data-type="programlisting">type Post @model {
  id: ID!
  title: String!
  imageKey: String!
}</pre>

<p>When creating a new post, there are two operations that will need to happen:</p>

<ul>
<li>
<p>The image is given a unique key and stored in the S3 bucket.</p>
</li>
<li>
<p>The post metadata, including the image key, is stored in the GraphQL API.</p>
</li>
</ul>

<p>When reading posts, this will be the sequence of events:</p>
<ol>
<li>
<p>GraphQL query to read a list of posts from the GraphQL API.</p>
</li>
<li>
<p>Map over the posts array, getting a signed URL for each image in the list of posts.</p>
</li>
<li>
<p>Render the posts using the signed URL for the image as the image source.</p>
</li>

</ol>

<p>The example we will build in this chapter implements a very common and useful pattern for building applications that rely on a combination of an API with references to large objects, such as images, videos, and files in general that are stored in S3.</p>








<section data-type="sect2" data-pdf-bookmark="Creating the Base Project"><div class="sect2" id="idm45364346471688">
<h2>Creating the Base Project</h2>

<p><a data-type="indexterm" data-primary="creating" data-secondary="base projects" id="idm45364346470296"/><a data-type="indexterm" data-primary="projects" data-secondary="creating base" id="idm45364346469320"/>To get started, we will create a new React project, initialize an Amplify app, and install the dependencies.</p>

<p>The first thing we will do is create the React project:</p>

<pre data-type="programlisting">~ npx create-react-app photo-app
~ cd photo-app</pre>

<p><a data-type="indexterm" data-primary="unique identifier" id="idm45364346466632"/><a data-type="indexterm" data-primary="UUID (universally unique identifier)" id="idm45364346465928"/><a data-type="indexterm" data-primary="Ant Design" id="idm45364346465192"/>Next, we will install the local dependencies. This project will use Ant Design for styling (<code>antd</code>), the UUID package for creating unique identifiers (<code>uuid</code>) along with the AWS Amplify and AWS Amplify React packages:</p>

<pre data-type="programlisting">~ npm install antd uuid aws-amplify @aws-amplify/ui-react</pre>

<p>Next, initialize a new Amplify project:</p>

<pre data-type="programlisting">~ amplify init

# Follow the steps to give the project a name, environment name, and set the
  default text editor.
# Accept defaults for everything else and choose your AWS Profile.</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Adding Authentication"><div class="sect2" id="idm45364346461144">
<h2>Adding Authentication</h2>

<p><a data-type="indexterm" data-primary="adding" data-secondary="authentication" id="idm45364346459944"/><a data-type="indexterm" data-primary="authentication" data-secondary="adding" id="idm45364346458968"/>Next, add authentication using the <code>auth</code> category:</p>

<pre data-type="programlisting">~ amplify add auth

? Do you want to use the default authentication and security configuration?
  Default configuration
? How do you want users to be able to sign in? Username
? Do you want to configure advanced settings? No, I am done.</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating the API"><div class="sect2" id="idm45364346456184">
<h2>Creating the API</h2>

<p><a data-type="indexterm" data-primary="APIs" data-secondary="creating" id="idm45364346454648"/><a data-type="indexterm" data-primary="creating" data-secondary="APIs" id="idm45364346453672"/><a data-type="indexterm" data-primary="creating" data-secondary="AppSync GraphQL API" id="idm45364346452728"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="creating" id="idm45364346451784"/>Next, we will create the AppSync GraphQL API:</p>

<pre data-type="programlisting">~ amplify add api

? Please select from one of the below mentioned services: GraphQL
? Provide API name: photoapp
? Choose an authorization type for the API: Amazon Cognito User Pool
? Do you want to configure advanced settings for the API? No
? Do you have an annotated GraphQL schema? N
? Do you want a guided schema creation? Y
? What best describes your project: Single object with fields
? Do you want to edit the schema now? Yes</pre>

<p>For the GraphQL schema, use the following:</p>

<pre data-type="programlisting">type Post @model {
  id: ID!
  title: String!
  imageKey: String!
}</pre>

<p>Finally, we will add storage using the <code>storage</code> category:</p>

<pre data-type="programlisting">~ amplify add storage

? Please select from one of the below mentioned services: Content
? Please provide a friendly name for your resource that will be used to label
  this category in the project: photos
? Please provide bucket name: &lt;your_unique_bucket_name&gt;
? Who should have access: Auth users only
? What kind of access do you want for Authenticated users? Choose all
  (create / update, read, &amp; delete)
? Do you want to add a Lambda Trigger for your S3 Bucket? N</pre>

<p>Now services have been configured and they are ready to be deployed:</p>

<pre data-type="programlisting">~ amplify push</pre>

<p>Now that the backend has been deployed, we can start writing the client-side code.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Writing the Client-Side Code"><div class="sect2" id="idm45364346455560">
<h2>Writing the Client-Side Code</h2>

<p><a data-type="indexterm" data-primary="client-side code, writing" id="idm45364346443064"/><a data-type="indexterm" data-primary="code" data-secondary="client-side" id="idm45364346442344"/><a data-type="indexterm" data-primary="writing client-side code" id="idm45364346441400"/>First, open <em>src/index.js</em> and configure the Amplify app by adding the following code below the last import:</p>

<pre data-type="programlisting">import 'antd/dist/antd.css'
import Amplify from 'aws-amplify'
import config from './aws-exports'
Amplify.configure(config)</pre>

<p>This app will have two views: one view for listing posts and one view for creating posts. Let’s next create two new components for these views in the <em>src</em> directory:</p>

<pre data-type="programlisting">~ cd src
~ touch Posts.js CreatePost.js
~ cd ..</pre>

<p>Next, open <em>src/App.js</em> and update it with the following code:</p>

<pre data-type="programlisting">/* src/App.js */
import React, { useState } from 'react';
import { Radio } from 'antd'
import { withAuthenticator, AmplifySignOut } from '@aws-amplify/ui-react'
import Posts from './Posts'
import CreatePost from './CreatePost'

function App() {
  const [viewState, updateViewState] = useState('viewPosts')

  return (
    &lt;div style={container}&gt;
      &lt;h1&gt;Photo App&lt;/h1&gt;
      &lt;Radio.Group
        value={viewState}
        onChange={e =&gt; updateViewState(e.target.value)}
      &gt;
        &lt;Radio.Button value="viewPosts"&gt;View Posts&lt;/Radio.Button&gt;
        &lt;Radio.Button value="addPost"&gt;Add Post&lt;/Radio.Button&gt;
      &lt;/Radio.Group&gt;
      {
        viewState === 'viewPosts' ? (
          &lt;Posts /&gt;
        ) : (
          &lt;CreatePost updateViewState={updateViewState} /&gt;
        )
      }
      &lt;AmplifySignOut /&gt;
    &lt;/div&gt;
  );
}

const container = { width: 500, margin: '0 auto', padding: 50 }

export default withAuthenticator(App);</pre>

<p>This component imports the <code>Posts</code> and <code>CreatePost</code> components and renders one of them based on the <code>viewState</code> component state.</p>

<p>To create the <code>viewState</code>, we used the <code>useState</code> hook. To toggle the value of <code>viewState</code>, we render a radio group from Ant Design that renders a button for either viewing posts (View Posts) or adding a new post (Add Post).</p>

<p>Next, open <em>src/CreatePost.js</em> and update it with the following code:</p>

<pre data-type="programlisting">/* src/CreatePost.js */
import React, { useState } from 'react';
import { Button, Input } from 'antd'
import { v4 as uuid } from 'uuid'
import { createPost } from './graphql/mutations'
import { API, graphqlOperation, Storage } from 'aws-amplify'

const initialFormState = {
  title: '',
  image: {}
}

function CreatePost({ updateViewState }) {
  const [formState, updateFormState] = useState(initialFormState)

  function onChange(key, value) {
    updateFormState({ ...formState, [key]: value })
  }

  function setPhoto(e) {
    if (!e.target.files[0]) return
    const file = e.target.files[0]
    updateFormState({ ...formState, image: file })
  }

  async function savePhoto() {
    const { title, image } = formState
    if (!title || !image.name ) return

    const imageKey =
      uuid() + formState.image.name.replace(/\s/g, '-').toLowerCase()
    await Storage.put(imageKey, formState.image)
    const post = { title, imageKey }
    await API.graphql(graphqlOperation(createPost, { input: post }))
    updateViewState('viewPosts')
  }

  return (
    &lt;div&gt;
      &lt;h2 style={heading}&gt;Add Photo&lt;/h2&gt;
      &lt;Input
        onChange={e =&gt; onChange('title', e.target.value)}
        style={withMargin}
        placeholder="Title"
      /&gt;
      &lt;input
        type='file'
        onChange={setPhoto}
        style={button}
      /&gt;
      &lt;Button
       style={button}
       type="primary"
       onClick={savePhoto}
      &gt;
      Save Photo&lt;/Button&gt;
    &lt;/div&gt;
  );
}

const heading = { margin: '20px 0px' }
const withMargin = { marginTop: 10 }
const button = { marginTop: 10 }

export default CreatePost</pre>










<section data-type="sect3" data-pdf-bookmark="About this component"><div class="sect3" id="idm45364346427832">
<h3>About this component</h3>

<p>In this component, we allow users to upload an image and create a new post with the image and a title:</p>
<ol>
<li>
<p>The state that this component holds is stored in the <code>formState</code> object, created using the <code>useState</code> hook. This object holds the post <code>title</code> as well as the post <code>image</code>.</p>
</li>
<li>
<p><code>onChange</code> updates the <code>title</code> of the <code>formState</code> when the user types into the input.</p>
</li>
<li>
<p><code>setPhoto</code> allows a user to upload an image and stores it in the <code>formState</code> as the <code>image</code>.</p>
</li>
<li>
<p><code>savePhoto</code> is where we store the image in S3 and then save the post information to AppSync using a GraphQL mutation:</p>
<ol>
<li>
<p>We first create a variable called <code>imageKey</code> using a combination of the image <code>name</code> and a <code>uuid</code>.</p>
</li>
<li>
<p>We then store the image in S3 using the <code>imageKey</code> as the reference.</p>
</li>
<li>
<p>After the image is stored, we then make an API call to AppSync, creating a new <code>Post</code> using a GraphQL Mutation and passing in the post <code>title</code> and <code>imageKey</code> as the fields.</p>
</li>

</ol>
</li>

</ol>

<p>Next, open <em>src/Posts.js</em> and update it with the following code:</p>

<pre data-type="programlisting">/* src/Posts.js */
import React, { useReducer, useEffect } from 'react';
import { listPosts } from './graphql/queries'
import { onCreatePost } from './graphql/subscriptions'
import { API, graphqlOperation, Storage } from 'aws-amplify'

function reducer(state, action) {
  switch(action.type) {
    case 'SET_POSTS':
      return  action.posts
    case 'ADD_POST':
      return [action.post, ...state]
    default:
      return state
  }
}

async function getSignedPosts(posts) {
  const signedPosts = await Promise.all(
    posts.map(async item =&gt; {
      const signedUrl = await Storage.get(item.imageKey)
      item.imageUrl = signedUrl
      return item
    })
  )
  return signedPosts
}

function Posts() {
  const [posts, dispatch] = useReducer(reducer, [])

  useEffect(() =&gt; {
    fetchPosts()

    const subscription = API.graphql(graphqlOperation(onCreatePost)).subscribe({
      next: async post =&gt; {
        const newPost = post.value.data.onCreatePost
        const signedUrl = await Storage.get(newPost.imageKey)
        newPost.imageUrl = signedUrl
        dispatch({ type: 'ADD_POST', post: newPost })
      }
    })
    return () =&gt; subscription.unsubscribe()
  }, [])

  async function fetchPosts() {
    const postData = await API.graphql(graphqlOperation(listPosts))
    const { data: { listPosts: { items }}} = postData
    const signedPosts = await getSignedPosts(items)
    dispatch({ type: 'SET_POSTS', posts: signedPosts })
  }

  return (
    &lt;div&gt;
      &lt;h2 style={heading}&gt;Posts&lt;/h2&gt;
      {
        posts.map(post =&gt; (
          &lt;div key={post.id} style={postContainer}&gt;
            &lt;img style={postImage} src={post.imageUrl} /&gt;
            &lt;h3 style={postTitle}&gt;{post.title}&lt;/h3&gt;
          &lt;/div&gt;
        ))
      }
    &lt;/div&gt;
  )
}

const postContainer = {
  padding: '20px 0px 0px',
  borderBottom: '1px solid #ddd'
}
const heading = { margin: '20px 0px' }
const postImage = { width: 400 }
const postTitle = { marginTop: 4 }

export default Posts</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="useReducer"><div class="sect3" id="idm45364346406968">
<h3>useReducer</h3>

<p><a data-type="indexterm" data-primary="useReducer component" id="idm45364346405960"/>In this component, we are using the <code>useReducer</code> hook to manage application state. We do this because we will be having a GraphQL subscription that will be handling data coming through in real time. Because <code>useState</code> creates a closure, we must move the state that is outside the component into a reducer.</p>

<p>The reducer has two actions, one for adding a single post (<code>ADD_POST</code>) and one for setting an array of posts (<code>SET_POSTS</code>).</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="About this component"><div class="sect3" id="idm45364346402488">
<h3>About this component</h3>

<p>There are two main things happening in this component:</p>
<dl>
<dt><code>useEffect</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="useEffect hook" id="idm45364346399384"/>When the component loads, this hook will fire, creating a new GraphQL subscription and then calling the <code>fetchPosts</code> function that we will go over in the next step:</p>
<ol>
<li>
<p>The subscription will listen for new posts that are created by using the <code>onCreatePost</code> subscription.</p>
</li>
<li>
<p>When a new post is created, the <code>next</code> function will fire and the data for the new post will come through in the function argument (<code>post</code>).</p>
</li>
<li>
<p>We then use the post image <code>imageKey</code> to get a signed URL by using the Storage API, calling <code>Storage.get</code>.</p>
</li>
<li>
<p>After getting the signed URL for the image, we add the <code>imageURL</code> field to the post and dipatch <code>ADD_POST</code> to add the new post to the state.</p>
</li>

</ol>
</dd>
<dt><code>fetchPosts</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="fetchPosts function" id="idm45364346388936"/>This function fetches the posts from the API, then calls <code>getSignedPosts</code> passing in the posts:</p>
<ol>
<li>
<p>The <code>getSignedPosts</code> function will map over all of the posts in the array, get a signed URL for the image in the post, and assign a new <code>imageUrl</code> field to the post with the signed image URL.</p>
</li>
<li>
<p>One the signed posts are returned, <code>SET_POSTS</code> is dispatched, updating the state with the posts array.</p>
</li>

</ol>
</dd>
</dl>

<p>That’s it; we should now be able to run the app and test it out:</p>

<pre data-type="programlisting">~ npm start</pre>

<p>To test out the subscription/real-time functionality, try opening a new window and running the app in both windows, viewing the posts in one window and creating a post in another window<a data-type="indexterm" data-primary="" data-startref="amz_is" id="idm45364346381736"/><a data-type="indexterm" data-primary="" data-startref="is_amz" id="idm45364346380760"/>.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45364346499816">
<h1>Summary</h1>

<p>Here are a few things to keep in mind from this chapter:</p>

<ul>
<li>
<p>When working with storage, images cannot be referenced directly by their URL; they must be signed using a <code>Storage.get</code> call.</p>
</li>
<li>
<p>Once a file is returned with a signed URL, it will be valid for 15 minutes by default; after that, it will expire. This can be overridden by passing in an <code>expires</code> option to set the availability of your URLs.</p>
</li>
<li>
<p>When working with an array of images, you can map over the array and use <code>Promise.all</code> to get a signed URL for each item in the array.</p>
</li>
</ul>
</div></section>







</div></section></div>



  </body></html>