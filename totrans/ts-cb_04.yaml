- en: Chapter 3\. The Type System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter you learned about the basic building blocks that allow
    you to make your JavaScript code more expressive. But if you are experienced in
    JavaScript, you understand that TypeScript’s fundamental types and annotations
    cover only a small set of its inherent flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is supposed to make intentions in JavaScript clearer, and it wants
    to do so without sacrificing this flexibility, especially since it allowed developers
    to design fantastic APIs used and loved by millions. Think of TypeScript more
    as a way to formalize JavaScript, rather than restrict it. Enter TypeScript’s
    type system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will develop a mental model for how to think about types.
    You will learn how to define sets of values as widely or as narrowly as you need,
    and how to change their scope throughout your control flow. You will also learn
    how to leverage a structural type system and when to break with the rules.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the line between TypeScript foundations and advanced type
    techniques. But whether you are an experienced TypeScript developer or just starting
    out, this mental model will be the baseline for everything to come.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Modeling Data with Union and Intersection Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have an elaborate data model you want to describe in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use union and intersection types to model your data. Use literal types to define
    specific variants.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you are creating a data model for a toy shop. Each item in this toy
    shop has some basic properties: name, quantity, and the recommended minimum age.
    Additional properties are relevant only for each particular type of toy, which
    requires you to create several derivations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For the functions you create, you need a type that is representative of all
    toys, a supertype that contains just the basic properties common to all toys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, as you can print all dolls, board games, or puzzles with that function,
    but there’s one caveat: you lose the information of the original toy within `printToy`.
    You can print only common properties, not specific ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a type representing all possible toys, you can create a *union type*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A good way to think of a type is as a set of compatible values. For each value,
    either annotated or not, TypeScript checks if this value is compatible with a
    certain type. For objects, this also includes values with more properties than
    defined in their type. Through inference, values with more properties are assigned
    a subtype in the structural type system. And values of subtypes are also part
    of the supertype set.
  prefs: []
  type: TYPE_NORMAL
- en: A union type is a union of sets. The number of compatible values gets broader,
    and there is also some overlap between types. For example, an object that has
    both `material` and `players` can be compatible with both `Doll` and `BoardGame`.
    This is a detail to look out for, and you can see a method to work with that detail
    in [Recipe 3.2](#ch03_item_discriminated_unions).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](#img-union) illustrates the concept of a union type in the form
    of a Venn diagram. Set theory analogies work well here, too.'
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0301](assets/tscb_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Visualization of a union type; each type represents a set of compatible
    values, and a union type represents the union sets
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can create union types everywhere, and with primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to widen the set of values as much as you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you also see in the toy shop example is some redundancy: the `ToyBase`
    properties are repeated. It would be much nicer if we could use `ToyBase` as the
    basis of each union part. And we can, using intersection types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Just like union types, *intersection types* resemble their counterparts from
    set theory. They tell TypeScript that compatible values need to be of type `A`
    *and* type `B`. The type now accepts a narrower set of values, one that includes
    all properties from both types, including their subtypes. [Figure 3-2](#img-intersection)
    shows a visualization of an intersection type.
  prefs: []
  type: TYPE_NORMAL
- en: Intersection types also work on primitive types, but they are of no good use.
    An intersection of `string & number` results in `never`, as no value satisfies
    both `string` and `number` properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0302](assets/tscb_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Visualization of an intersection type of two types; the set of
    possible values gets narrower
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Instead of type aliases and intersection types you can also define your models
    with interfaces. In [Recipe 2.5](ch02.html#ch02_item_interfaces_vs_types) we talk
    about the differences between them, and there are a few you need to look out for.
    So a `type BoardGame = ToyBase & { /* ... */ }` can easily be described as `interface
    BoardGame extends ToyBase { /* ... */ }`. However, you can’t define an interface
    that is a union type. You can define a union of interfaces, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are already great ways to model data within TypeScript, but we can do
    a little more. In TypeScript, literal values can be represented as a literal type.
    We can define a type that is just, for example, the number 1, and the only compatible
    value is `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called a *literal type*, and while it doesn’t seem to be quite useful
    alone, it is of great use when you combine multiple literal types to a union.
    For the `Doll` type, for example, we can explicitly set allowed values for `material`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This makes assigning any value other than `"plush"` or `"plastic"` impossible
    and makes our code much more robust.
  prefs: []
  type: TYPE_NORMAL
- en: With union types, intersection types, and literal types, it becomes much easier
    to define even elaborate models.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Explicitly Defining Models with Discriminated Union Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parts of your modeled union type have a huge overlap in their properties, so
    it becomes cumbersome to distinguish them in control flow.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a `kind` property to each union part with a string literal type, and check
    for its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a data model similar to what we created in [Recipe 3.1](#ch03_item_modelling_data).
    This time, we want to define various shapes for a graphics software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some similarities between the types but there is also still enough
    information to differentiate between them in an `area` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This works, but it comes with a few caveats. While `Circle` is the only type
    with a `radius` property, `Triangle` and `Square` share the `x` property. Since
    `Square` consists only of the `x` property, this makes `Triangle` a subtype of
    `Square`.
  prefs: []
  type: TYPE_NORMAL
- en: Given how we defined the control flow to check for the distinguishing subtype
    property `y` first, this is not an issue, but it’s just too easy to check for
    `x` alone and create a branch in the control flow that computes the area for both
    `Triangle` and `Square` in the same manner, which is just wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also hard to extend `Shape`. If we look at the required properties for
    a rectangle, we see that it contains the same properties as `Triangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There is no clear way to differentiate between each part of a union. To make
    sure each part of a union is distinguishable, we need to extend our models with
    an identifying property that makes absolutely clear what we are dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: This can happen through the addition of a `kind` property. This property takes
    a string literal type identifying the part of the model.
  prefs: []
  type: TYPE_NORMAL
- en: As seen in [Recipe 3.1](#ch03_item_modelling_data), TypeScript allows you to
    subset primitive types like `string`, `number`, `bigint`, and `boolean` to concrete
    values. Which means that every value is also a type, a set that consists of exactly
    one compatible value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for our model to be clearly defined, we add a `kind` property to each model
    part and set it to an exact literal type identifying this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don’t set `kind` to `string` but to the *exact* literal type `"circle"`
    (or `"square"` and `"triangle"`, respectively). This is a type, not a value, but
    the only compatible value is the literal string.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `kind` property with string literal types ensures there can’t be
    any overlap between parts of the union, as the literal types are not compatible
    with one another. This technique is called *discriminated union types* and effectively
    tears away each set that’s part of the union type `Shape`, pointing to an exact
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is fantastic for the `area` function, as we can effectively distinguish,
    for example, in a `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Not only does it become absolutely clear what we are dealing with, but it is
    also very future proof to upcoming changes, as we will see in [Recipe 3.3](#ch03_item_assert_never).
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Exhaustiveness Checking with the Assert never Technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your discriminated union types change over time, adding new parts to the union.
    It becomes difficult to track all occurrences in your code where you need to adapt
    to these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create exhaustiveness checks where you assert that all remaining cases can never
    happen with an `assertNever` function.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the full example from [Recipe 3.2](#ch03_item_discriminated_unions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using discriminated unions, we can distinguish between each part of a union.
    The `area` function uses a switch-case statement to handle each case separately.
    Thanks to string literal types for the `kind` property, there can be no overlap
    between types.
  prefs: []
  type: TYPE_NORMAL
- en: Once all options are exhausted, in the default case we throw an error, indicating
    that we reached an invalid situation that should never occur. If our types are
    right throughout the codebase, this error should never be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even the type system tells us that the default case is an impossible scenario.
    If we add `shape` in the default case and hover over it, TypeScript tells us that
    `shape` is of type `never`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`never` is an interesting type. It’s TypeScript *bottom type*, meaning that
    it’s at the very end of the type hierarchy. Where `any` and `unknown` include
    every possible value, no value is compatible to `never`. It’s the empty set, which
    explains the name. If one of your values happens to be of type `never`, you are
    in a situation that should *never* happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of `shape` in the default cases changes immediately if we extend the
    type `Shape` with, for example, a `Rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is control flow analysis at its best: TypeScript knows at exactly every
    point in time which types your values have. In the `default` branch, `shape` is
    of type `Rectangle`, but we are expected to deal with rectangles. Wouldn’t it
    be great if TypeScript could tell us that we missed taking care of a potential
    type? With the change, we now run into it every time we calculate the shape of
    a rectangle. The default case was meant to handle (from the perspective of the
    type system) impossible situations; we’d like to keep it that way.'
  prefs: []
  type: TYPE_NORMAL
- en: This is already bad in one situation, and it gets worse if you use the exhaustiveness
    checking pattern multiple times in your codebase. You can’t tell for sure that
    you didn’t miss one spot where your software will ultimately crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'One technique to ensure that you handled all possible cases is to create a
    helper function that asserts that all options are exhausted. It should ensure
    that the only values possible are no values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, you see `never` as an indicator that you are in an impossible situation.
    Here, we use it as an explicit type annotation for a function signature. You might
    ask: which values are we supposed to pass? And the answer is: none! In the best
    case, this function will never get called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we substitute the original default case from our example with `as⁠se⁠rt​Ne⁠ve⁠r`,
    we can use the type system to ensure that all possible values are compatible,
    even if there are no values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We now get red squiggly lines whenever we forget to exhaust all options.
    TypeScript won’t compile this code without an error, and it’s easy to spot all
    occurrences in our codebase where we need to add the `Rectangle` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Even though `never` has no compatible values and is used to indicate—for the
    type system—an impossible situation, we can use the type as type annotation to
    make sure we don’t forget about *possible* situations. Seeing types as sets of
    compatible values that can get broader or narrower based on control flow leads
    us to techniques like `assertNever`, a very helpful little function that can strengthen
    our codebase’s quality.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Pinning Types with Const Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can’t assign object literals to your carefully modeled discriminated union
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pin the type of your literals using type assertions and *const context*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In TypeScript, it’s possible to use each value as its own type. These are called
    literal types and allow you to subset bigger sets to just a couple of valid values.
  prefs: []
  type: TYPE_NORMAL
- en: Literal types in TypeScript are not only a nice trick to point to specific values
    but are also an essential part of how the type system works. This becomes obvious
    when you assign values of primitive types to different bindings via `let` or `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assign the same value twice, once via `let` and once via `const`, TypeScript
    infers two different types. With the `let` binding, TypeScript will infer the
    broader primitive type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With a `const` binding, TypeScript will infer the exact literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Object types behave slightly differently. `let` bindings still infer the broader
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But so do `const` bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The reasoning behind this is in JavaScript, while the binding itself is *constant*,
    which means I can’t reassign `person`, the values of an object’s property can
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is correct in the sense that it mirrors the behavior of JavaScript,
    but it can cause problems when we are very exact with our data models.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipes we modeled data using union and intersection types.
    We used *discriminated union types* to distinguish between types that are too
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that when we use literals for data, TypeScript will usually
    infer the broader set, which makes the values incompatible to the types defined.
    This produces a very lengthy error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways to solve this problem. First, we can use explicit annotations
    to ensure the type. As described in [Recipe 2.1](ch02.html#ch02_item_annotation),
    each annotation is a type-check, which means the value on the righthand side is
    checked for compatibility. Since there is no inference, Typescript will look at
    the exact values to decide whether an object literal is compatible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of type annotations, we can also do type assertions at the end of the
    assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, however, annotations can limit us. This is true especially when we
    have to work with literals that contain more information and are used in different
    places with different semantics.
  prefs: []
  type: TYPE_NORMAL
- en: From the moment we annotate or assert as `Circle`, the binding will always be
    a circle, no matter which values `circle` actually carries.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can be much more fine-grained with assertions. Instead of asserting
    that the entire object is of a certain type, we can assert single properties to
    be of a certain type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to assert as exact values is to use *const context* with an `as
    const` type assertion; TypeScript locks the value in as literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we apply *const context* to the entire object, we also make sure that the
    values are read-only and won’t be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Const context* type assertions are a very handy tool if we want to pin values
    to their exact literal type and keep them that way. If there are a lot of object
    literals in your code base that are not supposed to change but need to be consumed
    in various occasions, *const context* can help!'
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Narrowing Types with Type Predicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on certain conditions, you can assert that a value is of a narrower type
    than originally assigned, but TypeScript can’t narrow it for you.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add type predicates to a helper function’s signature to indicate the impact
    of a Boolean condition for the type system.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With literal types and union types, TypeScript allows you to define very specific
    sets of values. For example, we can define a die with six sides easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: While this notation is expressive, and the type system can tell you exactly
    which values are valid, it requires some work to get to this type.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine we have some kind of game where users are allowed to input any
    number. If it’s a valid number of dots, we are doing certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We write a conditional check to see if the input number is part of a set of
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that even though we do a check to make sure the set of values
    is known, TypeScript still handles `input` as `number`. There is no way for the
    type system to make the connection between your check and the change in the type
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can help the type system. First, extract your check into its own helper
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that this check returns a `boolean`. Either this condition is true or it’s
    false. For functions that return a Boolean value, we can change the return type
    of the function signature to a type predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We tell TypeScript that if this function returns true, we know more about the
    value that has been passed to the function. In our case, `value` is of type `Dice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, TypeScript gets a hint of what the actual types of your values are,
    allowing you to do more fine-grained operations on your values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript is restrictive and doesn’t allow any assertion with type predicates.
    It needs to be a type that is narrower than the original type. For example, getting
    a `string` input and asserting a subset of `number` as output will error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This fail-safe mechanism gives you some guarantee on the type level, but there
    is a caveat: it won’t check if your conditions make sense. The original check
    in `isDice` ensures that the value passed is included in an array of valid numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values in this array are your choice. If you include a wrong number, TypeScript
    will still think `value` is a valid `Dice`, even though your check does not line
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is easy to trip over. The condition in [Example 3-1](#ex-wrong-check) is
    true for integer numbers but wrong if you pass a floating point number. For example,
    `3.1415` would be a valid `Dice` dot count!
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. Incorrect logic for `isDice` for floating point numbers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, any condition works for TypeScript. Return `true` and TypeScript
    will think `value` is `Dice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript puts type assertions in your hand. It is your duty to make sure those
    assertions are valid and sound. If you rely heavily on type assertions via type
    predicates, make sure that you test accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Understanding void
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know `void` as a concept from other programming languages, but in TypeScript
    it can behave a little bit differently.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embrace `void` as a substitutable type for callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might know `void` from programming languages like Java or C#, where it
    indicates the absence of a return value. `void` also exists in TypeScript, and
    at first glance it does the same thing: if your functions or methods aren’t returning
    something, the return type is `void`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At second glance, however, the behavior of `void` is a bit more nuanced, and
    so is its position in the type system. `void` in TypeScript is a subtype of `undefined`.
    Functions in JavaScript always return something. Either a function explicitly
    returns a value, or it implicitly returns `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we created a type for `iHaveNoReturnValue`, it would show a function type
    with `void` as return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`void` as type can also be used for parameters and all other declarations.
    The only value that can be passed is `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`void` and `undefined` are pretty much the same. There’s one significant difference
    though: `void` as a return type can be substituted with different types, to allow
    for advanced callback patterns. Let’s create a `fetch` function, for example.
    Its task is to get a set of numbers and pass the results to a callback function,
    provided as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback function has two parameters in its signature—a status code and
    the results—and the return type is `void`. We can call `fetchResults` with callback
    functions that match the exact type of `callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'But if a function type specifies return type `void`, functions with a different,
    more specific return type are also accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The function signatures don’t match exactly, but the code still compiles. First,
    it’s OK to provide functions with a shorter argument list in their signature.
    JavaScript can call functions with excess parameters, and if they aren’t specified
    in the function, they’re simply ignored. No need to carry more parameters than
    you actually need.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the return type is `boolean`, but TypeScript will still pass this function
    along. This is useful when declaring a `void` return type. The original caller
    `fetchResults` does not expect a return value when calling the callback. So for
    the type system, the return value of `callback` is still `undefined`, even though
    it could be something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as the type system won’t allow you to work with the return value, your
    code should be safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That’s why we can pass callbacks with any return type. Even if the callback
    returns something, this value isn’t used and goes into the void.
  prefs: []
  type: TYPE_NORMAL
- en: The power lies within the calling function, which knows best what to expect
    from the callback function. And if the calling function doesn’t require a return
    value at all from the callback, anything goes!
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript calls this feature *substitutability*: the ability to substitute
    one thing for another, wherever it makes sense. This might seem odd at first.
    But especially when you work with libraries that you didn’t author, you will find
    this feature to be very valuable.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Dealing with Error Types in catch Clauses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can’t annotate explicit error types in `try-catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotate with `any` or `unknown` and use type predicates (see [Recipe 3.5](#ch03_item_type_predicates)
    to narrow to specific error types).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are coming from languages like Java, C++, or C#, you are used to doing
    your error handling by throwing exceptions and subsequently catching them in a
    cascade of `catch` clauses. There are arguably better ways to do error handling,
    but this one has been around for ages and, given history and influences, has found
    its way into JavaScript.^([1](ch03.html#id559))
  prefs: []
  type: TYPE_NORMAL
- en: “Throwing” errors and “catching” them is a valid way to handle errors in JavaScript
    and TypeScript, but there is a big difference when it comes to specifying your
    `catch` clauses. When you try to catch a specific error type, TypeScript will
    error.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-2](#ex-axios-error) uses the popular data-fetching library [Axios](https://axios-http.com)
    to show the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. Catching explicit error types does not work
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Any type can be thrown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, you are allowed to throw every expression. Of course, you can
    throw “exceptions” (or errors, as we call them in JavaScript), but it’s also possible
    to throw any other value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Since any valid value can be thrown, the possible values to catch are already
    broader than your usual subtype of `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: There is only one catch clause in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript has only one `catch` clause per `try` statement. In the past there
    have been [proposals for multiple `catch` clauses](https://oreil.ly/NMn8O) and
    even conditional expressions, but due to the lack of interest in JavaScript in
    the early 2000s, they never manifested.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you should use this one `catch` clause and do `instanceof` and `typeof`
    checks, as proposed on [MDN](https://oreil.ly/ipzoR).
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is also the only correct way to narrow types for `catch` clauses
    in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Since all possible values can be thrown, and we only have one `catch` clause
    per `try` statement to handle them, the type range of `e` is exceptionally broad.
  prefs: []
  type: TYPE_NORMAL
- en: Any exception can happen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since you know about every error that can happen, wouldn’t a proper union type
    with all possible “throwables” work just as well? In theory, yes. In practice,
    there is no way to tell which types the exception will have.
  prefs: []
  type: TYPE_NORMAL
- en: Next to all your user-defined exceptions and errors, the system might throw
    errors when something is wrong with the memory when it encountered a type mismatch
    or one of your functions has been undefined. A simple function call could exceed
    your call stack and cause the infamous stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The broad set of possible values, the single `catch` clause, and the uncertainty
    of errors that happen allow only two types for `e`: `any` and `unknown`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All reasons apply if you reject a `Promise`. The only thing TypeScript allows
    you to specify is the type of a fulfilled `Promise`. A rejection can happen on
    your behalf or through a system error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It becomes clearer if you call the same `Promise` in an `async`/`await` flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to define your own errors and catch accordingly, you can either
    write error classes and do instance of checks or create helper functions that
    check for certain properties and tell the correct type via type predicates. Axios
    is again a good example for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Error handling in JavaScript and TypeScript can be a “false friend” if you come
    from other programming languages with similar features. Be aware of the differences
    and trust the TypeScript team and type-checker to give you the correct control
    flow to make sure your errors are handled effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 Creating Exclusive Or Models with Optional never
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your model requires you to have mutually exclusive parts of a union, but your
    API can’t rely on the `kind` property to differentiate.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *optional never* technique to exclude certain properties.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to write a function that handles the result of a select operation in
    your application. This select operation gives you the list of possible options
    as well as the list of selected options. This function can deal with calls from
    a select operation that produces only a single value as well as from a select
    operation that results in multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: Since you need to adapt to an existing API, your function should be able to
    handle both and decide for the single and multiple cases within the function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Of course there are better ways to model APIs, and we can talk endlessly about
    that. But sometimes you have to deal with existing APIs that are not that great
    to begin with. TypeScript gives you techniques and methods to correctly type your
    data in scenarios like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your model mirrors that API, as you can pass either a single `value` or multiple
    `values`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This works as intended, but remember the structural type system features of
    TypeScript. Defining `SingleSelect` as a type allows also for values of all subtypes,
    which means that objects that have both the `value` property and the `values`
    property are also compatible to `SingleSelect`. The same goes for `MultipleSelect`.
    Nothing keeps you from using the `selectCallback` function with an object that
    contains both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The value you pass here is valid, but it doesn’t make sense in your application.
    You couldn’t decide whether this is a multiple select operation or a single select
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases like this we again need to separate the two sets of values just enough
    so our model becomes clearer. We can do this by using the optional `never` technique.^([2](ch03.html#id571))
    It involves taking the properties that are exclusive to each branch of a union
    and adding them as optional properties of type `never` to the other branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You tell TypeScript that this property is optional in this branch, and when
    it’s set, there is no compatible value for it. With that, all objects that contain
    both properties are invalid to `SelectProperties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The union types are separated again, without the inclusion of a `kind` property.
    This works great for models where the discriminating properties are just a few.
    If your model has too many distinct properties, and you can afford to add a `kind`
    property, use *discriminated union types* as shown in [Recipe 3.2](#ch03_item_discriminated_unions).
  prefs: []
  type: TYPE_NORMAL
- en: 3.9 Effectively Using Type Assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your code produces the correct results, but the types are way too wide. You
    know better!
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use type assertions to narrow to a smaller set using the `as` keyword, indicating
    an unsafe operation.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Think of rolling a die and producing a number between one and six. The JavaScript
    function is one line, using the Math library. You want to work with a narrowed
    type, a union of six literal number types indicating the results. However, your
    operation produces a `number`, and `number` is a type too wide for your results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `number` allows for more values than `Dice`, TypeScript won’t allow you
    to narrow the type just by annotating the function signature. This works only
    if the type is wider, a supertype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, just like with type predicates from [Recipe 3.5](#ch03_item_type_predicates),
    we can tell TypeScript that we know better, by asserting that the type is narrower
    than expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like type predicates, type assertions work only within the supertypes
    and subtypes of an assumed type. We can either set the value to a wider supertype
    or change it to a narrower subtype. TypeScript won’t allow us to switch sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Using the `as Dice` syntax is quite handy. It indicates a type change that we
    as developers are responsible for. This means that if something turns out wrong,
    we can easily scan our code for the `as` keyword and find possible culprits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In everyday language, people tend to call type assertions *type casts*. This
    arguably comes from similarity to actual, explicit type casts in C, Java, and
    the like. However, a type assertion is very different from a type cast. A type
    cast not only changes the set of compatible values but also changes the memory
    layout and even the values themselves. Casting a floating point number to an integer
    will cut off the mantissa. A type assertion in TypeScript, on the other hand,
    changes only the set of compatible values. The value stays the same. It’s called
    a *type assertion* because you assert that the type is something either narrower
    or wider, giving more hints to the type system. So if you are in a discussion
    on changing types, call them assertions, not casts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assertions are also often used when you assemble the properties of an object.
    You know that the shape is going to be of, for example, `Person`, but you need
    to set the properties first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'A type assertion tells TypeScript that the empty object is supposed to be `Person`
    at the end. Subsequently, TypeScript allows you to set properties. It’s also an
    *unsafe* operation, because you might forget that you set a property and TypeScript
    would not complain. Even worse, `Person` might change and get more properties,
    and you would get no indication at all that you are missing properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In situations like this, it’s better to opt for a *safe* object creation. Nothing
    keeps you from annotating and making sure that you set all the required properties
    with the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: While type annotations are safer than type assertions, in situations like `rollDice`
    there is no better choice. In other TypeScript scenarios you do have a choice
    but might want to prefer type assertions, even if you could annotate.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the `fetch` API, for example, getting JSON data from a backend,
    we can call `fetch` and assign the results to an annotated type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`res.json()` results in `any`, and everything that is `any` can be changed
    to any other type through a type annotation. There is no guarantee that the results
    are actually `Person[]`. We can write the same line differently, by asserting
    that the result is a `Person[]`, narrowing `any` to something more specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For the type system, this is the same thing, but we can easily scan situations
    where there might be problems. What if the model in `"/api/people"` changes? It’s
    harder to spot errors if we are just looking for annotations. An assertion here
    is an indicator of an *unsafe* operation.
  prefs: []
  type: TYPE_NORMAL
- en: What really helps is to think of creating a set of models that works within
    your application boundaries. The moment you rely on something from the outside,
    like APIs, or the correct calculation of a number, type assertions can indicate
    that you’ve crossed the boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Just like using type predicates (see [Recipe 3.5](#ch03_item_type_predicates)),
    type assertions put the responsibility of a correct type in your hands. Use them
    wisely.
  prefs: []
  type: TYPE_NORMAL
- en: 3.10 Using Index Signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to work with objects where you know the type of the values, but you
    don’t know all the property names up front.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use index signatures to define an open set of keys but with defined value types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a style in web APIs where you get collections in the form of a JavaScript
    object, where the property name is roughly equivalent to a unique identifier and
    the values have the same shape. This style is great if you are mostly concerned
    about *keys*, as a simple `Object.keys` call gives you all relevant IDs, allowing
    you to quickly filter and index the values you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s think of a performance review across all your websites, where you gather
    relevant performance metrics and group them by the domain’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to find the domain with the lowest timing for a given metric, we
    can create a function where we loop over all keys, index each metrics entry, and
    compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are good programmers, we want to type our function accordingly so that
    we make sure we don’t pass any data that doesn’t match our idea of a metric collection.
    Typing the value for the metrics on the righthand side is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining a shape that has a yet-to-be-defined set of keys is trickier, but
    TypeScript has a tool for that: index signatures. We can tell TypeScript that
    we don’t know which property names there are, but we know they will be of type
    `string` and they will point to `Metrics`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s all we need to type `findLowestTiming`. We annotate `collection`
    with `Me⁠tric​Co⁠ll⁠ec⁠ti⁠on` and make sure we only pass keys of `Metrics` for
    the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This is great, but there are some caveats. TypeScript allows you to read properties
    of any string, but it does not do any checks if the property is actually available,
    so be aware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing your index signature type to be either `Metrics` or `undefined` is
    a more realistic representation. It says you can index with all possible strings,
    but there might be no value; this results in a couple more safeguards but is ultimately
    the right choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The value being either `Metrics` or `undefined` is not exactly like a missing
    property, but it’s close enough and good enough for this use case. You can read
    about the nuance between missing properties and undefined values in [Recipe 3.11](#ch03_item_missing_vs_undefined).
    To set the property keys as optional, you tell TypeScript that `domain` is not
    the entire set of `string` but a subset of `string` with a so-called *mapped type*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define index signatures for everything that is a valid property key:
    `string`, `number`, or `symbol`, and with *mapped types* also everything that
    is a subset of those. For example, you can define a type to index only valid faces
    of a die:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add properties to your type. Take this `ElementCollection`, for
    example, which allows you to index items via a number but also has additional
    properties for `get` and `filter` functions as well as a `length` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If you combine your index signatures with other properties, you need to make
    sure that the broader set of your index signature includes the types from the
    specific properties. In the previous example there is no overlap between the number
    index signature and the string keys of your other properties, but if you define
    an index signature of strings that maps to `string` and want to have a `count`
    property of type `number` next to it, TypeScript will error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And it makes sense: if all string keys point to a string, why would `count`
    point to something else? There’s ambiguity, and TypeScript won’t allow this. You
    would have to widen the type of your index signature to make sure that the smaller
    set is part of the bigger set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now `count` subsets both the type from the index signature and the type of the
    property’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Index signatures and mapped types are powerful tools that allow you to work
    with web APIs as well as data structures that allow for flexible access to elements.
    Something that we know and love from JavaScript is now securely typed in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 3.11 Distinguishing Missing Properties and Undefined Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Missing properties and undefined values are not the same! You will run into
    situations where this difference matters.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Activate `exactOptionalPropertyTypes` in *tsconfig* to enable stricter handling
    of optional properties.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our software has user settings where we can define the user’s language and
    their preferred color overrides. It’s an additional theme, which means that the
    basic colors are already set in a `"default"` style. This means that the user
    setting for `theme` is optional: either it is available or it isn’t. We use TypeScript’s
    optional properties for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'With `strictNullChecks` active, accessing `theme` somewhere in your code widens
    the number of possible values. You have not only the three theme overrides but
    also the possibility of `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This is great behavior, as you really want to make sure that this property
    is set; otherwise, it could result in runtime errors. TypeScript adding `undefined`
    to the list of possible values of optional properties is good, but it doesn’t
    entirely mirror the behavior of JavaScript. *Optional properties* means that this
    key is missing from the object, which is subtle but important. For example, a
    missing key would return `false` in property checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we get entirely different results even though the two settings objects
    seem similar. What’s worse is that an `undefined` theme is a value we don’t consider
    valid. TypeScript doesn’t lie to us, though, as it’s fully aware that an `in`
    check only tells us if the property is available. The possible return values of
    `getTheme` include `undefined` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'And there are arguably better checks to see if the correct values are here.
    With *nullish coalescing* the preceding code becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Still, `in` checks are valid and used by developers, and the way TypeScript
    interprets optional properties can cause ambiguity. Reading `undefined` from an
    optional property is correct, but setting optional properties to `undefined` isn’t.
    By switching on `exactOptionalPropertyTypes`, TypeScript changes this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '`exactOptionalPropertyTypes` aligns TypeScript’s behavior even more to JavaScript.
    This flag is not within `strict` mode, however, so you need to set it yourself
    if you encounter problems like this.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.12 Working with Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript enums are a nice abstraction, but they seem to behave very differently
    compared to the rest of the type system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use them sparingly, prefer `const` enums, know their caveats, and maybe choose
    union types instead.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enums in TypeScript allow a developer to define a set of named constants, which
    makes it easier to document intent or create a set of distinct cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'They’re defined using the `enum` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Like classes, they contribute to the value and type namespaces, which means
    you can use `Direction` when annotating types or in your JavaScript code as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'They are a syntactic extension to JavaScript, which means they not only work
    on a type system level but also emit JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'When you define your enum as a `const enum`, TypeScript tries to substitute
    the usage with the actual values, getting rid of the emitted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript supports both string and numeric enums, and both variants behave
    very differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript enums are by default numeric, which means that every variant of
    that enum has a numeric value assigned, starting at 0\. The starting point and
    actual values of enum variants can be a default or user defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In a way, numeric enums define the same set as a union type of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'But there are significant differences. Where a union type of numbers allows
    only a strictly defined set of values, a numeric enum allows for every value to
    be assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that there is a use case of implementing flags with numeric enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Enums provide syntactic sugar for this scenario. To make it easier for the compiler
    to see which values are allowed, TypeScript expands compatible values for numeric
    enums to the entire set of `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enum variants can also be initialized with strings instead of numbers, effectively
    creating a string enum. If you choose to write a string enum, you have to define
    each variant, as strings can’t be incremented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'String enums are more restrictive than numeric enums. They only allow you to
    pass actual variants of the enum rather than the entire set of strings. However,
    they don’t allow you to pass the string equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike every other type in TypeScript, string enums are *nominal* types. This
    also means two enums with the same set of values are not compatible with each
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This can be a source of confusion and frustration, especially when values come
    from another source that doesn’t have knowledge of your enums but does have the
    correct string values.
  prefs: []
  type: TYPE_NORMAL
- en: Use enums wisely and know their caveats. Enums are great for feature flags and
    a set of named constants where you intentionally want people to use the data structure
    instead of just values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since TypeScript 5.0, the interpretation of number enums has become much stricter;
    now they behave, like string enums, as nominal types and don’t include the entire
    set of numbers as values. You still might find codebases that rely on the unique
    features of pre-5.0 number enums, so be aware!
  prefs: []
  type: TYPE_NORMAL
- en: Also try to prefer `const` enums wherever possible, as non-`const` enums can
    add size to your codebase that might be redundant. I have seen projects with more
    than two thousand flags in a non-`const` enum, resulting in huge tooling overhead,
    compile time overhead, and subsequently, runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, don’t use them at all. A simple union type works similarly and is much
    more aligned with the rest of the type system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You get all the benefits from enums such as proper tooling and type safety without
    going the extra round and risking outputting code that you don’t want. It also
    becomes clearer what you need to pass and where to get the value from.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to write your code enum-style, with an object and a named identifier,
    a `const` object with a `Values` helper type might just give you the desired behavior
    and is *much* closer to JavaScript. The same technique is also applicable to string
    unions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This line is particularly interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things happen that are not that usual:'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a type with the same name as a value. This is possible because TypeScript
    has distinct value and type namespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `typeof` operator, we grab the type from `Direction`. As `Direction`
    is in *const context*, we get the literal type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We index the type of `Direction` with its own keys, leaving us all the values
    on the righthand side of the object: `0`, `1`, `2`, and `3`. In short: a union
    type of numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using union types leaves no surprises:'
  prefs: []
  type: TYPE_NORMAL
- en: You *know* what code you end up with within the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don’t end up with changed behavior because somebody decides to go from a
    string enum to a numeric enum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have type safety where you need it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You give your colleagues and users the same conveniences as provided by enums.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But to be fair, a simple string union type does just what you need: type safety,
    autocomplete, and predictable behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.13 Defining Nominal Types in a Structural Type System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your application has several types that are aliases for the same primitive type
    but with entirely different semantics. Structural typing treats them the same,
    but it shouldn’t!
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use wrapping classes or create an intersection of your primitive type with a
    literal object type and use this to differentiate two integers.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript’s type system is structural. This means that if two types have a
    similar shape, values of this type are compatible with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript relies heavily on object literals, and TypeScript tries to infer
    the type or *shape* of those literals. A structural type system makes a lot of
    sense in this scenario, as values can come from anywhere and need to be compatible
    with interface and type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are situations where you need to be more definitive with your
    types. For object types, we learned about techniques like *discriminated unions*
    with the `kind` property in [Recipe 3.2](#ch03_item_discriminated_unions), or
    *exclusive or* with “optional `never`" in [Recipe 3.8](#ch03_item_optional_never).
    `string` enums are also nominal, as we see in [Recipe 3.12](#ch03_item_enums).
  prefs: []
  type: TYPE_NORMAL
- en: Those measurements are good enough for object types and enums, but they don’t
    solve the problem if you have two independent types that use the same set of values
    as primitive types. What if your eight-digit account number and your balance all
    point to the `number` type and you mix them up? Getting an eight-figure number
    on your balance sheet is a nice surprise, but it’s likely not correct.
  prefs: []
  type: TYPE_NORMAL
- en: Or perhaps you need to validate user input strings and want to make sure that
    you carry around only the validated user input in your program, not falling back
    to the original, probably unsafe, string.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript allows you to mimic nominal types within the type system to get more
    security. The trick is also to separate the sets of possible values with distinct
    properties just enough to ensure the same values don’t fall into the same set.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to achieve this would be wrapping classes. Instead of working with
    the values directly, we wrap each value in a class. With a `private kind` property
    we make sure they don’t overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: What’s interesting here is that since we use `private` properties, TypeScript
    will differentiate between the two classes. Right now, both `kind` properties
    are of type `string`. Even though they feature a different value, they can be
    changed internally. But classes work differently. If `private` or `protected`
    members are present, TypeScript considers two types compatible if they originate
    from the same declaration. Otherwise, they aren’t considered compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to refine this pattern with a more general approach. Instead
    of defining a `kind` member and setting it to a value, we define a `_nominal`
    member in each class declaration that is of type `void`. This separates both classes
    just enough but keeps us from using `_nominal` in just any way. `void` only allows
    us to set `_nominal` to `undefined`, and `undefined` is a falsy, and thus highly
    useless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We can now differentiate between two types that would have the same set of values.
    The only downside to this approach is that we wrap the original type, which means
    that every time we want to work with the original value, we need to unwrap it.
  prefs: []
  type: TYPE_NORMAL
- en: A different way to mimic nominal types is to intersect the primitive type with
    a branded object type with a `kind` property. This way, we retain all the operations
    from the original type, but we need to require type assertions to tell TypeScript
    that we want to use those types differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned in [Recipe 3.9](#ch03_item_assertions), we can safely assert
    another type if it is a subtype or supertype of the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Also note that the addition of `balance` and `amount` still works as originally
    intended but produces a number again. This is why we need to add another assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Both approaches have their advantages and disadvantages, and whether you prefer
    one or the other mostly depends on your scenario. Both approaches are workarounds
    and techniques developed by the community based on their understanding of the
    type system’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are discussions on the [TypeScript issue tracker on GitHub](https://oreil.ly/XxmUV)
    about opening the type system for nomimal types, and the possibility is constantly
    under investigation. One idea is to use the `unique` keyword from Symbols to differentiate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: As time of writing, this idea—and many others—remains a future possibility.
  prefs: []
  type: TYPE_NORMAL
- en: 3.14 Enabling Loose Autocomplete for String Subsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your API allows for any string to be passed, but you still want to show a couple
    of string values for autocomplete.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add `string & {}` to your union type of string literals.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say you define an API for access to a content management system. There
    are predefined content types like `post`, `page`, and `asset`, but developers
    can define their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'You create a `retrieve` function with a single parameter, the content type,
    that allows entries to be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This works well enough, but you want to give your users a hint on the default
    options for content type. A possibility is to create a helper type that lists
    all predefined content types as string literals in a union with `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This describes your situation very well but comes with a downside: `post`,
    `page`, and `asset` are subtypes of `string`, so putting them in a union *with*
    `string` effectively swallows the detailed information into the broader set.'
  prefs: []
  type: TYPE_NORMAL
- en: This means you don’t get statement completion hints via your editor, as you
    can see in [Figure 3-3](#img-no-complete).
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0303](assets/tscb_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. TypeScript widens `ContentType` to the entire set of `string`,
    thus swallowing autocomplete information
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To retain autocomplete information and preserve the literal types, we need
    to intersect `string` with the empty object type `{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The effect of this change is more subtle. It doesn’t alter the number of compatible
    values to `ContentType`, but it will set TypeScript into a mode that prevents
    subtype reduction and preserves the literal types.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the effect in [Figure 3-4](#img-yes-complete), where `ContentType`
    is not reduced to `string`, and therefore all literal values are available for
    statement completion in the text editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0304](assets/tscb_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Intersecting `string` with the empty object retains statement completion
    hints
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Still, every string is a valid `ContentType`; it just changes the developer
    experience of your API and gives hints where needed.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is used by popular libraries like [CSSType](https://oreil.ly/lwtC5)
    or the [Definitely Typed type definitions for React](https://oreil.ly/epbLV).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.html#id559-marker)) For example, the Rust Programming Language has
    been lauded for its error handling.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.html#id571-marker)) Shout-out to Dan Vanderkam who was first to call
    this technique “optional never” on his fantastic [*Effective TypeScript* blog](https://effectivetypescript.com).
  prefs: []
  type: TYPE_NORMAL
